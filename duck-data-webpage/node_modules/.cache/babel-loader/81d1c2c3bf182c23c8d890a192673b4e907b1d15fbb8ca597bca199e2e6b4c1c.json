{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { assert } from '@loaders.gl/loader-utils';\nimport { ImageLoader, getImageSize } from '@loaders.gl/images';\nimport { generateUrl } from \"./generate-url.js\";\nimport { deepLoad, shallowLoad } from \"./deep-load.js\";\nexport async function loadImageTexture(getUrl, options = {}) {\n  const imageUrls = await getImageUrls(getUrl, options);\n  return await deepLoad(imageUrls, ImageLoader.parse, options);\n}\nexport async function getImageUrls(getUrl, options, urlOptions = {}) {\n  const mipLevels = options && options.image && options.image.mipLevels || 0;\n  return mipLevels !== 0 ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) : generateUrl(getUrl, options, urlOptions);\n}\nasync function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {\n  const urls = [];\n  // If no mip levels supplied, we need to load the level 0 image and calculate based on size\n  if (mipLevels === 'auto') {\n    const url = generateUrl(getUrl, options, {\n      ...urlOptions,\n      lod: 0\n    });\n    const image = await shallowLoad(url, ImageLoader.parse, options);\n    const {\n      width,\n      height\n    } = getImageSize(image);\n    mipLevels = getMipLevels({\n      width,\n      height\n    });\n    // TODO - push image and make `deepLoad` pass through non-url values, avoid loading twice?\n    urls.push(url);\n  }\n  // We now know how many mipLevels we need, remaining image urls can now be constructed\n  assert(mipLevels > 0);\n  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {\n    const url = generateUrl(getUrl, options, {\n      ...urlOptions,\n      lod: mipLevel\n    });\n    urls.push(url);\n  }\n  return urls;\n}\n// Calculates number of mipmaps based on texture size (log2)\nexport function getMipLevels(size) {\n  return 1 + Math.floor(Math.log2(Math.max(size.width, size.height)));\n}","map":{"version":3,"names":["assert","ImageLoader","getImageSize","generateUrl","deepLoad","shallowLoad","loadImageTexture","getUrl","options","imageUrls","getImageUrls","parse","urlOptions","mipLevels","image","getMipmappedImageUrls","urls","url","lod","width","height","getMipLevels","push","mipLevel","length","size","Math","floor","log2","max"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/textures/dist/lib/texture-api/load-image.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { assert } from '@loaders.gl/loader-utils';\nimport { ImageLoader, getImageSize } from '@loaders.gl/images';\nimport { generateUrl } from \"./generate-url.js\";\nimport { deepLoad, shallowLoad } from \"./deep-load.js\";\nexport async function loadImageTexture(getUrl, options = {}) {\n    const imageUrls = await getImageUrls(getUrl, options);\n    return await deepLoad(imageUrls, ImageLoader.parse, options);\n}\nexport async function getImageUrls(getUrl, options, urlOptions = {}) {\n    const mipLevels = (options && options.image && options.image.mipLevels) || 0;\n    return mipLevels !== 0\n        ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions)\n        : generateUrl(getUrl, options, urlOptions);\n}\nasync function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {\n    const urls = [];\n    // If no mip levels supplied, we need to load the level 0 image and calculate based on size\n    if (mipLevels === 'auto') {\n        const url = generateUrl(getUrl, options, { ...urlOptions, lod: 0 });\n        const image = await shallowLoad(url, ImageLoader.parse, options);\n        const { width, height } = getImageSize(image);\n        mipLevels = getMipLevels({ width, height });\n        // TODO - push image and make `deepLoad` pass through non-url values, avoid loading twice?\n        urls.push(url);\n    }\n    // We now know how many mipLevels we need, remaining image urls can now be constructed\n    assert(mipLevels > 0);\n    for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {\n        const url = generateUrl(getUrl, options, { ...urlOptions, lod: mipLevel });\n        urls.push(url);\n    }\n    return urls;\n}\n// Calculates number of mipmaps based on texture size (log2)\nexport function getMipLevels(size) {\n    return 1 + Math.floor(Math.log2(Math.max(size.width, size.height)));\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,MAAM,QAAQ,0BAA0B;AACjD,SAASC,WAAW,EAAEC,YAAY,QAAQ,oBAAoB;AAC9D,SAASC,WAAW,QAAQ,mBAAmB;AAC/C,SAASC,QAAQ,EAAEC,WAAW,QAAQ,gBAAgB;AACtD,OAAO,eAAeC,gBAAgBA,CAACC,MAAM,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EACzD,MAAMC,SAAS,GAAG,MAAMC,YAAY,CAACH,MAAM,EAAEC,OAAO,CAAC;EACrD,OAAO,MAAMJ,QAAQ,CAACK,SAAS,EAAER,WAAW,CAACU,KAAK,EAAEH,OAAO,CAAC;AAChE;AACA,OAAO,eAAeE,YAAYA,CAACH,MAAM,EAAEC,OAAO,EAAEI,UAAU,GAAG,CAAC,CAAC,EAAE;EACjE,MAAMC,SAAS,GAAIL,OAAO,IAAIA,OAAO,CAACM,KAAK,IAAIN,OAAO,CAACM,KAAK,CAACD,SAAS,IAAK,CAAC;EAC5E,OAAOA,SAAS,KAAK,CAAC,GAChB,MAAME,qBAAqB,CAACR,MAAM,EAAEM,SAAS,EAAEL,OAAO,EAAEI,UAAU,CAAC,GACnET,WAAW,CAACI,MAAM,EAAEC,OAAO,EAAEI,UAAU,CAAC;AAClD;AACA,eAAeG,qBAAqBA,CAACR,MAAM,EAAEM,SAAS,EAAEL,OAAO,EAAEI,UAAU,EAAE;EACzE,MAAMI,IAAI,GAAG,EAAE;EACf;EACA,IAAIH,SAAS,KAAK,MAAM,EAAE;IACtB,MAAMI,GAAG,GAAGd,WAAW,CAACI,MAAM,EAAEC,OAAO,EAAE;MAAE,GAAGI,UAAU;MAAEM,GAAG,EAAE;IAAE,CAAC,CAAC;IACnE,MAAMJ,KAAK,GAAG,MAAMT,WAAW,CAACY,GAAG,EAAEhB,WAAW,CAACU,KAAK,EAAEH,OAAO,CAAC;IAChE,MAAM;MAAEW,KAAK;MAAEC;IAAO,CAAC,GAAGlB,YAAY,CAACY,KAAK,CAAC;IAC7CD,SAAS,GAAGQ,YAAY,CAAC;MAAEF,KAAK;MAAEC;IAAO,CAAC,CAAC;IAC3C;IACAJ,IAAI,CAACM,IAAI,CAACL,GAAG,CAAC;EAClB;EACA;EACAjB,MAAM,CAACa,SAAS,GAAG,CAAC,CAAC;EACrB,KAAK,IAAIU,QAAQ,GAAGP,IAAI,CAACQ,MAAM,EAAED,QAAQ,GAAGV,SAAS,EAAE,EAAEU,QAAQ,EAAE;IAC/D,MAAMN,GAAG,GAAGd,WAAW,CAACI,MAAM,EAAEC,OAAO,EAAE;MAAE,GAAGI,UAAU;MAAEM,GAAG,EAAEK;IAAS,CAAC,CAAC;IAC1EP,IAAI,CAACM,IAAI,CAACL,GAAG,CAAC;EAClB;EACA,OAAOD,IAAI;AACf;AACA;AACA,OAAO,SAASK,YAAYA,CAACI,IAAI,EAAE;EAC/B,OAAO,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,IAAI,CAACF,IAAI,CAACG,GAAG,CAACJ,IAAI,CAACN,KAAK,EAAEM,IAAI,CAACL,MAAM,CAAC,CAAC,CAAC;AACvE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}