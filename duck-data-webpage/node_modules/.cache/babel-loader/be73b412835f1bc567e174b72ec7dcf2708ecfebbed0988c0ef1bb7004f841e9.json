{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { PROP_TYPES_SYMBOL } from \"./constants.js\";\nexport function validateProps(props) {\n  const propTypes = props[PROP_TYPES_SYMBOL];\n  for (const propName in propTypes) {\n    const propType = propTypes[propName];\n    const {\n      validate\n    } = propType;\n    if (validate && !validate(props[propName], propType)) {\n      throw new Error(`Invalid prop ${propName}: ${props[propName]}`);\n    }\n  }\n}\n// Returns an object with \"change flags\", either false or strings indicating reason for change\nexport function diffProps(props, oldProps) {\n  // First check if any props have changed (ignore props that will be examined separately)\n  const propsChangedReason = compareProps({\n    newProps: props,\n    oldProps,\n    propTypes: props[PROP_TYPES_SYMBOL],\n    ignoreProps: {\n      data: null,\n      updateTriggers: null,\n      extensions: null,\n      transitions: null\n    }\n  });\n  // Now check if any data related props have changed\n  const dataChangedReason = diffDataProps(props, oldProps);\n  // Check update triggers to determine if any attributes need regeneration\n  // Note - if data has changed, all attributes will need regeneration, so skip this step\n  let updateTriggersChangedReason = false;\n  if (!dataChangedReason) {\n    updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);\n  }\n  return {\n    dataChanged: dataChangedReason,\n    propsChanged: propsChangedReason,\n    updateTriggersChanged: updateTriggersChangedReason,\n    extensionsChanged: diffExtensions(props, oldProps),\n    transitionsChanged: diffTransitions(props, oldProps)\n  };\n}\nfunction diffTransitions(props, oldProps) {\n  if (!props.transitions) {\n    return false;\n  }\n  const result = {};\n  const propTypes = props[PROP_TYPES_SYMBOL];\n  let changed = false;\n  for (const key in props.transitions) {\n    const propType = propTypes[key];\n    const type = propType && propType.type;\n    const isTransitionable = type === 'number' || type === 'color' || type === 'array';\n    if (isTransitionable && comparePropValues(props[key], oldProps[key], propType)) {\n      result[key] = true;\n      changed = true;\n    }\n  }\n  return changed ? result : false;\n}\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * @param {Object} opt.oldProps - object with old key/value pairs\n * @param {Object} opt.newProps - object with new key/value pairs\n * @param {Object} opt.ignoreProps={} - object, keys that should not be compared\n * @returns {null|String} - null when values of all keys are strictly equal.\n *   if unequal, returns a string explaining what changed.\n */\n/* eslint-disable max-statements, max-depth, complexity */\n/*\n * Note: for better performance, this function assumes that both oldProps and newProps\n   inherit the same prototype (defaultProps). That is, if neither object contains own\n   property <key>, assume `oldProps.<key>` and `newProps.<key>` are equal.\n */\nexport function compareProps({\n  newProps,\n  oldProps,\n  ignoreProps = {},\n  propTypes = {},\n  triggerName = 'props'\n}) {\n  // shallow equality => deep equality\n  if (oldProps === newProps) {\n    return false;\n  }\n  // TODO - do we need these checks? Should never happen...\n  if (typeof newProps !== 'object' || newProps === null) {\n    return `${triggerName} changed shallowly`;\n  }\n  if (typeof oldProps !== 'object' || oldProps === null) {\n    return `${triggerName} changed shallowly`;\n  }\n  // Compare explicitly defined new props against old/default values\n  for (const key of Object.keys(newProps)) {\n    if (!(key in ignoreProps)) {\n      if (!(key in oldProps)) {\n        return `${triggerName}.${key} added`;\n      }\n      const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);\n      if (changed) {\n        return `${triggerName}.${key} ${changed}`;\n      }\n    }\n  }\n  // Test if any old props have been dropped\n  for (const key of Object.keys(oldProps)) {\n    if (!(key in ignoreProps)) {\n      if (!(key in newProps)) {\n        return `${triggerName}.${key} dropped`;\n      }\n      if (!Object.hasOwnProperty.call(newProps, key)) {\n        // Compare dropped old prop against default value\n        const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);\n        if (changed) {\n          return `${triggerName}.${key} ${changed}`;\n        }\n      }\n    }\n  }\n  return false;\n}\n/* eslint-enable max-statements, max-depth, complexity */\n// HELPERS\nfunction comparePropValues(newProp, oldProp, propType) {\n  // If prop type has an equal function, invoke it\n  let equal = propType && propType.equal;\n  if (equal && !equal(newProp, oldProp, propType)) {\n    return 'changed deeply';\n  }\n  if (!equal) {\n    // If object has an equals function, invoke it\n    equal = newProp && oldProp && newProp.equals;\n    if (equal && !equal.call(newProp, oldProp)) {\n      return 'changed deeply';\n    }\n  }\n  if (!equal && oldProp !== newProp) {\n    return 'changed shallowly';\n  }\n  return null;\n}\n// The comparison of the data prop requires special handling\n// the dataComparator should be used if supplied\nfunction diffDataProps(props, oldProps) {\n  if (oldProps === null) {\n    return 'oldProps is null, initial diff';\n  }\n  let dataChanged = false;\n  // Support optional app defined comparison of data\n  const {\n    dataComparator,\n    _dataDiff\n  } = props;\n  if (dataComparator) {\n    if (!dataComparator(props.data, oldProps.data)) {\n      dataChanged = 'Data comparator detected a change';\n    }\n    // Otherwise, do a shallow equal on props\n  } else if (props.data !== oldProps.data) {\n    dataChanged = 'A new data container was supplied';\n  }\n  if (dataChanged && _dataDiff) {\n    dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;\n  }\n  return dataChanged;\n}\n// Checks if any update triggers have changed\n// also calls callback to invalidate attributes accordingly.\nfunction diffUpdateTriggers(props, oldProps) {\n  if (oldProps === null) {\n    return {\n      all: true\n    };\n  }\n  // If the 'all' updateTrigger fires, ignore testing others\n  if ('all' in props.updateTriggers) {\n    const diffReason = diffUpdateTrigger(props, oldProps, 'all');\n    if (diffReason) {\n      return {\n        all: true\n      };\n    }\n  }\n  const reason = {};\n  let changed = false;\n  // If the 'all' updateTrigger didn't fire, need to check all others\n  for (const triggerName in props.updateTriggers) {\n    if (triggerName !== 'all') {\n      const diffReason = diffUpdateTrigger(props, oldProps, triggerName);\n      if (diffReason) {\n        reason[triggerName] = true;\n        changed = true;\n      }\n    }\n  }\n  return changed ? reason : false;\n}\n// Returns true if any extensions have changed\nfunction diffExtensions(props, oldProps) {\n  if (oldProps === null) {\n    return true;\n  }\n  const oldExtensions = oldProps.extensions;\n  const {\n    extensions\n  } = props;\n  if (extensions === oldExtensions) {\n    return false;\n  }\n  if (!oldExtensions || !extensions) {\n    return true;\n  }\n  if (extensions.length !== oldExtensions.length) {\n    return true;\n  }\n  for (let i = 0; i < extensions.length; i++) {\n    if (!extensions[i].equals(oldExtensions[i])) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction diffUpdateTrigger(props, oldProps, triggerName) {\n  let newTriggers = props.updateTriggers[triggerName];\n  newTriggers = newTriggers === undefined || newTriggers === null ? {} : newTriggers;\n  let oldTriggers = oldProps.updateTriggers[triggerName];\n  oldTriggers = oldTriggers === undefined || oldTriggers === null ? {} : oldTriggers;\n  const diffReason = compareProps({\n    oldProps: oldTriggers,\n    newProps: newTriggers,\n    triggerName\n  });\n  return diffReason;\n}","map":{"version":3,"names":["PROP_TYPES_SYMBOL","validateProps","props","propTypes","propName","propType","validate","Error","diffProps","oldProps","propsChangedReason","compareProps","newProps","ignoreProps","data","updateTriggers","extensions","transitions","dataChangedReason","diffDataProps","updateTriggersChangedReason","diffUpdateTriggers","dataChanged","propsChanged","updateTriggersChanged","extensionsChanged","diffExtensions","transitionsChanged","diffTransitions","result","changed","key","type","isTransitionable","comparePropValues","triggerName","Object","keys","hasOwnProperty","call","newProp","oldProp","equal","equals","dataComparator","_dataDiff","all","diffReason","diffUpdateTrigger","reason","oldExtensions","length","i","newTriggers","undefined","oldTriggers"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\lifecycle\\props.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {PROP_TYPES_SYMBOL} from './constants';\n\nexport function validateProps(props) {\n  const propTypes = props[PROP_TYPES_SYMBOL];\n\n  for (const propName in propTypes) {\n    const propType = propTypes[propName];\n    const {validate} = propType;\n    if (validate && !validate(props[propName], propType)) {\n      throw new Error(`Invalid prop ${propName}: ${props[propName]}`);\n    }\n  }\n}\n\n// Returns an object with \"change flags\", either false or strings indicating reason for change\nexport function diffProps(\n  props,\n  oldProps\n): {\n  dataChanged: string | false | {startRow: number; endRow?: number}[];\n  propsChanged: string | false;\n  updateTriggersChanged: Record<string, true> | false;\n  extensionsChanged: boolean;\n  transitionsChanged: Record<string, true> | false;\n} {\n  // First check if any props have changed (ignore props that will be examined separately)\n  const propsChangedReason = compareProps({\n    newProps: props,\n    oldProps,\n    propTypes: props[PROP_TYPES_SYMBOL],\n    ignoreProps: {data: null, updateTriggers: null, extensions: null, transitions: null}\n  });\n\n  // Now check if any data related props have changed\n  const dataChangedReason = diffDataProps(props, oldProps);\n\n  // Check update triggers to determine if any attributes need regeneration\n  // Note - if data has changed, all attributes will need regeneration, so skip this step\n  let updateTriggersChangedReason: false | string | Record<string, true> = false;\n  if (!dataChangedReason) {\n    updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);\n  }\n\n  return {\n    dataChanged: dataChangedReason,\n    propsChanged: propsChangedReason,\n    updateTriggersChanged: updateTriggersChangedReason,\n    extensionsChanged: diffExtensions(props, oldProps),\n    transitionsChanged: diffTransitions(props, oldProps)\n  };\n}\n\nfunction diffTransitions(props, oldProps): false | Record<string, true> {\n  if (!props.transitions) {\n    return false;\n  }\n  const result: Record<string, true> = {};\n  const propTypes = props[PROP_TYPES_SYMBOL];\n  let changed = false;\n\n  for (const key in props.transitions) {\n    const propType = propTypes[key];\n    const type = propType && propType.type;\n    const isTransitionable = type === 'number' || type === 'color' || type === 'array';\n    if (isTransitionable && comparePropValues(props[key], oldProps[key], propType)) {\n      result[key] = true;\n      changed = true;\n    }\n  }\n  return changed ? result : false;\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * @param {Object} opt.oldProps - object with old key/value pairs\n * @param {Object} opt.newProps - object with new key/value pairs\n * @param {Object} opt.ignoreProps={} - object, keys that should not be compared\n * @returns {null|String} - null when values of all keys are strictly equal.\n *   if unequal, returns a string explaining what changed.\n */\n/* eslint-disable max-statements, max-depth, complexity */\n/*\n * Note: for better performance, this function assumes that both oldProps and newProps\n   inherit the same prototype (defaultProps). That is, if neither object contains own\n   property <key>, assume `oldProps.<key>` and `newProps.<key>` are equal.\n */\nexport function compareProps({\n  newProps,\n  oldProps,\n  ignoreProps = {},\n  propTypes = {},\n  triggerName = 'props'\n}): string | false {\n  // shallow equality => deep equality\n  if (oldProps === newProps) {\n    return false;\n  }\n\n  // TODO - do we need these checks? Should never happen...\n  if (typeof newProps !== 'object' || newProps === null) {\n    return `${triggerName} changed shallowly`;\n  }\n\n  if (typeof oldProps !== 'object' || oldProps === null) {\n    return `${triggerName} changed shallowly`;\n  }\n\n  // Compare explicitly defined new props against old/default values\n  for (const key of Object.keys(newProps)) {\n    if (!(key in ignoreProps)) {\n      if (!(key in oldProps)) {\n        return `${triggerName}.${key} added`;\n      }\n      const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);\n      if (changed) {\n        return `${triggerName}.${key} ${changed}`;\n      }\n    }\n  }\n\n  // Test if any old props have been dropped\n  for (const key of Object.keys(oldProps)) {\n    if (!(key in ignoreProps)) {\n      if (!(key in newProps)) {\n        return `${triggerName}.${key} dropped`;\n      }\n      if (!Object.hasOwnProperty.call(newProps, key)) {\n        // Compare dropped old prop against default value\n        const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);\n        if (changed) {\n          return `${triggerName}.${key} ${changed}`;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n/* eslint-enable max-statements, max-depth, complexity */\n\n// HELPERS\nfunction comparePropValues(newProp, oldProp, propType) {\n  // If prop type has an equal function, invoke it\n  let equal = propType && propType.equal;\n  if (equal && !equal(newProp, oldProp, propType)) {\n    return 'changed deeply';\n  }\n\n  if (!equal) {\n    // If object has an equals function, invoke it\n    equal = newProp && oldProp && newProp.equals;\n    if (equal && !equal.call(newProp, oldProp)) {\n      return 'changed deeply';\n    }\n  }\n\n  if (!equal && oldProp !== newProp) {\n    return 'changed shallowly';\n  }\n\n  return null;\n}\n\n// The comparison of the data prop requires special handling\n// the dataComparator should be used if supplied\nfunction diffDataProps(props, oldProps): string | false | {startRow: number; endRow?: number}[] {\n  if (oldProps === null) {\n    return 'oldProps is null, initial diff';\n  }\n\n  let dataChanged: string | false | {startRow: number; endRow?: number}[] = false;\n  // Support optional app defined comparison of data\n  const {dataComparator, _dataDiff} = props;\n  if (dataComparator) {\n    if (!dataComparator(props.data, oldProps.data)) {\n      dataChanged = 'Data comparator detected a change';\n    }\n    // Otherwise, do a shallow equal on props\n  } else if (props.data !== oldProps.data) {\n    dataChanged = 'A new data container was supplied';\n  }\n  if (dataChanged && _dataDiff) {\n    dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;\n  }\n\n  return dataChanged;\n}\n\n// Checks if any update triggers have changed\n// also calls callback to invalidate attributes accordingly.\nfunction diffUpdateTriggers(props, oldProps): Record<string, true> | false {\n  if (oldProps === null) {\n    return {all: true};\n  }\n\n  // If the 'all' updateTrigger fires, ignore testing others\n  if ('all' in props.updateTriggers) {\n    const diffReason = diffUpdateTrigger(props, oldProps, 'all');\n    if (diffReason) {\n      return {all: true};\n    }\n  }\n\n  const reason: Record<string, true> = {};\n  let changed = false;\n  // If the 'all' updateTrigger didn't fire, need to check all others\n  for (const triggerName in props.updateTriggers) {\n    if (triggerName !== 'all') {\n      const diffReason = diffUpdateTrigger(props, oldProps, triggerName);\n      if (diffReason) {\n        reason[triggerName] = true;\n        changed = true;\n      }\n    }\n  }\n\n  return changed ? reason : false;\n}\n\n// Returns true if any extensions have changed\nfunction diffExtensions(props, oldProps): boolean {\n  if (oldProps === null) {\n    return true;\n  }\n\n  const oldExtensions = oldProps.extensions;\n  const {extensions} = props;\n\n  if (extensions === oldExtensions) {\n    return false;\n  }\n  if (!oldExtensions || !extensions) {\n    return true;\n  }\n  if (extensions.length !== oldExtensions.length) {\n    return true;\n  }\n  for (let i = 0; i < extensions.length; i++) {\n    if (!extensions[i].equals(oldExtensions[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction diffUpdateTrigger(props, oldProps, triggerName) {\n  let newTriggers = props.updateTriggers[triggerName];\n  newTriggers = newTriggers === undefined || newTriggers === null ? {} : newTriggers;\n  let oldTriggers = oldProps.updateTriggers[triggerName];\n  oldTriggers = oldTriggers === undefined || oldTriggers === null ? {} : oldTriggers;\n  const diffReason = compareProps({\n    oldProps: oldTriggers,\n    newProps: newTriggers,\n    triggerName\n  });\n  return diffReason;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}