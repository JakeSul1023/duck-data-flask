{"ast":null,"code":"// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Input } from \"./input.js\";\nconst MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'mouseover', 'mouseout', 'mouseleave'];\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\nexport class MoveInput extends Input {\n  constructor(element, callback, options) {\n    super(element, callback, {\n      enable: true,\n      ...options\n    });\n    this.handleEvent = event => {\n      this.handleOverEvent(event);\n      this.handleOutEvent(event);\n      this.handleEnterEvent(event);\n      this.handleLeaveEvent(event);\n      this.handleMoveEvent(event);\n    };\n    this.pressed = false;\n    const {\n      enable\n    } = this.options;\n    this.enableMoveEvent = enable;\n    this.enableLeaveEvent = enable;\n    this.enableEnterEvent = enable;\n    this.enableOutEvent = enable;\n    this.enableOverEvent = enable;\n    MOUSE_EVENTS.forEach(event => element.addEventListener(event, this.handleEvent));\n  }\n  destroy() {\n    MOUSE_EVENTS.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n  }\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType, enabled) {\n    switch (eventType) {\n      case 'pointermove':\n        this.enableMoveEvent = enabled;\n        break;\n      case 'pointerover':\n        this.enableOverEvent = enabled;\n        break;\n      case 'pointerout':\n        this.enableOutEvent = enabled;\n        break;\n      case 'pointerenter':\n        this.enableEnterEvent = enabled;\n        break;\n      case 'pointerleave':\n        this.enableLeaveEvent = enabled;\n        break;\n      default:\n      // ignore\n    }\n  }\n  handleOverEvent(event) {\n    if (this.enableOverEvent && event.type === 'mouseover') {\n      this._emit('pointerover', event);\n    }\n  }\n  handleOutEvent(event) {\n    if (this.enableOutEvent && event.type === 'mouseout') {\n      this._emit('pointerout', event);\n    }\n  }\n  handleEnterEvent(event) {\n    if (this.enableEnterEvent && event.type === 'mouseenter') {\n      this._emit('pointerenter', event);\n    }\n  }\n  handleLeaveEvent(event) {\n    if (this.enableLeaveEvent && event.type === 'mouseleave') {\n      this._emit('pointerleave', event);\n    }\n  }\n  handleMoveEvent(event) {\n    if (this.enableMoveEvent) {\n      switch (event.type) {\n        case 'mousedown':\n          if (event.button >= 0) {\n            // Button is down\n            this.pressed = true;\n          }\n          break;\n        case 'mousemove':\n          // Move events use `bottons` to track the button being pressed\n          if (event.buttons === 0) {\n            // Button is not down\n            this.pressed = false;\n          }\n          if (!this.pressed) {\n            // Drag events are emitted by hammer already\n            // we just need to emit the move event on hover\n            this._emit('pointermove', event);\n          }\n          break;\n        case 'mouseup':\n          this.pressed = false;\n          break;\n        default:\n      }\n    }\n  }\n  _emit(type, event) {\n    this.callback({\n      type,\n      center: {\n        x: event.clientX,\n        y: event.clientY\n      },\n      srcEvent: event,\n      pointerType: 'mouse',\n      target: event.target\n    });\n  }\n}","map":{"version":3,"names":["Input","MOUSE_EVENTS","MoveInput","constructor","element","callback","options","enable","handleEvent","event","handleOverEvent","handleOutEvent","handleEnterEvent","handleLeaveEvent","handleMoveEvent","pressed","enableMoveEvent","enableLeaveEvent","enableEnterEvent","enableOutEvent","enableOverEvent","forEach","addEventListener","destroy","removeEventListener","enableEventType","eventType","enabled","type","_emit","button","buttons","center","x","clientX","y","clientY","srcEvent","pointerType","target"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\mjolnir.js\\src\\inputs\\move-input.ts"],"sourcesContent":["// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {MjolnirPointerEventRaw} from '../types';\nimport {Input, InputOptions} from './input';\n\nconst MOUSE_EVENTS = [\n  'mousedown',\n  'mousemove',\n  'mouseup',\n  'mouseover',\n  'mouseout',\n  'mouseleave'\n] as const;\n\ntype MoveEventType = 'pointermove' | 'pointerover' | 'pointerout' | 'pointerenter' | 'pointerleave';\n\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\nexport class MoveInput extends Input<MjolnirPointerEventRaw, Required<InputOptions>> {\n  pressed: boolean;\n  enableMoveEvent: boolean;\n  enableEnterEvent: boolean;\n  enableLeaveEvent: boolean;\n  enableOutEvent: boolean;\n  enableOverEvent: boolean;\n\n  constructor(\n    element: HTMLElement,\n    callback: (event: MjolnirPointerEventRaw) => void,\n    options: InputOptions\n  ) {\n    super(element, callback, {enable: true, ...options});\n\n    this.pressed = false;\n    const {enable} = this.options;\n\n    this.enableMoveEvent = enable;\n    this.enableLeaveEvent = enable;\n    this.enableEnterEvent = enable;\n    this.enableOutEvent = enable;\n    this.enableOverEvent = enable;\n\n    MOUSE_EVENTS.forEach((event) => element.addEventListener(event, this.handleEvent));\n  }\n\n  destroy() {\n    MOUSE_EVENTS.forEach((event) => this.element.removeEventListener(event, this.handleEvent));\n  }\n\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType: string, enabled: boolean) {\n    switch (eventType) {\n      case 'pointermove':\n        this.enableMoveEvent = enabled;\n        break;\n      case 'pointerover':\n        this.enableOverEvent = enabled;\n        break;\n      case 'pointerout':\n        this.enableOutEvent = enabled;\n        break;\n      case 'pointerenter':\n        this.enableEnterEvent = enabled;\n        break;\n      case 'pointerleave':\n        this.enableLeaveEvent = enabled;\n        break;\n      default:\n      // ignore\n    }\n  }\n\n  handleEvent = (event: MouseEvent) => {\n    this.handleOverEvent(event);\n    this.handleOutEvent(event);\n    this.handleEnterEvent(event);\n    this.handleLeaveEvent(event);\n    this.handleMoveEvent(event);\n  };\n\n  handleOverEvent(event: MouseEvent) {\n    if (this.enableOverEvent && event.type === 'mouseover') {\n      this._emit('pointerover', event);\n    }\n  }\n\n  handleOutEvent(event: MouseEvent) {\n    if (this.enableOutEvent && event.type === 'mouseout') {\n      this._emit('pointerout', event);\n    }\n  }\n\n  handleEnterEvent(event: MouseEvent) {\n    if (this.enableEnterEvent && event.type === 'mouseenter') {\n      this._emit('pointerenter', event);\n    }\n  }\n\n  handleLeaveEvent(event: MouseEvent) {\n    if (this.enableLeaveEvent && event.type === 'mouseleave') {\n      this._emit('pointerleave', event);\n    }\n  }\n\n  handleMoveEvent(event: MouseEvent) {\n    if (this.enableMoveEvent) {\n      switch (event.type) {\n        case 'mousedown':\n          if (event.button >= 0) {\n            // Button is down\n            this.pressed = true;\n          }\n          break;\n        case 'mousemove':\n          // Move events use `bottons` to track the button being pressed\n          if (event.buttons === 0) {\n            // Button is not down\n            this.pressed = false;\n          }\n          if (!this.pressed) {\n            // Drag events are emitted by hammer already\n            // we just need to emit the move event on hover\n            this._emit('pointermove', event);\n          }\n          break;\n        case 'mouseup':\n          this.pressed = false;\n          break;\n        default:\n      }\n    }\n  }\n\n  _emit(type: MoveEventType, event: MouseEvent) {\n    this.callback({\n      type,\n      center: {\n        x: event.clientX,\n        y: event.clientY\n      },\n      srcEvent: event,\n      pointerType: 'mouse',\n      target: event.target as HTMLElement\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}