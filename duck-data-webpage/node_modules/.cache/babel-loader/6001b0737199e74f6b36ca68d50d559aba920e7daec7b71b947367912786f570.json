{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This file is derived from the tar-js code base under MIT license\n// See https://github.com/beatgammit/tar-js/blob/master/LICENSE\n/*\n * tar-js\n * MIT (c) 2011 T. Jameson Little\n */\nimport { clean, pad, stringToUint8 } from \"./utils.js\";\nimport { format } from \"./header.js\";\nlet blockSize;\nlet headerLength;\nlet inputLength;\nconst recordSize = 512;\nclass Tar {\n  written;\n  out;\n  blocks = [];\n  length;\n  /**\n   * @param [recordsPerBlock]\n   */\n  constructor(recordsPerBlock) {\n    this.written = 0;\n    blockSize = (recordsPerBlock || 20) * recordSize;\n    this.out = clean(blockSize);\n    this.blocks = [];\n    this.length = 0;\n    this.save = this.save.bind(this);\n    this.clear = this.clear.bind(this);\n    this.append = this.append.bind(this);\n  }\n  /**\n   * Append a file to the tar archive\n   * @param filepath\n   * @param input\n   * @param [opts]\n   */\n  // eslint-disable-next-line complexity\n  append(filepath, input, opts) {\n    let checksum;\n    if (typeof input === 'string') {\n      input = stringToUint8(input);\n    } else if (input.constructor && input.constructor !== Uint8Array.prototype.constructor) {\n      // @ts-ignore\n      const errorInputMatch = /function\\s*([$A-Za-z_][0-9A-Za-z_]*)\\s*\\(/.exec(input.constructor.toString());\n      const errorInput = errorInputMatch && errorInputMatch[1];\n      const errorMessage = `Invalid input type. You gave me: ${errorInput}`;\n      throw errorMessage;\n    }\n    opts = opts || {};\n    const mode = opts.mode || parseInt('777', 8) & 0xfff;\n    const mtime = opts.mtime || Math.floor(Number(new Date()) / 1000);\n    const uid = opts.uid || 0;\n    const gid = opts.gid || 0;\n    const data = {\n      fileName: filepath,\n      fileMode: pad(mode, 7),\n      uid: pad(uid, 7),\n      gid: pad(gid, 7),\n      fileSize: pad(input.length, 11),\n      mtime: pad(mtime, 11),\n      checksum: '        ',\n      // 0 = just a file\n      type: '0',\n      ustar: 'ustar  ',\n      owner: opts.owner || '',\n      group: opts.group || ''\n    };\n    // calculate the checksum\n    checksum = 0;\n    Object.keys(data).forEach(key => {\n      let i;\n      const value = data[key];\n      let length;\n      for (i = 0, length = value.length; i < length; i += 1) {\n        checksum += value.charCodeAt(i);\n      }\n    });\n    data.checksum = `${pad(checksum, 6)}\\u0000 `;\n    const headerArr = format(data);\n    headerLength = Math.ceil(headerArr.length / recordSize) * recordSize;\n    inputLength = Math.ceil(input.length / recordSize) * recordSize;\n    this.blocks.push({\n      header: headerArr,\n      input,\n      headerLength,\n      inputLength\n    });\n  }\n  /**\n   * Compiling data to a Blob object\n   * @returns {Blob}\n   */\n  save() {\n    const buffers = [];\n    const chunks = new Array();\n    let length = 0;\n    const max = Math.pow(2, 20);\n    let chunk = new Array();\n    this.blocks.forEach((b = []) => {\n      if (length + b.headerLength + b.inputLength > max) {\n        chunks.push({\n          blocks: chunk,\n          length\n        });\n        chunk = [];\n        length = 0;\n      }\n      chunk.push(b);\n      length += b.headerLength + b.inputLength;\n    });\n    chunks.push({\n      blocks: chunk,\n      length\n    });\n    chunks.forEach((c = []) => {\n      const buffer = new Uint8Array(c.length);\n      let written = 0;\n      c.blocks.forEach((b = []) => {\n        buffer.set(b.header, written);\n        written += b.headerLength;\n        buffer.set(b.input, written);\n        written += b.inputLength;\n      });\n      buffers.push(buffer);\n    });\n    buffers.push(new Uint8Array(2 * recordSize));\n    return new Blob(buffers, {\n      type: 'octet/stream'\n    });\n  }\n  /**\n   * Clear the data by its blocksize\n   */\n  clear() {\n    this.written = 0;\n    this.out = clean(blockSize);\n  }\n}\nexport default Tar;","map":{"version":3,"names":["clean","pad","stringToUint8","format","blockSize","headerLength","inputLength","recordSize","Tar","written","out","blocks","length","constructor","recordsPerBlock","save","bind","clear","append","filepath","input","opts","checksum","Uint8Array","prototype","errorInputMatch","exec","toString","errorInput","errorMessage","mode","parseInt","mtime","Math","floor","Number","Date","uid","gid","data","fileName","fileMode","fileSize","type","ustar","owner","group","Object","keys","forEach","key","i","value","charCodeAt","headerArr","ceil","push","header","buffers","chunks","Array","max","pow","chunk","b","c","buffer","set","Blob"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/zip/dist/lib/tar/tar.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This file is derived from the tar-js code base under MIT license\n// See https://github.com/beatgammit/tar-js/blob/master/LICENSE\n/*\n * tar-js\n * MIT (c) 2011 T. Jameson Little\n */\nimport { clean, pad, stringToUint8 } from \"./utils.js\";\nimport { format } from \"./header.js\";\nlet blockSize;\nlet headerLength;\nlet inputLength;\nconst recordSize = 512;\nclass Tar {\n    written;\n    out;\n    blocks = [];\n    length;\n    /**\n     * @param [recordsPerBlock]\n     */\n    constructor(recordsPerBlock) {\n        this.written = 0;\n        blockSize = (recordsPerBlock || 20) * recordSize;\n        this.out = clean(blockSize);\n        this.blocks = [];\n        this.length = 0;\n        this.save = this.save.bind(this);\n        this.clear = this.clear.bind(this);\n        this.append = this.append.bind(this);\n    }\n    /**\n     * Append a file to the tar archive\n     * @param filepath\n     * @param input\n     * @param [opts]\n     */\n    // eslint-disable-next-line complexity\n    append(filepath, input, opts) {\n        let checksum;\n        if (typeof input === 'string') {\n            input = stringToUint8(input);\n        }\n        else if (input.constructor && input.constructor !== Uint8Array.prototype.constructor) {\n            // @ts-ignore\n            const errorInputMatch = /function\\s*([$A-Za-z_][0-9A-Za-z_]*)\\s*\\(/.exec(input.constructor.toString());\n            const errorInput = errorInputMatch && errorInputMatch[1];\n            const errorMessage = `Invalid input type. You gave me: ${errorInput}`;\n            throw errorMessage;\n        }\n        opts = opts || {};\n        const mode = opts.mode || parseInt('777', 8) & 0xfff;\n        const mtime = opts.mtime || Math.floor(Number(new Date()) / 1000);\n        const uid = opts.uid || 0;\n        const gid = opts.gid || 0;\n        const data = {\n            fileName: filepath,\n            fileMode: pad(mode, 7),\n            uid: pad(uid, 7),\n            gid: pad(gid, 7),\n            fileSize: pad(input.length, 11),\n            mtime: pad(mtime, 11),\n            checksum: '        ',\n            // 0 = just a file\n            type: '0',\n            ustar: 'ustar  ',\n            owner: opts.owner || '',\n            group: opts.group || ''\n        };\n        // calculate the checksum\n        checksum = 0;\n        Object.keys(data).forEach((key) => {\n            let i;\n            const value = data[key];\n            let length;\n            for (i = 0, length = value.length; i < length; i += 1) {\n                checksum += value.charCodeAt(i);\n            }\n        });\n        data.checksum = `${pad(checksum, 6)}\\u0000 `;\n        const headerArr = format(data);\n        headerLength = Math.ceil(headerArr.length / recordSize) * recordSize;\n        inputLength = Math.ceil(input.length / recordSize) * recordSize;\n        this.blocks.push({\n            header: headerArr,\n            input,\n            headerLength,\n            inputLength\n        });\n    }\n    /**\n     * Compiling data to a Blob object\n     * @returns {Blob}\n     */\n    save() {\n        const buffers = [];\n        const chunks = new Array();\n        let length = 0;\n        const max = Math.pow(2, 20);\n        let chunk = new Array();\n        this.blocks.forEach((b = []) => {\n            if (length + b.headerLength + b.inputLength > max) {\n                chunks.push({ blocks: chunk, length });\n                chunk = [];\n                length = 0;\n            }\n            chunk.push(b);\n            length += b.headerLength + b.inputLength;\n        });\n        chunks.push({ blocks: chunk, length });\n        chunks.forEach((c = []) => {\n            const buffer = new Uint8Array(c.length);\n            let written = 0;\n            c.blocks.forEach((b = []) => {\n                buffer.set(b.header, written);\n                written += b.headerLength;\n                buffer.set(b.input, written);\n                written += b.inputLength;\n            });\n            buffers.push(buffer);\n        });\n        buffers.push(new Uint8Array(2 * recordSize));\n        return new Blob(buffers, { type: 'octet/stream' });\n    }\n    /**\n     * Clear the data by its blocksize\n     */\n    clear() {\n        this.written = 0;\n        this.out = clean(blockSize);\n    }\n}\nexport default Tar;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}