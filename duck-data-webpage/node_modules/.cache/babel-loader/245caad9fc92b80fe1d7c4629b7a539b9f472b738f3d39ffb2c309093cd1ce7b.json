{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ColumnLayer } from '@deck.gl/layers';\nimport { CubeGeometry } from '@luma.gl/engine';\nimport { createColorRangeTexture, updateColorRangeTexture } from \"../common/utils/color-utils.js\";\nimport vs from \"./grid-cell-layer-vertex.glsl.js\";\nimport { gridUniforms } from \"./grid-layer-uniforms.js\";\nexport class GridCellLayer extends ColumnLayer {\n  getShaders() {\n    const shaders = super.getShaders();\n    shaders.modules.push(gridUniforms);\n    return {\n      ...shaders,\n      vs\n    };\n  }\n  initializeState() {\n    super.initializeState();\n    const attributeManager = this.getAttributeManager();\n    attributeManager.remove(['instanceElevations', 'instanceFillColors', 'instanceLineColors', 'instanceStrokeWidths']);\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 2,\n        type: 'float32',\n        accessor: 'getBin'\n      },\n      instanceColorValues: {\n        size: 1,\n        type: 'float32',\n        accessor: 'getColorValue'\n      },\n      instanceElevationValues: {\n        size: 1,\n        type: 'float32',\n        accessor: 'getElevationValue'\n      }\n    });\n  }\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps\n    } = params;\n    const model = this.state.fillModel;\n    if (oldProps.colorRange !== props.colorRange) {\n      this.state.colorTexture?.destroy();\n      this.state.colorTexture = createColorRangeTexture(this.context.device, props.colorRange, props.colorScaleType);\n      const gridProps = {\n        colorRange: this.state.colorTexture\n      };\n      model.shaderInputs.setProps({\n        grid: gridProps\n      });\n    } else if (oldProps.colorScaleType !== props.colorScaleType) {\n      updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);\n    }\n  }\n  finalizeState(context) {\n    super.finalizeState(context);\n    this.state.colorTexture?.destroy();\n  }\n  _updateGeometry() {\n    const geometry = new CubeGeometry();\n    this.state.fillModel.setGeometry(geometry);\n  }\n  draw({\n    uniforms\n  }) {\n    const {\n      cellOriginCommon,\n      cellSizeCommon,\n      elevationRange,\n      elevationScale,\n      extruded,\n      coverage,\n      colorDomain,\n      elevationDomain\n    } = this.props;\n    const colorCutoff = this.props.colorCutoff || [-Infinity, Infinity];\n    const elevationCutoff = this.props.elevationCutoff || [-Infinity, Infinity];\n    const fillModel = this.state.fillModel;\n    const gridProps = {\n      colorDomain: [Math.max(colorDomain[0], colorCutoff[0]),\n      // instanceColorValue that maps to colorRange[0]\n      Math.min(colorDomain[1], colorCutoff[1]),\n      // instanceColorValue that maps to colorRange[colorRange.length - 1]\n      Math.max(colorDomain[0] - 1, colorCutoff[0]),\n      // hide cell if instanceColorValue is less than this\n      Math.min(colorDomain[1] + 1, colorCutoff[1]) // hide cell if instanceColorValue is greater than this\n      ],\n      elevationDomain: [Math.max(elevationDomain[0], elevationCutoff[0]),\n      // instanceElevationValue that maps to elevationRange[0]\n      Math.min(elevationDomain[1], elevationCutoff[1]),\n      // instanceElevationValue that maps to elevationRange[elevationRange.length - 1]\n      Math.max(elevationDomain[0] - 1, elevationCutoff[0]),\n      // hide cell if instanceElevationValue is less than this\n      Math.min(elevationDomain[1] + 1, elevationCutoff[1]) // hide cell if instanceElevationValue is greater than this\n      ],\n      elevationRange: [elevationRange[0] * elevationScale, elevationRange[1] * elevationScale],\n      originCommon: cellOriginCommon,\n      sizeCommon: cellSizeCommon\n    };\n    fillModel.shaderInputs.setProps({\n      column: {\n        extruded,\n        coverage\n      },\n      grid: gridProps\n    });\n    fillModel.draw(this.context.renderPass);\n  }\n}\nGridCellLayer.layerName = 'GridCellLayer';","map":{"version":3,"names":["ColumnLayer","CubeGeometry","createColorRangeTexture","updateColorRangeTexture","vs","gridUniforms","GridCellLayer","getShaders","shaders","modules","push","initializeState","attributeManager","getAttributeManager","remove","addInstanced","instancePositions","size","type","accessor","instanceColorValues","instanceElevationValues","updateState","params","props","oldProps","model","state","fillModel","colorRange","colorTexture","destroy","context","device","colorScaleType","gridProps","shaderInputs","setProps","grid","finalizeState","_updateGeometry","geometry","setGeometry","draw","uniforms","cellOriginCommon","cellSizeCommon","elevationRange","elevationScale","extruded","coverage","colorDomain","elevationDomain","colorCutoff","Infinity","elevationCutoff","Math","max","min","originCommon","sizeCommon","column","renderPass","layerName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\aggregation-layers\\src\\grid-layer\\grid-cell-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Texture} from '@luma.gl/core';\nimport {UpdateParameters, Color} from '@deck.gl/core';\nimport {ColumnLayer} from '@deck.gl/layers';\nimport {CubeGeometry} from '@luma.gl/engine';\nimport {createColorRangeTexture, updateColorRangeTexture} from '../common/utils/color-utils';\nimport vs from './grid-cell-layer-vertex.glsl';\nimport {GridProps, gridUniforms} from './grid-layer-uniforms';\nimport type {ScaleType} from '../common/types';\n\n/** Proprties added by GridCellLayer. */\ntype GridCellLayerProps = {\n  cellSizeCommon: [number, number];\n  cellOriginCommon: [number, number];\n  colorDomain: [number, number];\n  colorCutoff: [number, number] | null;\n  colorRange: Color[];\n  colorScaleType: ScaleType;\n  elevationDomain: [number, number];\n  elevationCutoff: [number, number] | null;\n  elevationRange: [number, number];\n};\n\nexport class GridCellLayer<ExtraPropsT extends {} = {}> extends ColumnLayer<\n  null,\n  ExtraPropsT & Required<GridCellLayerProps>\n> {\n  static layerName = 'GridCellLayer';\n\n  state!: ColumnLayer['state'] & {\n    colorTexture: Texture;\n  };\n\n  getShaders() {\n    const shaders = super.getShaders();\n    shaders.modules.push(gridUniforms);\n    return {...shaders, vs};\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.remove([\n      'instanceElevations',\n      'instanceFillColors',\n      'instanceLineColors',\n      'instanceStrokeWidths'\n    ]);\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 2,\n        type: 'float32',\n        accessor: 'getBin'\n      },\n      instanceColorValues: {\n        size: 1,\n        type: 'float32',\n        accessor: 'getColorValue'\n      },\n      instanceElevationValues: {\n        size: 1,\n        type: 'float32',\n        accessor: 'getElevationValue'\n      }\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n\n    const {props, oldProps} = params;\n    const model = this.state.fillModel!;\n\n    if (oldProps.colorRange !== props.colorRange) {\n      this.state.colorTexture?.destroy();\n      this.state.colorTexture = createColorRangeTexture(\n        this.context.device,\n        props.colorRange,\n        props.colorScaleType\n      );\n      const gridProps: Partial<GridProps> = {colorRange: this.state.colorTexture};\n      model.shaderInputs.setProps({grid: gridProps});\n    } else if (oldProps.colorScaleType !== props.colorScaleType) {\n      updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);\n    }\n  }\n\n  finalizeState(context) {\n    super.finalizeState(context);\n\n    this.state.colorTexture?.destroy();\n  }\n\n  protected _updateGeometry() {\n    const geometry = new CubeGeometry();\n    this.state.fillModel!.setGeometry(geometry);\n  }\n\n  draw({uniforms}) {\n    const {\n      cellOriginCommon,\n      cellSizeCommon,\n      elevationRange,\n      elevationScale,\n      extruded,\n      coverage,\n      colorDomain,\n      elevationDomain\n    } = this.props;\n    const colorCutoff = this.props.colorCutoff || [-Infinity, Infinity];\n    const elevationCutoff = this.props.elevationCutoff || [-Infinity, Infinity];\n    const fillModel = this.state.fillModel!;\n\n    const gridProps: Omit<GridProps, 'colorRange'> = {\n      colorDomain: [\n        Math.max(colorDomain[0], colorCutoff[0]), // instanceColorValue that maps to colorRange[0]\n        Math.min(colorDomain[1], colorCutoff[1]), // instanceColorValue that maps to colorRange[colorRange.length - 1]\n        Math.max(colorDomain[0] - 1, colorCutoff[0]), // hide cell if instanceColorValue is less than this\n        Math.min(colorDomain[1] + 1, colorCutoff[1]) // hide cell if instanceColorValue is greater than this\n      ],\n      elevationDomain: [\n        Math.max(elevationDomain[0], elevationCutoff[0]), // instanceElevationValue that maps to elevationRange[0]\n        Math.min(elevationDomain[1], elevationCutoff[1]), // instanceElevationValue that maps to elevationRange[elevationRange.length - 1]\n        Math.max(elevationDomain[0] - 1, elevationCutoff[0]), // hide cell if instanceElevationValue is less than this\n        Math.min(elevationDomain[1] + 1, elevationCutoff[1]) // hide cell if instanceElevationValue is greater than this\n      ],\n      elevationRange: [elevationRange[0] * elevationScale, elevationRange[1] * elevationScale],\n      originCommon: cellOriginCommon,\n      sizeCommon: cellSizeCommon\n    };\n    fillModel.shaderInputs.setProps({\n      column: {extruded, coverage},\n      grid: gridProps\n    });\n    fillModel.draw(this.context.renderPass);\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAIA,SAAQA,WAAW,QAAO,iBAAiB;AAC3C,SAAQC,YAAY,QAAO,iBAAiB;AAC5C,SAAQC,uBAAuB,EAAEC,uBAAuB,QAAC;AACzD,OAAOC,EAAE;AACT,SAAmBC,YAAY,QAAC;AAgBhC,OAAM,MAAOC,aAA2C,SAAQN,WAG/D;EAOCO,UAAUA,CAAA;IACR,MAAMC,OAAO,GAAG,KAAK,CAACD,UAAU,EAAE;IAClCC,OAAO,CAACC,OAAO,CAACC,IAAI,CAACL,YAAY,CAAC;IAClC,OAAO;MAAC,GAAGG,OAAO;MAAEJ;IAAE,CAAC;EACzB;EAEAO,eAAeA,CAAA;IACb,KAAK,CAACA,eAAe,EAAE;IAEvB,MAAMC,gBAAgB,GAAG,IAAI,CAACC,mBAAmB,EAAG;IACpDD,gBAAgB,CAACE,MAAM,CAAC,CACtB,oBAAoB,EACpB,oBAAoB,EACpB,oBAAoB,EACpB,sBAAsB,CACvB,CAAC;IACFF,gBAAgB,CAACG,YAAY,CAAC;MAC5BC,iBAAiB,EAAE;QACjBC,IAAI,EAAE,CAAC;QACPC,IAAI,EAAE,SAAS;QACfC,QAAQ,EAAE;OACX;MACDC,mBAAmB,EAAE;QACnBH,IAAI,EAAE,CAAC;QACPC,IAAI,EAAE,SAAS;QACfC,QAAQ,EAAE;OACX;MACDE,uBAAuB,EAAE;QACvBJ,IAAI,EAAE,CAAC;QACPC,IAAI,EAAE,SAAS;QACfC,QAAQ,EAAE;;KAEb,CAAC;EACJ;EAEAG,WAAWA,CAACC,MAA8B;IACxC,KAAK,CAACD,WAAW,CAACC,MAAM,CAAC;IAEzB,MAAM;MAACC,KAAK;MAAEC;IAAQ,CAAC,GAAGF,MAAM;IAChC,MAAMG,KAAK,GAAG,IAAI,CAACC,KAAK,CAACC,SAAU;IAEnC,IAAIH,QAAQ,CAACI,UAAU,KAAKL,KAAK,CAACK,UAAU,EAAE;MAC5C,IAAI,CAACF,KAAK,CAACG,YAAY,EAAEC,OAAO,EAAE;MAClC,IAAI,CAACJ,KAAK,CAACG,YAAY,GAAG5B,uBAAuB,CAC/C,IAAI,CAAC8B,OAAO,CAACC,MAAM,EACnBT,KAAK,CAACK,UAAU,EAChBL,KAAK,CAACU,cAAc,CACrB;MACD,MAAMC,SAAS,GAAuB;QAACN,UAAU,EAAE,IAAI,CAACF,KAAK,CAACG;MAAY,CAAC;MAC3EJ,KAAK,CAACU,YAAY,CAACC,QAAQ,CAAC;QAACC,IAAI,EAAEH;MAAS,CAAC,CAAC;IAChD,CAAC,MAAM,IAAIV,QAAQ,CAACS,cAAc,KAAKV,KAAK,CAACU,cAAc,EAAE;MAC3D/B,uBAAuB,CAAC,IAAI,CAACwB,KAAK,CAACG,YAAY,EAAEN,KAAK,CAACU,cAAc,CAAC;IACxE;EACF;EAEAK,aAAaA,CAACP,OAAO;IACnB,KAAK,CAACO,aAAa,CAACP,OAAO,CAAC;IAE5B,IAAI,CAACL,KAAK,CAACG,YAAY,EAAEC,OAAO,EAAE;EACpC;EAEUS,eAAeA,CAAA;IACvB,MAAMC,QAAQ,GAAG,IAAIxC,YAAY,EAAE;IACnC,IAAI,CAAC0B,KAAK,CAACC,SAAU,CAACc,WAAW,CAACD,QAAQ,CAAC;EAC7C;EAEAE,IAAIA,CAAC;IAACC;EAAQ,CAAC;IACb,MAAM;MACJC,gBAAgB;MAChBC,cAAc;MACdC,cAAc;MACdC,cAAc;MACdC,QAAQ;MACRC,QAAQ;MACRC,WAAW;MACXC;IAAe,CAChB,GAAG,IAAI,CAAC5B,KAAK;IACd,MAAM6B,WAAW,GAAG,IAAI,CAAC7B,KAAK,CAAC6B,WAAW,IAAI,CAAC,CAACC,QAAQ,EAAEA,QAAQ,CAAC;IACnE,MAAMC,eAAe,GAAG,IAAI,CAAC/B,KAAK,CAAC+B,eAAe,IAAI,CAAC,CAACD,QAAQ,EAAEA,QAAQ,CAAC;IAC3E,MAAM1B,SAAS,GAAG,IAAI,CAACD,KAAK,CAACC,SAAU;IAEvC,MAAMO,SAAS,GAAkC;MAC/CgB,WAAW,EAAE,CACXK,IAAI,CAACC,GAAG,CAACN,WAAW,CAAC,CAAC,CAAC,EAAEE,WAAW,CAAC,CAAC,CAAC,CAAC;MAAE;MAC1CG,IAAI,CAACE,GAAG,CAACP,WAAW,CAAC,CAAC,CAAC,EAAEE,WAAW,CAAC,CAAC,CAAC,CAAC;MAAE;MAC1CG,IAAI,CAACC,GAAG,CAACN,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC,EAAEE,WAAW,CAAC,CAAC,CAAC,CAAC;MAAE;MAC9CG,IAAI,CAACE,GAAG,CAACP,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC,EAAEE,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;MAAA,CAC9C;MACDD,eAAe,EAAE,CACfI,IAAI,CAACC,GAAG,CAACL,eAAe,CAAC,CAAC,CAAC,EAAEG,eAAe,CAAC,CAAC,CAAC,CAAC;MAAE;MAClDC,IAAI,CAACE,GAAG,CAACN,eAAe,CAAC,CAAC,CAAC,EAAEG,eAAe,CAAC,CAAC,CAAC,CAAC;MAAE;MAClDC,IAAI,CAACC,GAAG,CAACL,eAAe,CAAC,CAAC,CAAC,GAAG,CAAC,EAAEG,eAAe,CAAC,CAAC,CAAC,CAAC;MAAE;MACtDC,IAAI,CAACE,GAAG,CAACN,eAAe,CAAC,CAAC,CAAC,GAAG,CAAC,EAAEG,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC;MAAA,CACtD;MACDR,cAAc,EAAE,CAACA,cAAc,CAAC,CAAC,CAAC,GAAGC,cAAc,EAAED,cAAc,CAAC,CAAC,CAAC,GAAGC,cAAc,CAAC;MACxFW,YAAY,EAAEd,gBAAgB;MAC9Be,UAAU,EAAEd;KACb;IACDlB,SAAS,CAACQ,YAAY,CAACC,QAAQ,CAAC;MAC9BwB,MAAM,EAAE;QAACZ,QAAQ;QAAEC;MAAQ,CAAC;MAC5BZ,IAAI,EAAEH;KACP,CAAC;IACFP,SAAS,CAACe,IAAI,CAAC,IAAI,CAACX,OAAO,CAAC8B,UAAU,CAAC;EACzC;;AA7GOxD,aAAA,CAAAyD,SAAS,GAAG,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}