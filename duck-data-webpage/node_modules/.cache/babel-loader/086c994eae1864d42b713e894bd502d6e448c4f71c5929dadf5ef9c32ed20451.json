{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { assert } from \"../utils/assert.js\";\n/** Minimal validators for number and array types */\nconst DEFAULT_PROP_VALIDATORS = {\n  number: {\n    type: 'number',\n    validate(value, propType) {\n      return Number.isFinite(value) && typeof propType === 'object' && (propType.max === undefined || value <= propType.max) && (propType.min === undefined || value >= propType.min);\n    }\n  },\n  array: {\n    type: 'array',\n    validate(value, propType) {\n      return Array.isArray(value) || ArrayBuffer.isView(value);\n    }\n  }\n};\n/**\n * Parse a list of property types into property definitions that can be used to validate\n * values passed in by applications.\n * @param propTypes\n * @returns\n */\nexport function makePropValidators(propTypes) {\n  const propValidators = {};\n  for (const [name, propType] of Object.entries(propTypes)) {\n    propValidators[name] = makePropValidator(propType);\n  }\n  return propValidators;\n}\n/**\n * Validate a map of user supplied properties against a map of validators\n * Inject default values when user doesn't supply a property\n * @param properties\n * @param propValidators\n * @returns\n */\nexport function getValidatedProperties(properties, propValidators, errorMessage) {\n  const validated = {};\n  for (const [key, propsValidator] of Object.entries(propValidators)) {\n    if (properties && key in properties && !propsValidator.private) {\n      if (propsValidator.validate) {\n        assert(propsValidator.validate(properties[key], propsValidator), `${errorMessage}: invalid ${key}`);\n      }\n      validated[key] = properties[key];\n    } else {\n      // property not supplied - use default value\n      validated[key] = propsValidator.value;\n    }\n  }\n  // TODO - warn for unused properties that don't match a validator?\n  return validated;\n}\n/**\n * Creates a property validator for a prop type. Either contains:\n * - a valid prop type object ({type, ...})\n * - or just a default value, in which case type and name inference is used\n */\nfunction makePropValidator(propType) {\n  let type = getTypeOf(propType);\n  if (type !== 'object') {\n    return {\n      value: propType,\n      ...DEFAULT_PROP_VALIDATORS[type],\n      type\n    };\n  }\n  // Special handling for objects\n  if (typeof propType === 'object') {\n    if (!propType) {\n      return {\n        type: 'object',\n        value: null\n      };\n    }\n    if (propType.type !== undefined) {\n      return {\n        ...propType,\n        ...DEFAULT_PROP_VALIDATORS[propType.type],\n        type: propType.type\n      };\n    }\n    // If no type and value this object is likely the value\n    if (propType.value === undefined) {\n      return {\n        type: 'object',\n        value: propType\n      };\n    }\n    type = getTypeOf(propType.value);\n    return {\n      ...propType,\n      ...DEFAULT_PROP_VALIDATORS[type],\n      type\n    };\n  }\n  throw new Error('props');\n}\n/**\n * \"improved\" version of javascript typeof that can distinguish arrays and null values\n */\nfunction getTypeOf(value) {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n  return typeof value;\n}","map":{"version":3,"names":["assert","DEFAULT_PROP_VALIDATORS","number","type","validate","value","propType","Number","isFinite","max","undefined","min","array","Array","isArray","ArrayBuffer","isView","makePropValidators","propTypes","propValidators","name","Object","entries","makePropValidator","getValidatedProperties","properties","errorMessage","validated","key","propsValidator","private","getTypeOf","Error"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\shadertools\\src\\lib\\filters\\prop-types.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {assert} from '../utils/assert';\n\n/**\n * For use by shader module and shader pass writers to describe the types of the\n * properties they expose (properties ultimately map to uniforms).\n */\nexport type PropType =\n  | {\n      type?: string;\n      value?: unknown;\n      max?: number;\n      min?: number;\n      softMax?: number;\n      softMin?: number;\n      hint?: string;\n      /** @deprecated internal uniform */\n      private?: boolean;\n    }\n  | number;\n\n/**\n * Internal property validators generated by processing the prop types ,\n * The `validate()` method can be used to validate the type of properties passed in to\n * shader module or shader pass\n */\nexport type PropValidator = {\n  type: string;\n  value?: unknown;\n  max?: number;\n  min?: number;\n  private?: boolean;\n  validate?(value: unknown, propDef: PropValidator): boolean;\n};\n\n/** Minimal validators for number and array types */\nconst DEFAULT_PROP_VALIDATORS: Record<string, PropValidator> = {\n  number: {\n    type: 'number',\n    validate(value: unknown, propType: PropType) {\n      return (\n        Number.isFinite(value) &&\n        typeof propType === 'object' &&\n        (propType.max === undefined || (value as number) <= propType.max) &&\n        (propType.min === undefined || (value as number) >= propType.min)\n      );\n    }\n  },\n  array: {\n    type: 'array',\n    validate(value: unknown, propType: PropType) {\n      return Array.isArray(value) || ArrayBuffer.isView(value);\n    }\n  }\n};\n\n/**\n * Parse a list of property types into property definitions that can be used to validate\n * values passed in by applications.\n * @param propTypes\n * @returns\n */\nexport function makePropValidators(\n  propTypes: Record<string, PropType>\n): Record<string, PropValidator> {\n  const propValidators: Record<string, PropValidator> = {};\n  for (const [name, propType] of Object.entries(propTypes)) {\n    propValidators[name] = makePropValidator(propType);\n  }\n  return propValidators;\n}\n\n/**\n * Validate a map of user supplied properties against a map of validators\n * Inject default values when user doesn't supply a property\n * @param properties\n * @param propValidators\n * @returns\n */\nexport function getValidatedProperties(\n  properties: Record<string, unknown>,\n  propValidators: Record<string, PropValidator>,\n  errorMessage: string\n): Record<string, unknown> {\n  const validated: Record<string, unknown> = {};\n\n  for (const [key, propsValidator] of Object.entries(propValidators)) {\n    if (properties && key in properties && !propsValidator.private) {\n      if (propsValidator.validate) {\n        assert(\n          propsValidator.validate(properties[key], propsValidator),\n          `${errorMessage}: invalid ${key}`\n        );\n      }\n      validated[key] = properties[key];\n    } else {\n      // property not supplied - use default value\n      validated[key] = propsValidator.value;\n    }\n  }\n\n  // TODO - warn for unused properties that don't match a validator?\n\n  return validated;\n}\n\n/**\n * Creates a property validator for a prop type. Either contains:\n * - a valid prop type object ({type, ...})\n * - or just a default value, in which case type and name inference is used\n */\nfunction makePropValidator(propType: PropType): PropValidator {\n  let type = getTypeOf(propType);\n\n  if (type !== 'object') {\n    return {value: propType, ...DEFAULT_PROP_VALIDATORS[type], type};\n  }\n\n  // Special handling for objects\n  if (typeof propType === 'object') {\n    if (!propType) {\n      return {type: 'object', value: null};\n    }\n    if (propType.type !== undefined) {\n      return {...propType, ...DEFAULT_PROP_VALIDATORS[propType.type], type: propType.type};\n    }\n    // If no type and value this object is likely the value\n    if (propType.value === undefined) {\n      return {type: 'object', value: propType};\n    }\n\n    type = getTypeOf(propType.value);\n    return {...propType, ...DEFAULT_PROP_VALIDATORS[type], type};\n  }\n\n  throw new Error('props');\n}\n\n/**\n * \"improved\" version of javascript typeof that can distinguish arrays and null values\n */\nfunction getTypeOf(value: unknown): string {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n  return typeof value;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}