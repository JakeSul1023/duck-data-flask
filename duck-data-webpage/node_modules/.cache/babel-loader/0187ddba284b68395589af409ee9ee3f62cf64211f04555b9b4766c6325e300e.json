{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { project32 } from '@deck.gl/core';\nimport { WebGLAggregator, CPUAggregator } from \"../common/aggregator/index.js\";\nimport AggregationLayer from \"../common/aggregation-layer.js\";\nimport ScreenGridCellLayer from \"./screen-grid-cell-layer.js\";\nimport { binOptionsUniforms } from \"./bin-options-uniforms.js\";\nimport { defaultColorRange } from \"../common/utils/color-utils.js\";\nconst defaultProps = {\n  cellSizePixels: {\n    type: 'number',\n    value: 100,\n    min: 1\n  },\n  cellMarginPixels: {\n    type: 'number',\n    value: 2,\n    min: 0\n  },\n  colorRange: defaultColorRange,\n  colorScaleType: 'linear',\n  getPosition: {\n    type: 'accessor',\n    value: d => d.position\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  gpuAggregation: true,\n  aggregation: 'SUM'\n};\n/** Aggregates data into histogram bins and renders them as a grid. */\nclass ScreenGridLayer extends AggregationLayer {\n  getAggregatorType() {\n    return this.props.gpuAggregation && WebGLAggregator.isSupported(this.context.device) ? 'gpu' : 'cpu';\n  }\n  createAggregator(type) {\n    if (type === 'cpu' || !WebGLAggregator.isSupported(this.context.device)) {\n      return new CPUAggregator({\n        dimensions: 2,\n        getBin: {\n          sources: ['positions'],\n          getValue: ({\n            positions\n          }, index, opts) => {\n            const viewport = this.context.viewport;\n            const p = viewport.project(positions);\n            const cellSizePixels = opts.cellSizePixels;\n            if (p[0] < 0 || p[0] >= viewport.width || p[1] < 0 || p[1] >= viewport.height) {\n              // Not on screen\n              return null;\n            }\n            return [Math.floor(p[0] / cellSizePixels), Math.floor(p[1] / cellSizePixels)];\n          }\n        },\n        getValue: [{\n          sources: ['counts'],\n          getValue: ({\n            counts\n          }) => counts\n        }]\n      });\n    }\n    return new WebGLAggregator(this.context.device, {\n      dimensions: 2,\n      channelCount: 1,\n      bufferLayout: this.getAttributeManager().getBufferLayouts({\n        isInstanced: false\n      }),\n      ...super.getShaders({\n        modules: [project32, binOptionsUniforms],\n        vs: `\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float counts;\n  \n  void getBin(out ivec2 binId) {\n    vec4 pos = project_position_to_clipspace(positions, positions64Low, vec3(0.0));\n    vec2 screenCoords = vec2(pos.x / pos.w + 1.0, 1.0 - pos.y / pos.w) / 2.0 * project.viewportSize / project.devicePixelRatio;\n    vec2 gridCoords = floor(screenCoords / binOptions.cellSizePixels);\n    binId = ivec2(gridCoords);\n  }\n  void getValue(out float weight) {\n    weight = counts;\n  }\n  `\n      })\n    });\n  }\n  initializeState() {\n    super.initializeState();\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 'float64',\n        fp64: this.use64bitPositions()\n      },\n      // this attribute is used in gpu aggregation path only\n      counts: {\n        size: 1,\n        accessor: 'getWeight'\n      }\n    });\n  }\n  shouldUpdateState({\n    changeFlags\n  }) {\n    return changeFlags.somethingChanged;\n  }\n  updateState(params) {\n    const aggregatorChanged = super.updateState(params);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const {\n      cellSizePixels,\n      aggregation\n    } = props;\n    if (aggregatorChanged || changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.viewportChanged || aggregation !== oldProps.aggregation || cellSizePixels !== oldProps.cellSizePixels) {\n      const {\n        width,\n        height\n      } = this.context.viewport;\n      const {\n        aggregator\n      } = this.state;\n      if (aggregator instanceof WebGLAggregator) {\n        aggregator.setProps({\n          binIdRange: [[0, Math.ceil(width / cellSizePixels)], [0, Math.ceil(height / cellSizePixels)]]\n        });\n      }\n      aggregator.setProps({\n        pointCount: this.getNumInstances(),\n        operations: [aggregation],\n        binOptions: {\n          cellSizePixels\n        }\n      });\n    }\n    if (changeFlags.viewportChanged) {\n      // Rerun aggregation on viewport change\n      this.state.aggregator.setNeedsUpdate();\n    }\n    return aggregatorChanged;\n  }\n  onAttributeChange(id) {\n    const {\n      aggregator\n    } = this.state;\n    switch (id) {\n      case 'positions':\n        aggregator.setNeedsUpdate();\n        break;\n      case 'counts':\n        aggregator.setNeedsUpdate(0);\n        break;\n      default:\n      // This should not happen\n    }\n  }\n  renderLayers() {\n    const {\n      aggregator\n    } = this.state;\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n    const binAttribute = aggregator.getBins();\n    const weightAttribute = aggregator.getResult(0);\n    return new CellLayerClass(this.props, this.getSubLayerProps({\n      id: 'cell-layer'\n    }), {\n      data: {\n        length: aggregator.binCount,\n        attributes: {\n          getBin: binAttribute,\n          getWeight: weightAttribute\n        }\n      },\n      // Data has changed shallowly, but we likely don't need to update the attributes\n      dataComparator: (data, oldData) => data.length === oldData.length,\n      updateTriggers: {\n        getBin: [binAttribute],\n        getWeight: [weightAttribute]\n      },\n      parameters: {\n        depthWriteEnabled: false,\n        ...this.props.parameters\n      },\n      // Evaluate domain at draw() time\n      colorDomain: () => this.props.colorDomain || aggregator.getResultDomain(0),\n      // Extensions are already handled by the GPUAggregator, do not pass it down\n      extensions: []\n    });\n  }\n  getPickingInfo(params) {\n    const info = params.info;\n    const {\n      index\n    } = info;\n    if (index >= 0) {\n      const bin = this.state.aggregator.getBin(index);\n      let object;\n      if (bin) {\n        object = {\n          col: bin.id[0],\n          row: bin.id[1],\n          value: bin.value[0],\n          count: bin.count\n        };\n        if (bin.pointIndices) {\n          object.pointIndices = bin.pointIndices;\n          object.points = Array.isArray(this.props.data) ? bin.pointIndices.map(i => this.props.data[i]) : [];\n        }\n      }\n      info.object = object;\n    }\n    return info;\n  }\n}\nScreenGridLayer.layerName = 'ScreenGridLayer';\nScreenGridLayer.defaultProps = defaultProps;\nexport default ScreenGridLayer;","map":{"version":3,"names":["project32","WebGLAggregator","CPUAggregator","AggregationLayer","ScreenGridCellLayer","binOptionsUniforms","defaultColorRange","defaultProps","cellSizePixels","type","value","min","cellMarginPixels","colorRange","colorScaleType","getPosition","d","position","getWeight","gpuAggregation","aggregation","ScreenGridLayer","getAggregatorType","props","isSupported","context","device","createAggregator","dimensions","getBin","sources","getValue","positions","index","opts","viewport","p","project","width","height","Math","floor","counts","channelCount","bufferLayout","getAttributeManager","getBufferLayouts","isInstanced","getShaders","modules","vs","initializeState","attributeManager","add","size","accessor","fp64","use64bitPositions","shouldUpdateState","changeFlags","somethingChanged","updateState","params","aggregatorChanged","oldProps","dataChanged","updateTriggersChanged","viewportChanged","aggregator","state","setProps","binIdRange","ceil","pointCount","getNumInstances","operations","binOptions","setNeedsUpdate","onAttributeChange","id","renderLayers","CellLayerClass","getSubLayerClass","binAttribute","getBins","weightAttribute","getResult","getSubLayerProps","data","length","binCount","attributes","dataComparator","oldData","updateTriggers","parameters","depthWriteEnabled","colorDomain","getResultDomain","extensions","getPickingInfo","info","bin","object","col","row","count","pointIndices","points","Array","isArray","map","i","layerName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\aggregation-layers\\src\\screen-grid-layer\\screen-grid-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  Accessor,\n  Color,\n  GetPickingInfoParams,\n  CompositeLayerProps,\n  Layer,\n  project32,\n  LayersList,\n  PickingInfo,\n  Position,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport {WebGLAggregator, CPUAggregator, AggregationOperation} from '../common/aggregator/index';\nimport AggregationLayer from '../common/aggregation-layer';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport {BinOptions, binOptionsUniforms} from './bin-options-uniforms';\nimport {defaultColorRange} from '../common/utils/color-utils';\n\nconst defaultProps: DefaultProps<ScreenGridLayerProps> = {\n  cellSizePixels: {type: 'number', value: 100, min: 1},\n  cellMarginPixels: {type: 'number', value: 2, min: 0},\n  colorRange: defaultColorRange,\n  colorScaleType: 'linear',\n  getPosition: {type: 'accessor', value: (d: any) => d.position},\n  getWeight: {type: 'accessor', value: 1},\n\n  gpuAggregation: true,\n  aggregation: 'SUM'\n};\n\n/** All properties supported by ScreenGridLayer. */\nexport type ScreenGridLayerProps<DataT = unknown> = _ScreenGridLayerProps<DataT> &\n  CompositeLayerProps;\n\n/** Properties added by ScreenGridLayer. */\nexport type _ScreenGridLayerProps<DataT> = {\n  /**\n   * Unit width/height of the bins.\n   * @default 100\n   */\n  cellSizePixels?: number;\n\n  /**\n   * Cell margin size in pixels.\n   * @default 2\n   */\n  cellMarginPixels?: number;\n\n  /**\n   * Color scale input domain. The color scale maps continues numeric domain into discrete color range.\n   * @default [1, max(weight)]\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Specified as an array of colors [color1, color2, ...].\n   *\n   * @default `6-class YlOrRd` - [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6)\n   */\n  colorRange?: Color[];\n\n  /**\n   * Scaling function used to determine the color of the grid cell.\n   * Supported Values are 'quantize', 'linear', 'quantile' and 'ordinal'.\n   * @default 'quantize'\n   */\n  colorScaleType?: 'linear' | 'quantize';\n\n  /**\n   * Method called to retrieve the position of each object.\n   *\n   * @default d => d.position\n   */\n  getPosition?: Accessor<DataT, Position>;\n\n  /**\n   * The weight of each object.\n   *\n   * @default 1\n   */\n  getWeight?: Accessor<DataT, number>;\n\n  /**\n   * Perform aggregation is performed on GPU.\n   *\n   * @default true\n   */\n  gpuAggregation?: boolean;\n\n  /**\n   * Defines the type of aggregation operation\n   * Valid values are 'SUM', 'MEAN', 'MIN', 'MAX', 'COUNT'.\n   *\n   * @default 'SUM'\n   */\n  aggregation?: AggregationOperation;\n};\n\nexport type ScreenGridLayerPickingInfo<DataT> = PickingInfo<{\n  /** Column index of the picked cell, starting from 0 at the left of the viewport */\n  col: number;\n  /** Row index of the picked cell, starting from 0 at the top of the viewport */\n  row: number;\n  /** Aggregated value */\n  value: number;\n  /** Number of data points in the picked cell */\n  count: number;\n  /** Indices of the data objects in the picked cell. Only available if using CPU aggregation. */\n  pointIndices?: number[];\n  /** The data objects in the picked cell. Only available if using CPU aggregation and layer data is an array. */\n  points?: DataT[];\n}>;\n\n/** Aggregates data into histogram bins and renders them as a grid. */\nexport default class ScreenGridLayer<\n  DataT = any,\n  ExtraProps extends {} = {}\n> extends AggregationLayer<DataT, ExtraProps & Required<_ScreenGridLayerProps<DataT>>> {\n  static layerName = 'ScreenGridLayer';\n  static defaultProps = defaultProps;\n\n  getAggregatorType(): string {\n    return this.props.gpuAggregation && WebGLAggregator.isSupported(this.context.device)\n      ? 'gpu'\n      : 'cpu';\n  }\n\n  createAggregator(type: string): WebGLAggregator | CPUAggregator {\n    if (type === 'cpu' || !WebGLAggregator.isSupported(this.context.device)) {\n      return new CPUAggregator({\n        dimensions: 2,\n        getBin: {\n          sources: ['positions'],\n          getValue: ({positions}: {positions: number[]}, index: number, opts: BinOptions) => {\n            const viewport = this.context.viewport;\n            const p = viewport.project(positions);\n            const cellSizePixels: number = opts.cellSizePixels;\n            if (p[0] < 0 || p[0] >= viewport.width || p[1] < 0 || p[1] >= viewport.height) {\n              // Not on screen\n              return null;\n            }\n            return [Math.floor(p[0] / cellSizePixels), Math.floor(p[1] / cellSizePixels)];\n          }\n        },\n        getValue: [{sources: ['counts'], getValue: ({counts}) => counts}]\n      });\n    }\n    return new WebGLAggregator(this.context.device, {\n      dimensions: 2,\n      channelCount: 1,\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts({isInstanced: false}),\n      ...super.getShaders({\n        modules: [project32, binOptionsUniforms],\n        vs: `\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float counts;\n  \n  void getBin(out ivec2 binId) {\n    vec4 pos = project_position_to_clipspace(positions, positions64Low, vec3(0.0));\n    vec2 screenCoords = vec2(pos.x / pos.w + 1.0, 1.0 - pos.y / pos.w) / 2.0 * project.viewportSize / project.devicePixelRatio;\n    vec2 gridCoords = floor(screenCoords / binOptions.cellSizePixels);\n    binId = ivec2(gridCoords);\n  }\n  void getValue(out float weight) {\n    weight = counts;\n  }\n  `\n      })\n    });\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      positions: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 'float64',\n        fp64: this.use64bitPositions()\n      },\n      // this attribute is used in gpu aggregation path only\n      counts: {size: 1, accessor: 'getWeight'}\n    });\n  }\n\n  shouldUpdateState({changeFlags}: UpdateParameters<this>) {\n    return changeFlags.somethingChanged;\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    const aggregatorChanged = super.updateState(params);\n\n    const {props, oldProps, changeFlags} = params;\n    const {cellSizePixels, aggregation} = props;\n    if (\n      aggregatorChanged ||\n      changeFlags.dataChanged ||\n      changeFlags.updateTriggersChanged ||\n      changeFlags.viewportChanged ||\n      aggregation !== oldProps.aggregation ||\n      cellSizePixels !== oldProps.cellSizePixels\n    ) {\n      const {width, height} = this.context.viewport;\n      const {aggregator} = this.state;\n\n      if (aggregator instanceof WebGLAggregator) {\n        aggregator.setProps({\n          binIdRange: [\n            [0, Math.ceil(width / cellSizePixels)],\n            [0, Math.ceil(height / cellSizePixels)]\n          ]\n        });\n      }\n\n      aggregator.setProps({\n        pointCount: this.getNumInstances(),\n        operations: [aggregation],\n        binOptions: {\n          cellSizePixels\n        }\n      });\n    }\n\n    if (changeFlags.viewportChanged) {\n      // Rerun aggregation on viewport change\n      this.state.aggregator.setNeedsUpdate();\n    }\n    return aggregatorChanged;\n  }\n\n  onAttributeChange(id: string) {\n    const {aggregator} = this.state;\n    switch (id) {\n      case 'positions':\n        aggregator.setNeedsUpdate();\n        break;\n\n      case 'counts':\n        aggregator.setNeedsUpdate(0);\n        break;\n\n      default:\n      // This should not happen\n    }\n  }\n\n  renderLayers(): LayersList | Layer | null {\n    const {aggregator} = this.state;\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n    const binAttribute = aggregator.getBins();\n    const weightAttribute = aggregator.getResult(0);\n\n    return new CellLayerClass(\n      this.props,\n      this.getSubLayerProps({\n        id: 'cell-layer'\n      }),\n      {\n        data: {\n          length: aggregator.binCount,\n          attributes: {\n            getBin: binAttribute,\n            getWeight: weightAttribute\n          }\n        },\n        // Data has changed shallowly, but we likely don't need to update the attributes\n        dataComparator: (data, oldData) => data.length === oldData.length,\n        updateTriggers: {\n          getBin: [binAttribute],\n          getWeight: [weightAttribute]\n        },\n        parameters: {\n          depthWriteEnabled: false,\n          ...this.props.parameters\n        },\n        // Evaluate domain at draw() time\n        colorDomain: () => this.props.colorDomain || aggregator.getResultDomain(0),\n        // Extensions are already handled by the GPUAggregator, do not pass it down\n        extensions: []\n      }\n    );\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): ScreenGridLayerPickingInfo<DataT> {\n    const info: ScreenGridLayerPickingInfo<DataT> = params.info;\n    const {index} = info;\n    if (index >= 0) {\n      const bin = this.state.aggregator.getBin(index);\n      let object: ScreenGridLayerPickingInfo<DataT>['object'];\n      if (bin) {\n        object = {\n          col: bin.id[0],\n          row: bin.id[1],\n          value: bin.value[0],\n          count: bin.count\n        };\n        if (bin.pointIndices) {\n          object.pointIndices = bin.pointIndices;\n          object.points = Array.isArray(this.props.data)\n            ? bin.pointIndices.map(i => (this.props.data as DataT[])[i])\n            : [];\n        }\n      }\n      info.object = object;\n    }\n\n    return info;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}