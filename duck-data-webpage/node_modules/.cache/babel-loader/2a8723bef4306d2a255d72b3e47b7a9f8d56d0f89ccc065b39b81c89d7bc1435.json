{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { getPolygonSignedArea } from '@math.gl/polygon';\n/**\n *\n * @param ring\n * @returns sum\n */\nexport function signedArea(ring) {\n  let sum = 0;\n  for (let i = 0, j = ring.length - 1, p1, p2; i < ring.length; j = i++) {\n    p1 = ring[i];\n    p2 = ring[j];\n    sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);\n  }\n  return sum;\n}\n/**\n * This function projects local coordinates in a\n * [0 - bufferSize, this.extent + bufferSize] range to a\n * [0 - (bufferSize / this.extent), 1 + (bufferSize / this.extent)] range.\n * The resulting extent would be 1.\n * @param line\n * @param feature\n */\nexport function convertToLocalCoordinates(coordinates, extent) {\n  if (Array.isArray(coordinates[0])) {\n    for (const subcoords of coordinates) {\n      convertToLocalCoordinates(subcoords, extent);\n    }\n    return;\n  }\n  // Just a point\n  const p = coordinates;\n  p[0] /= extent;\n  p[1] /= extent;\n}\n/**\n * For the binary code path, the feature data is just\n * one big flat array, so we just divide each value\n * @param data\n * @param feature\n */\nexport function convertToLocalCoordinatesFlat(data, extent) {\n  for (let i = 0; i < data.length; ++i) {\n    data[i] /= extent;\n  }\n}\n/**\n * Projects local tile coordinates to lngLat in place.\n * @param points\n * @param tileIndex\n */\nexport function projectToLngLat(line, tileIndex, extent) {\n  if (typeof line[0][0] !== 'number') {\n    for (const point of line) {\n      // @ts-expect-error\n      projectToLngLat(point, tileIndex, extent);\n    }\n    return;\n  }\n  const size = extent * Math.pow(2, tileIndex.z);\n  const x0 = extent * tileIndex.x;\n  const y0 = extent * tileIndex.y;\n  for (let j = 0; j < line.length; j++) {\n    const p = line[j];\n    p[0] = (p[0] + x0) * 360 / size - 180;\n    const y2 = 180 - (p[1] + y0) * 360 / size;\n    p[1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n  }\n}\n/**\n * Projects local tile coordinates to lngLat in place.\n * @param points\n * @param tileIndex\nexport function projectTileCoordinatesToLngLat(\n  points: number[][],\n  tileIndex: {x: number; y: number; z: number},\n  extent: number\n): void {\n  const {x, y, z} = tileIndex;\n  const size = extent * Math.pow(2, z);\n  const x0 = extent * x;\n  const y0 = extent * y;\n\n  for (const p of points) {\n    p[0] = ((p[0] + x0) * 360) / size - 180;\n    const y2 = 180 - ((p[1] + y0) * 360) / size;\n    p[1] = (360 / Math.PI) * Math.atan(Math.exp((y2 * Math.PI) / 180)) - 90;\n  }\n}\n */\n/**\n *\n * @param data\n * @param x0\n * @param y0\n * @param size\n */\nexport function projectToLngLatFlat(data, tileIndex, extent) {\n  const {\n    x,\n    y,\n    z\n  } = tileIndex;\n  const size = extent * Math.pow(2, z);\n  const x0 = extent * x;\n  const y0 = extent * y;\n  for (let j = 0, jl = data.length; j < jl; j += 2) {\n    data[j] = (data[j] + x0) * 360 / size - 180;\n    const y2 = 180 - (data[j + 1] + y0) * 360 / size;\n    data[j + 1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n  }\n}\n/**\n * Classifies an array of rings into polygons with outer rings and holes\n * @param rings\n * @returns polygons\n */\nexport function classifyRings(rings) {\n  const len = rings.length;\n  if (len <= 1) return [rings];\n  const polygons = [];\n  let polygon;\n  let ccw;\n  for (let i = 0; i < len; i++) {\n    const area = signedArea(rings[i]);\n    if (area === 0) continue; // eslint-disable-line no-continue\n    if (ccw === undefined) ccw = area < 0;\n    if (ccw === area < 0) {\n      if (polygon) polygons.push(polygon);\n      polygon = [rings[i]];\n    } else if (polygon) polygon.push(rings[i]);\n  }\n  if (polygon) polygons.push(polygon);\n  return polygons;\n}\n/**\n * Classifies an array of rings into polygons with outer rings and holes\n * The function also detects holes which have zero area and\n * removes them. In doing so it modifies the input\n * `geom.data` array to remove the unneeded data\n *\n * @param geometry\n * @returns object\n */\n// eslint-disable-next-line max-statements\nexport function classifyRingsFlat(geom) {\n  const len = geom.indices.length;\n  const type = 'Polygon';\n  if (len <= 1) {\n    return {\n      type,\n      data: geom.data,\n      areas: [[getPolygonSignedArea(geom.data)]],\n      indices: [geom.indices]\n    };\n  }\n  const areas = [];\n  const polygons = [];\n  let ringAreas = [];\n  let polygon = [];\n  let ccw;\n  let offset = 0;\n  for (let endIndex, i = 0, startIndex; i < len; i++) {\n    startIndex = geom.indices[i] - offset;\n    endIndex = geom.indices[i + 1] - offset || geom.data.length;\n    const shape = geom.data.slice(startIndex, endIndex);\n    const area = getPolygonSignedArea(shape);\n    if (area === 0) {\n      // This polygon has no area, so remove it from the shape\n      // Remove the section from the data array\n      const before = geom.data.slice(0, startIndex);\n      const after = geom.data.slice(endIndex);\n      geom.data = before.concat(after);\n      // Need to offset any remaining indices as we have\n      // modified the data buffer\n      offset += endIndex - startIndex;\n      // Do not add this index to the output and process next shape\n      continue; // eslint-disable-line no-continue\n    }\n    if (ccw === undefined) ccw = area < 0;\n    if (ccw === area < 0) {\n      if (polygon.length) {\n        areas.push(ringAreas);\n        polygons.push(polygon);\n      }\n      polygon = [startIndex];\n      ringAreas = [area];\n    } else {\n      ringAreas.push(area);\n      polygon.push(startIndex);\n    }\n  }\n  if (ringAreas) areas.push(ringAreas);\n  if (polygon.length) polygons.push(polygon);\n  return {\n    type,\n    areas,\n    indices: polygons,\n    data: geom.data\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}