{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { WebGLBinSorter } from \"./webgl-bin-sorter.js\";\nimport { WebGLAggregationTransform } from \"./webgl-aggregation-transform.js\";\nimport { _deepEqual as deepEqual, log } from '@deck.gl/core';\n/** An Aggregator implementation that calculates aggregation on the GPU */\nexport class WebGLAggregator {\n  /** Checks if the current device supports GPU aggregation */\n  static isSupported(device) {\n    return device.features.has('float32-renderable-webgl') && device.features.has('texture-blend-float-webgl');\n  }\n  constructor(device, props) {\n    this.binCount = 0;\n    /** Cached outputs */\n    this.binIds = null;\n    this.results = [];\n    this.device = device;\n    this.dimensions = props.dimensions;\n    this.channelCount = props.channelCount;\n    this.props = {\n      ...props,\n      pointCount: 0,\n      binIdRange: [[0, 0]],\n      operations: [],\n      attributes: {},\n      binOptions: {}\n    };\n    this.needsUpdate = new Array(this.channelCount).fill(true);\n    this.binSorter = new WebGLBinSorter(device, props);\n    this.aggregationTransform = new WebGLAggregationTransform(device, props);\n    this.setProps(props);\n  }\n  getBins() {\n    const buffer = this.aggregationTransform.binBuffer;\n    if (!buffer) {\n      return null;\n    }\n    if (this.binIds?.buffer !== buffer) {\n      // deck.gl Attribute.setBinaryValue uses shallow comparison to determine if attribute value has changed\n      // For performance, only create a new binary attribute descriptor when Buffer changes\n      this.binIds = {\n        buffer,\n        type: 'float32',\n        size: this.dimensions\n      };\n    }\n    return this.binIds;\n  }\n  /** Returns an accessor to the output for a given channel. */\n  getResult(channel) {\n    const buffer = this.aggregationTransform.valueBuffer;\n    if (!buffer || channel >= this.channelCount) {\n      return null;\n    }\n    if (this.results[channel]?.buffer !== buffer) {\n      this.results[channel] = {\n        buffer,\n        type: 'float32',\n        size: 1,\n        stride: this.channelCount * 4,\n        offset: channel * 4\n      };\n    }\n    return this.results[channel];\n  }\n  /** Returns the [min, max] of aggregated values for a given channel. */\n  getResultDomain(channel) {\n    return this.aggregationTransform.domains[channel];\n  }\n  /** Returns the information for a given bin. */\n  getBin(index) {\n    if (index < 0 || index >= this.binCount) {\n      return null;\n    }\n    const {\n      binIdRange\n    } = this.props;\n    let id;\n    if (this.dimensions === 1) {\n      id = [index + binIdRange[0][0]];\n    } else {\n      const [[x0, x1], [y0]] = binIdRange;\n      const width = x1 - x0;\n      id = [index % width + x0, Math.floor(index / width) + y0];\n    }\n    const pixel = this.binSorter.getBinValues(index);\n    if (!pixel) {\n      return null;\n    }\n    const count = pixel[3];\n    const value = [];\n    for (let channel = 0; channel < this.channelCount; channel++) {\n      const operation = this.props.operations[channel];\n      if (operation === 'COUNT') {\n        value[channel] = count;\n      } else if (count === 0) {\n        value[channel] = NaN;\n      } else {\n        value[channel] = operation === 'MEAN' ? pixel[channel] / count : pixel[channel];\n      }\n    }\n    return {\n      id,\n      value,\n      count\n    };\n  }\n  /** Release GPU resources */\n  destroy() {\n    this.binSorter.destroy();\n    this.aggregationTransform.destroy();\n  }\n  /** Update aggregation props. Normalize prop values and set change flags. */\n  setProps(props) {\n    const oldProps = this.props;\n    // Update local settings. These will set the flag this._needsUpdate\n    if ('binIdRange' in props && !deepEqual(props.binIdRange, oldProps.binIdRange, 2)) {\n      const binIdRange = props.binIdRange;\n      log.assert(binIdRange.length === this.dimensions);\n      if (this.dimensions === 1) {\n        const [[x0, x1]] = binIdRange;\n        this.binCount = x1 - x0;\n      } else {\n        const [[x0, x1], [y0, y1]] = binIdRange;\n        this.binCount = (x1 - x0) * (y1 - y0);\n      }\n      this.binSorter.setDimensions(this.binCount, binIdRange);\n      this.aggregationTransform.setDimensions(this.binCount, binIdRange);\n      this.setNeedsUpdate();\n    }\n    if (props.operations) {\n      for (let channel = 0; channel < this.channelCount; channel++) {\n        if (props.operations[channel] !== oldProps.operations[channel]) {\n          this.setNeedsUpdate(channel);\n        }\n      }\n    }\n    if (props.pointCount !== undefined && props.pointCount !== oldProps.pointCount) {\n      this.binSorter.setModelProps({\n        vertexCount: props.pointCount\n      });\n      this.setNeedsUpdate();\n    }\n    if (props.binOptions) {\n      if (!deepEqual(props.binOptions, oldProps.binOptions, 2)) {\n        this.setNeedsUpdate();\n      }\n      this.binSorter.model.shaderInputs.setProps({\n        binOptions: props.binOptions\n      });\n    }\n    if (props.attributes) {\n      const attributeBuffers = {};\n      const constantAttributes = {};\n      for (const attribute of Object.values(props.attributes)) {\n        for (const [attributeName, value] of Object.entries(attribute.getValue())) {\n          if (ArrayBuffer.isView(value)) {\n            constantAttributes[attributeName] = value;\n          } else if (value) {\n            attributeBuffers[attributeName] = value;\n          }\n        }\n      }\n      this.binSorter.setModelProps({\n        attributes: attributeBuffers,\n        constantAttributes\n      });\n    }\n    if (props.shaderModuleProps) {\n      this.binSorter.setModelProps({\n        shaderModuleProps: props.shaderModuleProps\n      });\n    }\n    Object.assign(this.props, props);\n  }\n  /** Flags a channel to need update.\n   * This is called internally by setProps() if certain props change\n   * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed\n   * the underlying buffers could have been updated and require rerunning the aggregation\n   * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.\n   */\n  setNeedsUpdate(channel) {\n    if (channel === undefined) {\n      this.needsUpdate.fill(true);\n    } else {\n      this.needsUpdate[channel] = true;\n    }\n  }\n  update() {}\n  /** Run aggregation */\n  preDraw() {\n    if (!this.needsUpdate.some(Boolean)) {\n      return;\n    }\n    const {\n      operations\n    } = this.props;\n    const operationsToUpdate = this.needsUpdate.map((needsUpdate, i) => needsUpdate ? operations[i] : null);\n    // Render data to bins\n    this.binSorter.update(operationsToUpdate);\n    // Read to buffer and calculate domain\n    this.aggregationTransform.update(this.binSorter.texture, operations);\n    for (let i = 0; i < this.channelCount; i++) {\n      if (this.needsUpdate[i]) {\n        this.needsUpdate[i] = false;\n        this.props.onUpdate?.({\n          channel: i\n        });\n      }\n    }\n    // Uncomment to debug\n    // console.log('binsFBO', new Float32Array(this.device.readPixelsToArrayWebGL(this.binSorter.texture!).buffer));\n    // console.log('binsBuffer', new Float32Array(this.aggregationTransform.binBuffer?.readSyncWebGL().buffer!));\n    // console.log('resultBuffer', new Float32Array(this.aggregationTransform.valueBuffer?.readSyncWebGL().buffer!));\n  }\n}\n//# sourceMappingURL=webgl-aggregator.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}