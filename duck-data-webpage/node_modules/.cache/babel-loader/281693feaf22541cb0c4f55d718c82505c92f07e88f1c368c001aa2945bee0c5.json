{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Convert binary geometry representation to GeoJSON\n * @param data   geometry data in binary representation\n * @param options\n * @param options.type  Input data type: Point, LineString, or Polygon\n * @param options.featureId  Global feature id. If specified, only a single feature is extracted\n * @return GeoJSON objects\n */\nexport function binaryToGeojson(data, options) {\n  const globalFeatureId = options?.globalFeatureId;\n  if (globalFeatureId !== undefined) {\n    return getSingleFeature(data, globalFeatureId);\n  }\n  return parseFeatures(data, options?.type);\n}\n/**\n * Return a single feature from a binary geometry representation as GeoJSON\n * @param data   geometry data in binary representation\n * @return GeoJSON feature\n */\nfunction getSingleFeature(data, globalFeatureId) {\n  const dataArray = normalizeInput(data);\n  for (const data of dataArray) {\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n    // Scan through data until we find matching feature\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n      if (currValue === lastValue) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {\n        return parseFeature(data, lastIndex, i);\n      }\n      lastIndex = i;\n      lastValue = currValue;\n    }\n    if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {\n      return parseFeature(data, lastIndex, data.featureIds.value.length);\n    }\n  }\n  throw new Error(`featureId:${globalFeatureId} not found`);\n}\nfunction parseFeatures(data, type) {\n  const dataArray = normalizeInput(data, type);\n  return parseFeatureCollection(dataArray);\n}\n/** Parse input binary data and return a valid GeoJSON geometry object */\nexport function binaryToGeometry(data, startIndex, endIndex) {\n  switch (data.type) {\n    case 'Point':\n      return pointToGeoJson(data, startIndex, endIndex);\n    case 'LineString':\n      return lineStringToGeoJson(data, startIndex, endIndex);\n    case 'Polygon':\n      return polygonToGeoJson(data, startIndex, endIndex);\n    default:\n      const unexpectedInput = data;\n      throw new Error(`Unsupported geometry type: ${unexpectedInput?.type}`);\n  }\n}\n// Normalize features\n// Return an array of data objects, each of which have a type key\nfunction normalizeInput(data, type) {\n  const features = [];\n  if (data.points) {\n    data.points.type = 'Point';\n    features.push(data.points);\n  }\n  if (data.lines) {\n    data.lines.type = 'LineString';\n    features.push(data.lines);\n  }\n  if (data.polygons) {\n    data.polygons.type = 'Polygon';\n    features.push(data.polygons);\n  }\n  return features;\n}\n/** Parse input binary data and return an array of GeoJSON Features */\nfunction parseFeatureCollection(dataArray) {\n  const features = [];\n  for (const data of dataArray) {\n    if (data.featureIds.value.length === 0) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n    // Need to deduce start, end indices of each feature\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n      if (currValue === lastValue) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      features.push(parseFeature(data, lastIndex, i));\n      lastIndex = i;\n      lastValue = currValue;\n    }\n    // Last feature\n    features.push(parseFeature(data, lastIndex, data.featureIds.value.length));\n  }\n  return features;\n}\n/** Parse input binary data and return a single GeoJSON Feature */\nfunction parseFeature(data, startIndex, endIndex) {\n  const geometry = binaryToGeometry(data, startIndex, endIndex);\n  const properties = parseProperties(data, startIndex, endIndex);\n  const fields = parseFields(data, startIndex, endIndex);\n  return {\n    type: 'Feature',\n    geometry,\n    properties,\n    ...fields\n  };\n}\n/** Parse input binary data and return an object of fields */\nfunction parseFields(data, startIndex = 0, endIndex) {\n  return data.fields && data.fields[data.featureIds.value[startIndex]];\n}\n/** Parse input binary data and return an object of properties */\nfunction parseProperties(data, startIndex = 0, endIndex) {\n  const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);\n  for (const key in data.numericProps) {\n    properties[key] = data.numericProps[key].value[startIndex];\n  }\n  return properties;\n}\n/** Parse binary data of type Polygon */\nfunction polygonToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {\n  const {\n    positions\n  } = data;\n  const polygonIndices = data.polygonIndices.value.filter(x => x >= startIndex && x <= endIndex);\n  const primitivePolygonIndices = data.primitivePolygonIndices.value.filter(x => x >= startIndex && x <= endIndex);\n  const multi = polygonIndices.length > 2;\n  // Polygon\n  if (!multi) {\n    const coordinates = [];\n    for (let i = 0; i < primitivePolygonIndices.length - 1; i++) {\n      const startRingIndex = primitivePolygonIndices[i];\n      const endRingIndex = primitivePolygonIndices[i + 1];\n      const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);\n      coordinates.push(ringCoordinates);\n    }\n    return {\n      type: 'Polygon',\n      coordinates\n    };\n  }\n  // MultiPolygon\n  const coordinates = [];\n  for (let i = 0; i < polygonIndices.length - 1; i++) {\n    const startPolygonIndex = polygonIndices[i];\n    const endPolygonIndex = polygonIndices[i + 1];\n    const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex).coordinates;\n    coordinates.push(polygonCoordinates);\n  }\n  return {\n    type: 'MultiPolygon',\n    coordinates\n  };\n}\n/** Parse binary data of type LineString */\nfunction lineStringToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {\n  const {\n    positions\n  } = data;\n  const pathIndices = data.pathIndices.value.filter(x => x >= startIndex && x <= endIndex);\n  const multi = pathIndices.length > 2;\n  if (!multi) {\n    const coordinates = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);\n    return {\n      type: 'LineString',\n      coordinates\n    };\n  }\n  const coordinates = [];\n  for (let i = 0; i < pathIndices.length - 1; i++) {\n    const ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);\n    coordinates.push(ringCoordinates);\n  }\n  return {\n    type: 'MultiLineString',\n    coordinates\n  };\n}\n/** Parse binary data of type Point */\nfunction pointToGeoJson(data, startIndex, endIndex) {\n  const {\n    positions\n  } = data;\n  const coordinates = ringToGeoJson(positions, startIndex, endIndex);\n  const multi = coordinates.length > 1;\n  if (multi) {\n    return {\n      type: 'MultiPoint',\n      coordinates\n    };\n  }\n  return {\n    type: 'Point',\n    coordinates: coordinates[0]\n  };\n}\n/**\n * Parse a linear ring of positions to a GeoJSON linear ring\n *\n * @param positions Positions TypedArray\n * @param startIndex Start index to include in ring\n * @param endIndex End index to include in ring\n * @returns GeoJSON ring\n */\nfunction ringToGeoJson(positions, startIndex, endIndex) {\n  startIndex = startIndex || 0;\n  endIndex = endIndex || positions.value.length / positions.size;\n  const ringCoordinates = [];\n  for (let j = startIndex; j < endIndex; j++) {\n    const coord = Array();\n    for (let k = j * positions.size; k < (j + 1) * positions.size; k++) {\n      coord.push(Number(positions.value[k]));\n    }\n    ringCoordinates.push(coord);\n  }\n  return ringCoordinates;\n}","map":{"version":3,"names":["binaryToGeojson","data","options","globalFeatureId","undefined","getSingleFeature","parseFeatures","type","dataArray","normalizeInput","lastIndex","lastValue","featureIds","value","i","length","currValue","globalFeatureIds","parseFeature","Error","parseFeatureCollection","binaryToGeometry","startIndex","endIndex","pointToGeoJson","lineStringToGeoJson","polygonToGeoJson","unexpectedInput","features","points","push","lines","polygons","geometry","properties","parseProperties","fields","parseFields","Object","assign","key","numericProps","Infinity","positions","polygonIndices","filter","x","primitivePolygonIndices","multi","coordinates","startRingIndex","endRingIndex","ringCoordinates","ringToGeoJson","startPolygonIndex","endPolygonIndex","polygonCoordinates","pathIndices","size","j","coord","Array","k","Number"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/gis/dist/lib/binary-features/binary-to-geojson.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Convert binary geometry representation to GeoJSON\n * @param data   geometry data in binary representation\n * @param options\n * @param options.type  Input data type: Point, LineString, or Polygon\n * @param options.featureId  Global feature id. If specified, only a single feature is extracted\n * @return GeoJSON objects\n */\nexport function binaryToGeojson(data, options) {\n    const globalFeatureId = options?.globalFeatureId;\n    if (globalFeatureId !== undefined) {\n        return getSingleFeature(data, globalFeatureId);\n    }\n    return parseFeatures(data, options?.type);\n}\n/**\n * Return a single feature from a binary geometry representation as GeoJSON\n * @param data   geometry data in binary representation\n * @return GeoJSON feature\n */\nfunction getSingleFeature(data, globalFeatureId) {\n    const dataArray = normalizeInput(data);\n    for (const data of dataArray) {\n        let lastIndex = 0;\n        let lastValue = data.featureIds.value[0];\n        // Scan through data until we find matching feature\n        for (let i = 0; i < data.featureIds.value.length; i++) {\n            const currValue = data.featureIds.value[i];\n            if (currValue === lastValue) {\n                // eslint-disable-next-line no-continue\n                continue;\n            }\n            if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {\n                return parseFeature(data, lastIndex, i);\n            }\n            lastIndex = i;\n            lastValue = currValue;\n        }\n        if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {\n            return parseFeature(data, lastIndex, data.featureIds.value.length);\n        }\n    }\n    throw new Error(`featureId:${globalFeatureId} not found`);\n}\nfunction parseFeatures(data, type) {\n    const dataArray = normalizeInput(data, type);\n    return parseFeatureCollection(dataArray);\n}\n/** Parse input binary data and return a valid GeoJSON geometry object */\nexport function binaryToGeometry(data, startIndex, endIndex) {\n    switch (data.type) {\n        case 'Point':\n            return pointToGeoJson(data, startIndex, endIndex);\n        case 'LineString':\n            return lineStringToGeoJson(data, startIndex, endIndex);\n        case 'Polygon':\n            return polygonToGeoJson(data, startIndex, endIndex);\n        default:\n            const unexpectedInput = data;\n            throw new Error(`Unsupported geometry type: ${unexpectedInput?.type}`);\n    }\n}\n// Normalize features\n// Return an array of data objects, each of which have a type key\nfunction normalizeInput(data, type) {\n    const features = [];\n    if (data.points) {\n        data.points.type = 'Point';\n        features.push(data.points);\n    }\n    if (data.lines) {\n        data.lines.type = 'LineString';\n        features.push(data.lines);\n    }\n    if (data.polygons) {\n        data.polygons.type = 'Polygon';\n        features.push(data.polygons);\n    }\n    return features;\n}\n/** Parse input binary data and return an array of GeoJSON Features */\nfunction parseFeatureCollection(dataArray) {\n    const features = [];\n    for (const data of dataArray) {\n        if (data.featureIds.value.length === 0) {\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n        let lastIndex = 0;\n        let lastValue = data.featureIds.value[0];\n        // Need to deduce start, end indices of each feature\n        for (let i = 0; i < data.featureIds.value.length; i++) {\n            const currValue = data.featureIds.value[i];\n            if (currValue === lastValue) {\n                // eslint-disable-next-line no-continue\n                continue;\n            }\n            features.push(parseFeature(data, lastIndex, i));\n            lastIndex = i;\n            lastValue = currValue;\n        }\n        // Last feature\n        features.push(parseFeature(data, lastIndex, data.featureIds.value.length));\n    }\n    return features;\n}\n/** Parse input binary data and return a single GeoJSON Feature */\nfunction parseFeature(data, startIndex, endIndex) {\n    const geometry = binaryToGeometry(data, startIndex, endIndex);\n    const properties = parseProperties(data, startIndex, endIndex);\n    const fields = parseFields(data, startIndex, endIndex);\n    return { type: 'Feature', geometry, properties, ...fields };\n}\n/** Parse input binary data and return an object of fields */\nfunction parseFields(data, startIndex = 0, endIndex) {\n    return data.fields && data.fields[data.featureIds.value[startIndex]];\n}\n/** Parse input binary data and return an object of properties */\nfunction parseProperties(data, startIndex = 0, endIndex) {\n    const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);\n    for (const key in data.numericProps) {\n        properties[key] = data.numericProps[key].value[startIndex];\n    }\n    return properties;\n}\n/** Parse binary data of type Polygon */\nfunction polygonToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {\n    const { positions } = data;\n    const polygonIndices = data.polygonIndices.value.filter((x) => x >= startIndex && x <= endIndex);\n    const primitivePolygonIndices = data.primitivePolygonIndices.value.filter((x) => x >= startIndex && x <= endIndex);\n    const multi = polygonIndices.length > 2;\n    // Polygon\n    if (!multi) {\n        const coordinates = [];\n        for (let i = 0; i < primitivePolygonIndices.length - 1; i++) {\n            const startRingIndex = primitivePolygonIndices[i];\n            const endRingIndex = primitivePolygonIndices[i + 1];\n            const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);\n            coordinates.push(ringCoordinates);\n        }\n        return { type: 'Polygon', coordinates };\n    }\n    // MultiPolygon\n    const coordinates = [];\n    for (let i = 0; i < polygonIndices.length - 1; i++) {\n        const startPolygonIndex = polygonIndices[i];\n        const endPolygonIndex = polygonIndices[i + 1];\n        const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex).coordinates;\n        coordinates.push(polygonCoordinates);\n    }\n    return { type: 'MultiPolygon', coordinates };\n}\n/** Parse binary data of type LineString */\nfunction lineStringToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {\n    const { positions } = data;\n    const pathIndices = data.pathIndices.value.filter((x) => x >= startIndex && x <= endIndex);\n    const multi = pathIndices.length > 2;\n    if (!multi) {\n        const coordinates = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);\n        return { type: 'LineString', coordinates };\n    }\n    const coordinates = [];\n    for (let i = 0; i < pathIndices.length - 1; i++) {\n        const ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);\n        coordinates.push(ringCoordinates);\n    }\n    return { type: 'MultiLineString', coordinates };\n}\n/** Parse binary data of type Point */\nfunction pointToGeoJson(data, startIndex, endIndex) {\n    const { positions } = data;\n    const coordinates = ringToGeoJson(positions, startIndex, endIndex);\n    const multi = coordinates.length > 1;\n    if (multi) {\n        return { type: 'MultiPoint', coordinates };\n    }\n    return { type: 'Point', coordinates: coordinates[0] };\n}\n/**\n * Parse a linear ring of positions to a GeoJSON linear ring\n *\n * @param positions Positions TypedArray\n * @param startIndex Start index to include in ring\n * @param endIndex End index to include in ring\n * @returns GeoJSON ring\n */\nfunction ringToGeoJson(positions, startIndex, endIndex) {\n    startIndex = startIndex || 0;\n    endIndex = endIndex || positions.value.length / positions.size;\n    const ringCoordinates = [];\n    for (let j = startIndex; j < endIndex; j++) {\n        const coord = Array();\n        for (let k = j * positions.size; k < (j + 1) * positions.size; k++) {\n            coord.push(Number(positions.value[k]));\n        }\n        ringCoordinates.push(coord);\n    }\n    return ringCoordinates;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}