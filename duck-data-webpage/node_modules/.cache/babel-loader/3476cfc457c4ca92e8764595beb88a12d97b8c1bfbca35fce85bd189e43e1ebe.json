{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { MODULE_INJECTORS_VS, MODULE_INJECTORS_FS } from \"../../module-injectors.js\";\nimport { assert } from \"../utils/assert.js\";\n// TODO - experimental\nconst MODULE_INJECTORS = {\n  vertex: MODULE_INJECTORS_VS,\n  fragment: MODULE_INJECTORS_FS\n};\nconst REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\nconst REGEX_END_OF_MAIN = /}\\n?[^{}]*$/; // End of main, assumes main is last function\nconst fragments = [];\nexport const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__';\n/**\n *\n */\nexport function normalizeInjections(injections) {\n  const result = {\n    vertex: {},\n    fragment: {}\n  };\n  for (const hook in injections) {\n    let injection = injections[hook];\n    const stage = getHookStage(hook);\n    if (typeof injection === 'string') {\n      injection = {\n        order: 0,\n        injection\n      };\n    }\n    result[stage][hook] = injection;\n  }\n  return result;\n}\nfunction getHookStage(hook) {\n  const type = hook.slice(0, 2);\n  switch (type) {\n    case 'vs':\n      return 'vertex';\n    case 'fs':\n      return 'fragment';\n    default:\n      throw new Error(type);\n  }\n}\n/**\n// A minimal shader injection/templating system.\n// RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/shader-injection-rfc.md\n * @param source\n * @param type\n * @param inject\n * @param injectStandardStubs\n * @returns\n */\n// eslint-disable-next-line complexity\nexport function injectShader(source, stage, inject, injectStandardStubs = false) {\n  const isVertex = stage === 'vertex';\n  for (const key in inject) {\n    const fragmentData = inject[key];\n    fragmentData.sort((a, b) => a.order - b.order);\n    fragments.length = fragmentData.length;\n    for (let i = 0, len = fragmentData.length; i < len; ++i) {\n      fragments[i] = fragmentData[i].injection;\n    }\n    const fragmentString = `${fragments.join('\\n')}\\n`;\n    switch (key) {\n      // declarations are injected before the main function\n      case 'vs:#decl':\n        if (isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      // inject code at the beginning of the main function\n      case 'vs:#main-start':\n        if (isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      // inject code at the end of main function\n      case 'vs:#main-end':\n        if (isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n      // declarations are injected before the main function\n      case 'fs:#decl':\n        if (!isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      // inject code at the beginning of the main function\n      case 'fs:#main-start':\n        if (!isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      // inject code at the end of main function\n      case 'fs:#main-end':\n        if (!isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n      default:\n        // TODO(Tarek): I think this usage should be deprecated.\n        // inject code after key, leaving key in place\n        source = source.replace(key, match => match + fragmentString);\n    }\n  }\n  // Remove if it hasn't already been replaced\n  source = source.replace(DECLARATION_INJECT_MARKER, '');\n  // Finally, if requested, insert an automatic module injector chunk\n  if (injectStandardStubs) {\n    source = source.replace(/\\}\\s*$/, match => match + MODULE_INJECTORS[stage]);\n  }\n  return source;\n}\n// Takes an array of inject objects and combines them into one\nexport function combineInjects(injects) {\n  const result = {};\n  assert(Array.isArray(injects) && injects.length > 1);\n  injects.forEach(inject => {\n    for (const key in inject) {\n      result[key] = result[key] ? `${result[key]}\\n${inject[key]}` : inject[key];\n    }\n  });\n  return result;\n}","map":{"version":3,"names":["MODULE_INJECTORS_VS","MODULE_INJECTORS_FS","assert","MODULE_INJECTORS","vertex","fragment","REGEX_START_OF_MAIN","REGEX_END_OF_MAIN","fragments","DECLARATION_INJECT_MARKER","normalizeInjections","injections","result","hook","injection","stage","getHookStage","order","type","slice","Error","injectShader","source","inject","injectStandardStubs","isVertex","key","fragmentData","sort","a","b","length","i","len","fragmentString","join","replace","match","combineInjects","injects","Array","isArray","forEach"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\shadertools\\src\\lib\\shader-assembly\\shader-injections.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {MODULE_INJECTORS_VS, MODULE_INJECTORS_FS} from '../../module-injectors';\nimport {assert} from '../utils/assert';\n\n// TODO - experimental\nconst MODULE_INJECTORS = {\n  vertex: MODULE_INJECTORS_VS,\n  fragment: MODULE_INJECTORS_FS\n};\n\nconst REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\nconst REGEX_END_OF_MAIN = /}\\n?[^{}]*$/; // End of main, assumes main is last function\nconst fragments: string[] = [];\n\nexport const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__';\n\n/**\n *\n */\nexport type ShaderInjection = {\n  injection: string;\n  order: number;\n};\n\n/**\n *  ShaderInjections, parsed and split per shader\n */\nexport type ShaderInjections = {\n  vertex: Record<string, ShaderInjection>;\n  fragment: Record<string, ShaderInjection>;\n};\n\n/**\n *\n */\nexport function normalizeInjections(\n  injections: Record<string, string | ShaderInjection>\n): ShaderInjections {\n  const result: ShaderInjections = {vertex: {}, fragment: {}};\n\n  for (const hook in injections) {\n    let injection = injections[hook];\n    const stage = getHookStage(hook);\n    if (typeof injection === 'string') {\n      injection = {\n        order: 0,\n        injection\n      };\n    }\n\n    result[stage][hook] = injection;\n  }\n\n  return result;\n}\n\nfunction getHookStage(hook: string): 'vertex' | 'fragment' {\n  const type = hook.slice(0, 2);\n  switch (type) {\n    case 'vs':\n      return 'vertex';\n    case 'fs':\n      return 'fragment';\n    default:\n      throw new Error(type);\n  }\n}\n\n/**\n// A minimal shader injection/templating system.\n// RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/shader-injection-rfc.md\n * @param source \n * @param type \n * @param inject \n * @param injectStandardStubs \n * @returns \n */\n// eslint-disable-next-line complexity\nexport function injectShader(\n  source: string,\n  stage: 'vertex' | 'fragment',\n  inject: Record<string, ShaderInjection[]>,\n  injectStandardStubs = false\n): string {\n  const isVertex = stage === 'vertex';\n\n  for (const key in inject) {\n    const fragmentData = inject[key];\n    fragmentData.sort((a: ShaderInjection, b: ShaderInjection): number => a.order - b.order);\n    fragments.length = fragmentData.length;\n    for (let i = 0, len = fragmentData.length; i < len; ++i) {\n      fragments[i] = fragmentData[i].injection;\n    }\n    const fragmentString = `${fragments.join('\\n')}\\n`;\n    switch (key) {\n      // declarations are injected before the main function\n      case 'vs:#decl':\n        if (isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      // inject code at the beginning of the main function\n      case 'vs:#main-start':\n        if (isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, (match: string) => match + fragmentString);\n        }\n        break;\n      // inject code at the end of main function\n      case 'vs:#main-end':\n        if (isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, (match: string) => fragmentString + match);\n        }\n        break;\n      // declarations are injected before the main function\n      case 'fs:#decl':\n        if (!isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      // inject code at the beginning of the main function\n      case 'fs:#main-start':\n        if (!isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, (match: string) => match + fragmentString);\n        }\n        break;\n      // inject code at the end of main function\n      case 'fs:#main-end':\n        if (!isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, (match: string) => fragmentString + match);\n        }\n        break;\n\n      default:\n        // TODO(Tarek): I think this usage should be deprecated.\n\n        // inject code after key, leaving key in place\n        source = source.replace(key, (match: string) => match + fragmentString);\n    }\n  }\n\n  // Remove if it hasn't already been replaced\n  source = source.replace(DECLARATION_INJECT_MARKER, '');\n\n  // Finally, if requested, insert an automatic module injector chunk\n  if (injectStandardStubs) {\n    source = source.replace(/\\}\\s*$/, (match: string) => match + MODULE_INJECTORS[stage]);\n  }\n\n  return source;\n}\n\n// Takes an array of inject objects and combines them into one\nexport function combineInjects(injects: any[]): Record<string, string> {\n  const result: Record<string, string> = {};\n  assert(Array.isArray(injects) && injects.length > 1);\n  injects.forEach(inject => {\n    for (const key in inject) {\n      result[key] = result[key] ? `${result[key]}\\n${inject[key]}` : inject[key];\n    }\n  });\n  return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}