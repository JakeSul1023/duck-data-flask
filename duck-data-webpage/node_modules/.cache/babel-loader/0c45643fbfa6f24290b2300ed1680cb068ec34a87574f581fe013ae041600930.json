{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { decodeRGB565, GL } from '@loaders.gl/math';\n/* eslint-disable complexity*/\nexport function normalize3DTileColorAttribute(tile, colors, batchTable) {\n  // no colors defined\n  if (!colors && (!tile || !tile.batchIds || !batchTable)) {\n    return null;\n  }\n  const {\n    batchIds,\n    isRGB565,\n    pointCount = 0\n  } = tile;\n  // Batch table, look up colors in table\n  if (batchIds && batchTable) {\n    const colorArray = new Uint8ClampedArray(pointCount * 3);\n    for (let i = 0; i < pointCount; i++) {\n      const batchId = batchIds[i];\n      // TODO figure out what is `dimensions` used for\n      const dimensions = batchTable.getProperty(batchId, 'dimensions');\n      const color = dimensions.map(d => d * 255);\n      colorArray[i * 3] = color[0];\n      colorArray[i * 3 + 1] = color[1];\n      colorArray[i * 3 + 2] = color[2];\n    }\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n  // RGB565 case, convert to RGB\n  if (colors && isRGB565) {\n    const colorArray = new Uint8ClampedArray(pointCount * 3);\n    for (let i = 0; i < pointCount; i++) {\n      const color = decodeRGB565(colors[i]);\n      colorArray[i * 3] = color[0];\n      colorArray[i * 3 + 1] = color[1];\n      colorArray[i * 3 + 2] = color[2];\n    }\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n  // RGB case (tile.isTranslucent)\n  if (colors && colors.length === pointCount * 3) {\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colors,\n      size: 3,\n      normalized: true\n    };\n  }\n  // DEFAULT: RGBA case\n  return {\n    type: GL.UNSIGNED_BYTE,\n    value: colors || new Uint8ClampedArray(),\n    size: 4,\n    normalized: true\n  };\n}\n/* eslint-enable complexity*/","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}