{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@luma.gl/core';\nimport { lightingUniformsGLSL } from \"./lighting-uniforms-glsl.js\";\nimport { lightingUniformsWGSL } from \"./lighting-uniforms-wgsl.js\";\n/** Max number of supported lights (in addition to ambient light */\nconst MAX_LIGHTS = 3;\n/** Whether to divide */\nconst COLOR_FACTOR = 255.0;\n/** Shader type field for lights */\n// eslint-disable-next-line no-shadow\nexport var LIGHT_TYPE;\n(function (LIGHT_TYPE) {\n  LIGHT_TYPE[LIGHT_TYPE[\"POINT\"] = 0] = \"POINT\";\n  LIGHT_TYPE[LIGHT_TYPE[\"DIRECTIONAL\"] = 1] = \"DIRECTIONAL\";\n})(LIGHT_TYPE || (LIGHT_TYPE = {}));\n/** UBO ready lighting module */\nexport const lighting = {\n  props: {},\n  uniforms: {},\n  name: 'lighting',\n  defines: {\n    MAX_LIGHTS\n  },\n  uniformTypes: {\n    enabled: 'i32',\n    lightType: 'i32',\n    directionalLightCount: 'i32',\n    pointLightCount: 'i32',\n    ambientLightColor: 'vec3<f32>',\n    // TODO define as arrays once we have appropriate uniformTypes\n    lightColor0: 'vec3<f32>',\n    lightPosition0: 'vec3<f32>',\n    // TODO - could combine direction and attenuation\n    lightDirection0: 'vec3<f32>',\n    lightAttenuation0: 'vec3<f32>',\n    lightColor1: 'vec3<f32>',\n    lightPosition1: 'vec3<f32>',\n    lightDirection1: 'vec3<f32>',\n    lightAttenuation1: 'vec3<f32>',\n    lightColor2: 'vec3<f32>',\n    lightPosition2: 'vec3<f32>',\n    lightDirection2: 'vec3<f32>',\n    lightAttenuation2: 'vec3<f32>'\n  },\n  defaultUniforms: {\n    enabled: 1,\n    lightType: LIGHT_TYPE.POINT,\n    directionalLightCount: 0,\n    pointLightCount: 0,\n    ambientLightColor: [0.1, 0.1, 0.1],\n    lightColor0: [1, 1, 1],\n    lightPosition0: [1, 1, 2],\n    // TODO - could combine direction and attenuation\n    lightDirection0: [1, 1, 1],\n    lightAttenuation0: [1, 0, 0],\n    lightColor1: [1, 1, 1],\n    lightPosition1: [1, 1, 2],\n    lightDirection1: [1, 1, 1],\n    lightAttenuation1: [1, 0, 0],\n    lightColor2: [1, 1, 1],\n    lightPosition2: [1, 1, 2],\n    lightDirection2: [1, 1, 1],\n    lightAttenuation2: [1, 0, 0]\n  },\n  source: lightingUniformsWGSL,\n  vs: lightingUniformsGLSL,\n  fs: lightingUniformsGLSL,\n  getUniforms\n};\nfunction getUniforms(props, prevUniforms = {}) {\n  // Copy props so we can modify\n  props = props ? {\n    ...props\n  } : props;\n  // TODO legacy\n  if (!props) {\n    return {\n      ...lighting.defaultUniforms\n    };\n  }\n  // Support for array of lights. Type of light is detected by type field\n  if (props.lights) {\n    props = {\n      ...props,\n      ...extractLightTypes(props.lights),\n      lights: undefined\n    };\n  }\n  // Specify lights separately\n  const {\n    ambientLight,\n    pointLights,\n    directionalLights\n  } = props || {};\n  const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;\n  // TODO - this may not be the correct decision\n  if (!hasLights) {\n    return {\n      ...lighting.defaultUniforms,\n      enabled: 0\n    };\n  }\n  const uniforms = {\n    ...lighting.defaultUniforms,\n    ...prevUniforms,\n    ...getLightSourceUniforms({\n      ambientLight,\n      pointLights,\n      directionalLights\n    })\n  };\n  if (props.enabled !== undefined) {\n    uniforms.enabled = props.enabled ? 1 : 0;\n  }\n  return uniforms;\n}\nfunction getLightSourceUniforms({\n  ambientLight,\n  pointLights = [],\n  directionalLights = []\n}) {\n  const lightSourceUniforms = {};\n  lightSourceUniforms.ambientLightColor = convertColor(ambientLight);\n  let currentLight = 0;\n  for (const pointLight of pointLights) {\n    lightSourceUniforms.lightType = LIGHT_TYPE.POINT;\n    const i = currentLight;\n    lightSourceUniforms[`lightColor${i}`] = convertColor(pointLight);\n    lightSourceUniforms[`lightPosition${i}`] = pointLight.position;\n    lightSourceUniforms[`lightAttenuation${i}`] = pointLight.attenuation || [1, 0, 0];\n    currentLight++;\n  }\n  for (const directionalLight of directionalLights) {\n    lightSourceUniforms.lightType = LIGHT_TYPE.DIRECTIONAL;\n    const i = currentLight;\n    lightSourceUniforms[`lightColor${i}`] = convertColor(directionalLight);\n    lightSourceUniforms[`lightDirection${i}`] = directionalLight.direction;\n    currentLight++;\n  }\n  if (currentLight > MAX_LIGHTS) {\n    log.warn('MAX_LIGHTS exceeded')();\n  }\n  lightSourceUniforms.directionalLightCount = directionalLights.length;\n  lightSourceUniforms.pointLightCount = pointLights.length;\n  return lightSourceUniforms;\n}\nfunction extractLightTypes(lights) {\n  const lightSources = {\n    pointLights: [],\n    directionalLights: []\n  };\n  for (const light of lights || []) {\n    switch (light.type) {\n      case 'ambient':\n        // Note: Only uses last ambient light\n        // TODO - add ambient light sources on CPU?\n        lightSources.ambientLight = light;\n        break;\n      case 'directional':\n        lightSources.directionalLights?.push(light);\n        break;\n      case 'point':\n        lightSources.pointLights?.push(light);\n        break;\n      default:\n      // eslint-disable-next-line\n      // console.warn(light.type);\n    }\n  }\n  return lightSources;\n}\n/** Take color 0-255 and intensity as input and output 0.0-1.0 range */\nfunction convertColor(colorDef = {}) {\n  const {\n    color = [0, 0, 0],\n    intensity = 1.0\n  } = colorDef;\n  return color.map(component => component * intensity / COLOR_FACTOR);\n}","map":{"version":3,"names":["log","lightingUniformsGLSL","lightingUniformsWGSL","MAX_LIGHTS","COLOR_FACTOR","LIGHT_TYPE","lighting","props","uniforms","name","defines","uniformTypes","enabled","lightType","directionalLightCount","pointLightCount","ambientLightColor","lightColor0","lightPosition0","lightDirection0","lightAttenuation0","lightColor1","lightPosition1","lightDirection1","lightAttenuation1","lightColor2","lightPosition2","lightDirection2","lightAttenuation2","defaultUniforms","POINT","source","vs","fs","getUniforms","prevUniforms","lights","extractLightTypes","undefined","ambientLight","pointLights","directionalLights","hasLights","length","getLightSourceUniforms","lightSourceUniforms","convertColor","currentLight","pointLight","i","position","attenuation","directionalLight","DIRECTIONAL","direction","warn","lightSources","light","type","push","colorDef","color","intensity","map","component"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\shadertools\\src\\modules\\lighting\\lights\\lighting.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {log} from '@luma.gl/core';\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\nimport {lightingUniformsGLSL} from './lighting-uniforms-glsl';\nimport {lightingUniformsWGSL} from './lighting-uniforms-wgsl';\nimport type {NumberArray3} from '@math.gl/core';\n\n/** Max number of supported lights (in addition to ambient light */\nconst MAX_LIGHTS = 3;\n\n/** Whether to divide */\nconst COLOR_FACTOR = 255.0;\n\n/** Shader type field for lights */\n// eslint-disable-next-line no-shadow\nexport enum LIGHT_TYPE {\n  POINT = 0,\n  DIRECTIONAL = 1\n}\n\n/** Lighting helper types */\n\nexport type Light = AmbientLight | PointLight | DirectionalLight;\n\nexport type AmbientLight = {\n  type: 'ambient';\n  color?: Readonly<NumberArray3>;\n  intensity?: number;\n};\n\nexport type PointLight = {\n  type: 'point';\n  position: Readonly<NumberArray3>;\n  color?: Readonly<NumberArray3>;\n  intensity?: number;\n  attenuation?: Readonly<NumberArray3>;\n};\n\nexport type DirectionalLight = {\n  type: 'directional';\n  direction: Readonly<NumberArray3>;\n  color?: Readonly<NumberArray3>;\n  intensity?: number;\n};\n\nexport type LightingProps = {\n  enabled?: boolean;\n  lights?: Light[];\n  /** @deprecated */\n  ambientLight?: AmbientLight;\n  /** @deprecated */\n  pointLights?: PointLight[];\n  /** @deprecated */\n  directionalLights?: DirectionalLight[];\n};\n\nexport type LightingUniforms = {\n  enabled: number;\n  ambientLightColor: Readonly<NumberArray3>;\n  directionalLightCount: number;\n  pointLightCount: number;\n  lightType: number; // [];\n  lightColor0: Readonly<NumberArray3>;\n  lightPosition0: Readonly<NumberArray3>;\n  lightDirection0: Readonly<NumberArray3>;\n  lightAttenuation0: Readonly<NumberArray3>;\n  lightColor1: Readonly<NumberArray3>;\n  lightPosition1: Readonly<NumberArray3>;\n  lightDirection1: Readonly<NumberArray3>;\n  lightAttenuation1: Readonly<NumberArray3>;\n  lightColor2: Readonly<NumberArray3>;\n  lightPosition2: Readonly<NumberArray3>;\n  lightDirection2: Readonly<NumberArray3>;\n  lightAttenuation2: Readonly<NumberArray3>;\n};\n\n/** UBO ready lighting module */\nexport const lighting = {\n  props: {} as LightingProps,\n  uniforms: {} as LightingUniforms,\n\n  name: 'lighting',\n\n  defines: {\n    MAX_LIGHTS\n  },\n\n  uniformTypes: {\n    enabled: 'i32',\n    lightType: 'i32',\n\n    directionalLightCount: 'i32',\n    pointLightCount: 'i32',\n\n    ambientLightColor: 'vec3<f32>',\n\n    // TODO define as arrays once we have appropriate uniformTypes\n    lightColor0: 'vec3<f32>',\n    lightPosition0: 'vec3<f32>',\n    // TODO - could combine direction and attenuation\n    lightDirection0: 'vec3<f32>',\n    lightAttenuation0: 'vec3<f32>',\n\n    lightColor1: 'vec3<f32>',\n    lightPosition1: 'vec3<f32>',\n    lightDirection1: 'vec3<f32>',\n    lightAttenuation1: 'vec3<f32>',\n    lightColor2: 'vec3<f32>',\n    lightPosition2: 'vec3<f32>',\n    lightDirection2: 'vec3<f32>',\n    lightAttenuation2: 'vec3<f32>'\n  },\n\n  defaultUniforms: {\n    enabled: 1,\n    lightType: LIGHT_TYPE.POINT,\n\n    directionalLightCount: 0,\n    pointLightCount: 0,\n\n    ambientLightColor: [0.1, 0.1, 0.1],\n    lightColor0: [1, 1, 1],\n    lightPosition0: [1, 1, 2],\n    // TODO - could combine direction and attenuation\n    lightDirection0: [1, 1, 1],\n    lightAttenuation0: [1, 0, 0],\n\n    lightColor1: [1, 1, 1],\n    lightPosition1: [1, 1, 2],\n    lightDirection1: [1, 1, 1],\n    lightAttenuation1: [1, 0, 0],\n    lightColor2: [1, 1, 1],\n    lightPosition2: [1, 1, 2],\n    lightDirection2: [1, 1, 1],\n    lightAttenuation2: [1, 0, 0]\n  },\n  source: lightingUniformsWGSL,\n  vs: lightingUniformsGLSL,\n  fs: lightingUniformsGLSL,\n\n  getUniforms\n} as const satisfies ShaderModule<LightingProps, LightingUniforms, {}>;\n\nfunction getUniforms(\n  props?: LightingProps,\n  prevUniforms: Partial<LightingUniforms> = {}\n): LightingUniforms {\n  // Copy props so we can modify\n  props = props ? {...props} : props;\n\n  // TODO legacy\n  if (!props) {\n    return {...lighting.defaultUniforms};\n  }\n  // Support for array of lights. Type of light is detected by type field\n  if (props.lights) {\n    props = {...props, ...extractLightTypes(props.lights), lights: undefined};\n  }\n\n  // Specify lights separately\n  const {ambientLight, pointLights, directionalLights} = props || {};\n  const hasLights =\n    ambientLight ||\n    (pointLights && pointLights.length > 0) ||\n    (directionalLights && directionalLights.length > 0);\n\n  // TODO - this may not be the correct decision\n  if (!hasLights) {\n    return {...lighting.defaultUniforms, enabled: 0};\n  }\n\n  const uniforms = {\n    ...lighting.defaultUniforms,\n    ...prevUniforms,\n    ...getLightSourceUniforms({ambientLight, pointLights, directionalLights})\n  };\n\n  if (props.enabled !== undefined) {\n    uniforms.enabled = props.enabled ? 1 : 0;\n  }\n\n  return uniforms;\n}\n\nfunction getLightSourceUniforms({\n  ambientLight,\n  pointLights = [],\n  directionalLights = []\n}: LightingProps): Partial<LightingUniforms> {\n  const lightSourceUniforms: Partial<LightingUniforms> = {};\n\n  lightSourceUniforms.ambientLightColor = convertColor(ambientLight);\n\n  let currentLight: 0 | 1 | 2 = 0;\n\n  for (const pointLight of pointLights) {\n    lightSourceUniforms.lightType = LIGHT_TYPE.POINT;\n\n    const i = currentLight as 0 | 1 | 2;\n    lightSourceUniforms[`lightColor${i}`] = convertColor(pointLight);\n    lightSourceUniforms[`lightPosition${i}`] = pointLight.position;\n    lightSourceUniforms[`lightAttenuation${i}`] = pointLight.attenuation || [1, 0, 0];\n    currentLight++;\n  }\n\n  for (const directionalLight of directionalLights) {\n    lightSourceUniforms.lightType = LIGHT_TYPE.DIRECTIONAL;\n\n    const i = currentLight as 0 | 1 | 2;\n    lightSourceUniforms[`lightColor${i}`] = convertColor(directionalLight);\n    lightSourceUniforms[`lightDirection${i}`] = directionalLight.direction;\n    currentLight++;\n  }\n\n  if (currentLight > MAX_LIGHTS) {\n    log.warn('MAX_LIGHTS exceeded')();\n  }\n\n  lightSourceUniforms.directionalLightCount = directionalLights.length;\n  lightSourceUniforms.pointLightCount = pointLights.length;\n\n  return lightSourceUniforms;\n}\n\nfunction extractLightTypes(lights: Light[]): LightingProps {\n  const lightSources: LightingProps = {pointLights: [], directionalLights: []};\n  for (const light of lights || []) {\n    switch (light.type) {\n      case 'ambient':\n        // Note: Only uses last ambient light\n        // TODO - add ambient light sources on CPU?\n        lightSources.ambientLight = light;\n        break;\n      case 'directional':\n        lightSources.directionalLights?.push(light);\n        break;\n      case 'point':\n        lightSources.pointLights?.push(light);\n        break;\n      default:\n      // eslint-disable-next-line\n      // console.warn(light.type);\n    }\n  }\n  return lightSources;\n}\n\n/** Take color 0-255 and intensity as input and output 0.0-1.0 range */\nfunction convertColor(\n  colorDef: {color?: Readonly<NumberArray3>; intensity?: number} = {}\n): NumberArray3 {\n  const {color = [0, 0, 0], intensity = 1.0} = colorDef;\n  return color.map(component => (component * intensity) / COLOR_FACTOR) as NumberArray3;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}