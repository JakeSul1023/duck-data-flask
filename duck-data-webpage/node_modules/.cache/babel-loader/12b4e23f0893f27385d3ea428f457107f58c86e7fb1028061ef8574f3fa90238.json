{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** Applies a scale to BinaryAttribute */\nexport class AttributeWithScale {\n  constructor(input, inputLength) {\n    this.props = {\n      scaleType: 'linear',\n      lowerPercentile: 0,\n      upperPercentile: 100\n    };\n    /** [min, max] of attribute values, or null if unknown */\n    this.domain = null;\n    /** Valid domain if lower/upper percentile are defined */\n    this.cutoff = null;\n    this.input = input;\n    this.inputLength = inputLength;\n    // No processing is needed with the default scale\n    this.attribute = input;\n  }\n  getScalePercentile() {\n    if (!this._percentile) {\n      const value = getAttributeValue(this.input, this.inputLength);\n      this._percentile = applyScaleQuantile(value);\n    }\n    return this._percentile;\n  }\n  getScaleOrdinal() {\n    if (!this._ordinal) {\n      const value = getAttributeValue(this.input, this.inputLength);\n      this._ordinal = applyScaleOrdinal(value);\n    }\n    return this._ordinal;\n  }\n  /** Returns the [lowerCutoff, upperCutoff] of scaled values, or null if not applicable */\n  getCutoff({\n    scaleType,\n    lowerPercentile,\n    upperPercentile\n  }) {\n    if (scaleType === 'quantile') {\n      return [lowerPercentile, upperPercentile - 1];\n    }\n    if (lowerPercentile > 0 || upperPercentile < 100) {\n      const {\n        domain: thresholds\n      } = this.getScalePercentile();\n      let lowValue = thresholds[Math.floor(lowerPercentile) - 1] ?? -Infinity;\n      let highValue = thresholds[Math.floor(upperPercentile) - 1] ?? Infinity;\n      if (scaleType === 'ordinal') {\n        const {\n          domain: sortedUniqueValues\n        } = this.getScaleOrdinal();\n        lowValue = sortedUniqueValues.findIndex(x => x >= lowValue);\n        highValue = sortedUniqueValues.findIndex(x => x > highValue) - 1;\n        if (highValue === -2) {\n          highValue = sortedUniqueValues.length - 1;\n        }\n      }\n      return [lowValue, highValue];\n    }\n    return null;\n  }\n  update(props) {\n    const oldProps = this.props;\n    if (props.scaleType !== oldProps.scaleType) {\n      switch (props.scaleType) {\n        case 'quantile':\n          {\n            const {\n              attribute\n            } = this.getScalePercentile();\n            this.attribute = attribute;\n            this.domain = [0, 99];\n            break;\n          }\n        case 'ordinal':\n          {\n            const {\n              attribute,\n              domain\n            } = this.getScaleOrdinal();\n            this.attribute = attribute;\n            this.domain = [0, domain.length - 1];\n            break;\n          }\n        default:\n          this.attribute = this.input;\n          this.domain = null;\n      }\n    }\n    if (props.scaleType !== oldProps.scaleType || props.lowerPercentile !== oldProps.lowerPercentile || props.upperPercentile !== oldProps.upperPercentile) {\n      this.cutoff = this.getCutoff(props);\n    }\n    this.props = props;\n    return this;\n  }\n}\n/**\n * Transform an array of values to ordinal indices\n */\nexport function applyScaleOrdinal(values) {\n  const uniqueValues = new Set();\n  for (const x of values) {\n    if (Number.isFinite(x)) {\n      uniqueValues.add(x);\n    }\n  }\n  const sortedUniqueValues = Array.from(uniqueValues).sort();\n  const domainMap = new Map();\n  for (let i = 0; i < sortedUniqueValues.length; i++) {\n    domainMap.set(sortedUniqueValues[i], i);\n  }\n  return {\n    attribute: {\n      value: values.map(x => Number.isFinite(x) ? domainMap.get(x) : NaN),\n      type: 'float32',\n      size: 1\n    },\n    domain: sortedUniqueValues\n  };\n}\n/**\n * Transform an array of values to percentiles\n */\nexport function applyScaleQuantile(values, rangeLength = 100) {\n  const sortedValues = Array.from(values).filter(Number.isFinite).sort(ascending);\n  let i = 0;\n  const n = Math.max(1, rangeLength);\n  const thresholds = new Array(n - 1);\n  while (++i < n) {\n    thresholds[i - 1] = threshold(sortedValues, i / n);\n  }\n  return {\n    attribute: {\n      value: values.map(x => Number.isFinite(x) ? bisectRight(thresholds, x) : NaN),\n      type: 'float32',\n      size: 1\n    },\n    domain: thresholds\n  };\n}\nfunction getAttributeValue(attribute, length) {\n  const elementStride = (attribute.stride ?? 4) / 4;\n  const elementOffset = (attribute.offset ?? 0) / 4;\n  let value = attribute.value;\n  if (!value) {\n    const bytes = attribute.buffer?.readSyncWebGL(0, elementStride * 4 * length);\n    if (bytes) {\n      value = new Float32Array(bytes.buffer);\n      attribute.value = value;\n    }\n  }\n  if (elementStride === 1) {\n    return value.subarray(0, length);\n  }\n  const result = new Float32Array(length);\n  for (let i = 0; i < length; i++) {\n    result[i] = value[i * elementStride + elementOffset];\n  }\n  return result;\n}\nfunction ascending(a, b) {\n  return a - b;\n}\nfunction threshold(domain, fraction) {\n  const domainLength = domain.length;\n  if (fraction <= 0 || domainLength < 2) {\n    return domain[0];\n  }\n  if (fraction >= 1) {\n    return domain[domainLength - 1];\n  }\n  const domainFraction = (domainLength - 1) * fraction;\n  const lowIndex = Math.floor(domainFraction);\n  const low = domain[lowIndex];\n  const high = domain[lowIndex + 1];\n  return low + (high - low) * (domainFraction - lowIndex);\n}\nfunction bisectRight(a, x) {\n  let lo = 0;\n  let hi = a.length;\n  while (lo < hi) {\n    const mid = lo + hi >>> 1;\n    if (a[mid] > x) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\n//# sourceMappingURL=scale-utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}