{"ast":null,"code":"/* global setTimeout, clearTimeout */\nimport { Recognizer } from \"../recognizer/recognizer.js\";\nimport { RecognizerState } from \"../recognizer/recognizer-state.js\";\nimport { TOUCH_ACTION_AUTO } from \"../touchaction/touchaction-Consts.js\";\nimport { InputEvent } from \"../input/input-consts.js\";\nconst EVENT_NAMES = ['', 'up'];\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n */\nexport class PressRecognizer extends Recognizer {\n  constructor(options = {}) {\n    super({\n      enable: true,\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      threshold: 9,\n      ...options\n    });\n    this._timer = null;\n    this._input = null;\n  }\n  getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  }\n  getEventNames() {\n    return EVENT_NAMES.map(suffix => this.options.event + suffix);\n  }\n  process(input) {\n    const {\n      options\n    } = this;\n    const validPointers = input.pointers.length === options.pointers;\n    const validMovement = input.distance < options.threshold;\n    const validTime = input.deltaTime > options.time;\n    this._input = input;\n    // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n    if (!validMovement || !validPointers || input.eventType & (InputEvent.End | InputEvent.Cancel) && !validTime) {\n      this.reset();\n    } else if (input.eventType & InputEvent.Start) {\n      this.reset();\n      this._timer = setTimeout(() => {\n        this.state = RecognizerState.Recognized;\n        this.tryEmit();\n      }, options.time);\n    } else if (input.eventType & InputEvent.End) {\n      return RecognizerState.Recognized;\n    }\n    return RecognizerState.Failed;\n  }\n  reset() {\n    clearTimeout(this._timer);\n  }\n  emit(input) {\n    if (this.state !== RecognizerState.Recognized) {\n      return;\n    }\n    if (input && input.eventType & InputEvent.End) {\n      this.manager.emit(`${this.options.event}up`, input);\n    } else {\n      this._input.timeStamp = Date.now();\n      this.manager.emit(this.options.event, this._input);\n    }\n  }\n}","map":{"version":3,"names":["Recognizer","RecognizerState","TOUCH_ACTION_AUTO","InputEvent","EVENT_NAMES","PressRecognizer","constructor","options","enable","event","pointers","time","threshold","_timer","_input","getTouchAction","getEventNames","map","suffix","process","input","validPointers","length","validMovement","distance","validTime","deltaTime","eventType","End","Cancel","reset","Start","setTimeout","state","Recognized","tryEmit","Failed","clearTimeout","emit","manager","timeStamp","Date","now"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\mjolnir.js\\src\\hammerjs\\recognizers\\press.ts"],"sourcesContent":["/* global setTimeout, clearTimeout */\nimport {Recognizer} from '../recognizer/recognizer';\nimport {RecognizerState} from '../recognizer/recognizer-state';\nimport {TOUCH_ACTION_AUTO} from '../touchaction/touchaction-Consts';\nimport {InputEvent} from '../input/input-consts';\nimport {HammerInput} from '../input/types';\n\nexport type PressRecognizerOptions = {\n  /** Name of the event.\n   * @default 'press'\n   */\n  event?: string;\n  /** Enable this event.\n   * @default true\n   */\n  enable?: boolean;\n  /** Required number of pointers.\n   * @default 1\n   */\n  pointers?: number;\n  /** Minimal press time in ms.\n   * @default 251\n   */\n  time?: number;\n  /** Minimal movement that is allowed while pressing.\n   * @default 9\n   */\n  threshold?: number;\n};\n\nconst EVENT_NAMES = ['', 'up'] as const;\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n */\nexport class PressRecognizer extends Recognizer<Required<PressRecognizerOptions>> {\n  private _timer: any = null;\n  private _input: HammerInput | null = null;\n\n  constructor(options: PressRecognizerOptions = {}) {\n    super({\n      enable: true,\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      threshold: 9,\n      ...options\n    });\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  }\n\n  getEventNames(): string[] {\n    return EVENT_NAMES.map((suffix) => this.options.event + suffix);\n  }\n\n  process(input: HammerInput) {\n    const {options} = this;\n    const validPointers = input.pointers.length === options.pointers;\n    const validMovement = input.distance < options.threshold;\n    const validTime = input.deltaTime > options.time;\n\n    this._input = input;\n\n    // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n    if (\n      !validMovement ||\n      !validPointers ||\n      (input.eventType & (InputEvent.End | InputEvent.Cancel) && !validTime)\n    ) {\n      this.reset();\n    } else if (input.eventType & InputEvent.Start) {\n      this.reset();\n      this._timer = setTimeout(() => {\n        this.state = RecognizerState.Recognized;\n        this.tryEmit();\n      }, options.time);\n    } else if (input.eventType & InputEvent.End) {\n      return RecognizerState.Recognized;\n    }\n    return RecognizerState.Failed;\n  }\n\n  reset() {\n    clearTimeout(this._timer);\n  }\n\n  emit(input?: HammerInput) {\n    if (this.state !== RecognizerState.Recognized) {\n      return;\n    }\n\n    if (input && input.eventType & InputEvent.End) {\n      this.manager.emit(`${this.options.event}up`, input);\n    } else {\n      this._input!.timeStamp = Date.now();\n      this.manager.emit(this.options.event, this._input!);\n    }\n  }\n}\n"],"mappings":"AAAA;AACA,SAAQA,UAAU,QAAC;AACnB,SAAQC,eAAe,QAAC;AACxB,SAAQC,iBAAiB,QAAC;AAC1B,SAAQC,UAAU,QAAC;AA0BnB,MAAMC,WAAW,GAAG,CAAC,EAAE,EAAE,IAAI,CAAU;AAEvC;;;;AAIA,OAAM,MAAOC,eAAgB,SAAQL,UAA4C;EAI/EM,YAAYC,OAAA,GAAkC,EAAE;IAC9C,KAAK,CAAC;MACJC,MAAM,EAAE,IAAI;MACZC,KAAK,EAAE,OAAO;MACdC,QAAQ,EAAE,CAAC;MACXC,IAAI,EAAE,GAAG;MACTC,SAAS,EAAE,CAAC;MACZ,GAAGL;KACJ,CAAC;IAXI,KAAAM,MAAM,GAAQ,IAAI;IAClB,KAAAC,MAAM,GAAuB,IAAI;EAWzC;EAEAC,cAAcA,CAAA;IACZ,OAAO,CAACb,iBAAiB,CAAC;EAC5B;EAEAc,aAAaA,CAAA;IACX,OAAOZ,WAAW,CAACa,GAAG,CAAEC,MAAM,IAAK,IAAI,CAACX,OAAO,CAACE,KAAK,GAAGS,MAAM,CAAC;EACjE;EAEAC,OAAOA,CAACC,KAAkB;IACxB,MAAM;MAACb;IAAO,CAAC,GAAG,IAAI;IACtB,MAAMc,aAAa,GAAGD,KAAK,CAACV,QAAQ,CAACY,MAAM,KAAKf,OAAO,CAACG,QAAQ;IAChE,MAAMa,aAAa,GAAGH,KAAK,CAACI,QAAQ,GAAGjB,OAAO,CAACK,SAAS;IACxD,MAAMa,SAAS,GAAGL,KAAK,CAACM,SAAS,GAAGnB,OAAO,CAACI,IAAI;IAEhD,IAAI,CAACG,MAAM,GAAGM,KAAK;IAEnB;IACA;IACA,IACE,CAACG,aAAa,IACd,CAACF,aAAa,IACbD,KAAK,CAACO,SAAS,IAAIxB,UAAU,CAACyB,GAAG,GAAGzB,UAAU,CAAC0B,MAAM,CAAC,IAAI,CAACJ,SAAU,EACtE;MACA,IAAI,CAACK,KAAK,EAAE;IACd,CAAC,MAAM,IAAIV,KAAK,CAACO,SAAS,GAAGxB,UAAU,CAAC4B,KAAK,EAAE;MAC7C,IAAI,CAACD,KAAK,EAAE;MACZ,IAAI,CAACjB,MAAM,GAAGmB,UAAU,CAAC,MAAK;QAC5B,IAAI,CAACC,KAAK,GAAGhC,eAAe,CAACiC,UAAU;QACvC,IAAI,CAACC,OAAO,EAAE;MAChB,CAAC,EAAE5B,OAAO,CAACI,IAAI,CAAC;IAClB,CAAC,MAAM,IAAIS,KAAK,CAACO,SAAS,GAAGxB,UAAU,CAACyB,GAAG,EAAE;MAC3C,OAAO3B,eAAe,CAACiC,UAAU;IACnC;IACA,OAAOjC,eAAe,CAACmC,MAAM;EAC/B;EAEAN,KAAKA,CAAA;IACHO,YAAY,CAAC,IAAI,CAACxB,MAAM,CAAC;EAC3B;EAEAyB,IAAIA,CAAClB,KAAmB;IACtB,IAAI,IAAI,CAACa,KAAK,KAAKhC,eAAe,CAACiC,UAAU,EAAE;MAC7C;IACF;IAEA,IAAId,KAAK,IAAIA,KAAK,CAACO,SAAS,GAAGxB,UAAU,CAACyB,GAAG,EAAE;MAC7C,IAAI,CAACW,OAAO,CAACD,IAAI,CAAC,GAAG,IAAI,CAAC/B,OAAO,CAACE,KAAK,IAAI,EAAEW,KAAK,CAAC;IACrD,CAAC,MAAM;MACL,IAAI,CAACN,MAAO,CAAC0B,SAAS,GAAGC,IAAI,CAACC,GAAG,EAAE;MACnC,IAAI,CAACH,OAAO,CAACD,IAAI,CAAC,IAAI,CAAC/B,OAAO,CAACE,KAAK,EAAE,IAAI,CAACK,MAAO,CAAC;IACrD;EACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}