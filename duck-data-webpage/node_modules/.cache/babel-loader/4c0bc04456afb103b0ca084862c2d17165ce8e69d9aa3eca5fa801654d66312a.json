{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getSchemaFromTileJSONLayer } from \"./get-schemas-from-tilejson.js\";\nconst isObject = x => x !== null && typeof x === 'object';\n/**\n * Parse TileJSON from metadata\n * @param jsonMetadata - metadata object\n * @param options - options\n * @returns - parsed TileJSON\n */\n// eslint-disable-next-line complexity\nexport function parseTileJSON(jsonMetadata, options) {\n  if (!jsonMetadata || !isObject(jsonMetadata)) {\n    return null;\n  }\n  let tileJSON = {\n    name: jsonMetadata.name || '',\n    description: jsonMetadata.description || ''\n  };\n  // tippecanoe\n  if (typeof jsonMetadata.generator === 'string') {\n    tileJSON.generator = jsonMetadata.generator;\n  }\n  if (typeof jsonMetadata.generator_options === 'string') {\n    tileJSON.generatorOptions = jsonMetadata.generator_options;\n  }\n  // Tippecanoe emits `antimeridian_adjusted_bounds` instead of `bounds`\n  tileJSON.boundingBox = parseBounds(jsonMetadata.bounds) || parseBounds(jsonMetadata.antimeridian_adjusted_bounds);\n  // TODO - can be undefined - we could set to center of bounds...\n  tileJSON.center = parseCenter(jsonMetadata.center);\n  // TODO - can be undefined, we could extract from layers...\n  tileJSON.maxZoom = safeParseFloat(jsonMetadata.maxzoom);\n  // TODO - can be undefined, we could extract from layers...\n  tileJSON.minZoom = safeParseFloat(jsonMetadata.minzoom);\n  // Look for nested metadata embedded in .json field\n  // TODO - document what source this applies to, when is this needed?\n  if (typeof jsonMetadata?.json === 'string') {\n    // try to parse json\n    try {\n      tileJSON.metaJson = JSON.parse(jsonMetadata.json);\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      console.warn('Failed to parse tilejson.json field', error);\n      // do nothing\n    }\n  }\n  // Look for fields in tilestats\n  const tilestats = jsonMetadata.tilestats || tileJSON.metaJson?.tilestats;\n  const tileStatsLayers = parseTilestatsLayers(tilestats, options);\n  const tileJSONlayers = parseTileJSONLayers(jsonMetadata.vector_layers); // eslint-disable-line camelcase\n  // TODO - merge in description from tilejson\n  const layers = mergeLayers(tileJSONlayers, tileStatsLayers);\n  tileJSON = {\n    ...tileJSON,\n    layers\n  };\n  if (tileJSON.maxZoom === null && layers.length > 0) {\n    tileJSON.maxZoom = layers[0].maxZoom || null;\n  }\n  if (tileJSON.minZoom === null && layers.length > 0) {\n    tileJSON.minZoom = layers[0].minZoom || null;\n  }\n  return tileJSON;\n}\nfunction parseTileJSONLayers(layers) {\n  // Look for fields in vector_layers\n  if (!Array.isArray(layers)) {\n    return [];\n  }\n  return layers.map(layer => parseTileJSONLayer(layer));\n}\nfunction parseTileJSONLayer(layer) {\n  const fields = Object.entries(layer.fields || []).map(([key, datatype]) => ({\n    name: key,\n    ...attributeTypeToFieldType(String(datatype))\n  }));\n  const layer2 = {\n    ...layer\n  };\n  delete layer2.fields;\n  return {\n    name: layer.id || '',\n    ...layer2,\n    fields\n  };\n}\n/** parse Layers array from tilestats */\nfunction parseTilestatsLayers(tilestats, options) {\n  if (isObject(tilestats) && Array.isArray(tilestats.layers)) {\n    // we are in luck!\n    return tilestats.layers.map(layer => parseTilestatsForLayer(layer, options));\n  }\n  return [];\n}\nfunction parseTilestatsForLayer(layer, options) {\n  const fields = [];\n  const indexedAttributes = {};\n  const attributes = layer.attributes || [];\n  for (const attribute of attributes) {\n    const name = attribute.attribute;\n    if (typeof name === 'string') {\n      // TODO - code copied from kepler.gl, need sample tilestats files to test\n      if (name.split('|').length > 1) {\n        // indexed field\n        const fname = name.split('|')[0];\n        indexedAttributes[fname] = indexedAttributes[fname] || [];\n        indexedAttributes[fname].push(attribute);\n        // eslint-disable-next-line no-console\n        console.warn('ignoring tilestats indexed field', fname);\n      } else if (!fields[name]) {\n        fields.push(attributeToField(attribute, options));\n      } else {\n        // return (fields[name], attribute);\n      }\n    }\n  }\n  return {\n    name: layer.layer || '',\n    dominantGeometry: layer.geometry,\n    fields\n  };\n}\nfunction mergeLayers(layers, tilestatsLayers) {\n  return layers.map(layer => {\n    const tilestatsLayer = tilestatsLayers.find(tsLayer => tsLayer.name === layer.name);\n    const fields = tilestatsLayer?.fields || layer.fields || [];\n    const mergedLayer = {\n      ...layer,\n      ...tilestatsLayer,\n      fields\n    };\n    mergedLayer.schema = getSchemaFromTileJSONLayer(mergedLayer);\n    return mergedLayer;\n  });\n}\n/**\n * bounds should be [minLng, minLat, maxLng, maxLat]\n *`[[w, s], [e, n]]`, indicates the limits of the bounding box using the axis units and order of the specified CRS.\n */\nfunction parseBounds(bounds) {\n  // supported formats\n  // string: \"-96.657715,40.126127,-90.140061,43.516689\",\n  // array: [ -180, -85.05112877980659, 180, 85.0511287798066 ]\n  const result = fromArrayOrString(bounds);\n  // validate bounds\n  if (Array.isArray(result) && result.length === 4 && [result[0], result[2]].every(isLng) && [result[1], result[3]].every(isLat)) {\n    return [[result[0], result[1]], [result[2], result[3]]];\n  }\n  return undefined;\n}\nfunction parseCenter(center) {\n  // supported formats\n  // string: \"-96.657715,40.126127,-90.140061,43.516689\",\n  // array: [-91.505127,41.615442,14]\n  const result = fromArrayOrString(center);\n  if (Array.isArray(result) && result.length === 3 && isLng(result[0]) && isLat(result[1]) && isZoom(result[2])) {\n    return result;\n  }\n  return null;\n}\nfunction safeParseFloat(input) {\n  const result = typeof input === 'string' ? parseFloat(input) : typeof input === 'number' ? input : null;\n  return result === null || isNaN(result) ? null : result;\n}\n// https://github.com/mapbox/tilejson-spec/tree/master/2.2.0\nfunction isLat(num) {\n  return Number.isFinite(num) && num <= 90 && num >= -90;\n}\nfunction isLng(num) {\n  return Number.isFinite(num) && num <= 180 && num >= -180;\n}\nfunction isZoom(num) {\n  return Number.isFinite(num) && num >= 0 && num <= 22;\n}\nfunction fromArrayOrString(data) {\n  if (typeof data === 'string') {\n    return data.split(',').map(parseFloat);\n  } else if (Array.isArray(data)) {\n    return data;\n  }\n  return null;\n}\n// possible types https://github.com/mapbox/tippecanoe#modifying-feature-attributes\nconst attrTypeMap = {\n  number: {\n    type: 'float32'\n  },\n  numeric: {\n    type: 'float32'\n  },\n  string: {\n    type: 'utf8'\n  },\n  vachar: {\n    type: 'utf8'\n  },\n  float: {\n    type: 'float32'\n  },\n  int: {\n    type: 'int32'\n  },\n  int4: {\n    type: 'int32'\n  },\n  boolean: {\n    type: 'boolean'\n  },\n  bool: {\n    type: 'boolean'\n  }\n};\nfunction attributeToField(attribute = {}, options) {\n  const fieldTypes = attributeTypeToFieldType(attribute.type);\n  const field = {\n    name: attribute.attribute,\n    // what happens if attribute type is string...\n    // filterProps: getFilterProps(fieldTypes.type, attribute),\n    ...fieldTypes\n  };\n  // attribute: \"_season_peaks_color\"\n  // count: 1000\n  // max: 0.95\n  // min: 0.24375\n  // type: \"number\"\n  if (typeof attribute.min === 'number') {\n    field.min = attribute.min;\n  }\n  if (typeof attribute.max === 'number') {\n    field.max = attribute.max;\n  }\n  if (typeof attribute.count === 'number') {\n    field.uniqueValueCount = attribute.count;\n  }\n  if (attribute.values) {\n    // Too much data? Add option?\n    field.values = attribute.values;\n  }\n  if (field.values && typeof options.maxValues === 'number') {\n    // Too much data? Add option?\n    field.values = field.values?.slice(0, options.maxValues);\n  }\n  return field;\n}\nfunction attributeTypeToFieldType(aType) {\n  const type = aType.toLowerCase();\n  if (!type || !attrTypeMap[type]) {\n    // console.warn(\n    //   `cannot convert attribute type ${type} to loaders.gl data type, use string by default`\n    // );\n  }\n  return attrTypeMap[type] || {\n    type: 'string'\n  };\n}","map":{"version":3,"names":["getSchemaFromTileJSONLayer","isObject","x","parseTileJSON","jsonMetadata","options","tileJSON","name","description","generator","generator_options","generatorOptions","boundingBox","parseBounds","bounds","antimeridian_adjusted_bounds","center","parseCenter","maxZoom","safeParseFloat","maxzoom","minZoom","minzoom","json","metaJson","JSON","parse","error","console","warn","tilestats","tileStatsLayers","parseTilestatsLayers","tileJSONlayers","parseTileJSONLayers","vector_layers","layers","mergeLayers","length","Array","isArray","map","layer","parseTileJSONLayer","fields","Object","entries","key","datatype","attributeTypeToFieldType","String","layer2","id","parseTilestatsForLayer","indexedAttributes","attributes","attribute","split","fname","push","attributeToField","dominantGeometry","geometry","tilestatsLayers","tilestatsLayer","find","tsLayer","mergedLayer","schema","result","fromArrayOrString","every","isLng","isLat","undefined","isZoom","input","parseFloat","isNaN","num","Number","isFinite","data","attrTypeMap","number","type","numeric","string","vachar","float","int","int4","boolean","bool","fieldTypes","field","min","max","count","uniqueValueCount","values","maxValues","slice","aType","toLowerCase"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/mvt/dist/lib/parse-tilejson.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getSchemaFromTileJSONLayer } from \"./get-schemas-from-tilejson.js\";\nconst isObject = (x) => x !== null && typeof x === 'object';\n/**\n * Parse TileJSON from metadata\n * @param jsonMetadata - metadata object\n * @param options - options\n * @returns - parsed TileJSON\n */\n// eslint-disable-next-line complexity\nexport function parseTileJSON(jsonMetadata, options) {\n    if (!jsonMetadata || !isObject(jsonMetadata)) {\n        return null;\n    }\n    let tileJSON = {\n        name: jsonMetadata.name || '',\n        description: jsonMetadata.description || ''\n    };\n    // tippecanoe\n    if (typeof jsonMetadata.generator === 'string') {\n        tileJSON.generator = jsonMetadata.generator;\n    }\n    if (typeof jsonMetadata.generator_options === 'string') {\n        tileJSON.generatorOptions = jsonMetadata.generator_options;\n    }\n    // Tippecanoe emits `antimeridian_adjusted_bounds` instead of `bounds`\n    tileJSON.boundingBox =\n        parseBounds(jsonMetadata.bounds) || parseBounds(jsonMetadata.antimeridian_adjusted_bounds);\n    // TODO - can be undefined - we could set to center of bounds...\n    tileJSON.center = parseCenter(jsonMetadata.center);\n    // TODO - can be undefined, we could extract from layers...\n    tileJSON.maxZoom = safeParseFloat(jsonMetadata.maxzoom);\n    // TODO - can be undefined, we could extract from layers...\n    tileJSON.minZoom = safeParseFloat(jsonMetadata.minzoom);\n    // Look for nested metadata embedded in .json field\n    // TODO - document what source this applies to, when is this needed?\n    if (typeof jsonMetadata?.json === 'string') {\n        // try to parse json\n        try {\n            tileJSON.metaJson = JSON.parse(jsonMetadata.json);\n        }\n        catch (error) {\n            // eslint-disable-next-line no-console\n            console.warn('Failed to parse tilejson.json field', error);\n            // do nothing\n        }\n    }\n    // Look for fields in tilestats\n    const tilestats = jsonMetadata.tilestats || tileJSON.metaJson?.tilestats;\n    const tileStatsLayers = parseTilestatsLayers(tilestats, options);\n    const tileJSONlayers = parseTileJSONLayers(jsonMetadata.vector_layers); // eslint-disable-line camelcase\n    // TODO - merge in description from tilejson\n    const layers = mergeLayers(tileJSONlayers, tileStatsLayers);\n    tileJSON = {\n        ...tileJSON,\n        layers\n    };\n    if (tileJSON.maxZoom === null && layers.length > 0) {\n        tileJSON.maxZoom = layers[0].maxZoom || null;\n    }\n    if (tileJSON.minZoom === null && layers.length > 0) {\n        tileJSON.minZoom = layers[0].minZoom || null;\n    }\n    return tileJSON;\n}\nfunction parseTileJSONLayers(layers) {\n    // Look for fields in vector_layers\n    if (!Array.isArray(layers)) {\n        return [];\n    }\n    return layers.map((layer) => parseTileJSONLayer(layer));\n}\nfunction parseTileJSONLayer(layer) {\n    const fields = Object.entries(layer.fields || []).map(([key, datatype]) => ({\n        name: key,\n        ...attributeTypeToFieldType(String(datatype))\n    }));\n    const layer2 = { ...layer };\n    delete layer2.fields;\n    return {\n        name: layer.id || '',\n        ...layer2,\n        fields\n    };\n}\n/** parse Layers array from tilestats */\nfunction parseTilestatsLayers(tilestats, options) {\n    if (isObject(tilestats) && Array.isArray(tilestats.layers)) {\n        // we are in luck!\n        return tilestats.layers.map((layer) => parseTilestatsForLayer(layer, options));\n    }\n    return [];\n}\nfunction parseTilestatsForLayer(layer, options) {\n    const fields = [];\n    const indexedAttributes = {};\n    const attributes = layer.attributes || [];\n    for (const attribute of attributes) {\n        const name = attribute.attribute;\n        if (typeof name === 'string') {\n            // TODO - code copied from kepler.gl, need sample tilestats files to test\n            if (name.split('|').length > 1) {\n                // indexed field\n                const fname = name.split('|')[0];\n                indexedAttributes[fname] = indexedAttributes[fname] || [];\n                indexedAttributes[fname].push(attribute);\n                // eslint-disable-next-line no-console\n                console.warn('ignoring tilestats indexed field', fname);\n            }\n            else if (!fields[name]) {\n                fields.push(attributeToField(attribute, options));\n            }\n            else {\n                // return (fields[name], attribute);\n            }\n        }\n    }\n    return {\n        name: layer.layer || '',\n        dominantGeometry: layer.geometry,\n        fields\n    };\n}\nfunction mergeLayers(layers, tilestatsLayers) {\n    return layers.map((layer) => {\n        const tilestatsLayer = tilestatsLayers.find((tsLayer) => tsLayer.name === layer.name);\n        const fields = tilestatsLayer?.fields || layer.fields || [];\n        const mergedLayer = {\n            ...layer,\n            ...tilestatsLayer,\n            fields\n        };\n        mergedLayer.schema = getSchemaFromTileJSONLayer(mergedLayer);\n        return mergedLayer;\n    });\n}\n/**\n * bounds should be [minLng, minLat, maxLng, maxLat]\n *`[[w, s], [e, n]]`, indicates the limits of the bounding box using the axis units and order of the specified CRS.\n */\nfunction parseBounds(bounds) {\n    // supported formats\n    // string: \"-96.657715,40.126127,-90.140061,43.516689\",\n    // array: [ -180, -85.05112877980659, 180, 85.0511287798066 ]\n    const result = fromArrayOrString(bounds);\n    // validate bounds\n    if (Array.isArray(result) &&\n        result.length === 4 &&\n        [result[0], result[2]].every(isLng) &&\n        [result[1], result[3]].every(isLat)) {\n        return [\n            [result[0], result[1]],\n            [result[2], result[3]]\n        ];\n    }\n    return undefined;\n}\nfunction parseCenter(center) {\n    // supported formats\n    // string: \"-96.657715,40.126127,-90.140061,43.516689\",\n    // array: [-91.505127,41.615442,14]\n    const result = fromArrayOrString(center);\n    if (Array.isArray(result) &&\n        result.length === 3 &&\n        isLng(result[0]) &&\n        isLat(result[1]) &&\n        isZoom(result[2])) {\n        return result;\n    }\n    return null;\n}\nfunction safeParseFloat(input) {\n    const result = typeof input === 'string' ? parseFloat(input) : typeof input === 'number' ? input : null;\n    return result === null || isNaN(result) ? null : result;\n}\n// https://github.com/mapbox/tilejson-spec/tree/master/2.2.0\nfunction isLat(num) {\n    return Number.isFinite(num) && num <= 90 && num >= -90;\n}\nfunction isLng(num) {\n    return Number.isFinite(num) && num <= 180 && num >= -180;\n}\nfunction isZoom(num) {\n    return Number.isFinite(num) && num >= 0 && num <= 22;\n}\nfunction fromArrayOrString(data) {\n    if (typeof data === 'string') {\n        return data.split(',').map(parseFloat);\n    }\n    else if (Array.isArray(data)) {\n        return data;\n    }\n    return null;\n}\n// possible types https://github.com/mapbox/tippecanoe#modifying-feature-attributes\nconst attrTypeMap = {\n    number: {\n        type: 'float32'\n    },\n    numeric: {\n        type: 'float32'\n    },\n    string: {\n        type: 'utf8'\n    },\n    vachar: {\n        type: 'utf8'\n    },\n    float: {\n        type: 'float32'\n    },\n    int: {\n        type: 'int32'\n    },\n    int4: {\n        type: 'int32'\n    },\n    boolean: {\n        type: 'boolean'\n    },\n    bool: {\n        type: 'boolean'\n    }\n};\nfunction attributeToField(attribute = {}, options) {\n    const fieldTypes = attributeTypeToFieldType(attribute.type);\n    const field = {\n        name: attribute.attribute,\n        // what happens if attribute type is string...\n        // filterProps: getFilterProps(fieldTypes.type, attribute),\n        ...fieldTypes\n    };\n    // attribute: \"_season_peaks_color\"\n    // count: 1000\n    // max: 0.95\n    // min: 0.24375\n    // type: \"number\"\n    if (typeof attribute.min === 'number') {\n        field.min = attribute.min;\n    }\n    if (typeof attribute.max === 'number') {\n        field.max = attribute.max;\n    }\n    if (typeof attribute.count === 'number') {\n        field.uniqueValueCount = attribute.count;\n    }\n    if (attribute.values) {\n        // Too much data? Add option?\n        field.values = attribute.values;\n    }\n    if (field.values && typeof options.maxValues === 'number') {\n        // Too much data? Add option?\n        field.values = field.values?.slice(0, options.maxValues);\n    }\n    return field;\n}\nfunction attributeTypeToFieldType(aType) {\n    const type = aType.toLowerCase();\n    if (!type || !attrTypeMap[type]) {\n        // console.warn(\n        //   `cannot convert attribute type ${type} to loaders.gl data type, use string by default`\n        // );\n    }\n    return attrTypeMap[type] || { type: 'string' };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}