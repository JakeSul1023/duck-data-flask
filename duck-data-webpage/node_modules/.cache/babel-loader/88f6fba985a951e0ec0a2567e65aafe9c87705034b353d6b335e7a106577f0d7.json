{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log, createIterable, project32, Viewport } from '@deck.gl/core';\nimport { WebGLAggregator, CPUAggregator } from \"../common/aggregator/index.js\";\nimport AggregationLayer from \"../common/aggregation-layer.js\";\nimport { defaultColorRange } from \"../common/utils/color-utils.js\";\nimport { AttributeWithScale } from \"../common/utils/scale-utils.js\";\nimport { getBinIdRange } from \"../common/utils/bounds-utils.js\";\nimport { GridCellLayer } from \"./grid-cell-layer.js\";\nimport { binOptionsUniforms } from \"./bin-options-uniforms.js\";\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\nconst defaultProps = {\n  gpuAggregation: true,\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorValue: {\n    type: 'accessor',\n    value: null\n  },\n  // default value is calculated from `getColorWeight` and `colorAggregation`\n  getColorWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  colorAggregation: 'SUM',\n  lowerPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 0\n  },\n  upperPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 100\n  },\n  colorScaleType: 'quantize',\n  onSetColorDomain: noop,\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationValue: {\n    type: 'accessor',\n    value: null\n  },\n  // default value is calculated from `getElevationWeight` and `elevationAggregation`\n  getElevationWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  elevationAggregation: 'SUM',\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  elevationLowerPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 0\n  },\n  elevationUpperPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 100\n  },\n  elevationScaleType: 'linear',\n  onSetElevationDomain: noop,\n  // grid\n  cellSize: {\n    type: 'number',\n    min: 0,\n    value: 1000\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  gridAggregator: {\n    type: 'function',\n    optional: true,\n    value: null\n  },\n  extruded: false,\n  // Optional material for 'lighting' shader module\n  material: true\n};\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\nclass GridLayer extends AggregationLayer {\n  getAggregatorType() {\n    const {\n      gpuAggregation,\n      gridAggregator,\n      getColorValue,\n      getElevationValue\n    } = this.props;\n    if (gpuAggregation && (gridAggregator || getColorValue || getElevationValue)) {\n      // If these features are desired by the app, the user should explicitly use CPU aggregation\n      log.warn('Features not supported by GPU aggregation, falling back to CPU')();\n      return 'cpu';\n    }\n    if (\n    // GPU aggregation is requested\n    gpuAggregation &&\n    // GPU aggregation is supported by the device\n    WebGLAggregator.isSupported(this.context.device)) {\n      return 'gpu';\n    }\n    return 'cpu';\n  }\n  createAggregator(type) {\n    if (type === 'cpu') {\n      const {\n        gridAggregator,\n        cellSize\n      } = this.props;\n      return new CPUAggregator({\n        dimensions: 2,\n        getBin: {\n          sources: ['positions'],\n          getValue: ({\n            positions\n          }, index, opts) => {\n            if (gridAggregator) {\n              return gridAggregator(positions, cellSize);\n            }\n            const viewport = this.state.aggregatorViewport;\n            // project to common space\n            const p = viewport.projectPosition(positions);\n            const {\n              cellSizeCommon,\n              cellOriginCommon\n            } = opts;\n            return [Math.floor((p[0] - cellOriginCommon[0]) / cellSizeCommon[0]), Math.floor((p[1] - cellOriginCommon[1]) / cellSizeCommon[1])];\n          }\n        },\n        getValue: [{\n          sources: ['colorWeights'],\n          getValue: ({\n            colorWeights\n          }) => colorWeights\n        }, {\n          sources: ['elevationWeights'],\n          getValue: ({\n            elevationWeights\n          }) => elevationWeights\n        }]\n      });\n    }\n    return new WebGLAggregator(this.context.device, {\n      dimensions: 2,\n      channelCount: 2,\n      bufferLayout: this.getAttributeManager().getBufferLayouts({\n        isInstanced: false\n      }),\n      ...super.getShaders({\n        modules: [project32, binOptionsUniforms],\n        vs: /* glsl */`\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float colorWeights;\n  in float elevationWeights;\n\n  void getBin(out ivec2 binId) {\n    vec3 positionCommon = project_position(positions, positions64Low);\n    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);\n    binId = ivec2(gridCoords);\n  }\n  void getValue(out vec2 value) {\n    value = vec2(colorWeights, elevationWeights);\n  }\n  `\n      })\n    });\n  }\n  initializeState() {\n    super.initializeState();\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 'float64',\n        fp64: this.use64bitPositions()\n      },\n      colorWeights: {\n        size: 1,\n        accessor: 'getColorWeight'\n      },\n      elevationWeights: {\n        size: 1,\n        accessor: 'getElevationWeight'\n      }\n    });\n  }\n  updateState(params) {\n    const aggregatorChanged = super.updateState(params);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const {\n      aggregator\n    } = this.state;\n    if ((changeFlags.dataChanged || !this.state.dataAsArray) && (props.getColorValue || props.getElevationValue)) {\n      // Convert data to array\n      this.state.dataAsArray = Array.from(createIterable(props.data).iterable);\n    }\n    if (aggregatorChanged || changeFlags.dataChanged || props.cellSize !== oldProps.cellSize || props.getColorValue !== oldProps.getColorValue || props.getElevationValue !== oldProps.getElevationValue || props.colorAggregation !== oldProps.colorAggregation || props.elevationAggregation !== oldProps.elevationAggregation) {\n      this._updateBinOptions();\n      const {\n        cellSizeCommon,\n        cellOriginCommon,\n        binIdRange,\n        dataAsArray\n      } = this.state;\n      aggregator.setProps({\n        // @ts-expect-error only used by GPUAggregator\n        binIdRange,\n        pointCount: this.getNumInstances(),\n        operations: [props.colorAggregation, props.elevationAggregation],\n        binOptions: {\n          cellSizeCommon,\n          cellOriginCommon\n        },\n        onUpdate: this._onAggregationUpdate.bind(this)\n      });\n      if (dataAsArray) {\n        const {\n          getColorValue,\n          getElevationValue\n        } = this.props;\n        aggregator.setProps({\n          // @ts-expect-error only used by CPUAggregator\n          customOperations: [getColorValue && (indices => getColorValue(indices.map(i => dataAsArray[i]), {\n            indices,\n            data: props.data\n          })), getElevationValue && (indices => getElevationValue(indices.map(i => dataAsArray[i]), {\n            indices,\n            data: props.data\n          }))]\n        });\n      }\n    }\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getColorValue) {\n      aggregator.setNeedsUpdate(0);\n    }\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getElevationValue) {\n      aggregator.setNeedsUpdate(1);\n    }\n    return aggregatorChanged;\n  }\n  _updateBinOptions() {\n    const bounds = this.getBounds();\n    const cellSizeCommon = [1, 1];\n    let cellOriginCommon = [0, 0];\n    let binIdRange = [[0, 1], [0, 1]];\n    let viewport = this.context.viewport;\n    if (bounds && Number.isFinite(bounds[0][0])) {\n      let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];\n      const {\n        cellSize\n      } = this.props;\n      const {\n        unitsPerMeter\n      } = viewport.getDistanceScales(centroid);\n      cellSizeCommon[0] = unitsPerMeter[0] * cellSize;\n      cellSizeCommon[1] = unitsPerMeter[1] * cellSize;\n      // Offset common space to center at the origin of the grid cell where the data center is in\n      // This improves precision without affecting the cell positions\n      const centroidCommon = viewport.projectFlat(centroid);\n      cellOriginCommon = [Math.floor(centroidCommon[0] / cellSizeCommon[0]) * cellSizeCommon[0], Math.floor(centroidCommon[1] / cellSizeCommon[1]) * cellSizeCommon[1]];\n      centroid = viewport.unprojectFlat(cellOriginCommon);\n      const ViewportType = viewport.constructor;\n      // We construct a viewport for the GPU aggregator's project module\n      // This viewport is determined by data\n      // removes arbitrary precision variance that depends on initial view state\n      viewport = viewport.isGeospatial ? new ViewportType({\n        longitude: centroid[0],\n        latitude: centroid[1],\n        zoom: 12\n      }) : new Viewport({\n        position: [centroid[0], centroid[1], 0],\n        zoom: 12\n      });\n      // Round to the nearest 32-bit float to match CPU and GPU results\n      cellOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];\n      binIdRange = getBinIdRange({\n        dataBounds: bounds,\n        getBinId: p => {\n          const positionCommon = viewport.projectFlat(p);\n          return [Math.floor((positionCommon[0] - cellOriginCommon[0]) / cellSizeCommon[0]), Math.floor((positionCommon[1] - cellOriginCommon[1]) / cellSizeCommon[1])];\n        }\n      });\n    }\n    this.setState({\n      cellSizeCommon,\n      cellOriginCommon,\n      binIdRange,\n      aggregatorViewport: viewport\n    });\n  }\n  draw(opts) {\n    // Replaces render time viewport with our own\n    if (opts.shaderModuleProps.project) {\n      opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;\n    }\n    super.draw(opts);\n  }\n  _onAggregationUpdate({\n    channel\n  }) {\n    const props = this.getCurrentLayer().props;\n    const {\n      aggregator\n    } = this.state;\n    if (channel === 0) {\n      const result = aggregator.getResult(0);\n      this.setState({\n        colors: new AttributeWithScale(result, aggregator.binCount)\n      });\n      props.onSetColorDomain(aggregator.getResultDomain(0));\n    } else if (channel === 1) {\n      const result = aggregator.getResult(1);\n      this.setState({\n        elevations: new AttributeWithScale(result, aggregator.binCount)\n      });\n      props.onSetElevationDomain(aggregator.getResultDomain(1));\n    }\n  }\n  onAttributeChange(id) {\n    const {\n      aggregator\n    } = this.state;\n    switch (id) {\n      case 'positions':\n        aggregator.setNeedsUpdate();\n        this._updateBinOptions();\n        const {\n          cellSizeCommon,\n          cellOriginCommon,\n          binIdRange\n        } = this.state;\n        aggregator.setProps({\n          // @ts-expect-error only used by GPUAggregator\n          binIdRange,\n          binOptions: {\n            cellSizeCommon,\n            cellOriginCommon\n          }\n        });\n        break;\n      case 'colorWeights':\n        aggregator.setNeedsUpdate(0);\n        break;\n      case 'elevationWeights':\n        aggregator.setNeedsUpdate(1);\n        break;\n      default:\n      // This should not happen\n    }\n  }\n  renderLayers() {\n    const {\n      aggregator,\n      cellOriginCommon,\n      cellSizeCommon\n    } = this.state;\n    const {\n      elevationScale,\n      colorRange,\n      elevationRange,\n      extruded,\n      coverage,\n      material,\n      transitions,\n      colorScaleType,\n      lowerPercentile,\n      upperPercentile,\n      colorDomain,\n      elevationScaleType,\n      elevationLowerPercentile,\n      elevationUpperPercentile,\n      elevationDomain\n    } = this.props;\n    const CellLayerClass = this.getSubLayerClass('cells', GridCellLayer);\n    const binAttribute = aggregator.getBins();\n    const colors = this.state.colors?.update({\n      scaleType: colorScaleType,\n      lowerPercentile,\n      upperPercentile\n    });\n    const elevations = this.state.elevations?.update({\n      scaleType: elevationScaleType,\n      lowerPercentile: elevationLowerPercentile,\n      upperPercentile: elevationUpperPercentile\n    });\n    if (!colors || !elevations) {\n      return null;\n    }\n    return new CellLayerClass(this.getSubLayerProps({\n      id: 'cells'\n    }), {\n      data: {\n        length: aggregator.binCount,\n        attributes: {\n          getBin: binAttribute,\n          getColorValue: colors.attribute,\n          getElevationValue: elevations.attribute\n        }\n      },\n      // Data has changed shallowly, but we likely don't need to update the attributes\n      dataComparator: (data, oldData) => data.length === oldData.length,\n      updateTriggers: {\n        getBin: [binAttribute],\n        getColorValue: [colors.attribute],\n        getElevationValue: [elevations.attribute]\n      },\n      cellOriginCommon,\n      cellSizeCommon,\n      elevationScale,\n      colorRange,\n      colorScaleType,\n      elevationRange,\n      extruded,\n      coverage,\n      material,\n      colorDomain: colors.domain || colorDomain || aggregator.getResultDomain(0),\n      elevationDomain: elevations.domain || elevationDomain || aggregator.getResultDomain(1),\n      colorCutoff: colors.cutoff,\n      elevationCutoff: elevations.cutoff,\n      transitions: transitions && {\n        getFillColor: transitions.getColorValue || transitions.getColorWeight,\n        getElevation: transitions.getElevationValue || transitions.getElevationWeight\n      },\n      // Extensions are already handled by the GPUAggregator, do not pass it down\n      extensions: []\n    });\n  }\n  getPickingInfo(params) {\n    const info = params.info;\n    const {\n      index\n    } = info;\n    if (index >= 0) {\n      const bin = this.state.aggregator.getBin(index);\n      let object;\n      if (bin) {\n        object = {\n          col: bin.id[0],\n          row: bin.id[1],\n          colorValue: bin.value[0],\n          elevationValue: bin.value[1],\n          count: bin.count\n        };\n        if (bin.pointIndices) {\n          object.pointIndices = bin.pointIndices;\n          object.points = Array.isArray(this.props.data) ? bin.pointIndices.map(i => this.props.data[i]) : [];\n        }\n      }\n      info.object = object;\n    }\n    return info;\n  }\n}\nGridLayer.layerName = 'GridLayer';\nGridLayer.defaultProps = defaultProps;\nexport default GridLayer;\n//# sourceMappingURL=grid-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}