{"ast":null,"code":"// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Manager as HammerManager } from \"./hammerjs/index.js\";\nimport { WheelInput } from \"./inputs/wheel-input.js\";\nimport { MoveInput } from \"./inputs/move-input.js\";\nimport { KeyInput } from \"./inputs/key-input.js\";\nimport { ContextmenuInput } from \"./inputs/contextmenu-input.js\";\nimport { EventRegistrar } from \"./utils/event-registrar.js\";\nfunction normalizeRecognizer(item) {\n  if ('recognizer' in item) {\n    return item;\n  }\n  let recognizer;\n  const itemArray = Array.isArray(item) ? [...item] : [item];\n  if (typeof itemArray[0] === 'function') {\n    // Backward compatibility: v2 / hammerjs style\n    const RecognizerType = itemArray.shift();\n    const options = itemArray.shift() || {};\n    recognizer = new RecognizerType(options);\n  } else {\n    recognizer = itemArray.shift();\n  }\n  return {\n    recognizer,\n    recognizeWith: typeof itemArray[0] === 'string' ? [itemArray[0]] : itemArray[0],\n    requireFailure: typeof itemArray[1] === 'string' ? [itemArray[1]] : itemArray[1]\n  };\n}\n// Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\nexport class EventManager {\n  constructor(element = null, options = {}) {\n    /**\n     * Handle basic events using the 'hammer.input' Hammer.js API:\n     * Before running Recognizers, Hammer emits a 'hammer.input' event\n     * with the basic event info. This function emits all basic events\n     * aliased to the \"class\" of event received.\n     * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n     */\n    this._onBasicInput = event => {\n      this.manager.emit(event.srcEvent.type, event);\n    };\n    /**\n     * Handle events not supported by Hammer.js,\n     * and pipe back out through same (Hammer) channel used by other events.\n     */\n    this._onOtherEvent = event => {\n      // console.log('onotherevent', event.type, event)\n      this.manager.emit(event.type, event);\n    };\n    this.options = {\n      recognizers: [],\n      events: {},\n      touchAction: 'compute',\n      tabIndex: 0,\n      cssProps: {},\n      ...options\n    };\n    this.events = new Map();\n    this.element = element;\n    if (!element) return;\n    this.manager = new HammerManager(element, this.options);\n    for (const item of this.options.recognizers) {\n      const {\n        recognizer,\n        recognizeWith,\n        requireFailure\n      } = normalizeRecognizer(item);\n      this.manager.add(recognizer);\n      if (recognizeWith) {\n        recognizer.recognizeWith(recognizeWith);\n      }\n      if (requireFailure) {\n        recognizer.requireFailure(requireFailure);\n      }\n    }\n    this.manager.on('hammer.input', this._onBasicInput);\n    // Handle events not handled by Hammer.js:\n    // - mouse wheel\n    // - pointer/touch/mouse move\n    this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.moveInput = new MoveInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.keyInput = new KeyInput(element, this._onOtherEvent, {\n      enable: false,\n      tabIndex: options.tabIndex\n    });\n    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    // Register all passed events.\n    this.on(this.options.events);\n  }\n  getElement() {\n    return this.element;\n  }\n  // Tear down internal event management implementations.\n  destroy() {\n    // manager etc. cannot exist if there is no element\n    if (!this.element) return;\n    this.wheelInput.destroy();\n    this.moveInput.destroy();\n    this.keyInput.destroy();\n    this.contextmenuInput.destroy();\n    this.manager.destroy();\n  }\n  /** Register an event handler function to be called on `event` */\n  on(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false);\n  }\n  once(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, true);\n  }\n  watch(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false, true);\n  }\n  off(event, handler) {\n    this._removeEventHandler(event, handler);\n  }\n  /*\n   * Enable/disable recognizer for the given event\n   */\n  _toggleRecognizer(name, enabled) {\n    const {\n      manager\n    } = this;\n    if (!manager) {\n      return;\n    }\n    const recognizer = manager.get(name);\n    if (recognizer) {\n      recognizer.set({\n        enable: enabled\n      });\n      manager.touchAction.update();\n    }\n    this.wheelInput?.enableEventType(name, enabled);\n    this.moveInput?.enableEventType(name, enabled);\n    this.keyInput?.enableEventType(name, enabled);\n    this.contextmenuInput?.enableEventType(name, enabled);\n  }\n  /**\n   * Process the event registration for a single event + handler.\n   */\n  _addEventHandler(event, handler, opts, once, passive) {\n    if (typeof event !== 'string') {\n      // @ts-ignore\n      opts = handler;\n      // If `event` is a map, call `on()` for each entry.\n      for (const [eventName, eventHandler] of Object.entries(event)) {\n        this._addEventHandler(eventName, eventHandler, opts, once, passive);\n      }\n      return;\n    }\n    const {\n      manager,\n      events\n    } = this;\n    if (!manager) return;\n    let eventRegistrar = events.get(event);\n    if (!eventRegistrar) {\n      // Enable recognizer for this event.\n      const recognizerName = this._getRecognizerName(event) || event;\n      eventRegistrar = new EventRegistrar(this, recognizerName);\n      events.set(event, eventRegistrar);\n      // Listen to the event\n      if (manager) {\n        manager.on(event, eventRegistrar.handleEvent);\n      }\n    }\n    eventRegistrar.add(event, handler, opts, once, passive);\n    if (!eventRegistrar.isEmpty()) {\n      this._toggleRecognizer(eventRegistrar.recognizerName, true);\n    }\n  }\n  /**\n   * Process the event deregistration for a single event + handler.\n   */\n  _removeEventHandler(event, handler) {\n    if (typeof event !== 'string') {\n      // If `event` is a map, call `off()` for each entry.\n      for (const [eventName, eventHandler] of Object.entries(event)) {\n        this._removeEventHandler(eventName, eventHandler);\n      }\n      return;\n    }\n    const {\n      events\n    } = this;\n    const eventRegistrar = events.get(event);\n    if (!eventRegistrar) {\n      return;\n    }\n    eventRegistrar.remove(event, handler);\n    if (eventRegistrar.isEmpty()) {\n      const {\n        recognizerName\n      } = eventRegistrar;\n      // Disable recognizer if no more handlers are attached to its events\n      let isRecognizerUsed = false;\n      for (const eh of events.values()) {\n        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n          isRecognizerUsed = true;\n          break;\n        }\n      }\n      if (!isRecognizerUsed) {\n        this._toggleRecognizer(recognizerName, false);\n      }\n    }\n  }\n  _getRecognizerName(event) {\n    return this.manager.recognizers.find(recognizer => {\n      return recognizer.getEventNames().includes(event);\n    })?.options.event;\n  }\n}\n//# sourceMappingURL=event-manager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}