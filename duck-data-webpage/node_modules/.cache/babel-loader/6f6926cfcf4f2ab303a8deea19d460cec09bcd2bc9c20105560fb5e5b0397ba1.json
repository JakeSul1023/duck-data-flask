{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { CompositeLayer } from '@deck.gl/core';\nimport { replaceInRange } from \"../utils.js\";\nimport { binaryToFeatureForAccesor } from \"./geojson-binary.js\";\nimport { POINT_LAYER, LINE_LAYER, POLYGON_LAYER, getDefaultProps, forwardProps } from \"./sub-layer-map.js\";\nimport { getGeojsonFeatures, separateGeojsonFeatures } from \"./geojson.js\";\nimport { createLayerPropsFromFeatures, createLayerPropsFromBinary } from \"./geojson-layer-props.js\";\nconst FEATURE_TYPES = ['points', 'linestrings', 'polygons'];\nconst defaultProps = {\n  ...getDefaultProps(POINT_LAYER.circle),\n  ...getDefaultProps(POINT_LAYER.icon),\n  ...getDefaultProps(POINT_LAYER.text),\n  ...getDefaultProps(LINE_LAYER),\n  ...getDefaultProps(POLYGON_LAYER),\n  // Overwrite sub layer defaults\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  _full3d: false,\n  iconAtlas: {\n    type: 'object',\n    value: null\n  },\n  iconMapping: {\n    type: 'object',\n    value: {}\n  },\n  getIcon: {\n    type: 'accessor',\n    value: f => f.properties.icon\n  },\n  getText: {\n    type: 'accessor',\n    value: f => f.properties.text\n  },\n  // Self props\n  pointType: 'circle',\n  // TODO: deprecated, remove in v9\n  getRadius: {\n    deprecatedFor: 'getPointRadius'\n  }\n};\n/** Render GeoJSON formatted data as polygons, lines and points (circles, icons and/or texts). */\nclass GeoJsonLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      layerProps: {},\n      features: {},\n      featuresDiff: {}\n    };\n  }\n  updateState({\n    props,\n    changeFlags\n  }) {\n    if (!changeFlags.dataChanged) {\n      return;\n    }\n    const {\n      data\n    } = this.props;\n    const binary = data && 'points' in data && 'polygons' in data && 'lines' in data;\n    this.setState({\n      binary\n    });\n    if (binary) {\n      this._updateStateBinary({\n        props,\n        changeFlags\n      });\n    } else {\n      this._updateStateJSON({\n        props,\n        changeFlags\n      });\n    }\n  }\n  _updateStateBinary({\n    props,\n    changeFlags\n  }) {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);\n    this.setState({\n      layerProps\n    });\n  }\n  _updateStateJSON({\n    props,\n    changeFlags\n  }) {\n    const features = getGeojsonFeatures(props.data);\n    const wrapFeature = this.getSubLayerRow.bind(this);\n    let newFeatures = {};\n    const featuresDiff = {};\n    if (Array.isArray(changeFlags.dataChanged)) {\n      const oldFeatures = this.state.features;\n      for (const key in oldFeatures) {\n        newFeatures[key] = oldFeatures[key].slice();\n        featuresDiff[key] = [];\n      }\n      for (const dataRange of changeFlags.dataChanged) {\n        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);\n        for (const key in oldFeatures) {\n          featuresDiff[key].push(replaceInRange({\n            data: newFeatures[key],\n            getIndex: f => f.__source.index,\n            dataRange,\n            replace: partialFeatures[key]\n          }));\n        }\n      }\n    } else {\n      newFeatures = separateGeojsonFeatures(features, wrapFeature);\n    }\n    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);\n    this.setState({\n      features: newFeatures,\n      featuresDiff,\n      layerProps\n    });\n  }\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {\n      index,\n      sourceLayer\n    } = info;\n    info.featureType = FEATURE_TYPES.find(ft => sourceLayer.id.startsWith(`${this.id}-${ft}-`));\n    if (index >= 0 && sourceLayer.id.startsWith(`${this.id}-points-text`) && this.state.binary) {\n      info.index = this.props.data.points.globalFeatureIds.value[index];\n    }\n    return info;\n  }\n  _updateAutoHighlight(info) {\n    // All sub layers except the points layer use source feature index to encode the picking color\n    // The points layer uses indices from the points data array.\n    const pointLayerIdPrefix = `${this.id}-points-`;\n    const sourceIsPoints = info.featureType === 'points';\n    for (const layer of this.getSubLayers()) {\n      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {\n        layer.updateAutoHighlight(info);\n      }\n    }\n  }\n  _renderPolygonLayer() {\n    const {\n      extruded,\n      wireframe\n    } = this.props;\n    const {\n      layerProps\n    } = this.state;\n    const id = 'polygons-fill';\n    const PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons?.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);\n    if (PolygonFillLayer) {\n      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);\n      // Avoid building the lineColors attribute if wireframe is off\n      const useLineColor = extruded && wireframe;\n      if (!useLineColor) {\n        delete forwardedProps.getLineColor;\n      }\n      // using a legacy API to invalid lineColor attributes\n      forwardedProps.updateTriggers.lineColors = useLineColor;\n      return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({\n        id,\n        updateTriggers: forwardedProps.updateTriggers\n      }), layerProps.polygons);\n    }\n    return null;\n  }\n  _renderLineLayers() {\n    const {\n      extruded,\n      stroked\n    } = this.props;\n    const {\n      layerProps\n    } = this.state;\n    const polygonStrokeLayerId = 'polygons-stroke';\n    const lineStringsLayerId = 'linestrings';\n    const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline?.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);\n    const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines?.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);\n    if (PolygonStrokeLayer || LineStringsLayer) {\n      const forwardedProps = forwardProps(this, LINE_LAYER.props);\n      return [PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({\n        id: polygonStrokeLayerId,\n        updateTriggers: forwardedProps.updateTriggers\n      }), layerProps.polygonsOutline), LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({\n        id: lineStringsLayerId,\n        updateTriggers: forwardedProps.updateTriggers\n      }), layerProps.lines)];\n    }\n    return null;\n  }\n  _renderPointLayers() {\n    const {\n      pointType\n    } = this.props;\n    const {\n      layerProps,\n      binary\n    } = this.state;\n    let {\n      highlightedObjectIndex\n    } = this.props;\n    if (!binary && Number.isFinite(highlightedObjectIndex)) {\n      // @ts-expect-error TODO - type non-binary data\n      highlightedObjectIndex = layerProps.points.data.findIndex(d => d.__source.index === highlightedObjectIndex);\n    }\n    // Avoid duplicate sub layer ids\n    const types = new Set(pointType.split('+'));\n    const pointLayers = [];\n    for (const type of types) {\n      const id = `points-${type}`;\n      const PointLayerMapping = POINT_LAYER[type];\n      const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points?.data) && this.getSubLayerClass(id, PointLayerMapping.type);\n      if (PointsLayer) {\n        const forwardedProps = forwardProps(this, PointLayerMapping.props);\n        let pointsLayerProps = layerProps.points;\n        if (type === 'text' && binary) {\n          // Picking colors are per-point but for text per-character are required\n          // getPickingInfo() maps back to the correct index\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          // @ts-expect-error TODO - type binary data\n          const {\n            instancePickingColors,\n            ...rest\n          } = pointsLayerProps.data.attributes;\n          pointsLayerProps = {\n            ...pointsLayerProps,\n            // @ts-expect-error TODO - type binary data\n            data: {\n              ...pointsLayerProps.data,\n              attributes: rest\n            }\n          };\n        }\n        pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({\n          id,\n          updateTriggers: forwardedProps.updateTriggers,\n          highlightedObjectIndex\n        }), pointsLayerProps));\n      }\n    }\n    return pointLayers;\n  }\n  renderLayers() {\n    const {\n      extruded\n    } = this.props;\n    const polygonFillLayer = this._renderPolygonLayer();\n    const lineLayers = this._renderLineLayers();\n    const pointLayers = this._renderPointLayers();\n    return [\n    // If not extruded: flat fill layer is drawn below outlines\n    !extruded && polygonFillLayer, lineLayers, pointLayers,\n    // If extruded: draw fill layer last for correct blending behavior\n    extruded && polygonFillLayer];\n  }\n  getSubLayerAccessor(accessor) {\n    const {\n      binary\n    } = this.state;\n    if (!binary || typeof accessor !== 'function') {\n      return super.getSubLayerAccessor(accessor);\n    }\n    return (object, info) => {\n      const {\n        data,\n        index\n      } = info;\n      const feature = binaryToFeatureForAccesor(data, index);\n      // @ts-ignore (TS2349) accessor is always function\n      return accessor(feature, info);\n    };\n  }\n}\nGeoJsonLayer.layerName = 'GeoJsonLayer';\nGeoJsonLayer.defaultProps = defaultProps;\nexport default GeoJsonLayer;\n//# sourceMappingURL=geojson-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}