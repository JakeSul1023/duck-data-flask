{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { EVENT_HANDLERS } from \"./constants.js\";\nimport { deepEqual } from \"../utils/deep-equal.js\";\nconst PLACEMENTS = {\n  'top-left': {\n    top: 0,\n    left: 0\n  },\n  'top-right': {\n    top: 0,\n    right: 0\n  },\n  'bottom-left': {\n    bottom: 0,\n    left: 0\n  },\n  'bottom-right': {\n    bottom: 0,\n    right: 0\n  },\n  fill: {\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0\n  }\n};\nconst DEFAULT_PLACEMENT = 'top-left';\nconst ROOT_CONTAINER_ID = '__root';\nexport class WidgetManager {\n  constructor(_ref) {\n    let {\n      deck,\n      parentElement\n    } = _ref;\n    /** Widgets added via the imperative API */\n    this.defaultWidgets = [];\n    /** Widgets received from the declarative API */\n    this.widgets = [];\n    /** Resolved widgets from both imperative and declarative APIs */\n    this.resolvedWidgets = [];\n    /** Mounted HTML containers */\n    this.containers = {};\n    /** Viewport provided to widget on redraw */\n    this.lastViewports = {};\n    this.deck = deck;\n    this.parentElement = parentElement;\n  }\n  getWidgets() {\n    return this.resolvedWidgets;\n  }\n  /** Declarative API to configure widgets */\n  setProps(props) {\n    if (props.widgets && !deepEqual(props.widgets, this.widgets, 1)) {\n      this._setWidgets(props.widgets);\n    }\n  }\n  finalize() {\n    for (const widget of this.getWidgets()) {\n      this._remove(widget);\n    }\n    this.defaultWidgets.length = 0;\n    this.resolvedWidgets.length = 0;\n    for (const id in this.containers) {\n      this.containers[id].remove();\n    }\n  }\n  /** Imperative API. Widgets added this way are not affected by the declarative prop. */\n  addDefault(widget) {\n    if (!this.defaultWidgets.find(w => w.id === widget.id)) {\n      this._add(widget);\n      this.defaultWidgets.push(widget);\n      // Update widget list\n      this._setWidgets(this.widgets);\n    }\n  }\n  /** Resolve widgets from the declarative prop */\n  _setWidgets(nextWidgets) {\n    const oldWidgetMap = {};\n    for (const widget of this.resolvedWidgets) {\n      oldWidgetMap[widget.id] = widget;\n    }\n    // Clear and rebuild the list\n    this.resolvedWidgets.length = 0;\n    // Add all default widgets\n    for (const widget of this.defaultWidgets) {\n      oldWidgetMap[widget.id] = null;\n      this.resolvedWidgets.push(widget);\n    }\n    for (let widget of nextWidgets) {\n      const oldWidget = oldWidgetMap[widget.id];\n      if (!oldWidget) {\n        // Widget is new\n        this._add(widget);\n      } else if (\n      // Widget placement changed\n      oldWidget.viewId !== widget.viewId || oldWidget.placement !== widget.placement) {\n        this._remove(oldWidget);\n        this._add(widget);\n      } else if (widget !== oldWidget) {\n        // Widget props changed\n        oldWidget.setProps(widget.props);\n        widget = oldWidget;\n      }\n      // mark as matched\n      oldWidgetMap[widget.id] = null;\n      this.resolvedWidgets.push(widget);\n    }\n    for (const id in oldWidgetMap) {\n      const oldWidget = oldWidgetMap[id];\n      if (oldWidget) {\n        // No longer exists\n        this._remove(oldWidget);\n      }\n    }\n    this.widgets = nextWidgets;\n  }\n  _add(widget) {\n    const {\n      viewId = null,\n      placement = DEFAULT_PLACEMENT\n    } = widget;\n    const element = widget.onAdd({\n      deck: this.deck,\n      viewId\n    });\n    if (element) {\n      this._getContainer(viewId, placement).append(element);\n    }\n    widget._element = element;\n  }\n  _remove(widget) {\n    widget.onRemove?.();\n    if (widget._element) {\n      widget._element.remove();\n    }\n    widget._element = undefined;\n  }\n  /* global document */\n  _getContainer(viewId, placement) {\n    const containerId = viewId || ROOT_CONTAINER_ID;\n    let viewContainer = this.containers[containerId];\n    if (!viewContainer) {\n      viewContainer = document.createElement('div');\n      viewContainer.style.pointerEvents = 'none';\n      viewContainer.style.position = 'absolute';\n      viewContainer.style.overflow = 'hidden';\n      this.parentElement?.append(viewContainer);\n      this.containers[containerId] = viewContainer;\n    }\n    let container = viewContainer.querySelector(`.${placement}`);\n    if (!container) {\n      container = document.createElement('div');\n      container.className = placement;\n      container.style.position = 'absolute';\n      container.style.zIndex = '2';\n      Object.assign(container.style, PLACEMENTS[placement]);\n      viewContainer.append(container);\n    }\n    return container;\n  }\n  _updateContainers() {\n    const canvasWidth = this.deck.width;\n    const canvasHeight = this.deck.height;\n    for (const id in this.containers) {\n      const viewport = this.lastViewports[id] || null;\n      const visible = id === ROOT_CONTAINER_ID || viewport;\n      const container = this.containers[id];\n      if (visible) {\n        container.style.display = 'block';\n        // Align the container with the view\n        container.style.left = `${viewport ? viewport.x : 0}px`;\n        container.style.top = `${viewport ? viewport.y : 0}px`;\n        container.style.width = `${viewport ? viewport.width : canvasWidth}px`;\n        container.style.height = `${viewport ? viewport.height : canvasHeight}px`;\n      } else {\n        container.style.display = 'none';\n      }\n    }\n  }\n  onRedraw(_ref2) {\n    let {\n      viewports,\n      layers\n    } = _ref2;\n    const viewportsById = viewports.reduce((acc, v) => {\n      acc[v.id] = v;\n      return acc;\n    }, {});\n    for (const widget of this.getWidgets()) {\n      const {\n        viewId\n      } = widget;\n      if (viewId) {\n        // Attached to a specific view\n        const viewport = viewportsById[viewId];\n        if (viewport) {\n          if (widget.onViewportChange) {\n            widget.onViewportChange(viewport);\n          }\n          widget.onRedraw?.({\n            viewports: [viewport],\n            layers\n          });\n        }\n      } else {\n        // Not attached to a specific view\n        if (widget.onViewportChange) {\n          for (const viewport of viewports) {\n            widget.onViewportChange(viewport);\n          }\n        }\n        widget.onRedraw?.({\n          viewports,\n          layers\n        });\n      }\n    }\n    this.lastViewports = viewportsById;\n    this._updateContainers();\n  }\n  onHover(info, event) {\n    for (const widget of this.getWidgets()) {\n      const {\n        viewId\n      } = widget;\n      if (!viewId || viewId === info.viewport?.id) {\n        widget.onHover?.(info, event);\n      }\n    }\n  }\n  onEvent(info, event) {\n    const eventHandlerProp = EVENT_HANDLERS[event.type];\n    if (!eventHandlerProp) {\n      return;\n    }\n    for (const widget of this.getWidgets()) {\n      const {\n        viewId\n      } = widget;\n      if (!viewId || viewId === info.viewport?.id) {\n        widget[eventHandlerProp]?.(info, event);\n      }\n    }\n  }\n}\n//# sourceMappingURL=widget-manager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}