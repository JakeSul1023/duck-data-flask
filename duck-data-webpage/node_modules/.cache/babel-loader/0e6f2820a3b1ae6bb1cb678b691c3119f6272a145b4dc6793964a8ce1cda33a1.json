{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n// TODO - Finish hierarchy suypport: this file is only half ported\n/* eslint-disable */\n// @ts-nocheck\nconst defined = x => x !== undefined;\nexport function initializeHierarchy(batchTable, jsonHeader, binaryBody) {\n  if (!jsonHeader) {\n    return null;\n  }\n  let hierarchy = batchTable.getExtension('3DTILES_batch_table_hierarchy');\n  const legacyHierarchy = jsonHeader.HIERARCHY;\n  if (legacyHierarchy) {\n    // eslint-disable-next-line\n    console.warn('3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.');\n    jsonHeader.extensions = jsonHeader.extensions || {};\n    jsonHeader.extensions['3DTILES_batch_table_hierarchy'] = legacyHierarchy;\n    hierarchy = legacyHierarchy;\n  }\n  if (!hierarchy) {\n    return null;\n  }\n  return initializeHierarchyValues(hierarchy, binaryBody);\n}\n// eslint-disable-next-line max-statements\nfunction initializeHierarchyValues(hierarchyJson, binaryBody) {\n  let i;\n  let classId;\n  let binaryAccessor;\n  const instancesLength = hierarchyJson.instancesLength;\n  const classes = hierarchyJson.classes;\n  let classIds = hierarchyJson.classIds;\n  let parentCounts = hierarchyJson.parentCounts;\n  let parentIds = hierarchyJson.parentIds;\n  let parentIdsLength = instancesLength;\n  if (defined(classIds.byteOffset)) {\n    classIds.componentType = defaultValue(classIds.componentType, GL.UNSIGNED_SHORT);\n    classIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(classIds);\n    classIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + classIds.byteOffset, instancesLength);\n  }\n  let parentIndexes;\n  if (defined(parentCounts)) {\n    if (defined(parentCounts.byteOffset)) {\n      parentCounts.componentType = defaultValue(parentCounts.componentType, GL.UNSIGNED_SHORT);\n      parentCounts.type = AttributeType.SCALAR;\n      binaryAccessor = getBinaryAccessor(parentCounts);\n      parentCounts = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentCounts.byteOffset, instancesLength);\n    }\n    parentIndexes = new Uint16Array(instancesLength);\n    parentIdsLength = 0;\n    for (i = 0; i < instancesLength; ++i) {\n      parentIndexes[i] = parentIdsLength;\n      parentIdsLength += parentCounts[i];\n    }\n  }\n  if (defined(parentIds) && defined(parentIds.byteOffset)) {\n    parentIds.componentType = defaultValue(parentIds.componentType, GL.UNSIGNED_SHORT);\n    parentIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(parentIds);\n    parentIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentIds.byteOffset, parentIdsLength);\n  }\n  const classesLength = classes.length;\n  for (i = 0; i < classesLength; ++i) {\n    const classInstancesLength = classes[i].length;\n    const properties = classes[i].instances;\n    const binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);\n    classes[i].instances = combine(binaryProperties, properties);\n  }\n  const classCounts = new Array(classesLength).fill(0);\n  const classIndexes = new Uint16Array(instancesLength);\n  for (i = 0; i < instancesLength; ++i) {\n    classId = classIds[i];\n    classIndexes[i] = classCounts[classId];\n    ++classCounts[classId];\n  }\n  const hierarchy = {\n    classes,\n    classIds,\n    classIndexes,\n    parentCounts,\n    parentIndexes,\n    parentIds\n  };\n  validateHierarchy(hierarchy);\n  return hierarchy;\n}\n// HELPER CODE\n// Traverse over the hierarchy and process each instance with the endConditionCallback.\n// When the endConditionCallback returns a value, the traversal stops and that value is returned.\nexport function traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {\n  if (!hierarchy) {\n    return;\n  }\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n  if (parentIds) {\n    return endConditionCallback(hierarchy, instanceIndex);\n  }\n  if (parentCounts > 0) {\n    return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);\n  }\n  return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);\n}\n// eslint-disable-next-line max-statements\nfunction traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {\n  const classIds = hierarchy.classIds;\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n  const parentIndexes = hierarchy.parentIndexes;\n  const instancesLength = classIds.length;\n  // Ignore instances that have already been visited. This occurs in diamond inheritance situations.\n  // Use a marker value to indicate that an instance has been visited, which increments with each run.\n  // This is more efficient than clearing the visited array every time.\n  const visited = scratchVisited;\n  visited.length = Math.max(visited.length, instancesLength);\n  const visitedMarker = ++marker;\n  const stack = scratchStack;\n  stack.length = 0;\n  stack.push(instanceIndex);\n  while (stack.length > 0) {\n    instanceIndex = stack.pop();\n    if (visited[instanceIndex] === visitedMarker) {\n      // This instance has already been visited, stop traversal\n      continue;\n    }\n    visited[instanceIndex] = visitedMarker;\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentCount = parentCounts[instanceIndex];\n    const parentIndex = parentIndexes[instanceIndex];\n    for (let i = 0; i < parentCount; ++i) {\n      const parentId = parentIds[parentIndex + i];\n      // Stop the traversal when the instance has no parent (its parentId equals itself)\n      // else add the parent to the stack to continue the traversal.\n      if (parentId !== instanceIndex) {\n        stack.push(parentId);\n      }\n    }\n  }\n  return null;\n}\nfunction traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {\n  let hasParent = true;\n  while (hasParent) {\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentId = hierarchy.parentIds[instanceIndex];\n    hasParent = parentId !== instanceIndex;\n    instanceIndex = parentId;\n  }\n  throw new Error('traverseHierarchySingleParent');\n}\n// DEBUG CODE\nfunction validateHierarchy(hierarchy) {\n  const scratchValidateStack = [];\n  const classIds = hierarchy.classIds;\n  const instancesLength = classIds.length;\n  for (let i = 0; i < instancesLength; ++i) {\n    validateInstance(hierarchy, i, stack);\n  }\n}\nfunction validateInstance(hierarchy, instanceIndex, stack) {\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n  const parentIndexes = hierarchy.parentIndexes;\n  const classIds = hierarchy.classIds;\n  const instancesLength = classIds.length;\n  if (!defined(parentIds)) {\n    // No need to validate if there are no parents\n    return;\n  }\n  assert(instanceIndex < instancesLength, `Parent index ${instanceIndex} exceeds the total number of instances: ${instancesLength}`);\n  assert(stack.indexOf(instanceIndex) === -1, 'Circular dependency detected in the batch table hierarchy.');\n  stack.push(instanceIndex);\n  const parentCount = defined(parentCounts) ? parentCounts[instanceIndex] : 1;\n  const parentIndex = defined(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;\n  for (let i = 0; i < parentCount; ++i) {\n    const parentId = parentIds[parentIndex + i];\n    // Stop the traversal when the instance has no parent (its parentId equals itself), else continue the traversal.\n    if (parentId !== instanceIndex) {\n      validateInstance(hierarchy, parentId, stack);\n    }\n  }\n  stack.pop(instanceIndex);\n}","map":{"version":3,"names":["defined","x","undefined","initializeHierarchy","batchTable","jsonHeader","binaryBody","hierarchy","getExtension","legacyHierarchy","HIERARCHY","console","warn","extensions","initializeHierarchyValues","hierarchyJson","i","classId","binaryAccessor","instancesLength","classes","classIds","parentCounts","parentIds","parentIdsLength","byteOffset","componentType","defaultValue","GL","UNSIGNED_SHORT","type","AttributeType","SCALAR","getBinaryAccessor","createArrayBufferView","buffer","parentIndexes","Uint16Array","classesLength","length","classInstancesLength","properties","instances","binaryProperties","getBinaryProperties","combine","classCounts","Array","fill","classIndexes","validateHierarchy","traverseHierarchy","instanceIndex","endConditionCallback","traverseHierarchyMultipleParents","traverseHierarchySingleParent","visited","scratchVisited","Math","max","visitedMarker","marker","stack","scratchStack","push","pop","result","parentCount","parentIndex","parentId","hasParent","Error","scratchValidateStack","validateInstance","assert","indexOf"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/3d-tiles/dist/lib/classes/tile-3d-batch-table-hierarchy.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n// TODO - Finish hierarchy suypport: this file is only half ported\n/* eslint-disable */\n// @ts-nocheck\nconst defined = (x) => x !== undefined;\nexport function initializeHierarchy(batchTable, jsonHeader, binaryBody) {\n    if (!jsonHeader) {\n        return null;\n    }\n    let hierarchy = batchTable.getExtension('3DTILES_batch_table_hierarchy');\n    const legacyHierarchy = jsonHeader.HIERARCHY;\n    if (legacyHierarchy) {\n        // eslint-disable-next-line\n        console.warn('3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.');\n        jsonHeader.extensions = jsonHeader.extensions || {};\n        jsonHeader.extensions['3DTILES_batch_table_hierarchy'] = legacyHierarchy;\n        hierarchy = legacyHierarchy;\n    }\n    if (!hierarchy) {\n        return null;\n    }\n    return initializeHierarchyValues(hierarchy, binaryBody);\n}\n// eslint-disable-next-line max-statements\nfunction initializeHierarchyValues(hierarchyJson, binaryBody) {\n    let i;\n    let classId;\n    let binaryAccessor;\n    const instancesLength = hierarchyJson.instancesLength;\n    const classes = hierarchyJson.classes;\n    let classIds = hierarchyJson.classIds;\n    let parentCounts = hierarchyJson.parentCounts;\n    let parentIds = hierarchyJson.parentIds;\n    let parentIdsLength = instancesLength;\n    if (defined(classIds.byteOffset)) {\n        classIds.componentType = defaultValue(classIds.componentType, GL.UNSIGNED_SHORT);\n        classIds.type = AttributeType.SCALAR;\n        binaryAccessor = getBinaryAccessor(classIds);\n        classIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + classIds.byteOffset, instancesLength);\n    }\n    let parentIndexes;\n    if (defined(parentCounts)) {\n        if (defined(parentCounts.byteOffset)) {\n            parentCounts.componentType = defaultValue(parentCounts.componentType, GL.UNSIGNED_SHORT);\n            parentCounts.type = AttributeType.SCALAR;\n            binaryAccessor = getBinaryAccessor(parentCounts);\n            parentCounts = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentCounts.byteOffset, instancesLength);\n        }\n        parentIndexes = new Uint16Array(instancesLength);\n        parentIdsLength = 0;\n        for (i = 0; i < instancesLength; ++i) {\n            parentIndexes[i] = parentIdsLength;\n            parentIdsLength += parentCounts[i];\n        }\n    }\n    if (defined(parentIds) && defined(parentIds.byteOffset)) {\n        parentIds.componentType = defaultValue(parentIds.componentType, GL.UNSIGNED_SHORT);\n        parentIds.type = AttributeType.SCALAR;\n        binaryAccessor = getBinaryAccessor(parentIds);\n        parentIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentIds.byteOffset, parentIdsLength);\n    }\n    const classesLength = classes.length;\n    for (i = 0; i < classesLength; ++i) {\n        const classInstancesLength = classes[i].length;\n        const properties = classes[i].instances;\n        const binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);\n        classes[i].instances = combine(binaryProperties, properties);\n    }\n    const classCounts = new Array(classesLength).fill(0);\n    const classIndexes = new Uint16Array(instancesLength);\n    for (i = 0; i < instancesLength; ++i) {\n        classId = classIds[i];\n        classIndexes[i] = classCounts[classId];\n        ++classCounts[classId];\n    }\n    const hierarchy = {\n        classes,\n        classIds,\n        classIndexes,\n        parentCounts,\n        parentIndexes,\n        parentIds\n    };\n    validateHierarchy(hierarchy);\n    return hierarchy;\n}\n// HELPER CODE\n// Traverse over the hierarchy and process each instance with the endConditionCallback.\n// When the endConditionCallback returns a value, the traversal stops and that value is returned.\nexport function traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {\n    if (!hierarchy) {\n        return;\n    }\n    const parentCounts = hierarchy.parentCounts;\n    const parentIds = hierarchy.parentIds;\n    if (parentIds) {\n        return endConditionCallback(hierarchy, instanceIndex);\n    }\n    if (parentCounts > 0) {\n        return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);\n    }\n    return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);\n}\n// eslint-disable-next-line max-statements\nfunction traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {\n    const classIds = hierarchy.classIds;\n    const parentCounts = hierarchy.parentCounts;\n    const parentIds = hierarchy.parentIds;\n    const parentIndexes = hierarchy.parentIndexes;\n    const instancesLength = classIds.length;\n    // Ignore instances that have already been visited. This occurs in diamond inheritance situations.\n    // Use a marker value to indicate that an instance has been visited, which increments with each run.\n    // This is more efficient than clearing the visited array every time.\n    const visited = scratchVisited;\n    visited.length = Math.max(visited.length, instancesLength);\n    const visitedMarker = ++marker;\n    const stack = scratchStack;\n    stack.length = 0;\n    stack.push(instanceIndex);\n    while (stack.length > 0) {\n        instanceIndex = stack.pop();\n        if (visited[instanceIndex] === visitedMarker) {\n            // This instance has already been visited, stop traversal\n            continue;\n        }\n        visited[instanceIndex] = visitedMarker;\n        const result = endConditionCallback(hierarchy, instanceIndex);\n        if (defined(result)) {\n            // The end condition was met, stop the traversal and return the result\n            return result;\n        }\n        const parentCount = parentCounts[instanceIndex];\n        const parentIndex = parentIndexes[instanceIndex];\n        for (let i = 0; i < parentCount; ++i) {\n            const parentId = parentIds[parentIndex + i];\n            // Stop the traversal when the instance has no parent (its parentId equals itself)\n            // else add the parent to the stack to continue the traversal.\n            if (parentId !== instanceIndex) {\n                stack.push(parentId);\n            }\n        }\n    }\n    return null;\n}\nfunction traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {\n    let hasParent = true;\n    while (hasParent) {\n        const result = endConditionCallback(hierarchy, instanceIndex);\n        if (defined(result)) {\n            // The end condition was met, stop the traversal and return the result\n            return result;\n        }\n        const parentId = hierarchy.parentIds[instanceIndex];\n        hasParent = parentId !== instanceIndex;\n        instanceIndex = parentId;\n    }\n    throw new Error('traverseHierarchySingleParent');\n}\n// DEBUG CODE\nfunction validateHierarchy(hierarchy) {\n    const scratchValidateStack = [];\n    const classIds = hierarchy.classIds;\n    const instancesLength = classIds.length;\n    for (let i = 0; i < instancesLength; ++i) {\n        validateInstance(hierarchy, i, stack);\n    }\n}\nfunction validateInstance(hierarchy, instanceIndex, stack) {\n    const parentCounts = hierarchy.parentCounts;\n    const parentIds = hierarchy.parentIds;\n    const parentIndexes = hierarchy.parentIndexes;\n    const classIds = hierarchy.classIds;\n    const instancesLength = classIds.length;\n    if (!defined(parentIds)) {\n        // No need to validate if there are no parents\n        return;\n    }\n    assert(instanceIndex < instancesLength, `Parent index ${instanceIndex} exceeds the total number of instances: ${instancesLength}`);\n    assert(stack.indexOf(instanceIndex) === -1, 'Circular dependency detected in the batch table hierarchy.');\n    stack.push(instanceIndex);\n    const parentCount = defined(parentCounts) ? parentCounts[instanceIndex] : 1;\n    const parentIndex = defined(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;\n    for (let i = 0; i < parentCount; ++i) {\n        const parentId = parentIds[parentIndex + i];\n        // Stop the traversal when the instance has no parent (its parentId equals itself), else continue the traversal.\n        if (parentId !== instanceIndex) {\n            validateInstance(hierarchy, parentId, stack);\n        }\n    }\n    stack.pop(instanceIndex);\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,OAAO,GAAIC,CAAC,IAAKA,CAAC,KAAKC,SAAS;AACtC,OAAO,SAASC,mBAAmBA,CAACC,UAAU,EAAEC,UAAU,EAAEC,UAAU,EAAE;EACpE,IAAI,CAACD,UAAU,EAAE;IACb,OAAO,IAAI;EACf;EACA,IAAIE,SAAS,GAAGH,UAAU,CAACI,YAAY,CAAC,+BAA+B,CAAC;EACxE,MAAMC,eAAe,GAAGJ,UAAU,CAACK,SAAS;EAC5C,IAAID,eAAe,EAAE;IACjB;IACAE,OAAO,CAACC,IAAI,CAAC,6EAA6E,CAAC;IAC3FP,UAAU,CAACQ,UAAU,GAAGR,UAAU,CAACQ,UAAU,IAAI,CAAC,CAAC;IACnDR,UAAU,CAACQ,UAAU,CAAC,+BAA+B,CAAC,GAAGJ,eAAe;IACxEF,SAAS,GAAGE,eAAe;EAC/B;EACA,IAAI,CAACF,SAAS,EAAE;IACZ,OAAO,IAAI;EACf;EACA,OAAOO,yBAAyB,CAACP,SAAS,EAAED,UAAU,CAAC;AAC3D;AACA;AACA,SAASQ,yBAAyBA,CAACC,aAAa,EAAET,UAAU,EAAE;EAC1D,IAAIU,CAAC;EACL,IAAIC,OAAO;EACX,IAAIC,cAAc;EAClB,MAAMC,eAAe,GAAGJ,aAAa,CAACI,eAAe;EACrD,MAAMC,OAAO,GAAGL,aAAa,CAACK,OAAO;EACrC,IAAIC,QAAQ,GAAGN,aAAa,CAACM,QAAQ;EACrC,IAAIC,YAAY,GAAGP,aAAa,CAACO,YAAY;EAC7C,IAAIC,SAAS,GAAGR,aAAa,CAACQ,SAAS;EACvC,IAAIC,eAAe,GAAGL,eAAe;EACrC,IAAInB,OAAO,CAACqB,QAAQ,CAACI,UAAU,CAAC,EAAE;IAC9BJ,QAAQ,CAACK,aAAa,GAAGC,YAAY,CAACN,QAAQ,CAACK,aAAa,EAAEE,EAAE,CAACC,cAAc,CAAC;IAChFR,QAAQ,CAACS,IAAI,GAAGC,aAAa,CAACC,MAAM;IACpCd,cAAc,GAAGe,iBAAiB,CAACZ,QAAQ,CAAC;IAC5CA,QAAQ,GAAGH,cAAc,CAACgB,qBAAqB,CAAC5B,UAAU,CAAC6B,MAAM,EAAE7B,UAAU,CAACmB,UAAU,GAAGJ,QAAQ,CAACI,UAAU,EAAEN,eAAe,CAAC;EACpI;EACA,IAAIiB,aAAa;EACjB,IAAIpC,OAAO,CAACsB,YAAY,CAAC,EAAE;IACvB,IAAItB,OAAO,CAACsB,YAAY,CAACG,UAAU,CAAC,EAAE;MAClCH,YAAY,CAACI,aAAa,GAAGC,YAAY,CAACL,YAAY,CAACI,aAAa,EAAEE,EAAE,CAACC,cAAc,CAAC;MACxFP,YAAY,CAACQ,IAAI,GAAGC,aAAa,CAACC,MAAM;MACxCd,cAAc,GAAGe,iBAAiB,CAACX,YAAY,CAAC;MAChDA,YAAY,GAAGJ,cAAc,CAACgB,qBAAqB,CAAC5B,UAAU,CAAC6B,MAAM,EAAE7B,UAAU,CAACmB,UAAU,GAAGH,YAAY,CAACG,UAAU,EAAEN,eAAe,CAAC;IAC5I;IACAiB,aAAa,GAAG,IAAIC,WAAW,CAAClB,eAAe,CAAC;IAChDK,eAAe,GAAG,CAAC;IACnB,KAAKR,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGG,eAAe,EAAE,EAAEH,CAAC,EAAE;MAClCoB,aAAa,CAACpB,CAAC,CAAC,GAAGQ,eAAe;MAClCA,eAAe,IAAIF,YAAY,CAACN,CAAC,CAAC;IACtC;EACJ;EACA,IAAIhB,OAAO,CAACuB,SAAS,CAAC,IAAIvB,OAAO,CAACuB,SAAS,CAACE,UAAU,CAAC,EAAE;IACrDF,SAAS,CAACG,aAAa,GAAGC,YAAY,CAACJ,SAAS,CAACG,aAAa,EAAEE,EAAE,CAACC,cAAc,CAAC;IAClFN,SAAS,CAACO,IAAI,GAAGC,aAAa,CAACC,MAAM;IACrCd,cAAc,GAAGe,iBAAiB,CAACV,SAAS,CAAC;IAC7CA,SAAS,GAAGL,cAAc,CAACgB,qBAAqB,CAAC5B,UAAU,CAAC6B,MAAM,EAAE7B,UAAU,CAACmB,UAAU,GAAGF,SAAS,CAACE,UAAU,EAAED,eAAe,CAAC;EACtI;EACA,MAAMc,aAAa,GAAGlB,OAAO,CAACmB,MAAM;EACpC,KAAKvB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsB,aAAa,EAAE,EAAEtB,CAAC,EAAE;IAChC,MAAMwB,oBAAoB,GAAGpB,OAAO,CAACJ,CAAC,CAAC,CAACuB,MAAM;IAC9C,MAAME,UAAU,GAAGrB,OAAO,CAACJ,CAAC,CAAC,CAAC0B,SAAS;IACvC,MAAMC,gBAAgB,GAAGC,mBAAmB,CAACJ,oBAAoB,EAAEC,UAAU,EAAEnC,UAAU,CAAC;IAC1Fc,OAAO,CAACJ,CAAC,CAAC,CAAC0B,SAAS,GAAGG,OAAO,CAACF,gBAAgB,EAAEF,UAAU,CAAC;EAChE;EACA,MAAMK,WAAW,GAAG,IAAIC,KAAK,CAACT,aAAa,CAAC,CAACU,IAAI,CAAC,CAAC,CAAC;EACpD,MAAMC,YAAY,GAAG,IAAIZ,WAAW,CAAClB,eAAe,CAAC;EACrD,KAAKH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGG,eAAe,EAAE,EAAEH,CAAC,EAAE;IAClCC,OAAO,GAAGI,QAAQ,CAACL,CAAC,CAAC;IACrBiC,YAAY,CAACjC,CAAC,CAAC,GAAG8B,WAAW,CAAC7B,OAAO,CAAC;IACtC,EAAE6B,WAAW,CAAC7B,OAAO,CAAC;EAC1B;EACA,MAAMV,SAAS,GAAG;IACda,OAAO;IACPC,QAAQ;IACR4B,YAAY;IACZ3B,YAAY;IACZc,aAAa;IACbb;EACJ,CAAC;EACD2B,iBAAiB,CAAC3C,SAAS,CAAC;EAC5B,OAAOA,SAAS;AACpB;AACA;AACA;AACA;AACA,OAAO,SAAS4C,iBAAiBA,CAAC5C,SAAS,EAAE6C,aAAa,EAAEC,oBAAoB,EAAE;EAC9E,IAAI,CAAC9C,SAAS,EAAE;IACZ;EACJ;EACA,MAAMe,YAAY,GAAGf,SAAS,CAACe,YAAY;EAC3C,MAAMC,SAAS,GAAGhB,SAAS,CAACgB,SAAS;EACrC,IAAIA,SAAS,EAAE;IACX,OAAO8B,oBAAoB,CAAC9C,SAAS,EAAE6C,aAAa,CAAC;EACzD;EACA,IAAI9B,YAAY,GAAG,CAAC,EAAE;IAClB,OAAOgC,gCAAgC,CAAC/C,SAAS,EAAE6C,aAAa,EAAEC,oBAAoB,CAAC;EAC3F;EACA,OAAOE,6BAA6B,CAAChD,SAAS,EAAE6C,aAAa,EAAEC,oBAAoB,CAAC;AACxF;AACA;AACA,SAASC,gCAAgCA,CAAC/C,SAAS,EAAE6C,aAAa,EAAEC,oBAAoB,EAAE;EACtF,MAAMhC,QAAQ,GAAGd,SAAS,CAACc,QAAQ;EACnC,MAAMC,YAAY,GAAGf,SAAS,CAACe,YAAY;EAC3C,MAAMC,SAAS,GAAGhB,SAAS,CAACgB,SAAS;EACrC,MAAMa,aAAa,GAAG7B,SAAS,CAAC6B,aAAa;EAC7C,MAAMjB,eAAe,GAAGE,QAAQ,CAACkB,MAAM;EACvC;EACA;EACA;EACA,MAAMiB,OAAO,GAAGC,cAAc;EAC9BD,OAAO,CAACjB,MAAM,GAAGmB,IAAI,CAACC,GAAG,CAACH,OAAO,CAACjB,MAAM,EAAEpB,eAAe,CAAC;EAC1D,MAAMyC,aAAa,GAAG,EAAEC,MAAM;EAC9B,MAAMC,KAAK,GAAGC,YAAY;EAC1BD,KAAK,CAACvB,MAAM,GAAG,CAAC;EAChBuB,KAAK,CAACE,IAAI,CAACZ,aAAa,CAAC;EACzB,OAAOU,KAAK,CAACvB,MAAM,GAAG,CAAC,EAAE;IACrBa,aAAa,GAAGU,KAAK,CAACG,GAAG,CAAC,CAAC;IAC3B,IAAIT,OAAO,CAACJ,aAAa,CAAC,KAAKQ,aAAa,EAAE;MAC1C;MACA;IACJ;IACAJ,OAAO,CAACJ,aAAa,CAAC,GAAGQ,aAAa;IACtC,MAAMM,MAAM,GAAGb,oBAAoB,CAAC9C,SAAS,EAAE6C,aAAa,CAAC;IAC7D,IAAIpD,OAAO,CAACkE,MAAM,CAAC,EAAE;MACjB;MACA,OAAOA,MAAM;IACjB;IACA,MAAMC,WAAW,GAAG7C,YAAY,CAAC8B,aAAa,CAAC;IAC/C,MAAMgB,WAAW,GAAGhC,aAAa,CAACgB,aAAa,CAAC;IAChD,KAAK,IAAIpC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmD,WAAW,EAAE,EAAEnD,CAAC,EAAE;MAClC,MAAMqD,QAAQ,GAAG9C,SAAS,CAAC6C,WAAW,GAAGpD,CAAC,CAAC;MAC3C;MACA;MACA,IAAIqD,QAAQ,KAAKjB,aAAa,EAAE;QAC5BU,KAAK,CAACE,IAAI,CAACK,QAAQ,CAAC;MACxB;IACJ;EACJ;EACA,OAAO,IAAI;AACf;AACA,SAASd,6BAA6BA,CAAChD,SAAS,EAAE6C,aAAa,EAAEC,oBAAoB,EAAE;EACnF,IAAIiB,SAAS,GAAG,IAAI;EACpB,OAAOA,SAAS,EAAE;IACd,MAAMJ,MAAM,GAAGb,oBAAoB,CAAC9C,SAAS,EAAE6C,aAAa,CAAC;IAC7D,IAAIpD,OAAO,CAACkE,MAAM,CAAC,EAAE;MACjB;MACA,OAAOA,MAAM;IACjB;IACA,MAAMG,QAAQ,GAAG9D,SAAS,CAACgB,SAAS,CAAC6B,aAAa,CAAC;IACnDkB,SAAS,GAAGD,QAAQ,KAAKjB,aAAa;IACtCA,aAAa,GAAGiB,QAAQ;EAC5B;EACA,MAAM,IAAIE,KAAK,CAAC,+BAA+B,CAAC;AACpD;AACA;AACA,SAASrB,iBAAiBA,CAAC3C,SAAS,EAAE;EAClC,MAAMiE,oBAAoB,GAAG,EAAE;EAC/B,MAAMnD,QAAQ,GAAGd,SAAS,CAACc,QAAQ;EACnC,MAAMF,eAAe,GAAGE,QAAQ,CAACkB,MAAM;EACvC,KAAK,IAAIvB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGG,eAAe,EAAE,EAAEH,CAAC,EAAE;IACtCyD,gBAAgB,CAAClE,SAAS,EAAES,CAAC,EAAE8C,KAAK,CAAC;EACzC;AACJ;AACA,SAASW,gBAAgBA,CAAClE,SAAS,EAAE6C,aAAa,EAAEU,KAAK,EAAE;EACvD,MAAMxC,YAAY,GAAGf,SAAS,CAACe,YAAY;EAC3C,MAAMC,SAAS,GAAGhB,SAAS,CAACgB,SAAS;EACrC,MAAMa,aAAa,GAAG7B,SAAS,CAAC6B,aAAa;EAC7C,MAAMf,QAAQ,GAAGd,SAAS,CAACc,QAAQ;EACnC,MAAMF,eAAe,GAAGE,QAAQ,CAACkB,MAAM;EACvC,IAAI,CAACvC,OAAO,CAACuB,SAAS,CAAC,EAAE;IACrB;IACA;EACJ;EACAmD,MAAM,CAACtB,aAAa,GAAGjC,eAAe,EAAE,gBAAgBiC,aAAa,2CAA2CjC,eAAe,EAAE,CAAC;EAClIuD,MAAM,CAACZ,KAAK,CAACa,OAAO,CAACvB,aAAa,CAAC,KAAK,CAAC,CAAC,EAAE,4DAA4D,CAAC;EACzGU,KAAK,CAACE,IAAI,CAACZ,aAAa,CAAC;EACzB,MAAMe,WAAW,GAAGnE,OAAO,CAACsB,YAAY,CAAC,GAAGA,YAAY,CAAC8B,aAAa,CAAC,GAAG,CAAC;EAC3E,MAAMgB,WAAW,GAAGpE,OAAO,CAACsB,YAAY,CAAC,GAAGc,aAAa,CAACgB,aAAa,CAAC,GAAGA,aAAa;EACxF,KAAK,IAAIpC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmD,WAAW,EAAE,EAAEnD,CAAC,EAAE;IAClC,MAAMqD,QAAQ,GAAG9C,SAAS,CAAC6C,WAAW,GAAGpD,CAAC,CAAC;IAC3C;IACA,IAAIqD,QAAQ,KAAKjB,aAAa,EAAE;MAC5BqB,gBAAgB,CAAClE,SAAS,EAAE8D,QAAQ,EAAEP,KAAK,CAAC;IAChD;EACJ;EACAA,KAAK,CAACG,GAAG,CAACb,aAAa,CAAC;AAC5B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}