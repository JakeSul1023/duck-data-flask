{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ImageSource } from '@loaders.gl/loader-utils';\n// import type {ImageSourceProps} from '@loaders.gl/loader-utils';\n// import {ImageSource} from '@loaders.gl/loader-utils';\nexport const ArcGISImageServerSource = {\n  name: 'ArcGISImageServer',\n  id: 'arcgis-image-server',\n  module: 'wms',\n  version: '0.0.0',\n  extensions: [],\n  mimeTypes: [],\n  options: {\n    'arcgis-image-server': {\n      // TODO - add options here\n    }\n  },\n  type: 'arcgis-image-server',\n  fromUrl: true,\n  fromBlob: false,\n  testURL: url => url.toLowerCase().includes('ImageServer'),\n  createDataSource: (url, props) => new ArcGISImageSource(url, props)\n};\n/**\n * ArcGIS ImageServer\n * Note - exports a big API, that could be exposed here if there is a use case\n * @see https://developers.arcgis.com/rest/services-reference/enterprise/image-service.htm\n */\nexport class ArcGISImageSource extends ImageSource {\n  url;\n  data;\n  constructor(url, props) {\n    super(props);\n    this.url = url;\n    this.data = url;\n  }\n  // ImageSource (normalized endpoints)\n  async getMetadata() {\n    return await this.metadata();\n    // TODO - normalize metadata\n  }\n  async getImage(parameters) {\n    throw new Error('not implemented');\n    // TODO - Map generic parameters to ArcGIS specific parameters\n    // return await this.exportImage(parameters);\n  }\n  // ImageServer endpoints\n  async metadata() {\n    // We just need a JSON parsing...\n    // return this.getUrl({path: '', ...options});\n    throw new Error('not implemented');\n  }\n  /**\n   * Form a URL to an ESRI ImageServer\n   // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&compressionQuality=&bandIds=&mosaicRule=&renderingRule=&f=image`,\n   */\n  exportImage(options) {\n    // See WMSService.getMap()\n    throw new Error('not implemented');\n  }\n  // URL creators\n  metadataURL(options) {\n    return `${this.url}?f=pjson`;\n  }\n  /**\n   * Form a URL to an ESRI ImageServer\n   // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?\n   //   bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&\n   //   size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&\n   //   noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&\n   //   compressionQuality=&bandIds=&mosaicRule=&renderingRule=&\n   //   f=image\n   */\n  exportImageURL(options) {\n    const bbox = `bbox=${options.bbox[0]},${options.bbox[1]},${options.bbox[2]},${options.bbox[3]}`;\n    const size = `size=${options.width},${options.height}`;\n    const arcgisOptions = {\n      ...options,\n      bbox,\n      size\n    };\n    // @ts-expect-error\n    delete arcgisOptions.width;\n    // @ts-expect-error\n    delete arcgisOptions.height;\n    return this.getUrl('exportImage', arcgisOptions);\n  }\n  // INTERNAL METHODS\n  /**\n   * @note protected, since perhaps getWMSUrl may need to be overridden to handle certain backends?\n   * @note if override is common, maybe add a callback prop?\n   * */\n  getUrl(path, options, extra) {\n    let url = `${this.url}/${path}`;\n    let first = true;\n    for (const [key, value] of Object.entries(options)) {\n      url += first ? '?' : '&';\n      first = false;\n      if (Array.isArray(value)) {\n        url += `${key.toUpperCase()}=${value.join(',')}`;\n      } else {\n        url += `${key.toUpperCase()}=${value ? String(value) : ''}`;\n      }\n    }\n    return url;\n  }\n  /** Checks for and parses a WMS XML formatted ServiceError and throws an exception */\n  async checkResponse(response) {\n    if (!response.ok) {\n      // } || response.headers['content-type'] === WMSErrorLoader.mimeTypes[0]) {\n      // const arrayBuffer = await response.arrayBuffer();\n      // const error = await WMSErrorLoader.parse(arrayBuffer, this.loadOptions);\n      throw new Error('error');\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}