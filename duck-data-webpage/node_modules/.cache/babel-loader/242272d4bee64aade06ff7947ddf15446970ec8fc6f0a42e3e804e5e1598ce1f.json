{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { decodeVertexType } from \"./decode-data-type.js\";\n/**\n * Decodes a vertex format, returning type, components, byte  length and flags (integer, signed, normalized)\n */\nexport function decodeVertexFormat(format) {\n  // Strip the -webgl ending if present\n  let webglOnly;\n  if (format.endsWith('-webgl')) {\n    format.replace('-webgl', '');\n    webglOnly = true;\n  }\n  // split components from type\n  const [type_, count] = format.split('x');\n  const type = type_;\n  const components = count ? parseInt(count) : 1;\n  // decode the type\n  const decodedType = decodeVertexType(type);\n  const result = {\n    type,\n    components,\n    byteLength: decodedType.byteLength * components,\n    integer: decodedType.integer,\n    signed: decodedType.signed,\n    normalized: decodedType.normalized\n  };\n  if (webglOnly) {\n    result.webglOnly = true;\n  }\n  return result;\n}","map":{"version":3,"names":["decodeVertexType","decodeVertexFormat","format","webglOnly","endsWith","replace","type_","count","split","type","components","parseInt","decodedType","result","byteLength","integer","signed","normalized"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\core\\src\\gpu-type-utils\\decode-vertex-format.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {VertexFormat, VertexType} from './vertex-formats';\nimport {decodeVertexType} from './decode-data-type';\n\nexport type VertexFormatInfo = {\n  /** Length in bytes */\n  byteLength: number;\n  /** Type of each component */\n  type: VertexType;\n  /** Number of components per vertex / row */\n  components: 1 | 2 | 3 | 4;\n  /** Is this an integer format (normalized integer formats are not integer) */\n  integer: boolean;\n  /** Is this a signed format? */\n  signed: boolean;\n  /** Is this a normalized format? */\n  normalized: boolean;\n  /** Is this a webgl only format? */\n  webglOnly?: boolean;\n};\n\n/**\n * Decodes a vertex format, returning type, components, byte  length and flags (integer, signed, normalized)\n */\nexport function decodeVertexFormat(format: VertexFormat): VertexFormatInfo {\n  // Strip the -webgl ending if present\n  let webglOnly: boolean | undefined;\n  if (format.endsWith('-webgl')) {\n    format.replace('-webgl', '');\n    webglOnly = true;\n  }\n  // split components from type\n  const [type_, count] = format.split('x');\n  const type = type_ as VertexType;\n  const components = (count ? parseInt(count) : 1) as 1 | 2 | 3 | 4;\n  // decode the type\n  const decodedType = decodeVertexType(type);\n  const result: VertexFormatInfo = {\n    type,\n    components,\n    byteLength: decodedType.byteLength * components,\n    integer: decodedType.integer,\n    signed: decodedType.signed,\n    normalized: decodedType.normalized\n  };\n  if (webglOnly) {\n    result.webglOnly = true;\n  }\n  return result;\n}\n"],"mappings":"AAAA;AACA;AACA;AAGA,SAAQA,gBAAgB,QAAC;AAmBzB;;;AAGA,OAAM,SAAUC,kBAAkBA,CAACC,MAAoB;EACrD;EACA,IAAIC,SAA8B;EAClC,IAAID,MAAM,CAACE,QAAQ,CAAC,QAAQ,CAAC,EAAE;IAC7BF,MAAM,CAACG,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;IAC5BF,SAAS,GAAG,IAAI;EAClB;EACA;EACA,MAAM,CAACG,KAAK,EAAEC,KAAK,CAAC,GAAGL,MAAM,CAACM,KAAK,CAAC,GAAG,CAAC;EACxC,MAAMC,IAAI,GAAGH,KAAmB;EAChC,MAAMI,UAAU,GAAIH,KAAK,GAAGI,QAAQ,CAACJ,KAAK,CAAC,GAAG,CAAmB;EACjE;EACA,MAAMK,WAAW,GAAGZ,gBAAgB,CAACS,IAAI,CAAC;EAC1C,MAAMI,MAAM,GAAqB;IAC/BJ,IAAI;IACJC,UAAU;IACVI,UAAU,EAAEF,WAAW,CAACE,UAAU,GAAGJ,UAAU;IAC/CK,OAAO,EAAEH,WAAW,CAACG,OAAO;IAC5BC,MAAM,EAAEJ,WAAW,CAACI,MAAM;IAC1BC,UAAU,EAAEL,WAAW,CAACK;GACzB;EACD,IAAId,SAAS,EAAE;IACbU,MAAM,CAACV,SAAS,GAAG,IAAI;EACzB;EACA,OAAOU,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}