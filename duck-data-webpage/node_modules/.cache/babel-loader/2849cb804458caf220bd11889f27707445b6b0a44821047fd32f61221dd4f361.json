{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport const defaultColorRange = [[255, 255, 178], [254, 217, 118], [254, 178, 76], [253, 141, 60], [240, 59, 32], [189, 0, 38]];\n// Converts a colorRange array to a flat array with 4 components per color\nexport function colorRangeToFlatArray(colorRange, normalize = false, ArrayType = Float32Array) {\n  let flatArray;\n  if (Number.isFinite(colorRange[0])) {\n    // its already a flat array.\n    flatArray = new ArrayType(colorRange);\n  } else {\n    // flatten it\n    flatArray = new ArrayType(colorRange.length * 4);\n    let index = 0;\n    for (let i = 0; i < colorRange.length; i++) {\n      const color = colorRange[i];\n      flatArray[index++] = color[0];\n      flatArray[index++] = color[1];\n      flatArray[index++] = color[2];\n      flatArray[index++] = Number.isFinite(color[3]) ? color[3] : 255;\n    }\n  }\n  if (normalize) {\n    for (let i = 0; i < flatArray.length; i++) {\n      flatArray[i] /= 255;\n    }\n  }\n  return flatArray;\n}\nexport const COLOR_RANGE_FILTER = {\n  linear: 'linear',\n  quantile: 'nearest',\n  quantize: 'nearest',\n  ordinal: 'nearest'\n};\nexport function updateColorRangeTexture(texture, type) {\n  texture.setSampler({\n    minFilter: COLOR_RANGE_FILTER[type],\n    magFilter: COLOR_RANGE_FILTER[type]\n  });\n}\nexport function createColorRangeTexture(device, colorRange, type = 'linear') {\n  const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);\n  return device.createTexture({\n    format: 'rgba8unorm',\n    mipmaps: false,\n    sampler: {\n      minFilter: COLOR_RANGE_FILTER[type],\n      magFilter: COLOR_RANGE_FILTER[type],\n      addressModeU: 'clamp-to-edge',\n      addressModeV: 'clamp-to-edge'\n    },\n    data: colors,\n    width: colors.length / 4,\n    height: 1\n  });\n}","map":{"version":3,"names":["defaultColorRange","colorRangeToFlatArray","colorRange","normalize","ArrayType","Float32Array","flatArray","Number","isFinite","length","index","i","color","COLOR_RANGE_FILTER","linear","quantile","quantize","ordinal","updateColorRangeTexture","texture","type","setSampler","minFilter","magFilter","createColorRangeTexture","device","colors","Uint8Array","createTexture","format","mipmaps","sampler","addressModeU","addressModeV","data","width","height"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\aggregation-layers\\src\\common\\utils\\color-utils.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Color} from '@deck.gl/core';\nimport type {Device, Texture} from '@luma.gl/core';\nimport type {NumericArray, TypedArray, TypedArrayConstructor} from '@math.gl/types';\nimport type {ScaleType} from '../types';\n\nexport const defaultColorRange: Color[] = [\n  [255, 255, 178],\n  [254, 217, 118],\n  [254, 178, 76],\n  [253, 141, 60],\n  [240, 59, 32],\n  [189, 0, 38]\n];\n\n// Converts a colorRange array to a flat array with 4 components per color\nexport function colorRangeToFlatArray(\n  colorRange: Color[] | NumericArray,\n  normalize = false,\n  ArrayType: TypedArrayConstructor = Float32Array\n): TypedArray {\n  let flatArray: TypedArray;\n\n  if (Number.isFinite(colorRange[0])) {\n    // its already a flat array.\n    flatArray = new ArrayType(colorRange as NumericArray);\n  } else {\n    // flatten it\n    flatArray = new ArrayType(colorRange.length * 4);\n    let index = 0;\n\n    for (let i = 0; i < colorRange.length; i++) {\n      const color = colorRange[i];\n      flatArray[index++] = color[0];\n      flatArray[index++] = color[1];\n      flatArray[index++] = color[2];\n      flatArray[index++] = Number.isFinite(color[3]) ? color[3] : 255;\n    }\n  }\n\n  if (normalize) {\n    for (let i = 0; i < flatArray.length; i++) {\n      flatArray[i] /= 255;\n    }\n  }\n  return flatArray;\n}\n\nexport const COLOR_RANGE_FILTER: Record<ScaleType, 'linear' | 'nearest'> = {\n  linear: 'linear',\n  quantile: 'nearest',\n  quantize: 'nearest',\n  ordinal: 'nearest'\n} as const;\n\nexport function updateColorRangeTexture(texture: Texture, type: ScaleType) {\n  texture.setSampler({\n    minFilter: COLOR_RANGE_FILTER[type],\n    magFilter: COLOR_RANGE_FILTER[type]\n  });\n}\n\nexport function createColorRangeTexture(\n  device: Device,\n  colorRange: Color[] | NumericArray,\n  type: ScaleType = 'linear'\n): Texture {\n  const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);\n\n  return device.createTexture({\n    format: 'rgba8unorm',\n    mipmaps: false,\n    sampler: {\n      minFilter: COLOR_RANGE_FILTER[type],\n      magFilter: COLOR_RANGE_FILTER[type],\n      addressModeU: 'clamp-to-edge',\n      addressModeV: 'clamp-to-edge'\n    },\n    data: colors,\n    width: colors.length / 4,\n    height: 1\n  });\n}\n"],"mappings":"AAAA;AACA;AACA;AAOA,OAAO,MAAMA,iBAAiB,GAAY,CACxC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,EACf,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,EACf,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,EACd,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,EACd,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE,CAAC,EACb,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC,CACb;AAED;AACA,OAAM,SAAUC,qBAAqBA,CACnCC,UAAkC,EAClCC,SAAS,GAAG,KAAK,EACjBC,SAAA,GAAmCC,YAAY;EAE/C,IAAIC,SAAqB;EAEzB,IAAIC,MAAM,CAACC,QAAQ,CAACN,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;IAClC;IACAI,SAAS,GAAG,IAAIF,SAAS,CAACF,UAA0B,CAAC;EACvD,CAAC,MAAM;IACL;IACAI,SAAS,GAAG,IAAIF,SAAS,CAACF,UAAU,CAACO,MAAM,GAAG,CAAC,CAAC;IAChD,IAAIC,KAAK,GAAG,CAAC;IAEb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,UAAU,CAACO,MAAM,EAAEE,CAAC,EAAE,EAAE;MAC1C,MAAMC,KAAK,GAAGV,UAAU,CAACS,CAAC,CAAC;MAC3BL,SAAS,CAACI,KAAK,EAAE,CAAC,GAAGE,KAAK,CAAC,CAAC,CAAC;MAC7BN,SAAS,CAACI,KAAK,EAAE,CAAC,GAAGE,KAAK,CAAC,CAAC,CAAC;MAC7BN,SAAS,CAACI,KAAK,EAAE,CAAC,GAAGE,KAAK,CAAC,CAAC,CAAC;MAC7BN,SAAS,CAACI,KAAK,EAAE,CAAC,GAAGH,MAAM,CAACC,QAAQ,CAACI,KAAK,CAAC,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG;IACjE;EACF;EAEA,IAAIT,SAAS,EAAE;IACb,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,SAAS,CAACG,MAAM,EAAEE,CAAC,EAAE,EAAE;MACzCL,SAAS,CAACK,CAAC,CAAC,IAAI,GAAG;IACrB;EACF;EACA,OAAOL,SAAS;AAClB;AAEA,OAAO,MAAMO,kBAAkB,GAA4C;EACzEC,MAAM,EAAE,QAAQ;EAChBC,QAAQ,EAAE,SAAS;EACnBC,QAAQ,EAAE,SAAS;EACnBC,OAAO,EAAE;CACD;AAEV,OAAM,SAAUC,uBAAuBA,CAACC,OAAgB,EAAEC,IAAe;EACvED,OAAO,CAACE,UAAU,CAAC;IACjBC,SAAS,EAAET,kBAAkB,CAACO,IAAI,CAAC;IACnCG,SAAS,EAAEV,kBAAkB,CAACO,IAAI;GACnC,CAAC;AACJ;AAEA,OAAM,SAAUI,uBAAuBA,CACrCC,MAAc,EACdvB,UAAkC,EAClCkB,IAAA,GAAkB,QAAQ;EAE1B,MAAMM,MAAM,GAAGzB,qBAAqB,CAACC,UAAU,EAAE,KAAK,EAAEyB,UAAU,CAAC;EAEnE,OAAOF,MAAM,CAACG,aAAa,CAAC;IAC1BC,MAAM,EAAE,YAAY;IACpBC,OAAO,EAAE,KAAK;IACdC,OAAO,EAAE;MACPT,SAAS,EAAET,kBAAkB,CAACO,IAAI,CAAC;MACnCG,SAAS,EAAEV,kBAAkB,CAACO,IAAI,CAAC;MACnCY,YAAY,EAAE,eAAe;MAC7BC,YAAY,EAAE;KACf;IACDC,IAAI,EAAER,MAAM;IACZS,KAAK,EAAET,MAAM,CAACjB,MAAM,GAAG,CAAC;IACxB2B,MAAM,EAAE;GACT,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}