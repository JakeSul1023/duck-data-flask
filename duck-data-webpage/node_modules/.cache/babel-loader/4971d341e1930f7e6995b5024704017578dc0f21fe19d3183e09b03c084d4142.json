{"ast":null,"code":"import { log } from '@luma.gl/core';\n// NOTE: Modules other than `@luma.gl/webgl` should not import `GL` from\n// `@luma.gl/constants`. Locally we use `GLEnum` instead of `GL` to avoid\n// conflicts with the `babel-plugin-inline-webgl-constants` plugin.\n// eslint-disable-next-line no-shadow\nvar GLEnum;\n(function (GLEnum) {\n  GLEnum[GLEnum[\"FUNC_ADD\"] = 32774] = \"FUNC_ADD\";\n  GLEnum[GLEnum[\"ONE\"] = 1] = \"ONE\";\n  GLEnum[GLEnum[\"SRC_ALPHA\"] = 770] = \"SRC_ALPHA\";\n  GLEnum[GLEnum[\"ONE_MINUS_SRC_ALPHA\"] = 771] = \"ONE_MINUS_SRC_ALPHA\";\n  GLEnum[GLEnum[\"TEXTURE_MIN_FILTER\"] = 10241] = \"TEXTURE_MIN_FILTER\";\n  GLEnum[GLEnum[\"LINEAR\"] = 9729] = \"LINEAR\";\n  GLEnum[GLEnum[\"LINEAR_MIPMAP_NEAREST\"] = 9985] = \"LINEAR_MIPMAP_NEAREST\";\n  GLEnum[GLEnum[\"UNPACK_FLIP_Y_WEBGL\"] = 37440] = \"UNPACK_FLIP_Y_WEBGL\";\n})(GLEnum || (GLEnum = {}));\n/**\n * Parses a GLTF material definition into uniforms and parameters for the PBR shader module\n */\nexport function parsePBRMaterial(device, material, attributes, options) {\n  const parsedMaterial = {\n    defines: {\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    },\n    bindings: {},\n    uniforms: {\n      // TODO: find better values?\n      camera: [0, 0, 0],\n      // Model should override\n      metallicRoughnessValues: [1, 1] // Default is 1 and 1\n    },\n    parameters: {},\n    glParameters: {},\n    generatedTextures: []\n  };\n  // TODO - always available\n  parsedMaterial.defines.USE_TEX_LOD = 1;\n  const {\n    imageBasedLightingEnvironment\n  } = options;\n  if (imageBasedLightingEnvironment) {\n    parsedMaterial.bindings.pbr_diffuseEnvSampler = imageBasedLightingEnvironment.diffuseEnvSampler.texture;\n    parsedMaterial.bindings.pbr_specularEnvSampler = imageBasedLightingEnvironment.specularEnvSampler.texture;\n    parsedMaterial.bindings.pbr_BrdfLUT = imageBasedLightingEnvironment.brdfLutTexture.texture;\n    parsedMaterial.uniforms.scaleIBLAmbient = [1, 1];\n  }\n  if (options?.pbrDebug) {\n    parsedMaterial.defines.PBR_DEBUG = 1;\n    // Override final color for reference app visualization of various parameters in the lighting equation.\n    parsedMaterial.uniforms.scaleDiffBaseMR = [0, 0, 0, 0];\n    parsedMaterial.uniforms.scaleFGDSpec = [0, 0, 0, 0];\n  }\n  if (attributes.NORMAL) parsedMaterial.defines.HAS_NORMALS = 1;\n  if (attributes.TANGENT && options?.useTangents) parsedMaterial.defines.HAS_TANGENTS = 1;\n  if (attributes.TEXCOORD_0) parsedMaterial.defines.HAS_UV = 1;\n  if (options?.imageBasedLightingEnvironment) parsedMaterial.defines.USE_IBL = 1;\n  if (options?.lights) parsedMaterial.defines.USE_LIGHTS = 1;\n  if (material) {\n    parseMaterial(device, material, parsedMaterial);\n  }\n  return parsedMaterial;\n}\n/** Parse GLTF material record */\nfunction parseMaterial(device, material, parsedMaterial) {\n  parsedMaterial.uniforms.unlit = Boolean(material.unlit);\n  if (material.pbrMetallicRoughness) {\n    parsePbrMetallicRoughness(device, material.pbrMetallicRoughness, parsedMaterial);\n  }\n  if (material.normalTexture) {\n    addTexture(device, material.normalTexture, 'pbr_normalSampler', 'HAS_NORMALMAP', parsedMaterial);\n    const {\n      scale = 1\n    } = material.normalTexture;\n    parsedMaterial.uniforms.normalScale = scale;\n  }\n  if (material.occlusionTexture) {\n    addTexture(device, material.occlusionTexture, 'pbr_occlusionSampler', 'HAS_OCCLUSIONMAP', parsedMaterial);\n    const {\n      strength = 1\n    } = material.occlusionTexture;\n    parsedMaterial.uniforms.occlusionStrength = strength;\n  }\n  if (material.emissiveTexture) {\n    addTexture(device, material.emissiveTexture, 'pbr_emissiveSampler', 'HAS_EMISSIVEMAP', parsedMaterial);\n    parsedMaterial.uniforms.emissiveFactor = material.emissiveFactor || [0, 0, 0];\n  }\n  switch (material.alphaMode) {\n    case 'MASK':\n      const {\n        alphaCutoff = 0.5\n      } = material;\n      parsedMaterial.defines.ALPHA_CUTOFF = 1;\n      parsedMaterial.uniforms.alphaCutoff = alphaCutoff;\n      break;\n    case 'BLEND':\n      log.warn('glTF BLEND alphaMode might not work well because it requires mesh sorting')();\n      // WebGPU style parameters\n      parsedMaterial.parameters.blendColorOperation = 'add';\n      parsedMaterial.parameters.blendColorSrcFactor = 'src-alpha';\n      parsedMaterial.parameters.blendColorDstFactor = 'one-minus-src-alpha';\n      parsedMaterial.parameters.blendAlphaOperation = 'add';\n      parsedMaterial.parameters.blendAlphaSrcFactor = 'one';\n      parsedMaterial.parameters.blendAlphaDstFactor = 'one-minus-src-alpha';\n      // GL parameters\n      parsedMaterial.glParameters.blend = true;\n      parsedMaterial.glParameters.blendEquation = GLEnum.FUNC_ADD;\n      parsedMaterial.glParameters.blendFunc = [GLEnum.SRC_ALPHA, GLEnum.ONE_MINUS_SRC_ALPHA, GLEnum.ONE, GLEnum.ONE_MINUS_SRC_ALPHA];\n      break;\n  }\n}\n/** Parse GLTF material sub record */\nfunction parsePbrMetallicRoughness(device, pbrMetallicRoughness, parsedMaterial) {\n  if (pbrMetallicRoughness.baseColorTexture) {\n    addTexture(device, pbrMetallicRoughness.baseColorTexture, 'pbr_baseColorSampler', 'HAS_BASECOLORMAP', parsedMaterial);\n  }\n  parsedMaterial.uniforms.baseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n  if (pbrMetallicRoughness.metallicRoughnessTexture) {\n    addTexture(device, pbrMetallicRoughness.metallicRoughnessTexture, 'pbr_metallicRoughnessSampler', 'HAS_METALROUGHNESSMAP', parsedMaterial);\n  }\n  const {\n    metallicFactor = 1,\n    roughnessFactor = 1\n  } = pbrMetallicRoughness;\n  parsedMaterial.uniforms.metallicRoughnessValues = [metallicFactor, roughnessFactor];\n}\n/** Create a texture from a glTF texture/sampler/image combo and add it to bindings */\nfunction addTexture(device, gltfTexture, uniformName, define = null, parsedMaterial) {\n  const parameters = gltfTexture?.texture?.sampler?.parameters || {};\n  const image = gltfTexture.texture.source.image;\n  let textureOptions;\n  let specialTextureParameters = {};\n  if (image.compressed) {\n    textureOptions = image;\n    specialTextureParameters = {\n      [GLEnum.TEXTURE_MIN_FILTER]: image.data.length > 1 ? GLEnum.LINEAR_MIPMAP_NEAREST : GLEnum.LINEAR\n    };\n  } else {\n    // Texture2D accepts a promise that returns an image as data (Async Textures)\n    textureOptions = {\n      data: image\n    };\n  }\n  const texture = device.createTexture({\n    id: gltfTexture.uniformName || gltfTexture.id,\n    parameters: {\n      ...parameters,\n      ...specialTextureParameters\n    },\n    pixelStore: {\n      [GLEnum.UNPACK_FLIP_Y_WEBGL]: false\n    },\n    ...textureOptions\n  });\n  parsedMaterial.bindings[uniformName] = texture;\n  if (define) parsedMaterial.defines[define] = 1;\n  parsedMaterial.generatedTextures.push(texture);\n}\n/*\n/**\n * Parses a GLTF material definition into uniforms and parameters for the PBR shader module\n *\nexport class PBRMaterialParser {\n  readonly device: Device;\n\n  readonly defines: Record<string, number | boolean>;\n  readonly bindings: Record<string, Binding>;\n  readonly uniforms: Record<string, any>;\n  readonly parameters: Record<string, any>;\n\n  /** Hold on to generated textures, we destroy them in the destroy method *\n  readonly generatedTextures: Texture[];\n\n  constructor(device: Device, props: PBRMaterialParserProps) {\n    const {attributes, material, pbrDebug, imageBasedLightingEnvironment, lights, useTangents} =\n      props;\n    this.device = device;\n\n    this.defines = {\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    };\n\n    if (this.device.features.has('glsl-texture-lod')) {\n      this.defines.USE_TEX_LOD = 1;\n    }\n\n    this.uniforms = {\n      // TODO: find better values?\n      camera: [0, 0, 0], // Model should override\n\n      metallicRoughnessValues: [1, 1] // Default is 1 and 1\n    };\n\n    this.bindings = {};\n\n    this.parameters = {};\n    this.generatedTextures = [];\n\n    if (imageBasedLightingEnvironment) {\n      this.bindings.pbr_diffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();\n      this.bindings.pbr_specularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();\n      this.bindings.pbr_BrdfLUT = imageBasedLightingEnvironment.getBrdfTexture();\n      this.uniforms.scaleIBLAmbient = [1, 1];\n    }\n\n    if (pbrDebug) {\n      // Override final color for reference app visualization\n      // of various parameters in the lighting equation.\n      this.uniforms.scaleDiffBaseMR = [0, 0, 0, 0];\n      this.uniforms.scaleFGDSpec = [0, 0, 0, 0];\n    }\n\n    this.defineIfPresent(attributes.NORMAL, 'HAS_NORMALS');\n    this.defineIfPresent(attributes.TANGENT && useTangents, 'HAS_TANGENTS');\n    this.defineIfPresent(attributes.TEXCOORD_0, 'HAS_UV');\n\n    this.defineIfPresent(imageBasedLightingEnvironment, 'USE_IBL');\n    this.defineIfPresent(lights, 'USE_LIGHTS');\n    this.defineIfPresent(pbrDebug, 'PBR_DEBUG');\n\n    if (material) {\n      this.parseMaterial(material);\n    }\n  }\n\n  /**\n   * Destroy all generated resources to release memory.\n   *\n  destroy(): void {\n    this.generatedTextures.forEach(texture => texture.destroy());\n  }\n\n  /** Add a define if the the value is non-nullish *\n  defineIfPresent(value: unknown, name: string): void {\n    if (value) {\n      this.defines[name] = 1;\n    }\n  }\n\n  /** Parse GLTF material record *\n  parseMaterial(material) {\n    this.uniforms.unlit = Boolean(material.unlit);\n\n    if (material.pbrMetallicRoughness) {\n      this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);\n    }\n    if (material.normalTexture) {\n      this.addTexture(material.normalTexture, 'pbr_normalSampler', 'HAS_NORMALMAP');\n\n      const {scale = 1} = material.normalTexture;\n      this.uniforms.normalScale = scale;\n    }\n    if (material.occlusionTexture) {\n      this.addTexture(material.occlusionTexture, 'pbr_occlusionSampler', 'HAS_OCCLUSIONMAP');\n\n      const {strength = 1} = material.occlusionTexture;\n      this.uniforms.occlusionStrength = strength;\n    }\n    if (material.emissiveTexture) {\n      this.addTexture(material.emissiveTexture, 'pbr_emissiveSampler', 'HAS_EMISSIVEMAP');\n      this.uniforms.emissiveFactor = material.emissiveFactor || [0, 0, 0];\n    }\n    if (material.alphaMode === 'MASK') {\n      const {alphaCutoff = 0.5} = material;\n      this.defines.ALPHA_CUTOFF = 1;\n      this.uniforms.alphaCutoff = alphaCutoff;\n    } else if (material.alphaMode === 'BLEND') {\n      log.warn('BLEND alphaMode might not work well because it requires mesh sorting')();\n      Object.assign(this.parameters, {\n        blend: true,\n        blendEquation: GL.FUNC_ADD,\n        blendFunc: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA, GL.ONE, GL.ONE_MINUS_SRC_ALPHA]\n      });\n    }\n  }\n\n  /** Parse GLTF material sub record *\n  parsePbrMetallicRoughness(pbrMetallicRoughness) {\n    if (pbrMetallicRoughness.baseColorTexture) {\n      this.addTexture(\n        pbrMetallicRoughness.baseColorTexture,\n        'pbr_baseColorSampler',\n        'HAS_BASECOLORMAP'\n      );\n    }\n    this.uniforms.baseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n    if (pbrMetallicRoughness.metallicRoughnessTexture) {\n      this.addTexture(\n        pbrMetallicRoughness.metallicRoughnessTexture,\n        'pbr_metallicRoughnessSampler',\n        'HAS_METALROUGHNESSMAP'\n      );\n    }\n    const {metallicFactor = 1, roughnessFactor = 1} = pbrMetallicRoughness;\n    this.uniforms.metallicRoughnessValues = [metallicFactor, roughnessFactor];\n  }\n\n  /** Create a texture from a glTF texture/sampler/image combo and add it to bindings *\n  addTexture(gltfTexture, name, define = null) {\n    const parameters = gltfTexture?.texture?.sampler?.parameters || {};\n\n    const image = gltfTexture.texture.source.image;\n    let textureOptions;\n    let specialTextureParameters = {};\n    if (image.compressed) {\n      textureOptions = image;\n      specialTextureParameters = {\n        [GL.TEXTURE_MIN_FILTER]: image.data.length > 1 ? GL.LINEAR_MIPMAP_NEAREST : GL.LINEAR\n      };\n    } else {\n      // Texture2D accepts a promise that returns an image as data (Async Textures)\n      textureOptions = {data: image};\n    }\n\n    const texture: Texture = this.device.createTexture({\n      id: gltfTexture.name || gltfTexture.id,\n      parameters: {\n        ...parameters,\n        ...specialTextureParameters\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      },\n      ...textureOptions\n    });\n    this.bindings[name] = texture;\n    this.defineIfPresent(define, define);\n    this.generatedTextures.push(texture);\n  }\n}\n*/","map":{"version":3,"names":["log","GLEnum","parsePBRMaterial","device","material","attributes","options","parsedMaterial","defines","MANUAL_SRGB","SRGB_FAST_APPROXIMATION","bindings","uniforms","camera","metallicRoughnessValues","parameters","glParameters","generatedTextures","USE_TEX_LOD","imageBasedLightingEnvironment","pbr_diffuseEnvSampler","diffuseEnvSampler","texture","pbr_specularEnvSampler","specularEnvSampler","pbr_BrdfLUT","brdfLutTexture","scaleIBLAmbient","pbrDebug","PBR_DEBUG","scaleDiffBaseMR","scaleFGDSpec","NORMAL","HAS_NORMALS","TANGENT","useTangents","HAS_TANGENTS","TEXCOORD_0","HAS_UV","USE_IBL","lights","USE_LIGHTS","parseMaterial","unlit","Boolean","pbrMetallicRoughness","parsePbrMetallicRoughness","normalTexture","addTexture","scale","normalScale","occlusionTexture","strength","occlusionStrength","emissiveTexture","emissiveFactor","alphaMode","alphaCutoff","ALPHA_CUTOFF","warn","blendColorOperation","blendColorSrcFactor","blendColorDstFactor","blendAlphaOperation","blendAlphaSrcFactor","blendAlphaDstFactor","blend","blendEquation","FUNC_ADD","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","ONE","baseColorTexture","baseColorFactor","metallicRoughnessTexture","metallicFactor","roughnessFactor","gltfTexture","uniformName","define","sampler","image","source","textureOptions","specialTextureParameters","compressed","TEXTURE_MIN_FILTER","data","length","LINEAR_MIPMAP_NEAREST","LINEAR","createTexture","id","pixelStore","UNPACK_FLIP_Y_WEBGL","push"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\gltf\\src\\pbr\\parse-pbr-material.ts"],"sourcesContent":["import type {Device, Texture, Parameters} from '@luma.gl/core';\nimport {log} from '@luma.gl/core';\nimport {PBREnvironment} from './pbr-environment';\nimport {PBRMaterialBindings, PBRMaterialUniforms, PBRProjectionProps} from '@luma.gl/shadertools';\n\n/* eslint-disable camelcase */\n\nexport type ParsePBRMaterialOptions = {\n  /** Debug PBR shader */\n  pbrDebug?: boolean;\n  /** Enable lights */\n  lights?: any;\n  /** Use tangents */\n  useTangents?: boolean;\n  /** provide an image based (texture cube) lighting environment */\n  imageBasedLightingEnvironment?: PBREnvironment;\n};\n\nexport type ParsedPBRMaterial = {\n  readonly defines: Record<string, number | boolean>;\n  readonly bindings: Partial<PBRMaterialBindings>;\n  readonly uniforms: Partial<PBRProjectionProps & PBRMaterialUniforms>;\n  readonly parameters: Parameters;\n  readonly glParameters: Record<string, any>;\n  /** List of all generated textures, makes it easy to destroy them later */\n  readonly generatedTextures: Texture[];\n};\n\n// NOTE: Modules other than `@luma.gl/webgl` should not import `GL` from\n// `@luma.gl/constants`. Locally we use `GLEnum` instead of `GL` to avoid\n// conflicts with the `babel-plugin-inline-webgl-constants` plugin.\n// eslint-disable-next-line no-shadow\nenum GLEnum {\n  FUNC_ADD = 0x8006,\n  ONE = 1,\n  SRC_ALPHA = 0x0302,\n  ONE_MINUS_SRC_ALPHA = 0x0303,\n  TEXTURE_MIN_FILTER = 0x2801,\n  LINEAR = 0x2601,\n  LINEAR_MIPMAP_NEAREST = 0x2701,\n  UNPACK_FLIP_Y_WEBGL = 0x9240\n}\n\n/**\n * Parses a GLTF material definition into uniforms and parameters for the PBR shader module\n */\nexport function parsePBRMaterial(\n  device: Device,\n  material,\n  attributes: Record<string, any>,\n  options: ParsePBRMaterialOptions\n): ParsedPBRMaterial {\n  const parsedMaterial: ParsedPBRMaterial = {\n    defines: {\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    },\n    bindings: {},\n    uniforms: {\n      // TODO: find better values?\n      camera: [0, 0, 0], // Model should override\n\n      metallicRoughnessValues: [1, 1] // Default is 1 and 1\n    },\n    parameters: {},\n    glParameters: {},\n    generatedTextures: []\n  };\n\n  // TODO - always available\n  parsedMaterial.defines.USE_TEX_LOD = 1;\n\n  const {imageBasedLightingEnvironment} = options;\n  if (imageBasedLightingEnvironment) {\n    parsedMaterial.bindings.pbr_diffuseEnvSampler =\n      imageBasedLightingEnvironment.diffuseEnvSampler.texture;\n    parsedMaterial.bindings.pbr_specularEnvSampler =\n      imageBasedLightingEnvironment.specularEnvSampler.texture;\n    parsedMaterial.bindings.pbr_BrdfLUT = imageBasedLightingEnvironment.brdfLutTexture.texture;\n    parsedMaterial.uniforms.scaleIBLAmbient = [1, 1];\n  }\n\n  if (options?.pbrDebug) {\n    parsedMaterial.defines.PBR_DEBUG = 1;\n    // Override final color for reference app visualization of various parameters in the lighting equation.\n    parsedMaterial.uniforms.scaleDiffBaseMR = [0, 0, 0, 0];\n    parsedMaterial.uniforms.scaleFGDSpec = [0, 0, 0, 0];\n  }\n\n  if (attributes.NORMAL) parsedMaterial.defines.HAS_NORMALS = 1;\n  if (attributes.TANGENT && options?.useTangents) parsedMaterial.defines.HAS_TANGENTS = 1;\n  if (attributes.TEXCOORD_0) parsedMaterial.defines.HAS_UV = 1;\n\n  if (options?.imageBasedLightingEnvironment) parsedMaterial.defines.USE_IBL = 1;\n  if (options?.lights) parsedMaterial.defines.USE_LIGHTS = 1;\n\n  if (material) {\n    parseMaterial(device, material, parsedMaterial);\n  }\n\n  return parsedMaterial;\n}\n\n/** Parse GLTF material record */\nfunction parseMaterial(device: Device, material, parsedMaterial: ParsedPBRMaterial): void {\n  parsedMaterial.uniforms.unlit = Boolean(material.unlit);\n\n  if (material.pbrMetallicRoughness) {\n    parsePbrMetallicRoughness(device, material.pbrMetallicRoughness, parsedMaterial);\n  }\n  if (material.normalTexture) {\n    addTexture(\n      device,\n      material.normalTexture,\n      'pbr_normalSampler',\n      'HAS_NORMALMAP',\n      parsedMaterial\n    );\n\n    const {scale = 1} = material.normalTexture;\n    parsedMaterial.uniforms.normalScale = scale;\n  }\n  if (material.occlusionTexture) {\n    addTexture(\n      device,\n      material.occlusionTexture,\n      'pbr_occlusionSampler',\n      'HAS_OCCLUSIONMAP',\n      parsedMaterial\n    );\n\n    const {strength = 1} = material.occlusionTexture;\n    parsedMaterial.uniforms.occlusionStrength = strength;\n  }\n  if (material.emissiveTexture) {\n    addTexture(\n      device,\n      material.emissiveTexture,\n      'pbr_emissiveSampler',\n      'HAS_EMISSIVEMAP',\n      parsedMaterial\n    );\n    parsedMaterial.uniforms.emissiveFactor = material.emissiveFactor || [0, 0, 0];\n  }\n\n  switch (material.alphaMode) {\n    case 'MASK':\n      const {alphaCutoff = 0.5} = material;\n      parsedMaterial.defines.ALPHA_CUTOFF = 1;\n      parsedMaterial.uniforms.alphaCutoff = alphaCutoff;\n      break;\n    case 'BLEND':\n      log.warn('glTF BLEND alphaMode might not work well because it requires mesh sorting')();\n\n      // WebGPU style parameters\n      parsedMaterial.parameters.blendColorOperation = 'add';\n      parsedMaterial.parameters.blendColorSrcFactor = 'src-alpha';\n      parsedMaterial.parameters.blendColorDstFactor = 'one-minus-src-alpha';\n\n      parsedMaterial.parameters.blendAlphaOperation = 'add';\n      parsedMaterial.parameters.blendAlphaSrcFactor = 'one';\n      parsedMaterial.parameters.blendAlphaDstFactor = 'one-minus-src-alpha';\n\n      // GL parameters\n      parsedMaterial.glParameters.blend = true;\n      parsedMaterial.glParameters.blendEquation = GLEnum.FUNC_ADD;\n      parsedMaterial.glParameters.blendFunc = [\n        GLEnum.SRC_ALPHA,\n        GLEnum.ONE_MINUS_SRC_ALPHA,\n        GLEnum.ONE,\n        GLEnum.ONE_MINUS_SRC_ALPHA\n      ];\n\n      break;\n  }\n}\n\n/** Parse GLTF material sub record */\nfunction parsePbrMetallicRoughness(\n  device: Device,\n  pbrMetallicRoughness,\n  parsedMaterial: ParsedPBRMaterial\n): void {\n  if (pbrMetallicRoughness.baseColorTexture) {\n    addTexture(\n      device,\n      pbrMetallicRoughness.baseColorTexture,\n      'pbr_baseColorSampler',\n      'HAS_BASECOLORMAP',\n      parsedMaterial\n    );\n  }\n  parsedMaterial.uniforms.baseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n  if (pbrMetallicRoughness.metallicRoughnessTexture) {\n    addTexture(\n      device,\n      pbrMetallicRoughness.metallicRoughnessTexture,\n      'pbr_metallicRoughnessSampler',\n      'HAS_METALROUGHNESSMAP',\n      parsedMaterial\n    );\n  }\n  const {metallicFactor = 1, roughnessFactor = 1} = pbrMetallicRoughness;\n  parsedMaterial.uniforms.metallicRoughnessValues = [metallicFactor, roughnessFactor];\n}\n\n/** Create a texture from a glTF texture/sampler/image combo and add it to bindings */\nfunction addTexture(\n  device: Device,\n  gltfTexture,\n  uniformName: string,\n  define = null,\n  parsedMaterial: ParsedPBRMaterial\n): void {\n  const parameters = gltfTexture?.texture?.sampler?.parameters || {};\n\n  const image = gltfTexture.texture.source.image;\n  let textureOptions;\n  let specialTextureParameters = {};\n  if (image.compressed) {\n    textureOptions = image;\n    specialTextureParameters = {\n      [GLEnum.TEXTURE_MIN_FILTER]:\n        image.data.length > 1 ? GLEnum.LINEAR_MIPMAP_NEAREST : GLEnum.LINEAR\n    };\n  } else {\n    // Texture2D accepts a promise that returns an image as data (Async Textures)\n    textureOptions = {data: image};\n  }\n\n  const texture: Texture = device.createTexture({\n    id: gltfTexture.uniformName || gltfTexture.id,\n    parameters: {\n      ...parameters,\n      ...specialTextureParameters\n    },\n    pixelStore: {\n      [GLEnum.UNPACK_FLIP_Y_WEBGL]: false\n    },\n    ...textureOptions\n  });\n  parsedMaterial.bindings[uniformName] = texture;\n  if (define) parsedMaterial.defines[define] = 1;\n  parsedMaterial.generatedTextures.push(texture);\n}\n\n/*\n/**\n * Parses a GLTF material definition into uniforms and parameters for the PBR shader module\n *\nexport class PBRMaterialParser {\n  readonly device: Device;\n\n  readonly defines: Record<string, number | boolean>;\n  readonly bindings: Record<string, Binding>;\n  readonly uniforms: Record<string, any>;\n  readonly parameters: Record<string, any>;\n\n  /** Hold on to generated textures, we destroy them in the destroy method *\n  readonly generatedTextures: Texture[];\n\n  constructor(device: Device, props: PBRMaterialParserProps) {\n    const {attributes, material, pbrDebug, imageBasedLightingEnvironment, lights, useTangents} =\n      props;\n    this.device = device;\n\n    this.defines = {\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    };\n\n    if (this.device.features.has('glsl-texture-lod')) {\n      this.defines.USE_TEX_LOD = 1;\n    }\n\n    this.uniforms = {\n      // TODO: find better values?\n      camera: [0, 0, 0], // Model should override\n\n      metallicRoughnessValues: [1, 1] // Default is 1 and 1\n    };\n\n    this.bindings = {};\n\n    this.parameters = {};\n    this.generatedTextures = [];\n\n    if (imageBasedLightingEnvironment) {\n      this.bindings.pbr_diffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();\n      this.bindings.pbr_specularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();\n      this.bindings.pbr_BrdfLUT = imageBasedLightingEnvironment.getBrdfTexture();\n      this.uniforms.scaleIBLAmbient = [1, 1];\n    }\n\n    if (pbrDebug) {\n      // Override final color for reference app visualization\n      // of various parameters in the lighting equation.\n      this.uniforms.scaleDiffBaseMR = [0, 0, 0, 0];\n      this.uniforms.scaleFGDSpec = [0, 0, 0, 0];\n    }\n\n    this.defineIfPresent(attributes.NORMAL, 'HAS_NORMALS');\n    this.defineIfPresent(attributes.TANGENT && useTangents, 'HAS_TANGENTS');\n    this.defineIfPresent(attributes.TEXCOORD_0, 'HAS_UV');\n\n    this.defineIfPresent(imageBasedLightingEnvironment, 'USE_IBL');\n    this.defineIfPresent(lights, 'USE_LIGHTS');\n    this.defineIfPresent(pbrDebug, 'PBR_DEBUG');\n\n    if (material) {\n      this.parseMaterial(material);\n    }\n  }\n\n  /**\n   * Destroy all generated resources to release memory.\n   *\n  destroy(): void {\n    this.generatedTextures.forEach(texture => texture.destroy());\n  }\n\n  /** Add a define if the the value is non-nullish *\n  defineIfPresent(value: unknown, name: string): void {\n    if (value) {\n      this.defines[name] = 1;\n    }\n  }\n\n  /** Parse GLTF material record *\n  parseMaterial(material) {\n    this.uniforms.unlit = Boolean(material.unlit);\n\n    if (material.pbrMetallicRoughness) {\n      this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);\n    }\n    if (material.normalTexture) {\n      this.addTexture(material.normalTexture, 'pbr_normalSampler', 'HAS_NORMALMAP');\n\n      const {scale = 1} = material.normalTexture;\n      this.uniforms.normalScale = scale;\n    }\n    if (material.occlusionTexture) {\n      this.addTexture(material.occlusionTexture, 'pbr_occlusionSampler', 'HAS_OCCLUSIONMAP');\n\n      const {strength = 1} = material.occlusionTexture;\n      this.uniforms.occlusionStrength = strength;\n    }\n    if (material.emissiveTexture) {\n      this.addTexture(material.emissiveTexture, 'pbr_emissiveSampler', 'HAS_EMISSIVEMAP');\n      this.uniforms.emissiveFactor = material.emissiveFactor || [0, 0, 0];\n    }\n    if (material.alphaMode === 'MASK') {\n      const {alphaCutoff = 0.5} = material;\n      this.defines.ALPHA_CUTOFF = 1;\n      this.uniforms.alphaCutoff = alphaCutoff;\n    } else if (material.alphaMode === 'BLEND') {\n      log.warn('BLEND alphaMode might not work well because it requires mesh sorting')();\n      Object.assign(this.parameters, {\n        blend: true,\n        blendEquation: GL.FUNC_ADD,\n        blendFunc: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA, GL.ONE, GL.ONE_MINUS_SRC_ALPHA]\n      });\n    }\n  }\n\n  /** Parse GLTF material sub record *\n  parsePbrMetallicRoughness(pbrMetallicRoughness) {\n    if (pbrMetallicRoughness.baseColorTexture) {\n      this.addTexture(\n        pbrMetallicRoughness.baseColorTexture,\n        'pbr_baseColorSampler',\n        'HAS_BASECOLORMAP'\n      );\n    }\n    this.uniforms.baseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n    if (pbrMetallicRoughness.metallicRoughnessTexture) {\n      this.addTexture(\n        pbrMetallicRoughness.metallicRoughnessTexture,\n        'pbr_metallicRoughnessSampler',\n        'HAS_METALROUGHNESSMAP'\n      );\n    }\n    const {metallicFactor = 1, roughnessFactor = 1} = pbrMetallicRoughness;\n    this.uniforms.metallicRoughnessValues = [metallicFactor, roughnessFactor];\n  }\n\n  /** Create a texture from a glTF texture/sampler/image combo and add it to bindings *\n  addTexture(gltfTexture, name, define = null) {\n    const parameters = gltfTexture?.texture?.sampler?.parameters || {};\n\n    const image = gltfTexture.texture.source.image;\n    let textureOptions;\n    let specialTextureParameters = {};\n    if (image.compressed) {\n      textureOptions = image;\n      specialTextureParameters = {\n        [GL.TEXTURE_MIN_FILTER]: image.data.length > 1 ? GL.LINEAR_MIPMAP_NEAREST : GL.LINEAR\n      };\n    } else {\n      // Texture2D accepts a promise that returns an image as data (Async Textures)\n      textureOptions = {data: image};\n    }\n\n    const texture: Texture = this.device.createTexture({\n      id: gltfTexture.name || gltfTexture.id,\n      parameters: {\n        ...parameters,\n        ...specialTextureParameters\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      },\n      ...textureOptions\n    });\n    this.bindings[name] = texture;\n    this.defineIfPresent(define, define);\n    this.generatedTextures.push(texture);\n  }\n}\n*/\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}