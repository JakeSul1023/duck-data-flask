{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport function getDataTypeFromTypedArray(arrayOrType) {\n  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n  switch (type) {\n    case Float32Array:\n      return 'float32';\n    case Uint16Array:\n      return 'uint16';\n    case Uint32Array:\n      return 'uint32';\n    case Uint8Array:\n    case Uint8ClampedArray:\n      return 'uint8';\n    case Int8Array:\n      return 'sint8';\n    case Int16Array:\n      return 'sint16';\n    case Int32Array:\n      return 'sint32';\n    default:\n      // Failed to deduce data type from typed array\n      throw new Error(type.constructor.name);\n  }\n}\nexport function getTypedArrayFromDataType(dataType) {\n  switch (dataType) {\n    case 'float32':\n      return Float32Array;\n    case 'uint32':\n      return Uint32Array;\n    case 'sint32':\n      return Int32Array;\n    case 'uint16':\n    case 'unorm16':\n      return Uint16Array;\n    case 'sint16':\n    case 'snorm16':\n      return Int16Array;\n    case 'uint8':\n    case 'unorm8':\n      return Uint8Array;\n    case 'sint8':\n    case 'snorm8':\n      return Int8Array;\n    default:\n      // Failed to deduce typed array from data type\n      throw new Error(dataType);\n  }\n}\n/** Get the vertex format for an attribute with TypedArray and size */\nexport function getVertexFormatFromAttribute(typedArray, size, normalized) {\n  if (!size || size > 4) {\n    throw new Error(`size ${size}`);\n  }\n  const components = size;\n  let dataType = getDataTypeFromTypedArray(typedArray);\n  // TODO - Special cases for WebGL (not supported on WebGPU), overrides the check below\n  if (dataType === 'uint8' && normalized && components === 1) {\n    return 'unorm8-webgl';\n  }\n  if (dataType === 'uint8' && normalized && components === 3) {\n    return 'unorm8x3-webgl';\n  }\n  if (dataType === 'uint8' || dataType === 'sint8') {\n    if (components === 1 || components === 3) {\n      // WebGPU 8 bit formats must be aligned to 16 bit boundaries');\n      throw new Error(`size: ${size}`);\n    }\n    if (normalized) {\n      dataType = dataType.replace('int', 'norm');\n    }\n    return `${dataType}x${components}`;\n  }\n  if (dataType === 'uint16' || dataType === 'sint16') {\n    if (components === 1 || components === 3) {\n      // WebGPU 16 bit formats must be aligned to 32 bit boundaries\n      throw new Error(`size: ${size}`);\n    }\n    if (normalized) {\n      dataType = dataType.replace('int', 'norm');\n    }\n    return `${dataType}x${components}`;\n  }\n  if (components === 1) {\n    return dataType;\n  }\n  return `${dataType}x${components}`;\n}","map":{"version":3,"names":["getDataTypeFromTypedArray","arrayOrType","type","ArrayBuffer","isView","constructor","Float32Array","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","Int8Array","Int16Array","Int32Array","Error","name","getTypedArrayFromDataType","dataType","getVertexFormatFromAttribute","typedArray","size","normalized","components","replace"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\core\\src\\gpu-type-utils\\vertex-format-from-attribute.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {TypedArray, TypedArrayConstructor} from '../types';\nimport {VertexFormat} from './vertex-formats';\n\n// import {DataType} from '../types/vertex-formats';\n// type Omit<DataType, 'float16'> unfortunately breaks Typescript inferance\ntype DataType = 'uint8' | 'sint8' | 'uint16' | 'sint16' | 'uint32' | 'sint32' | 'float32';\ntype DataTypeNorm = 'unorm8' | 'snorm8' | 'unorm16' | 'snorm16';\n\nexport function getDataTypeFromTypedArray(\n  arrayOrType: TypedArray | TypedArrayConstructor\n): DataType {\n  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n  switch (type) {\n    case Float32Array:\n      return 'float32';\n    case Uint16Array:\n      return 'uint16';\n    case Uint32Array:\n      return 'uint32';\n    case Uint8Array:\n    case Uint8ClampedArray:\n      return 'uint8';\n    case Int8Array:\n      return 'sint8';\n    case Int16Array:\n      return 'sint16';\n    case Int32Array:\n      return 'sint32';\n    default:\n      // Failed to deduce data type from typed array\n      throw new Error(type.constructor.name);\n  }\n}\n\nexport function getTypedArrayFromDataType(\n  dataType: DataType | DataTypeNorm\n): TypedArrayConstructor {\n  switch (dataType) {\n    case 'float32':\n      return Float32Array;\n    case 'uint32':\n      return Uint32Array;\n    case 'sint32':\n      return Int32Array;\n    case 'uint16':\n    case 'unorm16':\n      return Uint16Array;\n    case 'sint16':\n    case 'snorm16':\n      return Int16Array;\n    case 'uint8':\n    case 'unorm8':\n      return Uint8Array;\n    case 'sint8':\n    case 'snorm8':\n      return Int8Array;\n    default:\n      // Failed to deduce typed array from data type\n      throw new Error(dataType);\n  }\n}\n\n/** Get the vertex format for an attribute with TypedArray and size */\nexport function getVertexFormatFromAttribute(\n  typedArray: TypedArray,\n  size: number,\n  normalized?: boolean\n): VertexFormat {\n  if (!size || size > 4) {\n    throw new Error(`size ${size}`);\n  }\n\n  const components = size as 1 | 2 | 3 | 4;\n  let dataType: DataType | DataTypeNorm = getDataTypeFromTypedArray(typedArray);\n\n  // TODO - Special cases for WebGL (not supported on WebGPU), overrides the check below\n  if (dataType === 'uint8' && normalized && components === 1) {\n    return 'unorm8-webgl';\n  }\n  if (dataType === 'uint8' && normalized && components === 3) {\n    return 'unorm8x3-webgl';\n  }\n\n  if (dataType === 'uint8' || dataType === 'sint8') {\n    if (components === 1 || components === 3) {\n      // WebGPU 8 bit formats must be aligned to 16 bit boundaries');\n      throw new Error(`size: ${size}`);\n    }\n    if (normalized) {\n      dataType = dataType.replace('int', 'norm') as 'unorm8' | 'snorm8';\n    }\n    return `${dataType}x${components}`;\n  }\n  if (dataType === 'uint16' || dataType === 'sint16') {\n    if (components === 1 || components === 3) {\n      // WebGPU 16 bit formats must be aligned to 32 bit boundaries\n      throw new Error(`size: ${size}`);\n    }\n    if (normalized) {\n      dataType = dataType.replace('int', 'norm') as 'unorm16' | 'snorm16';\n    }\n    return `${dataType}x${components}`;\n  }\n\n  if (components === 1) {\n    return dataType;\n  }\n\n  return `${dataType}x${components}`;\n}\n"],"mappings":"AAAA;AACA;AACA;AAUA,OAAM,SAAUA,yBAAyBA,CACvCC,WAA+C;EAE/C,MAAMC,IAAI,GAAGC,WAAW,CAACC,MAAM,CAACH,WAAW,CAAC,GAAGA,WAAW,CAACI,WAAW,GAAGJ,WAAW;EACpF,QAAQC,IAAI;IACV,KAAKI,YAAY;MACf,OAAO,SAAS;IAClB,KAAKC,WAAW;MACd,OAAO,QAAQ;IACjB,KAAKC,WAAW;MACd,OAAO,QAAQ;IACjB,KAAKC,UAAU;IACf,KAAKC,iBAAiB;MACpB,OAAO,OAAO;IAChB,KAAKC,SAAS;MACZ,OAAO,OAAO;IAChB,KAAKC,UAAU;MACb,OAAO,QAAQ;IACjB,KAAKC,UAAU;MACb,OAAO,QAAQ;IACjB;MACE;MACA,MAAM,IAAIC,KAAK,CAACZ,IAAI,CAACG,WAAW,CAACU,IAAI,CAAC;EAC1C;AACF;AAEA,OAAM,SAAUC,yBAAyBA,CACvCC,QAAiC;EAEjC,QAAQA,QAAQ;IACd,KAAK,SAAS;MACZ,OAAOX,YAAY;IACrB,KAAK,QAAQ;MACX,OAAOE,WAAW;IACpB,KAAK,QAAQ;MACX,OAAOK,UAAU;IACnB,KAAK,QAAQ;IACb,KAAK,SAAS;MACZ,OAAON,WAAW;IACpB,KAAK,QAAQ;IACb,KAAK,SAAS;MACZ,OAAOK,UAAU;IACnB,KAAK,OAAO;IACZ,KAAK,QAAQ;MACX,OAAOH,UAAU;IACnB,KAAK,OAAO;IACZ,KAAK,QAAQ;MACX,OAAOE,SAAS;IAClB;MACE;MACA,MAAM,IAAIG,KAAK,CAACG,QAAQ,CAAC;EAC7B;AACF;AAEA;AACA,OAAM,SAAUC,4BAA4BA,CAC1CC,UAAsB,EACtBC,IAAY,EACZC,UAAoB;EAEpB,IAAI,CAACD,IAAI,IAAIA,IAAI,GAAG,CAAC,EAAE;IACrB,MAAM,IAAIN,KAAK,CAAC,QAAQM,IAAI,EAAE,CAAC;EACjC;EAEA,MAAME,UAAU,GAAGF,IAAqB;EACxC,IAAIH,QAAQ,GAA4BjB,yBAAyB,CAACmB,UAAU,CAAC;EAE7E;EACA,IAAIF,QAAQ,KAAK,OAAO,IAAII,UAAU,IAAIC,UAAU,KAAK,CAAC,EAAE;IAC1D,OAAO,cAAc;EACvB;EACA,IAAIL,QAAQ,KAAK,OAAO,IAAII,UAAU,IAAIC,UAAU,KAAK,CAAC,EAAE;IAC1D,OAAO,gBAAgB;EACzB;EAEA,IAAIL,QAAQ,KAAK,OAAO,IAAIA,QAAQ,KAAK,OAAO,EAAE;IAChD,IAAIK,UAAU,KAAK,CAAC,IAAIA,UAAU,KAAK,CAAC,EAAE;MACxC;MACA,MAAM,IAAIR,KAAK,CAAC,SAASM,IAAI,EAAE,CAAC;IAClC;IACA,IAAIC,UAAU,EAAE;MACdJ,QAAQ,GAAGA,QAAQ,CAACM,OAAO,CAAC,KAAK,EAAE,MAAM,CAAwB;IACnE;IACA,OAAO,GAAGN,QAAQ,IAAIK,UAAU,EAAE;EACpC;EACA,IAAIL,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,KAAK,QAAQ,EAAE;IAClD,IAAIK,UAAU,KAAK,CAAC,IAAIA,UAAU,KAAK,CAAC,EAAE;MACxC;MACA,MAAM,IAAIR,KAAK,CAAC,SAASM,IAAI,EAAE,CAAC;IAClC;IACA,IAAIC,UAAU,EAAE;MACdJ,QAAQ,GAAGA,QAAQ,CAACM,OAAO,CAAC,KAAK,EAAE,MAAM,CAA0B;IACrE;IACA,OAAO,GAAGN,QAAQ,IAAIK,UAAU,EAAE;EACpC;EAEA,IAAIA,UAAU,KAAK,CAAC,EAAE;IACpB,OAAOL,QAAQ;EACjB;EAEA,OAAO,GAAGA,QAAQ,IAAIK,UAAU,EAAE;AACpC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}