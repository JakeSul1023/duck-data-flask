{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n/* eslint-disable */\nimport { Vector3, Matrix4, assert, equals, _MathUtils, vec3 } from '@math.gl/core';\nimport { WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z } from \"../constants.js\";\nimport { fromCartographicToRadians, toCartographicFromRadians } from \"../type-utils.js\";\nimport { localFrameToFixedFrame } from \"./helpers/ellipsoid-transform.js\";\nimport { scaleToGeodeticSurface } from \"./helpers/scale-to-geodetic-surface.js\";\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\nconst scratchK = new Vector3();\nconst scratchPosition = new Vector3();\nconst scratchHeight = new Vector3();\nconst scratchCartesian = new Vector3();\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * `(x / a)^2 + (y / b)^2 + (z / c)^2 = 1`.  Primarily used\n * to represent the shape of planetary bodies.\n */\nexport class Ellipsoid {\n  constructor(x = 0.0, y = 0.0, z = 0.0) {\n    this.centerToleranceSquared = _MathUtils.EPSILON1;\n    assert(x >= 0.0);\n    assert(y >= 0.0);\n    assert(z >= 0.0);\n    this.radii = new Vector3(x, y, z);\n    this.radiiSquared = new Vector3(x * x, y * y, z * z);\n    this.radiiToTheFourth = new Vector3(x * x * x * x, y * y * y * y, z * z * z * z);\n    this.oneOverRadii = new Vector3(x === 0.0 ? 0.0 : 1.0 / x, y === 0.0 ? 0.0 : 1.0 / y, z === 0.0 ? 0.0 : 1.0 / z);\n    this.oneOverRadiiSquared = new Vector3(x === 0.0 ? 0.0 : 1.0 / (x * x), y === 0.0 ? 0.0 : 1.0 / (y * y), z === 0.0 ? 0.0 : 1.0 / (z * z));\n    this.minimumRadius = Math.min(x, y, z);\n    this.maximumRadius = Math.max(x, y, z);\n    if (this.radiiSquared.z !== 0) {\n      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;\n    }\n    Object.freeze(this);\n  }\n  /** Compares this Ellipsoid against the provided Ellipsoid componentwise */\n  equals(right) {\n    return this === right || Boolean(right && this.radii.equals(right.radii));\n  }\n  /** Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'. */\n  toString() {\n    return this.radii.toString();\n  }\n  cartographicToCartesian(cartographic, result = [0, 0, 0]) {\n    const normal = scratchNormal;\n    const k = scratchK;\n    const [,, height] = cartographic;\n    this.geodeticSurfaceNormalCartographic(cartographic, normal);\n    k.copy(this.radiiSquared).scale(normal);\n    const gamma = Math.sqrt(normal.dot(k));\n    k.scale(1 / gamma);\n    normal.scale(height);\n    k.add(normal);\n    return k.to(result);\n  }\n  cartesianToCartographic(cartesian, result = [0, 0, 0]) {\n    scratchCartesian.from(cartesian);\n    const point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition);\n    if (!point) {\n      return undefined;\n    }\n    const normal = this.geodeticSurfaceNormal(point, scratchNormal);\n    const h = scratchHeight;\n    h.copy(scratchCartesian).subtract(point);\n    const longitude = Math.atan2(normal.y, normal.x);\n    const latitude = Math.asin(normal.z);\n    const height = Math.sign(vec3.dot(h, scratchCartesian)) * vec3.length(h);\n    return toCartographicFromRadians([longitude, latitude, height], result);\n  }\n  eastNorthUpToFixedFrame(origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, 'east', 'north', 'up', origin, result);\n  }\n  // Computes a 4x4 transformation matrix from a reference frame centered at\n  // the provided origin to the ellipsoid's fixed reference frame.\n  localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);\n  }\n  geocentricSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector.from(cartesian).normalize().to(result);\n  }\n  geodeticSurfaceNormalCartographic(cartographic, result = [0, 0, 0]) {\n    const cartographicVectorRadians = fromCartographicToRadians(cartographic);\n    const longitude = cartographicVectorRadians[0];\n    const latitude = cartographicVectorRadians[1];\n    const cosLatitude = Math.cos(latitude);\n    scratchVector.set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude)).normalize();\n    return scratchVector.to(result);\n  }\n  geodeticSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);\n  }\n  /** Scales the provided Cartesian position along the geodetic surface normal\n   * so that it is on the surface of this ellipsoid.  If the position is\n   * at the center of the ellipsoid, this function returns undefined. */\n  scaleToGeodeticSurface(cartesian, result) {\n    return scaleToGeodeticSurface(cartesian, this, result);\n  }\n  /** Scales the provided Cartesian position along the geocentric surface normal\n   * so that it is on the surface of this ellipsoid. */\n  scaleToGeocentricSurface(cartesian, result = [0, 0, 0]) {\n    scratchPosition.from(cartesian);\n    const positionX = scratchPosition.x;\n    const positionY = scratchPosition.y;\n    const positionZ = scratchPosition.z;\n    const oneOverRadiiSquared = this.oneOverRadiiSquared;\n    const beta = 1.0 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);\n    return scratchPosition.multiplyScalar(beta).to(result);\n  }\n  /** Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n   * its components by the result of `Ellipsoid#oneOverRadii` */\n  transformPositionToScaledSpace(position, result = [0, 0, 0]) {\n    return scratchPosition.from(position).scale(this.oneOverRadii).to(result);\n  }\n  /** Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n   * its components by the result of `Ellipsoid#radii`. */\n  transformPositionFromScaledSpace(position, result = [0, 0, 0]) {\n    return scratchPosition.from(position).scale(this.radii).to(result);\n  }\n  /** Computes a point which is the intersection of the surface normal with the z-axis. */\n  getSurfaceNormalIntersectionWithZAxis(position, buffer = 0, result = [0, 0, 0]) {\n    // Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\n    assert(equals(this.radii.x, this.radii.y, _MathUtils.EPSILON15));\n    assert(this.radii.z > 0);\n    scratchPosition.from(position);\n    const z = scratchPosition.z * (1 - this.squaredXOverSquaredZ);\n    if (Math.abs(z) >= this.radii.z - buffer) {\n      return undefined;\n    }\n    return scratchPosition.set(0.0, 0.0, z).to(result);\n  }\n}\n/** An Ellipsoid instance initialized to the WGS84 standard. */\nEllipsoid.WGS84 = new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z);\n//# sourceMappingURL=ellipsoid.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}