{"ast":null,"code":"// From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license\n// http://2ality.com/2016/10/asynchronous-iteration.html\nclass ArrayQueue extends Array {\n  enqueue(value) {\n    // Add at the end\n    return this.push(value);\n  }\n  dequeue() {\n    // Remove first element\n    return this.shift();\n  }\n}\nexport default class AsyncQueue {\n  _values;\n  _settlers;\n  _closed;\n  constructor() {\n    // enqueues > dequeues\n    this._values = new ArrayQueue();\n    // dequeues > enqueues\n    this._settlers = new ArrayQueue();\n    this._closed = false;\n  }\n  close() {\n    while (this._settlers.length > 0) {\n      this._settlers.dequeue().resolve({\n        done: true\n      });\n    }\n    this._closed = true;\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n  enqueue(value) {\n    if (this._closed) {\n      throw new Error('Closed');\n    }\n    if (this._settlers.length > 0) {\n      if (this._values.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      const settler = this._settlers.dequeue();\n      if (value instanceof Error) {\n        settler.reject(value);\n      } else {\n        settler.resolve({\n          value\n        });\n      }\n    } else {\n      this._values.enqueue(value);\n    }\n  }\n  /**\n   * @returns a Promise for an IteratorResult\n   */\n  next() {\n    if (this._values.length > 0) {\n      const value = this._values.dequeue();\n      if (value instanceof Error) {\n        return Promise.reject(value);\n      }\n      return Promise.resolve({\n        value\n      });\n    }\n    if (this._closed) {\n      if (this._settlers.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      return Promise.resolve({\n        done: true\n      });\n    }\n    // Wait for new values to be enqueued\n    return new Promise((resolve, reject) => {\n      this._settlers.enqueue({\n        resolve,\n        reject\n      });\n    });\n  }\n}\n/**\n * @returns a Promise for an Array with the elements in `asyncIterable`\n */\nexport async function takeAsync(asyncIterable) {\n  let count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n  const result = [];\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  while (result.length < count) {\n    const {\n      value,\n      done\n    } = await iterator.next();\n    if (done) {\n      break;\n    }\n    result.push(value);\n  }\n  return result;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}