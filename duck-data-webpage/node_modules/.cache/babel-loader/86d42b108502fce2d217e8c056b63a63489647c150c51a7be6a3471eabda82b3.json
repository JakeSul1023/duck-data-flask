{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** Applies a scale to BinaryAttribute */\nexport class AttributeWithScale {\n  constructor(input, inputLength) {\n    this.props = {\n      scaleType: 'linear',\n      lowerPercentile: 0,\n      upperPercentile: 100\n    };\n    /** [min, max] of attribute values, or null if unknown */\n    this.domain = null;\n    /** Valid domain if lower/upper percentile are defined */\n    this.cutoff = null;\n    this.input = input;\n    this.inputLength = inputLength;\n    // No processing is needed with the default scale\n    this.attribute = input;\n  }\n  getScalePercentile() {\n    if (!this._percentile) {\n      const value = getAttributeValue(this.input, this.inputLength);\n      this._percentile = applyScaleQuantile(value);\n    }\n    return this._percentile;\n  }\n  getScaleOrdinal() {\n    if (!this._ordinal) {\n      const value = getAttributeValue(this.input, this.inputLength);\n      this._ordinal = applyScaleOrdinal(value);\n    }\n    return this._ordinal;\n  }\n  /** Returns the [lowerCutoff, upperCutoff] of scaled values, or null if not applicable */\n  getCutoff({\n    scaleType,\n    lowerPercentile,\n    upperPercentile\n  }) {\n    if (scaleType === 'quantile') {\n      return [lowerPercentile, upperPercentile - 1];\n    }\n    if (lowerPercentile > 0 || upperPercentile < 100) {\n      const {\n        domain: thresholds\n      } = this.getScalePercentile();\n      let lowValue = thresholds[Math.floor(lowerPercentile) - 1] ?? -Infinity;\n      let highValue = thresholds[Math.floor(upperPercentile) - 1] ?? Infinity;\n      if (scaleType === 'ordinal') {\n        const {\n          domain: sortedUniqueValues\n        } = this.getScaleOrdinal();\n        lowValue = sortedUniqueValues.findIndex(x => x >= lowValue);\n        highValue = sortedUniqueValues.findIndex(x => x > highValue) - 1;\n        if (highValue === -2) {\n          highValue = sortedUniqueValues.length - 1;\n        }\n      }\n      return [lowValue, highValue];\n    }\n    return null;\n  }\n  update(props) {\n    const oldProps = this.props;\n    if (props.scaleType !== oldProps.scaleType) {\n      switch (props.scaleType) {\n        case 'quantile':\n          {\n            const {\n              attribute\n            } = this.getScalePercentile();\n            this.attribute = attribute;\n            this.domain = [0, 99];\n            break;\n          }\n        case 'ordinal':\n          {\n            const {\n              attribute,\n              domain\n            } = this.getScaleOrdinal();\n            this.attribute = attribute;\n            this.domain = [0, domain.length - 1];\n            break;\n          }\n        default:\n          this.attribute = this.input;\n          this.domain = null;\n      }\n    }\n    if (props.scaleType !== oldProps.scaleType || props.lowerPercentile !== oldProps.lowerPercentile || props.upperPercentile !== oldProps.upperPercentile) {\n      this.cutoff = this.getCutoff(props);\n    }\n    this.props = props;\n    return this;\n  }\n}\n/**\n * Transform an array of values to ordinal indices\n */\nexport function applyScaleOrdinal(values) {\n  const uniqueValues = new Set();\n  for (const x of values) {\n    if (Number.isFinite(x)) {\n      uniqueValues.add(x);\n    }\n  }\n  const sortedUniqueValues = Array.from(uniqueValues).sort();\n  const domainMap = new Map();\n  for (let i = 0; i < sortedUniqueValues.length; i++) {\n    domainMap.set(sortedUniqueValues[i], i);\n  }\n  return {\n    attribute: {\n      value: values.map(x => Number.isFinite(x) ? domainMap.get(x) : NaN),\n      type: 'float32',\n      size: 1\n    },\n    domain: sortedUniqueValues\n  };\n}\n/**\n * Transform an array of values to percentiles\n */\nexport function applyScaleQuantile(values, rangeLength = 100) {\n  const sortedValues = Array.from(values).filter(Number.isFinite).sort(ascending);\n  let i = 0;\n  const n = Math.max(1, rangeLength);\n  const thresholds = new Array(n - 1);\n  while (++i < n) {\n    thresholds[i - 1] = threshold(sortedValues, i / n);\n  }\n  return {\n    attribute: {\n      value: values.map(x => Number.isFinite(x) ? bisectRight(thresholds, x) : NaN),\n      type: 'float32',\n      size: 1\n    },\n    domain: thresholds\n  };\n}\nfunction getAttributeValue(attribute, length) {\n  const elementStride = (attribute.stride ?? 4) / 4;\n  const elementOffset = (attribute.offset ?? 0) / 4;\n  let value = attribute.value;\n  if (!value) {\n    const bytes = attribute.buffer?.readSyncWebGL(0, elementStride * 4 * length);\n    if (bytes) {\n      value = new Float32Array(bytes.buffer);\n      attribute.value = value;\n    }\n  }\n  if (elementStride === 1) {\n    return value.subarray(0, length);\n  }\n  const result = new Float32Array(length);\n  for (let i = 0; i < length; i++) {\n    result[i] = value[i * elementStride + elementOffset];\n  }\n  return result;\n}\nfunction ascending(a, b) {\n  return a - b;\n}\nfunction threshold(domain, fraction) {\n  const domainLength = domain.length;\n  if (fraction <= 0 || domainLength < 2) {\n    return domain[0];\n  }\n  if (fraction >= 1) {\n    return domain[domainLength - 1];\n  }\n  const domainFraction = (domainLength - 1) * fraction;\n  const lowIndex = Math.floor(domainFraction);\n  const low = domain[lowIndex];\n  const high = domain[lowIndex + 1];\n  return low + (high - low) * (domainFraction - lowIndex);\n}\nfunction bisectRight(a, x) {\n  let lo = 0;\n  let hi = a.length;\n  while (lo < hi) {\n    const mid = lo + hi >>> 1;\n    if (a[mid] > x) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}","map":{"version":3,"names":["AttributeWithScale","constructor","input","inputLength","props","scaleType","lowerPercentile","upperPercentile","domain","cutoff","attribute","getScalePercentile","_percentile","value","getAttributeValue","applyScaleQuantile","getScaleOrdinal","_ordinal","applyScaleOrdinal","getCutoff","thresholds","lowValue","Math","floor","Infinity","highValue","sortedUniqueValues","findIndex","x","length","update","oldProps","values","uniqueValues","Set","Number","isFinite","add","Array","from","sort","domainMap","Map","i","set","map","get","NaN","type","size","rangeLength","sortedValues","filter","ascending","n","max","threshold","bisectRight","elementStride","stride","elementOffset","offset","bytes","buffer","readSyncWebGL","Float32Array","subarray","result","a","b","fraction","domainLength","domainFraction","lowIndex","low","high","lo","hi","mid"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\aggregation-layers\\src\\common\\utils\\scale-utils.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {BinaryAttribute} from '@deck.gl/core';\nimport type {ScaleType} from '../types';\n\ntype ScaleProps = {\n  scaleType: ScaleType;\n  /** Trim the lower end of the domain by this percentile. Set to `0` to disable. */\n  lowerPercentile: number;\n  /** Trim the upper end of the domain by this percentile. Set to `100` to disable. */\n  upperPercentile: number;\n};\n\n/** Applies a scale to BinaryAttribute */\nexport class AttributeWithScale {\n  /** Input values accessor. Has either a `value` (CPU aggregation) or a `buffer` (GPU aggregation) */\n  private readonly input: BinaryAttribute;\n  private readonly inputLength: number;\n\n  private props: ScaleProps = {\n    scaleType: 'linear',\n    lowerPercentile: 0,\n    upperPercentile: 100\n  };\n\n  // cached calculations\n  private _percentile?: {attribute: BinaryAttribute; domain: number[]};\n  private _ordinal?: {attribute: BinaryAttribute; domain: number[]};\n\n  /** Output values accessor */\n  attribute: BinaryAttribute;\n  /** [min, max] of attribute values, or null if unknown */\n  domain: [number, number] | null = null;\n  /** Valid domain if lower/upper percentile are defined */\n  cutoff: [number, number] | null = null;\n\n  constructor(input: BinaryAttribute, inputLength: number) {\n    this.input = input;\n    this.inputLength = inputLength;\n    // No processing is needed with the default scale\n    this.attribute = input;\n  }\n\n  private getScalePercentile() {\n    if (!this._percentile) {\n      const value = getAttributeValue(this.input, this.inputLength);\n      this._percentile = applyScaleQuantile(value);\n    }\n    return this._percentile;\n  }\n\n  private getScaleOrdinal() {\n    if (!this._ordinal) {\n      const value = getAttributeValue(this.input, this.inputLength);\n      this._ordinal = applyScaleOrdinal(value);\n    }\n    return this._ordinal;\n  }\n\n  /** Returns the [lowerCutoff, upperCutoff] of scaled values, or null if not applicable */\n  private getCutoff({\n    scaleType,\n    lowerPercentile,\n    upperPercentile\n  }: ScaleProps): [number, number] | null {\n    if (scaleType === 'quantile') {\n      return [lowerPercentile, upperPercentile - 1];\n    }\n\n    if (lowerPercentile > 0 || upperPercentile < 100) {\n      const {domain: thresholds} = this.getScalePercentile();\n      let lowValue = thresholds[Math.floor(lowerPercentile) - 1] ?? -Infinity;\n      let highValue = thresholds[Math.floor(upperPercentile) - 1] ?? Infinity;\n\n      if (scaleType === 'ordinal') {\n        const {domain: sortedUniqueValues} = this.getScaleOrdinal();\n        lowValue = sortedUniqueValues.findIndex(x => x >= lowValue);\n        highValue = sortedUniqueValues.findIndex(x => x > highValue) - 1;\n        if (highValue === -2) {\n          highValue = sortedUniqueValues.length - 1;\n        }\n      }\n      return [lowValue, highValue];\n    }\n\n    return null;\n  }\n\n  update(props: ScaleProps) {\n    const oldProps = this.props;\n\n    if (props.scaleType !== oldProps.scaleType) {\n      switch (props.scaleType) {\n        case 'quantile': {\n          const {attribute} = this.getScalePercentile();\n          this.attribute = attribute;\n          this.domain = [0, 99];\n          break;\n        }\n        case 'ordinal': {\n          const {attribute, domain} = this.getScaleOrdinal();\n          this.attribute = attribute;\n          this.domain = [0, domain.length - 1];\n          break;\n        }\n\n        default:\n          this.attribute = this.input;\n          this.domain = null;\n      }\n    }\n    if (\n      props.scaleType !== oldProps.scaleType ||\n      props.lowerPercentile !== oldProps.lowerPercentile ||\n      props.upperPercentile !== oldProps.upperPercentile\n    ) {\n      this.cutoff = this.getCutoff(props);\n    }\n    this.props = props;\n    return this;\n  }\n}\n\n/**\n * Transform an array of values to ordinal indices\n */\nexport function applyScaleOrdinal(values: Float32Array): {\n  attribute: BinaryAttribute;\n  domain: number[];\n} {\n  const uniqueValues = new Set<number>();\n  for (const x of values) {\n    if (Number.isFinite(x)) {\n      uniqueValues.add(x);\n    }\n  }\n  const sortedUniqueValues = Array.from(uniqueValues).sort();\n  const domainMap = new Map();\n  for (let i = 0; i < sortedUniqueValues.length; i++) {\n    domainMap.set(sortedUniqueValues[i], i);\n  }\n\n  return {\n    attribute: {\n      value: values.map(x => (Number.isFinite(x) ? domainMap.get(x) : NaN)),\n      type: 'float32',\n      size: 1\n    },\n    domain: sortedUniqueValues\n  };\n}\n\n/**\n * Transform an array of values to percentiles\n */\nexport function applyScaleQuantile(\n  values: Float32Array,\n  rangeLength = 100\n): {\n  attribute: BinaryAttribute;\n  domain: number[];\n} {\n  const sortedValues = Array.from(values).filter(Number.isFinite).sort(ascending);\n  let i = 0;\n  const n = Math.max(1, rangeLength);\n  const thresholds: number[] = new Array(n - 1);\n  while (++i < n) {\n    thresholds[i - 1] = threshold(sortedValues, i / n);\n  }\n  return {\n    attribute: {\n      value: values.map(x => (Number.isFinite(x) ? bisectRight(thresholds, x) : NaN)),\n      type: 'float32',\n      size: 1\n    },\n    domain: thresholds\n  };\n}\n\nfunction getAttributeValue(attribute: BinaryAttribute, length: number): Float32Array {\n  const elementStride = (attribute.stride ?? 4) / 4;\n  const elementOffset = (attribute.offset ?? 0) / 4;\n  let value = attribute.value as Float32Array;\n  if (!value) {\n    const bytes = attribute.buffer?.readSyncWebGL(0, elementStride * 4 * length);\n    if (bytes) {\n      value = new Float32Array(bytes.buffer);\n      attribute.value = value;\n    }\n  }\n\n  if (elementStride === 1) {\n    return value.subarray(0, length);\n  }\n  const result = new Float32Array(length);\n  for (let i = 0; i < length; i++) {\n    result[i] = value[i * elementStride + elementOffset];\n  }\n  return result;\n}\n\nfunction ascending(a: number, b: number): number {\n  return a - b;\n}\n\nfunction threshold(domain: number[], fraction: number): number {\n  const domainLength = domain.length;\n  if (fraction <= 0 || domainLength < 2) {\n    return domain[0];\n  }\n  if (fraction >= 1) {\n    return domain[domainLength - 1];\n  }\n\n  const domainFraction = (domainLength - 1) * fraction;\n  const lowIndex = Math.floor(domainFraction);\n  const low = domain[lowIndex];\n  const high = domain[lowIndex + 1];\n  return low + (high - low) * (domainFraction - lowIndex);\n}\n\nfunction bisectRight(a: number[], x: number): number {\n  let lo = 0;\n  let hi = a.length;\n  while (lo < hi) {\n    const mid = (lo + hi) >>> 1;\n    if (a[mid] > x) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}