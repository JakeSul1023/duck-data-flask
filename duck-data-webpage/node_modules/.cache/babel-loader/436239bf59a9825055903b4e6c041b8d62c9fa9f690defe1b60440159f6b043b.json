{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@luma.gl/core';\nimport { lightingUniformsGLSL } from \"./lighting-uniforms-glsl.js\";\nimport { lightingUniformsWGSL } from \"./lighting-uniforms-wgsl.js\";\n/** Max number of supported lights (in addition to ambient light */\nconst MAX_LIGHTS = 3;\n/** Whether to divide */\nconst COLOR_FACTOR = 255.0;\n/** Shader type field for lights */\n// eslint-disable-next-line no-shadow\nexport var LIGHT_TYPE;\n(function (LIGHT_TYPE) {\n  LIGHT_TYPE[LIGHT_TYPE[\"POINT\"] = 0] = \"POINT\";\n  LIGHT_TYPE[LIGHT_TYPE[\"DIRECTIONAL\"] = 1] = \"DIRECTIONAL\";\n})(LIGHT_TYPE || (LIGHT_TYPE = {}));\n/** UBO ready lighting module */\nexport const lighting = {\n  props: {},\n  uniforms: {},\n  name: 'lighting',\n  defines: {\n    MAX_LIGHTS\n  },\n  uniformTypes: {\n    enabled: 'i32',\n    lightType: 'i32',\n    directionalLightCount: 'i32',\n    pointLightCount: 'i32',\n    ambientLightColor: 'vec3<f32>',\n    // TODO define as arrays once we have appropriate uniformTypes\n    lightColor0: 'vec3<f32>',\n    lightPosition0: 'vec3<f32>',\n    // TODO - could combine direction and attenuation\n    lightDirection0: 'vec3<f32>',\n    lightAttenuation0: 'vec3<f32>',\n    lightColor1: 'vec3<f32>',\n    lightPosition1: 'vec3<f32>',\n    lightDirection1: 'vec3<f32>',\n    lightAttenuation1: 'vec3<f32>',\n    lightColor2: 'vec3<f32>',\n    lightPosition2: 'vec3<f32>',\n    lightDirection2: 'vec3<f32>',\n    lightAttenuation2: 'vec3<f32>'\n  },\n  defaultUniforms: {\n    enabled: 1,\n    lightType: LIGHT_TYPE.POINT,\n    directionalLightCount: 0,\n    pointLightCount: 0,\n    ambientLightColor: [0.1, 0.1, 0.1],\n    lightColor0: [1, 1, 1],\n    lightPosition0: [1, 1, 2],\n    // TODO - could combine direction and attenuation\n    lightDirection0: [1, 1, 1],\n    lightAttenuation0: [1, 0, 0],\n    lightColor1: [1, 1, 1],\n    lightPosition1: [1, 1, 2],\n    lightDirection1: [1, 1, 1],\n    lightAttenuation1: [1, 0, 0],\n    lightColor2: [1, 1, 1],\n    lightPosition2: [1, 1, 2],\n    lightDirection2: [1, 1, 1],\n    lightAttenuation2: [1, 0, 0]\n  },\n  source: lightingUniformsWGSL,\n  vs: lightingUniformsGLSL,\n  fs: lightingUniformsGLSL,\n  getUniforms\n};\nfunction getUniforms(props) {\n  let prevUniforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // Copy props so we can modify\n  props = props ? {\n    ...props\n  } : props;\n  // TODO legacy\n  if (!props) {\n    return {\n      ...lighting.defaultUniforms\n    };\n  }\n  // Support for array of lights. Type of light is detected by type field\n  if (props.lights) {\n    props = {\n      ...props,\n      ...extractLightTypes(props.lights),\n      lights: undefined\n    };\n  }\n  // Specify lights separately\n  const {\n    ambientLight,\n    pointLights,\n    directionalLights\n  } = props || {};\n  const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;\n  // TODO - this may not be the correct decision\n  if (!hasLights) {\n    return {\n      ...lighting.defaultUniforms,\n      enabled: 0\n    };\n  }\n  const uniforms = {\n    ...lighting.defaultUniforms,\n    ...prevUniforms,\n    ...getLightSourceUniforms({\n      ambientLight,\n      pointLights,\n      directionalLights\n    })\n  };\n  if (props.enabled !== undefined) {\n    uniforms.enabled = props.enabled ? 1 : 0;\n  }\n  return uniforms;\n}\nfunction getLightSourceUniforms(_ref) {\n  let {\n    ambientLight,\n    pointLights = [],\n    directionalLights = []\n  } = _ref;\n  const lightSourceUniforms = {};\n  lightSourceUniforms.ambientLightColor = convertColor(ambientLight);\n  let currentLight = 0;\n  for (const pointLight of pointLights) {\n    lightSourceUniforms.lightType = LIGHT_TYPE.POINT;\n    const i = currentLight;\n    lightSourceUniforms[`lightColor${i}`] = convertColor(pointLight);\n    lightSourceUniforms[`lightPosition${i}`] = pointLight.position;\n    lightSourceUniforms[`lightAttenuation${i}`] = pointLight.attenuation || [1, 0, 0];\n    currentLight++;\n  }\n  for (const directionalLight of directionalLights) {\n    lightSourceUniforms.lightType = LIGHT_TYPE.DIRECTIONAL;\n    const i = currentLight;\n    lightSourceUniforms[`lightColor${i}`] = convertColor(directionalLight);\n    lightSourceUniforms[`lightDirection${i}`] = directionalLight.direction;\n    currentLight++;\n  }\n  if (currentLight > MAX_LIGHTS) {\n    log.warn('MAX_LIGHTS exceeded')();\n  }\n  lightSourceUniforms.directionalLightCount = directionalLights.length;\n  lightSourceUniforms.pointLightCount = pointLights.length;\n  return lightSourceUniforms;\n}\nfunction extractLightTypes(lights) {\n  const lightSources = {\n    pointLights: [],\n    directionalLights: []\n  };\n  for (const light of lights || []) {\n    switch (light.type) {\n      case 'ambient':\n        // Note: Only uses last ambient light\n        // TODO - add ambient light sources on CPU?\n        lightSources.ambientLight = light;\n        break;\n      case 'directional':\n        lightSources.directionalLights?.push(light);\n        break;\n      case 'point':\n        lightSources.pointLights?.push(light);\n        break;\n      default:\n      // eslint-disable-next-line\n      // console.warn(light.type);\n    }\n  }\n  return lightSources;\n}\n/** Take color 0-255 and intensity as input and output 0.0-1.0 range */\nfunction convertColor() {\n  let colorDef = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    color = [0, 0, 0],\n    intensity = 1.0\n  } = colorDef;\n  return color.map(component => component * intensity / COLOR_FACTOR);\n}\n//# sourceMappingURL=lighting.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}