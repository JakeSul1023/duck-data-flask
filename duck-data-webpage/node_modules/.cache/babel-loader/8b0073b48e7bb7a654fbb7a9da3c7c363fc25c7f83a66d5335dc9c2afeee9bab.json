{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Buffer, ComputePipeline, UniformStore, log, getTypedArrayFromDataType } from '@luma.gl/core';\nimport { ShaderAssembler, getShaderLayoutFromWGSL } from '@luma.gl/shadertools';\nimport { isNumericArray } from '@math.gl/types';\nimport { ShaderInputs } from \"../shader-inputs.js\";\nimport { PipelineFactory } from \"../factories/pipeline-factory.js\";\nimport { ShaderFactory } from \"../factories/shader-factory.js\";\nimport { uid } from \"../utils/uid.js\";\n// import {getDebugTableForShaderLayout} from '../debug/debug-shader-layout';\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n/**\n * v9 Model API\n * A model\n * - automatically reuses pipelines (programs) when possible\n * - automatically rebuilds pipelines if necessary to accommodate changed settings\n * shadertools integration\n * - accepts modules and performs shader transpilation\n */\nexport class Computation {\n  static defaultProps = {\n    ...ComputePipeline.defaultProps,\n    id: 'unnamed',\n    handle: undefined,\n    userData: {},\n    source: '',\n    modules: [],\n    defines: {},\n    bindings: undefined,\n    shaderInputs: undefined,\n    pipelineFactory: undefined,\n    shaderFactory: undefined,\n    shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),\n    debugShaders: undefined\n  };\n  device;\n  id;\n  pipelineFactory;\n  shaderFactory;\n  userData = {};\n  /** Bindings (textures, samplers, uniform buffers) */\n  bindings = {};\n  /** The underlying GPU pipeline. */\n  pipeline;\n  /** Assembled compute shader source */\n  source;\n  /** the underlying compiled compute shader */\n  // @ts-ignore Set in function called from constructor\n  shader;\n  /** ShaderInputs instance */\n  shaderInputs;\n  // @ts-ignore Set in function called from constructor\n  _uniformStore;\n  _pipelineNeedsUpdate = 'newly created';\n  _getModuleUniforms;\n  props;\n  _destroyed = false;\n  constructor(device, props) {\n    if (device.type !== 'webgpu') {\n      throw new Error('Computation is only supported in WebGPU');\n    }\n    this.props = {\n      ...Computation.defaultProps,\n      ...props\n    };\n    props = this.props;\n    this.id = props.id || uid('model');\n    this.device = device;\n    Object.assign(this.userData, props.userData);\n    // Setup shader module inputs\n    const moduleMap = Object.fromEntries(this.props.modules?.map(module => [module.name, module]) || []);\n    // @ts-ignore TODO - fix up typing?\n    this.shaderInputs = props.shaderInputs || new ShaderInputs(moduleMap);\n    this.setShaderInputs(this.shaderInputs);\n    // Support WGSL shader layout introspection\n    // TODO - Don't modify props!!\n    this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.props.source);\n    // Setup shader assembler\n    const platformInfo = getPlatformInfo(device);\n    // Extract modules from shader inputs if not supplied\n    const modules = (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];\n    this.pipelineFactory = props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);\n    this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);\n    const {\n      source,\n      getUniforms\n    } = this.props.shaderAssembler.assembleWGSLShader({\n      platformInfo,\n      ...this.props,\n      modules\n    });\n    this.source = source;\n    // @ts-ignore\n    this._getModuleUniforms = getUniforms;\n    // Create the pipeline\n    // @note order is important\n    this.pipeline = this._updatePipeline();\n    // Apply any dynamic settings that will not trigger pipeline change\n    if (props.bindings) {\n      this.setBindings(props.bindings);\n    }\n    // Catch any access to non-standard props\n    Object.seal(this);\n  }\n  destroy() {\n    if (this._destroyed) return;\n    this.pipelineFactory.release(this.pipeline);\n    this.shaderFactory.release(this.shader);\n    this._uniformStore.destroy();\n    this._destroyed = true;\n  }\n  // Draw call\n  predraw() {\n    // Update uniform buffers if needed\n    this.updateShaderInputs();\n  }\n  dispatch(computePass, x, y, z) {\n    try {\n      this._logDrawCallStart();\n      // Check if the pipeline is invalidated\n      // TODO - this is likely the worst place to do this from performance perspective. Perhaps add a predraw()?\n      this.pipeline = this._updatePipeline();\n      // Set pipeline state, we may be sharing a pipeline so we need to set all state on every draw\n      // Any caching needs to be done inside the pipeline functions\n      this.pipeline.setBindings(this.bindings);\n      computePass.setPipeline(this.pipeline);\n      // @ts-expect-error\n      computePass.setBindings([]);\n      computePass.dispatch(x, y, z);\n    } finally {\n      this._logDrawCallEnd();\n    }\n  }\n  // Update fixed fields (can trigger pipeline rebuild)\n  // Update dynamic fields\n  /**\n   * Updates the vertex count (used in draw calls)\n   * @note Any attributes with stepMode=vertex need to be at least this big\n   */\n  setVertexCount(vertexCount) {\n    // this.vertexCount = vertexCount;\n  }\n  /**\n   * Updates the instance count (used in draw calls)\n   * @note Any attributes with stepMode=instance need to be at least this big\n   */\n  setInstanceCount(instanceCount) {\n    // this.instanceCount = instanceCount;\n  }\n  setShaderInputs(shaderInputs) {\n    this.shaderInputs = shaderInputs;\n    this._uniformStore = new UniformStore(this.shaderInputs.modules);\n    // Create uniform buffer bindings for all modules\n    for (const moduleName of Object.keys(this.shaderInputs.modules)) {\n      const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);\n      this.bindings[`${moduleName}Uniforms`] = uniformBuffer;\n    }\n  }\n  /**\n   * Updates shader module settings (which results in uniforms being set)\n   */\n  setShaderModuleProps(props) {\n    const uniforms = this._getModuleUniforms(props);\n    // Extract textures & framebuffers set by the modules\n    // TODO better way to extract bindings\n    const keys = Object.keys(uniforms).filter(k => {\n      const uniform = uniforms[k];\n      return !isNumericArray(uniform) && typeof uniform !== 'number' && typeof uniform !== 'boolean';\n    });\n    const bindings = {};\n    for (const k of keys) {\n      bindings[k] = uniforms[k];\n      delete uniforms[k];\n    }\n  }\n  updateShaderInputs() {\n    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());\n  }\n  /**\n   * Sets bindings (textures, samplers, uniform buffers)\n   */\n  setBindings(bindings) {\n    Object.assign(this.bindings, bindings);\n  }\n  _setPipelineNeedsUpdate(reason) {\n    this._pipelineNeedsUpdate = this._pipelineNeedsUpdate || reason;\n  }\n  _updatePipeline() {\n    if (this._pipelineNeedsUpdate) {\n      let prevShader = null;\n      if (this.pipeline) {\n        log.log(1, `Model ${this.id}: Recreating pipeline because \"${this._pipelineNeedsUpdate}\".`)();\n        prevShader = this.shader;\n      }\n      this._pipelineNeedsUpdate = false;\n      this.shader = this.shaderFactory.createShader({\n        id: `${this.id}-fragment`,\n        stage: 'compute',\n        source: this.source,\n        debugShaders: this.props.debugShaders\n      });\n      this.pipeline = this.pipelineFactory.createComputePipeline({\n        ...this.props,\n        shader: this.shader\n      });\n      if (prevShader) {\n        this.shaderFactory.release(prevShader);\n      }\n    }\n    return this.pipeline;\n  }\n  /** Throttle draw call logging */\n  _lastLogTime = 0;\n  _logOpen = false;\n  _logDrawCallStart() {\n    // IF level is 4 or higher, log every frame.\n    const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {\n      return;\n    }\n    this._lastLogTime = Date.now();\n    this._logOpen = true;\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {\n      collapsed: log.level <= 2\n    })();\n  }\n  _logDrawCallEnd() {\n    if (this._logOpen) {\n      // const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.props.shaderLayout, this.id);\n      // log.table(logLevel, attributeTable)();\n      // log.table(logLevel, uniformTable)();\n      // log.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();\n      const uniformTable = this.shaderInputs.getDebugTable();\n      log.table(LOG_DRAW_PRIORITY, uniformTable)();\n      log.groupEnd(LOG_DRAW_PRIORITY)();\n      this._logOpen = false;\n    }\n  }\n  _drawCount = 0;\n  // TODO - fix typing of luma data types\n  _getBufferOrConstantValues(attribute, dataType) {\n    const TypedArrayConstructor = getTypedArrayFromDataType(dataType);\n    const typedArray = attribute instanceof Buffer ? new TypedArrayConstructor(attribute.debugData) : attribute;\n    return typedArray.toString();\n  }\n}\n/** Create a shadertools platform info from the Device */\nexport function getPlatformInfo(device) {\n  return {\n    type: device.type,\n    shaderLanguage: device.info.shadingLanguage,\n    shaderLanguageVersion: device.info.shadingLanguageVersion,\n    gpu: device.info.gpu,\n    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API\n    features: device.features\n  };\n}","map":{"version":3,"names":["Buffer","ComputePipeline","UniformStore","log","getTypedArrayFromDataType","ShaderAssembler","getShaderLayoutFromWGSL","isNumericArray","ShaderInputs","PipelineFactory","ShaderFactory","uid","LOG_DRAW_PRIORITY","LOG_DRAW_TIMEOUT","Computation","defaultProps","id","handle","undefined","userData","source","modules","defines","bindings","shaderInputs","pipelineFactory","shaderFactory","shaderAssembler","getDefaultShaderAssembler","debugShaders","device","pipeline","shader","_uniformStore","_pipelineNeedsUpdate","_getModuleUniforms","props","_destroyed","constructor","type","Error","Object","assign","moduleMap","fromEntries","map","module","name","setShaderInputs","shaderLayout","platformInfo","getPlatformInfo","length","getModules","getDefaultPipelineFactory","getDefaultShaderFactory","getUniforms","assembleWGSLShader","_updatePipeline","setBindings","seal","destroy","release","predraw","updateShaderInputs","dispatch","computePass","x","y","z","_logDrawCallStart","setPipeline","_logDrawCallEnd","setVertexCount","vertexCount","setInstanceCount","instanceCount","moduleName","keys","uniformBuffer","getManagedUniformBuffer","setShaderModuleProps","uniforms","filter","k","uniform","setUniforms","getUniformValues","_setPipelineNeedsUpdate","reason","prevShader","createShader","stage","createComputePipeline","_lastLogTime","_logOpen","logDrawTimeout","level","Date","now","group","collapsed","uniformTable","getDebugTable","table","groupEnd","_drawCount","_getBufferOrConstantValues","attribute","dataType","TypedArrayConstructor","typedArray","debugData","toString","shaderLanguage","info","shadingLanguage","shaderLanguageVersion","shadingLanguageVersion","gpu","features"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\engine\\src\\compute\\computation.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {DeviceFeature, ComputePipelineProps, Shader, Binding} from '@luma.gl/core';\nimport {\n  Device,\n  Buffer,\n  ComputePipeline,\n  ComputePass,\n  UniformStore,\n  log,\n  getTypedArrayFromDataType\n} from '@luma.gl/core';\nimport type {ShaderModule, PlatformInfo} from '@luma.gl/shadertools';\nimport {ShaderAssembler, getShaderLayoutFromWGSL} from '@luma.gl/shadertools';\nimport {TypedArray, isNumericArray} from '@math.gl/types';\nimport {ShaderInputs} from '../shader-inputs';\nimport {PipelineFactory} from '../factories/pipeline-factory';\nimport {ShaderFactory} from '../factories/shader-factory';\nimport {uid} from '../utils/uid';\n// import {getDebugTableForShaderLayout} from '../debug/debug-shader-layout';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\nexport type ComputationProps = Omit<ComputePipelineProps, 'shader'> & {\n  source?: string;\n\n  /** shadertool shader modules (added to shader code) */\n  modules?: ShaderModule[];\n  /** Shadertool module defines (configures shader code)*/\n  defines?: Record<string, string | number | boolean>;\n  // TODO - injections, hooks etc?\n\n  /** Shader inputs, used to generated uniform buffers and bindings */\n  shaderInputs?: ShaderInputs;\n\n  /** Bindings */\n  bindings?: Record<string, Binding>;\n\n  /** Show shader source in browser? */\n  debugShaders?: 'never' | 'errors' | 'warnings' | 'always';\n\n  /** Factory used to create a {@link ComputePipeline}. Defaults to {@link Device} default factory. */\n  pipelineFactory?: PipelineFactory;\n  /** Factory used to create a {@link Shader}. Defaults to {@link Device} default factory. */\n  shaderFactory?: ShaderFactory;\n  /** Shader assembler. Defaults to the ShaderAssembler.getShaderAssembler() */\n  shaderAssembler?: ShaderAssembler;\n};\n\n/**\n * v9 Model API\n * A model\n * - automatically reuses pipelines (programs) when possible\n * - automatically rebuilds pipelines if necessary to accommodate changed settings\n * shadertools integration\n * - accepts modules and performs shader transpilation\n */\nexport class Computation {\n  static defaultProps: Required<ComputationProps> = {\n    ...ComputePipeline.defaultProps,\n    id: 'unnamed',\n    handle: undefined,\n    userData: {},\n\n    source: '',\n    modules: [],\n    defines: {},\n\n    bindings: undefined!,\n    shaderInputs: undefined!,\n\n    pipelineFactory: undefined!,\n    shaderFactory: undefined!,\n    shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),\n\n    debugShaders: undefined!\n  };\n\n  readonly device: Device;\n  readonly id: string;\n\n  readonly pipelineFactory: PipelineFactory;\n  readonly shaderFactory: ShaderFactory;\n\n  userData: {[key: string]: any} = {};\n\n  /** Bindings (textures, samplers, uniform buffers) */\n  bindings: Record<string, Binding> = {};\n\n  /** The underlying GPU pipeline. */\n  pipeline: ComputePipeline;\n  /** Assembled compute shader source */\n  source: string;\n  /** the underlying compiled compute shader */\n  // @ts-ignore Set in function called from constructor\n  shader: Shader;\n\n  /** ShaderInputs instance */\n  shaderInputs: ShaderInputs;\n\n  // @ts-ignore Set in function called from constructor\n  _uniformStore: UniformStore;\n\n  _pipelineNeedsUpdate: string | false = 'newly created';\n\n  private _getModuleUniforms: (props?: Record<string, Record<string, any>>) => Record<string, any>;\n  private props: Required<ComputationProps>;\n\n  private _destroyed = false;\n\n  constructor(device: Device, props: ComputationProps) {\n    if (device.type !== 'webgpu') {\n      throw new Error('Computation is only supported in WebGPU');\n    }\n\n    this.props = {...Computation.defaultProps, ...props};\n    props = this.props;\n    this.id = props.id || uid('model');\n    this.device = device;\n\n    Object.assign(this.userData, props.userData);\n\n    // Setup shader module inputs\n    const moduleMap = Object.fromEntries(\n      this.props.modules?.map(module => [module.name, module]) || []\n    );\n    // @ts-ignore TODO - fix up typing?\n    this.shaderInputs = props.shaderInputs || new ShaderInputs(moduleMap);\n    this.setShaderInputs(this.shaderInputs);\n\n    // Support WGSL shader layout introspection\n    // TODO - Don't modify props!!\n    this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.props.source);\n\n    // Setup shader assembler\n    const platformInfo = getPlatformInfo(device);\n\n    // Extract modules from shader inputs if not supplied\n    const modules =\n      (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];\n\n    this.pipelineFactory =\n      props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);\n    this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);\n\n    const {source, getUniforms} = this.props.shaderAssembler.assembleWGSLShader({\n      platformInfo,\n      ...this.props,\n      modules\n    });\n\n    this.source = source;\n    // @ts-ignore\n    this._getModuleUniforms = getUniforms;\n\n    // Create the pipeline\n    // @note order is important\n    this.pipeline = this._updatePipeline();\n\n    // Apply any dynamic settings that will not trigger pipeline change\n    if (props.bindings) {\n      this.setBindings(props.bindings);\n    }\n\n    // Catch any access to non-standard props\n    Object.seal(this);\n  }\n\n  destroy(): void {\n    if (this._destroyed) return;\n    this.pipelineFactory.release(this.pipeline);\n    this.shaderFactory.release(this.shader);\n    this._uniformStore.destroy();\n    this._destroyed = true;\n  }\n\n  // Draw call\n\n  predraw() {\n    // Update uniform buffers if needed\n    this.updateShaderInputs();\n  }\n\n  dispatch(computePass: ComputePass, x: number, y?: number, z?: number): void {\n    try {\n      this._logDrawCallStart();\n\n      // Check if the pipeline is invalidated\n      // TODO - this is likely the worst place to do this from performance perspective. Perhaps add a predraw()?\n      this.pipeline = this._updatePipeline();\n\n      // Set pipeline state, we may be sharing a pipeline so we need to set all state on every draw\n      // Any caching needs to be done inside the pipeline functions\n      this.pipeline.setBindings(this.bindings);\n      computePass.setPipeline(this.pipeline);\n      // @ts-expect-error\n      computePass.setBindings([]);\n\n      computePass.dispatch(x, y, z);\n    } finally {\n      this._logDrawCallEnd();\n    }\n  }\n\n  // Update fixed fields (can trigger pipeline rebuild)\n\n  // Update dynamic fields\n\n  /**\n   * Updates the vertex count (used in draw calls)\n   * @note Any attributes with stepMode=vertex need to be at least this big\n   */\n  setVertexCount(vertexCount: number): void {\n    // this.vertexCount = vertexCount;\n  }\n\n  /**\n   * Updates the instance count (used in draw calls)\n   * @note Any attributes with stepMode=instance need to be at least this big\n   */\n  setInstanceCount(instanceCount: number): void {\n    // this.instanceCount = instanceCount;\n  }\n\n  setShaderInputs(shaderInputs: ShaderInputs): void {\n    this.shaderInputs = shaderInputs;\n    this._uniformStore = new UniformStore(this.shaderInputs.modules);\n    // Create uniform buffer bindings for all modules\n    for (const moduleName of Object.keys(this.shaderInputs.modules)) {\n      const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);\n      this.bindings[`${moduleName}Uniforms`] = uniformBuffer;\n    }\n  }\n\n  /**\n   * Updates shader module settings (which results in uniforms being set)\n   */\n  setShaderModuleProps(props: Record<string, any>): void {\n    const uniforms = this._getModuleUniforms(props);\n\n    // Extract textures & framebuffers set by the modules\n    // TODO better way to extract bindings\n    const keys = Object.keys(uniforms).filter(k => {\n      const uniform = uniforms[k];\n      return (\n        !isNumericArray(uniform) && typeof uniform !== 'number' && typeof uniform !== 'boolean'\n      );\n    });\n    const bindings: Record<string, Binding> = {};\n    for (const k of keys) {\n      bindings[k] = uniforms[k];\n      delete uniforms[k];\n    }\n  }\n\n  updateShaderInputs(): void {\n    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());\n  }\n\n  /**\n   * Sets bindings (textures, samplers, uniform buffers)\n   */\n  setBindings(bindings: Record<string, Binding>): void {\n    Object.assign(this.bindings, bindings);\n  }\n\n  _setPipelineNeedsUpdate(reason: string): void {\n    this._pipelineNeedsUpdate = this._pipelineNeedsUpdate || reason;\n  }\n\n  _updatePipeline(): ComputePipeline {\n    if (this._pipelineNeedsUpdate) {\n      let prevShader: Shader | null = null;\n      if (this.pipeline) {\n        log.log(\n          1,\n          `Model ${this.id}: Recreating pipeline because \"${this._pipelineNeedsUpdate}\".`\n        )();\n        prevShader = this.shader;\n      }\n\n      this._pipelineNeedsUpdate = false;\n\n      this.shader = this.shaderFactory.createShader({\n        id: `${this.id}-fragment`,\n        stage: 'compute',\n        source: this.source,\n        debugShaders: this.props.debugShaders\n      });\n\n      this.pipeline = this.pipelineFactory.createComputePipeline({\n        ...this.props,\n        shader: this.shader\n      });\n\n      if (prevShader) {\n        this.shaderFactory.release(prevShader);\n      }\n    }\n    return this.pipeline;\n  }\n\n  /** Throttle draw call logging */\n  _lastLogTime = 0;\n  _logOpen = false;\n\n  _logDrawCallStart(): void {\n    // IF level is 4 or higher, log every frame.\n    const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {\n      return;\n    }\n\n    this._lastLogTime = Date.now();\n    this._logOpen = true;\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.level <= 2})();\n  }\n\n  _logDrawCallEnd(): void {\n    if (this._logOpen) {\n      // const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.props.shaderLayout, this.id);\n\n      // log.table(logLevel, attributeTable)();\n      // log.table(logLevel, uniformTable)();\n      // log.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();\n\n      const uniformTable = this.shaderInputs.getDebugTable();\n      log.table(LOG_DRAW_PRIORITY, uniformTable)();\n\n      log.groupEnd(LOG_DRAW_PRIORITY)();\n      this._logOpen = false;\n    }\n  }\n\n  protected _drawCount = 0;\n\n  // TODO - fix typing of luma data types\n  _getBufferOrConstantValues(attribute: Buffer | TypedArray, dataType: any): string {\n    const TypedArrayConstructor = getTypedArrayFromDataType(dataType);\n    const typedArray =\n      attribute instanceof Buffer ? new TypedArrayConstructor(attribute.debugData) : attribute;\n    return typedArray.toString();\n  }\n}\n\n/** Create a shadertools platform info from the Device */\nexport function getPlatformInfo(device: Device): PlatformInfo {\n  return {\n    type: device.type,\n    shaderLanguage: device.info.shadingLanguage,\n    shaderLanguageVersion: device.info.shadingLanguageVersion as 100 | 300,\n    gpu: device.info.gpu,\n    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API\n    features: device.features as unknown as Set<DeviceFeature>\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}