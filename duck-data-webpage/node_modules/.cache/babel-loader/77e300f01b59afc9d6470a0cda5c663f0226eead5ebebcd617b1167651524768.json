{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Texture, log } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\nimport { getTextureFormatWebGL } from \"../converters/webgl-texture-table.js\";\nimport { convertSamplerParametersToWebGL } from \"../converters/sampler-parameters.js\";\nimport { WEBGLSampler } from \"./webgl-sampler.js\";\nimport { WEBGLTextureView } from \"./webgl-texture-view.js\";\nimport { initializeTextureStorage,\n// clearMipLevel,\ncopyExternalImageToMipLevel, copyCPUDataToMipLevel,\n// copyGPUBufferToMipLevel,\ngetWebGLTextureTarget } from \"../helpers/webgl-texture-utils.js\";\n/**\n * WebGL... the texture API from hell... hopefully made simpler\n */\nexport class WEBGLTexture extends Texture {\n  // readonly MAX_ATTRIBUTES: number;\n  device;\n  gl;\n  handle;\n  sampler = undefined; // TODO - currently unused in WebGL. Create dummy sampler?\n  view = undefined; // TODO - currently unused in WebGL. Create dummy view?\n  mipmaps;\n  // Texture type\n  /** Whether the internal format is compressed */\n  compressed;\n  /**\n   * The WebGL target corresponding to the texture type\n   * @note `target` cannot be modified by bind:\n   * textures are special because when you first bind them to a target,\n   * When you first bind a texture as a GL_TEXTURE_2D, you are saying that this texture is a 2D texture.\n   * And it will always be a 2D texture; this state cannot be changed ever.\n   * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;\n   * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error\n   */\n  glTarget;\n  /** The WebGL format - essentially channel structure */\n  glFormat;\n  /** The WebGL data format - the type of each channel */\n  glType;\n  /** The WebGL constant corresponding to the WebGPU style constant in format */\n  glInternalFormat;\n  // state\n  /** Texture binding slot - TODO - move to texture view? */\n  textureUnit = 0;\n  constructor(device, props) {\n    super(device, props);\n    // Texture base class strips out the data prop, so we need to add it back in\n    const propsWithData = {\n      ...this.props\n    };\n    propsWithData.data = props.data;\n    this.device = device;\n    this.gl = this.device.gl;\n    // Note: In WebGL the texture target defines the type of texture on first bind.\n    this.glTarget = getWebGLTextureTarget(this.props.dimension);\n    // The target format of this texture\n    const formatInfo = getTextureFormatWebGL(this.props.format);\n    this.glInternalFormat = formatInfo.internalFormat;\n    this.glFormat = formatInfo.format;\n    this.glType = formatInfo.type;\n    this.compressed = formatInfo.compressed;\n    this.mipmaps = Boolean(this.props.mipmaps);\n    this._initialize(propsWithData);\n    Object.seal(this);\n  }\n  /** Initialize texture with supplied props */\n  // eslint-disable-next-line max-statements\n  _initialize(propsWithData) {\n    this.handle = this.props.handle || this.gl.createTexture();\n    this.device.setSpectorMetadata(this.handle, {\n      ...this.props,\n      data: propsWithData.data\n    });\n    let {\n      width,\n      height\n    } = propsWithData;\n    if (!width || !height) {\n      const textureSize = Texture.getTextureDataSize(propsWithData.data);\n      width = textureSize?.width || 1;\n      height = textureSize?.height || 1;\n    }\n    // Store opts for accessors\n    this.width = width;\n    this.height = height;\n    this.depth = propsWithData.depth;\n    // Set texture sampler parameters\n    this.setSampler(propsWithData.sampler);\n    // @ts-ignore TODO - fix types\n    this.view = new WEBGLTextureView(this.device, {\n      ...this.props,\n      texture: this\n    });\n    this.bind();\n    initializeTextureStorage(this.gl, this.mipLevels, this);\n    if (propsWithData.data) {\n      // prettier-ignore\n      switch (propsWithData.dimension) {\n        case '1d':\n          this.setTexture1DData(propsWithData.data);\n          break;\n        case '2d':\n          this.setTexture2DData(propsWithData.data);\n          break;\n        case '3d':\n          this.setTexture3DData(propsWithData.data);\n          break;\n        case 'cube':\n          this.setTextureCubeData(propsWithData.data);\n          break;\n        case '2d-array':\n          this.setTextureArrayData(propsWithData.data);\n          break;\n        case 'cube-array':\n          this.setTextureCubeArrayData(propsWithData.data);\n          break;\n        // @ts-expect-error\n        default:\n          throw new Error(propsWithData.dimension);\n      }\n    }\n    if (this.mipmaps) {\n      this.generateMipmap();\n    }\n  }\n  destroy() {\n    if (this.handle) {\n      this.gl.deleteTexture(this.handle);\n      this.removeStats();\n      this.trackDeallocatedMemory('Texture');\n      // this.handle = null;\n      this.destroyed = true;\n    }\n  }\n  createView(props) {\n    return new WEBGLTextureView(this.device, {\n      ...props,\n      texture: this\n    });\n  }\n  setSampler(sampler = {}) {\n    let samplerProps;\n    if (sampler instanceof WEBGLSampler) {\n      this.sampler = sampler;\n      samplerProps = sampler.props;\n    } else {\n      this.sampler = new WEBGLSampler(this.device, sampler);\n      samplerProps = sampler;\n    }\n    const parameters = convertSamplerParametersToWebGL(samplerProps);\n    this._setSamplerParameters(parameters);\n  }\n  // Call to regenerate mipmaps after modifying texture(s)\n  generateMipmap(options) {\n    const isFilterableAndRenderable = this.device.isTextureFormatRenderable(this.props.format) && this.device.isTextureFormatFilterable(this.props.format);\n    if (!isFilterableAndRenderable) {\n      log.warn(`${this} is not renderable or filterable, may not be able to generate mipmaps`)();\n      if (!options?.force) {\n        return;\n      }\n    }\n    try {\n      this.gl.bindTexture(this.glTarget, this.handle);\n      this.gl.generateMipmap(this.glTarget);\n    } catch (error) {\n      log.warn(`Error generating mipmap for ${this}: ${error.message}`)();\n    } finally {\n      this.gl.bindTexture(this.glTarget, null);\n    }\n  }\n  // Image Data Setters\n  copyExternalImage(options) {\n    const size = Texture.getExternalImageSize(options.image);\n    const opts = {\n      ...Texture.defaultCopyExternalImageOptions,\n      ...size,\n      ...options\n    };\n    const {\n      image,\n      depth,\n      mipLevel,\n      x,\n      y,\n      z,\n      flipY\n    } = opts;\n    let {\n      width,\n      height\n    } = opts;\n    const {\n      dimension,\n      glTarget,\n      glFormat,\n      glInternalFormat,\n      glType\n    } = this;\n    // WebGL will error if we try to copy outside the bounds of the texture\n    width = Math.min(width, this.width - x);\n    height = Math.min(height, this.height - y);\n    if (options.sourceX || options.sourceY) {\n      // requires copyTexSubImage2D from a framebuffer'\n      throw new Error('WebGL does not support sourceX/sourceY)');\n    }\n    copyExternalImageToMipLevel(this.device.gl, this.handle, image, {\n      dimension,\n      mipLevel,\n      x,\n      y,\n      z,\n      width,\n      height,\n      depth,\n      glFormat,\n      glInternalFormat,\n      glType,\n      glTarget,\n      flipY\n    });\n    return {\n      width: opts.width,\n      height: opts.height\n    };\n  }\n  setTexture1DData(data) {\n    throw new Error('setTexture1DData not supported in WebGL.');\n  }\n  /** Set a simple texture */\n  setTexture2DData(lodData, depth = 0) {\n    this.bind();\n    const lodArray = Texture.normalizeTextureData(lodData, this);\n    // If the user provides multiple LODs, then automatic mipmap\n    // generation generateMipmap() should be disabled to avoid overwriting them.\n    if (lodArray.length > 1 && this.props.mipmaps !== false) {\n      log.warn(`Texture ${this.id} mipmap and multiple LODs.`)();\n    }\n    for (let lodLevel = 0; lodLevel < lodArray.length; lodLevel++) {\n      const imageData = lodArray[lodLevel];\n      this._setMipLevel(depth, lodLevel, imageData);\n    }\n    this.unbind();\n  }\n  /**\n   * Sets a 3D texture\n   * @param data\n   */\n  setTexture3DData(data) {\n    if (this.props.dimension !== '3d') {\n      throw new Error(this.id);\n    }\n    if (ArrayBuffer.isView(data)) {\n      this.bind();\n      copyCPUDataToMipLevel(this.device.gl, data, this);\n      this.unbind();\n    }\n  }\n  /**\n   * Set a Texture Cube Data\n   * @todo - could support TextureCubeArray with depth\n   * @param data\n   * @param index\n   */\n  setTextureCubeData(data, depth = 0) {\n    if (this.props.dimension !== 'cube') {\n      throw new Error(this.id);\n    }\n    for (const face of Texture.CubeFaces) {\n      this.setTextureCubeFaceData(data[face], face);\n    }\n  }\n  /**\n   * Sets an entire texture array\n   * @param data\n   */\n  setTextureArrayData(data) {\n    if (this.props.dimension !== '2d-array') {\n      throw new Error(this.id);\n    }\n    throw new Error('setTextureArrayData not implemented.');\n  }\n  /**\n   * Sets an entire texture cube array\n   * @param data\n   */\n  setTextureCubeArrayData(data) {\n    throw new Error('setTextureCubeArrayData not supported in WebGL2.');\n  }\n  setTextureCubeFaceData(lodData, face, depth = 0) {\n    // assert(this.props.dimension === 'cube');\n    // If the user provides multiple LODs, then automatic mipmap\n    // generation generateMipmap() should be disabled to avoid overwriting them.\n    if (Array.isArray(lodData) && lodData.length > 1 && this.props.mipmaps !== false) {\n      log.warn(`${this.id} has mipmap and multiple LODs.`)();\n    }\n    const faceDepth = Texture.CubeFaces.indexOf(face);\n    this.setTexture2DData(lodData, faceDepth);\n  }\n  // DEPRECATED METHODS\n  /** Update external texture (video frame or canvas) @deprecated Use ExternalTexture */\n  update() {\n    throw new Error('Texture.update() not implemented. Use ExternalTexture');\n  }\n  // INTERNAL METHODS\n  /** @todo update this method to accept LODs */\n  setImageDataForFace(options) {\n    const {\n      face,\n      width,\n      height,\n      pixels,\n      data,\n      format = 6408,\n      type = 5121\n      // generateMipmap = false // TODO\n    } = options;\n    const {\n      gl\n    } = this;\n    const imageData = pixels || data;\n    this.bind();\n    if (imageData instanceof Promise) {\n      imageData.then(resolvedImageData => this.setImageDataForFace(Object.assign({}, options, {\n        face,\n        data: resolvedImageData,\n        pixels: resolvedImageData\n      })));\n    } else if (this.width || this.height) {\n      gl.texImage2D(face, 0, format, width, height, 0 /* border*/, format, type, imageData);\n    } else {\n      gl.texImage2D(face, 0, format, format, type, imageData);\n    }\n  }\n  _getImageDataMap(faceData) {\n    for (let i = 0; i < Texture.CubeFaces.length; ++i) {\n      const faceName = Texture.CubeFaces[i];\n      if (faceData[faceName]) {\n        faceData[34069 + i] = faceData[faceName];\n        delete faceData[faceName];\n      }\n    }\n    return faceData;\n  }\n  // RESOURCE METHODS\n  /**\n   * Sets sampler parameters on texture\n   */\n  _setSamplerParameters(parameters) {\n    log.log(1, `${this.id} sampler parameters`, this.device.getGLKeys(parameters))();\n    this.gl.bindTexture(this.glTarget, this.handle);\n    for (const [pname, pvalue] of Object.entries(parameters)) {\n      const param = Number(pname);\n      const value = pvalue;\n      // Apparently integer/float issues require two different texture parameter setting functions in JavaScript.\n      // For now, pick the float version for parameters specified as GLfloat.\n      switch (param) {\n        case 33082:\n        case 33083:\n          this.gl.texParameterf(this.glTarget, param, value);\n          break;\n        case 10241:\n          this.gl.texParameteri(this.glTarget, param, value);\n          break;\n        case 10242:\n        case 10243:\n          this.gl.texParameteri(this.glTarget, param, value);\n          break;\n        case 34046:\n          // We have to query feature before using it\n          if (this.device.features.has('texture-filterable-anisotropic-webgl')) {\n            this.gl.texParameteri(this.glTarget, param, value);\n          }\n          break;\n        default:\n          this.gl.texParameteri(this.glTarget, param, value);\n          break;\n      }\n    }\n    this.gl.bindTexture(this.glTarget, null);\n  }\n  // INTERNAL SETTERS\n  /**\n   * Copy a region of data from a CPU memory buffer into this texture.\n   * @todo -   GLUnpackParameters parameters\n   */\n  _setMipLevel(depth, mipLevel, textureData, glTarget = this.glTarget) {\n    // if (!textureData) {\n    //   clearMipLevel(this.device.gl, {...this, depth, level});\n    //   return;\n    // }\n    if (Texture.isExternalImage(textureData)) {\n      copyExternalImageToMipLevel(this.device.gl, this.handle, textureData, {\n        ...this,\n        depth,\n        mipLevel,\n        glTarget,\n        flipY: this.props.flipY\n      });\n      return;\n    }\n    // @ts-expect-error\n    if (Texture.isTextureLevelData(textureData)) {\n      copyCPUDataToMipLevel(this.device.gl, textureData.data, {\n        ...this,\n        depth,\n        mipLevel,\n        glTarget\n      });\n      return;\n    }\n    throw new Error('Texture: invalid image data');\n  }\n  // HELPERS\n  getActiveUnit() {\n    return this.gl.getParameter(34016) - 33984;\n  }\n  bind(textureUnit) {\n    const {\n      gl\n    } = this;\n    if (textureUnit !== undefined) {\n      this.textureUnit = textureUnit;\n      gl.activeTexture(33984 + textureUnit);\n    }\n    gl.bindTexture(this.glTarget, this.handle);\n    return textureUnit;\n  }\n  unbind(textureUnit) {\n    const {\n      gl\n    } = this;\n    if (textureUnit !== undefined) {\n      this.textureUnit = textureUnit;\n      gl.activeTexture(33984 + textureUnit);\n    }\n    gl.bindTexture(this.glTarget, null);\n    return textureUnit;\n  }\n}\n// TODO - Remove when texture refactor is complete\n/*\nsetCubeMapData(options: {\n  width: number;\n  height: number;\n  data: Record<GL, Texture2DData> | Record<TextureCubeFace, Texture2DData>;\n  format?: any;\n  type?: any;\n  /** @deprecated Use .data *\n  pixels: any;\n}): void {\n  const {gl} = this;\n\n  const {width, height, pixels, data, format = GL.RGBA, type = GL.UNSIGNED_BYTE} = options;\n\n  // pixel data (imageDataMap) is an Object from Face to Image or Promise.\n  // For example:\n  // {\n  // GL.TEXTURE_CUBE_MAP_POSITIVE_X : Image-or-Promise,\n  // GL.TEXTURE_CUBE_MAP_NEGATIVE_X : Image-or-Promise,\n  // ... }\n  // To provide multiple level-of-details (LODs) this can be Face to Array\n  // of Image or Promise, like this\n  // {\n  // GL.TEXTURE_CUBE_MAP_POSITIVE_X : [Image-or-Promise-LOD-0, Image-or-Promise-LOD-1],\n  // GL.TEXTURE_CUBE_MAP_NEGATIVE_X : [Image-or-Promise-LOD-0, Image-or-Promise-LOD-1],\n  // ... }\n\n  const imageDataMap = this._getImageDataMap(pixels || data);\n\n  const resolvedFaces = WEBGLTexture.FACES.map(face => {\n    const facePixels = imageDataMap[face];\n    return Array.isArray(facePixels) ? facePixels : [facePixels];\n  });\n  this.bind();\n\n  WEBGLTexture.FACES.forEach((face, index) => {\n    if (resolvedFaces[index].length > 1 && this.props.mipmaps !== false) {\n      // If the user provides multiple LODs, then automatic mipmap\n      // generation generateMipmap() should be disabled to avoid overwritting them.\n      log.warn(`${this.id} has mipmap and multiple LODs.`)();\n    }\n    resolvedFaces[index].forEach((image, lodLevel) => {\n      // TODO: adjust width & height for LOD!\n      if (width && height) {\n        gl.texImage2D(face, lodLevel, format, width, height, 0 /* border*, format, type, image);\n      } else {\n        gl.texImage2D(face, lodLevel, format, format, type, image);\n      }\n    });\n  });\n\n  this.unbind();\n}\n*/","map":{"version":3,"names":["Texture","log","GL","getTextureFormatWebGL","convertSamplerParametersToWebGL","WEBGLSampler","WEBGLTextureView","initializeTextureStorage","copyExternalImageToMipLevel","copyCPUDataToMipLevel","getWebGLTextureTarget","WEBGLTexture","device","gl","handle","sampler","undefined","view","mipmaps","compressed","glTarget","glFormat","glType","glInternalFormat","textureUnit","constructor","props","propsWithData","data","dimension","formatInfo","format","internalFormat","type","Boolean","_initialize","Object","seal","createTexture","setSpectorMetadata","width","height","textureSize","getTextureDataSize","depth","setSampler","texture","bind","mipLevels","setTexture1DData","setTexture2DData","setTexture3DData","setTextureCubeData","setTextureArrayData","setTextureCubeArrayData","Error","generateMipmap","destroy","deleteTexture","removeStats","trackDeallocatedMemory","destroyed","createView","samplerProps","parameters","_setSamplerParameters","options","isFilterableAndRenderable","isTextureFormatRenderable","isTextureFormatFilterable","warn","force","bindTexture","error","message","copyExternalImage","size","getExternalImageSize","image","opts","defaultCopyExternalImageOptions","mipLevel","x","y","z","flipY","Math","min","sourceX","sourceY","lodData","lodArray","normalizeTextureData","length","id","lodLevel","imageData","_setMipLevel","unbind","ArrayBuffer","isView","face","CubeFaces","setTextureCubeFaceData","Array","isArray","faceDepth","indexOf","update","setImageDataForFace","pixels","Promise","then","resolvedImageData","assign","texImage2D","_getImageDataMap","faceData","i","faceName","getGLKeys","pname","pvalue","entries","param","Number","value","texParameterf","texParameteri","features","has","textureData","isExternalImage","isTextureLevelData","getActiveUnit","getParameter","activeTexture"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\webgl\\src\\adapter\\resources\\webgl-texture.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {\n  Device,\n  TextureProps,\n  TextureViewProps,\n  Sampler,\n  SamplerProps,\n  SamplerParameters,\n  TextureCubeFace,\n  ExternalImage,\n  Texture1DData,\n  Texture2DData,\n  Texture3DData,\n  TextureCubeData,\n  TextureArrayData,\n  TextureCubeArrayData\n} from '@luma.gl/core';\nimport {Texture, log} from '@luma.gl/core';\nimport {\n  GL,\n  GLPixelType,\n  GLSamplerParameters,\n  GLTexelDataFormat,\n  GLTextureTarget\n} from '@luma.gl/constants';\nimport {getTextureFormatWebGL} from '../converters/webgl-texture-table';\nimport {convertSamplerParametersToWebGL} from '../converters/sampler-parameters';\nimport {WebGLDevice} from '../webgl-device';\nimport {WEBGLSampler} from './webgl-sampler';\nimport {WEBGLTextureView} from './webgl-texture-view';\n\nimport {\n  initializeTextureStorage,\n  // clearMipLevel,\n  copyExternalImageToMipLevel,\n  copyCPUDataToMipLevel,\n  // copyGPUBufferToMipLevel,\n  getWebGLTextureTarget\n} from '../helpers/webgl-texture-utils';\n\n/**\n * WebGL... the texture API from hell... hopefully made simpler\n */\nexport class WEBGLTexture extends Texture {\n  // readonly MAX_ATTRIBUTES: number;\n  readonly device: WebGLDevice;\n  readonly gl: WebGL2RenderingContext;\n  handle: WebGLTexture;\n\n  sampler: WEBGLSampler = undefined; // TODO - currently unused in WebGL. Create dummy sampler?\n  view: WEBGLTextureView = undefined; // TODO - currently unused in WebGL. Create dummy view?\n\n  mipmaps: boolean;\n\n  // Texture type\n  /** Whether the internal format is compressed */\n  compressed: boolean;\n\n  /**\n   * The WebGL target corresponding to the texture type\n   * @note `target` cannot be modified by bind:\n   * textures are special because when you first bind them to a target,\n   * When you first bind a texture as a GL_TEXTURE_2D, you are saying that this texture is a 2D texture.\n   * And it will always be a 2D texture; this state cannot be changed ever.\n   * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;\n   * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error\n   */\n  glTarget: GLTextureTarget;\n  /** The WebGL format - essentially channel structure */\n  glFormat: GLTexelDataFormat;\n  /** The WebGL data format - the type of each channel */\n  glType: GLPixelType;\n  /** The WebGL constant corresponding to the WebGPU style constant in format */\n  glInternalFormat: GL;\n\n  // state\n  /** Texture binding slot - TODO - move to texture view? */\n  textureUnit: number = 0;\n\n  constructor(device: Device, props: TextureProps) {\n    super(device, props);\n\n    // Texture base class strips out the data prop, so we need to add it back in\n    const propsWithData = {...this.props};\n    propsWithData.data = props.data;\n\n    this.device = device as WebGLDevice;\n    this.gl = this.device.gl;\n\n    // Note: In WebGL the texture target defines the type of texture on first bind.\n    this.glTarget = getWebGLTextureTarget(this.props.dimension);\n\n    // The target format of this texture\n    const formatInfo = getTextureFormatWebGL(this.props.format);\n    this.glInternalFormat = formatInfo.internalFormat;\n    this.glFormat = formatInfo.format;\n    this.glType = formatInfo.type;\n    this.compressed = formatInfo.compressed;\n    this.mipmaps = Boolean(this.props.mipmaps);\n\n    this._initialize(propsWithData);\n\n    Object.seal(this);\n  }\n\n  /** Initialize texture with supplied props */\n  // eslint-disable-next-line max-statements\n  _initialize(propsWithData: TextureProps): void {\n    this.handle = this.props.handle || this.gl.createTexture();\n    this.device.setSpectorMetadata(this.handle, {...this.props, data: propsWithData.data});\n\n    let {width, height} = propsWithData;\n\n    if (!width || !height) {\n      const textureSize = Texture.getTextureDataSize(propsWithData.data);\n      width = textureSize?.width || 1;\n      height = textureSize?.height || 1;\n    }\n\n    // Store opts for accessors\n    this.width = width;\n    this.height = height;\n    this.depth = propsWithData.depth;\n\n    // Set texture sampler parameters\n    this.setSampler(propsWithData.sampler);\n    // @ts-ignore TODO - fix types\n    this.view = new WEBGLTextureView(this.device, {...this.props, texture: this});\n\n    this.bind();\n    initializeTextureStorage(this.gl, this.mipLevels, this);\n\n    if (propsWithData.data) {\n      // prettier-ignore\n      switch (propsWithData.dimension) {\n        case '1d': this.setTexture1DData(propsWithData.data); break;\n        case '2d': this.setTexture2DData(propsWithData.data); break;\n        case '3d': this.setTexture3DData(propsWithData.data); break;\n        case 'cube': this.setTextureCubeData(propsWithData.data); break;\n        case '2d-array': this.setTextureArrayData(propsWithData.data); break;\n        case 'cube-array': this.setTextureCubeArrayData(propsWithData.data); break;\n        // @ts-expect-error\n        default: throw new Error(propsWithData.dimension);\n      }\n    }\n\n    if (this.mipmaps) {\n      this.generateMipmap();\n    }\n  }\n\n  override destroy(): void {\n    if (this.handle) {\n      this.gl.deleteTexture(this.handle);\n      this.removeStats();\n      this.trackDeallocatedMemory('Texture');\n      // this.handle = null;\n      this.destroyed = true;\n    }\n  }\n\n  createView(props: TextureViewProps): WEBGLTextureView {\n    return new WEBGLTextureView(this.device, {...props, texture: this});\n  }\n\n  setSampler(sampler: Sampler | SamplerProps = {}): void {\n    let samplerProps: SamplerParameters;\n    if (sampler instanceof WEBGLSampler) {\n      this.sampler = sampler;\n      samplerProps = sampler.props;\n    } else {\n      this.sampler = new WEBGLSampler(this.device, sampler);\n      samplerProps = sampler as SamplerProps;\n    }\n\n    const parameters = convertSamplerParametersToWebGL(samplerProps);\n    this._setSamplerParameters(parameters);\n  }\n\n  // Call to regenerate mipmaps after modifying texture(s)\n  generateMipmap(options?: {force?: boolean}): void {\n    const isFilterableAndRenderable =\n      this.device.isTextureFormatRenderable(this.props.format) &&\n      this.device.isTextureFormatFilterable(this.props.format);\n    if (!isFilterableAndRenderable) {\n      log.warn(`${this} is not renderable or filterable, may not be able to generate mipmaps`)();\n      if (!options?.force) {\n        return;\n      }\n    }\n\n    try {\n      this.gl.bindTexture(this.glTarget, this.handle);\n      this.gl.generateMipmap(this.glTarget);\n    } catch (error) {\n      log.warn(`Error generating mipmap for ${this}: ${(error as Error).message}`)();\n    } finally {\n      this.gl.bindTexture(this.glTarget, null);\n    }\n  }\n\n  // Image Data Setters\n  copyExternalImage(options: {\n    image: ExternalImage;\n    sourceX?: number;\n    sourceY?: number;\n    width?: number;\n    height?: number;\n    depth?: number;\n    mipLevel?: number;\n    x?: number;\n    y?: number;\n    z?: number;\n    aspect?: 'all' | 'stencil-only' | 'depth-only';\n    colorSpace?: 'srgb';\n    premultipliedAlpha?: boolean;\n    flipY?: boolean;\n  }): {width: number; height: number} {\n    const size = Texture.getExternalImageSize(options.image);\n    const opts = {...Texture.defaultCopyExternalImageOptions, ...size, ...options};\n\n    const {image, depth, mipLevel, x, y, z, flipY} = opts;\n    let {width, height} = opts;\n    const {dimension, glTarget, glFormat, glInternalFormat, glType} = this;\n\n    // WebGL will error if we try to copy outside the bounds of the texture\n    width = Math.min(width, this.width - x);\n    height = Math.min(height, this.height - y);\n\n    if (options.sourceX || options.sourceY) {\n      // requires copyTexSubImage2D from a framebuffer'\n      throw new Error('WebGL does not support sourceX/sourceY)');\n    }\n\n    copyExternalImageToMipLevel(this.device.gl, this.handle, image, {\n      dimension,\n      mipLevel,\n      x,\n      y,\n      z,\n      width,\n      height,\n      depth,\n      glFormat,\n      glInternalFormat,\n      glType,\n      glTarget,\n      flipY\n    });\n\n    return {width: opts.width, height: opts.height};\n  }\n\n  setTexture1DData(data: Texture1DData): void {\n    throw new Error('setTexture1DData not supported in WebGL.');\n  }\n\n  /** Set a simple texture */\n  setTexture2DData(lodData: Texture2DData, depth = 0): void {\n    this.bind();\n\n    const lodArray = Texture.normalizeTextureData(lodData, this);\n\n    // If the user provides multiple LODs, then automatic mipmap\n    // generation generateMipmap() should be disabled to avoid overwriting them.\n    if (lodArray.length > 1 && this.props.mipmaps !== false) {\n      log.warn(`Texture ${this.id} mipmap and multiple LODs.`)();\n    }\n\n    for (let lodLevel = 0; lodLevel < lodArray.length; lodLevel++) {\n      const imageData = lodArray[lodLevel];\n      this._setMipLevel(depth, lodLevel, imageData);\n    }\n\n    this.unbind();\n  }\n\n  /**\n   * Sets a 3D texture\n   * @param data\n   */\n  setTexture3DData(data: Texture3DData): void {\n    if (this.props.dimension !== '3d') {\n      throw new Error(this.id);\n    }\n    if (ArrayBuffer.isView(data)) {\n      this.bind();\n      copyCPUDataToMipLevel(this.device.gl, data, this);\n      this.unbind();\n    }\n  }\n\n  /**\n   * Set a Texture Cube Data\n   * @todo - could support TextureCubeArray with depth\n   * @param data\n   * @param index\n   */\n  setTextureCubeData(data: TextureCubeData, depth: number = 0): void {\n    if (this.props.dimension !== 'cube') {\n      throw new Error(this.id);\n    }\n    for (const face of Texture.CubeFaces) {\n      this.setTextureCubeFaceData(data[face], face);\n    }\n  }\n\n  /**\n   * Sets an entire texture array\n   * @param data\n   */\n  setTextureArrayData(data: TextureArrayData): void {\n    if (this.props.dimension !== '2d-array') {\n      throw new Error(this.id);\n    }\n    throw new Error('setTextureArrayData not implemented.');\n  }\n\n  /**\n   * Sets an entire texture cube array\n   * @param data\n   */\n  setTextureCubeArrayData(data: TextureCubeArrayData): void {\n    throw new Error('setTextureCubeArrayData not supported in WebGL2.');\n  }\n\n  setTextureCubeFaceData(lodData: Texture2DData, face: TextureCubeFace, depth: number = 0): void {\n    // assert(this.props.dimension === 'cube');\n\n    // If the user provides multiple LODs, then automatic mipmap\n    // generation generateMipmap() should be disabled to avoid overwriting them.\n    if (Array.isArray(lodData) && lodData.length > 1 && this.props.mipmaps !== false) {\n      log.warn(`${this.id} has mipmap and multiple LODs.`)();\n    }\n\n    const faceDepth = Texture.CubeFaces.indexOf(face);\n\n    this.setTexture2DData(lodData, faceDepth);\n  }\n\n  // DEPRECATED METHODS\n\n  /** Update external texture (video frame or canvas) @deprecated Use ExternalTexture */\n  update(): void {\n    throw new Error('Texture.update() not implemented. Use ExternalTexture');\n  }\n\n  // INTERNAL METHODS\n\n  /** @todo update this method to accept LODs */\n  setImageDataForFace(options): void {\n    const {\n      face,\n      width,\n      height,\n      pixels,\n      data,\n      format = GL.RGBA,\n      type = GL.UNSIGNED_BYTE\n      // generateMipmap = false // TODO\n    } = options;\n\n    const {gl} = this;\n\n    const imageData = pixels || data;\n\n    this.bind();\n    if (imageData instanceof Promise) {\n      imageData.then(resolvedImageData =>\n        this.setImageDataForFace(\n          Object.assign({}, options, {\n            face,\n            data: resolvedImageData,\n            pixels: resolvedImageData\n          })\n        )\n      );\n    } else if (this.width || this.height) {\n      gl.texImage2D(face, 0, format, width, height, 0 /* border*/, format, type, imageData);\n    } else {\n      gl.texImage2D(face, 0, format, format, type, imageData);\n    }\n  }\n\n  _getImageDataMap(faceData: Record<string | GL, any>): Record<GL, any> {\n    for (let i = 0; i < Texture.CubeFaces.length; ++i) {\n      const faceName = Texture.CubeFaces[i];\n      if (faceData[faceName]) {\n        faceData[GL.TEXTURE_CUBE_MAP_POSITIVE_X + i] = faceData[faceName];\n        delete faceData[faceName];\n      }\n    }\n    return faceData;\n  }\n\n  // RESOURCE METHODS\n\n  /**\n   * Sets sampler parameters on texture\n   */\n  _setSamplerParameters(parameters: GLSamplerParameters): void {\n    log.log(1, `${this.id} sampler parameters`, this.device.getGLKeys(parameters))();\n\n    this.gl.bindTexture(this.glTarget, this.handle);\n    for (const [pname, pvalue] of Object.entries(parameters)) {\n      const param = Number(pname) as keyof GLSamplerParameters;\n      const value = pvalue;\n\n      // Apparently integer/float issues require two different texture parameter setting functions in JavaScript.\n      // For now, pick the float version for parameters specified as GLfloat.\n      switch (param) {\n        case GL.TEXTURE_MIN_LOD:\n        case GL.TEXTURE_MAX_LOD:\n          this.gl.texParameterf(this.glTarget, param, value);\n          break;\n\n        case GL.TEXTURE_MIN_FILTER:\n          this.gl.texParameteri(this.glTarget, param, value);\n          break;\n\n        case GL.TEXTURE_WRAP_S:\n        case GL.TEXTURE_WRAP_T:\n          this.gl.texParameteri(this.glTarget, param, value);\n          break;\n        case GL.TEXTURE_MAX_ANISOTROPY_EXT:\n          // We have to query feature before using it\n          if (this.device.features.has('texture-filterable-anisotropic-webgl')) {\n            this.gl.texParameteri(this.glTarget, param, value);\n          }\n          break;\n        default:\n          this.gl.texParameteri(this.glTarget, param, value);\n          break;\n      }\n    }\n\n    this.gl.bindTexture(this.glTarget, null);\n  }\n\n  // INTERNAL SETTERS\n\n  /**\n   * Copy a region of data from a CPU memory buffer into this texture.\n   * @todo -   GLUnpackParameters parameters\n   */\n  protected _setMipLevel(\n    depth: number,\n    mipLevel: number,\n    textureData: Texture2DData,\n    glTarget: GL = this.glTarget\n  ) {\n    // if (!textureData) {\n    //   clearMipLevel(this.device.gl, {...this, depth, level});\n    //   return;\n    // }\n\n    if (Texture.isExternalImage(textureData)) {\n      copyExternalImageToMipLevel(this.device.gl, this.handle, textureData, {\n        ...this,\n        depth,\n        mipLevel,\n        glTarget,\n        flipY: this.props.flipY\n      });\n      return;\n    }\n\n    // @ts-expect-error\n    if (Texture.isTextureLevelData(textureData)) {\n      copyCPUDataToMipLevel(this.device.gl, textureData.data, {\n        ...this,\n        depth,\n        mipLevel,\n        glTarget\n      });\n      return;\n    }\n\n    throw new Error('Texture: invalid image data');\n  }\n  // HELPERS\n\n  getActiveUnit(): number {\n    return this.gl.getParameter(GL.ACTIVE_TEXTURE) - GL.TEXTURE0;\n  }\n\n  bind(textureUnit?: number): number {\n    const {gl} = this;\n\n    if (textureUnit !== undefined) {\n      this.textureUnit = textureUnit;\n      gl.activeTexture(gl.TEXTURE0 + textureUnit);\n    }\n\n    gl.bindTexture(this.glTarget, this.handle);\n    return textureUnit;\n  }\n\n  unbind(textureUnit?: number): number | undefined {\n    const {gl} = this;\n\n    if (textureUnit !== undefined) {\n      this.textureUnit = textureUnit;\n      gl.activeTexture(gl.TEXTURE0 + textureUnit);\n    }\n\n    gl.bindTexture(this.glTarget, null);\n    return textureUnit;\n  }\n}\n\n// TODO - Remove when texture refactor is complete\n\n/*\nsetCubeMapData(options: {\n  width: number;\n  height: number;\n  data: Record<GL, Texture2DData> | Record<TextureCubeFace, Texture2DData>;\n  format?: any;\n  type?: any;\n  /** @deprecated Use .data *\n  pixels: any;\n}): void {\n  const {gl} = this;\n\n  const {width, height, pixels, data, format = GL.RGBA, type = GL.UNSIGNED_BYTE} = options;\n\n  // pixel data (imageDataMap) is an Object from Face to Image or Promise.\n  // For example:\n  // {\n  // GL.TEXTURE_CUBE_MAP_POSITIVE_X : Image-or-Promise,\n  // GL.TEXTURE_CUBE_MAP_NEGATIVE_X : Image-or-Promise,\n  // ... }\n  // To provide multiple level-of-details (LODs) this can be Face to Array\n  // of Image or Promise, like this\n  // {\n  // GL.TEXTURE_CUBE_MAP_POSITIVE_X : [Image-or-Promise-LOD-0, Image-or-Promise-LOD-1],\n  // GL.TEXTURE_CUBE_MAP_NEGATIVE_X : [Image-or-Promise-LOD-0, Image-or-Promise-LOD-1],\n  // ... }\n\n  const imageDataMap = this._getImageDataMap(pixels || data);\n\n  const resolvedFaces = WEBGLTexture.FACES.map(face => {\n    const facePixels = imageDataMap[face];\n    return Array.isArray(facePixels) ? facePixels : [facePixels];\n  });\n  this.bind();\n\n  WEBGLTexture.FACES.forEach((face, index) => {\n    if (resolvedFaces[index].length > 1 && this.props.mipmaps !== false) {\n      // If the user provides multiple LODs, then automatic mipmap\n      // generation generateMipmap() should be disabled to avoid overwritting them.\n      log.warn(`${this.id} has mipmap and multiple LODs.`)();\n    }\n    resolvedFaces[index].forEach((image, lodLevel) => {\n      // TODO: adjust width & height for LOD!\n      if (width && height) {\n        gl.texImage2D(face, lodLevel, format, width, height, 0 /* border*, format, type, image);\n      } else {\n        gl.texImage2D(face, lodLevel, format, format, type, image);\n      }\n    });\n  });\n\n  this.unbind();\n}\n*/\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}