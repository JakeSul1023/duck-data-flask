{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Resource } from \"./resource.js\";\n/**\n * Encodes commands to queue that can be executed later\n */\nexport class CommandEncoder extends Resource {\n  static defaultProps = {\n    ...Resource.defaultProps,\n    measureExecutionTime: undefined\n  };\n  get [Symbol.toStringTag]() {\n    return 'CommandEncoder';\n  }\n  constructor(device, props) {\n    super(device, props, CommandEncoder.defaultProps);\n  }\n}","map":{"version":3,"names":["Resource","CommandEncoder","defaultProps","measureExecutionTime","undefined","Symbol","toStringTag","constructor","device","props"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\core\\src\\adapter\\resources\\command-encoder.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// import type {TypedArray} from '@math.gl/types';\nimport {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\nimport {Buffer} from './buffer';\nimport {Texture} from './texture';\nimport {QuerySet} from './query-set';\n\n// WEBGPU COMMAND ENCODER OPERATIONS\n\nexport type CopyBufferToBufferOptions = {\n  sourceBuffer: Buffer;\n  sourceOffset?: number;\n  destinationBuffer: Buffer;\n  destinationOffset?: number;\n  size: number;\n};\n\nexport type CopyBufferToTextureOptions = {\n  sourceBuffer: Buffer;\n  byteOffset?: number;\n  destinationTexture: Texture;\n  mipLevel?: number; //  = 0;\n  origin?: [number, number, number] | number[];\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n  bytesPerRow: number;\n  rowsPerImage: number;\n  size: [number, number, number] | number[];\n};\n\nexport type CopyTextureToBufferOptions = {\n  /** Texture to copy to/from. */\n  sourceTexture: Texture;\n  /**  Mip-map level of the texture to copy to/from. (Default 0) */\n  mipLevel?: number;\n  /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from.\n   * Together with `copySize`, defines the full copy sub-region.\n   */\n  /** Defines which aspects of the texture to copy to/from. */\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n\n  /** Width to copy */\n  width?: number;\n  height?: number;\n  depthOrArrayLayers?: number;\n  origin?: number[];\n\n  /** Destination buffer */\n  destinationBuffer: Buffer;\n  /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */\n  byteOffset?: number;\n  /**\n   * The stride, in bytes, between the beginning of each block row and the subsequent block row.\n   * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).\n   */\n  bytesPerRow?: number;\n  /**\n   * Number of block rows per single image of the texture.\n   * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.\n   * Required if there are multiple images (i.e. the copy depth is more than one).\n   */\n  rowsPerImage?: number;\n};\n\nexport type CopyTextureToTextureOptions = {\n  /** Texture to copy to/from. */\n  sourceTexture: Texture;\n  /**  Mip-map level of the texture to copy to/from. (Default 0) */\n  mipLevel?: number;\n  /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */\n  origin?: number[];\n  /** Defines which aspects of the {@link GPUImageCopyTexture#texture} to copy to/from. */\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n\n  /** Texture to copy to/from. */\n  destinationTexture: Texture;\n  /**  Mip-map level of the texture to copy to/from. (Default 0) */\n  destinationMipLevel?: number;\n  /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */\n  destinationOrigin?: number[];\n  /** Defines which aspects of the {@link GPUImageCopyTexture#texture} to copy to/from. */\n  destinationAspect?: 'all' | 'stencil-only' | 'depth-only';\n\n  /** Width to copy */\n  width?: number;\n  height?: number;\n  depthOrArrayLayers?: number;\n};\n\n// ADDITIONAL COMMAND ENCODER OPERATIONS DEFINED BY LUMA.GL\n\n/** Options for clearing a texture mip level */\nexport type ClearTextureOptions = {\n  /** Texture to Clear. */\n  texture: Texture;\n  /**  Mip-map level of the texture clear. (Default 0) */\n  mipLevel?: number;\n  /** Defines which aspects of the Texture to clear. */\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n};\n\n// export type WriteBufferOptions = {\n//   buffer: Buffer;\n//   bufferOffset?: number;\n//   data: BufferSource;\n//   dataOffset?: number;\n//   size?: number;\n// };\n\n// export type WriteTextureOptions = {\n//   destination: Texture;\n//   mipLevel?: number; //  = 0;\n//   origin?: [number, number, number] | number[];\n//   aspect?: 'all' | 'stencil-only' | 'depth-only';\n//   data: BufferSource;\n//   // dataLayout;\n//   offset: number;\n//   bytesPerRow: number;\n//   rowsPerImage: number;\n//   size: [number, number, number] | number[];\n// };\n\nexport type CommandEncoderProps = ResourceProps & {\n  measureExecutionTime?: boolean;\n};\n\n/**\n * Encodes commands to queue that can be executed later\n */\nexport abstract class CommandEncoder extends Resource<CommandEncoderProps> {\n  static override defaultProps: Required<CommandEncoderProps> = {\n    ...Resource.defaultProps,\n    measureExecutionTime: undefined!\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'CommandEncoder';\n  }\n\n  constructor(device: Device, props: CommandEncoderProps) {\n    super(device, props, CommandEncoder.defaultProps);\n  }\n\n  /** Completes recording of the commands sequence */\n  abstract finish(): void; // TODO - return the CommandBuffer?\n\n  /** Add a command that that copies data from a sub-region of a Buffer to a sub-region of another Buffer. */\n  abstract copyBufferToBuffer(options: CopyBufferToBufferOptions): void;\n\n  /** Add a command that copies data from a sub-region of a GPUBuffer to a sub-region of one or multiple continuous texture subresources. */\n  abstract copyBufferToTexture(options: CopyBufferToTextureOptions): void;\n\n  /** Add a command that copies data from a sub-region of one or multiple continuous texture subresources to a sub-region of a Buffer. */\n  abstract copyTextureToBuffer(options: CopyTextureToBufferOptions): void;\n\n  /** Add a command that copies data from a sub-region of one or multiple contiguous texture subresources to another sub-region of one or multiple continuous texture subresources. */\n  abstract copyTextureToTexture(options: CopyTextureToTextureOptions): void;\n\n  /** Add a command that clears a texture mip level. */\n  // abstract clearTexture(options: ClearTextureOptions): void;\n\n  // abstract readTexture(options: ReadTextureOptions): Promise<TypedArray>;\n\n  /** Reads results from a query set into a GPU buffer. Values are 64 bits so byteLength must be querySet.props.count * 8 */\n  abstract resolveQuerySet(\n    querySet: QuerySet,\n    destination: Buffer,\n    options?: {\n      firstQuery?: number;\n      queryCount?: number;\n      destinationOffset?: number;\n    }\n  ): void;\n\n  /** Begins a labeled debug group containing subsequent commands */\n  abstract pushDebugGroup(groupLabel: string): void;\n  /** Ends the labeled debug group most recently started by pushDebugGroup() */\n  abstract popDebugGroup(): void;\n  /** Marks a point in a stream of commands with a label */\n  abstract insertDebugMarker(markerLabel: string): void;\n\n  // TODO - luma.gl has these on the device, should we align with WebGPU API?\n  // beginRenderPass(GPURenderPassDescriptor descriptor): GPURenderPassEncoder;\n  // beginComputePass(optional GPUComputePassDescriptor descriptor = {}): GPUComputePassEncoder;\n}\n"],"mappings":"AAAA;AACA;AACA;AAIA,SAAQA,QAAQ,QAAgB;AA2HhC;;;AAGA,OAAM,MAAgBC,cAAe,SAAQD,QAA6B;EACxE,OAAgBE,YAAY,GAAkC;IAC5D,GAAGF,QAAQ,CAACE,YAAY;IACxBC,oBAAoB,EAAEC;GACvB;EAED,KAAcC,MAAM,CAACC,WAAW,IAAC;IAC/B,OAAO,gBAAgB;EACzB;EAEAC,YAAYC,MAAc,EAAEC,KAA0B;IACpD,KAAK,CAACD,MAAM,EAAEC,KAAK,EAAER,cAAc,CAACC,YAAY,CAAC;EACnD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}