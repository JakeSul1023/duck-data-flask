{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport { assert } from '@loaders.gl/loader-utils';\nexport function calculateTransformProps(tileHeader, tile) {\n  assert(tileHeader);\n  assert(tile);\n  const {\n    rtcCenter,\n    gltfUpAxis\n  } = tile;\n  const {\n    computedTransform,\n    boundingVolume: {\n      center\n    }\n  } = tileHeader;\n  let modelMatrix = new Matrix4(computedTransform);\n  // Translate if appropriate\n  if (rtcCenter) {\n    modelMatrix.translate(rtcCenter);\n  }\n  // glTF models need to be rotated from Y to Z up\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#y-up-to-z-up\n  switch (gltfUpAxis) {\n    case 'Z':\n      break;\n    case 'Y':\n      const rotationY = new Matrix4().rotateX(Math.PI / 2);\n      modelMatrix = modelMatrix.multiplyRight(rotationY);\n      break;\n    case 'X':\n      const rotationX = new Matrix4().rotateY(-Math.PI / 2);\n      modelMatrix = modelMatrix.multiplyRight(rotationX);\n      break;\n    default:\n      break;\n  }\n  // Scale/offset positions if normalized integers\n  if (tile.isQuantized) {\n    modelMatrix.translate(tile.quantizedVolumeOffset).scale(tile.quantizedVolumeScale);\n  }\n  // Option 1: Cartesian matrix and origin\n  const cartesianOrigin = new Vector3(center);\n  tile.cartesianModelMatrix = modelMatrix;\n  tile.cartesianOrigin = cartesianOrigin;\n  // Option 2: Cartographic matrix and origin\n  const cartographicOrigin = Ellipsoid.WGS84.cartesianToCartographic(cartesianOrigin, new Vector3());\n  const fromFixedFrameMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin);\n  const toFixedFrameMatrix = fromFixedFrameMatrix.invert();\n  tile.cartographicModelMatrix = toFixedFrameMatrix.multiplyRight(modelMatrix);\n  tile.cartographicOrigin = cartographicOrigin;\n  // Deprecated, drop\n  if (!tile.coordinateSystem) {\n    tile.modelMatrix = tile.cartographicModelMatrix;\n  }\n}","map":{"version":3,"names":["Ellipsoid","Matrix4","Vector3","assert","calculateTransformProps","tileHeader","tile","rtcCenter","gltfUpAxis","computedTransform","boundingVolume","center","modelMatrix","translate","rotationY","rotateX","Math","PI","multiplyRight","rotationX","rotateY","isQuantized","quantizedVolumeOffset","scale","quantizedVolumeScale","cartesianOrigin","cartesianModelMatrix","cartographicOrigin","WGS84","cartesianToCartographic","fromFixedFrameMatrix","eastNorthUpToFixedFrame","toFixedFrameMatrix","invert","cartographicModelMatrix","coordinateSystem"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/tiles/dist/tileset/helpers/transform-utils.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport { assert } from '@loaders.gl/loader-utils';\nexport function calculateTransformProps(tileHeader, tile) {\n    assert(tileHeader);\n    assert(tile);\n    const { rtcCenter, gltfUpAxis } = tile;\n    const { computedTransform, boundingVolume: { center } } = tileHeader;\n    let modelMatrix = new Matrix4(computedTransform);\n    // Translate if appropriate\n    if (rtcCenter) {\n        modelMatrix.translate(rtcCenter);\n    }\n    // glTF models need to be rotated from Y to Z up\n    // https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#y-up-to-z-up\n    switch (gltfUpAxis) {\n        case 'Z':\n            break;\n        case 'Y':\n            const rotationY = new Matrix4().rotateX(Math.PI / 2);\n            modelMatrix = modelMatrix.multiplyRight(rotationY);\n            break;\n        case 'X':\n            const rotationX = new Matrix4().rotateY(-Math.PI / 2);\n            modelMatrix = modelMatrix.multiplyRight(rotationX);\n            break;\n        default:\n            break;\n    }\n    // Scale/offset positions if normalized integers\n    if (tile.isQuantized) {\n        modelMatrix.translate(tile.quantizedVolumeOffset).scale(tile.quantizedVolumeScale);\n    }\n    // Option 1: Cartesian matrix and origin\n    const cartesianOrigin = new Vector3(center);\n    tile.cartesianModelMatrix = modelMatrix;\n    tile.cartesianOrigin = cartesianOrigin;\n    // Option 2: Cartographic matrix and origin\n    const cartographicOrigin = Ellipsoid.WGS84.cartesianToCartographic(cartesianOrigin, new Vector3());\n    const fromFixedFrameMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin);\n    const toFixedFrameMatrix = fromFixedFrameMatrix.invert();\n    tile.cartographicModelMatrix = toFixedFrameMatrix.multiplyRight(modelMatrix);\n    tile.cartographicOrigin = cartographicOrigin;\n    // Deprecated, drop\n    if (!tile.coordinateSystem) {\n        tile.modelMatrix = tile.cartographicModelMatrix;\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,SAAS,QAAQ,qBAAqB;AAC/C,SAASC,OAAO,EAAEC,OAAO,QAAQ,eAAe;AAChD,SAASC,MAAM,QAAQ,0BAA0B;AACjD,OAAO,SAASC,uBAAuBA,CAACC,UAAU,EAAEC,IAAI,EAAE;EACtDH,MAAM,CAACE,UAAU,CAAC;EAClBF,MAAM,CAACG,IAAI,CAAC;EACZ,MAAM;IAAEC,SAAS;IAAEC;EAAW,CAAC,GAAGF,IAAI;EACtC,MAAM;IAAEG,iBAAiB;IAAEC,cAAc,EAAE;MAAEC;IAAO;EAAE,CAAC,GAAGN,UAAU;EACpE,IAAIO,WAAW,GAAG,IAAIX,OAAO,CAACQ,iBAAiB,CAAC;EAChD;EACA,IAAIF,SAAS,EAAE;IACXK,WAAW,CAACC,SAAS,CAACN,SAAS,CAAC;EACpC;EACA;EACA;EACA,QAAQC,UAAU;IACd,KAAK,GAAG;MACJ;IACJ,KAAK,GAAG;MACJ,MAAMM,SAAS,GAAG,IAAIb,OAAO,CAAC,CAAC,CAACc,OAAO,CAACC,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC;MACpDL,WAAW,GAAGA,WAAW,CAACM,aAAa,CAACJ,SAAS,CAAC;MAClD;IACJ,KAAK,GAAG;MACJ,MAAMK,SAAS,GAAG,IAAIlB,OAAO,CAAC,CAAC,CAACmB,OAAO,CAAC,CAACJ,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC;MACrDL,WAAW,GAAGA,WAAW,CAACM,aAAa,CAACC,SAAS,CAAC;MAClD;IACJ;MACI;EACR;EACA;EACA,IAAIb,IAAI,CAACe,WAAW,EAAE;IAClBT,WAAW,CAACC,SAAS,CAACP,IAAI,CAACgB,qBAAqB,CAAC,CAACC,KAAK,CAACjB,IAAI,CAACkB,oBAAoB,CAAC;EACtF;EACA;EACA,MAAMC,eAAe,GAAG,IAAIvB,OAAO,CAACS,MAAM,CAAC;EAC3CL,IAAI,CAACoB,oBAAoB,GAAGd,WAAW;EACvCN,IAAI,CAACmB,eAAe,GAAGA,eAAe;EACtC;EACA,MAAME,kBAAkB,GAAG3B,SAAS,CAAC4B,KAAK,CAACC,uBAAuB,CAACJ,eAAe,EAAE,IAAIvB,OAAO,CAAC,CAAC,CAAC;EAClG,MAAM4B,oBAAoB,GAAG9B,SAAS,CAAC4B,KAAK,CAACG,uBAAuB,CAACN,eAAe,CAAC;EACrF,MAAMO,kBAAkB,GAAGF,oBAAoB,CAACG,MAAM,CAAC,CAAC;EACxD3B,IAAI,CAAC4B,uBAAuB,GAAGF,kBAAkB,CAACd,aAAa,CAACN,WAAW,CAAC;EAC5EN,IAAI,CAACqB,kBAAkB,GAAGA,kBAAkB;EAC5C;EACA,IAAI,CAACrB,IAAI,CAAC6B,gBAAgB,EAAE;IACxB7B,IAAI,CAACM,WAAW,GAAGN,IAAI,CAAC4B,uBAAuB;EACnD;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}