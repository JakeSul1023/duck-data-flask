{"ast":null,"code":"import { Stats } from '@probe.gl/stats';\nconst STAT_QUEUED_REQUESTS = 'Queued Requests';\nconst STAT_ACTIVE_REQUESTS = 'Active Requests';\nconst STAT_CANCELLED_REQUESTS = 'Cancelled Requests';\nconst STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';\nconst STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';\nconst DEFAULT_PROPS = {\n  id: 'request-scheduler',\n  /** Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing. */\n  throttleRequests: true,\n  /** The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit. */\n  maxRequests: 6,\n  /**\n   * Specifies a debounce time, in milliseconds. All requests are queued, until no new requests have\n   * been added to the queue for this amount of time.\n   */\n  debounceTime: 0\n};\n/**\n * Used to issue a request, without having them \"deeply queued\" by the browser.\n * @todo - Track requests globally, across multiple servers\n */\nexport default class RequestScheduler {\n  props;\n  stats;\n  activeRequestCount = 0;\n  /** Tracks the number of active requests and prioritizes/cancels queued requests. */\n  requestQueue = [];\n  requestMap = new Map();\n  updateTimer = null;\n  constructor(props = {}) {\n    this.props = {\n      ...DEFAULT_PROPS,\n      ...props\n    };\n    // Returns the statistics used by the request scheduler.\n    this.stats = new Stats({\n      id: this.props.id\n    });\n    this.stats.get(STAT_QUEUED_REQUESTS);\n    this.stats.get(STAT_ACTIVE_REQUESTS);\n    this.stats.get(STAT_CANCELLED_REQUESTS);\n    this.stats.get(STAT_QUEUED_REQUESTS_EVER);\n    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);\n  }\n  /**\n   * Called by an application that wants to issue a request, without having it deeply queued by the browser\n   *\n   * When the returned promise resolved, it is OK for the application to issue a request.\n   * The promise resolves to an object that contains a `done` method.\n   * When the application's request has completed (or failed), the application must call the `done` function\n   *\n   * @param handle\n   * @param getPriority will be called when request \"slots\" open up,\n   *    allowing the caller to update priority or cancel the request\n   *    Highest priority executes first, priority < 0 cancels the request\n   * @returns a promise\n   *   - resolves to a object (with a `done` field) when the request can be issued without queueing,\n   *   - resolves to `null` if the request has been cancelled (by the callback return < 0).\n   *     In this case the application should not issue the request\n   */\n  scheduleRequest(handle, getPriority = () => 0) {\n    // Allows throttling to be disabled\n    if (!this.props.throttleRequests) {\n      return Promise.resolve({\n        done: () => {}\n      });\n    }\n    // dedupe\n    if (this.requestMap.has(handle)) {\n      return this.requestMap.get(handle);\n    }\n    const request = {\n      handle,\n      priority: 0,\n      getPriority\n    };\n    const promise = new Promise(resolve => {\n      // @ts-ignore\n      request.resolve = resolve;\n      return request;\n    });\n    this.requestQueue.push(request);\n    this.requestMap.set(handle, promise);\n    this._issueNewRequests();\n    return promise;\n  }\n  // PRIVATE\n  _issueRequest(request) {\n    const {\n      handle,\n      resolve\n    } = request;\n    let isDone = false;\n    const done = () => {\n      // can only be called once\n      if (!isDone) {\n        isDone = true;\n        // Stop tracking a request - it has completed, failed, cancelled etc\n        this.requestMap.delete(handle);\n        this.activeRequestCount--;\n        // A slot just freed up, see if any queued requests are waiting\n        this._issueNewRequests();\n      }\n    };\n    // Track this request\n    this.activeRequestCount++;\n    return resolve ? resolve({\n      done\n    }) : Promise.resolve({\n      done\n    });\n  }\n  /** We check requests asynchronously, to prevent multiple updates */\n  _issueNewRequests() {\n    if (this.updateTimer !== null) {\n      clearTimeout(this.updateTimer);\n    }\n    this.updateTimer = setTimeout(() => this._issueNewRequestsAsync(), this.props.debounceTime);\n  }\n  /** Refresh all requests  */\n  _issueNewRequestsAsync() {\n    if (this.updateTimer !== null) {\n      clearTimeout(this.updateTimer);\n    }\n    this.updateTimer = null;\n    const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);\n    if (freeSlots === 0) {\n      return;\n    }\n    this._updateAllRequests();\n    // Resolve pending promises for the top-priority requests\n    for (let i = 0; i < freeSlots; ++i) {\n      const request = this.requestQueue.shift();\n      if (request) {\n        this._issueRequest(request); // eslint-disable-line @typescript-eslint/no-floating-promises\n      }\n    }\n    // Uncomment to debug\n    // console.log(`${freeSlots} free slots, ${this.requestQueue.length} queued requests`);\n  }\n  /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */\n  _updateAllRequests() {\n    const requestQueue = this.requestQueue;\n    for (let i = 0; i < requestQueue.length; ++i) {\n      const request = requestQueue[i];\n      if (!this._updateRequest(request)) {\n        // Remove the element and make sure to adjust the counter to account for shortened array\n        requestQueue.splice(i, 1);\n        this.requestMap.delete(request.handle);\n        i--;\n      }\n    }\n    // Sort the remaining requests based on priority\n    requestQueue.sort((a, b) => a.priority - b.priority);\n  }\n  /** Update a single request by calling the callback */\n  _updateRequest(request) {\n    request.priority = request.getPriority(request.handle); // eslint-disable-line callback-return\n    // by returning a negative priority, the callback cancels the request\n    if (request.priority < 0) {\n      request.resolve(null);\n      return false;\n    }\n    return true;\n  }\n}","map":{"version":3,"names":["Stats","STAT_QUEUED_REQUESTS","STAT_ACTIVE_REQUESTS","STAT_CANCELLED_REQUESTS","STAT_QUEUED_REQUESTS_EVER","STAT_ACTIVE_REQUESTS_EVER","DEFAULT_PROPS","id","throttleRequests","maxRequests","debounceTime","RequestScheduler","props","stats","activeRequestCount","requestQueue","requestMap","Map","updateTimer","constructor","get","scheduleRequest","handle","getPriority","Promise","resolve","done","has","request","priority","promise","push","set","_issueNewRequests","_issueRequest","isDone","delete","clearTimeout","setTimeout","_issueNewRequestsAsync","freeSlots","Math","max","_updateAllRequests","i","shift","length","_updateRequest","splice","sort","a","b"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/loader-utils/dist/lib/request-utils/request-scheduler.js"],"sourcesContent":["import { Stats } from '@probe.gl/stats';\nconst STAT_QUEUED_REQUESTS = 'Queued Requests';\nconst STAT_ACTIVE_REQUESTS = 'Active Requests';\nconst STAT_CANCELLED_REQUESTS = 'Cancelled Requests';\nconst STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';\nconst STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';\nconst DEFAULT_PROPS = {\n    id: 'request-scheduler',\n    /** Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing. */\n    throttleRequests: true,\n    /** The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit. */\n    maxRequests: 6,\n    /**\n     * Specifies a debounce time, in milliseconds. All requests are queued, until no new requests have\n     * been added to the queue for this amount of time.\n     */\n    debounceTime: 0\n};\n/**\n * Used to issue a request, without having them \"deeply queued\" by the browser.\n * @todo - Track requests globally, across multiple servers\n */\nexport default class RequestScheduler {\n    props;\n    stats;\n    activeRequestCount = 0;\n    /** Tracks the number of active requests and prioritizes/cancels queued requests. */\n    requestQueue = [];\n    requestMap = new Map();\n    updateTimer = null;\n    constructor(props = {}) {\n        this.props = { ...DEFAULT_PROPS, ...props };\n        // Returns the statistics used by the request scheduler.\n        this.stats = new Stats({ id: this.props.id });\n        this.stats.get(STAT_QUEUED_REQUESTS);\n        this.stats.get(STAT_ACTIVE_REQUESTS);\n        this.stats.get(STAT_CANCELLED_REQUESTS);\n        this.stats.get(STAT_QUEUED_REQUESTS_EVER);\n        this.stats.get(STAT_ACTIVE_REQUESTS_EVER);\n    }\n    /**\n     * Called by an application that wants to issue a request, without having it deeply queued by the browser\n     *\n     * When the returned promise resolved, it is OK for the application to issue a request.\n     * The promise resolves to an object that contains a `done` method.\n     * When the application's request has completed (or failed), the application must call the `done` function\n     *\n     * @param handle\n     * @param getPriority will be called when request \"slots\" open up,\n     *    allowing the caller to update priority or cancel the request\n     *    Highest priority executes first, priority < 0 cancels the request\n     * @returns a promise\n     *   - resolves to a object (with a `done` field) when the request can be issued without queueing,\n     *   - resolves to `null` if the request has been cancelled (by the callback return < 0).\n     *     In this case the application should not issue the request\n     */\n    scheduleRequest(handle, getPriority = () => 0) {\n        // Allows throttling to be disabled\n        if (!this.props.throttleRequests) {\n            return Promise.resolve({ done: () => { } });\n        }\n        // dedupe\n        if (this.requestMap.has(handle)) {\n            return this.requestMap.get(handle);\n        }\n        const request = { handle, priority: 0, getPriority };\n        const promise = new Promise((resolve) => {\n            // @ts-ignore\n            request.resolve = resolve;\n            return request;\n        });\n        this.requestQueue.push(request);\n        this.requestMap.set(handle, promise);\n        this._issueNewRequests();\n        return promise;\n    }\n    // PRIVATE\n    _issueRequest(request) {\n        const { handle, resolve } = request;\n        let isDone = false;\n        const done = () => {\n            // can only be called once\n            if (!isDone) {\n                isDone = true;\n                // Stop tracking a request - it has completed, failed, cancelled etc\n                this.requestMap.delete(handle);\n                this.activeRequestCount--;\n                // A slot just freed up, see if any queued requests are waiting\n                this._issueNewRequests();\n            }\n        };\n        // Track this request\n        this.activeRequestCount++;\n        return resolve ? resolve({ done }) : Promise.resolve({ done });\n    }\n    /** We check requests asynchronously, to prevent multiple updates */\n    _issueNewRequests() {\n        if (this.updateTimer !== null) {\n            clearTimeout(this.updateTimer);\n        }\n        this.updateTimer = setTimeout(() => this._issueNewRequestsAsync(), this.props.debounceTime);\n    }\n    /** Refresh all requests  */\n    _issueNewRequestsAsync() {\n        if (this.updateTimer !== null) {\n            clearTimeout(this.updateTimer);\n        }\n        this.updateTimer = null;\n        const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);\n        if (freeSlots === 0) {\n            return;\n        }\n        this._updateAllRequests();\n        // Resolve pending promises for the top-priority requests\n        for (let i = 0; i < freeSlots; ++i) {\n            const request = this.requestQueue.shift();\n            if (request) {\n                this._issueRequest(request); // eslint-disable-line @typescript-eslint/no-floating-promises\n            }\n        }\n        // Uncomment to debug\n        // console.log(`${freeSlots} free slots, ${this.requestQueue.length} queued requests`);\n    }\n    /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */\n    _updateAllRequests() {\n        const requestQueue = this.requestQueue;\n        for (let i = 0; i < requestQueue.length; ++i) {\n            const request = requestQueue[i];\n            if (!this._updateRequest(request)) {\n                // Remove the element and make sure to adjust the counter to account for shortened array\n                requestQueue.splice(i, 1);\n                this.requestMap.delete(request.handle);\n                i--;\n            }\n        }\n        // Sort the remaining requests based on priority\n        requestQueue.sort((a, b) => a.priority - b.priority);\n    }\n    /** Update a single request by calling the callback */\n    _updateRequest(request) {\n        request.priority = request.getPriority(request.handle); // eslint-disable-line callback-return\n        // by returning a negative priority, the callback cancels the request\n        if (request.priority < 0) {\n            request.resolve(null);\n            return false;\n        }\n        return true;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}