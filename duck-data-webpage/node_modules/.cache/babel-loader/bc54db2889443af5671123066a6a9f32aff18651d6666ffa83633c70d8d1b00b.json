{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport const dashShaders = {\n  inject: {\n    'vs:#decl': `\nin vec2 instanceDashArrays;\nin float instanceDashOffsets;\nout vec2 vDashArray;\nout float vDashOffset;\n`,\n    'vs:#main-end': `\nvDashArray = instanceDashArrays;\nvDashOffset = instanceDashOffsets / width.x;\n`,\n    'fs:#decl': `\nuniform pathStyleUniforms {\nfloat dashAlignMode;\nbool dashGapPickable;\n} pathStyle;\nin vec2 vDashArray;\nin float vDashOffset;\n`,\n    // if given position is in the gap part of the dashed line\n    // dashArray.x: solid stroke length, relative to width\n    // dashArray.y: gap length, relative to width\n    // alignMode:\n    // 0 - no adjustment\n    // o----     ----     ----     ---- o----     -o----     ----     o\n    // 1 - stretch to fit, draw half dash at each end for nicer joints\n    // o--    ----    ----    ----    --o--      --o--     ----     --o\n    'fs:#main-start': `\nfloat solidLength = vDashArray.x;\nfloat gapLength = vDashArray.y;\nfloat unitLength = solidLength + gapLength;\nfloat offset;\nif (unitLength > 0.0) {\nif (pathStyle.dashAlignMode == 0.0) {\noffset = vDashOffset;\n} else {\nunitLength = vPathLength / round(vPathLength / unitLength);\noffset = solidLength / 2.0;\n}\nfloat unitOffset = mod(vPathPosition.y + offset, unitLength);\nif (gapLength > 0.0 && unitOffset > solidLength) {\nif (path.capType <= 0.5) {\nif (!(pathStyle.dashGapPickable && bool(picking.isActive))) {\ndiscard;\n}\n} else {\nfloat distToEnd = length(vec2(\nmin(unitOffset - solidLength, unitLength - unitOffset),\nvPathPosition.x\n));\nif (distToEnd > 1.0) {\nif (!(pathStyle.dashGapPickable && bool(picking.isActive))) {\ndiscard;\n}\n}\n}\n}\n}\n`\n  }\n};\nexport const offsetShaders = {\n  inject: {\n    'vs:#decl': `\nin float instanceOffsets;\n`,\n    'vs:DECKGL_FILTER_SIZE': `\nfloat offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\nsize *= offsetWidth;\n`,\n    'vs:#main-end': `\nfloat offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\nfloat offsetDir = sign(instanceOffsets);\nvPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;\nvPathPosition.y *= offsetWidth;\nvPathLength *= offsetWidth;\n`,\n    'fs:#main-start': `\nfloat isInside;\nisInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);\nif (isInside == 0.0) {\ndiscard;\n}\n`\n  }\n};\n//# sourceMappingURL=shaders.glsl.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}