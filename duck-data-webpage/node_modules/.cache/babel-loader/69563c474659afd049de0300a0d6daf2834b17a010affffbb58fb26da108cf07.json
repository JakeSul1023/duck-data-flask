{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getDataTypeFromArray, getDataTypeFromValue } from \"./data-type.js\";\n/**\n * SCHEMA SUPPORT - AUTODEDUCTION\n * @param {*} table\n * @param {*} schema\n * @returns\n */\nexport function deduceTableSchema(table) {\n  switch (table.shape) {\n    case 'array-row-table':\n    case 'object-row-table':\n      return deduceSchemaFromRows(table.data);\n    case 'geojson-table':\n      return deduceSchemaFromGeoJSON(table.features);\n    case 'columnar-table':\n      return deduceSchemaFromColumns(table.data);\n    case 'arrow-table':\n    default:\n      throw new Error('Deduce schema');\n  }\n}\nexport function deduceSchema(data) {\n  return Array.isArray(data) ? deduceSchemaFromRows(data) : deduceSchemaFromColumns(data);\n}\n/** Given an object with columnar arrays, try to deduce a schema */\nfunction deduceSchemaFromColumns(columnarTable) {\n  const fields = [];\n  for (const [columnName, column] of Object.entries(columnarTable)) {\n    const field = deduceFieldFromColumn(column, columnName);\n    fields.push(field);\n  }\n  return {\n    fields,\n    metadata: {}\n  };\n}\n/** Given an array of rows, try to deduce a schema */\nfunction deduceSchemaFromRows(rowTable) {\n  if (!rowTable.length) {\n    throw new Error('deduce from empty table');\n  }\n  const fields = [];\n  const row0 = rowTable[0];\n  // TODO - fields can be nullable, false detection...\n  // Could look at additional rows if nulls in first row\n  // TODO - if array, column names will be numbers\n  for (const [columnName, value] of Object.entries(row0)) {\n    fields.push(deduceFieldFromValue(value, columnName));\n  }\n  return {\n    fields,\n    metadata: {}\n  };\n}\n/** Given a GeoJSON, try to deduce a schema */\nfunction deduceSchemaFromGeoJSON(features) {\n  if (!features.length) {\n    throw new Error('deduce from empty table');\n  }\n  const fields = [];\n  const row0 = features[0].properties || {};\n  // TODO - fields can be nullable, false detection...\n  // Could look at additional rows if nulls in first row\n  // TODO - if array, column names will be numbers\n  for (const [columnName, value] of Object.entries(row0)) {\n    fields.push(deduceFieldFromValue(value, columnName));\n  }\n  return {\n    fields,\n    metadata: {}\n  };\n}\n/** Given a column (i.e. array), attempt to deduce an appropriate `Field` */\nfunction deduceFieldFromColumn(column, name) {\n  if (ArrayBuffer.isView(column)) {\n    const type = getDataTypeFromArray(column);\n    return {\n      name,\n      type: type.type || 'null',\n      nullable: type.nullable\n      // metadata: {}\n    };\n  }\n  if (Array.isArray(column) && column.length > 0) {\n    const value = column[0];\n    const type = getDataTypeFromValue(value);\n    // TODO - support nested schemas?\n    return {\n      name,\n      type,\n      nullable: true\n      // metadata: {},\n    };\n  }\n  throw new Error('empty table');\n}\n/** Given a value, attempt to deduce an appropriate `Field` */\nfunction deduceFieldFromValue(value, name) {\n  const type = getDataTypeFromValue(value);\n  return {\n    name,\n    type,\n    nullable: true\n    // metadata: {}\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}