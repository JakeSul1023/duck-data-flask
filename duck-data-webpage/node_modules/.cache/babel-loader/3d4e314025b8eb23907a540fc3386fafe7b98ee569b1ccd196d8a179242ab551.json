{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport Transition from \"../transitions/transition.js\";\nconst noop = () => {};\n// Enums cannot be directly exported as they are not transpiled correctly into ES5, see https://github.com/visgl/deck.gl/issues/7130\nexport const TRANSITION_EVENTS = {\n  BREAK: 1,\n  SNAP_TO_END: 2,\n  IGNORE: 3\n};\nconst DEFAULT_EASING = t => t;\nconst DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;\nexport default class TransitionManager {\n  constructor(opts) {\n    this._onTransitionUpdate = transition => {\n      // NOTE: Be cautious re-ordering statements in this function.\n      const {\n        time,\n        settings: {\n          interpolator,\n          startProps,\n          endProps,\n          duration,\n          easing\n        }\n      } = transition;\n      const t = easing(time / duration);\n      const viewport = interpolator.interpolateProps(startProps, endProps, t);\n      // This gurantees all props (e.g. bearing, longitude) are normalized\n      // So when viewports are compared they are in same range.\n      this.propsInTransition = this.getControllerState({\n        ...this.props,\n        ...viewport\n      }).getViewportProps();\n      this.onViewStateChange({\n        viewState: this.propsInTransition,\n        oldViewState: this.props\n      });\n    };\n    this.getControllerState = opts.getControllerState;\n    this.propsInTransition = null;\n    this.transition = new Transition(opts.timeline);\n    this.onViewStateChange = opts.onViewStateChange || noop;\n    this.onStateChange = opts.onStateChange || noop;\n  }\n  finalize() {\n    this.transition.cancel();\n  }\n  // Returns current transitioned viewport.\n  getViewportInTransition() {\n    return this.propsInTransition;\n  }\n  // Process the vewiport change, either ignore or trigger a new transition.\n  // Return true if a new transition is triggered, false otherwise.\n  processViewStateChange(nextProps) {\n    let transitionTriggered = false;\n    const currentProps = this.props;\n    // Set this.props here as '_triggerTransition' calls '_updateViewport' that uses this.props.\n    this.props = nextProps;\n    // NOTE: Be cautious re-ordering statements in this function.\n    if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n      return false;\n    }\n    if (this._isTransitionEnabled(nextProps)) {\n      let startProps = currentProps;\n      if (this.transition.inProgress) {\n        // @ts-expect-error\n        const {\n          interruption,\n          endProps\n        } = this.transition.settings;\n        startProps = {\n          ...currentProps,\n          ...(interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps)\n        };\n      }\n      this._triggerTransition(startProps, nextProps);\n      transitionTriggered = true;\n    } else {\n      this.transition.cancel();\n    }\n    return transitionTriggered;\n  }\n  updateTransition() {\n    this.transition.update();\n  }\n  // Helper methods\n  _isTransitionEnabled(props) {\n    const {\n      transitionDuration,\n      transitionInterpolator\n    } = props;\n    return (transitionDuration > 0 || transitionDuration === 'auto') && Boolean(transitionInterpolator);\n  }\n  _isUpdateDueToCurrentTransition(props) {\n    if (this.transition.inProgress && this.propsInTransition) {\n      // @ts-expect-error\n      return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);\n    }\n    return false;\n  }\n  _shouldIgnoreViewportChange(currentProps, nextProps) {\n    if (this.transition.inProgress) {\n      // @ts-expect-error\n      const transitionSettings = this.transition.settings;\n      // Ignore update if it is requested to be ignored\n      return transitionSettings.interruption === TRANSITION_EVENTS.IGNORE ||\n      // Ignore update if it is due to current active transition.\n      this._isUpdateDueToCurrentTransition(nextProps);\n    }\n    if (this._isTransitionEnabled(nextProps)) {\n      // Ignore if none of the viewport props changed.\n      return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);\n    }\n    return true;\n  }\n  _triggerTransition(startProps, endProps) {\n    const startViewstate = this.getControllerState(startProps);\n    const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);\n    // update transitionDuration for 'auto' mode\n    const transitionInterpolator = endProps.transitionInterpolator;\n    const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;\n    if (duration === 0) {\n      return;\n    }\n    const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);\n    this.propsInTransition = {};\n    const transitionSettings = {\n      duration,\n      easing: endProps.transitionEasing || DEFAULT_EASING,\n      interpolator: transitionInterpolator,\n      interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,\n      startProps: initialProps.start,\n      endProps: initialProps.end,\n      onStart: endProps.onTransitionStart,\n      onUpdate: this._onTransitionUpdate,\n      onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),\n      onEnd: this._onTransitionEnd(endProps.onTransitionEnd)\n    };\n    this.transition.start(transitionSettings);\n    this.onStateChange({\n      inTransition: true\n    });\n    this.updateTransition();\n  }\n  _onTransitionEnd(callback) {\n    return transition => {\n      this.propsInTransition = null;\n      this.onStateChange({\n        inTransition: false,\n        isZooming: false,\n        isPanning: false,\n        isRotating: false\n      });\n      callback?.(transition);\n    };\n  }\n}\n//# sourceMappingURL=transition-manager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}