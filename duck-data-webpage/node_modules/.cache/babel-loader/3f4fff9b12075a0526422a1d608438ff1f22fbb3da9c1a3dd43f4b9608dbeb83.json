{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Vector3, mat4 } from '@math.gl/core';\nimport { INTERSECTION } from \"../../constants.js\";\nconst scratchVector = new Vector3();\nconst scratchVector2 = new Vector3();\n/** A BoundingSphere */\nexport class BoundingSphere {\n  /** Creates a bounding sphere */\n  constructor(center = [0, 0, 0], radius = 0.0) {\n    this.radius = -0;\n    this.center = new Vector3();\n    this.fromCenterRadius(center, radius);\n  }\n  /** Sets the bounding sphere from `center` and `radius`. */\n  fromCenterRadius(center, radius) {\n    this.center.from(center);\n    this.radius = radius;\n    return this;\n  }\n  /**\n   * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\n   * tightly and fully encompasses the box.\n   */\n  fromCornerPoints(corner, oppositeCorner) {\n    oppositeCorner = scratchVector.from(oppositeCorner);\n    this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);\n    this.radius = this.center.distance(oppositeCorner);\n    return this;\n  }\n  /** Compares the provided BoundingSphere component wise */\n  equals(right) {\n    return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;\n  }\n  /** Duplicates a BoundingSphere instance. */\n  clone() {\n    return new BoundingSphere(this.center, this.radius);\n  }\n  /** Computes a bounding sphere that contains both the left and right bounding spheres. */\n  union(boundingSphere) {\n    const leftCenter = this.center;\n    const leftRadius = this.radius;\n    const rightCenter = boundingSphere.center;\n    const rightRadius = boundingSphere.radius;\n    const toRightCenter = scratchVector.copy(rightCenter).subtract(leftCenter);\n    const centerSeparation = toRightCenter.magnitude();\n    if (leftRadius >= centerSeparation + rightRadius) {\n      // Left sphere wins.\n      return this.clone();\n    }\n    if (rightRadius >= centerSeparation + leftRadius) {\n      // Right sphere wins.\n      return boundingSphere.clone();\n    }\n    // There are two tangent points, one on far side of each sphere.\n    const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n    // Compute the center point halfway between the two tangent points.\n    scratchVector2.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);\n    this.center.copy(scratchVector2);\n    this.radius = halfDistanceBetweenTangentPoints;\n    return this;\n  }\n  /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */\n  expand(point) {\n    const scratchPoint = scratchVector.from(point);\n    const radius = scratchPoint.subtract(this.center).magnitude();\n    if (radius > this.radius) {\n      this.radius = radius;\n    }\n    return this;\n  }\n  // BoundingVolume interface\n  /**\n   * Applies a 4x4 affine transformation matrix to a bounding sphere.\n   * @param sphere The bounding sphere to apply the transformation to.\n   * @param transform The transformation matrix to apply to the bounding sphere.\n   * @returns self.\n   */\n  transform(transform) {\n    this.center.transform(transform);\n    const scale = mat4.getScaling(scratchVector, transform);\n    this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;\n    return this;\n  }\n  /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */\n  distanceSquaredTo(point) {\n    const d = this.distanceTo(point);\n    return d * d;\n  }\n  /** Computes the estimated distance from the closest point on a bounding sphere to a point. */\n  distanceTo(point) {\n    const scratchPoint = scratchVector.from(point);\n    const delta = scratchPoint.subtract(this.center);\n    return Math.max(0, delta.len() - this.radius);\n  }\n  /** Determines which side of a plane a sphere is located. */\n  intersectPlane(plane) {\n    const center = this.center;\n    const radius = this.radius;\n    const normal = plane.normal;\n    const distanceToPlane = normal.dot(center) + plane.distance;\n    // The center point is negative side of the plane normal\n    if (distanceToPlane < -radius) {\n      return INTERSECTION.OUTSIDE;\n    }\n    // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n    if (distanceToPlane < radius) {\n      return INTERSECTION.INTERSECTING;\n    }\n    // The center point and radius is positive side of the plane\n    return INTERSECTION.INSIDE;\n  }\n}","map":{"version":3,"names":["Vector3","mat4","INTERSECTION","scratchVector","scratchVector2","BoundingSphere","constructor","center","radius","fromCenterRadius","from","fromCornerPoints","corner","oppositeCorner","add","scale","distance","equals","right","Boolean","clone","union","boundingSphere","leftCenter","leftRadius","rightCenter","rightRadius","toRightCenter","copy","subtract","centerSeparation","magnitude","halfDistanceBetweenTangentPoints","expand","point","scratchPoint","transform","getScaling","Math","max","distanceSquaredTo","d","distanceTo","delta","len","intersectPlane","plane","normal","distanceToPlane","dot","OUTSIDE","INTERSECTING","INSIDE"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\culling\\src\\lib\\bounding-volumes\\bounding-sphere.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {NumericArray, Vector3, mat4} from '@math.gl/core';\n\nimport {INTERSECTION} from '../../constants';\nimport {BoundingVolume} from './bounding-volume';\nimport {Plane} from '../plane';\n\nconst scratchVector = new Vector3();\nconst scratchVector2 = new Vector3();\n\n/** A BoundingSphere */\nexport class BoundingSphere implements BoundingVolume {\n  center: Vector3;\n  radius: number;\n\n  /** Creates a bounding sphere */\n  constructor(center: readonly number[] = [0, 0, 0], radius: number = 0.0) {\n    this.radius = -0;\n    this.center = new Vector3();\n    this.fromCenterRadius(center, radius);\n  }\n\n  /** Sets the bounding sphere from `center` and `radius`. */\n  fromCenterRadius(center: readonly number[], radius: number): this {\n    this.center.from(center);\n    this.radius = radius;\n    return this;\n  }\n\n  /**\n   * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\n   * tightly and fully encompasses the box.\n   */\n  fromCornerPoints(corner: readonly number[], oppositeCorner: readonly number[]): this {\n    oppositeCorner = scratchVector.from(oppositeCorner);\n    this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);\n    this.radius = this.center.distance(oppositeCorner);\n    return this;\n  }\n\n  /** Compares the provided BoundingSphere component wise */\n  equals(right: BoundingSphere): boolean {\n    return (\n      this === right ||\n      (Boolean(right) && this.center.equals(right.center) && this.radius === right.radius)\n    );\n  }\n\n  /** Duplicates a BoundingSphere instance. */\n  clone(): BoundingSphere {\n    return new BoundingSphere(this.center, this.radius);\n  }\n\n  /** Computes a bounding sphere that contains both the left and right bounding spheres. */\n  union(boundingSphere: BoundingSphere): BoundingSphere {\n    const leftCenter = this.center;\n    const leftRadius = this.radius;\n    const rightCenter = boundingSphere.center;\n    const rightRadius = boundingSphere.radius;\n\n    const toRightCenter = scratchVector.copy(rightCenter).subtract(leftCenter);\n    const centerSeparation = toRightCenter.magnitude();\n\n    if (leftRadius >= centerSeparation + rightRadius) {\n      // Left sphere wins.\n      return this.clone();\n    }\n\n    if (rightRadius >= centerSeparation + leftRadius) {\n      // Right sphere wins.\n      return boundingSphere.clone();\n    }\n\n    // There are two tangent points, one on far side of each sphere.\n    const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n\n    // Compute the center point halfway between the two tangent points.\n    scratchVector2\n      .copy(toRightCenter)\n      .scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation)\n      .add(leftCenter);\n\n    this.center.copy(scratchVector2);\n    this.radius = halfDistanceBetweenTangentPoints;\n\n    return this;\n  }\n\n  /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */\n  expand(point: readonly number[]): this {\n    const scratchPoint = scratchVector.from(point);\n    const radius = scratchPoint.subtract(this.center).magnitude();\n    if (radius > this.radius) {\n      this.radius = radius;\n    }\n    return this;\n  }\n\n  // BoundingVolume interface\n\n  /**\n   * Applies a 4x4 affine transformation matrix to a bounding sphere.\n   * @param sphere The bounding sphere to apply the transformation to.\n   * @param transform The transformation matrix to apply to the bounding sphere.\n   * @returns self.\n   */\n  transform(transform: readonly number[]): this {\n    this.center.transform(transform);\n    const scale = mat4.getScaling(scratchVector, transform);\n    this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;\n    return this;\n  }\n\n  /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */\n  distanceSquaredTo(point: Readonly<NumericArray>): number {\n    const d = this.distanceTo(point);\n    return d * d;\n  }\n\n  /** Computes the estimated distance from the closest point on a bounding sphere to a point. */\n  distanceTo(point: Readonly<NumericArray>): number {\n    const scratchPoint = scratchVector.from(point);\n    const delta = scratchPoint.subtract(this.center);\n    return Math.max(0, delta.len() - this.radius);\n  }\n\n  /** Determines which side of a plane a sphere is located. */\n  intersectPlane(plane: Plane): number {\n    const center = this.center;\n    const radius = this.radius;\n    const normal = plane.normal;\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    // The center point is negative side of the plane normal\n    if (distanceToPlane < -radius) {\n      return INTERSECTION.OUTSIDE;\n    }\n    // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n    if (distanceToPlane < radius) {\n      return INTERSECTION.INTERSECTING;\n    }\n    // The center point and radius is positive side of the plane\n    return INTERSECTION.INSIDE;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}