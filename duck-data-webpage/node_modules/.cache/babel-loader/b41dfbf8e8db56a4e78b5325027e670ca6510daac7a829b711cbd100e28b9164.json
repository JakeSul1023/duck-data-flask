{"ast":null,"code":"import { load } from '@loaders.gl/core';\nimport { TilesetTraverser } from \"../tileset-traverser.js\";\nimport { getLodStatus } from \"../helpers/i3s-lod.js\";\nimport { Tile3D } from \"../tile-3d.js\";\nimport { I3STileManager } from \"./i3s-tile-manager.js\";\nexport class I3STilesetTraverser extends TilesetTraverser {\n  _tileManager;\n  constructor(options) {\n    super(options);\n    this._tileManager = new I3STileManager();\n  }\n  /**\n   * Check if there are no penging tile header requests,\n   * that means the traversal is finished and we can call\n   * following-up callbacks.\n   */\n  traversalFinished(frameState) {\n    return !this._tileManager.hasPendingTiles(frameState.viewport.id, this._frameNumber || 0);\n  }\n  shouldRefine(tile, frameState) {\n    tile._lodJudge = getLodStatus(tile, frameState);\n    return tile._lodJudge === 'DIG';\n  }\n  updateChildTiles(tile, frameState) {\n    const children = tile.header.children || [];\n    // children which are already fetched and constructed as Tile3D instances\n    const childTiles = tile.children;\n    const tileset = tile.tileset;\n    for (const child of children) {\n      const extendedId = `${child.id}-${frameState.viewport.id}`;\n      // if child tile is not fetched\n      const childTile = childTiles && childTiles.find(t => t.id === extendedId);\n      if (!childTile) {\n        let request = () => this._loadTile(child.id, tileset);\n        const cachedRequest = this._tileManager.find(extendedId);\n        if (!cachedRequest) {\n          // eslint-disable-next-line max-depth\n          if (tileset.tileset.nodePages) {\n            request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);\n          }\n          this._tileManager.add(request, extendedId, header => this._onTileLoad(header, tile, extendedId), frameState);\n        } else {\n          // update frameNumber since it is still needed in current frame\n          this._tileManager.update(extendedId, frameState);\n        }\n      } else if (childTile) {\n        // if child tile is fetched and available\n        this.updateTile(childTile, frameState);\n      }\n    }\n    return false;\n  }\n  async _loadTile(nodeId, tileset) {\n    const {\n      loader\n    } = tileset;\n    const nodeUrl = tileset.getTileUrl(`${tileset.url}/nodes/${nodeId}`);\n    // load metadata\n    const options = {\n      ...tileset.loadOptions,\n      i3s: {\n        ...tileset.loadOptions.i3s,\n        isTileHeader: true\n      }\n    };\n    return await load(nodeUrl, loader, options);\n  }\n  /**\n   * The callback to init Tile3D instance after loading the tile JSON\n   * @param {Object} header - the tile JSON from a dataset\n   * @param {Tile3D} tile - the parent Tile3D instance\n   * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.\n   *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;\n   * @return {void}\n   */\n  _onTileLoad(header, tile, extendedId) {\n    // after child tile is fetched\n    const childTile = new Tile3D(tile.tileset, header, tile, extendedId);\n    tile.children.push(childTile);\n    const frameState = this._tileManager.find(childTile.id).frameState;\n    this.updateTile(childTile, frameState);\n    // after tile fetched, resume traversal if still in current update/traversal frame\n    if (this._frameNumber === frameState.frameNumber && (this.traversalFinished(frameState) || new Date().getTime() - this.lastUpdate > this.updateDebounceTime)) {\n      this.executeTraversal(childTile, frameState);\n    }\n  }\n}","map":{"version":3,"names":["load","TilesetTraverser","getLodStatus","Tile3D","I3STileManager","I3STilesetTraverser","_tileManager","constructor","options","traversalFinished","frameState","hasPendingTiles","viewport","id","_frameNumber","shouldRefine","tile","_lodJudge","updateChildTiles","children","header","childTiles","tileset","child","extendedId","childTile","find","t","request","_loadTile","cachedRequest","nodePages","nodePagesTile","formTileFromNodePages","add","_onTileLoad","update","updateTile","nodeId","loader","nodeUrl","getTileUrl","url","loadOptions","i3s","isTileHeader","push","frameNumber","Date","getTime","lastUpdate","updateDebounceTime","executeTraversal"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/tiles/dist/tileset/format-i3s/i3s-tileset-traverser.js"],"sourcesContent":["import { load } from '@loaders.gl/core';\nimport { TilesetTraverser } from \"../tileset-traverser.js\";\nimport { getLodStatus } from \"../helpers/i3s-lod.js\";\nimport { Tile3D } from \"../tile-3d.js\";\nimport { I3STileManager } from \"./i3s-tile-manager.js\";\nexport class I3STilesetTraverser extends TilesetTraverser {\n    _tileManager;\n    constructor(options) {\n        super(options);\n        this._tileManager = new I3STileManager();\n    }\n    /**\n     * Check if there are no penging tile header requests,\n     * that means the traversal is finished and we can call\n     * following-up callbacks.\n     */\n    traversalFinished(frameState) {\n        return !this._tileManager.hasPendingTiles(frameState.viewport.id, this._frameNumber || 0);\n    }\n    shouldRefine(tile, frameState) {\n        tile._lodJudge = getLodStatus(tile, frameState);\n        return tile._lodJudge === 'DIG';\n    }\n    updateChildTiles(tile, frameState) {\n        const children = tile.header.children || [];\n        // children which are already fetched and constructed as Tile3D instances\n        const childTiles = tile.children;\n        const tileset = tile.tileset;\n        for (const child of children) {\n            const extendedId = `${child.id}-${frameState.viewport.id}`;\n            // if child tile is not fetched\n            const childTile = childTiles && childTiles.find((t) => t.id === extendedId);\n            if (!childTile) {\n                let request = () => this._loadTile(child.id, tileset);\n                const cachedRequest = this._tileManager.find(extendedId);\n                if (!cachedRequest) {\n                    // eslint-disable-next-line max-depth\n                    if (tileset.tileset.nodePages) {\n                        request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);\n                    }\n                    this._tileManager.add(request, extendedId, (header) => this._onTileLoad(header, tile, extendedId), frameState);\n                }\n                else {\n                    // update frameNumber since it is still needed in current frame\n                    this._tileManager.update(extendedId, frameState);\n                }\n            }\n            else if (childTile) {\n                // if child tile is fetched and available\n                this.updateTile(childTile, frameState);\n            }\n        }\n        return false;\n    }\n    async _loadTile(nodeId, tileset) {\n        const { loader } = tileset;\n        const nodeUrl = tileset.getTileUrl(`${tileset.url}/nodes/${nodeId}`);\n        // load metadata\n        const options = {\n            ...tileset.loadOptions,\n            i3s: {\n                ...tileset.loadOptions.i3s,\n                isTileHeader: true\n            }\n        };\n        return await load(nodeUrl, loader, options);\n    }\n    /**\n     * The callback to init Tile3D instance after loading the tile JSON\n     * @param {Object} header - the tile JSON from a dataset\n     * @param {Tile3D} tile - the parent Tile3D instance\n     * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.\n     *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;\n     * @return {void}\n     */\n    _onTileLoad(header, tile, extendedId) {\n        // after child tile is fetched\n        const childTile = new Tile3D(tile.tileset, header, tile, extendedId);\n        tile.children.push(childTile);\n        const frameState = this._tileManager.find(childTile.id).frameState;\n        this.updateTile(childTile, frameState);\n        // after tile fetched, resume traversal if still in current update/traversal frame\n        if (this._frameNumber === frameState.frameNumber &&\n            (this.traversalFinished(frameState) ||\n                new Date().getTime() - this.lastUpdate > this.updateDebounceTime)) {\n            this.executeTraversal(childTile, frameState);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}