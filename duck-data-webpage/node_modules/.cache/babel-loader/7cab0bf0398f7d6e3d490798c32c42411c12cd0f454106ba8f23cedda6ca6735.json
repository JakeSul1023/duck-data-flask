{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ArrowLikeField } from \"./arrow-like-field.js\";\nexport class ArrowLikeSchema {\n  fields;\n  metadata;\n  constructor(fields, metadata = new Map()) {\n    // checkNames(fields);\n    // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`\n    this.fields = fields.map(field => new ArrowLikeField(field.name, field.type, field.nullable, field.metadata));\n    this.metadata = metadata instanceof Map ? metadata : new Map(Object.entries(metadata));\n  }\n  // TODO - arrow only seems to compare fields, not metadata\n  compareTo(other) {\n    if (this.metadata !== other.metadata) {\n      return false;\n    }\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  select(...columnNames) {\n    // Ensure column names reference valid fields\n    const nameMap = Object.create(null);\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n    const selectedFields = this.fields.filter(field => nameMap[field.name]);\n    return new ArrowLikeSchema(selectedFields, this.metadata);\n  }\n  selectAt(...columnIndices) {\n    // Ensure column indices reference valid fields\n    const selectedFields = columnIndices.map(index => this.fields[index]).filter(Boolean);\n    return new ArrowLikeSchema(selectedFields, this.metadata);\n  }\n  assign(schemaOrFields) {\n    let fields;\n    let metadata = this.metadata;\n    if (schemaOrFields instanceof ArrowLikeSchema) {\n      const otherArrowLikeSchema = schemaOrFields;\n      fields = otherArrowLikeSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherArrowLikeSchema.metadata);\n    } else {\n      fields = schemaOrFields;\n    }\n    // Create a merged list of fields, overwrite fields in place, new fields at end\n    const fieldMap = Object.create(null);\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n    const mergedFields = Object.values(fieldMap);\n    return new ArrowLikeSchema(mergedFields, metadata);\n  }\n}\n// Warn if any duplicated field names\n// function checkNames(fields: Field[]): void {\n//   const usedNames: Record<string, boolean> = {};\n//   for (const field of fields) {\n//     if (usedNames[field.name]) {\n//       // eslint-disable-next-line\n//       console.warn('ArrowLikeSchema: duplicated field name', field.name, field);\n//     }\n//     usedNames[field.name] = true;\n//   }\n// }\nfunction mergeMaps(m1, m2) {\n  // @ts-ignore\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}","map":{"version":3,"names":["ArrowLikeField","ArrowLikeSchema","fields","metadata","constructor","Map","map","field","name","type","nullable","Object","entries","compareTo","other","length","i","select","columnNames","nameMap","create","selectedFields","filter","selectAt","columnIndices","index","Boolean","assign","schemaOrFields","otherArrowLikeSchema","mergeMaps","fieldMap","mergedFields","values","m1","m2"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/schema/dist/lib/table/arrow-api/arrow-like-schema.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ArrowLikeField } from \"./arrow-like-field.js\";\nexport class ArrowLikeSchema {\n    fields;\n    metadata;\n    constructor(fields, metadata = new Map()) {\n        // checkNames(fields);\n        // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`\n        this.fields = fields.map((field) => new ArrowLikeField(field.name, field.type, field.nullable, field.metadata));\n        this.metadata =\n            metadata instanceof Map ? metadata : new Map(Object.entries(metadata));\n    }\n    // TODO - arrow only seems to compare fields, not metadata\n    compareTo(other) {\n        if (this.metadata !== other.metadata) {\n            return false;\n        }\n        if (this.fields.length !== other.fields.length) {\n            return false;\n        }\n        for (let i = 0; i < this.fields.length; ++i) {\n            if (!this.fields[i].compareTo(other.fields[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    select(...columnNames) {\n        // Ensure column names reference valid fields\n        const nameMap = Object.create(null);\n        for (const name of columnNames) {\n            nameMap[name] = true;\n        }\n        const selectedFields = this.fields.filter((field) => nameMap[field.name]);\n        return new ArrowLikeSchema(selectedFields, this.metadata);\n    }\n    selectAt(...columnIndices) {\n        // Ensure column indices reference valid fields\n        const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);\n        return new ArrowLikeSchema(selectedFields, this.metadata);\n    }\n    assign(schemaOrFields) {\n        let fields;\n        let metadata = this.metadata;\n        if (schemaOrFields instanceof ArrowLikeSchema) {\n            const otherArrowLikeSchema = schemaOrFields;\n            fields = otherArrowLikeSchema.fields;\n            metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherArrowLikeSchema.metadata);\n        }\n        else {\n            fields = schemaOrFields;\n        }\n        // Create a merged list of fields, overwrite fields in place, new fields at end\n        const fieldMap = Object.create(null);\n        for (const field of this.fields) {\n            fieldMap[field.name] = field;\n        }\n        for (const field of fields) {\n            fieldMap[field.name] = field;\n        }\n        const mergedFields = Object.values(fieldMap);\n        return new ArrowLikeSchema(mergedFields, metadata);\n    }\n}\n// Warn if any duplicated field names\n// function checkNames(fields: Field[]): void {\n//   const usedNames: Record<string, boolean> = {};\n//   for (const field of fields) {\n//     if (usedNames[field.name]) {\n//       // eslint-disable-next-line\n//       console.warn('ArrowLikeSchema: duplicated field name', field.name, field);\n//     }\n//     usedNames[field.name] = true;\n//   }\n// }\nfunction mergeMaps(m1, m2) {\n    // @ts-ignore\n    return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}