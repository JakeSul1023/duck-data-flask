{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Buffer } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\n/** WebGL Buffer interface */\nexport class WEBGLBuffer extends Buffer {\n  device;\n  gl;\n  handle;\n  /** Target in OpenGL defines the type of buffer */\n  glTarget;\n  /** Usage is a hint on how frequently the buffer will be updates */\n  glUsage;\n  /** Index type is needed when issuing draw calls, so we pre-compute it */\n  glIndexType = 5123;\n  /** Number of bytes allocated on the GPU for this buffer */\n  byteLength;\n  /** Number of bytes used */\n  bytesUsed;\n  constructor(device, props = {}) {\n    super(device, props);\n    this.device = device;\n    this.gl = this.device.gl;\n    const handle = typeof props === 'object' ? props.handle : undefined;\n    this.handle = handle || this.gl.createBuffer();\n    device.setSpectorMetadata(this.handle, {\n      ...this.props,\n      data: typeof this.props.data\n    });\n    // - In WebGL1, need to make sure we use GL.ELEMENT_ARRAY_BUFFER when initializing element buffers\n    //   otherwise buffer type will lock to generic (non-element) buffer\n    // - In WebGL2, we can use GL.COPY_READ_BUFFER which avoids locking the type here\n    this.glTarget = getWebGLTarget(this.props.usage);\n    this.glUsage = getWebGLUsage(this.props.usage);\n    this.glIndexType = this.props.indexType === 'uint32' ? 5125 : 5123;\n    // Set data: (re)initializes the buffer\n    if (props.data) {\n      this._initWithData(props.data, props.byteOffset, props.byteLength);\n    } else {\n      this._initWithByteLength(props.byteLength || 0);\n    }\n  }\n  // PRIVATE METHODS\n  /** Allocate a new buffer and initialize to contents of typed array */\n  _initWithData(data, byteOffset = 0, byteLength = data.byteLength + byteOffset) {\n    // const glTarget = this.device.isWebGL2 ? GL.COPY_WRITE_BUFFER : this.glTarget;\n    const glTarget = this.glTarget;\n    this.gl.bindBuffer(glTarget, this.handle);\n    this.gl.bufferData(glTarget, byteLength, this.glUsage);\n    this.gl.bufferSubData(glTarget, byteOffset, data);\n    this.gl.bindBuffer(glTarget, null);\n    this.bytesUsed = byteLength;\n    this.byteLength = byteLength;\n    this._setDebugData(data, byteOffset, byteLength);\n    this.trackAllocatedMemory(byteLength);\n  }\n  // Allocate a GPU buffer of specified size.\n  _initWithByteLength(byteLength) {\n    // assert(byteLength >= 0);\n    // Workaround needed for Safari (#291):\n    // gl.bufferData with size equal to 0 crashes. Instead create zero sized array.\n    let data = byteLength;\n    if (byteLength === 0) {\n      // @ts-expect-error\n      data = new Float32Array(0);\n    }\n    // const glTarget = this.device.isWebGL2 ? GL.COPY_WRITE_BUFFER : this.glTarget;\n    const glTarget = this.glTarget;\n    this.gl.bindBuffer(glTarget, this.handle);\n    this.gl.bufferData(glTarget, data, this.glUsage);\n    this.gl.bindBuffer(glTarget, null);\n    this.bytesUsed = byteLength;\n    this.byteLength = byteLength;\n    this._setDebugData(null, 0, byteLength);\n    this.trackAllocatedMemory(byteLength);\n    return this;\n  }\n  destroy() {\n    if (!this.destroyed && this.handle) {\n      this.removeStats();\n      this.trackDeallocatedMemory();\n      this.gl.deleteBuffer(this.handle);\n      this.destroyed = true;\n      // @ts-expect-error\n      this.handle = null;\n    }\n  }\n  write(data, byteOffset = 0) {\n    const srcOffset = 0;\n    const byteLength = undefined; // data.byteLength;\n    // Create the buffer - binding it here for the first time locks the type\n    // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type\n    const glTarget = 36663;\n    this.gl.bindBuffer(glTarget, this.handle);\n    // WebGL2: subData supports additional srcOffset and length parameters\n    if (srcOffset !== 0 || byteLength !== undefined) {\n      this.gl.bufferSubData(glTarget, byteOffset, data, srcOffset, byteLength);\n    } else {\n      this.gl.bufferSubData(glTarget, byteOffset, data);\n    }\n    this.gl.bindBuffer(glTarget, null);\n    this._setDebugData(data, byteOffset, data.byteLength);\n  }\n  /** Asynchronously read data from the buffer */\n  async readAsync(byteOffset = 0, byteLength) {\n    return this.readSyncWebGL(byteOffset, byteLength);\n  }\n  /** Synchronously read data from the buffer. WebGL only. */\n  readSyncWebGL(byteOffset = 0, byteLength) {\n    byteLength = byteLength ?? this.byteLength - byteOffset;\n    const data = new Uint8Array(byteLength);\n    const dstOffset = 0;\n    // Use GL.COPY_READ_BUFFER to avoid disturbing other targets and locking type\n    this.gl.bindBuffer(36662, this.handle);\n    this.gl.getBufferSubData(36662, byteOffset, data, dstOffset, byteLength);\n    this.gl.bindBuffer(36662, null);\n    // Update local `data` if offsets are 0\n    this._setDebugData(data, byteOffset, byteLength);\n    return data;\n  }\n}\n/**\n * Returns a WebGL buffer target\n *\n * @param usage\n * static MAP_READ = 0x01;\n * static MAP_WRITE = 0x02;\n * static COPY_SRC = 0x0004;\n * static COPY_DST = 0x0008;\n * static INDEX = 0x0010;\n * static VERTEX = 0x0020;\n * static UNIFORM = 0x0040;\n * static STORAGE = 0x0080;\n * static INDIRECT = 0x0100;\n * static QUERY_RESOLVE = 0x0200;\n *\n * @returns WebGL buffer targe\n *\n * Buffer bind points in WebGL2\n * gl.COPY_READ_BUFFER: Buffer for copying from one buffer object to another.\n * gl.COPY_WRITE_BUFFER: Buffer for copying from one buffer object to another.\n * gl.TRANSFORM_FEEDBACK_BUFFER: Buffer for transform feedback operations.\n * gl.PIXEL_PACK_BUFFER: Buffer used for pixel transfer operations.\n * gl.PIXEL_UNPACK_BUFFER: Buffer used for pixel transfer operations.\n */\nfunction getWebGLTarget(usage) {\n  if (usage & Buffer.INDEX) {\n    return 34963;\n  }\n  if (usage & Buffer.VERTEX) {\n    return 34962;\n  }\n  if (usage & Buffer.UNIFORM) {\n    return 35345;\n  }\n  // Binding a buffer for the first time locks the type\n  // In WebGL2, we can use GL.COPY_WRITE_BUFFER to avoid locking the type\n  return 34962;\n}\n/** @todo usage is not passed correctly */\nfunction getWebGLUsage(usage) {\n  if (usage & Buffer.INDEX) {\n    return 35044;\n  }\n  if (usage & Buffer.VERTEX) {\n    return 35044;\n  }\n  if (usage & Buffer.UNIFORM) {\n    return 35048;\n  }\n  return 35044;\n}","map":{"version":3,"names":["Buffer","GL","WEBGLBuffer","device","gl","handle","glTarget","glUsage","glIndexType","byteLength","bytesUsed","constructor","props","undefined","createBuffer","setSpectorMetadata","data","getWebGLTarget","usage","getWebGLUsage","indexType","_initWithData","byteOffset","_initWithByteLength","bindBuffer","bufferData","bufferSubData","_setDebugData","trackAllocatedMemory","Float32Array","destroy","destroyed","removeStats","trackDeallocatedMemory","deleteBuffer","write","srcOffset","readAsync","readSyncWebGL","Uint8Array","dstOffset","getBufferSubData","INDEX","VERTEX","UNIFORM"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\webgl\\src\\adapter\\resources\\webgl-buffer.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {BufferProps} from '@luma.gl/core';\nimport {Buffer} from '@luma.gl/core';\nimport {GL} from '@luma.gl/constants';\nimport {WebGLDevice} from '../webgl-device';\n\n/** WebGL Buffer interface */\nexport class WEBGLBuffer extends Buffer {\n  readonly device: WebGLDevice;\n  readonly gl: WebGL2RenderingContext;\n  readonly handle: WebGLBuffer;\n\n  /** Target in OpenGL defines the type of buffer */\n  readonly glTarget: GL.ARRAY_BUFFER | GL.ELEMENT_ARRAY_BUFFER | GL.UNIFORM_BUFFER;\n  /** Usage is a hint on how frequently the buffer will be updates */\n  readonly glUsage: GL.STATIC_DRAW | GL.DYNAMIC_DRAW;\n  /** Index type is needed when issuing draw calls, so we pre-compute it */\n  readonly glIndexType: GL.UNSIGNED_SHORT | GL.UNSIGNED_INT = GL.UNSIGNED_SHORT;\n\n  /** Number of bytes allocated on the GPU for this buffer */\n  byteLength: number;\n  /** Number of bytes used */\n  bytesUsed: number;\n\n  constructor(device: WebGLDevice, props: BufferProps = {}) {\n    super(device, props);\n\n    this.device = device;\n    this.gl = this.device.gl;\n\n    const handle = typeof props === 'object' ? props.handle : undefined;\n    this.handle = handle || this.gl.createBuffer();\n    device.setSpectorMetadata(this.handle, {...this.props, data: typeof this.props.data});\n\n    // - In WebGL1, need to make sure we use GL.ELEMENT_ARRAY_BUFFER when initializing element buffers\n    //   otherwise buffer type will lock to generic (non-element) buffer\n    // - In WebGL2, we can use GL.COPY_READ_BUFFER which avoids locking the type here\n    this.glTarget = getWebGLTarget(this.props.usage);\n    this.glUsage = getWebGLUsage(this.props.usage);\n    this.glIndexType = this.props.indexType === 'uint32' ? GL.UNSIGNED_INT : GL.UNSIGNED_SHORT;\n\n    // Set data: (re)initializes the buffer\n    if (props.data) {\n      this._initWithData(props.data, props.byteOffset, props.byteLength);\n    } else {\n      this._initWithByteLength(props.byteLength || 0);\n    }\n  }\n\n  // PRIVATE METHODS\n\n  /** Allocate a new buffer and initialize to contents of typed array */\n  _initWithData(\n    data: ArrayBuffer | ArrayBufferView,\n    byteOffset: number = 0,\n    byteLength: number = data.byteLength + byteOffset\n  ): void {\n    // const glTarget = this.device.isWebGL2 ? GL.COPY_WRITE_BUFFER : this.glTarget;\n    const glTarget = this.glTarget;\n    this.gl.bindBuffer(glTarget, this.handle);\n    this.gl.bufferData(glTarget, byteLength, this.glUsage);\n    this.gl.bufferSubData(glTarget, byteOffset, data);\n    this.gl.bindBuffer(glTarget, null);\n\n    this.bytesUsed = byteLength;\n    this.byteLength = byteLength;\n\n    this._setDebugData(data, byteOffset, byteLength);\n    this.trackAllocatedMemory(byteLength);\n  }\n\n  // Allocate a GPU buffer of specified size.\n  _initWithByteLength(byteLength: number): this {\n    // assert(byteLength >= 0);\n\n    // Workaround needed for Safari (#291):\n    // gl.bufferData with size equal to 0 crashes. Instead create zero sized array.\n    let data = byteLength;\n    if (byteLength === 0) {\n      // @ts-expect-error\n      data = new Float32Array(0);\n    }\n\n    // const glTarget = this.device.isWebGL2 ? GL.COPY_WRITE_BUFFER : this.glTarget;\n    const glTarget = this.glTarget;\n\n    this.gl.bindBuffer(glTarget, this.handle);\n    this.gl.bufferData(glTarget, data, this.glUsage);\n    this.gl.bindBuffer(glTarget, null);\n\n    this.bytesUsed = byteLength;\n    this.byteLength = byteLength;\n\n    this._setDebugData(null, 0, byteLength);\n    this.trackAllocatedMemory(byteLength);\n\n    return this;\n  }\n\n  override destroy(): void {\n    if (!this.destroyed && this.handle) {\n      this.removeStats();\n      this.trackDeallocatedMemory();\n      this.gl.deleteBuffer(this.handle);\n      this.destroyed = true;\n      // @ts-expect-error\n      this.handle = null;\n    }\n  }\n\n  override write(data: ArrayBufferView, byteOffset: number = 0): void {\n    const srcOffset = 0;\n    const byteLength = undefined; // data.byteLength;\n\n    // Create the buffer - binding it here for the first time locks the type\n    // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type\n    const glTarget = GL.COPY_WRITE_BUFFER;\n    this.gl.bindBuffer(glTarget, this.handle);\n    // WebGL2: subData supports additional srcOffset and length parameters\n    if (srcOffset !== 0 || byteLength !== undefined) {\n      this.gl.bufferSubData(glTarget, byteOffset, data, srcOffset, byteLength);\n    } else {\n      this.gl.bufferSubData(glTarget, byteOffset, data);\n    }\n    this.gl.bindBuffer(glTarget, null);\n\n    this._setDebugData(data, byteOffset, data.byteLength);\n  }\n\n  /** Asynchronously read data from the buffer */\n  override async readAsync(byteOffset = 0, byteLength?: number): Promise<Uint8Array> {\n    return this.readSyncWebGL(byteOffset, byteLength);\n  }\n\n  /** Synchronously read data from the buffer. WebGL only. */\n  override readSyncWebGL(byteOffset = 0, byteLength?: number): Uint8Array {\n    byteLength = byteLength ?? this.byteLength - byteOffset;\n    const data = new Uint8Array(byteLength);\n    const dstOffset = 0;\n\n    // Use GL.COPY_READ_BUFFER to avoid disturbing other targets and locking type\n    this.gl.bindBuffer(GL.COPY_READ_BUFFER, this.handle);\n    this.gl.getBufferSubData(GL.COPY_READ_BUFFER, byteOffset, data, dstOffset, byteLength);\n    this.gl.bindBuffer(GL.COPY_READ_BUFFER, null);\n\n    // Update local `data` if offsets are 0\n    this._setDebugData(data, byteOffset, byteLength);\n\n    return data;\n  }\n}\n\n/**\n * Returns a WebGL buffer target\n *\n * @param usage\n * static MAP_READ = 0x01;\n * static MAP_WRITE = 0x02;\n * static COPY_SRC = 0x0004;\n * static COPY_DST = 0x0008;\n * static INDEX = 0x0010;\n * static VERTEX = 0x0020;\n * static UNIFORM = 0x0040;\n * static STORAGE = 0x0080;\n * static INDIRECT = 0x0100;\n * static QUERY_RESOLVE = 0x0200;\n *\n * @returns WebGL buffer targe\n *\n * Buffer bind points in WebGL2\n * gl.COPY_READ_BUFFER: Buffer for copying from one buffer object to another.\n * gl.COPY_WRITE_BUFFER: Buffer for copying from one buffer object to another.\n * gl.TRANSFORM_FEEDBACK_BUFFER: Buffer for transform feedback operations.\n * gl.PIXEL_PACK_BUFFER: Buffer used for pixel transfer operations.\n * gl.PIXEL_UNPACK_BUFFER: Buffer used for pixel transfer operations.\n */\nfunction getWebGLTarget(\n  usage: number\n): GL.ARRAY_BUFFER | GL.ELEMENT_ARRAY_BUFFER | GL.UNIFORM_BUFFER {\n  if (usage & Buffer.INDEX) {\n    return GL.ELEMENT_ARRAY_BUFFER;\n  }\n  if (usage & Buffer.VERTEX) {\n    return GL.ARRAY_BUFFER;\n  }\n  if (usage & Buffer.UNIFORM) {\n    return GL.UNIFORM_BUFFER;\n  }\n\n  // Binding a buffer for the first time locks the type\n  // In WebGL2, we can use GL.COPY_WRITE_BUFFER to avoid locking the type\n  return GL.ARRAY_BUFFER;\n}\n\n/** @todo usage is not passed correctly */\nfunction getWebGLUsage(usage: number): GL.STATIC_DRAW | GL.DYNAMIC_DRAW {\n  if (usage & Buffer.INDEX) {\n    return GL.STATIC_DRAW;\n  }\n  if (usage & Buffer.VERTEX) {\n    return GL.STATIC_DRAW;\n  }\n  if (usage & Buffer.UNIFORM) {\n    return GL.DYNAMIC_DRAW;\n  }\n  return GL.STATIC_DRAW;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}