{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { compareArrayBuffers, concatenateArrayBuffers } from '@loaders.gl/loader-utils';\nimport { createZip64Info, setFieldToNumber } from \"./zip64-info-generation.js\";\n// offsets accroding to https://en.wikipedia.org/wiki/ZIP_(file_format)\nconst COMPRESSION_METHOD_OFFSET = 8;\nconst COMPRESSED_SIZE_OFFSET = 18;\nconst UNCOMPRESSED_SIZE_OFFSET = 22;\nconst FILE_NAME_LENGTH_OFFSET = 26;\nconst EXTRA_FIELD_LENGTH_OFFSET = 28;\nconst FILE_NAME_OFFSET = 30n;\nexport const signature = new Uint8Array([0x50, 0x4b, 0x03, 0x04]);\n/**\n * Parses local file header of zip file\n * @param headerOffset - offset in the archive where header starts\n * @param buffer - buffer containing whole array\n * @returns Info from the header\n */\nexport const parseZipLocalFileHeader = async (headerOffset, file) => {\n  const mainHeader = new DataView(await file.slice(headerOffset, headerOffset + FILE_NAME_OFFSET));\n  const magicBytes = mainHeader.buffer.slice(0, 4);\n  if (!compareArrayBuffers(magicBytes, signature)) {\n    return null;\n  }\n  const fileNameLength = mainHeader.getUint16(FILE_NAME_LENGTH_OFFSET, true);\n  const extraFieldLength = mainHeader.getUint16(EXTRA_FIELD_LENGTH_OFFSET, true);\n  const additionalHeader = await file.slice(headerOffset + FILE_NAME_OFFSET, headerOffset + FILE_NAME_OFFSET + BigInt(fileNameLength + extraFieldLength));\n  const fileNameBuffer = additionalHeader.slice(0, fileNameLength);\n  const extraDataBuffer = new DataView(additionalHeader.slice(fileNameLength, additionalHeader.byteLength));\n  const fileName = new TextDecoder().decode(fileNameBuffer).split('\\\\').join('/');\n  let fileDataOffset = headerOffset + FILE_NAME_OFFSET + BigInt(fileNameLength + extraFieldLength);\n  const compressionMethod = mainHeader.getUint16(COMPRESSION_METHOD_OFFSET, true);\n  let compressedSize = BigInt(mainHeader.getUint32(COMPRESSED_SIZE_OFFSET, true)); // add zip 64 logic\n  let uncompressedSize = BigInt(mainHeader.getUint32(UNCOMPRESSED_SIZE_OFFSET, true)); // add zip 64 logic\n  let offsetInZip64Data = 4;\n  // looking for info that might be also be in zip64 extra field\n  if (uncompressedSize === BigInt(0xffffffff)) {\n    uncompressedSize = extraDataBuffer.getBigUint64(offsetInZip64Data, true);\n    offsetInZip64Data += 8;\n  }\n  if (compressedSize === BigInt(0xffffffff)) {\n    compressedSize = extraDataBuffer.getBigUint64(offsetInZip64Data, true);\n    offsetInZip64Data += 8;\n  }\n  if (fileDataOffset === BigInt(0xffffffff)) {\n    fileDataOffset = extraDataBuffer.getBigUint64(offsetInZip64Data, true); // setting it to the one from zip64\n  }\n  return {\n    fileNameLength,\n    fileName,\n    extraFieldLength,\n    fileDataOffset,\n    compressedSize,\n    compressionMethod\n  };\n};\n/**\n * generates local header for the file\n * @param options info that can be placed into local header\n * @returns buffer with header\n */\nexport function generateLocalHeader(options) {\n  const optionsToUse = {\n    ...options,\n    extraLength: 0,\n    fnlength: options.fileName.length\n  };\n  let zip64header = new ArrayBuffer(0);\n  const optionsToZip64 = {};\n  if (optionsToUse.length >= 0xffffffff) {\n    optionsToZip64.size = optionsToUse.length;\n    optionsToUse.length = 0xffffffff;\n  }\n  if (Object.keys(optionsToZip64).length) {\n    zip64header = createZip64Info(optionsToZip64);\n    optionsToUse.extraLength = zip64header.byteLength;\n  }\n  // base length without file name and extra info is static\n  const header = new DataView(new ArrayBuffer(Number(FILE_NAME_OFFSET)));\n  for (const field of ZIP_HEADER_FIELDS) {\n    setFieldToNumber(header, field.size, field.offset, optionsToUse[field.name ?? ''] ?? field.default ?? 0);\n  }\n  const encodedName = new TextEncoder().encode(optionsToUse.fileName);\n  const resHeader = concatenateArrayBuffers(header.buffer, encodedName, zip64header);\n  return resHeader;\n}\nconst ZIP_HEADER_FIELDS = [\n// Local file header signature = 0x04034b50\n{\n  offset: 0,\n  size: 4,\n  default: new DataView(signature.buffer).getUint32(0, true)\n},\n// Version needed to extract (minimum)\n{\n  offset: 4,\n  size: 2,\n  default: 45\n},\n// General purpose bit flag\n{\n  offset: 6,\n  size: 2,\n  default: 0\n},\n// Compression method\n{\n  offset: 8,\n  size: 2,\n  default: 0\n},\n// File last modification time\n{\n  offset: 10,\n  size: 2,\n  default: 0\n},\n// File last modification date\n{\n  offset: 12,\n  size: 2,\n  default: 0\n},\n// CRC-32 of uncompressed data\n{\n  offset: 14,\n  size: 4,\n  name: 'crc32'\n},\n// Compressed size (or 0xffffffff for ZIP64)\n{\n  offset: 18,\n  size: 4,\n  name: 'length'\n},\n// Uncompressed size (or 0xffffffff for ZIP64)\n{\n  offset: 22,\n  size: 4,\n  name: 'length'\n},\n// File name length (n)\n{\n  offset: 26,\n  size: 2,\n  name: 'fnlength'\n},\n// Extra field length (m)\n{\n  offset: 28,\n  size: 2,\n  default: 0,\n  name: 'extraLength'\n}];","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}