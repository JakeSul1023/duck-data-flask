{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { BufferTransform } from '@luma.gl/engine';\nimport { fp64arithmetic } from '@luma.gl/shadertools';\nimport { GL } from '@luma.gl/constants';\nimport { getAttributeTypeFromSize, cycleBuffers, padBuffer, matchBuffer, getFloat32VertexFormat } from \"./gpu-transition-utils.js\";\nimport { GPUTransitionBase } from \"./gpu-transition.js\";\nexport default class GPUInterpolationTransition extends GPUTransitionBase {\n  constructor({\n    device,\n    attribute,\n    timeline\n  }) {\n    super({\n      device,\n      attribute,\n      timeline\n    });\n    this.type = 'interpolation';\n    this.transform = getTransform(device, attribute);\n  }\n  start(transitionSettings, numInstances) {\n    const prevLength = this.currentLength;\n    const prevStartIndices = this.currentStartIndices;\n    super.start(transitionSettings, numInstances, transitionSettings.duration);\n    if (transitionSettings.duration <= 0) {\n      this.transition.cancel();\n      return;\n    }\n    const {\n      buffers,\n      attribute\n    } = this;\n    // Alternate between two buffers when new transitions start.\n    // Last destination buffer is used as an attribute (from state),\n    // And the other buffer is now the current buffer.\n    cycleBuffers(buffers);\n    buffers[0] = padBuffer({\n      device: this.device,\n      buffer: buffers[0],\n      attribute,\n      fromLength: prevLength,\n      toLength: this.currentLength,\n      fromStartIndices: prevStartIndices,\n      getData: transitionSettings.enter\n    });\n    buffers[1] = matchBuffer({\n      device: this.device,\n      source: buffers[0],\n      target: buffers[1]\n    });\n    this.setBuffer(buffers[1]);\n    const {\n      transform\n    } = this;\n    const model = transform.model;\n    let vertexCount = Math.floor(this.currentLength / attribute.size);\n    if (useFp64(attribute)) {\n      vertexCount /= 2;\n    }\n    model.setVertexCount(vertexCount);\n    if (attribute.isConstant) {\n      model.setAttributes({\n        aFrom: buffers[0]\n      });\n      model.setConstantAttributes({\n        aTo: attribute.value\n      });\n    } else {\n      model.setAttributes({\n        aFrom: buffers[0],\n        aTo: attribute.getBuffer()\n      });\n    }\n    transform.transformFeedback.setBuffers({\n      vCurrent: buffers[1]\n    });\n  }\n  onUpdate() {\n    const {\n      duration,\n      easing\n    } = this.settings;\n    const {\n      time\n    } = this.transition;\n    let t = time / duration;\n    if (easing) {\n      t = easing(t);\n    }\n    const {\n      model\n    } = this.transform;\n    const interpolationProps = {\n      time: t\n    };\n    model.shaderInputs.setProps({\n      interpolation: interpolationProps\n    });\n    this.transform.run({\n      discard: true\n    });\n  }\n  delete() {\n    super.delete();\n    this.transform.destroy();\n  }\n}\nconst uniformBlock = `\\\nuniform interpolationUniforms {\n  float time;\n} interpolation;\n`;\nconst interpolationUniforms = {\n  name: 'interpolation',\n  vs: uniformBlock,\n  uniformTypes: {\n    time: 'f32'\n  }\n};\nconst vs = `\\\n#version 300 es\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nin ATTRIBUTE_TYPE aFrom;\nin ATTRIBUTE_TYPE aTo;\nout ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, interpolation.time);\n  gl_Position = vec4(0.0);\n}\n`;\nconst vs64 = `\\\n#version 300 es\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nin ATTRIBUTE_TYPE aFrom;\nin ATTRIBUTE_TYPE aFrom64Low;\nin ATTRIBUTE_TYPE aTo;\nin ATTRIBUTE_TYPE aTo64Low;\nout ATTRIBUTE_TYPE vCurrent;\nout ATTRIBUTE_TYPE vCurrent64Low;\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\nvoid main(void) {\n  for (int i=0; i<ATTRIBUTE_SIZE; i++) {\n    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), interpolation.time);\n    vCurrent[i] = value.x;\n    vCurrent64Low[i] = value.y;\n  }\n  gl_Position = vec4(0.0);\n}\n`;\nfunction useFp64(attribute) {\n  return attribute.doublePrecision && attribute.value instanceof Float64Array;\n}\nfunction getTransform(device, attribute) {\n  const attributeSize = attribute.size;\n  const attributeType = getAttributeTypeFromSize(attributeSize);\n  const inputFormat = getFloat32VertexFormat(attributeSize);\n  const bufferLayout = attribute.getBufferLayout();\n  if (useFp64(attribute)) {\n    return new BufferTransform(device, {\n      vs: vs64,\n      bufferLayout: [{\n        name: 'aFrom',\n        byteStride: 8 * attributeSize,\n        attributes: [{\n          attribute: 'aFrom',\n          format: inputFormat,\n          byteOffset: 0\n        }, {\n          attribute: 'aFrom64Low',\n          format: inputFormat,\n          byteOffset: 4 * attributeSize\n        }]\n      }, {\n        name: 'aTo',\n        byteStride: 8 * attributeSize,\n        attributes: [{\n          attribute: 'aTo',\n          format: inputFormat,\n          byteOffset: 0\n        }, {\n          attribute: 'aTo64Low',\n          format: inputFormat,\n          byteOffset: 4 * attributeSize\n        }]\n      }],\n      // @ts-expect-error fp64 module only sets ONE uniform via defaultUniforms\n      modules: [fp64arithmetic, interpolationUniforms],\n      defines: {\n        ATTRIBUTE_TYPE: attributeType,\n        ATTRIBUTE_SIZE: attributeSize\n      },\n      // Default uniforms are not set without this\n      moduleSettings: {},\n      varyings: ['vCurrent', 'vCurrent64Low'],\n      bufferMode: 35980,\n      disableWarnings: true\n    });\n  }\n  return new BufferTransform(device, {\n    vs,\n    bufferLayout: [{\n      name: 'aFrom',\n      format: inputFormat\n    }, {\n      name: 'aTo',\n      format: bufferLayout.attributes[0].format\n    }],\n    modules: [interpolationUniforms],\n    defines: {\n      ATTRIBUTE_TYPE: attributeType\n    },\n    varyings: ['vCurrent'],\n    // TODO investigate why this is needed\n    disableWarnings: true\n  });\n}","map":{"version":3,"names":["BufferTransform","fp64arithmetic","GL","getAttributeTypeFromSize","cycleBuffers","padBuffer","matchBuffer","getFloat32VertexFormat","GPUTransitionBase","GPUInterpolationTransition","constructor","device","attribute","timeline","type","transform","getTransform","start","transitionSettings","numInstances","prevLength","currentLength","prevStartIndices","currentStartIndices","duration","transition","cancel","buffers","buffer","fromLength","toLength","fromStartIndices","getData","enter","source","target","setBuffer","model","vertexCount","Math","floor","size","useFp64","setVertexCount","isConstant","setAttributes","aFrom","setConstantAttributes","aTo","value","getBuffer","transformFeedback","setBuffers","vCurrent","onUpdate","easing","settings","time","t","interpolationProps","shaderInputs","setProps","interpolation","run","discard","delete","destroy","uniformBlock","interpolationUniforms","name","vs","uniformTypes","vs64","doublePrecision","Float64Array","attributeSize","attributeType","inputFormat","bufferLayout","getBufferLayout","byteStride","attributes","format","byteOffset","modules","defines","ATTRIBUTE_TYPE","ATTRIBUTE_SIZE","moduleSettings","varyings","bufferMode","disableWarnings"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\transitions\\gpu-interpolation-transition.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '@luma.gl/core';\nimport {Timeline, BufferTransform} from '@luma.gl/engine';\nimport {fp64arithmetic} from '@luma.gl/shadertools';\nimport type {ShaderModule} from '@luma.gl/shadertools';\nimport {GL} from '@luma.gl/constants';\nimport Attribute from '../lib/attribute/attribute';\nimport {\n  getAttributeTypeFromSize,\n  cycleBuffers,\n  padBuffer,\n  matchBuffer,\n  getFloat32VertexFormat\n} from './gpu-transition-utils';\nimport {GPUTransitionBase} from './gpu-transition';\n\nimport type {InterpolationTransitionSettings} from '../lib/attribute/transition-settings';\nimport type {TypedArray} from '../types/types';\n\nexport default class GPUInterpolationTransition extends GPUTransitionBase<InterpolationTransitionSettings> {\n  type = 'interpolation';\n\n  private transform: BufferTransform;\n\n  constructor({\n    device,\n    attribute,\n    timeline\n  }: {\n    device: Device;\n    attribute: Attribute;\n    timeline: Timeline;\n  }) {\n    super({device, attribute, timeline});\n    this.transform = getTransform(device, attribute);\n  }\n\n  override start(transitionSettings: InterpolationTransitionSettings, numInstances: number): void {\n    const prevLength = this.currentLength;\n    const prevStartIndices = this.currentStartIndices;\n\n    super.start(transitionSettings, numInstances, transitionSettings.duration);\n\n    if (transitionSettings.duration <= 0) {\n      this.transition.cancel();\n      return;\n    }\n\n    const {buffers, attribute} = this;\n    // Alternate between two buffers when new transitions start.\n    // Last destination buffer is used as an attribute (from state),\n    // And the other buffer is now the current buffer.\n    cycleBuffers(buffers);\n\n    buffers[0] = padBuffer({\n      device: this.device,\n      buffer: buffers[0],\n      attribute,\n      fromLength: prevLength,\n      toLength: this.currentLength,\n      fromStartIndices: prevStartIndices,\n      getData: transitionSettings.enter\n    });\n    buffers[1] = matchBuffer({\n      device: this.device,\n      source: buffers[0],\n      target: buffers[1]\n    });\n\n    this.setBuffer(buffers[1]);\n\n    const {transform} = this;\n    const model = transform.model;\n    let vertexCount = Math.floor(this.currentLength / attribute.size);\n    if (useFp64(attribute)) {\n      vertexCount /= 2;\n    }\n    model.setVertexCount(vertexCount);\n    if (attribute.isConstant) {\n      model.setAttributes({aFrom: buffers[0]});\n      model.setConstantAttributes({aTo: attribute.value as TypedArray});\n    } else {\n      model.setAttributes({\n        aFrom: buffers[0],\n        aTo: attribute.getBuffer()!\n      });\n    }\n    transform.transformFeedback.setBuffers({vCurrent: buffers[1]});\n  }\n\n  onUpdate() {\n    const {duration, easing} = this.settings!;\n    const {time} = this.transition;\n    let t = time / duration;\n    if (easing) {\n      t = easing(t);\n    }\n    const {model} = this.transform;\n    const interpolationProps: InterpolationProps = {time: t};\n    model.shaderInputs.setProps({interpolation: interpolationProps});\n\n    this.transform.run({discard: true});\n  }\n\n  override delete() {\n    super.delete();\n    this.transform.destroy();\n  }\n}\n\nconst uniformBlock = `\\\nuniform interpolationUniforms {\n  float time;\n} interpolation;\n`;\n\ntype InterpolationProps = {time: number};\n\nconst interpolationUniforms = {\n  name: 'interpolation',\n  vs: uniformBlock,\n  uniformTypes: {\n    time: 'f32'\n  }\n} as const satisfies ShaderModule<InterpolationProps>;\n\nconst vs = `\\\n#version 300 es\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nin ATTRIBUTE_TYPE aFrom;\nin ATTRIBUTE_TYPE aTo;\nout ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, interpolation.time);\n  gl_Position = vec4(0.0);\n}\n`;\nconst vs64 = `\\\n#version 300 es\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nin ATTRIBUTE_TYPE aFrom;\nin ATTRIBUTE_TYPE aFrom64Low;\nin ATTRIBUTE_TYPE aTo;\nin ATTRIBUTE_TYPE aTo64Low;\nout ATTRIBUTE_TYPE vCurrent;\nout ATTRIBUTE_TYPE vCurrent64Low;\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\nvoid main(void) {\n  for (int i=0; i<ATTRIBUTE_SIZE; i++) {\n    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), interpolation.time);\n    vCurrent[i] = value.x;\n    vCurrent64Low[i] = value.y;\n  }\n  gl_Position = vec4(0.0);\n}\n`;\n\nfunction useFp64(attribute: Attribute): boolean {\n  return attribute.doublePrecision && attribute.value instanceof Float64Array;\n}\n\nfunction getTransform(device: Device, attribute: Attribute): BufferTransform {\n  const attributeSize = attribute.size;\n  const attributeType = getAttributeTypeFromSize(attributeSize);\n  const inputFormat = getFloat32VertexFormat(attributeSize);\n  const bufferLayout = attribute.getBufferLayout();\n\n  if (useFp64(attribute)) {\n    return new BufferTransform(device, {\n      vs: vs64,\n      bufferLayout: [\n        {\n          name: 'aFrom',\n          byteStride: 8 * attributeSize,\n          attributes: [\n            {attribute: 'aFrom', format: inputFormat, byteOffset: 0},\n            {attribute: 'aFrom64Low', format: inputFormat, byteOffset: 4 * attributeSize}\n          ]\n        },\n        {\n          name: 'aTo',\n          byteStride: 8 * attributeSize,\n          attributes: [\n            {attribute: 'aTo', format: inputFormat, byteOffset: 0},\n            {attribute: 'aTo64Low', format: inputFormat, byteOffset: 4 * attributeSize}\n          ]\n        }\n      ],\n      // @ts-expect-error fp64 module only sets ONE uniform via defaultUniforms\n      modules: [fp64arithmetic, interpolationUniforms],\n      defines: {\n        ATTRIBUTE_TYPE: attributeType,\n        ATTRIBUTE_SIZE: attributeSize\n      },\n      // Default uniforms are not set without this\n      moduleSettings: {},\n      varyings: ['vCurrent', 'vCurrent64Low'],\n      bufferMode: GL.INTERLEAVED_ATTRIBS,\n      disableWarnings: true\n    });\n  }\n  return new BufferTransform(device, {\n    vs,\n    bufferLayout: [\n      {name: 'aFrom', format: inputFormat},\n      {name: 'aTo', format: bufferLayout.attributes![0].format}\n    ],\n    modules: [interpolationUniforms],\n    defines: {\n      ATTRIBUTE_TYPE: attributeType\n    },\n    varyings: ['vCurrent'],\n\n    // TODO investigate why this is needed\n    disableWarnings: true\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}