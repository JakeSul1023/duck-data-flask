{"ast":null,"code":"import { TouchAction } from \"./touchaction/touchaction.js\";\nimport { PointerEventInput } from \"./inputs/pointerevent.js\";\nimport { splitStr } from \"./utils/split-str.js\";\nimport { prefixed } from \"./utils/prefixed.js\";\nimport { RecognizerState } from \"./recognizer/recognizer-state.js\";\nconst STOP = 1;\nconst FORCED_STOP = 2;\nconst defaultOptions = {\n  touchAction: 'compute',\n  enable: true,\n  inputTarget: null,\n  cssProps: {\n    /**\n     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n     */\n    userSelect: 'none',\n    /**\n     * (Webkit) Disable default dragging behavior\n     */\n    // @ts-ignore\n    userDrag: 'none',\n    /**\n     * (iOS only) Disables the default callout shown when you touch and hold a touch target.\n     * When you touch and hold a touch target such as a link, Safari displays\n     * a callout containing information about the link. This property allows you to disable that callout.\n     */\n    // @ts-ignore\n    touchCallout: 'none',\n    /**\n     * (iOS only) Sets the color of the highlight that appears over a link while it's being tapped.\n     */\n    // @ts-ignore\n    tapHighlightColor: 'rgba(0,0,0,0)'\n  }\n};\n/**\n * Manager\n */\nexport class Manager {\n  constructor(element, options) {\n    this.options = {\n      ...defaultOptions,\n      ...options,\n      cssProps: {\n        ...defaultOptions.cssProps,\n        ...options.cssProps\n      },\n      inputTarget: options.inputTarget || element\n    };\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = new PointerEventInput(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    this.toggleCssProps(true);\n  }\n  /**\n   * set options\n   */\n  set(options) {\n    Object.assign(this.options, options);\n    // Options that need a little more setup\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n    return this;\n  }\n  /**\n   * stop recognizing for this session.\n   * This session will be discarded, when a new [input]start event is fired.\n   * When forced, the recognizer cycle is stopped immediately.\n   */\n  stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  }\n  /**\n   * run the recognizers!\n   * called by the inputHandler function on every movement of the pointers (touches)\n   * it walks through all the recognizers and tries to detect the gesture that is being made\n   */\n  recognize(inputData) {\n    const {\n      session\n    } = this;\n    if (session.stopped) {\n      return;\n    }\n    // run the touch-action polyfill\n    if (this.session.prevented) {\n      inputData.srcEvent.preventDefault();\n    }\n    let recognizer;\n    const {\n      recognizers\n    } = this;\n    // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n    let {\n      curRecognizer\n    } = session;\n    // reset when the last recognizer is recognized\n    // or when we're in a new session\n    if (!curRecognizer || curRecognizer && curRecognizer.state & RecognizerState.Recognized) {\n      curRecognizer = session.curRecognizer = null;\n    }\n    let i = 0;\n    while (i < recognizers.length) {\n      recognizer = recognizers[i];\n      // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n      if (session.stopped !== FORCED_STOP && (\n      // 1\n      !curRecognizer || recognizer === curRecognizer ||\n      // 2\n      recognizer.canRecognizeWith(curRecognizer))) {\n        // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      }\n      // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n      if (!curRecognizer && recognizer.state & (RecognizerState.Began | RecognizerState.Changed | RecognizerState.Ended)) {\n        curRecognizer = session.curRecognizer = recognizer;\n      }\n      i++;\n    }\n  }\n  /**\n   * get a recognizer by its event name.\n   */\n  get(recognizerName) {\n    const {\n      recognizers\n    } = this;\n    for (let i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizerName) {\n        return recognizers[i];\n      }\n    }\n    return null;\n  }\n  /**\n   * add a recognizer to the manager\n   * existing recognizers with the same event name will be removed\n   */\n  add(recognizer) {\n    if (Array.isArray(recognizer)) {\n      for (const item of recognizer) {\n        this.add(item);\n      }\n      return this;\n    }\n    // remove existing\n    const existing = this.get(recognizer.options.event);\n    if (existing) {\n      this.remove(existing);\n    }\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n    this.touchAction.update();\n    return recognizer;\n  }\n  /**\n   * remove a recognizer by name or instance\n   */\n  remove(recognizerOrName) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.remove(item);\n      }\n      return this;\n    }\n    const recognizer = typeof recognizerOrName === 'string' ? this.get(recognizerOrName) : recognizerOrName;\n    // let's make sure this recognizer exists\n    if (recognizer) {\n      const {\n        recognizers\n      } = this;\n      const index = recognizers.indexOf(recognizer);\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n    return this;\n  }\n  /**\n   * bind event\n   */\n  on(events, handler) {\n    if (!events || !handler) {\n      return;\n    }\n    const {\n      handlers\n    } = this;\n    for (const event of splitStr(events)) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    }\n  }\n  /**\n   * unbind event, leave hander blank to remove all handlers\n   */\n  off(events, handler) {\n    if (!events) {\n      return;\n    }\n    const {\n      handlers\n    } = this;\n    for (const event of splitStr(events)) {\n      if (!handler) {\n        delete handlers[event];\n      } else if (handlers[event]) {\n        handlers[event].splice(handlers[event].indexOf(handler), 1);\n      }\n    }\n  }\n  /**\n   * emit event to the listeners\n   */\n  emit(event, data) {\n    // no handlers, so skip it all\n    const handlers = this.handlers[event] && this.handlers[event].slice();\n    if (!handlers || !handlers.length) {\n      return;\n    }\n    const evt = data;\n    evt.type = event;\n    evt.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n    let i = 0;\n    while (i < handlers.length) {\n      handlers[i](evt);\n      i++;\n    }\n  }\n  /**\n   * destroy the manager and unbinds all events\n   * it doesn't unbind dom events, that is the user own responsibility\n   */\n  destroy() {\n    this.toggleCssProps(false);\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  }\n  /**\n   * add/remove the css properties as defined in manager.options.cssProps\n   */\n  toggleCssProps(add) {\n    const {\n      element\n    } = this;\n    if (!element) {\n      return;\n    }\n    for (const [name, value] of Object.entries(this.options.cssProps)) {\n      const prop = prefixed(element.style, name);\n      if (add) {\n        this.oldCssProps[prop] = element.style[prop];\n        element.style[prop] = value;\n      } else {\n        element.style[prop] = this.oldCssProps[prop] || '';\n      }\n    }\n    if (!add) {\n      this.oldCssProps = {};\n    }\n  }\n}","map":{"version":3,"names":["TouchAction","PointerEventInput","splitStr","prefixed","RecognizerState","STOP","FORCED_STOP","defaultOptions","touchAction","enable","inputTarget","cssProps","userSelect","userDrag","touchCallout","tapHighlightColor","Manager","constructor","element","options","handlers","session","recognizers","oldCssProps","input","toggleCssProps","set","Object","assign","update","destroy","target","init","stop","force","stopped","recognize","inputData","prevented","srcEvent","preventDefault","recognizer","curRecognizer","state","Recognized","i","length","canRecognizeWith","reset","Began","Changed","Ended","get","recognizerName","event","add","Array","isArray","item","existing","remove","push","manager","recognizerOrName","index","indexOf","splice","on","events","handler","off","emit","data","slice","evt","type","name","value","entries","prop","style"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\mjolnir.js\\src\\hammerjs\\manager.ts"],"sourcesContent":["import {TouchAction} from './touchaction/touchaction';\nimport {PointerEventInput} from './inputs/pointerevent';\nimport {splitStr} from './utils/split-str';\nimport {prefixed} from './utils/prefixed';\nimport {RecognizerState} from './recognizer/recognizer-state';\n\nimport type {Input} from './input/input';\nimport type {Recognizer} from './recognizer/recognizer';\nimport type {Session, HammerInput} from './input/types';\n\nconst STOP = 1;\nconst FORCED_STOP = 2;\n\nexport type ManagerOptions = {\n  /**\n   * The value for the touchAction property/fallback.\n   * When set to `compute` it will magically set the correct value based on the added recognizers.\n   * @default compute\n   */\n  touchAction?: string;\n\n  /**\n   * @default true\n   */\n  enable?: boolean;\n\n  /**\n   * EXPERIMENTAL FEATURE -- can be removed/changed\n   * Change the parent input target element.\n   * If Null, then it is being set the to main element.\n   * @default null\n   */\n  inputTarget?: null | EventTarget;\n\n  /**\n   * Some CSS properties can be used to improve the working of Hammer.\n   * Add them to this method and they will be set when creating a new Manager.\n   */\n  cssProps?: Partial<CSSStyleDeclaration>;\n};\n\nexport type HammerEvent = HammerInput & {\n  type: string;\n  preventDefault: () => void;\n};\nexport type EventHandler = (event: HammerEvent) => void;\n\nconst defaultOptions: Required<ManagerOptions> = {\n  touchAction: 'compute',\n  enable: true,\n  inputTarget: null,\n  cssProps: {\n    /**\n     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n     */\n    userSelect: 'none',\n    /**\n     * (Webkit) Disable default dragging behavior\n     */\n    // @ts-ignore\n    userDrag: 'none',\n    /**\n     * (iOS only) Disables the default callout shown when you touch and hold a touch target.\n     * When you touch and hold a touch target such as a link, Safari displays\n     * a callout containing information about the link. This property allows you to disable that callout.\n     */\n    // @ts-ignore\n    touchCallout: 'none',\n    /**\n     * (iOS only) Sets the color of the highlight that appears over a link while it's being tapped.\n     */\n    // @ts-ignore\n    tapHighlightColor: 'rgba(0,0,0,0)'\n  }\n};\n\n/**\n * Manager\n */\nexport class Manager {\n  options: Required<ManagerOptions>;\n\n  element: HTMLElement | null;\n  touchAction: TouchAction;\n  oldCssProps: {[prop: string]: any};\n  session: Session;\n  recognizers: Recognizer[];\n  input: Input;\n  handlers: {[event: string]: EventHandler[]};\n\n  constructor(element: HTMLElement, options: ManagerOptions) {\n    this.options = {\n      ...defaultOptions,\n      ...options,\n      cssProps: {...defaultOptions.cssProps, ...options.cssProps},\n      inputTarget: options.inputTarget || element\n    };\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = new PointerEventInput(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    this.toggleCssProps(true);\n  }\n\n  /**\n   * set options\n   */\n  set(options: Partial<ManagerOptions>) {\n    Object.assign(this.options, options);\n\n    // Options that need a little more setup\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n    return this;\n  }\n\n  /**\n   * stop recognizing for this session.\n   * This session will be discarded, when a new [input]start event is fired.\n   * When forced, the recognizer cycle is stopped immediately.\n   */\n  stop(force?: boolean) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  }\n\n  /**\n   * run the recognizers!\n   * called by the inputHandler function on every movement of the pointers (touches)\n   * it walks through all the recognizers and tries to detect the gesture that is being made\n   */\n  recognize(inputData: HammerInput) {\n    const {session} = this;\n    if (session.stopped) {\n      return;\n    }\n\n    // run the touch-action polyfill\n    if (this.session.prevented) {\n      inputData.srcEvent.preventDefault();\n    }\n\n    let recognizer;\n    const {recognizers} = this;\n\n    // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n    let {curRecognizer} = session;\n\n    // reset when the last recognizer is recognized\n    // or when we're in a new session\n    if (!curRecognizer || (curRecognizer && curRecognizer.state & RecognizerState.Recognized)) {\n      curRecognizer = session.curRecognizer = null;\n    }\n\n    let i = 0;\n    while (i < recognizers.length) {\n      recognizer = recognizers[i];\n\n      // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n      if (\n        session.stopped !== FORCED_STOP && // 1\n        (!curRecognizer ||\n          recognizer === curRecognizer || // 2\n          recognizer.canRecognizeWith(curRecognizer))\n      ) {\n        // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      }\n\n      // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n      if (\n        !curRecognizer &&\n        recognizer.state & (RecognizerState.Began | RecognizerState.Changed | RecognizerState.Ended)\n      ) {\n        curRecognizer = session.curRecognizer = recognizer;\n      }\n      i++;\n    }\n  }\n\n  /**\n   * get a recognizer by its event name.\n   */\n  get(recognizerName: string): Recognizer | null {\n    const {recognizers} = this;\n    for (let i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizerName) {\n        return recognizers[i];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * add a recognizer to the manager\n   * existing recognizers with the same event name will be removed\n   */\n  add(recognizer: Recognizer | Recognizer[]) {\n    if (Array.isArray(recognizer)) {\n      for (const item of recognizer) {\n        this.add(item);\n      }\n      return this;\n    }\n\n    // remove existing\n    const existing = this.get(recognizer.options.event);\n    if (existing) {\n      this.remove(existing);\n    }\n\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n\n    this.touchAction.update();\n    return recognizer;\n  }\n\n  /**\n   * remove a recognizer by name or instance\n   */\n  remove(recognizerOrName: Recognizer | string | (Recognizer | string)[]) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.remove(item);\n      }\n      return this;\n    }\n\n    const recognizer =\n      typeof recognizerOrName === 'string' ? this.get(recognizerOrName) : recognizerOrName;\n\n    // let's make sure this recognizer exists\n    if (recognizer) {\n      const {recognizers} = this;\n      const index = recognizers.indexOf(recognizer);\n\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * bind event\n   */\n  on(events: string, handler: EventHandler) {\n    if (!events || !handler) {\n      return;\n    }\n    const {handlers} = this;\n    for (const event of splitStr(events)) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    }\n  }\n\n  /**\n   * unbind event, leave hander blank to remove all handlers\n   */\n  off(events: string, handler?: EventHandler) {\n    if (!events) {\n      return;\n    }\n\n    const {handlers} = this;\n    for (const event of splitStr(events)) {\n      if (!handler) {\n        delete handlers[event];\n      } else if (handlers[event]) {\n        handlers[event].splice(handlers[event].indexOf(handler), 1);\n      }\n    }\n  }\n\n  /**\n   * emit event to the listeners\n   */\n  emit(event: string, data: HammerInput) {\n    // no handlers, so skip it all\n    const handlers = this.handlers[event] && this.handlers[event].slice();\n    if (!handlers || !handlers.length) {\n      return;\n    }\n\n    const evt = data as HammerEvent;\n    evt.type = event;\n    evt.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n\n    let i = 0;\n    while (i < handlers.length) {\n      handlers[i](evt);\n      i++;\n    }\n  }\n\n  /**\n   * destroy the manager and unbinds all events\n   * it doesn't unbind dom events, that is the user own responsibility\n   */\n  destroy() {\n    this.toggleCssProps(false);\n\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  }\n\n  /**\n   * add/remove the css properties as defined in manager.options.cssProps\n   */\n  private toggleCssProps(add: boolean) {\n    const {element} = this;\n    if (!element) {\n      return;\n    }\n    for (const [name, value] of Object.entries(this.options.cssProps)) {\n      const prop = prefixed(element.style, name) as any;\n      if (add) {\n        this.oldCssProps[prop] = element.style[prop];\n        element.style[prop] = value as any;\n      } else {\n        element.style[prop] = this.oldCssProps[prop] || '';\n      }\n    }\n    if (!add) {\n      this.oldCssProps = {};\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}