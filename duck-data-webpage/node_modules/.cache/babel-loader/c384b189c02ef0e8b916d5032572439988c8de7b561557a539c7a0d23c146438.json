{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { CompositeLayer, AttributeManager } from '@deck.gl/core';\nclass AggregationLayer extends CompositeLayer {\n  /** Allow this layer to participates in the draw cycle */\n  get isDrawable() {\n    return true;\n  }\n  initializeState() {\n    this.getAttributeManager().remove(['instancePickingColors']);\n  }\n  // Extend Layer.updateState to update the Aggregator instance\n  // returns true if aggregator is changed\n  updateState(params) {\n    super.updateState(params);\n    const aggregatorType = this.getAggregatorType();\n    if (params.changeFlags.extensionsChanged || this.state.aggregatorType !== aggregatorType) {\n      this.state.aggregator?.destroy();\n      const aggregator = this.createAggregator(aggregatorType);\n      aggregator.setProps({\n        attributes: this.getAttributeManager()?.attributes\n      });\n      this.setState({\n        aggregator,\n        aggregatorType\n      });\n      return true;\n    }\n    return false;\n  }\n  // Override Layer.finalizeState to dispose the Aggregator instance\n  finalizeState(context) {\n    super.finalizeState(context);\n    this.state.aggregator.destroy();\n  }\n  // Override Layer.updateAttributes to update the aggregator\n  updateAttributes(changedAttributes) {\n    const {\n      aggregator\n    } = this.state;\n    aggregator.setProps({\n      attributes: changedAttributes\n    });\n    for (const id in changedAttributes) {\n      this.onAttributeChange(id);\n    }\n    // In aggregator.update() the aggregator allocates the buffers to store its output\n    // These buffers will be exposed by aggregator.getResults() and passed to the sublayers\n    // Therefore update() must be called before renderLayers()\n    // CPUAggregator's output is populated right here in update()\n    // GPUAggregator's output is pre-allocated and populated in preDraw(), see comments below\n    aggregator.update();\n  }\n  draw({\n    shaderModuleProps\n  }) {\n    // GPU aggregation needs `shaderModuleProps` for projection/filter uniforms which are only accessible at draw time\n    // GPUAggregator's Buffers are pre-allocated during `update()` and passed down to the sublayer attributes in renderLayers()\n    // Although the Buffers have been bound to the sublayer's Model, their content are not populated yet\n    // GPUAggregator.preDraw() is called in the draw cycle here right before Buffers are used by sublayer.draw()\n    const {\n      aggregator\n    } = this.state;\n    // @ts-expect-error only used by GPU aggregators\n    aggregator.setProps({\n      shaderModuleProps\n    });\n    aggregator.preDraw();\n  }\n  // override CompositeLayer._getAttributeManager to create AttributeManager instance\n  _getAttributeManager() {\n    return new AttributeManager(this.context.device, {\n      id: this.props.id,\n      stats: this.context.stats\n    });\n  }\n}\nAggregationLayer.layerName = 'AggregationLayer';\nexport default AggregationLayer;\n//# sourceMappingURL=aggregation-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}