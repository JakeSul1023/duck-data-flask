{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport LayersPass from \"./layers-pass.js\";\nexport default class ShadowPass extends LayersPass {\n  constructor(device, props) {\n    super(device, props);\n    // The shadowMap texture\n    const shadowMap = device.createTexture({\n      format: 'rgba8unorm',\n      width: 1,\n      height: 1,\n      sampler: {\n        minFilter: 'linear',\n        magFilter: 'linear',\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge'\n      },\n      mipmaps: true\n    });\n    const depthBuffer = device.createTexture({\n      format: 'depth16unorm',\n      width: 1,\n      height: 1,\n      mipmaps: false\n    });\n    this.fbo = device.createFramebuffer({\n      id: 'shadowmap',\n      width: 1,\n      height: 1,\n      colorAttachments: [shadowMap],\n      // Depth attachment has to be specified for depth test to work\n      depthStencilAttachment: depthBuffer\n    });\n  }\n  delete() {\n    if (this.fbo) {\n      this.fbo.destroy();\n      this.fbo = null;\n    }\n  }\n  getShadowMap() {\n    return this.fbo.colorAttachments[0].texture;\n  }\n  render(params) {\n    const target = this.fbo;\n    // @ts-expect-error TODO - assuming WebGL context\n    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();\n    const viewport = params.viewports[0];\n    const width = viewport.width * pixelRatio;\n    const height = viewport.height * pixelRatio;\n    const clearColor = [1, 1, 1, 1];\n    if (width !== target.width || height !== target.height) {\n      target.resize({\n        width,\n        height\n      });\n    }\n    super.render({\n      ...params,\n      clearColor,\n      target,\n      pass: 'shadow'\n    });\n  }\n  getLayerParameters(layer, layerIndex, viewport) {\n    return {\n      ...layer.props.parameters,\n      blend: false,\n      depthWriteEnabled: true,\n      depthCompare: 'less-equal'\n    };\n  }\n  shouldDrawLayer(layer) {\n    return layer.props.shadowEnabled !== false;\n  }\n  getShaderModuleProps(layer, effects, otherShaderModuleProps) {\n    return {\n      shadow: {\n        project: otherShaderModuleProps.project,\n        drawToShadowMap: true\n      }\n    };\n  }\n}","map":{"version":3,"names":["LayersPass","ShadowPass","constructor","device","props","shadowMap","createTexture","format","width","height","sampler","minFilter","magFilter","addressModeU","addressModeV","mipmaps","depthBuffer","fbo","createFramebuffer","id","colorAttachments","depthStencilAttachment","delete","destroy","getShadowMap","texture","render","params","target","pixelRatio","canvasContext","cssToDeviceRatio","viewport","viewports","clearColor","resize","pass","getLayerParameters","layer","layerIndex","parameters","blend","depthWriteEnabled","depthCompare","shouldDrawLayer","shadowEnabled","getShaderModuleProps","effects","otherShaderModuleProps","shadow","project","drawToShadowMap"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\passes\\shadow-pass.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, Framebuffer, Parameters, Texture} from '@luma.gl/core';\nimport type Layer from '../lib/layer';\nimport type Viewport from '../viewports/viewport';\nimport LayersPass from './layers-pass';\n\nexport default class ShadowPass extends LayersPass {\n  fbo: Framebuffer;\n\n  constructor(\n    device: Device,\n    props?: {\n      id;\n    }\n  ) {\n    super(device, props);\n\n    // The shadowMap texture\n    const shadowMap = device.createTexture({\n      format: 'rgba8unorm',\n      width: 1,\n      height: 1,\n      sampler: {\n        minFilter: 'linear',\n        magFilter: 'linear',\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge'\n      },\n      mipmaps: true\n    });\n\n    const depthBuffer = device.createTexture({\n      format: 'depth16unorm',\n      width: 1,\n      height: 1,\n      mipmaps: false\n    });\n\n    this.fbo = device.createFramebuffer({\n      id: 'shadowmap',\n      width: 1,\n      height: 1,\n      colorAttachments: [shadowMap],\n      // Depth attachment has to be specified for depth test to work\n      depthStencilAttachment: depthBuffer\n    });\n  }\n\n  delete() {\n    if (this.fbo) {\n      this.fbo.destroy();\n      this.fbo = null!;\n    }\n  }\n\n  getShadowMap(): Texture {\n    return this.fbo.colorAttachments[0].texture;\n  }\n\n  render(params) {\n    const target = this.fbo;\n\n    // @ts-expect-error TODO - assuming WebGL context\n    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();\n\n    const viewport = params.viewports[0];\n    const width = viewport.width * pixelRatio;\n    const height = viewport.height * pixelRatio;\n    const clearColor = [1, 1, 1, 1];\n    if (width !== target.width || height !== target.height) {\n      target.resize({width, height});\n    }\n\n    super.render({...params, clearColor, target, pass: 'shadow'});\n  }\n\n  protected getLayerParameters(\n    layer: Layer<{}>,\n    layerIndex: number,\n    viewport: Viewport\n  ): Parameters {\n    return {\n      ...layer.props.parameters,\n      blend: false,\n      depthWriteEnabled: true,\n      depthCompare: 'less-equal'\n    };\n  }\n\n  shouldDrawLayer(layer) {\n    return layer.props.shadowEnabled !== false;\n  }\n\n  getShaderModuleProps(layer: Layer, effects: any, otherShaderModuleProps: Record<string, any>) {\n    return {\n      shadow: {\n        project: otherShaderModuleProps.project,\n        drawToShadowMap: true\n      }\n    };\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAKA,OAAOA,UAAU;AAEjB,eAAc,MAAOC,UAAW,SAAQD,UAAU;EAGhDE,YACEC,MAAc,EACdC,KAEC;IAED,KAAK,CAACD,MAAM,EAAEC,KAAK,CAAC;IAEpB;IACA,MAAMC,SAAS,GAAGF,MAAM,CAACG,aAAa,CAAC;MACrCC,MAAM,EAAE,YAAY;MACpBC,KAAK,EAAE,CAAC;MACRC,MAAM,EAAE,CAAC;MACTC,OAAO,EAAE;QACPC,SAAS,EAAE,QAAQ;QACnBC,SAAS,EAAE,QAAQ;QACnBC,YAAY,EAAE,eAAe;QAC7BC,YAAY,EAAE;OACf;MACDC,OAAO,EAAE;KACV,CAAC;IAEF,MAAMC,WAAW,GAAGb,MAAM,CAACG,aAAa,CAAC;MACvCC,MAAM,EAAE,cAAc;MACtBC,KAAK,EAAE,CAAC;MACRC,MAAM,EAAE,CAAC;MACTM,OAAO,EAAE;KACV,CAAC;IAEF,IAAI,CAACE,GAAG,GAAGd,MAAM,CAACe,iBAAiB,CAAC;MAClCC,EAAE,EAAE,WAAW;MACfX,KAAK,EAAE,CAAC;MACRC,MAAM,EAAE,CAAC;MACTW,gBAAgB,EAAE,CAACf,SAAS,CAAC;MAC7B;MACAgB,sBAAsB,EAAEL;KACzB,CAAC;EACJ;EAEAM,MAAMA,CAAA;IACJ,IAAI,IAAI,CAACL,GAAG,EAAE;MACZ,IAAI,CAACA,GAAG,CAACM,OAAO,EAAE;MAClB,IAAI,CAACN,GAAG,GAAG,IAAK;IAClB;EACF;EAEAO,YAAYA,CAAA;IACV,OAAO,IAAI,CAACP,GAAG,CAACG,gBAAgB,CAAC,CAAC,CAAC,CAACK,OAAO;EAC7C;EAEAC,MAAMA,CAACC,MAAM;IACX,MAAMC,MAAM,GAAG,IAAI,CAACX,GAAG;IAEvB;IACA,MAAMY,UAAU,GAAG,IAAI,CAAC1B,MAAM,CAAC2B,aAAa,CAACC,gBAAgB,EAAE;IAE/D,MAAMC,QAAQ,GAAGL,MAAM,CAACM,SAAS,CAAC,CAAC,CAAC;IACpC,MAAMzB,KAAK,GAAGwB,QAAQ,CAACxB,KAAK,GAAGqB,UAAU;IACzC,MAAMpB,MAAM,GAAGuB,QAAQ,CAACvB,MAAM,GAAGoB,UAAU;IAC3C,MAAMK,UAAU,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAC/B,IAAI1B,KAAK,KAAKoB,MAAM,CAACpB,KAAK,IAAIC,MAAM,KAAKmB,MAAM,CAACnB,MAAM,EAAE;MACtDmB,MAAM,CAACO,MAAM,CAAC;QAAC3B,KAAK;QAAEC;MAAM,CAAC,CAAC;IAChC;IAEA,KAAK,CAACiB,MAAM,CAAC;MAAC,GAAGC,MAAM;MAAEO,UAAU;MAAEN,MAAM;MAAEQ,IAAI,EAAE;IAAQ,CAAC,CAAC;EAC/D;EAEUC,kBAAkBA,CAC1BC,KAAgB,EAChBC,UAAkB,EAClBP,QAAkB;IAElB,OAAO;MACL,GAAGM,KAAK,CAAClC,KAAK,CAACoC,UAAU;MACzBC,KAAK,EAAE,KAAK;MACZC,iBAAiB,EAAE,IAAI;MACvBC,YAAY,EAAE;KACf;EACH;EAEAC,eAAeA,CAACN,KAAK;IACnB,OAAOA,KAAK,CAAClC,KAAK,CAACyC,aAAa,KAAK,KAAK;EAC5C;EAEAC,oBAAoBA,CAACR,KAAY,EAAES,OAAY,EAAEC,sBAA2C;IAC1F,OAAO;MACLC,MAAM,EAAE;QACNC,OAAO,EAAEF,sBAAsB,CAACE,OAAO;QACvCC,eAAe,EAAE;;KAEpB;EACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}