{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Reads a chunk from a random access file\n * @param file\n * @param start\n * @param length\n * @returns\n */\nexport async function readArrayBuffer(file, start, length) {\n  // TODO - we can do better for ArrayBuffer and string\n  if (!(file instanceof Blob)) {\n    file = new Blob([file]);\n  }\n  const slice = file.slice(start, start + length);\n  return await readBlob(slice);\n}\n/**\n * Read a slice of a Blob or File, without loading the entire file into memory\n * The trick when reading File objects is to read successive \"slices\" of the File\n * Per spec https://w3c.github.io/FileAPI/, slicing a File only updates the start and end fields\n * Actually reading from file happens in `readAsArrayBuffer`\n * @param blob to read\n */\nexport async function readBlob(blob) {\n  return await new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = event => resolve(event?.target?.result);\n    // TODO - reject with a proper Error\n    fileReader.onerror = error => reject(error);\n    fileReader.readAsArrayBuffer(blob);\n  });\n}","map":{"version":3,"names":["readArrayBuffer","file","start","length","Blob","slice","readBlob","blob","Promise","resolve","reject","fileReader","FileReader","onload","event","target","result","onerror","error","readAsArrayBuffer"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/core/dist/lib/fetch/read-array-buffer.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Reads a chunk from a random access file\n * @param file\n * @param start\n * @param length\n * @returns\n */\nexport async function readArrayBuffer(file, start, length) {\n    // TODO - we can do better for ArrayBuffer and string\n    if (!(file instanceof Blob)) {\n        file = new Blob([file]);\n    }\n    const slice = file.slice(start, start + length);\n    return await readBlob(slice);\n}\n/**\n * Read a slice of a Blob or File, without loading the entire file into memory\n * The trick when reading File objects is to read successive \"slices\" of the File\n * Per spec https://w3c.github.io/FileAPI/, slicing a File only updates the start and end fields\n * Actually reading from file happens in `readAsArrayBuffer`\n * @param blob to read\n */\nexport async function readBlob(blob) {\n    return await new Promise((resolve, reject) => {\n        const fileReader = new FileReader();\n        fileReader.onload = (event) => resolve(event?.target?.result);\n        // TODO - reject with a proper Error\n        fileReader.onerror = (error) => reject(error);\n        fileReader.readAsArrayBuffer(blob);\n    });\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAeA,eAAeA,CAACC,IAAI,EAAEC,KAAK,EAAEC,MAAM,EAAE;EACvD;EACA,IAAI,EAAEF,IAAI,YAAYG,IAAI,CAAC,EAAE;IACzBH,IAAI,GAAG,IAAIG,IAAI,CAAC,CAACH,IAAI,CAAC,CAAC;EAC3B;EACA,MAAMI,KAAK,GAAGJ,IAAI,CAACI,KAAK,CAACH,KAAK,EAAEA,KAAK,GAAGC,MAAM,CAAC;EAC/C,OAAO,MAAMG,QAAQ,CAACD,KAAK,CAAC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAeC,QAAQA,CAACC,IAAI,EAAE;EACjC,OAAO,MAAM,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IAC1C,MAAMC,UAAU,GAAG,IAAIC,UAAU,CAAC,CAAC;IACnCD,UAAU,CAACE,MAAM,GAAIC,KAAK,IAAKL,OAAO,CAACK,KAAK,EAAEC,MAAM,EAAEC,MAAM,CAAC;IAC7D;IACAL,UAAU,CAACM,OAAO,GAAIC,KAAK,IAAKR,MAAM,CAACQ,KAAK,CAAC;IAC7CP,UAAU,CAACQ,iBAAiB,CAACZ,IAAI,CAAC;EACtC,CAAC,CAAC;AACN","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}