{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nconst SUBTREE_FILE_MAGIC = 0x74627573;\nconst SUBTREE_FILE_VERSION = 1;\n/**\n * Parse subtree file\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling#subtree-file-format\n * @param data\n * @returns\n */\n// eslint-disable-next-line max-statements\nexport default async function parse3DTilesSubtree(data, options, context) {\n  const magic = new Uint32Array(data.slice(0, 4));\n  if (magic[0] !== SUBTREE_FILE_MAGIC) {\n    throw new Error('Wrong subtree file magic number');\n  }\n  const version = new Uint32Array(data.slice(4, 8));\n  if (version[0] !== SUBTREE_FILE_VERSION) {\n    throw new Error('Wrong subtree file verson, must be 1');\n  }\n  const jsonByteLength = parseUint64Value(data.slice(8, 16));\n  const stringAttribute = new Uint8Array(data, 24, jsonByteLength);\n  const textDecoder = new TextDecoder('utf8');\n  const string = textDecoder.decode(stringAttribute);\n  const subtree = JSON.parse(string);\n  const binaryByteLength = parseUint64Value(data.slice(16, 24));\n  let internalBinaryBuffer = new ArrayBuffer(0);\n  if (binaryByteLength) {\n    internalBinaryBuffer = data.slice(24 + jsonByteLength);\n  }\n  await loadExplicitBitstream(subtree, subtree.tileAvailability, internalBinaryBuffer, context);\n  if (Array.isArray(subtree.contentAvailability)) {\n    for (const contentAvailability of subtree.contentAvailability) {\n      await loadExplicitBitstream(subtree, contentAvailability, internalBinaryBuffer, context);\n    }\n  } else {\n    await loadExplicitBitstream(subtree, subtree.contentAvailability, internalBinaryBuffer, context);\n  }\n  await loadExplicitBitstream(subtree, subtree.childSubtreeAvailability, internalBinaryBuffer, context);\n  return subtree;\n}\n/**\n * Load explicit bitstream for subtree availability data.\n * @param subtree - subtree data\n * @param availabilityObject - tileAvailability / contentAvailability / childSubtreeAvailability object\n * @param internalBinaryBuffer - subtree binary buffer\n * @param context - loaders.gl context\n */\nexport async function loadExplicitBitstream(subtree, availabilityObject, internalBinaryBuffer, context) {\n  const bufferViewIndex = Number.isFinite(availabilityObject.bitstream) ? availabilityObject.bitstream : availabilityObject.bufferView;\n  if (typeof bufferViewIndex !== 'number') {\n    return;\n  }\n  const bufferView = subtree.bufferViews[bufferViewIndex];\n  const buffer = subtree.buffers[bufferView.buffer];\n  if (!context?.baseUrl) {\n    throw new Error('Url is not provided');\n  }\n  if (!context.fetch) {\n    throw new Error('fetch is not provided');\n  }\n  // External bitstream loading\n  if (buffer.uri) {\n    const bufferUri = `${context?.baseUrl || ''}/${buffer.uri}`;\n    const response = await context.fetch(bufferUri);\n    const data = await response.arrayBuffer();\n    availabilityObject.explicitBitstream = new Uint8Array(data, bufferView.byteOffset, bufferView.byteLength);\n    return;\n  }\n  const bufferStart = subtree.buffers.slice(0, bufferView.buffer).reduce((offset, buf) => offset + buf.byteLength, 0);\n  availabilityObject.explicitBitstream = new Uint8Array(internalBinaryBuffer.slice(bufferStart, bufferStart + buffer.byteLength), bufferView.byteOffset, bufferView.byteLength);\n}\n/**\n * Parse buffer to return uint64 value\n * @param buffer\n * @returns 64-bit value until precision is lost after Number.MAX_SAFE_INTEGER\n */\nfunction parseUint64Value(buffer) {\n  const dataView = new DataView(buffer);\n  const left = dataView.getUint32(0, true);\n  const right = dataView.getUint32(4, true);\n  // combine the two 32-bit values\n  return left + 2 ** 32 * right;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}