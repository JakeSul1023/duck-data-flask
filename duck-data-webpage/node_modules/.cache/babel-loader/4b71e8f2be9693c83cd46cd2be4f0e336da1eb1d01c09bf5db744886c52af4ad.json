{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\nimport * as Polygon from \"./polygon.js\";\nimport { Tesselator } from '@deck.gl/core';\nimport { cutPolygonByGrid, cutPolygonByMercatorBounds } from '@math.gl/polygon';\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PolygonTesselator extends Tesselator {\n  constructor(opts) {\n    const {\n      fp64,\n      IndexType = Uint32Array\n    } = opts;\n    super({\n      ...opts,\n      attributes: {\n        positions: {\n          size: 3,\n          type: fp64 ? Float64Array : Float32Array\n        },\n        vertexValid: {\n          type: Uint16Array,\n          size: 1\n        },\n        indices: {\n          type: IndexType,\n          size: 1\n        }\n      }\n    });\n  }\n  /** Get attribute by name */\n  get(attributeName) {\n    const {\n      attributes\n    } = this;\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n    return attributes[attributeName];\n  }\n  /** Override base Tesselator method */\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n    const externalIndices = this.buffers.indices;\n    if (externalIndices) {\n      // @ts-ignore (2339) value is not defined on TypedArray (fall through)\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    } else if (this.data && !this.getGeometry) {\n      throw new Error('missing indices buffer');\n    }\n  }\n  /** Implement base Tesselator interface */\n  normalizeGeometry(polygon) {\n    if (this.normalize) {\n      const normalizedPolygon = Polygon.normalize(polygon, this.positionSize);\n      if (this.opts.resolution) {\n        return cutPolygonByGrid(Polygon.getPositions(normalizedPolygon), Polygon.getHoleIndices(normalizedPolygon), {\n          size: this.positionSize,\n          gridResolution: this.opts.resolution,\n          edgeTypes: true\n        });\n      }\n      if (this.opts.wrapLongitude) {\n        return cutPolygonByMercatorBounds(Polygon.getPositions(normalizedPolygon), Polygon.getHoleIndices(normalizedPolygon), {\n          size: this.positionSize,\n          maxLatitude: 86,\n          edgeTypes: true\n        });\n      }\n      return normalizedPolygon;\n    }\n    // normalize is explicitly set to false, assume that user passed in already normalized polygons\n    return polygon;\n  }\n  /** Implement base Tesselator interface */\n  getGeometrySize(polygon) {\n    if (isCut(polygon)) {\n      let size = 0;\n      for (const subPolygon of polygon) {\n        size += this.getGeometrySize(subPolygon);\n      }\n      return size;\n    }\n    return Polygon.getPositions(polygon).length / this.positionSize;\n  }\n  /** Override base Tesselator method */\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization/tesselation\n    return null;\n  }\n  /** Implement base Tesselator interface */\n  updateGeometryAttributes(polygon, context) {\n    if (polygon && isCut(polygon)) {\n      for (const subPolygon of polygon) {\n        const geometrySize = this.getGeometrySize(subPolygon);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPolygon, context);\n        context.vertexStart += geometrySize;\n        context.indexStart = this.indexStarts[context.geometryIndex + 1];\n      }\n    } else {\n      const normalizedPolygon = polygon;\n      this._updateIndices(normalizedPolygon, context);\n      this._updatePositions(normalizedPolygon, context);\n      this._updateVertexValid(normalizedPolygon, context);\n    }\n  }\n  // Flatten the indices array\n  _updateIndices(polygon, {\n    geometryIndex,\n    vertexStart: offset,\n    indexStart\n  }) {\n    const {\n      attributes,\n      indexStarts,\n      typedArrayManager\n    } = this;\n    let target = attributes.indices;\n    if (!target || !polygon) {\n      return;\n    }\n    let i = indexStart;\n    // 1. get triangulated indices for the internal areas\n    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject, this.opts.full3d);\n    // make sure the buffer is large enough\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n    // 2. offset each index by the number of indices in previous polygons\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n  // Flatten out all the vertices of all the sub subPolygons\n  _updatePositions(polygon, {\n    vertexStart,\n    geometrySize\n  }) {\n    const {\n      attributes: {\n        positions\n      },\n      positionSize\n    } = this;\n    if (!positions || !polygon) {\n      return;\n    }\n    const polygonPositions = Polygon.getPositions(polygon);\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n  _updateVertexValid(polygon, {\n    vertexStart,\n    geometrySize\n  }) {\n    const {\n      positionSize\n    } = this;\n    const vertexValid = this.attributes.vertexValid;\n    const holeIndices = polygon && Polygon.getHoleIndices(polygon);\n    /* We are reusing the some buffer for `nextPositions` by offseting one vertex\n     * to the left. As a result,\n     * the last vertex of each ring overlaps with the first vertex of the next ring.\n     * `vertexValid` is used to mark the end of each ring so we don't draw these\n     * segments:\n      positions      A0 A1 A2 A3 A4 B0 B1 B2 C0 ...\n      nextPositions  A1 A2 A3 A4 B0 B1 B2 C0 C1 ...\n      vertexValid    1  1  1  1  0  1  1  0  1 ...\n     */\n    if (polygon && polygon.edgeTypes) {\n      vertexValid.set(polygon.edgeTypes, vertexStart);\n    } else {\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    }\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n}\nfunction isCut(polygon) {\n  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);\n}","map":{"version":3,"names":["Polygon","Tesselator","cutPolygonByGrid","cutPolygonByMercatorBounds","PolygonTesselator","constructor","opts","fp64","IndexType","Uint32Array","attributes","positions","size","type","Float64Array","Float32Array","vertexValid","Uint16Array","indices","get","attributeName","subarray","vertexCount","updateGeometry","externalIndices","buffers","value","length","data","getGeometry","Error","normalizeGeometry","polygon","normalize","normalizedPolygon","positionSize","resolution","getPositions","getHoleIndices","gridResolution","edgeTypes","wrapLongitude","maxLatitude","getGeometrySize","isCut","subPolygon","getGeometryFromBuffer","buffer","updateGeometryAttributes","context","geometrySize","vertexStart","indexStart","indexStarts","geometryIndex","_updateIndices","_updatePositions","_updateVertexValid","offset","typedArrayManager","target","i","getSurfaceIndices","preproject","full3d","allocate","copy","j","polygonPositions","x","y","z","holeIndices","set","fill","Array","isArray","Number","isFinite"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\layers\\src\\solid-polygon-layer\\polygon-tesselator.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\nimport * as Polygon from './polygon';\nimport {Tesselator} from '@deck.gl/core';\nimport {cutPolygonByGrid, cutPolygonByMercatorBounds} from '@math.gl/polygon';\n\nimport type {\n  PolygonGeometry,\n  NormalizedPolygonGeometry,\n  FlatComplexPolygonGeometry\n} from './polygon';\nimport type {TypedArray} from '@math.gl/core';\n\ntype GeometryUpdateContext = {\n  vertexStart: number;\n  indexStart: number;\n  geometrySize: number;\n  geometryIndex: number;\n};\n\ntype CutPolygon = FlatComplexPolygonGeometry & {\n  edgeTypes: number[];\n};\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PolygonTesselator extends Tesselator<\n  PolygonGeometry,\n  NormalizedPolygonGeometry | CutPolygon[],\n  {\n    fp64?: boolean;\n    IndexType?: Uint32ArrayConstructor | Uint16ArrayConstructor;\n    resolution?: number;\n    wrapLongitude?: boolean;\n    preproject?: (xy: number[]) => number[];\n    full3d?: boolean;\n  }\n> {\n  constructor(opts) {\n    const {fp64, IndexType = Uint32Array} = opts;\n    super({\n      ...opts,\n      attributes: {\n        positions: {size: 3, type: fp64 ? Float64Array : Float32Array},\n        vertexValid: {type: Uint16Array, size: 1},\n        indices: {type: IndexType, size: 1}\n      }\n    });\n  }\n\n  /** Get attribute by name */\n  get(attributeName: string): TypedArray | null {\n    const {attributes} = this;\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    return attributes[attributeName];\n  }\n\n  /** Override base Tesselator method */\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n\n    const externalIndices = this.buffers.indices;\n    if (externalIndices) {\n      // @ts-ignore (2339) value is not defined on TypedArray (fall through)\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    } else if (this.data && !this.getGeometry) {\n      throw new Error('missing indices buffer');\n    }\n  }\n\n  /** Implement base Tesselator interface */\n  protected normalizeGeometry(polygon: PolygonGeometry): NormalizedPolygonGeometry | CutPolygon[] {\n    if (this.normalize) {\n      const normalizedPolygon = Polygon.normalize(polygon, this.positionSize);\n      if (this.opts.resolution) {\n        return cutPolygonByGrid(\n          Polygon.getPositions(normalizedPolygon),\n          Polygon.getHoleIndices(normalizedPolygon),\n          {\n            size: this.positionSize,\n            gridResolution: this.opts.resolution,\n            edgeTypes: true\n          }\n        ) as CutPolygon[];\n      }\n      if (this.opts.wrapLongitude) {\n        return cutPolygonByMercatorBounds(\n          Polygon.getPositions(normalizedPolygon),\n          Polygon.getHoleIndices(normalizedPolygon),\n          {\n            size: this.positionSize,\n            maxLatitude: 86,\n            edgeTypes: true\n          }\n        ) as CutPolygon[];\n      }\n      return normalizedPolygon;\n    }\n    // normalize is explicitly set to false, assume that user passed in already normalized polygons\n    return polygon as NormalizedPolygonGeometry;\n  }\n\n  /** Implement base Tesselator interface */\n  protected getGeometrySize(polygon: NormalizedPolygonGeometry | CutPolygon[]): number {\n    if (isCut(polygon)) {\n      let size = 0;\n      for (const subPolygon of polygon) {\n        size += this.getGeometrySize(subPolygon);\n      }\n      return size;\n    }\n    return Polygon.getPositions(polygon).length / this.positionSize;\n  }\n\n  /** Override base Tesselator method */\n  protected getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization/tesselation\n    return null;\n  }\n\n  /** Implement base Tesselator interface */\n  protected updateGeometryAttributes(\n    polygon: NormalizedPolygonGeometry | CutPolygon[] | null,\n    context: GeometryUpdateContext\n  ) {\n    if (polygon && isCut(polygon)) {\n      for (const subPolygon of polygon) {\n        const geometrySize = this.getGeometrySize(subPolygon);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPolygon, context);\n        context.vertexStart += geometrySize;\n        context.indexStart = this.indexStarts[context.geometryIndex + 1];\n      }\n    } else {\n      const normalizedPolygon = polygon as NormalizedPolygonGeometry;\n      this._updateIndices(normalizedPolygon, context);\n      this._updatePositions(normalizedPolygon, context);\n      this._updateVertexValid(normalizedPolygon, context);\n    }\n  }\n\n  // Flatten the indices array\n  private _updateIndices(\n    polygon: NormalizedPolygonGeometry | null,\n    {geometryIndex, vertexStart: offset, indexStart}: GeometryUpdateContext\n  ) {\n    const {attributes, indexStarts, typedArrayManager} = this;\n\n    let target = attributes.indices;\n    if (!target || !polygon) {\n      return;\n    }\n    let i = indexStart;\n\n    // 1. get triangulated indices for the internal areas\n    const indices = Polygon.getSurfaceIndices(\n      polygon,\n      this.positionSize,\n      this.opts.preproject,\n      this.opts.full3d\n    );\n\n    // make sure the buffer is large enough\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n\n    // 2. offset each index by the number of indices in previous polygons\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n\n  // Flatten out all the vertices of all the sub subPolygons\n  private _updatePositions(\n    polygon: NormalizedPolygonGeometry | null,\n    {vertexStart, geometrySize}: GeometryUpdateContext\n  ) {\n    const {\n      attributes: {positions},\n      positionSize\n    } = this;\n    if (!positions || !polygon) {\n      return;\n    }\n    const polygonPositions = Polygon.getPositions(polygon);\n\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n\n  private _updateVertexValid(\n    polygon: NormalizedPolygonGeometry | null,\n    {vertexStart, geometrySize}: GeometryUpdateContext\n  ) {\n    const {positionSize} = this;\n    const vertexValid = this.attributes.vertexValid as TypedArray;\n    const holeIndices = polygon && Polygon.getHoleIndices(polygon);\n    /* We are reusing the some buffer for `nextPositions` by offseting one vertex\n     * to the left. As a result,\n     * the last vertex of each ring overlaps with the first vertex of the next ring.\n     * `vertexValid` is used to mark the end of each ring so we don't draw these\n     * segments:\n      positions      A0 A1 A2 A3 A4 B0 B1 B2 C0 ...\n      nextPositions  A1 A2 A3 A4 B0 B1 B2 C0 C1 ...\n      vertexValid    1  1  1  1  0  1  1  0  1 ...\n     */\n    if (polygon && (polygon as CutPolygon).edgeTypes) {\n      vertexValid.set((polygon as CutPolygon).edgeTypes, vertexStart);\n    } else {\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    }\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n}\n\nfunction isCut(polygon: NormalizedPolygonGeometry | CutPolygon[]): polygon is CutPolygon[] {\n  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}