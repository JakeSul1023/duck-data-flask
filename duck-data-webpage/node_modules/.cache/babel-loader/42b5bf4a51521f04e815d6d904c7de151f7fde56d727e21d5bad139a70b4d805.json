{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { CompositeLayer, _flatten as flatten } from '@deck.gl/core';\nimport { GeoJsonLayer } from '@deck.gl/layers';\nimport { Tileset2D, STRATEGY_DEFAULT } from \"../tileset-2d/index.js\";\nimport { urlType, getURLFromTemplate } from \"../tileset-2d/index.js\";\nconst defaultProps = {\n  TilesetClass: Tileset2D,\n  data: {\n    type: 'data',\n    value: []\n  },\n  dataComparator: urlType.equal,\n  renderSubLayers: {\n    type: 'function',\n    value: props => new GeoJsonLayer(props)\n  },\n  getTileData: {\n    type: 'function',\n    optional: true,\n    value: null\n  },\n  // TODO - change to onViewportLoad to align with Tile3DLayer\n  onViewportLoad: {\n    type: 'function',\n    optional: true,\n    value: null\n  },\n  onTileLoad: {\n    type: 'function',\n    value: tile => {}\n  },\n  onTileUnload: {\n    type: 'function',\n    value: tile => {}\n  },\n  // eslint-disable-next-line\n  onTileError: {\n    type: 'function',\n    value: err => console.error(err)\n  },\n  extent: {\n    type: 'array',\n    optional: true,\n    value: null,\n    compare: true\n  },\n  tileSize: 512,\n  maxZoom: null,\n  minZoom: 0,\n  maxCacheSize: null,\n  maxCacheByteSize: null,\n  refinementStrategy: STRATEGY_DEFAULT,\n  zRange: null,\n  maxRequests: 6,\n  debounceTime: 0,\n  zoomOffset: 0\n};\n/**\n * The TileLayer is a composite layer that makes it possible to visualize very large datasets.\n *\n * Instead of fetching the entire dataset, it only loads and renders what's visible in the current viewport.\n */\nclass TileLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      tileset: null,\n      isLoaded: false\n    };\n  }\n  finalizeState() {\n    this.state?.tileset?.finalize();\n  }\n  get isLoaded() {\n    return Boolean(this.state?.tileset?.selectedTiles?.every(tile => tile.isLoaded && tile.layers && tile.layers.every(layer => layer.isLoaded)));\n  }\n  shouldUpdateState({\n    changeFlags\n  }) {\n    return changeFlags.somethingChanged;\n  }\n  updateState({\n    changeFlags\n  }) {\n    let {\n      tileset\n    } = this.state;\n    const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;\n    const dataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);\n    if (!tileset) {\n      tileset = new this.props.TilesetClass(this._getTilesetOptions());\n      this.setState({\n        tileset\n      });\n    } else if (propsChanged) {\n      tileset.setOptions(this._getTilesetOptions());\n      if (dataChanged) {\n        // reload all tiles\n        // use cached layers until new content is loaded\n        tileset.reloadAll();\n      } else {\n        // some render options changed, regenerate sub layers now\n        tileset.tiles.forEach(tile => {\n          tile.layers = null;\n        });\n      }\n    }\n    this._updateTileset();\n  }\n  _getTilesetOptions() {\n    const {\n      tileSize,\n      maxCacheSize,\n      maxCacheByteSize,\n      refinementStrategy,\n      extent,\n      maxZoom,\n      minZoom,\n      maxRequests,\n      debounceTime,\n      zoomOffset\n    } = this.props;\n    return {\n      maxCacheSize,\n      maxCacheByteSize,\n      maxZoom,\n      minZoom,\n      tileSize,\n      refinementStrategy,\n      extent,\n      maxRequests,\n      debounceTime,\n      zoomOffset,\n      getTileData: this.getTileData.bind(this),\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileError: this._onTileError.bind(this),\n      onTileUnload: this._onTileUnload.bind(this)\n    };\n  }\n  _updateTileset() {\n    const tileset = this.state.tileset;\n    const {\n      zRange,\n      modelMatrix\n    } = this.props;\n    const frameNumber = tileset.update(this.context.viewport, {\n      zRange,\n      modelMatrix\n    });\n    const {\n      isLoaded\n    } = tileset;\n    const loadingStateChanged = this.state.isLoaded !== isLoaded;\n    const tilesetChanged = this.state.frameNumber !== frameNumber;\n    if (isLoaded && (loadingStateChanged || tilesetChanged)) {\n      this._onViewportLoad();\n    }\n    if (tilesetChanged) {\n      // Save the tileset frame number - trigger a rerender\n      this.setState({\n        frameNumber\n      });\n    }\n    // Save the loaded state - should not trigger a rerender\n    this.state.isLoaded = isLoaded;\n  }\n  _onViewportLoad() {\n    const {\n      tileset\n    } = this.state;\n    const {\n      onViewportLoad\n    } = this.props;\n    if (onViewportLoad) {\n      // This method can only be called when tileset is defined and updated\n      onViewportLoad(tileset.selectedTiles);\n    }\n  }\n  _onTileLoad(tile) {\n    this.props.onTileLoad(tile);\n    tile.layers = null;\n    this.setNeedsUpdate();\n  }\n  _onTileError(error, tile) {\n    this.props.onTileError(error);\n    tile.layers = null;\n    this.setNeedsUpdate();\n  }\n  _onTileUnload(tile) {\n    this.props.onTileUnload(tile);\n  }\n  // Methods for subclass to override\n  getTileData(tile) {\n    const {\n      data,\n      getTileData,\n      fetch\n    } = this.props;\n    const {\n      signal\n    } = tile;\n    tile.url = typeof data === 'string' || Array.isArray(data) ? getURLFromTemplate(data, tile) : null;\n    if (getTileData) {\n      return getTileData(tile);\n    }\n    if (fetch && tile.url) {\n      return fetch(tile.url, {\n        propName: 'data',\n        layer: this,\n        signal\n      });\n    }\n    return null;\n  }\n  renderSubLayers(props) {\n    return this.props.renderSubLayers(props);\n  }\n  getSubLayerPropsByTile(tile) {\n    return null;\n  }\n  getPickingInfo(params) {\n    // TileLayer does not directly render anything, sourceLayer cannot be null\n    const sourceLayer = params.sourceLayer;\n    const sourceTile = sourceLayer.props.tile;\n    const info = params.info;\n    if (info.picked) {\n      info.tile = sourceTile;\n    }\n    info.sourceTile = sourceTile;\n    info.sourceTileSubLayer = sourceLayer;\n    return info;\n  }\n  _updateAutoHighlight(info) {\n    info.sourceTileSubLayer.updateAutoHighlight(info);\n  }\n  renderLayers() {\n    return this.state.tileset.tiles.map(tile => {\n      const subLayerProps = this.getSubLayerPropsByTile(tile);\n      // cache the rendered layer in the tile\n      if (!tile.isLoaded && !tile.content) {\n        // nothing to show\n      } else if (!tile.layers) {\n        const layers = this.renderSubLayers({\n          ...this.props,\n          ...this.getSubLayerProps({\n            id: tile.id,\n            updateTriggers: this.props.updateTriggers\n          }),\n          data: tile.content,\n          _offset: 0,\n          tile\n        });\n        tile.layers = flatten(layers, Boolean).map(layer => layer.clone({\n          tile,\n          ...subLayerProps\n        }));\n      } else if (subLayerProps && tile.layers[0] && Object.keys(subLayerProps).some(propName => tile.layers[0].props[propName] !== subLayerProps[propName])) {\n        tile.layers = tile.layers.map(layer => layer.clone(subLayerProps));\n      }\n      return tile.layers;\n    });\n  }\n  filterSubLayer({\n    layer,\n    cullRect\n  }) {\n    const {\n      tile\n    } = layer.props;\n    return this.state.tileset.isTileVisible(tile, cullRect);\n  }\n}\nTileLayer.defaultProps = defaultProps;\nTileLayer.layerName = 'TileLayer';\nexport default TileLayer;\n//# sourceMappingURL=tile-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}