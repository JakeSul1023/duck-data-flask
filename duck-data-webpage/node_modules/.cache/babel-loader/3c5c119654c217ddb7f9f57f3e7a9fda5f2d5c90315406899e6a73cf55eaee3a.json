{"ast":null,"code":"// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { Stats } from '@probe.gl/stats';\nimport { RequestScheduler, path } from '@loaders.gl/loader-utils';\nimport { TilesetCache } from \"./tileset-cache.js\";\nimport { calculateTransformProps } from \"./helpers/transform-utils.js\";\nimport { getFrameState, limitSelectedTiles } from \"./helpers/frame-state.js\";\nimport { getZoomFromBoundingVolume, getZoomFromExtent, getZoomFromFullExtent } from \"./helpers/zoom.js\";\nimport { Tile3D } from \"./tile-3d.js\";\nimport { TILESET_TYPE } from \"../constants.js\";\nimport { TilesetTraverser } from \"./tileset-traverser.js\";\n// TODO - these should be moved into their respective modules\nimport { Tileset3DTraverser } from \"./format-3d-tiles/tileset-3d-traverser.js\";\nimport { I3STilesetTraverser } from \"./format-i3s/i3s-tileset-traverser.js\";\nconst DEFAULT_PROPS = {\n  description: '',\n  ellipsoid: Ellipsoid.WGS84,\n  modelMatrix: new Matrix4(),\n  throttleRequests: true,\n  maxRequests: 64,\n  /** Default memory values optimized for viewing mesh-based 3D Tiles on both mobile and desktop devices */\n  maximumMemoryUsage: 32,\n  memoryCacheOverflow: 1,\n  maximumTilesSelected: 0,\n  debounceTime: 0,\n  onTileLoad: () => {},\n  onTileUnload: () => {},\n  onTileError: () => {},\n  onTraversalComplete: selectedTiles => selectedTiles,\n  contentLoader: undefined,\n  viewDistanceScale: 1.0,\n  maximumScreenSpaceError: 8,\n  memoryAdjustedScreenSpaceError: false,\n  loadTiles: true,\n  updateTransforms: true,\n  viewportTraversersMap: null,\n  loadOptions: {\n    fetch: {}\n  },\n  attributions: [],\n  basePath: '',\n  i3s: {}\n};\n// Tracked Stats\nconst TILES_TOTAL = 'Tiles In Tileset(s)';\nconst TILES_IN_MEMORY = 'Tiles In Memory';\nconst TILES_IN_VIEW = 'Tiles In View';\nconst TILES_RENDERABLE = 'Tiles To Render';\nconst TILES_LOADED = 'Tiles Loaded';\nconst TILES_LOADING = 'Tiles Loading';\nconst TILES_UNLOADED = 'Tiles Unloaded';\nconst TILES_LOAD_FAILED = 'Failed Tile Loads';\nconst POINTS_COUNT = 'Points/Vertices';\nconst TILES_GPU_MEMORY = 'Tile Memory Use';\nconst MAXIMUM_SSE = 'Maximum Screen Space Error';\n/**\n * The Tileset loading and rendering flow is as below,\n * A rendered (i.e. deck.gl `Tile3DLayer`) triggers `tileset.update()` after a `tileset` is loaded\n * `tileset` starts traversing the tile tree and update `requestTiles` (tiles of which content need\n * to be fetched) and `selectedTiles` (tiles ready for rendering under the current viewport).\n * `Tile3DLayer` will update rendering based on `selectedTiles`.\n * `Tile3DLayer` also listens to `onTileLoad` callback and trigger another round of `update and then traversal`\n * when new tiles are loaded.\n\n * As I3S tileset have stored `tileHeader` file (metadata) and tile content files (geometry, texture, ...) separately.\n * During each traversal, it issues `tilHeader` requests if that `tileHeader` is not yet fetched,\n * after the tile header is fulfilled, it will resume the traversal starting from the tile just fetched (not root).\n\n * Tile3DLayer\n *      |\n *  await load(tileset)\n *      |\n *  tileset.update()\n *      |                async load tileHeader\n *  tileset.traverse() -------------------------- Queued\n *      |        resume traversal after fetched  |\n *      |----------------------------------------|\n *      |\n *      |                     async load tile content\n * tilset.requestedTiles  ----------------------------- RequestScheduler\n *                                                             |\n * tilset.selectedTiles (ready for rendering)                  |\n *      |         Listen to                                    |\n *   Tile3DLayer ----------- onTileLoad  ----------------------|\n *      |                         |   notify new tile is available\n *   updateLayers                 |\n *                       tileset.update // trigger another round of update\n*/\nexport class Tileset3D {\n  // props: Tileset3DProps;\n  options;\n  loadOptions;\n  type;\n  tileset;\n  loader;\n  url;\n  basePath;\n  modelMatrix;\n  ellipsoid;\n  lodMetricType;\n  lodMetricValue;\n  refine;\n  root = null;\n  roots = {};\n  /** @todo any->unknown */\n  asset = {};\n  // Metadata for the entire tileset\n  description = '';\n  properties;\n  extras = null;\n  attributions = {};\n  credits = {};\n  stats;\n  /** flags that contain information about data types in nested tiles */\n  contentFormats = {\n    draco: false,\n    meshopt: false,\n    dds: false,\n    ktx2: false\n  };\n  // view props\n  cartographicCenter = null;\n  cartesianCenter = null;\n  zoom = 1;\n  boundingVolume = null;\n  /** Updated based on the camera position and direction */\n  dynamicScreenSpaceErrorComputedDensity = 0.0;\n  // METRICS\n  /**\n   * The maximum amount of GPU memory (in MB) that may be used to cache tiles\n   * Tiles not in view are unloaded to enforce private\n   */\n  maximumMemoryUsage = 32;\n  /** The total amount of GPU memory in bytes used by the tileset. */\n  gpuMemoryUsageInBytes = 0;\n  /**\n   * If loading the level of detail required by maximumScreenSpaceError\n   * results in the memory usage exceeding maximumMemoryUsage (GPU), level of detail refinement\n   * will instead use this (larger) adjusted screen space error to achieve the\n   * best possible visual quality within the available memory.\n   */\n  memoryAdjustedScreenSpaceError = 0.0;\n  _cacheBytes = 0;\n  _cacheOverflowBytes = 0;\n  /** Update tracker. increase in each update cycle. */\n  _frameNumber = 0;\n  _queryParams = {};\n  _extensionsUsed = [];\n  _tiles = {};\n  /** counter for tracking tiles requests */\n  _pendingCount = 0;\n  /** Hold traversal results */\n  selectedTiles = [];\n  // TRAVERSAL\n  traverseCounter = 0;\n  geometricError = 0;\n  lastUpdatedVieports = null;\n  _requestedTiles = [];\n  _emptyTiles = [];\n  frameStateData = {};\n  _traverser;\n  _cache = new TilesetCache();\n  _requestScheduler;\n  // Promise tracking\n  updatePromise = null;\n  tilesetInitializationPromise;\n  /**\n   * Create a new Tileset3D\n   * @param json\n   * @param props\n   */\n  // eslint-disable-next-line max-statements\n  constructor(tileset, options) {\n    // PUBLIC MEMBERS\n    this.options = {\n      ...DEFAULT_PROPS,\n      ...options\n    };\n    // raw data\n    this.tileset = tileset;\n    this.loader = tileset.loader;\n    // could be  3d tiles, i3s\n    this.type = tileset.type;\n    // The url to a tileset JSON file.\n    this.url = tileset.url;\n    this.basePath = tileset.basePath || path.dirname(this.url);\n    this.modelMatrix = this.options.modelMatrix;\n    this.ellipsoid = this.options.ellipsoid;\n    // Geometric error when the tree is not rendered at all\n    this.lodMetricType = tileset.lodMetricType;\n    this.lodMetricValue = tileset.lodMetricValue;\n    this.refine = tileset.root.refine;\n    this.loadOptions = this.options.loadOptions || {};\n    // TRAVERSAL\n    this._traverser = this._initializeTraverser();\n    this._requestScheduler = new RequestScheduler({\n      throttleRequests: this.options.throttleRequests,\n      maxRequests: this.options.maxRequests\n    });\n    this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError;\n    this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024;\n    this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024;\n    // METRICS\n    // The total amount of GPU memory in bytes used by the tileset.\n    this.stats = new Stats({\n      id: this.url\n    });\n    this._initializeStats();\n    this.tilesetInitializationPromise = this._initializeTileSet(tileset);\n  }\n  /** Release resources */\n  destroy() {\n    this._destroy();\n  }\n  /** Is the tileset loaded (update needs to have been called at least once) */\n  isLoaded() {\n    // Check that `_frameNumber !== 0` which means that update was called at least once\n    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;\n  }\n  get tiles() {\n    return Object.values(this._tiles);\n  }\n  get frameNumber() {\n    return this._frameNumber;\n  }\n  get queryParams() {\n    return new URLSearchParams(this._queryParams).toString();\n  }\n  setProps(props) {\n    this.options = {\n      ...this.options,\n      ...props\n    };\n  }\n  /** @deprecated */\n  // setOptions(options: Tileset3DProps): void {\n  //   this.options = {...this.options, ...options};\n  // }\n  /**\n   * Return a loadable tile url for a specific tile subpath\n   * @param tilePath a tile subpath\n   */\n  getTileUrl(tilePath) {\n    const isDataUrl = tilePath.startsWith('data:');\n    if (isDataUrl) {\n      return tilePath;\n    }\n    let tileUrl = tilePath;\n    if (this.queryParams.length) {\n      tileUrl = `${tilePath}${tilePath.includes('?') ? '&' : '?'}${this.queryParams}`;\n    }\n    return tileUrl;\n  }\n  // TODO CESIUM specific\n  hasExtension(extensionName) {\n    return Boolean(this._extensionsUsed.indexOf(extensionName) > -1);\n  }\n  /**\n   * Update visible tiles relying on a list of viewports\n   * @param viewports - list of viewports\n   * @deprecated\n   */\n  update(viewports = null) {\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.tilesetInitializationPromise.then(() => {\n      if (!viewports && this.lastUpdatedVieports) {\n        viewports = this.lastUpdatedVieports;\n      } else {\n        this.lastUpdatedVieports = viewports;\n      }\n      if (viewports) {\n        this.doUpdate(viewports);\n      }\n    });\n  }\n  /**\n   * Update visible tiles relying on a list of viewports.\n   * Do it with debounce delay to prevent update spam\n   * @param viewports viewports\n   * @returns Promise of new frameNumber\n   */\n  async selectTiles(viewports = null) {\n    await this.tilesetInitializationPromise;\n    if (viewports) {\n      this.lastUpdatedVieports = viewports;\n    }\n    if (!this.updatePromise) {\n      this.updatePromise = new Promise(resolve => {\n        setTimeout(() => {\n          if (this.lastUpdatedVieports) {\n            this.doUpdate(this.lastUpdatedVieports);\n          }\n          resolve(this._frameNumber);\n          this.updatePromise = null;\n        }, this.options.debounceTime);\n      });\n    }\n    return this.updatePromise;\n  }\n  adjustScreenSpaceError() {\n    if (this.gpuMemoryUsageInBytes < this._cacheBytes) {\n      this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError);\n    } else if (this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes) {\n      this.memoryAdjustedScreenSpaceError *= 1.02;\n    }\n  }\n  /**\n   * Update visible tiles relying on a list of viewports\n   * @param viewports viewports\n   */\n  // eslint-disable-next-line max-statements, complexity\n  doUpdate(viewports) {\n    if ('loadTiles' in this.options && !this.options.loadTiles) {\n      return;\n    }\n    if (this.traverseCounter > 0) {\n      return;\n    }\n    const preparedViewports = viewports instanceof Array ? viewports : [viewports];\n    this._cache.reset();\n    this._frameNumber++;\n    this.traverseCounter = preparedViewports.length;\n    const viewportsToTraverse = [];\n    // First loop to decrement traverseCounter\n    for (const viewport of preparedViewports) {\n      const id = viewport.id;\n      if (this._needTraverse(id)) {\n        viewportsToTraverse.push(id);\n      } else {\n        this.traverseCounter--;\n      }\n    }\n    // Second loop to traverse\n    for (const viewport of preparedViewports) {\n      const id = viewport.id;\n      if (!this.roots[id]) {\n        this.roots[id] = this._initializeTileHeaders(this.tileset, null);\n      }\n      if (!viewportsToTraverse.includes(id)) {\n        continue; // eslint-disable-line no-continue\n      }\n      const frameState = getFrameState(viewport, this._frameNumber);\n      this._traverser.traverse(this.roots[id], frameState, this.options);\n    }\n  }\n  /**\n   * Check if traversal is needed for particular viewport\n   * @param {string} viewportId - id of a viewport\n   * @return {boolean}\n   */\n  _needTraverse(viewportId) {\n    let traverserId = viewportId;\n    if (this.options.viewportTraversersMap) {\n      traverserId = this.options.viewportTraversersMap[viewportId];\n    }\n    if (traverserId !== viewportId) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * The callback to post-process tiles after traversal procedure\n   * @param frameState - frame state for tile culling\n   */\n  _onTraversalEnd(frameState) {\n    const id = frameState.viewport.id;\n    if (!this.frameStateData[id]) {\n      this.frameStateData[id] = {\n        selectedTiles: [],\n        _requestedTiles: [],\n        _emptyTiles: []\n      };\n    }\n    const currentFrameStateData = this.frameStateData[id];\n    const selectedTiles = Object.values(this._traverser.selectedTiles);\n    const [filteredSelectedTiles, unselectedTiles] = limitSelectedTiles(selectedTiles, frameState, this.options.maximumTilesSelected);\n    currentFrameStateData.selectedTiles = filteredSelectedTiles;\n    for (const tile of unselectedTiles) {\n      tile.unselect();\n    }\n    currentFrameStateData._requestedTiles = Object.values(this._traverser.requestedTiles);\n    currentFrameStateData._emptyTiles = Object.values(this._traverser.emptyTiles);\n    this.traverseCounter--;\n    if (this.traverseCounter > 0) {\n      return;\n    }\n    this._updateTiles();\n  }\n  /**\n   * Update tiles relying on data from all traversers\n   */\n  _updateTiles() {\n    this.selectedTiles = [];\n    this._requestedTiles = [];\n    this._emptyTiles = [];\n    for (const frameStateKey in this.frameStateData) {\n      const frameStateDataValue = this.frameStateData[frameStateKey];\n      this.selectedTiles = this.selectedTiles.concat(frameStateDataValue.selectedTiles);\n      this._requestedTiles = this._requestedTiles.concat(frameStateDataValue._requestedTiles);\n      this._emptyTiles = this._emptyTiles.concat(frameStateDataValue._emptyTiles);\n    }\n    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);\n    for (const tile of this.selectedTiles) {\n      this._tiles[tile.id] = tile;\n    }\n    this._loadTiles();\n    this._unloadTiles();\n    this._updateStats();\n  }\n  _tilesChanged(oldSelectedTiles, selectedTiles) {\n    if (oldSelectedTiles.length !== selectedTiles.length) {\n      return true;\n    }\n    const set1 = new Set(oldSelectedTiles.map(t => t.id));\n    const set2 = new Set(selectedTiles.map(t => t.id));\n    let changed = oldSelectedTiles.filter(x => !set2.has(x.id)).length > 0;\n    changed = changed || selectedTiles.filter(x => !set1.has(x.id)).length > 0;\n    return changed;\n  }\n  _loadTiles() {\n    // Sort requests by priority before making any requests.\n    // This makes it less likely this requests will be cancelled after being issued.\n    // requestedTiles.sort((a, b) => a._priority - b._priority);\n    for (const tile of this._requestedTiles) {\n      if (tile.contentUnloaded) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._loadTile(tile);\n      }\n    }\n  }\n  _unloadTiles() {\n    // unload tiles from cache when hit maximumMemoryUsage\n    this._cache.unloadTiles(this, (tileset, tile) => tileset._unloadTile(tile));\n  }\n  _updateStats() {\n    let tilesRenderable = 0;\n    let pointsRenderable = 0;\n    for (const tile of this.selectedTiles) {\n      if (tile.contentAvailable && tile.content) {\n        tilesRenderable++;\n        if (tile.content.pointCount) {\n          pointsRenderable += tile.content.pointCount;\n        } else {\n          // Calculate vertices for non point cloud tiles.\n          pointsRenderable += tile.content.vertexCount;\n        }\n      }\n    }\n    this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;\n    this.stats.get(TILES_RENDERABLE).count = tilesRenderable;\n    this.stats.get(POINTS_COUNT).count = pointsRenderable;\n    this.stats.get(MAXIMUM_SSE).count = this.memoryAdjustedScreenSpaceError;\n  }\n  async _initializeTileSet(tilesetJson) {\n    if (this.type === TILESET_TYPE.I3S) {\n      this.calculateViewPropsI3S();\n      tilesetJson.root = await tilesetJson.root;\n    }\n    this.root = this._initializeTileHeaders(tilesetJson, null);\n    if (this.type === TILESET_TYPE.TILES3D) {\n      this._initializeTiles3DTileset(tilesetJson);\n      this.calculateViewPropsTiles3D();\n    }\n    if (this.type === TILESET_TYPE.I3S) {\n      this._initializeI3STileset();\n    }\n  }\n  /**\n   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.\n   * These metrics help apps center view on tileset\n   * For I3S there is extent (<1.8 version) or fullExtent (>=1.8 version) to calculate view props\n   * @returns\n   */\n  calculateViewPropsI3S() {\n    // for I3S 1.8 try to calculate with fullExtent\n    const fullExtent = this.tileset.fullExtent;\n    if (fullExtent) {\n      const {\n        xmin,\n        xmax,\n        ymin,\n        ymax,\n        zmin,\n        zmax\n      } = fullExtent;\n      this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, zmin + (zmax - zmin) / 2);\n      this.cartesianCenter = new Vector3();\n      Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter);\n      this.zoom = getZoomFromFullExtent(fullExtent, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n    // for I3S 1.6-1.7 try to calculate with extent\n    const extent = this.tileset.store?.extent;\n    if (extent) {\n      const [xmin, ymin, xmax, ymax] = extent;\n      this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, 0);\n      this.cartesianCenter = new Vector3();\n      Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter);\n      this.zoom = getZoomFromExtent(extent, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n    // eslint-disable-next-line no-console\n    console.warn('Extent is not defined in the tileset header');\n    this.cartographicCenter = new Vector3();\n    this.zoom = 1;\n    return;\n  }\n  /**\n   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.\n   * These metrics help apps center view on tileset.\n   * For 3DTiles the root tile data is used to calculate view props.\n   * @returns\n   */\n  calculateViewPropsTiles3D() {\n    const root = this.root;\n    const {\n      center\n    } = root.boundingVolume;\n    // TODO - handle all cases\n    if (!center) {\n      // eslint-disable-next-line no-console\n      console.warn('center was not pre-calculated for the root tile');\n      this.cartographicCenter = new Vector3();\n      this.zoom = 1;\n      return;\n    }\n    // cartographic coordinates are undefined at the center of the ellipsoid\n    if (center[0] !== 0 || center[1] !== 0 || center[2] !== 0) {\n      this.cartographicCenter = new Vector3();\n      Ellipsoid.WGS84.cartesianToCartographic(center, this.cartographicCenter);\n    } else {\n      this.cartographicCenter = new Vector3(0, 0, -Ellipsoid.WGS84.radii[0]);\n    }\n    this.cartesianCenter = center;\n    this.zoom = getZoomFromBoundingVolume(root.boundingVolume, this.cartographicCenter);\n  }\n  _initializeStats() {\n    this.stats.get(TILES_TOTAL);\n    this.stats.get(TILES_LOADING);\n    this.stats.get(TILES_IN_MEMORY);\n    this.stats.get(TILES_IN_VIEW);\n    this.stats.get(TILES_RENDERABLE);\n    this.stats.get(TILES_LOADED);\n    this.stats.get(TILES_UNLOADED);\n    this.stats.get(TILES_LOAD_FAILED);\n    this.stats.get(POINTS_COUNT);\n    this.stats.get(TILES_GPU_MEMORY, 'memory');\n    this.stats.get(MAXIMUM_SSE);\n  }\n  // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.\n  // eslint-disable-next-line max-statements\n  _initializeTileHeaders(tilesetJson, parentTileHeader) {\n    // A tileset JSON file referenced from a tile may exist in a different directory than the root tileset.\n    // Get the basePath relative to the external tileset.\n    const rootTile = new Tile3D(this, tilesetJson.root, parentTileHeader); // resource\n    // If there is a parentTileHeader, add the root of the currently loading tileset\n    // to parentTileHeader's children, and update its depth.\n    if (parentTileHeader) {\n      parentTileHeader.children.push(rootTile);\n      rootTile.depth = parentTileHeader.depth + 1;\n    }\n    // 3DTiles knows the hierarchy beforehand\n    if (this.type === TILESET_TYPE.TILES3D) {\n      const stack = [];\n      stack.push(rootTile);\n      while (stack.length > 0) {\n        const tile = stack.pop();\n        this.stats.get(TILES_TOTAL).incrementCount();\n        const children = tile.header.children || [];\n        for (const childHeader of children) {\n          const childTile = new Tile3D(this, childHeader, tile);\n          // Special handling for Google\n          // A session key must be used for all tile requests\n          if (childTile.contentUrl?.includes('?session=')) {\n            const url = new URL(childTile.contentUrl);\n            const session = url.searchParams.get('session');\n            // eslint-disable-next-line max-depth\n            if (session) {\n              this._queryParams.session = session;\n            }\n          }\n          tile.children.push(childTile);\n          childTile.depth = tile.depth + 1;\n          stack.push(childTile);\n        }\n      }\n    }\n    return rootTile;\n  }\n  _initializeTraverser() {\n    let TraverserClass;\n    const type = this.type;\n    switch (type) {\n      case TILESET_TYPE.TILES3D:\n        TraverserClass = Tileset3DTraverser;\n        break;\n      case TILESET_TYPE.I3S:\n        TraverserClass = I3STilesetTraverser;\n        break;\n      default:\n        TraverserClass = TilesetTraverser;\n    }\n    return new TraverserClass({\n      basePath: this.basePath,\n      onTraversalEnd: this._onTraversalEnd.bind(this)\n    });\n  }\n  _destroyTileHeaders(parentTile) {\n    this._destroySubtree(parentTile);\n  }\n  async _loadTile(tile) {\n    let loaded;\n    try {\n      this._onStartTileLoading();\n      loaded = await tile.loadContent();\n    } catch (error) {\n      this._onTileLoadError(tile, error instanceof Error ? error : new Error('load failed'));\n    } finally {\n      this._onEndTileLoading();\n      this._onTileLoad(tile, loaded);\n    }\n  }\n  _onTileLoadError(tile, error) {\n    this.stats.get(TILES_LOAD_FAILED).incrementCount();\n    const message = error.message || error.toString();\n    const url = tile.url;\n    // TODO - Allow for probe log to be injected instead of console?\n    console.error(`A 3D tile failed to load: ${tile.url} ${message}`); // eslint-disable-line\n    this.options.onTileError(tile, message, url);\n  }\n  _onTileLoad(tile, loaded) {\n    if (!loaded) {\n      return;\n    }\n    if (this.type === TILESET_TYPE.I3S) {\n      // We can't calculate tiles total in I3S in advance so we calculate it dynamically.\n      const nodesInNodePages = this.tileset?.nodePagesTile?.nodesInNodePages || 0;\n      this.stats.get(TILES_TOTAL).reset();\n      this.stats.get(TILES_TOTAL).addCount(nodesInNodePages);\n    }\n    // add coordinateOrigin and modelMatrix to tile\n    if (tile && tile.content) {\n      calculateTransformProps(tile, tile.content);\n    }\n    this.updateContentTypes(tile);\n    this._addTileToCache(tile);\n    this.options.onTileLoad(tile);\n  }\n  /**\n   * Update information about data types in nested tiles\n   * @param tile instance of a nested Tile3D\n   */\n  updateContentTypes(tile) {\n    if (this.type === TILESET_TYPE.I3S) {\n      if (tile.header.isDracoGeometry) {\n        this.contentFormats.draco = true;\n      }\n      switch (tile.header.textureFormat) {\n        case 'dds':\n          this.contentFormats.dds = true;\n          break;\n        case 'ktx2':\n          this.contentFormats.ktx2 = true;\n          break;\n        default:\n      }\n    } else if (this.type === TILESET_TYPE.TILES3D) {\n      const {\n        extensionsRemoved = []\n      } = tile.content?.gltf || {};\n      if (extensionsRemoved.includes('KHR_draco_mesh_compression')) {\n        this.contentFormats.draco = true;\n      }\n      if (extensionsRemoved.includes('EXT_meshopt_compression')) {\n        this.contentFormats.meshopt = true;\n      }\n      if (extensionsRemoved.includes('KHR_texture_basisu')) {\n        this.contentFormats.ktx2 = true;\n      }\n    }\n  }\n  _onStartTileLoading() {\n    this._pendingCount++;\n    this.stats.get(TILES_LOADING).incrementCount();\n  }\n  _onEndTileLoading() {\n    this._pendingCount--;\n    this.stats.get(TILES_LOADING).decrementCount();\n  }\n  _addTileToCache(tile) {\n    this._cache.add(this, tile, tileset => tileset._updateCacheStats(tile));\n  }\n  _updateCacheStats(tile) {\n    this.stats.get(TILES_LOADED).incrementCount();\n    this.stats.get(TILES_IN_MEMORY).incrementCount();\n    // TODO: Calculate GPU memory usage statistics for a tile.\n    this.gpuMemoryUsageInBytes += tile.gpuMemoryUsageInBytes || 0;\n    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n    // Adjust SSE based on cache limits\n    if (this.options.memoryAdjustedScreenSpaceError) {\n      this.adjustScreenSpaceError();\n    }\n  }\n  _unloadTile(tile) {\n    this.gpuMemoryUsageInBytes -= tile.gpuMemoryUsageInBytes || 0;\n    this.stats.get(TILES_IN_MEMORY).decrementCount();\n    this.stats.get(TILES_UNLOADED).incrementCount();\n    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n    this.options.onTileUnload(tile);\n    tile.unloadContent();\n  }\n  // Traverse the tree and destroy all tiles\n  _destroy() {\n    const stack = [];\n    if (this.root) {\n      stack.push(this.root);\n    }\n    while (stack.length > 0) {\n      const tile = stack.pop();\n      for (const child of tile.children) {\n        stack.push(child);\n      }\n      this._destroyTile(tile);\n    }\n    this.root = null;\n  }\n  // Traverse the tree and destroy all sub tiles\n  _destroySubtree(tile) {\n    const root = tile;\n    const stack = [];\n    stack.push(root);\n    while (stack.length > 0) {\n      tile = stack.pop();\n      for (const child of tile.children) {\n        stack.push(child);\n      }\n      if (tile !== root) {\n        this._destroyTile(tile);\n      }\n    }\n    root.children = [];\n  }\n  _destroyTile(tile) {\n    this._cache.unloadTile(this, tile);\n    this._unloadTile(tile);\n    tile.destroy();\n  }\n  _initializeTiles3DTileset(tilesetJson) {\n    if (tilesetJson.queryString) {\n      const searchParams = new URLSearchParams(tilesetJson.queryString);\n      const queryParams = Object.fromEntries(searchParams.entries());\n      this._queryParams = {\n        ...this._queryParams,\n        ...queryParams\n      };\n    }\n    this.asset = tilesetJson.asset;\n    if (!this.asset) {\n      throw new Error('Tileset must have an asset property.');\n    }\n    if (this.asset.version !== '0.0' && this.asset.version !== '1.0' && this.asset.version !== '1.1') {\n      throw new Error('The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.');\n    }\n    // Note: `asset.tilesetVersion` is version of the tileset itself (not the version of the 3D TILES standard)\n    // We add this version as a `v=1.0` query param to fetch the right version and not get an older cached version\n    if ('tilesetVersion' in this.asset) {\n      this._queryParams.v = this.asset.tilesetVersion;\n    }\n    // TODO - ion resources have a credits property we can use for additional attribution.\n    this.credits = {\n      attributions: this.options.attributions || []\n    };\n    this.description = this.options.description || '';\n    // Gets the tileset's properties dictionary object, which contains metadata about per-feature properties.\n    this.properties = tilesetJson.properties;\n    this.geometricError = tilesetJson.geometricError;\n    this._extensionsUsed = tilesetJson.extensionsUsed || [];\n    // Returns the extras property at the top of the tileset JSON (application specific metadata).\n    this.extras = tilesetJson.extras;\n  }\n  _initializeI3STileset() {\n    // @ts-expect-error\n    if (this.loadOptions.i3s && 'token' in this.loadOptions.i3s) {\n      // @ts-ignore\n      this._queryParams.token = this.loadOptions.i3s.token;\n    }\n  }\n}","map":{"version":3,"names":["Matrix4","Vector3","Ellipsoid","Stats","RequestScheduler","path","TilesetCache","calculateTransformProps","getFrameState","limitSelectedTiles","getZoomFromBoundingVolume","getZoomFromExtent","getZoomFromFullExtent","Tile3D","TILESET_TYPE","TilesetTraverser","Tileset3DTraverser","I3STilesetTraverser","DEFAULT_PROPS","description","ellipsoid","WGS84","modelMatrix","throttleRequests","maxRequests","maximumMemoryUsage","memoryCacheOverflow","maximumTilesSelected","debounceTime","onTileLoad","onTileUnload","onTileError","onTraversalComplete","selectedTiles","contentLoader","undefined","viewDistanceScale","maximumScreenSpaceError","memoryAdjustedScreenSpaceError","loadTiles","updateTransforms","viewportTraversersMap","loadOptions","fetch","attributions","basePath","i3s","TILES_TOTAL","TILES_IN_MEMORY","TILES_IN_VIEW","TILES_RENDERABLE","TILES_LOADED","TILES_LOADING","TILES_UNLOADED","TILES_LOAD_FAILED","POINTS_COUNT","TILES_GPU_MEMORY","MAXIMUM_SSE","Tileset3D","options","type","tileset","loader","url","lodMetricType","lodMetricValue","refine","root","roots","asset","properties","extras","credits","stats","contentFormats","draco","meshopt","dds","ktx2","cartographicCenter","cartesianCenter","zoom","boundingVolume","dynamicScreenSpaceErrorComputedDensity","gpuMemoryUsageInBytes","_cacheBytes","_cacheOverflowBytes","_frameNumber","_queryParams","_extensionsUsed","_tiles","_pendingCount","traverseCounter","geometricError","lastUpdatedVieports","_requestedTiles","_emptyTiles","frameStateData","_traverser","_cache","_requestScheduler","updatePromise","tilesetInitializationPromise","constructor","dirname","_initializeTraverser","id","_initializeStats","_initializeTileSet","destroy","_destroy","isLoaded","length","tiles","Object","values","frameNumber","queryParams","URLSearchParams","toString","setProps","props","getTileUrl","tilePath","isDataUrl","startsWith","tileUrl","includes","hasExtension","extensionName","Boolean","indexOf","update","viewports","then","doUpdate","selectTiles","Promise","resolve","setTimeout","adjustScreenSpaceError","Math","max","preparedViewports","Array","reset","viewportsToTraverse","viewport","_needTraverse","push","_initializeTileHeaders","frameState","traverse","viewportId","traverserId","_onTraversalEnd","currentFrameStateData","filteredSelectedTiles","unselectedTiles","tile","unselect","requestedTiles","emptyTiles","_updateTiles","frameStateKey","frameStateDataValue","concat","_loadTiles","_unloadTiles","_updateStats","_tilesChanged","oldSelectedTiles","set1","Set","map","t","set2","changed","filter","x","has","contentUnloaded","_loadTile","unloadTiles","_unloadTile","tilesRenderable","pointsRenderable","contentAvailable","content","pointCount","vertexCount","get","count","tilesetJson","I3S","calculateViewPropsI3S","TILES3D","_initializeTiles3DTileset","calculateViewPropsTiles3D","_initializeI3STileset","fullExtent","xmin","xmax","ymin","ymax","zmin","zmax","cartographicToCartesian","extent","store","console","warn","center","cartesianToCartographic","radii","parentTileHeader","rootTile","children","depth","stack","pop","incrementCount","header","childHeader","childTile","contentUrl","URL","session","searchParams","TraverserClass","onTraversalEnd","bind","_destroyTileHeaders","parentTile","_destroySubtree","loaded","_onStartTileLoading","loadContent","error","_onTileLoadError","Error","_onEndTileLoading","_onTileLoad","message","nodesInNodePages","nodePagesTile","addCount","updateContentTypes","_addTileToCache","isDracoGeometry","textureFormat","extensionsRemoved","gltf","decrementCount","add","_updateCacheStats","unloadContent","child","_destroyTile","unloadTile","queryString","fromEntries","entries","version","v","tilesetVersion","extensionsUsed","token"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/tiles/dist/tileset/tileset-3d.js"],"sourcesContent":["// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { Stats } from '@probe.gl/stats';\nimport { RequestScheduler, path } from '@loaders.gl/loader-utils';\nimport { TilesetCache } from \"./tileset-cache.js\";\nimport { calculateTransformProps } from \"./helpers/transform-utils.js\";\nimport { getFrameState, limitSelectedTiles } from \"./helpers/frame-state.js\";\nimport { getZoomFromBoundingVolume, getZoomFromExtent, getZoomFromFullExtent } from \"./helpers/zoom.js\";\nimport { Tile3D } from \"./tile-3d.js\";\nimport { TILESET_TYPE } from \"../constants.js\";\nimport { TilesetTraverser } from \"./tileset-traverser.js\";\n// TODO - these should be moved into their respective modules\nimport { Tileset3DTraverser } from \"./format-3d-tiles/tileset-3d-traverser.js\";\nimport { I3STilesetTraverser } from \"./format-i3s/i3s-tileset-traverser.js\";\nconst DEFAULT_PROPS = {\n    description: '',\n    ellipsoid: Ellipsoid.WGS84,\n    modelMatrix: new Matrix4(),\n    throttleRequests: true,\n    maxRequests: 64,\n    /** Default memory values optimized for viewing mesh-based 3D Tiles on both mobile and desktop devices */\n    maximumMemoryUsage: 32,\n    memoryCacheOverflow: 1,\n    maximumTilesSelected: 0,\n    debounceTime: 0,\n    onTileLoad: () => { },\n    onTileUnload: () => { },\n    onTileError: () => { },\n    onTraversalComplete: (selectedTiles) => selectedTiles,\n    contentLoader: undefined,\n    viewDistanceScale: 1.0,\n    maximumScreenSpaceError: 8,\n    memoryAdjustedScreenSpaceError: false,\n    loadTiles: true,\n    updateTransforms: true,\n    viewportTraversersMap: null,\n    loadOptions: { fetch: {} },\n    attributions: [],\n    basePath: '',\n    i3s: {}\n};\n// Tracked Stats\nconst TILES_TOTAL = 'Tiles In Tileset(s)';\nconst TILES_IN_MEMORY = 'Tiles In Memory';\nconst TILES_IN_VIEW = 'Tiles In View';\nconst TILES_RENDERABLE = 'Tiles To Render';\nconst TILES_LOADED = 'Tiles Loaded';\nconst TILES_LOADING = 'Tiles Loading';\nconst TILES_UNLOADED = 'Tiles Unloaded';\nconst TILES_LOAD_FAILED = 'Failed Tile Loads';\nconst POINTS_COUNT = 'Points/Vertices';\nconst TILES_GPU_MEMORY = 'Tile Memory Use';\nconst MAXIMUM_SSE = 'Maximum Screen Space Error';\n/**\n * The Tileset loading and rendering flow is as below,\n * A rendered (i.e. deck.gl `Tile3DLayer`) triggers `tileset.update()` after a `tileset` is loaded\n * `tileset` starts traversing the tile tree and update `requestTiles` (tiles of which content need\n * to be fetched) and `selectedTiles` (tiles ready for rendering under the current viewport).\n * `Tile3DLayer` will update rendering based on `selectedTiles`.\n * `Tile3DLayer` also listens to `onTileLoad` callback and trigger another round of `update and then traversal`\n * when new tiles are loaded.\n\n * As I3S tileset have stored `tileHeader` file (metadata) and tile content files (geometry, texture, ...) separately.\n * During each traversal, it issues `tilHeader` requests if that `tileHeader` is not yet fetched,\n * after the tile header is fulfilled, it will resume the traversal starting from the tile just fetched (not root).\n\n * Tile3DLayer\n *      |\n *  await load(tileset)\n *      |\n *  tileset.update()\n *      |                async load tileHeader\n *  tileset.traverse() -------------------------- Queued\n *      |        resume traversal after fetched  |\n *      |----------------------------------------|\n *      |\n *      |                     async load tile content\n * tilset.requestedTiles  ----------------------------- RequestScheduler\n *                                                             |\n * tilset.selectedTiles (ready for rendering)                  |\n *      |         Listen to                                    |\n *   Tile3DLayer ----------- onTileLoad  ----------------------|\n *      |                         |   notify new tile is available\n *   updateLayers                 |\n *                       tileset.update // trigger another round of update\n*/\nexport class Tileset3D {\n    // props: Tileset3DProps;\n    options;\n    loadOptions;\n    type;\n    tileset;\n    loader;\n    url;\n    basePath;\n    modelMatrix;\n    ellipsoid;\n    lodMetricType;\n    lodMetricValue;\n    refine;\n    root = null;\n    roots = {};\n    /** @todo any->unknown */\n    asset = {};\n    // Metadata for the entire tileset\n    description = '';\n    properties;\n    extras = null;\n    attributions = {};\n    credits = {};\n    stats;\n    /** flags that contain information about data types in nested tiles */\n    contentFormats = { draco: false, meshopt: false, dds: false, ktx2: false };\n    // view props\n    cartographicCenter = null;\n    cartesianCenter = null;\n    zoom = 1;\n    boundingVolume = null;\n    /** Updated based on the camera position and direction */\n    dynamicScreenSpaceErrorComputedDensity = 0.0;\n    // METRICS\n    /**\n     * The maximum amount of GPU memory (in MB) that may be used to cache tiles\n     * Tiles not in view are unloaded to enforce private\n     */\n    maximumMemoryUsage = 32;\n    /** The total amount of GPU memory in bytes used by the tileset. */\n    gpuMemoryUsageInBytes = 0;\n    /**\n     * If loading the level of detail required by maximumScreenSpaceError\n     * results in the memory usage exceeding maximumMemoryUsage (GPU), level of detail refinement\n     * will instead use this (larger) adjusted screen space error to achieve the\n     * best possible visual quality within the available memory.\n     */\n    memoryAdjustedScreenSpaceError = 0.0;\n    _cacheBytes = 0;\n    _cacheOverflowBytes = 0;\n    /** Update tracker. increase in each update cycle. */\n    _frameNumber = 0;\n    _queryParams = {};\n    _extensionsUsed = [];\n    _tiles = {};\n    /** counter for tracking tiles requests */\n    _pendingCount = 0;\n    /** Hold traversal results */\n    selectedTiles = [];\n    // TRAVERSAL\n    traverseCounter = 0;\n    geometricError = 0;\n    lastUpdatedVieports = null;\n    _requestedTiles = [];\n    _emptyTiles = [];\n    frameStateData = {};\n    _traverser;\n    _cache = new TilesetCache();\n    _requestScheduler;\n    // Promise tracking\n    updatePromise = null;\n    tilesetInitializationPromise;\n    /**\n     * Create a new Tileset3D\n     * @param json\n     * @param props\n     */\n    // eslint-disable-next-line max-statements\n    constructor(tileset, options) {\n        // PUBLIC MEMBERS\n        this.options = { ...DEFAULT_PROPS, ...options };\n        // raw data\n        this.tileset = tileset;\n        this.loader = tileset.loader;\n        // could be  3d tiles, i3s\n        this.type = tileset.type;\n        // The url to a tileset JSON file.\n        this.url = tileset.url;\n        this.basePath = tileset.basePath || path.dirname(this.url);\n        this.modelMatrix = this.options.modelMatrix;\n        this.ellipsoid = this.options.ellipsoid;\n        // Geometric error when the tree is not rendered at all\n        this.lodMetricType = tileset.lodMetricType;\n        this.lodMetricValue = tileset.lodMetricValue;\n        this.refine = tileset.root.refine;\n        this.loadOptions = this.options.loadOptions || {};\n        // TRAVERSAL\n        this._traverser = this._initializeTraverser();\n        this._requestScheduler = new RequestScheduler({\n            throttleRequests: this.options.throttleRequests,\n            maxRequests: this.options.maxRequests\n        });\n        this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError;\n        this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024;\n        this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024;\n        // METRICS\n        // The total amount of GPU memory in bytes used by the tileset.\n        this.stats = new Stats({ id: this.url });\n        this._initializeStats();\n        this.tilesetInitializationPromise = this._initializeTileSet(tileset);\n    }\n    /** Release resources */\n    destroy() {\n        this._destroy();\n    }\n    /** Is the tileset loaded (update needs to have been called at least once) */\n    isLoaded() {\n        // Check that `_frameNumber !== 0` which means that update was called at least once\n        return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;\n    }\n    get tiles() {\n        return Object.values(this._tiles);\n    }\n    get frameNumber() {\n        return this._frameNumber;\n    }\n    get queryParams() {\n        return new URLSearchParams(this._queryParams).toString();\n    }\n    setProps(props) {\n        this.options = { ...this.options, ...props };\n    }\n    /** @deprecated */\n    // setOptions(options: Tileset3DProps): void {\n    //   this.options = {...this.options, ...options};\n    // }\n    /**\n     * Return a loadable tile url for a specific tile subpath\n     * @param tilePath a tile subpath\n     */\n    getTileUrl(tilePath) {\n        const isDataUrl = tilePath.startsWith('data:');\n        if (isDataUrl) {\n            return tilePath;\n        }\n        let tileUrl = tilePath;\n        if (this.queryParams.length) {\n            tileUrl = `${tilePath}${tilePath.includes('?') ? '&' : '?'}${this.queryParams}`;\n        }\n        return tileUrl;\n    }\n    // TODO CESIUM specific\n    hasExtension(extensionName) {\n        return Boolean(this._extensionsUsed.indexOf(extensionName) > -1);\n    }\n    /**\n     * Update visible tiles relying on a list of viewports\n     * @param viewports - list of viewports\n     * @deprecated\n     */\n    update(viewports = null) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.tilesetInitializationPromise.then(() => {\n            if (!viewports && this.lastUpdatedVieports) {\n                viewports = this.lastUpdatedVieports;\n            }\n            else {\n                this.lastUpdatedVieports = viewports;\n            }\n            if (viewports) {\n                this.doUpdate(viewports);\n            }\n        });\n    }\n    /**\n     * Update visible tiles relying on a list of viewports.\n     * Do it with debounce delay to prevent update spam\n     * @param viewports viewports\n     * @returns Promise of new frameNumber\n     */\n    async selectTiles(viewports = null) {\n        await this.tilesetInitializationPromise;\n        if (viewports) {\n            this.lastUpdatedVieports = viewports;\n        }\n        if (!this.updatePromise) {\n            this.updatePromise = new Promise((resolve) => {\n                setTimeout(() => {\n                    if (this.lastUpdatedVieports) {\n                        this.doUpdate(this.lastUpdatedVieports);\n                    }\n                    resolve(this._frameNumber);\n                    this.updatePromise = null;\n                }, this.options.debounceTime);\n            });\n        }\n        return this.updatePromise;\n    }\n    adjustScreenSpaceError() {\n        if (this.gpuMemoryUsageInBytes < this._cacheBytes) {\n            this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError);\n        }\n        else if (this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes) {\n            this.memoryAdjustedScreenSpaceError *= 1.02;\n        }\n    }\n    /**\n     * Update visible tiles relying on a list of viewports\n     * @param viewports viewports\n     */\n    // eslint-disable-next-line max-statements, complexity\n    doUpdate(viewports) {\n        if ('loadTiles' in this.options && !this.options.loadTiles) {\n            return;\n        }\n        if (this.traverseCounter > 0) {\n            return;\n        }\n        const preparedViewports = viewports instanceof Array ? viewports : [viewports];\n        this._cache.reset();\n        this._frameNumber++;\n        this.traverseCounter = preparedViewports.length;\n        const viewportsToTraverse = [];\n        // First loop to decrement traverseCounter\n        for (const viewport of preparedViewports) {\n            const id = viewport.id;\n            if (this._needTraverse(id)) {\n                viewportsToTraverse.push(id);\n            }\n            else {\n                this.traverseCounter--;\n            }\n        }\n        // Second loop to traverse\n        for (const viewport of preparedViewports) {\n            const id = viewport.id;\n            if (!this.roots[id]) {\n                this.roots[id] = this._initializeTileHeaders(this.tileset, null);\n            }\n            if (!viewportsToTraverse.includes(id)) {\n                continue; // eslint-disable-line no-continue\n            }\n            const frameState = getFrameState(viewport, this._frameNumber);\n            this._traverser.traverse(this.roots[id], frameState, this.options);\n        }\n    }\n    /**\n     * Check if traversal is needed for particular viewport\n     * @param {string} viewportId - id of a viewport\n     * @return {boolean}\n     */\n    _needTraverse(viewportId) {\n        let traverserId = viewportId;\n        if (this.options.viewportTraversersMap) {\n            traverserId = this.options.viewportTraversersMap[viewportId];\n        }\n        if (traverserId !== viewportId) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * The callback to post-process tiles after traversal procedure\n     * @param frameState - frame state for tile culling\n     */\n    _onTraversalEnd(frameState) {\n        const id = frameState.viewport.id;\n        if (!this.frameStateData[id]) {\n            this.frameStateData[id] = { selectedTiles: [], _requestedTiles: [], _emptyTiles: [] };\n        }\n        const currentFrameStateData = this.frameStateData[id];\n        const selectedTiles = Object.values(this._traverser.selectedTiles);\n        const [filteredSelectedTiles, unselectedTiles] = limitSelectedTiles(selectedTiles, frameState, this.options.maximumTilesSelected);\n        currentFrameStateData.selectedTiles = filteredSelectedTiles;\n        for (const tile of unselectedTiles) {\n            tile.unselect();\n        }\n        currentFrameStateData._requestedTiles = Object.values(this._traverser.requestedTiles);\n        currentFrameStateData._emptyTiles = Object.values(this._traverser.emptyTiles);\n        this.traverseCounter--;\n        if (this.traverseCounter > 0) {\n            return;\n        }\n        this._updateTiles();\n    }\n    /**\n     * Update tiles relying on data from all traversers\n     */\n    _updateTiles() {\n        this.selectedTiles = [];\n        this._requestedTiles = [];\n        this._emptyTiles = [];\n        for (const frameStateKey in this.frameStateData) {\n            const frameStateDataValue = this.frameStateData[frameStateKey];\n            this.selectedTiles = this.selectedTiles.concat(frameStateDataValue.selectedTiles);\n            this._requestedTiles = this._requestedTiles.concat(frameStateDataValue._requestedTiles);\n            this._emptyTiles = this._emptyTiles.concat(frameStateDataValue._emptyTiles);\n        }\n        this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);\n        for (const tile of this.selectedTiles) {\n            this._tiles[tile.id] = tile;\n        }\n        this._loadTiles();\n        this._unloadTiles();\n        this._updateStats();\n    }\n    _tilesChanged(oldSelectedTiles, selectedTiles) {\n        if (oldSelectedTiles.length !== selectedTiles.length) {\n            return true;\n        }\n        const set1 = new Set(oldSelectedTiles.map((t) => t.id));\n        const set2 = new Set(selectedTiles.map((t) => t.id));\n        let changed = oldSelectedTiles.filter((x) => !set2.has(x.id)).length > 0;\n        changed = changed || selectedTiles.filter((x) => !set1.has(x.id)).length > 0;\n        return changed;\n    }\n    _loadTiles() {\n        // Sort requests by priority before making any requests.\n        // This makes it less likely this requests will be cancelled after being issued.\n        // requestedTiles.sort((a, b) => a._priority - b._priority);\n        for (const tile of this._requestedTiles) {\n            if (tile.contentUnloaded) {\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                this._loadTile(tile);\n            }\n        }\n    }\n    _unloadTiles() {\n        // unload tiles from cache when hit maximumMemoryUsage\n        this._cache.unloadTiles(this, (tileset, tile) => tileset._unloadTile(tile));\n    }\n    _updateStats() {\n        let tilesRenderable = 0;\n        let pointsRenderable = 0;\n        for (const tile of this.selectedTiles) {\n            if (tile.contentAvailable && tile.content) {\n                tilesRenderable++;\n                if (tile.content.pointCount) {\n                    pointsRenderable += tile.content.pointCount;\n                }\n                else {\n                    // Calculate vertices for non point cloud tiles.\n                    pointsRenderable += tile.content.vertexCount;\n                }\n            }\n        }\n        this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;\n        this.stats.get(TILES_RENDERABLE).count = tilesRenderable;\n        this.stats.get(POINTS_COUNT).count = pointsRenderable;\n        this.stats.get(MAXIMUM_SSE).count = this.memoryAdjustedScreenSpaceError;\n    }\n    async _initializeTileSet(tilesetJson) {\n        if (this.type === TILESET_TYPE.I3S) {\n            this.calculateViewPropsI3S();\n            tilesetJson.root = await tilesetJson.root;\n        }\n        this.root = this._initializeTileHeaders(tilesetJson, null);\n        if (this.type === TILESET_TYPE.TILES3D) {\n            this._initializeTiles3DTileset(tilesetJson);\n            this.calculateViewPropsTiles3D();\n        }\n        if (this.type === TILESET_TYPE.I3S) {\n            this._initializeI3STileset();\n        }\n    }\n    /**\n     * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.\n     * These metrics help apps center view on tileset\n     * For I3S there is extent (<1.8 version) or fullExtent (>=1.8 version) to calculate view props\n     * @returns\n     */\n    calculateViewPropsI3S() {\n        // for I3S 1.8 try to calculate with fullExtent\n        const fullExtent = this.tileset.fullExtent;\n        if (fullExtent) {\n            const { xmin, xmax, ymin, ymax, zmin, zmax } = fullExtent;\n            this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, zmin + (zmax - zmin) / 2);\n            this.cartesianCenter = new Vector3();\n            Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter);\n            this.zoom = getZoomFromFullExtent(fullExtent, this.cartographicCenter, this.cartesianCenter);\n            return;\n        }\n        // for I3S 1.6-1.7 try to calculate with extent\n        const extent = this.tileset.store?.extent;\n        if (extent) {\n            const [xmin, ymin, xmax, ymax] = extent;\n            this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, 0);\n            this.cartesianCenter = new Vector3();\n            Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter);\n            this.zoom = getZoomFromExtent(extent, this.cartographicCenter, this.cartesianCenter);\n            return;\n        }\n        // eslint-disable-next-line no-console\n        console.warn('Extent is not defined in the tileset header');\n        this.cartographicCenter = new Vector3();\n        this.zoom = 1;\n        return;\n    }\n    /**\n     * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.\n     * These metrics help apps center view on tileset.\n     * For 3DTiles the root tile data is used to calculate view props.\n     * @returns\n     */\n    calculateViewPropsTiles3D() {\n        const root = this.root;\n        const { center } = root.boundingVolume;\n        // TODO - handle all cases\n        if (!center) {\n            // eslint-disable-next-line no-console\n            console.warn('center was not pre-calculated for the root tile');\n            this.cartographicCenter = new Vector3();\n            this.zoom = 1;\n            return;\n        }\n        // cartographic coordinates are undefined at the center of the ellipsoid\n        if (center[0] !== 0 || center[1] !== 0 || center[2] !== 0) {\n            this.cartographicCenter = new Vector3();\n            Ellipsoid.WGS84.cartesianToCartographic(center, this.cartographicCenter);\n        }\n        else {\n            this.cartographicCenter = new Vector3(0, 0, -Ellipsoid.WGS84.radii[0]);\n        }\n        this.cartesianCenter = center;\n        this.zoom = getZoomFromBoundingVolume(root.boundingVolume, this.cartographicCenter);\n    }\n    _initializeStats() {\n        this.stats.get(TILES_TOTAL);\n        this.stats.get(TILES_LOADING);\n        this.stats.get(TILES_IN_MEMORY);\n        this.stats.get(TILES_IN_VIEW);\n        this.stats.get(TILES_RENDERABLE);\n        this.stats.get(TILES_LOADED);\n        this.stats.get(TILES_UNLOADED);\n        this.stats.get(TILES_LOAD_FAILED);\n        this.stats.get(POINTS_COUNT);\n        this.stats.get(TILES_GPU_MEMORY, 'memory');\n        this.stats.get(MAXIMUM_SSE);\n    }\n    // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.\n    // eslint-disable-next-line max-statements\n    _initializeTileHeaders(tilesetJson, parentTileHeader) {\n        // A tileset JSON file referenced from a tile may exist in a different directory than the root tileset.\n        // Get the basePath relative to the external tileset.\n        const rootTile = new Tile3D(this, tilesetJson.root, parentTileHeader); // resource\n        // If there is a parentTileHeader, add the root of the currently loading tileset\n        // to parentTileHeader's children, and update its depth.\n        if (parentTileHeader) {\n            parentTileHeader.children.push(rootTile);\n            rootTile.depth = parentTileHeader.depth + 1;\n        }\n        // 3DTiles knows the hierarchy beforehand\n        if (this.type === TILESET_TYPE.TILES3D) {\n            const stack = [];\n            stack.push(rootTile);\n            while (stack.length > 0) {\n                const tile = stack.pop();\n                this.stats.get(TILES_TOTAL).incrementCount();\n                const children = tile.header.children || [];\n                for (const childHeader of children) {\n                    const childTile = new Tile3D(this, childHeader, tile);\n                    // Special handling for Google\n                    // A session key must be used for all tile requests\n                    if (childTile.contentUrl?.includes('?session=')) {\n                        const url = new URL(childTile.contentUrl);\n                        const session = url.searchParams.get('session');\n                        // eslint-disable-next-line max-depth\n                        if (session) {\n                            this._queryParams.session = session;\n                        }\n                    }\n                    tile.children.push(childTile);\n                    childTile.depth = tile.depth + 1;\n                    stack.push(childTile);\n                }\n            }\n        }\n        return rootTile;\n    }\n    _initializeTraverser() {\n        let TraverserClass;\n        const type = this.type;\n        switch (type) {\n            case TILESET_TYPE.TILES3D:\n                TraverserClass = Tileset3DTraverser;\n                break;\n            case TILESET_TYPE.I3S:\n                TraverserClass = I3STilesetTraverser;\n                break;\n            default:\n                TraverserClass = TilesetTraverser;\n        }\n        return new TraverserClass({\n            basePath: this.basePath,\n            onTraversalEnd: this._onTraversalEnd.bind(this)\n        });\n    }\n    _destroyTileHeaders(parentTile) {\n        this._destroySubtree(parentTile);\n    }\n    async _loadTile(tile) {\n        let loaded;\n        try {\n            this._onStartTileLoading();\n            loaded = await tile.loadContent();\n        }\n        catch (error) {\n            this._onTileLoadError(tile, error instanceof Error ? error : new Error('load failed'));\n        }\n        finally {\n            this._onEndTileLoading();\n            this._onTileLoad(tile, loaded);\n        }\n    }\n    _onTileLoadError(tile, error) {\n        this.stats.get(TILES_LOAD_FAILED).incrementCount();\n        const message = error.message || error.toString();\n        const url = tile.url;\n        // TODO - Allow for probe log to be injected instead of console?\n        console.error(`A 3D tile failed to load: ${tile.url} ${message}`); // eslint-disable-line\n        this.options.onTileError(tile, message, url);\n    }\n    _onTileLoad(tile, loaded) {\n        if (!loaded) {\n            return;\n        }\n        if (this.type === TILESET_TYPE.I3S) {\n            // We can't calculate tiles total in I3S in advance so we calculate it dynamically.\n            const nodesInNodePages = this.tileset?.nodePagesTile?.nodesInNodePages || 0;\n            this.stats.get(TILES_TOTAL).reset();\n            this.stats.get(TILES_TOTAL).addCount(nodesInNodePages);\n        }\n        // add coordinateOrigin and modelMatrix to tile\n        if (tile && tile.content) {\n            calculateTransformProps(tile, tile.content);\n        }\n        this.updateContentTypes(tile);\n        this._addTileToCache(tile);\n        this.options.onTileLoad(tile);\n    }\n    /**\n     * Update information about data types in nested tiles\n     * @param tile instance of a nested Tile3D\n     */\n    updateContentTypes(tile) {\n        if (this.type === TILESET_TYPE.I3S) {\n            if (tile.header.isDracoGeometry) {\n                this.contentFormats.draco = true;\n            }\n            switch (tile.header.textureFormat) {\n                case 'dds':\n                    this.contentFormats.dds = true;\n                    break;\n                case 'ktx2':\n                    this.contentFormats.ktx2 = true;\n                    break;\n                default:\n            }\n        }\n        else if (this.type === TILESET_TYPE.TILES3D) {\n            const { extensionsRemoved = [] } = tile.content?.gltf || {};\n            if (extensionsRemoved.includes('KHR_draco_mesh_compression')) {\n                this.contentFormats.draco = true;\n            }\n            if (extensionsRemoved.includes('EXT_meshopt_compression')) {\n                this.contentFormats.meshopt = true;\n            }\n            if (extensionsRemoved.includes('KHR_texture_basisu')) {\n                this.contentFormats.ktx2 = true;\n            }\n        }\n    }\n    _onStartTileLoading() {\n        this._pendingCount++;\n        this.stats.get(TILES_LOADING).incrementCount();\n    }\n    _onEndTileLoading() {\n        this._pendingCount--;\n        this.stats.get(TILES_LOADING).decrementCount();\n    }\n    _addTileToCache(tile) {\n        this._cache.add(this, tile, (tileset) => tileset._updateCacheStats(tile));\n    }\n    _updateCacheStats(tile) {\n        this.stats.get(TILES_LOADED).incrementCount();\n        this.stats.get(TILES_IN_MEMORY).incrementCount();\n        // TODO: Calculate GPU memory usage statistics for a tile.\n        this.gpuMemoryUsageInBytes += tile.gpuMemoryUsageInBytes || 0;\n        this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n        // Adjust SSE based on cache limits\n        if (this.options.memoryAdjustedScreenSpaceError) {\n            this.adjustScreenSpaceError();\n        }\n    }\n    _unloadTile(tile) {\n        this.gpuMemoryUsageInBytes -= tile.gpuMemoryUsageInBytes || 0;\n        this.stats.get(TILES_IN_MEMORY).decrementCount();\n        this.stats.get(TILES_UNLOADED).incrementCount();\n        this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n        this.options.onTileUnload(tile);\n        tile.unloadContent();\n    }\n    // Traverse the tree and destroy all tiles\n    _destroy() {\n        const stack = [];\n        if (this.root) {\n            stack.push(this.root);\n        }\n        while (stack.length > 0) {\n            const tile = stack.pop();\n            for (const child of tile.children) {\n                stack.push(child);\n            }\n            this._destroyTile(tile);\n        }\n        this.root = null;\n    }\n    // Traverse the tree and destroy all sub tiles\n    _destroySubtree(tile) {\n        const root = tile;\n        const stack = [];\n        stack.push(root);\n        while (stack.length > 0) {\n            tile = stack.pop();\n            for (const child of tile.children) {\n                stack.push(child);\n            }\n            if (tile !== root) {\n                this._destroyTile(tile);\n            }\n        }\n        root.children = [];\n    }\n    _destroyTile(tile) {\n        this._cache.unloadTile(this, tile);\n        this._unloadTile(tile);\n        tile.destroy();\n    }\n    _initializeTiles3DTileset(tilesetJson) {\n        if (tilesetJson.queryString) {\n            const searchParams = new URLSearchParams(tilesetJson.queryString);\n            const queryParams = Object.fromEntries(searchParams.entries());\n            this._queryParams = { ...this._queryParams, ...queryParams };\n        }\n        this.asset = tilesetJson.asset;\n        if (!this.asset) {\n            throw new Error('Tileset must have an asset property.');\n        }\n        if (this.asset.version !== '0.0' &&\n            this.asset.version !== '1.0' &&\n            this.asset.version !== '1.1') {\n            throw new Error('The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.');\n        }\n        // Note: `asset.tilesetVersion` is version of the tileset itself (not the version of the 3D TILES standard)\n        // We add this version as a `v=1.0` query param to fetch the right version and not get an older cached version\n        if ('tilesetVersion' in this.asset) {\n            this._queryParams.v = this.asset.tilesetVersion;\n        }\n        // TODO - ion resources have a credits property we can use for additional attribution.\n        this.credits = {\n            attributions: this.options.attributions || []\n        };\n        this.description = this.options.description || '';\n        // Gets the tileset's properties dictionary object, which contains metadata about per-feature properties.\n        this.properties = tilesetJson.properties;\n        this.geometricError = tilesetJson.geometricError;\n        this._extensionsUsed = tilesetJson.extensionsUsed || [];\n        // Returns the extras property at the top of the tileset JSON (application specific metadata).\n        this.extras = tilesetJson.extras;\n    }\n    _initializeI3STileset() {\n        // @ts-expect-error\n        if (this.loadOptions.i3s && 'token' in this.loadOptions.i3s) {\n            // @ts-ignore\n            this._queryParams.token = this.loadOptions.i3s.token;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}