{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// All utility methods needed to implement Marching Squares algorithm\n// Ref: https://en.wikipedia.org/wiki/Marching_squares\nimport { ISOLINES_CODE_OFFSET_MAP, ISOBANDS_CODE_OFFSET_MAP } from \"./marching-squares-codes.js\";\n// Utility methods\nfunction getVertexCode(weight, threshold) {\n  // threshold must be a single value or a range (array of size 2)\n  if (Number.isNaN(weight)) {\n    return 0;\n  }\n  // Iso-bands\n  if (Array.isArray(threshold)) {\n    if (weight < threshold[0]) {\n      return 0;\n    }\n    return weight < threshold[1] ? 1 : 2;\n  }\n  // Iso-lines\n  return weight >= threshold ? 1 : 0;\n}\n// Returns marching square code for given cell\n/* eslint-disable complexity, max-statements*/\nexport function getCode(opts) {\n  // Assumptions\n  // Origin is on bottom-left , and X increase to right, Y to top\n  // When processing one cell, we process 4 cells, by extending row to top and on column to right\n  // to create a 2X2 cell grid\n  const {\n    x,\n    y,\n    xRange,\n    yRange,\n    getValue,\n    threshold\n  } = opts;\n  const isLeftBoundary = x < xRange[0];\n  const isRightBoundary = x >= xRange[1] - 1;\n  const isBottomBoundary = y < yRange[0];\n  const isTopBoundary = y >= yRange[1] - 1;\n  const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;\n  let weights = 0;\n  let current;\n  let right;\n  let top;\n  let topRight;\n  // TOP\n  if (isLeftBoundary || isTopBoundary) {\n    top = 0;\n  } else {\n    const w = getValue(x, y + 1);\n    top = getVertexCode(w, threshold);\n    weights += w;\n  }\n  // TOP-RIGHT\n  if (isRightBoundary || isTopBoundary) {\n    topRight = 0;\n  } else {\n    const w = getValue(x + 1, y + 1);\n    topRight = getVertexCode(w, threshold);\n    weights += w;\n  }\n  // RIGHT\n  if (isRightBoundary || isBottomBoundary) {\n    right = 0;\n  } else {\n    const w = getValue(x + 1, y);\n    right = getVertexCode(w, threshold);\n    weights += w;\n  }\n  // CURRENT\n  if (isLeftBoundary || isBottomBoundary) {\n    current = 0;\n  } else {\n    const w = getValue(x, y);\n    current = getVertexCode(w, threshold);\n    weights += w;\n  }\n  let code = -1;\n  if (Number.isFinite(threshold)) {\n    code = top << 3 | topRight << 2 | right << 1 | current;\n  }\n  if (Array.isArray(threshold)) {\n    code = top << 6 | topRight << 4 | right << 2 | current;\n  }\n  let meanCode = 0;\n  // meanCode is only needed for saddle cases, and they should\n  // only occur when we are not processing a cell on boundary\n  // because when on a boundary either, bottom-row, top-row, left-column or right-column will have both 0 codes\n  if (!isBoundary) {\n    meanCode = getVertexCode(weights / 4, threshold);\n  }\n  return {\n    code,\n    meanCode\n  };\n}\n/* eslint-enable complexity, max-statements*/\n// Returns intersection vertices for given cellindex\n// [x, y] refers current marching cell, reference vertex is always top-right corner\nexport function getPolygons(opts) {\n  const {\n    x,\n    y,\n    z,\n    code,\n    meanCode\n  } = opts;\n  let offsets = ISOBANDS_CODE_OFFSET_MAP[code];\n  // handle saddle cases\n  if (!Array.isArray(offsets)) {\n    offsets = offsets[meanCode];\n  }\n  // Reference vertex is at top-right move to top-right corner\n  const rX = x + 1;\n  const rY = y + 1;\n  // offsets format\n  // [[1A, 1B, 1C, ...], [2A, 2B, 2C, ...]],\n  // vertices format\n  // [\n  //   [[x1A, y1A], [x1B, y1B], [x1C, y1C] ... ],\n  //        ...\n  // ]\n  const polygons = [];\n  offsets.forEach(polygonOffsets => {\n    const polygon = [];\n    polygonOffsets.forEach(xyOffset => {\n      const vX = rX + xyOffset[0];\n      const vY = rY + xyOffset[1];\n      polygon.push([vX, vY, z]);\n    });\n    polygons.push(polygon);\n  });\n  return polygons;\n}\n// Returns intersection vertices for given cellindex\n// [x, y] refers current marching cell, reference vertex is always top-right corner\nexport function getLines(opts) {\n  const {\n    x,\n    y,\n    z,\n    code,\n    meanCode\n  } = opts;\n  let offsets = ISOLINES_CODE_OFFSET_MAP[code];\n  // handle saddle cases\n  if (!Array.isArray(offsets)) {\n    offsets = offsets[meanCode];\n  }\n  // Reference vertex is at top-right move to top-right corner\n  const rX = x + 1;\n  const rY = y + 1;\n  // offsets format\n  // [[1A, 1B], [2A, 2B]],\n  // vertices format\n  // [[x1A, y1A], [x1B, y1B], [x2A, x2B], ...],\n  const lines = [];\n  offsets.forEach(xyOffsets => {\n    xyOffsets.forEach(offset => {\n      const vX = rX + offset[0];\n      const vY = rY + offset[1];\n      lines.push([vX, vY, z]);\n    });\n  });\n  return lines;\n}","map":{"version":3,"names":["ISOLINES_CODE_OFFSET_MAP","ISOBANDS_CODE_OFFSET_MAP","getVertexCode","weight","threshold","Number","isNaN","Array","isArray","getCode","opts","x","y","xRange","yRange","getValue","isLeftBoundary","isRightBoundary","isBottomBoundary","isTopBoundary","isBoundary","weights","current","right","top","topRight","w","code","isFinite","meanCode","getPolygons","z","offsets","rX","rY","polygons","forEach","polygonOffsets","polygon","xyOffset","vX","vY","push","getLines","lines","xyOffsets","offset"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\aggregation-layers\\src\\contour-layer\\marching-squares.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// All utility methods needed to implement Marching Squares algorithm\n// Ref: https://en.wikipedia.org/wiki/Marching_squares\n\nimport {ISOLINES_CODE_OFFSET_MAP, ISOBANDS_CODE_OFFSET_MAP} from './marching-squares-codes';\n\n// Utility methods\n\nfunction getVertexCode(weight: number, threshold: number | number[]): number {\n  // threshold must be a single value or a range (array of size 2)\n  if (Number.isNaN(weight)) {\n    return 0;\n  }\n  // Iso-bands\n  if (Array.isArray(threshold)) {\n    if (weight < threshold[0]) {\n      return 0;\n    }\n    return weight < threshold[1] ? 1 : 2;\n  }\n  // Iso-lines\n  return weight >= threshold ? 1 : 0;\n}\n\n// Returns marching square code for given cell\n/* eslint-disable complexity, max-statements*/\nexport function getCode(opts: {\n  getValue: (x: number, y: number) => number;\n  threshold: number | number[];\n  x: number;\n  xRange: [number, number];\n  y: number;\n  yRange: [number, number];\n}): {\n  code: number;\n  meanCode: number;\n} {\n  // Assumptions\n  // Origin is on bottom-left , and X increase to right, Y to top\n  // When processing one cell, we process 4 cells, by extending row to top and on column to right\n  // to create a 2X2 cell grid\n  const {x, y, xRange, yRange, getValue, threshold} = opts;\n\n  const isLeftBoundary = x < xRange[0];\n  const isRightBoundary = x >= xRange[1] - 1;\n  const isBottomBoundary = y < yRange[0];\n  const isTopBoundary = y >= yRange[1] - 1;\n  const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;\n\n  let weights: number = 0;\n  let current: number;\n  let right: number;\n  let top: number;\n  let topRight: number;\n\n  // TOP\n  if (isLeftBoundary || isTopBoundary) {\n    top = 0;\n  } else {\n    const w = getValue(x, y + 1);\n    top = getVertexCode(w, threshold);\n    weights += w;\n  }\n\n  // TOP-RIGHT\n  if (isRightBoundary || isTopBoundary) {\n    topRight = 0;\n  } else {\n    const w = getValue(x + 1, y + 1);\n    topRight = getVertexCode(w, threshold);\n    weights += w;\n  }\n\n  // RIGHT\n  if (isRightBoundary || isBottomBoundary) {\n    right = 0;\n  } else {\n    const w = getValue(x + 1, y);\n    right = getVertexCode(w, threshold);\n    weights += w;\n  }\n\n  // CURRENT\n  if (isLeftBoundary || isBottomBoundary) {\n    current = 0;\n  } else {\n    const w = getValue(x, y);\n    current = getVertexCode(w, threshold);\n    weights += w;\n  }\n\n  let code = -1;\n  if (Number.isFinite(threshold)) {\n    code = (top << 3) | (topRight << 2) | (right << 1) | current;\n  }\n  if (Array.isArray(threshold)) {\n    code = (top << 6) | (topRight << 4) | (right << 2) | current;\n  }\n\n  let meanCode = 0;\n  // meanCode is only needed for saddle cases, and they should\n  // only occur when we are not processing a cell on boundary\n  // because when on a boundary either, bottom-row, top-row, left-column or right-column will have both 0 codes\n  if (!isBoundary) {\n    meanCode = getVertexCode(weights / 4, threshold);\n  }\n  return {code, meanCode};\n}\n/* eslint-enable complexity, max-statements*/\n\n// Returns intersection vertices for given cellindex\n// [x, y] refers current marching cell, reference vertex is always top-right corner\nexport function getPolygons(opts: {\n  x: number;\n  y: number;\n  z: number;\n  code: number;\n  meanCode: number;\n}) {\n  const {x, y, z, code, meanCode} = opts;\n  let offsets: any = ISOBANDS_CODE_OFFSET_MAP[code];\n\n  // handle saddle cases\n  if (!Array.isArray(offsets)) {\n    offsets = offsets[meanCode];\n  }\n\n  // Reference vertex is at top-right move to top-right corner\n  const rX = x + 1;\n  const rY = y + 1;\n\n  // offsets format\n  // [[1A, 1B, 1C, ...], [2A, 2B, 2C, ...]],\n  // vertices format\n  // [\n  //   [[x1A, y1A], [x1B, y1B], [x1C, y1C] ... ],\n  //        ...\n  // ]\n\n  const polygons: number[][][] = [];\n  offsets.forEach(polygonOffsets => {\n    const polygon: number[][] = [];\n    polygonOffsets.forEach(xyOffset => {\n      const vX = rX + xyOffset[0];\n      const vY = rY + xyOffset[1];\n      polygon.push([vX, vY, z]);\n    });\n    polygons.push(polygon);\n  });\n  return polygons;\n}\n\n// Returns intersection vertices for given cellindex\n// [x, y] refers current marching cell, reference vertex is always top-right corner\nexport function getLines(opts: {x: number; y: number; z: number; code: number; meanCode: number}) {\n  const {x, y, z, code, meanCode} = opts;\n  let offsets = ISOLINES_CODE_OFFSET_MAP[code];\n\n  // handle saddle cases\n  if (!Array.isArray(offsets)) {\n    offsets = offsets[meanCode];\n  }\n\n  // Reference vertex is at top-right move to top-right corner\n  const rX = x + 1;\n  const rY = y + 1;\n\n  // offsets format\n  // [[1A, 1B], [2A, 2B]],\n  // vertices format\n  // [[x1A, y1A], [x1B, y1B], [x2A, x2B], ...],\n  const lines: number[][] = [];\n  offsets.forEach(xyOffsets => {\n    xyOffsets.forEach(offset => {\n      const vX = rX + offset[0];\n      const vY = rY + offset[1];\n      lines.push([vX, vY, z]);\n    });\n  });\n  return lines;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}