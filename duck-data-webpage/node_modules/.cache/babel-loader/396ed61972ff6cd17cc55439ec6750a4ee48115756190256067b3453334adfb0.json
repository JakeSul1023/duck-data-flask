{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { createIterable, getAccessorFromBuffer } from \"./iterable-utils.js\";\nimport defaultTypedArrayManager from \"./typed-array-manager.js\";\nimport assert from \"./assert.js\";\nimport { Buffer } from '@luma.gl/core';\nexport default class Tesselator {\n  constructor(opts) {\n    this.indexStarts = [0];\n    this.vertexStarts = [0];\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    const {\n      attributes = {}\n    } = opts;\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n    this.updateGeometry(opts);\n  }\n  /* Public methods */\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n    // @ts-ignore (2339) when geometryBuffer is a luma Buffer, size falls back to positionFormat\n    geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices); // binary data missing startIndices\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.vertexPositions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.vertexPositions;\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n  updatePartialGeometry({\n    startRow,\n    endRow\n  }) {\n    this._rebuildGeometry({\n      startRow,\n      endRow\n    });\n  }\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n    if (!ArrayBuffer.isView(value)) {\n      // Cannot read binary geometries\n      return null;\n    }\n    // @ts-ignore (2322) NumericArray not assignable to GeometryT\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n  /* Private utility methods */\n  _allocate(instanceCount, copy) {\n    // allocate attributes\n    const {\n      attributes,\n      buffers,\n      _attributeDefs,\n      typedArrayManager\n    } = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {\n      data,\n      getGeometry\n    } = this;\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;\n      visitor(geometry, objectInfo.index);\n    }\n  }\n  /* eslint-disable complexity,max-statements */\n  _rebuildGeometry(dataRange) {\n    if (!this.data) {\n      return;\n    }\n    let {\n      indexStarts,\n      vertexStarts,\n      instanceCount\n    } = this;\n    const {\n      data,\n      geometryBuffer\n    } = this;\n    const {\n      startRow = 0,\n      endRow = Infinity\n    } = dataRange || {};\n    const normalizedData = {};\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry((geometry, dataIndex) => {\n        const normalizedGeometry = geometry && this.normalizeGeometry(geometry);\n        normalizedData[dataIndex] = normalizedGeometry;\n        vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);\n      }, startRow, endRow);\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else {\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || 0;\n      if (ArrayBuffer.isView(geometryBuffer)) {\n        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;\n      } else if (geometryBuffer instanceof Buffer) {\n        const byteStride = this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;\n      } else if (geometryBuffer.buffer) {\n        const byteStride = geometryBuffer.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;\n      } else if (geometryBuffer.value) {\n        const bufferValue = geometryBuffer.value;\n        const elementStride =\n        // @ts-ignore (2339) if stride is not specified, will fall through to positionSize\n        geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        instanceCount = instanceCount || bufferValue.length / elementStride;\n      }\n    }\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n    // @ts-ignore (2739) context will be populated in the loop\n    const context = {};\n    this._forEachGeometry((geometry, dataIndex) => {\n      const normalizedGeometry = normalizedData[dataIndex] || geometry;\n      context.vertexStart = vertexStarts[dataIndex];\n      context.indexStart = indexStarts[dataIndex];\n      const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n      context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n      context.geometryIndex = dataIndex;\n      this.updateGeometryAttributes(normalizedGeometry, context);\n    }, startRow, endRow);\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}","map":{"version":3,"names":["createIterable","getAccessorFromBuffer","defaultTypedArrayManager","assert","Buffer","Tesselator","constructor","opts","indexStarts","vertexStarts","vertexCount","instanceCount","attributes","typedArrayManager","_attributeDefs","updateGeometry","Object","assign","data","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","normalize","positionSize","size","startIndices","getGeometryFromBuffer","vertexPositions","Array","isArray","dataRange","_rebuildGeometry","updatePartialGeometry","startRow","endRow","value","ArrayBuffer","isView","offset","stride","_allocate","copy","name","release","def","allocate","_forEachGeometry","visitor","iterable","objectInfo","object","index","geometry","Infinity","normalizedData","dataIndex","normalizedGeometry","normalizeGeometry","getGeometrySize","length","byteStride","byteLength","buffer","bufferValue","elementStride","BYTES_PER_ELEMENT","Boolean","context","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex","updateGeometryAttributes"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\utils\\tesselator.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/core';\n\nimport type {BinaryAttribute} from '../lib/attribute/attribute';\nimport type {TypedArray} from '../types/types';\nimport type {AccessorFunction} from '../types/layer-props';\nimport type {TypedArrayManager} from './typed-array-manager';\n\ntype ExternalBuffer = TypedArray | Buffer | BinaryAttribute;\n\ntype TesselatorOptions<GeometryT, ExtraOptionsT> = ExtraOptionsT & {\n  attributes?: Record<string, any>;\n  getGeometry?: AccessorFunction<any, GeometryT>;\n  data?: any;\n  buffers?: Record<string, ExternalBuffer>;\n  geometryBuffer?: ExternalBuffer;\n  positionFormat?: 'XY' | 'XYZ';\n  dataChanged?: {startRow: number; endRow?: number}[] | string | false;\n  normalize?: boolean;\n};\n\nexport type GeometryUpdateContext = {\n  vertexStart: number;\n  indexStart: number;\n  geometrySize: number;\n  geometryIndex: number;\n};\n\nexport default abstract class Tesselator<GeometryT, NormalizedGeometryT, ExtraOptionsT> {\n  opts: TesselatorOptions<GeometryT, ExtraOptionsT>;\n  typedArrayManager: TypedArrayManager;\n  indexStarts: number[] = [0];\n  vertexStarts: number[] = [0];\n  vertexCount: number = 0;\n  instanceCount: number = 0;\n  attributes: Record<string, TypedArray | null>;\n\n  protected _attributeDefs: any;\n  protected data: any;\n  protected getGeometry?: AccessorFunction<any, GeometryT> | null;\n  protected geometryBuffer?: ExternalBuffer;\n  protected buffers!: Record<string, ExternalBuffer>;\n  protected positionSize!: number;\n  protected normalize!: boolean;\n\n  constructor(opts: TesselatorOptions<GeometryT, ExtraOptionsT>) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n  }\n\n  /* Public methods */\n  updateGeometry(opts: TesselatorOptions<GeometryT, ExtraOptionsT>): void {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      // @ts-ignore (2339) when geometryBuffer is a luma Buffer, size falls back to positionFormat\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices); // binary data missing startIndices\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.vertexPositions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.vertexPositions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged as {startRow: number; endRow?: number}[]) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}: {startRow: number; endRow: number}): void {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  // Subclass interface\n\n  /** Convert geometry to a uniform shape */\n  protected abstract normalizeGeometry(geometry: GeometryT): NormalizedGeometryT;\n\n  /** Update the positions buffer of a single geometry */\n  protected abstract updateGeometryAttributes(\n    geometry: NormalizedGeometryT | null,\n    context: GeometryUpdateContext\n  );\n\n  /** Get the number of vertices in a geometry */\n  protected abstract getGeometrySize(geometry: NormalizedGeometryT): number;\n\n  protected getGeometryFromBuffer(\n    geometryBuffer: ExternalBuffer\n  ): AccessorFunction<any, GeometryT> | null {\n    const value = (geometryBuffer as BinaryAttribute).value || geometryBuffer;\n    if (!ArrayBuffer.isView(value)) {\n      // Cannot read binary geometries\n      return null;\n    }\n\n    // @ts-ignore (2322) NumericArray not assignable to GeometryT\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: (geometryBuffer as BinaryAttribute).offset,\n      stride: (geometryBuffer as BinaryAttribute).stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  private _allocate(instanceCount: number, copy: boolean): void {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  private _forEachGeometry(\n    visitor: (geometry: GeometryT | null, index: number) => void,\n    startRow: number,\n    endRow: number\n  ): void {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  private _rebuildGeometry(dataRange?: {startRow: number; endRow?: number}): void {\n    if (!this.data) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    const normalizedData: Record<number, NormalizedGeometryT | null> = {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry: GeometryT | null, dataIndex: number) => {\n          const normalizedGeometry = geometry && this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = normalizedGeometry;\n          vertexStarts[dataIndex + 1] =\n            vertexStarts[dataIndex] +\n            (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else {\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || 0;\n\n      if (ArrayBuffer.isView(geometryBuffer)) {\n        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;\n      } else if (geometryBuffer instanceof Buffer) {\n        const byteStride = this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;\n      } else if (geometryBuffer.buffer) {\n        const byteStride = geometryBuffer.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;\n      } else if (geometryBuffer.value) {\n        const bufferValue = geometryBuffer.value;\n        const elementStride =\n          // @ts-ignore (2339) if stride is not specified, will fall through to positionSize\n          geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        instanceCount = instanceCount || bufferValue.length / elementStride;\n      }\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    // @ts-ignore (2739) context will be populated in the loop\n    const context: GeometryUpdateContext = {};\n\n    this._forEachGeometry(\n      (geometry: GeometryT | null, dataIndex: number) => {\n        const normalizedGeometry =\n          normalizedData[dataIndex] || (geometry as unknown as NormalizedGeometryT);\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(normalizedGeometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}