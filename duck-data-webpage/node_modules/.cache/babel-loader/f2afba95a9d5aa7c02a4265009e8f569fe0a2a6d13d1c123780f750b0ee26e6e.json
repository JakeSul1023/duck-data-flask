{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport function isTable(table) {\n  const shape = typeof table === 'object' && table?.shape;\n  switch (shape) {\n    case 'array-row-table':\n    case 'object-row-table':\n      return Array.isArray(table.data);\n    case 'geojson-table':\n      return Array.isArray(table.features);\n    case 'columnar-table':\n      return table.data && typeof table.data === 'object';\n    case 'arrow-table':\n      return Boolean(table?.data?.numRows !== undefined);\n    default:\n      return false;\n  }\n}\n/**\n * Returns the length of the table (i.e. the number of rows)\n */\nexport function getTableLength(table) {\n  switch (table.shape) {\n    case 'array-row-table':\n    case 'object-row-table':\n      return table.data.length;\n    case 'geojson-table':\n      return table.features.length;\n    case 'arrow-table':\n      const arrowTable = table.data;\n      return arrowTable.numRows;\n    case 'columnar-table':\n      for (const column of Object.values(table.data)) {\n        return column.length || 0;\n      }\n      return 0;\n    default:\n      throw new Error('table');\n  }\n}\n/**\n * Returns the number of columns in the table\n * @throws Fails to deduce number of columns if the table has no schema and is empty\n */\nexport function getTableNumCols(table) {\n  if (table.schema) {\n    return table.schema.fields.length;\n  }\n  if (getTableLength(table) === 0) {\n    throw new Error('empty table');\n  }\n  switch (table.shape) {\n    case 'array-row-table':\n      return table.data[0].length;\n    case 'object-row-table':\n      return Object.keys(table.data[0]).length;\n    case 'geojson-table':\n      return Object.keys(table.features[0]).length;\n    case 'columnar-table':\n      return Object.keys(table.data).length;\n    case 'arrow-table':\n      const arrowTable = table.data;\n      return arrowTable.numCols;\n    default:\n      throw new Error('table');\n  }\n}\n/** Get a table cell value at row index and column name */\nexport function getTableCell(table, rowIndex, columnName) {\n  switch (table.shape) {\n    case 'array-row-table':\n      const columnIndex = getTableColumnIndex(table, columnName);\n      return table.data[rowIndex][columnIndex];\n    case 'object-row-table':\n      return table.data[rowIndex][columnName];\n    case 'geojson-table':\n      return table.features[rowIndex][columnName];\n    case 'columnar-table':\n      const column = table.data[columnName];\n      return column[rowIndex];\n    case 'arrow-table':\n      const arrowTable = table.data;\n      const arrowColumnIndex = arrowTable.schema.fields.findIndex(field => field.name === columnName);\n      return arrowTable.getChildAt(arrowColumnIndex)?.get(rowIndex);\n    default:\n      throw new Error('todo');\n  }\n}\n/** Get a table cell value at row index and column name */\nexport function getTableCellAt(table, rowIndex, columnIndex) {\n  switch (table.shape) {\n    case 'array-row-table':\n      return table.data[rowIndex][columnIndex];\n    case 'object-row-table':\n      const columnName1 = getTableColumnName(table, columnIndex);\n      return table.data[rowIndex][columnName1];\n    case 'geojson-table':\n      const columnName2 = getTableColumnName(table, columnIndex);\n      return table.features[rowIndex][columnName2];\n    case 'columnar-table':\n      const columnName3 = getTableColumnName(table, columnIndex);\n      const column = table.data[columnName3];\n      return column[rowIndex];\n    case 'arrow-table':\n      const arrowTable = table.data;\n      return arrowTable.getChildAt(columnIndex)?.get(rowIndex);\n    default:\n      throw new Error('todo');\n  }\n}\n/** Deduce the table row shape */\nexport function getTableRowShape(table) {\n  switch (table.shape) {\n    case 'array-row-table':\n    case 'object-row-table':\n      return table.shape;\n    case 'geojson-table':\n      // TODO - this is not correct, geojson-table is not a row table\n      return 'object-row-table';\n    case 'columnar-table':\n    default:\n      throw new Error('Not a row table');\n  }\n}\n/** Get the index of a named table column. Requires the table to have a schema */\nexport function getTableColumnIndex(table, columnName) {\n  const columnIndex = table.schema?.fields.findIndex(field => field.name === columnName);\n  if (columnIndex === undefined) {\n    throw new Error(columnName);\n  }\n  return columnIndex;\n}\n/** Get the name of a table column by index. Requires the table to have a schema */\nexport function getTableColumnName(table, columnIndex) {\n  const columnName = table.schema?.fields[columnIndex]?.name;\n  if (!columnName) {\n    throw new Error(`${columnIndex}`);\n  }\n  return columnName;\n}\n/**\n * Returns one row of the table in object format.\n * @param target Optional parameter will be used if needed to store the row. Can be reused between calls to improve performance\n * @returns an array representing the row. May be the original array in the row, a new object, or the target parameter\n */\n// eslint-disable-next-line complexity\nexport function getTableRowAsObject(table, rowIndex, target, copy) {\n  switch (table.shape) {\n    case 'object-row-table':\n      return copy ? Object.fromEntries(Object.entries(table.data[rowIndex])) : table.data[rowIndex];\n    case 'array-row-table':\n      if (table.schema) {\n        const objectRow = target || {};\n        for (let i = 0; i < table.schema.fields.length; i++) {\n          objectRow[table.schema.fields[i].name] = table.data[rowIndex][i];\n        }\n        return objectRow;\n      }\n      throw new Error('no schema');\n    case 'geojson-table':\n      if (table.schema) {\n        const objectRow = target || {};\n        // TODO - should lift properties to top level\n        for (let i = 0; i < table.schema.fields.length; i++) {\n          objectRow[table.schema.fields[i].name] = table.features[rowIndex][i];\n        }\n        return objectRow;\n      }\n      throw new Error('no schema');\n    case 'columnar-table':\n      if (table.schema) {\n        const objectRow = target || {};\n        for (let i = 0; i < table.schema.fields.length; i++) {\n          objectRow[table.schema.fields[i].name] = table.data[table.schema.fields[i].name][rowIndex];\n        }\n        return objectRow;\n      } else {\n        // eslint-disable-line no-else-return\n        const objectRow = target || {};\n        for (const [name, column] of Object.entries(table.data)) {\n          objectRow[name] = column[rowIndex];\n        }\n        return objectRow;\n      }\n    case 'arrow-table':\n      const arrowTable = table.data;\n      const objectRow = target || {};\n      const row = arrowTable.get(rowIndex);\n      const schema = arrowTable.schema;\n      for (let i = 0; i < schema.fields.length; i++) {\n        objectRow[schema.fields[i].name] = row?.[schema.fields[i].name];\n      }\n      return objectRow;\n    default:\n      throw new Error('shape');\n  }\n}\n/**\n * Returns one row of the table in array format.\n * @param target Optional parameter will be used if needed to store the row. Can be reused between calls to improve performance.\n * @returns an array representing the row. May be the original array in the row, a new object, or the target parameter\n */\n// eslint-disable-next-line complexity\nexport function getTableRowAsArray(table, rowIndex, target, copy) {\n  switch (table.shape) {\n    case 'array-row-table':\n      return copy ? Array.from(table.data[rowIndex]) : table.data[rowIndex];\n    case 'object-row-table':\n      if (table.schema) {\n        const arrayRow = target || [];\n        for (let i = 0; i < table.schema.fields.length; i++) {\n          arrayRow[i] = table.data[rowIndex][table.schema.fields[i].name];\n        }\n        return arrayRow;\n      }\n      // Warning: just slap on the values, this risks mismatches between rows\n      return Object.values(table.data[rowIndex]);\n    case 'geojson-table':\n      if (table.schema) {\n        const arrayRow = target || [];\n        // TODO - should lift properties to top level\n        for (let i = 0; i < table.schema.fields.length; i++) {\n          arrayRow[i] = table.features[rowIndex][table.schema.fields[i].name];\n        }\n        return arrayRow;\n      }\n      // Warning: just slap on the values, this risks mismatches between rows\n      return Object.values(table.features[rowIndex]);\n    case 'columnar-table':\n      if (table.schema) {\n        const arrayRow = target || [];\n        for (let i = 0; i < table.schema.fields.length; i++) {\n          arrayRow[i] = table.data[table.schema.fields[i].name][rowIndex];\n        }\n        return arrayRow;\n      } else {\n        // eslint-disable-line no-else-return\n        const arrayRow = target || [];\n        let i = 0;\n        for (const column of Object.values(table.data)) {\n          arrayRow[i] = column[rowIndex];\n          i++;\n        }\n        return arrayRow;\n      }\n    case 'arrow-table':\n      const arrowTable = table.data;\n      const arrayRow = target || [];\n      const row = arrowTable.get(rowIndex);\n      const schema = arrowTable.schema;\n      for (let i = 0; i < schema.fields.length; i++) {\n        arrayRow[i] = row?.[schema.fields[i].name];\n      }\n      return arrayRow;\n    default:\n      throw new Error('shape');\n  }\n}\n/** Convert any table into array row format */\nexport function makeArrayRowTable(table) {\n  if (table.shape === 'array-row-table') {\n    return table;\n  }\n  const length = getTableLength(table);\n  const data = new Array(length);\n  for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n    data[rowIndex] = getTableRowAsArray(table, rowIndex);\n  }\n  return {\n    shape: 'array-row-table',\n    schema: table.schema,\n    data\n  };\n}\n/** Convert any table into object row format */\nexport function makeObjectRowTable(table) {\n  if (table.shape === 'object-row-table') {\n    return table;\n  }\n  const length = getTableLength(table);\n  const data = new Array(length);\n  for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n    data[rowIndex] = getTableRowAsObject(table, rowIndex);\n  }\n  return {\n    shape: 'object-row-table',\n    schema: table.schema,\n    data\n  };\n}\n/** Convert any table into object row format */\nexport function makeColumnarTable(table) {\n  if (table.shape === 'object-row-table') {\n    return table;\n  }\n  const length = getTableLength(table);\n  const data = new Array(length);\n  for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n    data[rowIndex] = getTableRowAsObject(table, rowIndex);\n  }\n  return {\n    shape: 'object-row-table',\n    schema: table.schema,\n    data\n  };\n}\n// Row Iterators\n/**\n * Iterate over table rows\n * @param table\n * @param shape\n */\nexport function* makeRowIterator(table, shape) {\n  switch (shape) {\n    case 'array-row-table':\n      yield* makeArrayRowIterator(table);\n      break;\n    case 'object-row-table':\n      yield* makeObjectRowIterator(table);\n      break;\n    default:\n      throw new Error(`Unknown row type ${shape}`);\n  }\n}\n/**\n * Streaming processing: Iterate over table, yielding array rows\n * @param table\n * @param shape\n */\nexport function makeArrayRowIterator(table) {\n  let target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return function* () {\n    const length = getTableLength(table);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n      yield getTableRowAsArray(table, rowIndex, target);\n    }\n  }();\n}\n/**\n * Streaming processing: Iterate over table, yielding object rows\n * @param table\n * @param shape\n */\nexport function makeObjectRowIterator(table) {\n  let target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function* () {\n    const length = getTableLength(table);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n      yield getTableRowAsObject(table, rowIndex, target);\n    }\n  }();\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}