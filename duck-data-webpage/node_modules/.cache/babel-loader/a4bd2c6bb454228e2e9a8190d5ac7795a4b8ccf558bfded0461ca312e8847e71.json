{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { initializeShaderModule } from '@luma.gl/shadertools';\nimport { ShaderInputs } from \"../shader-inputs.js\";\nimport { ClipSpace } from \"../models/clip-space.js\";\nimport { SwapFramebuffers } from \"../compute/swap.js\";\nimport { BackgroundTextureModel } from \"../models/billboard-texture-model.js\";\nimport { getFragmentShaderForRenderPass } from \"./get-fragment-shader.js\";\n/** A pass that renders a given texture into screen space */\nexport class ShaderPassRenderer {\n  device;\n  shaderInputs;\n  passRenderers;\n  swapFramebuffers;\n  /** For rendering to the screen */\n  clipSpace;\n  textureModel;\n  constructor(device, props) {\n    this.device = device;\n    props.shaderPasses.map(shaderPass => initializeShaderModule(shaderPass));\n    const modules = props.shaderPasses.reduce((object, shaderPass) => ({\n      ...object,\n      [shaderPass.name]: shaderPass\n    }), {});\n    this.shaderInputs = props.shaderInputs || new ShaderInputs(modules);\n    const size = device.getCanvasContext().getPixelSize();\n    this.swapFramebuffers = new SwapFramebuffers(device, {\n      colorAttachments: ['rgba8unorm'],\n      width: size[0],\n      height: size[1]\n    });\n    this.textureModel = new BackgroundTextureModel(device, {\n      backgroundTexture: this.swapFramebuffers.current.colorAttachments[0].texture\n    });\n    this.clipSpace = new ClipSpace(device, {\n      source: /* wgsl */`\\\n  @group(0) @binding(0) var sourceTexture: texture_2d<f32>;\n  @group(0) @binding(1) var sourceTextureSampler: sampler;\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n\tlet texCoord: vec2<f32> = inputs.coordinate;\n\treturn textureSample(sourceTexture, sourceTextureSampler, texCoord);\n}\n`,\n      fs: /* glsl */`\\\n#version 300 es\n\nuniform sampler2D sourceTexture;\nin vec2 uv;\nin vec2 coordinate;\nout vec4 fragColor;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n  fragColor = texture(sourceTexture, coordinate);\n}\n`\n    });\n    this.passRenderers = props.shaderPasses.map(shaderPass => new PassRenderer(device, shaderPass));\n  }\n  /** Destroys resources created by this ShaderPassRenderer */\n  destroy() {\n    for (const subPassRenderer of this.passRenderers) {\n      subPassRenderer.destroy();\n    }\n    this.swapFramebuffers.destroy();\n    this.clipSpace.destroy();\n  }\n  resize(width, height) {\n    this.swapFramebuffers.resize({\n      width,\n      height\n    });\n    // this.props.passes.forEach(pass => pass.resize(width, height));\n  }\n  renderToScreen(options) {\n    // Run the shader passes and generate an output texture\n    const outputTexture = this.renderToTexture(options);\n    if (!outputTexture) {\n      // source texture not yet loaded\n      return false;\n    }\n    const renderPass = this.device.beginRenderPass({\n      clearColor: [0, 0, 0, 1],\n      clearDepth: 1\n    });\n    this.clipSpace.setBindings({\n      sourceTexture: outputTexture\n    });\n    this.clipSpace.draw(renderPass);\n    renderPass.end();\n    return true;\n  }\n  /** Runs the shaderPasses in sequence on the sourceTexture and returns a texture with the results.\n   * @returns null if the the sourceTexture has not yet been loaded\n   */\n  renderToTexture(options) {\n    const {\n      sourceTexture\n    } = options;\n    if (!sourceTexture.isReady) {\n      return null;\n    }\n    this.textureModel.destroy();\n    this.textureModel = new BackgroundTextureModel(this.device, {\n      backgroundTexture: sourceTexture\n    });\n    // Clear the current texture before we begin\n    const clearTexturePass = this.device.beginRenderPass({\n      framebuffer: this.swapFramebuffers.current,\n      clearColor: [0, 0, 0, 1]\n    });\n    this.textureModel.draw(clearTexturePass);\n    clearTexturePass.end();\n    // const commandEncoder = this.device.createCommandEncoder();\n    // commandEncoder.copyTextureToTexture({\n    //   sourceTexture: sourceTexture.texture,\n    //   destinationTexture: this.swapFramebuffers.current.colorAttachments[0].texture\n    // });\n    // commandEncoder.finish();\n    let first = true;\n    for (const passRenderer of this.passRenderers) {\n      for (const subPassRenderer of passRenderer.subPassRenderers) {\n        if (!first) {\n          this.swapFramebuffers.swap();\n        }\n        first = false;\n        const swapBufferTexture = this.swapFramebuffers.current.colorAttachments[0].texture;\n        const bindings = {\n          sourceTexture: swapBufferTexture\n          // texSize: [sourceTextures.width, sourceTextures.height]\n        };\n        const renderPass = this.device.beginRenderPass({\n          framebuffer: this.swapFramebuffers.next,\n          clearColor: [0, 0, 0, 1],\n          clearDepth: 1\n        });\n        subPassRenderer.render({\n          renderPass,\n          bindings\n        });\n        renderPass.end();\n      }\n    }\n    this.swapFramebuffers.swap();\n    const outputTexture = this.swapFramebuffers.current.colorAttachments[0].texture;\n    return outputTexture;\n  }\n}\n/** renders one ShaderPass */\nclass PassRenderer {\n  shaderPass;\n  subPassRenderers;\n  constructor(device, shaderPass, props = {}) {\n    this.shaderPass = shaderPass;\n    // const id = `${shaderPass.name}-pass`;\n    const subPasses = shaderPass.passes || [];\n    // normalizePasses(gl, module, id, props);\n    this.subPassRenderers = subPasses.map(subPass => {\n      // const idn = `${id}-${subPasses.length + 1}`;\n      return new SubPassRenderer(device, shaderPass, subPass);\n    });\n  }\n  destroy() {\n    for (const subPassRenderer of this.subPassRenderers) {\n      subPassRenderer.destroy();\n    }\n  }\n}\n/** Renders one subpass of a ShaderPass */\nclass SubPassRenderer {\n  model;\n  shaderPass;\n  subPass;\n  constructor(device, shaderPass, subPass) {\n    this.shaderPass = shaderPass;\n    this.subPass = subPass;\n    const action = subPass.action || subPass.filter && 'filter' || subPass.sampler && 'sample' || 'filter';\n    const fs = getFragmentShaderForRenderPass({\n      shaderPass,\n      action,\n      shadingLanguage: device.info.shadingLanguage\n    });\n    this.model = new ClipSpace(device, {\n      id: `${shaderPass.name}-subpass`,\n      source: fs,\n      fs,\n      modules: [shaderPass],\n      parameters: {\n        depthWriteEnabled: false,\n        depthCompare: 'always'\n      }\n    });\n  }\n  destroy() {\n    this.model.destroy();\n  }\n  render(options) {\n    const {\n      renderPass,\n      bindings\n    } = options;\n    this.model.shaderInputs.setProps({\n      [this.shaderPass.name]: this.shaderPass.uniforms || {}\n    });\n    this.model.shaderInputs.setProps({\n      [this.shaderPass.name]: this.subPass.uniforms || {}\n    });\n    // this.model.setBindings(this.subPass.bindings || {});\n    this.model.setBindings(bindings || {});\n    this.model.draw(renderPass);\n  }\n}","map":{"version":3,"names":["initializeShaderModule","ShaderInputs","ClipSpace","SwapFramebuffers","BackgroundTextureModel","getFragmentShaderForRenderPass","ShaderPassRenderer","device","shaderInputs","passRenderers","swapFramebuffers","clipSpace","textureModel","constructor","props","shaderPasses","map","shaderPass","modules","reduce","object","name","size","getCanvasContext","getPixelSize","colorAttachments","width","height","backgroundTexture","current","texture","source","fs","PassRenderer","destroy","subPassRenderer","resize","renderToScreen","options","outputTexture","renderToTexture","renderPass","beginRenderPass","clearColor","clearDepth","setBindings","sourceTexture","draw","end","isReady","clearTexturePass","framebuffer","first","passRenderer","subPassRenderers","swap","swapBufferTexture","bindings","next","render","subPasses","passes","subPass","SubPassRenderer","model","action","filter","sampler","shadingLanguage","info","id","parameters","depthWriteEnabled","depthCompare","setProps","uniforms"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\engine\\src\\passes\\shader-pass-renderer.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, RenderPass, Texture} from '@luma.gl/core';\nimport type {ShaderPass} from '@luma.gl/shadertools';\nimport {initializeShaderModule} from '@luma.gl/shadertools';\nimport {ShaderInputs} from '../shader-inputs';\nimport {AsyncTexture} from '../async-texture/async-texture';\nimport {ClipSpace} from '../models/clip-space';\nimport {SwapFramebuffers} from '../compute/swap';\nimport {BackgroundTextureModel} from '../models/billboard-texture-model';\n\nimport {getFragmentShaderForRenderPass} from './get-fragment-shader';\n\ntype ShaderSubPass = NonNullable<ShaderPass['passes']>[0];\n\n/** Props for ShaderPassRenderer */\nexport type ShaderPassRendererProps = {\n  /** List of ShaderPasses to apply to the sourceTexture */\n  shaderPasses: ShaderPass[];\n  /** Optional typed ShaderInputs object for setting uniforms */\n  shaderInputs: ShaderInputs;\n};\n\n/** A pass that renders a given texture into screen space */\nexport class ShaderPassRenderer {\n  device: Device;\n  shaderInputs: ShaderInputs;\n  passRenderers: PassRenderer[];\n  swapFramebuffers: SwapFramebuffers;\n  /** For rendering to the screen */\n  clipSpace: ClipSpace;\n  textureModel: BackgroundTextureModel;\n\n  constructor(device: Device, props: ShaderPassRendererProps) {\n    this.device = device;\n\n    props.shaderPasses.map(shaderPass => initializeShaderModule(shaderPass));\n\n    const modules = props.shaderPasses.reduce(\n      (object, shaderPass) => ({...object, [shaderPass.name]: shaderPass}),\n      {}\n    );\n    this.shaderInputs = props.shaderInputs || new ShaderInputs(modules);\n\n    const size = device.getCanvasContext().getPixelSize();\n    this.swapFramebuffers = new SwapFramebuffers(device, {\n      colorAttachments: ['rgba8unorm'],\n      width: size[0],\n      height: size[1]\n    });\n\n    this.textureModel = new BackgroundTextureModel(device, {\n      backgroundTexture: this.swapFramebuffers.current.colorAttachments[0].texture\n    });\n\n    this.clipSpace = new ClipSpace(device, {\n      source: /* wgsl */ `\\\n  @group(0) @binding(0) var sourceTexture: texture_2d<f32>;\n  @group(0) @binding(1) var sourceTextureSampler: sampler;\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n\tlet texCoord: vec2<f32> = inputs.coordinate;\n\treturn textureSample(sourceTexture, sourceTextureSampler, texCoord);\n}\n`,\n\n      fs: /* glsl */ `\\\n#version 300 es\n\nuniform sampler2D sourceTexture;\nin vec2 uv;\nin vec2 coordinate;\nout vec4 fragColor;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n  fragColor = texture(sourceTexture, coordinate);\n}\n`\n    });\n\n    this.passRenderers = props.shaderPasses.map(shaderPass => new PassRenderer(device, shaderPass));\n  }\n\n  /** Destroys resources created by this ShaderPassRenderer */\n  destroy() {\n    for (const subPassRenderer of this.passRenderers) {\n      subPassRenderer.destroy();\n    }\n    this.swapFramebuffers.destroy();\n    this.clipSpace.destroy();\n  }\n\n  resize(width: number, height: number): void {\n    this.swapFramebuffers.resize({width, height});\n    // this.props.passes.forEach(pass => pass.resize(width, height));\n  }\n\n  renderToScreen(options: {sourceTexture: AsyncTexture; uniforms: any; bindings: any}): boolean {\n    // Run the shader passes and generate an output texture\n    const outputTexture = this.renderToTexture(options);\n    if (!outputTexture) {\n      // source texture not yet loaded\n      return false;\n    }\n\n    const renderPass = this.device.beginRenderPass({clearColor: [0, 0, 0, 1], clearDepth: 1});\n    this.clipSpace.setBindings({sourceTexture: outputTexture});\n    this.clipSpace.draw(renderPass);\n    renderPass.end();\n    return true;\n  }\n\n  /** Runs the shaderPasses in sequence on the sourceTexture and returns a texture with the results.\n   * @returns null if the the sourceTexture has not yet been loaded\n   */\n  renderToTexture(options: {\n    sourceTexture: AsyncTexture;\n    uniforms: any;\n    bindings: any;\n  }): Texture | null {\n    const {sourceTexture} = options;\n    if (!sourceTexture.isReady) {\n      return null;\n    }\n\n    this.textureModel.destroy();\n    this.textureModel = new BackgroundTextureModel(this.device, {\n      backgroundTexture: sourceTexture\n    });\n\n    // Clear the current texture before we begin\n    const clearTexturePass = this.device.beginRenderPass({\n      framebuffer: this.swapFramebuffers.current,\n      clearColor: [0, 0, 0, 1]\n    });\n    this.textureModel.draw(clearTexturePass);\n    clearTexturePass.end();\n\n    // const commandEncoder = this.device.createCommandEncoder();\n    // commandEncoder.copyTextureToTexture({\n    //   sourceTexture: sourceTexture.texture,\n    //   destinationTexture: this.swapFramebuffers.current.colorAttachments[0].texture\n    // });\n    // commandEncoder.finish();\n\n    let first = true;\n    for (const passRenderer of this.passRenderers) {\n      for (const subPassRenderer of passRenderer.subPassRenderers) {\n        if (!first) {\n          this.swapFramebuffers.swap();\n        }\n        first = false;\n\n        const swapBufferTexture = this.swapFramebuffers.current.colorAttachments[0].texture;\n\n        const bindings = {\n          sourceTexture: swapBufferTexture\n          // texSize: [sourceTextures.width, sourceTextures.height]\n        };\n\n        const renderPass = this.device.beginRenderPass({\n          framebuffer: this.swapFramebuffers.next,\n          clearColor: [0, 0, 0, 1],\n          clearDepth: 1\n        });\n        subPassRenderer.render({renderPass, bindings});\n        renderPass.end();\n      }\n    }\n\n    this.swapFramebuffers.swap();\n    const outputTexture = this.swapFramebuffers.current.colorAttachments[0].texture;\n    return outputTexture;\n  }\n}\n\n/** renders one ShaderPass */\nclass PassRenderer {\n  shaderPass: ShaderPass;\n  subPassRenderers: SubPassRenderer[];\n\n  constructor(device: Device, shaderPass: ShaderPass, props = {}) {\n    this.shaderPass = shaderPass;\n    // const id = `${shaderPass.name}-pass`;\n\n    const subPasses = shaderPass.passes || [];\n    // normalizePasses(gl, module, id, props);\n\n    this.subPassRenderers = subPasses.map(subPass => {\n      // const idn = `${id}-${subPasses.length + 1}`;\n      return new SubPassRenderer(device, shaderPass, subPass);\n    });\n  }\n\n  destroy() {\n    for (const subPassRenderer of this.subPassRenderers) {\n      subPassRenderer.destroy();\n    }\n  }\n}\n\n/** Renders one subpass of a ShaderPass */\nclass SubPassRenderer {\n  model: ClipSpace;\n  shaderPass: ShaderPass;\n  subPass: ShaderSubPass;\n\n  constructor(device: Device, shaderPass: ShaderPass, subPass: ShaderSubPass) {\n    this.shaderPass = shaderPass;\n    this.subPass = subPass;\n    const action =\n      subPass.action || (subPass.filter && 'filter') || (subPass.sampler && 'sample') || 'filter';\n    const fs = getFragmentShaderForRenderPass({\n      shaderPass,\n      action,\n      shadingLanguage: device.info.shadingLanguage\n    });\n\n    this.model = new ClipSpace(device, {\n      id: `${shaderPass.name}-subpass`,\n      source: fs,\n      fs,\n      modules: [shaderPass],\n      parameters: {\n        depthWriteEnabled: false,\n        depthCompare: 'always'\n      }\n    });\n  }\n\n  destroy() {\n    this.model.destroy();\n  }\n\n  render(options: {renderPass: RenderPass; bindings: any}): void {\n    const {renderPass, bindings} = options;\n\n    this.model.shaderInputs.setProps({\n      [this.shaderPass.name]: this.shaderPass.uniforms || {}\n    });\n    this.model.shaderInputs.setProps({\n      [this.shaderPass.name]: this.subPass.uniforms || {}\n    });\n    // this.model.setBindings(this.subPass.bindings || {});\n    this.model.setBindings(bindings || {});\n    this.model.draw(renderPass);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}