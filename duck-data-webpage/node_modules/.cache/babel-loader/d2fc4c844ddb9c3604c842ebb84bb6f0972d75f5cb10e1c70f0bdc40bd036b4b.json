{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Matrix3, _MathUtils } from '@math.gl/core';\nconst scratchMatrix = new Matrix3();\nconst scratchUnitary = new Matrix3();\nconst scratchDiagonal = new Matrix3();\nconst jMatrix = new Matrix3();\nconst jMatrixTranspose = new Matrix3();\n/**\n * Computes the eigenvectors and eigenvalues of a symmetric matrix.\n *\n * - Returns a diagonal matrix and unitary matrix such that:\n * `matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)`\n * - The values along the diagonal of the diagonal matrix are the eigenvalues. The columns\n * of the unitary matrix are the corresponding eigenvectors.\n * - This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n * section 8.4.3 The Classical Jacobi Algorithm\n *\n * @param matrix The 3x3 matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.\n * @param result Optional object with unitary and diagonal properties which are matrices onto which to store the result.\n * @returns An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.\n *\n * @example\n * const a = //... symmetric matrix\n * const result = {\n *   unitary : new Matrix3(),\n *   diagonal : new Matrix3()\n * };\n * computeEigenDecomposition(a, result);\n *\n * const unitaryTranspose = Matrix3.transpose(result.unitary, new Matrix3());\n * const b = Matrix3.multiply(result.unitary, result.diagonal, new Matrix3());\n * Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n *\n * const lambda = result.diagonal.getColumn(0, new Vector3()).x;  // first eigenvalue\n * const v = result.unitary.getColumn(0, new Vector3());          // first eigenvector\n * const c = v.multiplyByScalar(lambda);                          // equal to v.transformByMatrix3(a)\n */\nexport function computeEigenDecomposition(matrix,\n// @ts-expect-error accept empty object type\nresult = {}) {\n  const EIGEN_TOLERANCE = _MathUtils.EPSILON20;\n  const EIGEN_MAX_SWEEPS = 10;\n  let count = 0;\n  let sweep = 0;\n  const unitaryMatrix = scratchUnitary;\n  const diagonalMatrix = scratchDiagonal;\n  unitaryMatrix.identity();\n  diagonalMatrix.copy(matrix);\n  const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);\n  while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {\n    shurDecomposition(diagonalMatrix, jMatrix);\n    jMatrixTranspose.copy(jMatrix).transpose();\n    diagonalMatrix.multiplyRight(jMatrix);\n    diagonalMatrix.multiplyLeft(jMatrixTranspose);\n    unitaryMatrix.multiplyRight(jMatrix);\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n  result.unitary = unitaryMatrix.toTarget(result.unitary);\n  result.diagonal = diagonalMatrix.toTarget(result.diagonal);\n  return result;\n}\nfunction computeFrobeniusNorm(matrix) {\n  let norm = 0.0;\n  for (let i = 0; i < 9; ++i) {\n    const temp = matrix[i];\n    norm += temp * temp;\n  }\n  return Math.sqrt(norm);\n}\nconst rowVal = [1, 0, 0];\nconst colVal = [2, 2, 1];\n// Computes the \"off-diagonal\" Frobenius norm.\n// Assumes matrix is symmetric.\nfunction offDiagonalFrobeniusNorm(matrix) {\n  let norm = 0.0;\n  for (let i = 0; i < 3; ++i) {\n    const temp = matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n  return Math.sqrt(norm);\n}\n// The routine takes a matrix, which is assumed to be symmetric, and\n// finds the largest off-diagonal term, and then creates\n// a matrix (result) which can be used to help reduce it\n//\n// This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n// section 8.4.2 The 2by2 Symmetric Schur Decomposition.\n//\n// eslint-disable-next-line max-statements\nfunction shurDecomposition(matrix, result) {\n  const tolerance = _MathUtils.EPSILON15;\n  let maxDiagonal = 0.0;\n  let rotAxis = 1;\n  // find pivot (rotAxis) based on max diagonal of matrix\n  for (let i = 0; i < 3; ++i) {\n    const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])]);\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n  const p = rowVal[rotAxis];\n  const q = colVal[rotAxis];\n  let c = 1.0;\n  let s = 0.0;\n  if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p)]) > tolerance) {\n    const qq = matrix[scratchMatrix.getElementIndex(q, q)];\n    const pp = matrix[scratchMatrix.getElementIndex(p, p)];\n    const qp = matrix[scratchMatrix.getElementIndex(q, p)];\n    const tau = (qq - pp) / 2.0 / qp;\n    let t;\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n  // Copy into result\n  Matrix3.IDENTITY.to(result);\n  result[scratchMatrix.getElementIndex(p, p)] = result[scratchMatrix.getElementIndex(q, q)] = c;\n  result[scratchMatrix.getElementIndex(q, p)] = s;\n  result[scratchMatrix.getElementIndex(p, q)] = -s;\n  return result;\n}","map":{"version":3,"names":["Matrix3","_MathUtils","scratchMatrix","scratchUnitary","scratchDiagonal","jMatrix","jMatrixTranspose","computeEigenDecomposition","matrix","result","EIGEN_TOLERANCE","EPSILON20","EIGEN_MAX_SWEEPS","count","sweep","unitaryMatrix","diagonalMatrix","identity","copy","epsilon","computeFrobeniusNorm","offDiagonalFrobeniusNorm","shurDecomposition","transpose","multiplyRight","multiplyLeft","unitary","toTarget","diagonal","norm","i","temp","Math","sqrt","rowVal","colVal","getElementIndex","tolerance","EPSILON15","maxDiagonal","rotAxis","abs","p","q","c","s","qq","pp","qp","tau","t","IDENTITY","to"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\culling\\src\\lib\\algorithms\\compute-eigen-decomposition.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Matrix3, _MathUtils} from '@math.gl/core';\n\nconst scratchMatrix = new Matrix3();\nconst scratchUnitary = new Matrix3();\nconst scratchDiagonal = new Matrix3();\n\nconst jMatrix = new Matrix3();\nconst jMatrixTranspose = new Matrix3();\n\nexport type EigenDecomposition = {\n  unitary: Matrix3;\n  diagonal: Matrix3;\n};\n\n/**\n * Computes the eigenvectors and eigenvalues of a symmetric matrix.\n *\n * - Returns a diagonal matrix and unitary matrix such that:\n * `matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)`\n * - The values along the diagonal of the diagonal matrix are the eigenvalues. The columns\n * of the unitary matrix are the corresponding eigenvectors.\n * - This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n * section 8.4.3 The Classical Jacobi Algorithm\n *\n * @param matrix The 3x3 matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.\n * @param result Optional object with unitary and diagonal properties which are matrices onto which to store the result.\n * @returns An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.\n *\n * @example\n * const a = //... symmetric matrix\n * const result = {\n *   unitary : new Matrix3(),\n *   diagonal : new Matrix3()\n * };\n * computeEigenDecomposition(a, result);\n *\n * const unitaryTranspose = Matrix3.transpose(result.unitary, new Matrix3());\n * const b = Matrix3.multiply(result.unitary, result.diagonal, new Matrix3());\n * Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n *\n * const lambda = result.diagonal.getColumn(0, new Vector3()).x;  // first eigenvalue\n * const v = result.unitary.getColumn(0, new Vector3());          // first eigenvector\n * const c = v.multiplyByScalar(lambda);                          // equal to v.transformByMatrix3(a)\n */\nexport function computeEigenDecomposition(\n  matrix: number[],\n  // @ts-expect-error accept empty object type\n  result: EigenDecomposition = {}\n): EigenDecomposition {\n  const EIGEN_TOLERANCE = _MathUtils.EPSILON20;\n  const EIGEN_MAX_SWEEPS = 10;\n\n  let count = 0;\n  let sweep = 0;\n\n  const unitaryMatrix = scratchUnitary;\n  const diagonalMatrix = scratchDiagonal;\n\n  unitaryMatrix.identity();\n  diagonalMatrix.copy(matrix);\n\n  const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);\n\n  while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {\n    shurDecomposition(diagonalMatrix, jMatrix);\n\n    jMatrixTranspose.copy(jMatrix).transpose();\n\n    diagonalMatrix.multiplyRight(jMatrix);\n    diagonalMatrix.multiplyLeft(jMatrixTranspose);\n    unitaryMatrix.multiplyRight(jMatrix);\n\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n\n  result.unitary = unitaryMatrix.toTarget(result.unitary);\n  result.diagonal = diagonalMatrix.toTarget(result.diagonal);\n\n  return result;\n}\n\nfunction computeFrobeniusNorm(matrix: Matrix3): number {\n  let norm = 0.0;\n  for (let i = 0; i < 9; ++i) {\n    const temp = matrix[i];\n    norm += temp * temp;\n  }\n  return Math.sqrt(norm);\n}\n\nconst rowVal = [1, 0, 0];\nconst colVal = [2, 2, 1];\n\n// Computes the \"off-diagonal\" Frobenius norm.\n// Assumes matrix is symmetric.\nfunction offDiagonalFrobeniusNorm(matrix: Matrix3): number {\n  let norm = 0.0;\n  for (let i = 0; i < 3; ++i) {\n    const temp = matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n  return Math.sqrt(norm);\n}\n\n// The routine takes a matrix, which is assumed to be symmetric, and\n// finds the largest off-diagonal term, and then creates\n// a matrix (result) which can be used to help reduce it\n//\n// This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n// section 8.4.2 The 2by2 Symmetric Schur Decomposition.\n//\n// eslint-disable-next-line max-statements\nfunction shurDecomposition(matrix: Matrix3, result: Matrix3): Matrix3 {\n  const tolerance = _MathUtils.EPSILON15;\n\n  let maxDiagonal = 0.0;\n  let rotAxis = 1;\n\n  // find pivot (rotAxis) based on max diagonal of matrix\n  for (let i = 0; i < 3; ++i) {\n    const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])]);\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n\n  const p = rowVal[rotAxis];\n  const q = colVal[rotAxis];\n\n  let c = 1.0;\n  let s = 0.0;\n\n  if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p)]) > tolerance) {\n    const qq = matrix[scratchMatrix.getElementIndex(q, q)];\n    const pp = matrix[scratchMatrix.getElementIndex(p, p)];\n    const qp = matrix[scratchMatrix.getElementIndex(q, p)];\n\n    const tau = (qq - pp) / 2.0 / qp;\n    let t;\n\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n\n  // Copy into result\n  Matrix3.IDENTITY.to(result);\n  result[scratchMatrix.getElementIndex(p, p)] = result[scratchMatrix.getElementIndex(q, q)] = c;\n  result[scratchMatrix.getElementIndex(q, p)] = s;\n  result[scratchMatrix.getElementIndex(p, q)] = -s;\n\n  return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}