{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Texture, log } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\nimport { getTextureFormatWebGL } from \"../converters/webgl-texture-table.js\";\nimport { convertSamplerParametersToWebGL } from \"../converters/sampler-parameters.js\";\nimport { WEBGLSampler } from \"./webgl-sampler.js\";\nimport { WEBGLTextureView } from \"./webgl-texture-view.js\";\nimport { initializeTextureStorage,\n// clearMipLevel,\ncopyExternalImageToMipLevel, copyCPUDataToMipLevel,\n// copyGPUBufferToMipLevel,\ngetWebGLTextureTarget } from \"../helpers/webgl-texture-utils.js\";\n/**\n * WebGL... the texture API from hell... hopefully made simpler\n */\nexport class WEBGLTexture extends Texture {\n  // readonly MAX_ATTRIBUTES: number;\n  device;\n  gl;\n  handle;\n  sampler = (() => undefined)(); // TODO - currently unused in WebGL. Create dummy sampler?\n  view = (() => undefined)(); // TODO - currently unused in WebGL. Create dummy view?\n  mipmaps;\n  // Texture type\n  /** Whether the internal format is compressed */\n  compressed;\n  /**\n   * The WebGL target corresponding to the texture type\n   * @note `target` cannot be modified by bind:\n   * textures are special because when you first bind them to a target,\n   * When you first bind a texture as a GL_TEXTURE_2D, you are saying that this texture is a 2D texture.\n   * And it will always be a 2D texture; this state cannot be changed ever.\n   * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;\n   * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error\n   */\n  glTarget;\n  /** The WebGL format - essentially channel structure */\n  glFormat;\n  /** The WebGL data format - the type of each channel */\n  glType;\n  /** The WebGL constant corresponding to the WebGPU style constant in format */\n  glInternalFormat;\n  // state\n  /** Texture binding slot - TODO - move to texture view? */\n  textureUnit = 0;\n  constructor(device, props) {\n    super(device, props);\n    // Texture base class strips out the data prop, so we need to add it back in\n    const propsWithData = {\n      ...this.props\n    };\n    propsWithData.data = props.data;\n    this.device = device;\n    this.gl = this.device.gl;\n    // Note: In WebGL the texture target defines the type of texture on first bind.\n    this.glTarget = getWebGLTextureTarget(this.props.dimension);\n    // The target format of this texture\n    const formatInfo = getTextureFormatWebGL(this.props.format);\n    this.glInternalFormat = formatInfo.internalFormat;\n    this.glFormat = formatInfo.format;\n    this.glType = formatInfo.type;\n    this.compressed = formatInfo.compressed;\n    this.mipmaps = Boolean(this.props.mipmaps);\n    this._initialize(propsWithData);\n    Object.seal(this);\n  }\n  /** Initialize texture with supplied props */\n  // eslint-disable-next-line max-statements\n  _initialize(propsWithData) {\n    this.handle = this.props.handle || this.gl.createTexture();\n    this.device.setSpectorMetadata(this.handle, {\n      ...this.props,\n      data: propsWithData.data\n    });\n    let {\n      width,\n      height\n    } = propsWithData;\n    if (!width || !height) {\n      const textureSize = Texture.getTextureDataSize(propsWithData.data);\n      width = textureSize?.width || 1;\n      height = textureSize?.height || 1;\n    }\n    // Store opts for accessors\n    this.width = width;\n    this.height = height;\n    this.depth = propsWithData.depth;\n    // Set texture sampler parameters\n    this.setSampler(propsWithData.sampler);\n    // @ts-ignore TODO - fix types\n    this.view = new WEBGLTextureView(this.device, {\n      ...this.props,\n      texture: this\n    });\n    this.bind();\n    initializeTextureStorage(this.gl, this.mipLevels, this);\n    if (propsWithData.data) {\n      // prettier-ignore\n      switch (propsWithData.dimension) {\n        case '1d':\n          this.setTexture1DData(propsWithData.data);\n          break;\n        case '2d':\n          this.setTexture2DData(propsWithData.data);\n          break;\n        case '3d':\n          this.setTexture3DData(propsWithData.data);\n          break;\n        case 'cube':\n          this.setTextureCubeData(propsWithData.data);\n          break;\n        case '2d-array':\n          this.setTextureArrayData(propsWithData.data);\n          break;\n        case 'cube-array':\n          this.setTextureCubeArrayData(propsWithData.data);\n          break;\n        // @ts-expect-error\n        default:\n          throw new Error(propsWithData.dimension);\n      }\n    }\n    if (this.mipmaps) {\n      this.generateMipmap();\n    }\n  }\n  destroy() {\n    if (this.handle) {\n      this.gl.deleteTexture(this.handle);\n      this.removeStats();\n      this.trackDeallocatedMemory('Texture');\n      // this.handle = null;\n      this.destroyed = true;\n    }\n  }\n  createView(props) {\n    return new WEBGLTextureView(this.device, {\n      ...props,\n      texture: this\n    });\n  }\n  setSampler() {\n    let sampler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let samplerProps;\n    if (sampler instanceof WEBGLSampler) {\n      this.sampler = sampler;\n      samplerProps = sampler.props;\n    } else {\n      this.sampler = new WEBGLSampler(this.device, sampler);\n      samplerProps = sampler;\n    }\n    const parameters = convertSamplerParametersToWebGL(samplerProps);\n    this._setSamplerParameters(parameters);\n  }\n  // Call to regenerate mipmaps after modifying texture(s)\n  generateMipmap(options) {\n    const isFilterableAndRenderable = this.device.isTextureFormatRenderable(this.props.format) && this.device.isTextureFormatFilterable(this.props.format);\n    if (!isFilterableAndRenderable) {\n      log.warn(`${this} is not renderable or filterable, may not be able to generate mipmaps`)();\n      if (!options?.force) {\n        return;\n      }\n    }\n    try {\n      this.gl.bindTexture(this.glTarget, this.handle);\n      this.gl.generateMipmap(this.glTarget);\n    } catch (error) {\n      log.warn(`Error generating mipmap for ${this}: ${error.message}`)();\n    } finally {\n      this.gl.bindTexture(this.glTarget, null);\n    }\n  }\n  // Image Data Setters\n  copyExternalImage(options) {\n    const size = Texture.getExternalImageSize(options.image);\n    const opts = {\n      ...Texture.defaultCopyExternalImageOptions,\n      ...size,\n      ...options\n    };\n    const {\n      image,\n      depth,\n      mipLevel,\n      x,\n      y,\n      z,\n      flipY\n    } = opts;\n    let {\n      width,\n      height\n    } = opts;\n    const {\n      dimension,\n      glTarget,\n      glFormat,\n      glInternalFormat,\n      glType\n    } = this;\n    // WebGL will error if we try to copy outside the bounds of the texture\n    width = Math.min(width, this.width - x);\n    height = Math.min(height, this.height - y);\n    if (options.sourceX || options.sourceY) {\n      // requires copyTexSubImage2D from a framebuffer'\n      throw new Error('WebGL does not support sourceX/sourceY)');\n    }\n    copyExternalImageToMipLevel(this.device.gl, this.handle, image, {\n      dimension,\n      mipLevel,\n      x,\n      y,\n      z,\n      width,\n      height,\n      depth,\n      glFormat,\n      glInternalFormat,\n      glType,\n      glTarget,\n      flipY\n    });\n    return {\n      width: opts.width,\n      height: opts.height\n    };\n  }\n  setTexture1DData(data) {\n    throw new Error('setTexture1DData not supported in WebGL.');\n  }\n  /** Set a simple texture */\n  setTexture2DData(lodData) {\n    let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.bind();\n    const lodArray = Texture.normalizeTextureData(lodData, this);\n    // If the user provides multiple LODs, then automatic mipmap\n    // generation generateMipmap() should be disabled to avoid overwriting them.\n    if (lodArray.length > 1 && this.props.mipmaps !== false) {\n      log.warn(`Texture ${this.id} mipmap and multiple LODs.`)();\n    }\n    for (let lodLevel = 0; lodLevel < lodArray.length; lodLevel++) {\n      const imageData = lodArray[lodLevel];\n      this._setMipLevel(depth, lodLevel, imageData);\n    }\n    this.unbind();\n  }\n  /**\n   * Sets a 3D texture\n   * @param data\n   */\n  setTexture3DData(data) {\n    if (this.props.dimension !== '3d') {\n      throw new Error(this.id);\n    }\n    if (ArrayBuffer.isView(data)) {\n      this.bind();\n      copyCPUDataToMipLevel(this.device.gl, data, this);\n      this.unbind();\n    }\n  }\n  /**\n   * Set a Texture Cube Data\n   * @todo - could support TextureCubeArray with depth\n   * @param data\n   * @param index\n   */\n  setTextureCubeData(data) {\n    let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (this.props.dimension !== 'cube') {\n      throw new Error(this.id);\n    }\n    for (const face of Texture.CubeFaces) {\n      this.setTextureCubeFaceData(data[face], face);\n    }\n  }\n  /**\n   * Sets an entire texture array\n   * @param data\n   */\n  setTextureArrayData(data) {\n    if (this.props.dimension !== '2d-array') {\n      throw new Error(this.id);\n    }\n    throw new Error('setTextureArrayData not implemented.');\n  }\n  /**\n   * Sets an entire texture cube array\n   * @param data\n   */\n  setTextureCubeArrayData(data) {\n    throw new Error('setTextureCubeArrayData not supported in WebGL2.');\n  }\n  setTextureCubeFaceData(lodData, face) {\n    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    // assert(this.props.dimension === 'cube');\n    // If the user provides multiple LODs, then automatic mipmap\n    // generation generateMipmap() should be disabled to avoid overwriting them.\n    if (Array.isArray(lodData) && lodData.length > 1 && this.props.mipmaps !== false) {\n      log.warn(`${this.id} has mipmap and multiple LODs.`)();\n    }\n    const faceDepth = Texture.CubeFaces.indexOf(face);\n    this.setTexture2DData(lodData, faceDepth);\n  }\n  // DEPRECATED METHODS\n  /** Update external texture (video frame or canvas) @deprecated Use ExternalTexture */\n  update() {\n    throw new Error('Texture.update() not implemented. Use ExternalTexture');\n  }\n  // INTERNAL METHODS\n  /** @todo update this method to accept LODs */\n  setImageDataForFace(options) {\n    const {\n      face,\n      width,\n      height,\n      pixels,\n      data,\n      format = 6408,\n      type = 5121\n      // generateMipmap = false // TODO\n    } = options;\n    const {\n      gl\n    } = this;\n    const imageData = pixels || data;\n    this.bind();\n    if (imageData instanceof Promise) {\n      imageData.then(resolvedImageData => this.setImageDataForFace(Object.assign({}, options, {\n        face,\n        data: resolvedImageData,\n        pixels: resolvedImageData\n      })));\n    } else if (this.width || this.height) {\n      gl.texImage2D(face, 0, format, width, height, 0 /* border*/, format, type, imageData);\n    } else {\n      gl.texImage2D(face, 0, format, format, type, imageData);\n    }\n  }\n  _getImageDataMap(faceData) {\n    for (let i = 0; i < Texture.CubeFaces.length; ++i) {\n      const faceName = Texture.CubeFaces[i];\n      if (faceData[faceName]) {\n        faceData[34069 + i] = faceData[faceName];\n        delete faceData[faceName];\n      }\n    }\n    return faceData;\n  }\n  // RESOURCE METHODS\n  /**\n   * Sets sampler parameters on texture\n   */\n  _setSamplerParameters(parameters) {\n    log.log(1, `${this.id} sampler parameters`, this.device.getGLKeys(parameters))();\n    this.gl.bindTexture(this.glTarget, this.handle);\n    for (const [pname, pvalue] of Object.entries(parameters)) {\n      const param = Number(pname);\n      const value = pvalue;\n      // Apparently integer/float issues require two different texture parameter setting functions in JavaScript.\n      // For now, pick the float version for parameters specified as GLfloat.\n      switch (param) {\n        case 33082:\n        case 33083:\n          this.gl.texParameterf(this.glTarget, param, value);\n          break;\n        case 10241:\n          this.gl.texParameteri(this.glTarget, param, value);\n          break;\n        case 10242:\n        case 10243:\n          this.gl.texParameteri(this.glTarget, param, value);\n          break;\n        case 34046:\n          // We have to query feature before using it\n          if (this.device.features.has('texture-filterable-anisotropic-webgl')) {\n            this.gl.texParameteri(this.glTarget, param, value);\n          }\n          break;\n        default:\n          this.gl.texParameteri(this.glTarget, param, value);\n          break;\n      }\n    }\n    this.gl.bindTexture(this.glTarget, null);\n  }\n  // INTERNAL SETTERS\n  /**\n   * Copy a region of data from a CPU memory buffer into this texture.\n   * @todo -   GLUnpackParameters parameters\n   */\n  _setMipLevel(depth, mipLevel, textureData) {\n    let glTarget = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.glTarget;\n    // if (!textureData) {\n    //   clearMipLevel(this.device.gl, {...this, depth, level});\n    //   return;\n    // }\n    if (Texture.isExternalImage(textureData)) {\n      copyExternalImageToMipLevel(this.device.gl, this.handle, textureData, {\n        ...this,\n        depth,\n        mipLevel,\n        glTarget,\n        flipY: this.props.flipY\n      });\n      return;\n    }\n    // @ts-expect-error\n    if (Texture.isTextureLevelData(textureData)) {\n      copyCPUDataToMipLevel(this.device.gl, textureData.data, {\n        ...this,\n        depth,\n        mipLevel,\n        glTarget\n      });\n      return;\n    }\n    throw new Error('Texture: invalid image data');\n  }\n  // HELPERS\n  getActiveUnit() {\n    return this.gl.getParameter(34016) - 33984;\n  }\n  bind(textureUnit) {\n    const {\n      gl\n    } = this;\n    if (textureUnit !== undefined) {\n      this.textureUnit = textureUnit;\n      gl.activeTexture(33984 + textureUnit);\n    }\n    gl.bindTexture(this.glTarget, this.handle);\n    return textureUnit;\n  }\n  unbind(textureUnit) {\n    const {\n      gl\n    } = this;\n    if (textureUnit !== undefined) {\n      this.textureUnit = textureUnit;\n      gl.activeTexture(33984 + textureUnit);\n    }\n    gl.bindTexture(this.glTarget, null);\n    return textureUnit;\n  }\n}\n// TODO - Remove when texture refactor is complete\n/*\nsetCubeMapData(options: {\n  width: number;\n  height: number;\n  data: Record<GL, Texture2DData> | Record<TextureCubeFace, Texture2DData>;\n  format?: any;\n  type?: any;\n  /** @deprecated Use .data *\n  pixels: any;\n}): void {\n  const {gl} = this;\n\n  const {width, height, pixels, data, format = GL.RGBA, type = GL.UNSIGNED_BYTE} = options;\n\n  // pixel data (imageDataMap) is an Object from Face to Image or Promise.\n  // For example:\n  // {\n  // GL.TEXTURE_CUBE_MAP_POSITIVE_X : Image-or-Promise,\n  // GL.TEXTURE_CUBE_MAP_NEGATIVE_X : Image-or-Promise,\n  // ... }\n  // To provide multiple level-of-details (LODs) this can be Face to Array\n  // of Image or Promise, like this\n  // {\n  // GL.TEXTURE_CUBE_MAP_POSITIVE_X : [Image-or-Promise-LOD-0, Image-or-Promise-LOD-1],\n  // GL.TEXTURE_CUBE_MAP_NEGATIVE_X : [Image-or-Promise-LOD-0, Image-or-Promise-LOD-1],\n  // ... }\n\n  const imageDataMap = this._getImageDataMap(pixels || data);\n\n  const resolvedFaces = WEBGLTexture.FACES.map(face => {\n    const facePixels = imageDataMap[face];\n    return Array.isArray(facePixels) ? facePixels : [facePixels];\n  });\n  this.bind();\n\n  WEBGLTexture.FACES.forEach((face, index) => {\n    if (resolvedFaces[index].length > 1 && this.props.mipmaps !== false) {\n      // If the user provides multiple LODs, then automatic mipmap\n      // generation generateMipmap() should be disabled to avoid overwritting them.\n      log.warn(`${this.id} has mipmap and multiple LODs.`)();\n    }\n    resolvedFaces[index].forEach((image, lodLevel) => {\n      // TODO: adjust width & height for LOD!\n      if (width && height) {\n        gl.texImage2D(face, lodLevel, format, width, height, 0 /* border*, format, type, image);\n      } else {\n        gl.texImage2D(face, lodLevel, format, format, type, image);\n      }\n    });\n  });\n\n  this.unbind();\n}\n*/\n//# sourceMappingURL=webgl-texture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}