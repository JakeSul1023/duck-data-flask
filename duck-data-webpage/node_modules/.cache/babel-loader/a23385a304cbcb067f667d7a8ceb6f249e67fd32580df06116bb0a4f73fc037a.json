{"ast":null,"code":"// WebGL2 Query (also handles disjoint timer extensions)\nimport { QuerySet } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\n/**\n * Asynchronous queries for different kinds of information\n */\nexport class WEBGLQuerySet extends QuerySet {\n  device;\n  handle;\n  target = null;\n  _queryPending = false;\n  _pollingPromise = null;\n  get [Symbol.toStringTag]() {\n    return 'Query';\n  }\n  // Create a query class\n  constructor(device, props) {\n    super(device, props);\n    this.device = device;\n    if (props.count > 1) {\n      throw new Error('WebGL QuerySet can only have one value');\n    }\n    this.handle = this.device.gl.createQuery();\n    Object.seal(this);\n  }\n  destroy() {\n    this.device.gl.deleteQuery(this.handle);\n  }\n  // FOR RENDER PASS AND COMMAND ENCODER\n  /**\n   * Shortcut for timer query (dependent on extension in both WebGL1 and 2)\n   * Measures GPU time delta between this call and a matching `end` call in the\n   * GPU instruction stream.\n   */\n  beginTimestampQuery() {\n    return this._begin(35007);\n  }\n  endTimestampQuery() {\n    this._end();\n  }\n  // Shortcut for occlusion queries\n  beginOcclusionQuery(options) {\n    return this._begin(options?.conservative ? 36202 : 35887);\n  }\n  endOcclusionQuery() {\n    this._end();\n  }\n  // Shortcut for transformFeedbackQuery\n  beginTransformFeedbackQuery() {\n    return this._begin(35976);\n  }\n  endTransformFeedbackQuery() {\n    this._end();\n  }\n  async resolveQuery() {\n    const value = await this.pollQuery();\n    return [value];\n  }\n  // PRIVATE METHODS\n  /**\n   * Due to OpenGL API limitations, after calling `begin()` on one Query\n   * instance, `end()` must be called on that same instance before\n   * calling `begin()` on another query. While there can be multiple\n   * outstanding queries representing disjoint `begin()`/`end()` intervals.\n   * It is not possible to interleave or overlap `begin` and `end` calls.\n   */\n  _begin(target) {\n    // Don't start a new query if one is already active.\n    if (this._queryPending) {\n      return;\n    }\n    this.target = target;\n    this.device.gl.beginQuery(this.target, this.handle);\n    return;\n  }\n  // ends the current query\n  _end() {\n    // Can't end a new query if the last one hasn't been resolved.\n    if (this._queryPending) {\n      return;\n    }\n    if (this.target) {\n      this.device.gl.endQuery(this.target);\n      this.target = null;\n      this._queryPending = true;\n    }\n    return;\n  }\n  // Returns true if the query result is available\n  isResultAvailable() {\n    if (!this._queryPending) {\n      return false;\n    }\n    const resultAvailable = this.device.gl.getQueryParameter(this.handle, 34919);\n    if (resultAvailable) {\n      this._queryPending = false;\n    }\n    return resultAvailable;\n  }\n  // Timing query is disjoint, i.e. results are invalid\n  isTimerDisjoint() {\n    return this.device.gl.getParameter(36795);\n  }\n  // Returns query result.\n  getResult() {\n    return this.device.gl.getQueryParameter(this.handle, 34918);\n  }\n  // Returns the query result, converted to milliseconds to match JavaScript conventions.\n  getTimerMilliseconds() {\n    return this.getResult() / 1e6;\n  }\n  // Polls the query\n  pollQuery(limit = Number.POSITIVE_INFINITY) {\n    if (this._pollingPromise) {\n      return this._pollingPromise;\n    }\n    let counter = 0;\n    this._pollingPromise = new Promise((resolve, reject) => {\n      const poll = () => {\n        if (this.isResultAvailable()) {\n          resolve(this.getResult());\n          this._pollingPromise = null;\n        } else if (counter++ > limit) {\n          reject('Timed out');\n          this._pollingPromise = null;\n        } else {\n          requestAnimationFrame(poll);\n        }\n      };\n      requestAnimationFrame(poll);\n    });\n    return this._pollingPromise;\n  }\n}\n//# sourceMappingURL=webgl-query-set.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}