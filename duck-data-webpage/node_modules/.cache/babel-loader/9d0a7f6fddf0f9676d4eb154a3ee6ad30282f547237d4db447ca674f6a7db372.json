{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { project } from '@deck.gl/core';\n/** A model can have one of the following modes */\nexport const TERRAIN_MODE = {\n  NONE: 0,\n  /** A terrain layer rendering encoded ground elevation into the height map */\n  WRITE_HEIGHT_MAP: 1,\n  /** An offset layer reading encoded ground elevation from the height map */\n  USE_HEIGHT_MAP: 2,\n  /** A terrain layer rendering to screen, using the cover fbo overlaid with its own texture */\n  USE_COVER: 3,\n  /** A terrain layer rendering to screen, using the cover fbo as texture */\n  USE_COVER_ONLY: 4,\n  /** Draped layer is rendered into a texture, and never to screen */\n  SKIP: 5\n};\nconst TERRAIN_MODE_CONSTANTS = Object.keys(TERRAIN_MODE).map(key => `const float TERRAIN_MODE_${key} = ${TERRAIN_MODE[key]}.0;`).join('\\n');\nconst uniformBlock =\n// eslint-disable-next-line prefer-template\nTERRAIN_MODE_CONSTANTS + /* glsl */`\nuniform terrainUniforms {\n  float mode;\n  vec4 bounds;\n} terrain;\n\nuniform sampler2D terrain_map;\n`;\nexport const terrainModule = {\n  name: 'terrain',\n  dependencies: [project],\n  // eslint-disable-next-line prefer-template\n  vs: uniformBlock + /* glsl */'out vec3 commonPos;',\n  // eslint-disable-next-line prefer-template\n  fs: uniformBlock + /* glsl */'in vec3 commonPos;',\n  inject: {\n    'vs:#main-start': /* glsl */`\nif (terrain.mode == TERRAIN_MODE_SKIP) {\n  gl_Position = vec4(0.0);\n  return;\n}\n`,\n    'vs:DECKGL_FILTER_GL_POSITION': /* glsl */`\ncommonPos = geometry.position.xyz;\nif (terrain.mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  vec2 texCoords = (commonPos.xy - terrain.bounds.xy) / terrain.bounds.zw;\n  position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);\n  commonPos.z += project.commonOrigin.z;\n}\nif (terrain.mode == TERRAIN_MODE_USE_HEIGHT_MAP) {\n  vec3 anchor = geometry.worldPosition;\n  anchor.z = 0.0;\n  vec3 anchorCommon = project_position(anchor);\n  vec2 texCoords = (anchorCommon.xy - terrain.bounds.xy) / terrain.bounds.zw;\n  if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {\n    float terrainZ = texture(terrain_map, texCoords).r;\n    geometry.position.z += terrainZ;\n    position = project_common_position_to_clipspace(geometry.position);\n  }\n}\n    `,\n    'fs:#main-start': /* glsl */`\nif (terrain.mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  fragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);\n  return;\n}\n    `,\n    'fs:DECKGL_FILTER_COLOR': /* glsl */`\nif ((terrain.mode == TERRAIN_MODE_USE_COVER) || (terrain.mode == TERRAIN_MODE_USE_COVER_ONLY)) {\n  vec2 texCoords = (commonPos.xy - terrain.bounds.xy) / terrain.bounds.zw;\n  vec4 pixel = texture(terrain_map, texCoords);\n  if (terrain.mode == TERRAIN_MODE_USE_COVER_ONLY) {\n    color = pixel;\n  } else {\n    // pixel is premultiplied\n    color = pixel + color * (1.0 - pixel.a);\n  }\n  return;\n}\n    `\n  },\n  // eslint-disable-next-line complexity\n  getUniforms: (opts = {}) => {\n    if ('dummyHeightMap' in opts) {\n      const {\n        drawToTerrainHeightMap,\n        heightMap,\n        heightMapBounds,\n        dummyHeightMap,\n        terrainCover,\n        useTerrainHeightMap,\n        terrainSkipRender\n      } = opts;\n      const projectUniforms = project.getUniforms(opts.project);\n      const {\n        commonOrigin\n      } = projectUniforms;\n      let mode = terrainSkipRender ? TERRAIN_MODE.SKIP : TERRAIN_MODE.NONE;\n      // height map if case USE_HEIGHT_MAP, terrain cover if USE_COVER, otherwise empty\n      let sampler = dummyHeightMap;\n      // height map bounds if case USE_HEIGHT_MAP, terrain cover bounds if USE_COVER, otherwise null\n      let bounds = null;\n      if (drawToTerrainHeightMap) {\n        mode = TERRAIN_MODE.WRITE_HEIGHT_MAP;\n        bounds = heightMapBounds;\n      } else if (useTerrainHeightMap && heightMap) {\n        mode = TERRAIN_MODE.USE_HEIGHT_MAP;\n        sampler = heightMap;\n        bounds = heightMapBounds;\n      } else if (terrainCover) {\n        // This is a terrain layer\n        const fbo = opts.isPicking ? terrainCover.getPickingFramebuffer() : terrainCover.getRenderFramebuffer();\n        sampler = fbo?.colorAttachments[0].texture;\n        if (opts.isPicking) {\n          // Never render the layer itself in picking pass\n          mode = TERRAIN_MODE.SKIP;\n        }\n        if (sampler) {\n          mode = mode === TERRAIN_MODE.SKIP ? TERRAIN_MODE.USE_COVER_ONLY : TERRAIN_MODE.USE_COVER;\n          bounds = terrainCover.bounds;\n        } else {\n          sampler = dummyHeightMap;\n        }\n      }\n      /* eslint-disable camelcase */\n      return {\n        mode,\n        terrain_map: sampler,\n        // Convert bounds to the common space, as [minX, minY, width, height]\n        bounds: bounds ? [bounds[0] - commonOrigin[0], bounds[1] - commonOrigin[1], bounds[2] - bounds[0], bounds[3] - bounds[1]] : [0, 0, 0, 0]\n      };\n    }\n    return {};\n  },\n  uniformTypes: {\n    mode: 'f32',\n    bounds: 'vec4<f32>'\n  }\n};","map":{"version":3,"names":["project","TERRAIN_MODE","NONE","WRITE_HEIGHT_MAP","USE_HEIGHT_MAP","USE_COVER","USE_COVER_ONLY","SKIP","TERRAIN_MODE_CONSTANTS","Object","keys","map","key","join","uniformBlock","terrainModule","name","dependencies","vs","fs","inject","getUniforms","opts","drawToTerrainHeightMap","heightMap","heightMapBounds","dummyHeightMap","terrainCover","useTerrainHeightMap","terrainSkipRender","projectUniforms","commonOrigin","mode","sampler","bounds","fbo","isPicking","getPickingFramebuffer","getRenderFramebuffer","colorAttachments","texture","terrain_map","uniformTypes"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\extensions\\src\\terrain\\shader-module.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable camelcase */\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\nimport {project, ProjectProps, ProjectUniforms} from '@deck.gl/core';\n\nimport type {Texture} from '@luma.gl/core';\nimport type {Bounds} from '../utils/projection-utils';\nimport type {TerrainCover} from './terrain-cover';\n\n/** Module parameters expected by the terrain shader module */\nexport type TerrainModuleProps = {\n  project: ProjectProps;\n  isPicking: boolean;\n  heightMap: Texture | null;\n  heightMapBounds?: Bounds | null;\n  dummyHeightMap: Texture;\n  terrainCover?: TerrainCover | null;\n  drawToTerrainHeightMap?: boolean;\n  useTerrainHeightMap?: boolean;\n  terrainSkipRender?: boolean;\n};\n\ntype TerrainModuleUniforms = {\n  mode: number;\n  bounds: [number, number, number, number];\n};\n\ntype TerrainModuleBindings = {\n  terrain_map: Texture;\n};\n\n/** A model can have one of the following modes */\nexport const TERRAIN_MODE = {\n  NONE: 0,\n  /** A terrain layer rendering encoded ground elevation into the height map */\n  WRITE_HEIGHT_MAP: 1,\n  /** An offset layer reading encoded ground elevation from the height map */\n  USE_HEIGHT_MAP: 2,\n  /** A terrain layer rendering to screen, using the cover fbo overlaid with its own texture */\n  USE_COVER: 3,\n  /** A terrain layer rendering to screen, using the cover fbo as texture */\n  USE_COVER_ONLY: 4,\n  /** Draped layer is rendered into a texture, and never to screen */\n  SKIP: 5\n};\n\nconst TERRAIN_MODE_CONSTANTS = Object.keys(TERRAIN_MODE)\n  .map(key => `const float TERRAIN_MODE_${key} = ${TERRAIN_MODE[key]}.0;`)\n  .join('\\n');\n\nconst uniformBlock =\n  // eslint-disable-next-line prefer-template\n  TERRAIN_MODE_CONSTANTS +\n  /* glsl */ `\nuniform terrainUniforms {\n  float mode;\n  vec4 bounds;\n} terrain;\n\nuniform sampler2D terrain_map;\n`;\n\nexport const terrainModule = {\n  name: 'terrain',\n  dependencies: [project],\n  // eslint-disable-next-line prefer-template\n  vs: uniformBlock + /* glsl */ 'out vec3 commonPos;',\n  // eslint-disable-next-line prefer-template\n  fs: uniformBlock + /* glsl */ 'in vec3 commonPos;',\n  inject: {\n    'vs:#main-start': /* glsl */ `\nif (terrain.mode == TERRAIN_MODE_SKIP) {\n  gl_Position = vec4(0.0);\n  return;\n}\n`,\n    'vs:DECKGL_FILTER_GL_POSITION': /* glsl */ `\ncommonPos = geometry.position.xyz;\nif (terrain.mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  vec2 texCoords = (commonPos.xy - terrain.bounds.xy) / terrain.bounds.zw;\n  position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);\n  commonPos.z += project.commonOrigin.z;\n}\nif (terrain.mode == TERRAIN_MODE_USE_HEIGHT_MAP) {\n  vec3 anchor = geometry.worldPosition;\n  anchor.z = 0.0;\n  vec3 anchorCommon = project_position(anchor);\n  vec2 texCoords = (anchorCommon.xy - terrain.bounds.xy) / terrain.bounds.zw;\n  if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {\n    float terrainZ = texture(terrain_map, texCoords).r;\n    geometry.position.z += terrainZ;\n    position = project_common_position_to_clipspace(geometry.position);\n  }\n}\n    `,\n    'fs:#main-start': /* glsl */ `\nif (terrain.mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  fragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);\n  return;\n}\n    `,\n    'fs:DECKGL_FILTER_COLOR': /* glsl */ `\nif ((terrain.mode == TERRAIN_MODE_USE_COVER) || (terrain.mode == TERRAIN_MODE_USE_COVER_ONLY)) {\n  vec2 texCoords = (commonPos.xy - terrain.bounds.xy) / terrain.bounds.zw;\n  vec4 pixel = texture(terrain_map, texCoords);\n  if (terrain.mode == TERRAIN_MODE_USE_COVER_ONLY) {\n    color = pixel;\n  } else {\n    // pixel is premultiplied\n    color = pixel + color * (1.0 - pixel.a);\n  }\n  return;\n}\n    `\n  },\n  // eslint-disable-next-line complexity\n  getUniforms: (opts: Partial<TerrainModuleProps> = {}) => {\n    if ('dummyHeightMap' in opts) {\n      const {\n        drawToTerrainHeightMap,\n        heightMap,\n        heightMapBounds,\n        dummyHeightMap,\n        terrainCover,\n        useTerrainHeightMap,\n        terrainSkipRender\n      } = opts;\n      const projectUniforms = project.getUniforms(opts.project) as ProjectUniforms;\n      const {commonOrigin} = projectUniforms;\n\n      let mode: number = terrainSkipRender ? TERRAIN_MODE.SKIP : TERRAIN_MODE.NONE;\n      // height map if case USE_HEIGHT_MAP, terrain cover if USE_COVER, otherwise empty\n      let sampler: Texture | undefined = dummyHeightMap as Texture;\n      // height map bounds if case USE_HEIGHT_MAP, terrain cover bounds if USE_COVER, otherwise null\n      let bounds: number[] | null = null;\n      if (drawToTerrainHeightMap) {\n        mode = TERRAIN_MODE.WRITE_HEIGHT_MAP;\n        bounds = heightMapBounds!;\n      } else if (useTerrainHeightMap && heightMap) {\n        mode = TERRAIN_MODE.USE_HEIGHT_MAP;\n        sampler = heightMap;\n        bounds = heightMapBounds!;\n      } else if (terrainCover) {\n        // This is a terrain layer\n        const fbo = opts.isPicking\n          ? terrainCover.getPickingFramebuffer()\n          : terrainCover.getRenderFramebuffer();\n        sampler = fbo?.colorAttachments[0].texture;\n        if (opts.isPicking) {\n          // Never render the layer itself in picking pass\n          mode = TERRAIN_MODE.SKIP;\n        }\n        if (sampler) {\n          mode = mode === TERRAIN_MODE.SKIP ? TERRAIN_MODE.USE_COVER_ONLY : TERRAIN_MODE.USE_COVER;\n          bounds = terrainCover.bounds;\n        } else {\n          sampler = dummyHeightMap!;\n        }\n      }\n\n      /* eslint-disable camelcase */\n      return {\n        mode,\n        terrain_map: sampler,\n        // Convert bounds to the common space, as [minX, minY, width, height]\n        bounds: bounds\n          ? [\n              bounds[0] - commonOrigin[0],\n              bounds[1] - commonOrigin[1],\n              bounds[2] - bounds[0],\n              bounds[3] - bounds[1]\n            ]\n          : [0, 0, 0, 0]\n      };\n    }\n    return {};\n  },\n  uniformTypes: {\n    mode: 'f32',\n    bounds: 'vec4<f32>'\n  }\n} as const satisfies ShaderModule<TerrainModuleProps, TerrainModuleUniforms, TerrainModuleBindings>;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}