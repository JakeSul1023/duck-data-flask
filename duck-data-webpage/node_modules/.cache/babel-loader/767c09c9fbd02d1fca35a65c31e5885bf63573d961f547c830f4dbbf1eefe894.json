{"ast":null,"code":"// TextDecoder iterators\n// TextDecoder will keep any partial undecoded bytes between calls to `decode`\nexport async function* makeTextDecoderIterator(arrayBufferIterator, options = {}) {\n  const textDecoder = new TextDecoder(undefined, options);\n  for await (const arrayBuffer of arrayBufferIterator) {\n    yield typeof arrayBuffer === 'string' ? arrayBuffer : textDecoder.decode(arrayBuffer, {\n      stream: true\n    });\n  }\n}\n// TextEncoder iterator\n// TODO - this is not useful unless min chunk size is given\n// TextEncoder will keep any partial undecoded bytes between calls to `encode`\n// If iterator does not yield strings, assume arrayBuffer and return unencoded\nexport async function* makeTextEncoderIterator(textIterator) {\n  const textEncoder = new TextEncoder();\n  for await (const text of textIterator) {\n    yield typeof text === 'string' ? textEncoder.encode(text) : text;\n  }\n}\n/**\n * @param textIterator async iterable yielding strings\n * @returns an async iterable over lines\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\nexport async function* makeLineIterator(textIterator) {\n  let previous = '';\n  for await (const textChunk of textIterator) {\n    previous += textChunk;\n    let eolIndex;\n    while ((eolIndex = previous.indexOf('\\n')) >= 0) {\n      // line includes the EOL\n      const line = previous.slice(0, eolIndex + 1);\n      previous = previous.slice(eolIndex + 1);\n      yield line;\n    }\n  }\n  if (previous.length > 0) {\n    yield previous;\n  }\n}\n/**\n * @param lineIterator async iterable yielding lines\n * @returns async iterable yielding numbered lines\n *\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\nexport async function* makeNumberedLineIterator(lineIterator) {\n  let counter = 1;\n  for await (const line of lineIterator) {\n    yield {\n      counter,\n      line\n    };\n    counter++;\n  }\n}","map":{"version":3,"names":["makeTextDecoderIterator","arrayBufferIterator","options","textDecoder","TextDecoder","undefined","arrayBuffer","decode","stream","makeTextEncoderIterator","textIterator","textEncoder","TextEncoder","text","encode","makeLineIterator","previous","textChunk","eolIndex","indexOf","line","slice","length","makeNumberedLineIterator","lineIterator","counter"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/loader-utils/dist/lib/iterators/text-iterators.js"],"sourcesContent":["// TextDecoder iterators\n// TextDecoder will keep any partial undecoded bytes between calls to `decode`\nexport async function* makeTextDecoderIterator(arrayBufferIterator, options = {}) {\n    const textDecoder = new TextDecoder(undefined, options);\n    for await (const arrayBuffer of arrayBufferIterator) {\n        yield typeof arrayBuffer === 'string'\n            ? arrayBuffer\n            : textDecoder.decode(arrayBuffer, { stream: true });\n    }\n}\n// TextEncoder iterator\n// TODO - this is not useful unless min chunk size is given\n// TextEncoder will keep any partial undecoded bytes between calls to `encode`\n// If iterator does not yield strings, assume arrayBuffer and return unencoded\nexport async function* makeTextEncoderIterator(textIterator) {\n    const textEncoder = new TextEncoder();\n    for await (const text of textIterator) {\n        yield typeof text === 'string' ? textEncoder.encode(text) : text;\n    }\n}\n/**\n * @param textIterator async iterable yielding strings\n * @returns an async iterable over lines\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\nexport async function* makeLineIterator(textIterator) {\n    let previous = '';\n    for await (const textChunk of textIterator) {\n        previous += textChunk;\n        let eolIndex;\n        while ((eolIndex = previous.indexOf('\\n')) >= 0) {\n            // line includes the EOL\n            const line = previous.slice(0, eolIndex + 1);\n            previous = previous.slice(eolIndex + 1);\n            yield line;\n        }\n    }\n    if (previous.length > 0) {\n        yield previous;\n    }\n}\n/**\n * @param lineIterator async iterable yielding lines\n * @returns async iterable yielding numbered lines\n *\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\nexport async function* makeNumberedLineIterator(lineIterator) {\n    let counter = 1;\n    for await (const line of lineIterator) {\n        yield { counter, line };\n        counter++;\n    }\n}\n"],"mappings":"AAAA;AACA;AACA,OAAO,gBAAgBA,uBAAuBA,CAACC,mBAAmB,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EAC9E,MAAMC,WAAW,GAAG,IAAIC,WAAW,CAACC,SAAS,EAAEH,OAAO,CAAC;EACvD,WAAW,MAAMI,WAAW,IAAIL,mBAAmB,EAAE;IACjD,MAAM,OAAOK,WAAW,KAAK,QAAQ,GAC/BA,WAAW,GACXH,WAAW,CAACI,MAAM,CAACD,WAAW,EAAE;MAAEE,MAAM,EAAE;IAAK,CAAC,CAAC;EAC3D;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO,gBAAgBC,uBAAuBA,CAACC,YAAY,EAAE;EACzD,MAAMC,WAAW,GAAG,IAAIC,WAAW,CAAC,CAAC;EACrC,WAAW,MAAMC,IAAI,IAAIH,YAAY,EAAE;IACnC,MAAM,OAAOG,IAAI,KAAK,QAAQ,GAAGF,WAAW,CAACG,MAAM,CAACD,IAAI,CAAC,GAAGA,IAAI;EACpE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,gBAAgBE,gBAAgBA,CAACL,YAAY,EAAE;EAClD,IAAIM,QAAQ,GAAG,EAAE;EACjB,WAAW,MAAMC,SAAS,IAAIP,YAAY,EAAE;IACxCM,QAAQ,IAAIC,SAAS;IACrB,IAAIC,QAAQ;IACZ,OAAO,CAACA,QAAQ,GAAGF,QAAQ,CAACG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;MAC7C;MACA,MAAMC,IAAI,GAAGJ,QAAQ,CAACK,KAAK,CAAC,CAAC,EAAEH,QAAQ,GAAG,CAAC,CAAC;MAC5CF,QAAQ,GAAGA,QAAQ,CAACK,KAAK,CAACH,QAAQ,GAAG,CAAC,CAAC;MACvC,MAAME,IAAI;IACd;EACJ;EACA,IAAIJ,QAAQ,CAACM,MAAM,GAAG,CAAC,EAAE;IACrB,MAAMN,QAAQ;EAClB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,gBAAgBO,wBAAwBA,CAACC,YAAY,EAAE;EAC1D,IAAIC,OAAO,GAAG,CAAC;EACf,WAAW,MAAML,IAAI,IAAII,YAAY,EAAE;IACnC,MAAM;MAAEC,OAAO;MAAEL;IAAK,CAAC;IACvBK,OAAO,EAAE;EACb;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}