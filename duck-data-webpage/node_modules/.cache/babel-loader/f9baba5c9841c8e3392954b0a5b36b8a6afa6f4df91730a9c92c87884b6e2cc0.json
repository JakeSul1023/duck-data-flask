{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { BufferTransform } from '@luma.gl/engine';\nimport { padBuffer, matchBuffer, getAttributeTypeFromSize, getFloat32VertexFormat, cycleBuffers } from \"./gpu-transition-utils.js\";\nimport { GPUTransitionBase } from \"./gpu-transition.js\";\nexport default class GPUSpringTransition extends GPUTransitionBase {\n  constructor(_ref) {\n    let {\n      device,\n      attribute,\n      timeline\n    } = _ref;\n    super({\n      device,\n      attribute,\n      timeline\n    });\n    this.type = 'spring';\n    this.texture = getTexture(device);\n    this.framebuffer = getFramebuffer(device, this.texture);\n    this.transform = getTransform(device, attribute);\n  }\n  start(transitionSettings, numInstances) {\n    const prevLength = this.currentLength;\n    const prevStartIndices = this.currentStartIndices;\n    super.start(transitionSettings, numInstances);\n    const {\n      buffers,\n      attribute\n    } = this;\n    for (let i = 0; i < 2; i++) {\n      buffers[i] = padBuffer({\n        device: this.device,\n        buffer: buffers[i],\n        attribute,\n        fromLength: prevLength,\n        toLength: this.currentLength,\n        fromStartIndices: prevStartIndices,\n        getData: transitionSettings.enter\n      });\n    }\n    buffers[2] = matchBuffer({\n      device: this.device,\n      source: buffers[0],\n      target: buffers[2]\n    });\n    this.setBuffer(buffers[1]);\n    const {\n      model\n    } = this.transform;\n    model.setVertexCount(Math.floor(this.currentLength / attribute.size));\n    if (attribute.isConstant) {\n      model.setConstantAttributes({\n        aTo: attribute.value\n      });\n    } else {\n      model.setAttributes({\n        aTo: attribute.getBuffer()\n      });\n    }\n  }\n  onUpdate() {\n    const {\n      buffers,\n      transform,\n      framebuffer,\n      transition\n    } = this;\n    const settings = this.settings;\n    transform.model.setAttributes({\n      aPrev: buffers[0],\n      aCur: buffers[1]\n    });\n    transform.transformFeedback.setBuffers({\n      vNext: buffers[2]\n    });\n    const springProps = {\n      stiffness: settings.stiffness,\n      damping: settings.damping\n    };\n    transform.model.shaderInputs.setProps({\n      spring: springProps\n    });\n    transform.run({\n      framebuffer,\n      discard: false,\n      parameters: {\n        viewport: [0, 0, 1, 1]\n      },\n      clearColor: [0, 0, 0, 0]\n    });\n    cycleBuffers(buffers);\n    this.setBuffer(buffers[1]);\n    const isTransitioning = this.device.readPixelsToArrayWebGL(framebuffer)[0] > 0;\n    if (!isTransitioning) {\n      transition.end();\n    }\n  }\n  delete() {\n    super.delete();\n    this.transform.destroy();\n    this.texture.destroy();\n    this.framebuffer.destroy();\n  }\n}\nconst uniformBlock = `\\\nuniform springUniforms {\n  float damping;\n  float stiffness;\n} spring;\n`;\nconst springUniforms = {\n  name: 'spring',\n  vs: uniformBlock,\n  uniformTypes: {\n    damping: 'f32',\n    stiffness: 'f32'\n  }\n};\nconst vs = `\\\n#version 300 es\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nin ATTRIBUTE_TYPE aPrev;\nin ATTRIBUTE_TYPE aCur;\nin ATTRIBUTE_TYPE aTo;\nout ATTRIBUTE_TYPE vNext;\nout float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE force = delta * spring.stiffness;\n  ATTRIBUTE_TYPE resistance = velocity * spring.damping;\n  return force - resistance + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n`;\nconst fs = `\\\n#version 300 es\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nin float vIsTransitioningFlag;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  fragColor = vec4(1.0);\n}`;\nfunction getTransform(device, attribute) {\n  const attributeType = getAttributeTypeFromSize(attribute.size);\n  const format = getFloat32VertexFormat(attribute.size);\n  return new BufferTransform(device, {\n    vs,\n    fs,\n    bufferLayout: [{\n      name: 'aPrev',\n      format\n    }, {\n      name: 'aCur',\n      format\n    }, {\n      name: 'aTo',\n      format: attribute.getBufferLayout().attributes[0].format\n    }],\n    varyings: ['vNext'],\n    modules: [springUniforms],\n    defines: {\n      ATTRIBUTE_TYPE: attributeType\n    },\n    parameters: {\n      depthCompare: 'always',\n      blendColorOperation: 'max',\n      blendColorSrcFactor: 'one',\n      blendColorDstFactor: 'one',\n      blendAlphaOperation: 'max',\n      blendAlphaSrcFactor: 'one',\n      blendAlphaDstFactor: 'one'\n    }\n  });\n}\nfunction getTexture(device) {\n  return device.createTexture({\n    data: new Uint8Array(4),\n    format: 'rgba8unorm',\n    mipmaps: false,\n    width: 1,\n    height: 1\n  });\n}\nfunction getFramebuffer(device, texture) {\n  return device.createFramebuffer({\n    id: 'spring-transition-is-transitioning-framebuffer',\n    width: 1,\n    height: 1,\n    colorAttachments: [texture]\n  });\n}\n//# sourceMappingURL=gpu-spring-transition.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}