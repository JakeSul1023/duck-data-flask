{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { uid } from \"../../utils/uid.js\";\n/**\n * Base class for GPU (WebGPU/WebGL) Resources\n */\nexport class Resource {\n  /** Default properties for resource */\n  static defaultProps = {\n    id: 'undefined',\n    handle: undefined,\n    userData: undefined\n  };\n  toString() {\n    return `${this[Symbol.toStringTag] || this.constructor.name}:\"${this.id}\"`;\n  }\n  /** props.id, for debugging. */\n  id;\n  props;\n  userData = {};\n  _device;\n  /** Whether this resource has been destroyed */\n  destroyed = false;\n  /** For resources that allocate GPU memory */\n  allocatedBytes = 0;\n  /** Attached resources will be destroyed when this resource is destroyed. Tracks auto-created \"sub\" resources. */\n  _attachedResources = new Set();\n  /**\n   * Create a new Resource. Called from Subclass\n   */\n  constructor(device, props, defaultProps) {\n    if (!device) {\n      throw new Error('no device');\n    }\n    this._device = device;\n    this.props = selectivelyMerge(props, defaultProps);\n    const id = this.props.id !== 'undefined' ? this.props.id : uid(this[Symbol.toStringTag]);\n    this.props.id = id;\n    this.id = id;\n    this.userData = this.props.userData || {};\n    this.addStats();\n  }\n  /**\n   * destroy can be called on any resource to release it before it is garbage collected.\n   */\n  destroy() {\n    this.destroyResource();\n  }\n  /** @deprecated Use destroy() */\n  delete() {\n    this.destroy();\n    return this;\n  }\n  /**\n   * Combines a map of user props and default props, only including props from defaultProps\n   * @returns returns a map of overridden default props\n   */\n  getProps() {\n    return this.props;\n  }\n  // ATTACHED RESOURCES\n  /**\n   * Attaches a resource. Attached resources are auto destroyed when this resource is destroyed\n   * Called automatically when sub resources are auto created but can be called by application\n   */\n  attachResource(resource) {\n    this._attachedResources.add(resource);\n  }\n  /**\n   * Detach an attached resource. The resource will no longer be auto-destroyed when this resource is destroyed.\n   */\n  detachResource(resource) {\n    this._attachedResources.delete(resource);\n  }\n  /**\n   * Destroys a resource (only if owned), and removes from the owned (auto-destroy) list for this resource.\n   */\n  destroyAttachedResource(resource) {\n    if (this._attachedResources.delete(resource)) {\n      resource.destroy();\n    }\n  }\n  /** Destroy all owned resources. Make sure the resources are no longer needed before calling. */\n  destroyAttachedResources() {\n    for (const resource of Object.values(this._attachedResources)) {\n      resource.destroy();\n    }\n    // don't remove while we are iterating\n    this._attachedResources = new Set();\n  }\n  // PROTECTED METHODS\n  /** Perform all destroy steps. Can be called by derived resources when overriding destroy() */\n  destroyResource() {\n    this.destroyAttachedResources();\n    this.removeStats();\n    this.destroyed = true;\n  }\n  /** Called by .destroy() to track object destruction. Subclass must call if overriding destroy() */\n  removeStats() {\n    const stats = this._device.statsManager.getStats('Resource Counts');\n    const name = this[Symbol.toStringTag];\n    stats.get(`${name}s Active`).decrementCount();\n  }\n  /** Called by subclass to track memory allocations */\n  trackAllocatedMemory(bytes, name = this[Symbol.toStringTag]) {\n    const stats = this._device.statsManager.getStats('Resource Counts');\n    stats.get('GPU Memory').addCount(bytes);\n    stats.get(`${name} Memory`).addCount(bytes);\n    this.allocatedBytes = bytes;\n  }\n  /** Called by subclass to track memory deallocations */\n  trackDeallocatedMemory(name = this[Symbol.toStringTag]) {\n    const stats = this._device.statsManager.getStats('Resource Counts');\n    stats.get('GPU Memory').subtractCount(this.allocatedBytes);\n    stats.get(`${name} Memory`).subtractCount(this.allocatedBytes);\n    this.allocatedBytes = 0;\n  }\n  /** Called by resource constructor to track object creation */\n  addStats() {\n    const stats = this._device.statsManager.getStats('Resource Counts');\n    const name = this[Symbol.toStringTag];\n    stats.get('Resources Created').incrementCount();\n    stats.get(`${name}s Created`).incrementCount();\n    stats.get(`${name}s Active`).incrementCount();\n  }\n}\n/**\n * Combines a map of user props and default props, only including props from defaultProps\n * @param props\n * @param defaultProps\n * @returns returns a map of overridden default props\n */\nfunction selectivelyMerge(props, defaultProps) {\n  const mergedProps = {\n    ...defaultProps\n  };\n  for (const key in props) {\n    if (props[key] !== undefined) {\n      mergedProps[key] = props[key];\n    }\n  }\n  return mergedProps;\n}\n//# sourceMappingURL=resource.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}