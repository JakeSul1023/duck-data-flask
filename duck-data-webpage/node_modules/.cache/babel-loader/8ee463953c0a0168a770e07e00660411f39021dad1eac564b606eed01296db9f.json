{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Timeline } from '@luma.gl/engine';\nimport { getShaderAssembler, layerUniforms } from \"../shaderlib/index.js\";\nimport { LIFECYCLE } from \"../lifecycle/constants.js\";\nimport log from \"../utils/log.js\";\nimport debug from \"../debug/index.js\";\nimport { flatten } from \"../utils/flatten.js\";\nimport { Stats } from '@probe.gl/stats';\nimport ResourceManager from \"./resource/resource-manager.js\";\nimport Viewport from \"../viewports/viewport.js\";\nconst TRACE_SET_LAYERS = 'layerManager.setLayers';\nconst TRACE_ACTIVATE_VIEWPORT = 'layerManager.activateViewport';\nexport default class LayerManager {\n  /**\n   * @param device\n   * @param param1\n   */\n  // eslint-disable-next-line\n  constructor(device, props) {\n    this._lastRenderedLayers = [];\n    this._needsRedraw = false;\n    this._needsUpdate = false;\n    this._nextLayers = null;\n    this._debug = false;\n    // This flag is separate from _needsUpdate because it can be set during an update and should trigger another full update\n    this._defaultShaderModulesChanged = false;\n    //\n    // INTERNAL METHODS\n    //\n    /** Make a viewport \"current\" in layer context, updating viewportChanged flags */\n    this.activateViewport = viewport => {\n      debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);\n      if (viewport) {\n        this.context.viewport = viewport;\n      }\n    };\n    const {\n      deck,\n      stats,\n      viewport,\n      timeline\n    } = props || {};\n    // Currently deck.gl expects the DeckGL.layers array to be different\n    // whenever React rerenders. If the same layers array is used, the\n    // LayerManager's diffing algorithm will generate a fatal error and\n    // break the rendering.\n    // `this._lastRenderedLayers` stores the UNFILTERED layers sent\n    // down to LayerManager, so that `layers` reference can be compared.\n    // If it's the same across two React render calls, the diffing logic\n    // will be skipped.\n    this.layers = [];\n    this.resourceManager = new ResourceManager({\n      device,\n      protocol: 'deck://'\n    });\n    this.context = {\n      mousePosition: null,\n      userData: {},\n      layerManager: this,\n      device,\n      // @ts-expect-error\n      gl: device?.gl,\n      deck,\n      shaderAssembler: getShaderAssembler(device?.info?.shadingLanguage || 'glsl'),\n      defaultShaderModules: [layerUniforms],\n      renderPass: undefined,\n      stats: stats || new Stats({\n        id: 'deck.gl'\n      }),\n      // Make sure context.viewport is not empty on the first layer initialization\n      viewport: viewport || new Viewport({\n        id: 'DEFAULT-INITIAL-VIEWPORT'\n      }),\n      // Current viewport, exposed to layers for project* function\n      timeline: timeline || new Timeline(),\n      resourceManager: this.resourceManager,\n      onError: undefined\n    };\n    Object.seal(this);\n  }\n  /** Method to call when the layer manager is not needed anymore. */\n  finalize() {\n    this.resourceManager.finalize();\n    // Finalize all layers\n    for (const layer of this.layers) {\n      this._finalizeLayer(layer);\n    }\n  }\n  /** Check if a redraw is needed */\n  needsRedraw(opts = {\n    clearRedrawFlags: false\n  }) {\n    let redraw = this._needsRedraw;\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n    // This layers list doesn't include sublayers, relying on composite layers\n    for (const layer of this.layers) {\n      // Call every layer to clear their flags\n      const layerNeedsRedraw = layer.getNeedsRedraw(opts);\n      redraw = redraw || layerNeedsRedraw;\n    }\n    return redraw;\n  }\n  /** Check if a deep update of all layers is needed */\n  needsUpdate() {\n    if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {\n      // New layers array may be the same as the old one if `setProps` is called by React\n      return 'layers changed';\n    }\n    if (this._defaultShaderModulesChanged) {\n      return 'shader modules changed';\n    }\n    return this._needsUpdate;\n  }\n  /** Layers will be redrawn (in next animation frame) */\n  setNeedsRedraw(reason) {\n    this._needsRedraw = this._needsRedraw || reason;\n  }\n  /** Layers will be updated deeply (in next animation frame)\n    Potentially regenerating attributes and sub layers */\n  setNeedsUpdate(reason) {\n    this._needsUpdate = this._needsUpdate || reason;\n  }\n  /** Gets a list of currently rendered layers. Optionally filter by id. */\n  getLayers({\n    layerIds\n  } = {}) {\n    // Filtering by layerId compares beginning of strings, so that sublayers will be included\n    // Dependes on the convention of adding suffixes to the parent's layer name\n    return layerIds ? this.layers.filter(layer => layerIds.find(layerId => layer.id.indexOf(layerId) === 0)) : this.layers;\n  }\n  /** Set props needed for layer rendering and picking. */\n  setProps(props) {\n    if ('debug' in props) {\n      this._debug = props.debug;\n    }\n    // A way for apps to add data to context that can be accessed in layers\n    if ('userData' in props) {\n      this.context.userData = props.userData;\n    }\n    // New layers will be processed in `updateLayers` in the next update cycle\n    if ('layers' in props) {\n      this._nextLayers = props.layers;\n    }\n    if ('onError' in props) {\n      this.context.onError = props.onError;\n    }\n  }\n  /** Supply a new layer list, initiating sublayer generation and layer matching */\n  setLayers(newLayers, reason) {\n    debug(TRACE_SET_LAYERS, this, reason, newLayers);\n    this._lastRenderedLayers = newLayers;\n    const flatLayers = flatten(newLayers, Boolean);\n    for (const layer of flatLayers) {\n      layer.context = this.context;\n    }\n    this._updateLayers(this.layers, flatLayers);\n  }\n  /** Update layers from last cycle if `setNeedsUpdate()` has been called */\n  updateLayers() {\n    // NOTE: For now, even if only some layer has changed, we update all layers\n    // to ensure that layer id maps etc remain consistent even if different\n    // sublayers are rendered\n    const reason = this.needsUpdate();\n    if (reason) {\n      this.setNeedsRedraw(`updating layers: ${reason}`);\n      // Force a full update\n      this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);\n    }\n    // Updated, clear the backlog\n    this._nextLayers = null;\n  }\n  /** Register a default shader module */\n  addDefaultShaderModule(module) {\n    const {\n      defaultShaderModules\n    } = this.context;\n    if (!defaultShaderModules.find(m => m.name === module.name)) {\n      defaultShaderModules.push(module);\n      this._defaultShaderModulesChanged = true;\n    }\n  }\n  /** Deregister a default shader module */\n  removeDefaultShaderModule(module) {\n    const {\n      defaultShaderModules\n    } = this.context;\n    const i = defaultShaderModules.findIndex(m => m.name === module.name);\n    if (i >= 0) {\n      defaultShaderModules.splice(i, 1);\n      this._defaultShaderModulesChanged = true;\n    }\n  }\n  _handleError(stage, error, layer) {\n    layer.raiseError(error, `${stage} of ${layer}`);\n  }\n  // TODO - mark layers with exceptions as bad and remove from rendering cycle?\n  /** Match all layers, checking for caught errors\n    to avoid having an exception in one layer disrupt other layers */\n  _updateLayers(oldLayers, newLayers) {\n    // Create old layer map\n    const oldLayerMap = {};\n    for (const oldLayer of oldLayers) {\n      if (oldLayerMap[oldLayer.id]) {\n        log.warn(`Multiple old layers with same id ${oldLayer.id}`)();\n      } else {\n        oldLayerMap[oldLayer.id] = oldLayer;\n      }\n    }\n    if (this._defaultShaderModulesChanged) {\n      for (const layer of oldLayers) {\n        layer.setNeedsUpdate();\n        layer.setChangeFlags({\n          extensionsChanged: true\n        });\n      }\n      this._defaultShaderModulesChanged = false;\n    }\n    // Allocate array for generated layers\n    const generatedLayers = [];\n    // Match sublayers\n    this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);\n    // Finalize unmatched layers\n    this._finalizeOldLayers(oldLayerMap);\n    let needsUpdate = false;\n    for (const layer of generatedLayers) {\n      if (layer.hasUniformTransition()) {\n        needsUpdate = `Uniform transition in ${layer}`;\n        break;\n      }\n    }\n    this._needsUpdate = needsUpdate;\n    this.layers = generatedLayers;\n  }\n  /* eslint-disable complexity,max-statements */\n  // Note: adds generated layers to `generatedLayers` array parameter\n  _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {\n    for (const newLayer of newLayers) {\n      newLayer.context = this.context;\n      // Given a new coming layer, find its matching old layer (if any)\n      const oldLayer = oldLayerMap[newLayer.id];\n      if (oldLayer === null) {\n        // null, rather than undefined, means this id was originally there\n        log.warn(`Multiple new layers with same id ${newLayer.id}`)();\n      }\n      // Remove the old layer from candidates, as it has been matched with this layer\n      oldLayerMap[newLayer.id] = null;\n      let sublayers = null;\n      // We must not generate exceptions until after layer matching is complete\n      try {\n        if (this._debug && oldLayer !== newLayer) {\n          newLayer.validateProps();\n        }\n        if (!oldLayer) {\n          this._initializeLayer(newLayer);\n        } else {\n          this._transferLayerState(oldLayer, newLayer);\n          this._updateLayer(newLayer);\n        }\n        generatedLayers.push(newLayer);\n        // Call layer lifecycle method: render sublayers\n        sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;\n        // End layer lifecycle method: render sublayers\n      } catch (err) {\n        this._handleError('matching', err, newLayer); // Record first exception\n      }\n      if (sublayers) {\n        this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);\n      }\n    }\n  }\n  /* eslint-enable complexity,max-statements */\n  // Finalize any old layers that were not matched\n  _finalizeOldLayers(oldLayerMap) {\n    for (const layerId in oldLayerMap) {\n      const layer = oldLayerMap[layerId];\n      if (layer) {\n        this._finalizeLayer(layer);\n      }\n    }\n  }\n  // / EXCEPTION SAFE LAYER ACCESS\n  /** Safely initializes a single layer, calling layer methods */\n  _initializeLayer(layer) {\n    try {\n      layer._initialize();\n      layer.lifecycle = LIFECYCLE.INITIALIZED;\n    } catch (err) {\n      this._handleError('initialization', err, layer);\n      // TODO - what should the lifecycle state be here? LIFECYCLE.INITIALIZATION_FAILED?\n    }\n  }\n  /** Transfer state from one layer to a newer version */\n  _transferLayerState(oldLayer, newLayer) {\n    newLayer._transferState(oldLayer);\n    newLayer.lifecycle = LIFECYCLE.MATCHED;\n    if (newLayer !== oldLayer) {\n      oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;\n    }\n  }\n  /** Safely updates a single layer, cleaning all flags */\n  _updateLayer(layer) {\n    try {\n      layer._update();\n    } catch (err) {\n      this._handleError('update', err, layer);\n    }\n  }\n  /** Safely finalizes a single layer, removing all resources */\n  _finalizeLayer(layer) {\n    this._needsRedraw = this._needsRedraw || `finalized ${layer}`;\n    layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;\n    try {\n      layer._finalize();\n      layer.lifecycle = LIFECYCLE.FINALIZED;\n    } catch (err) {\n      this._handleError('finalization', err, layer);\n    }\n  }\n}","map":{"version":3,"names":["Timeline","getShaderAssembler","layerUniforms","LIFECYCLE","log","debug","flatten","Stats","ResourceManager","Viewport","TRACE_SET_LAYERS","TRACE_ACTIVATE_VIEWPORT","LayerManager","constructor","device","props","_lastRenderedLayers","_needsRedraw","_needsUpdate","_nextLayers","_debug","_defaultShaderModulesChanged","activateViewport","viewport","context","deck","stats","timeline","layers","resourceManager","protocol","mousePosition","userData","layerManager","gl","shaderAssembler","info","shadingLanguage","defaultShaderModules","renderPass","undefined","id","onError","Object","seal","finalize","layer","_finalizeLayer","needsRedraw","opts","clearRedrawFlags","redraw","layerNeedsRedraw","getNeedsRedraw","needsUpdate","setNeedsRedraw","reason","setNeedsUpdate","getLayers","layerIds","filter","find","layerId","indexOf","setProps","setLayers","newLayers","flatLayers","Boolean","_updateLayers","updateLayers","addDefaultShaderModule","module","m","name","push","removeDefaultShaderModule","i","findIndex","splice","_handleError","stage","error","raiseError","oldLayers","oldLayerMap","oldLayer","warn","setChangeFlags","extensionsChanged","generatedLayers","_updateSublayersRecursively","_finalizeOldLayers","hasUniformTransition","newLayer","sublayers","validateProps","_initializeLayer","_transferLayerState","_updateLayer","isComposite","getSubLayers","err","_initialize","lifecycle","INITIALIZED","_transferState","MATCHED","AWAITING_GC","_update","AWAITING_FINALIZATION","_finalize","FINALIZED"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\lib\\layer-manager.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device, RenderPass} from '@luma.gl/core';\nimport {Timeline} from '@luma.gl/engine';\nimport type {ShaderAssembler, ShaderModule} from '@luma.gl/shadertools';\nimport {getShaderAssembler, layerUniforms} from '../shaderlib/index';\nimport {LIFECYCLE} from '../lifecycle/constants';\nimport log from '../utils/log';\nimport debug from '../debug/index';\nimport {flatten} from '../utils/flatten';\nimport {Stats} from '@probe.gl/stats';\nimport ResourceManager from './resource/resource-manager';\n\nimport Viewport from '../viewports/viewport';\n\nimport type Layer from './layer';\nimport type CompositeLayer from './composite-layer';\nimport type Deck from './deck';\n\nconst TRACE_SET_LAYERS = 'layerManager.setLayers';\nconst TRACE_ACTIVATE_VIEWPORT = 'layerManager.activateViewport';\n\nexport type LayerContext = {\n  layerManager: LayerManager;\n  resourceManager: ResourceManager;\n  deck?: Deck<any>;\n  device: Device;\n  shaderAssembler: ShaderAssembler;\n  defaultShaderModules: ShaderModule[];\n  renderPass: RenderPass;\n  stats: Stats;\n  viewport: Viewport;\n  timeline: Timeline;\n  mousePosition: {x: number; y: number} | null;\n  userData: any;\n  onError?: <PropsT extends {}>(error: Error, source: Layer<PropsT>) => void;\n  /** @deprecated Use context.device */\n  gl: WebGL2RenderingContext;\n};\n\nexport type LayersList = (Layer | undefined | false | null | LayersList)[];\n\nexport type LayerManagerProps = {\n  deck?: Deck<any>;\n  stats?: Stats;\n  viewport?: Viewport;\n  timeline?: Timeline;\n};\nexport default class LayerManager {\n  layers: Layer[];\n  context: LayerContext;\n  resourceManager: ResourceManager;\n\n  private _lastRenderedLayers: LayersList = [];\n  private _needsRedraw: string | false = false;\n  private _needsUpdate: string | false = false;\n  private _nextLayers: LayersList | null = null;\n  private _debug: boolean = false;\n  // This flag is separate from _needsUpdate because it can be set during an update and should trigger another full update\n  private _defaultShaderModulesChanged: boolean = false;\n\n  /**\n   * @param device\n   * @param param1\n   */\n  // eslint-disable-next-line\n  constructor(device: Device, props: LayerManagerProps) {\n    const {deck, stats, viewport, timeline} = props || {};\n\n    // Currently deck.gl expects the DeckGL.layers array to be different\n    // whenever React rerenders. If the same layers array is used, the\n    // LayerManager's diffing algorithm will generate a fatal error and\n    // break the rendering.\n\n    // `this._lastRenderedLayers` stores the UNFILTERED layers sent\n    // down to LayerManager, so that `layers` reference can be compared.\n    // If it's the same across two React render calls, the diffing logic\n    // will be skipped.\n    this.layers = [];\n    this.resourceManager = new ResourceManager({device, protocol: 'deck://'});\n\n    this.context = {\n      mousePosition: null,\n      userData: {},\n      layerManager: this,\n      device,\n      // @ts-expect-error\n      gl: device?.gl,\n      deck,\n      shaderAssembler: getShaderAssembler(device?.info?.shadingLanguage || 'glsl'),\n      defaultShaderModules: [layerUniforms],\n      renderPass: undefined!,\n      stats: stats || new Stats({id: 'deck.gl'}),\n      // Make sure context.viewport is not empty on the first layer initialization\n      viewport: viewport || new Viewport({id: 'DEFAULT-INITIAL-VIEWPORT'}), // Current viewport, exposed to layers for project* function\n      timeline: timeline || new Timeline(),\n      resourceManager: this.resourceManager,\n      onError: undefined\n    };\n\n    Object.seal(this);\n  }\n\n  /** Method to call when the layer manager is not needed anymore. */\n  finalize() {\n    this.resourceManager.finalize();\n    // Finalize all layers\n    for (const layer of this.layers) {\n      this._finalizeLayer(layer);\n    }\n  }\n\n  /** Check if a redraw is needed */\n  needsRedraw(\n    opts: {\n      /** Reset redraw flags to false after the call */\n      clearRedrawFlags: boolean;\n    } = {clearRedrawFlags: false}\n  ): string | false {\n    let redraw = this._needsRedraw;\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n\n    // This layers list doesn't include sublayers, relying on composite layers\n    for (const layer of this.layers) {\n      // Call every layer to clear their flags\n      const layerNeedsRedraw = layer.getNeedsRedraw(opts);\n      redraw = redraw || layerNeedsRedraw;\n    }\n\n    return redraw;\n  }\n\n  /** Check if a deep update of all layers is needed */\n  needsUpdate(): string | false {\n    if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {\n      // New layers array may be the same as the old one if `setProps` is called by React\n      return 'layers changed';\n    }\n    if (this._defaultShaderModulesChanged) {\n      return 'shader modules changed';\n    }\n    return this._needsUpdate;\n  }\n\n  /** Layers will be redrawn (in next animation frame) */\n  setNeedsRedraw(reason: string): void {\n    this._needsRedraw = this._needsRedraw || reason;\n  }\n\n  /** Layers will be updated deeply (in next animation frame)\n    Potentially regenerating attributes and sub layers */\n  setNeedsUpdate(reason: string): void {\n    this._needsUpdate = this._needsUpdate || reason;\n  }\n\n  /** Gets a list of currently rendered layers. Optionally filter by id. */\n  getLayers({layerIds}: {layerIds?: string[]} = {}): Layer[] {\n    // Filtering by layerId compares beginning of strings, so that sublayers will be included\n    // Dependes on the convention of adding suffixes to the parent's layer name\n    return layerIds\n      ? this.layers.filter(layer => layerIds.find(layerId => layer.id.indexOf(layerId) === 0))\n      : this.layers;\n  }\n\n  /** Set props needed for layer rendering and picking. */\n  setProps(props: any): void {\n    if ('debug' in props) {\n      this._debug = props.debug;\n    }\n\n    // A way for apps to add data to context that can be accessed in layers\n    if ('userData' in props) {\n      this.context.userData = props.userData;\n    }\n\n    // New layers will be processed in `updateLayers` in the next update cycle\n    if ('layers' in props) {\n      this._nextLayers = props.layers;\n    }\n\n    if ('onError' in props) {\n      this.context.onError = props.onError;\n    }\n  }\n\n  /** Supply a new layer list, initiating sublayer generation and layer matching */\n  setLayers(newLayers: LayersList, reason?: string): void {\n    debug(TRACE_SET_LAYERS, this, reason, newLayers);\n\n    this._lastRenderedLayers = newLayers;\n\n    const flatLayers = flatten(newLayers, Boolean) as Layer[];\n\n    for (const layer of flatLayers) {\n      layer.context = this.context;\n    }\n\n    this._updateLayers(this.layers, flatLayers);\n  }\n\n  /** Update layers from last cycle if `setNeedsUpdate()` has been called */\n  updateLayers(): void {\n    // NOTE: For now, even if only some layer has changed, we update all layers\n    // to ensure that layer id maps etc remain consistent even if different\n    // sublayers are rendered\n    const reason = this.needsUpdate();\n    if (reason) {\n      this.setNeedsRedraw(`updating layers: ${reason}`);\n      // Force a full update\n      this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);\n    }\n    // Updated, clear the backlog\n    this._nextLayers = null;\n  }\n\n  //\n  // INTERNAL METHODS\n  //\n\n  /** Make a viewport \"current\" in layer context, updating viewportChanged flags */\n  activateViewport = (viewport: Viewport) => {\n    debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);\n    if (viewport) {\n      this.context.viewport = viewport;\n    }\n  };\n\n  /** Register a default shader module */\n  addDefaultShaderModule(module: ShaderModule) {\n    const {defaultShaderModules} = this.context;\n    if (!defaultShaderModules.find(m => m.name === module.name)) {\n      defaultShaderModules.push(module);\n      this._defaultShaderModulesChanged = true;\n    }\n  }\n\n  /** Deregister a default shader module */\n  removeDefaultShaderModule(module: ShaderModule) {\n    const {defaultShaderModules} = this.context;\n    const i = defaultShaderModules.findIndex(m => m.name === module.name);\n    if (i >= 0) {\n      defaultShaderModules.splice(i, 1);\n      this._defaultShaderModulesChanged = true;\n    }\n  }\n\n  private _handleError(stage: string, error: Error, layer: Layer) {\n    layer.raiseError(error, `${stage} of ${layer}`);\n  }\n\n  // TODO - mark layers with exceptions as bad and remove from rendering cycle?\n  /** Match all layers, checking for caught errors\n    to avoid having an exception in one layer disrupt other layers */\n  private _updateLayers(oldLayers: Layer[], newLayers: Layer[]): void {\n    // Create old layer map\n    const oldLayerMap: {[layerId: string]: Layer | null} = {};\n    for (const oldLayer of oldLayers) {\n      if (oldLayerMap[oldLayer.id]) {\n        log.warn(`Multiple old layers with same id ${oldLayer.id}`)();\n      } else {\n        oldLayerMap[oldLayer.id] = oldLayer;\n      }\n    }\n\n    if (this._defaultShaderModulesChanged) {\n      for (const layer of oldLayers) {\n        layer.setNeedsUpdate();\n        layer.setChangeFlags({extensionsChanged: true});\n      }\n      this._defaultShaderModulesChanged = false;\n    }\n\n    // Allocate array for generated layers\n    const generatedLayers: Layer[] = [];\n\n    // Match sublayers\n    this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);\n\n    // Finalize unmatched layers\n    this._finalizeOldLayers(oldLayerMap);\n\n    let needsUpdate: string | false = false;\n    for (const layer of generatedLayers) {\n      if (layer.hasUniformTransition()) {\n        needsUpdate = `Uniform transition in ${layer}`;\n        break;\n      }\n    }\n\n    this._needsUpdate = needsUpdate;\n    this.layers = generatedLayers;\n  }\n\n  /* eslint-disable complexity,max-statements */\n  // Note: adds generated layers to `generatedLayers` array parameter\n  private _updateSublayersRecursively(\n    newLayers: Layer[],\n    oldLayerMap: {[layerId: string]: Layer | null},\n    generatedLayers: Layer[]\n  ) {\n    for (const newLayer of newLayers) {\n      newLayer.context = this.context;\n\n      // Given a new coming layer, find its matching old layer (if any)\n      const oldLayer = oldLayerMap[newLayer.id];\n      if (oldLayer === null) {\n        // null, rather than undefined, means this id was originally there\n        log.warn(`Multiple new layers with same id ${newLayer.id}`)();\n      }\n      // Remove the old layer from candidates, as it has been matched with this layer\n      oldLayerMap[newLayer.id] = null;\n\n      let sublayers: Layer[] | null = null;\n\n      // We must not generate exceptions until after layer matching is complete\n      try {\n        if (this._debug && oldLayer !== newLayer) {\n          newLayer.validateProps();\n        }\n\n        if (!oldLayer) {\n          this._initializeLayer(newLayer);\n        } else {\n          this._transferLayerState(oldLayer, newLayer);\n          this._updateLayer(newLayer);\n        }\n        generatedLayers.push(newLayer);\n\n        // Call layer lifecycle method: render sublayers\n        sublayers = newLayer.isComposite ? (newLayer as CompositeLayer).getSubLayers() : null;\n        // End layer lifecycle method: render sublayers\n      } catch (err) {\n        this._handleError('matching', err as Error, newLayer); // Record first exception\n      }\n\n      if (sublayers) {\n        this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);\n      }\n    }\n  }\n  /* eslint-enable complexity,max-statements */\n\n  // Finalize any old layers that were not matched\n  private _finalizeOldLayers(oldLayerMap: {[layerId: string]: Layer | null}): void {\n    for (const layerId in oldLayerMap) {\n      const layer = oldLayerMap[layerId];\n      if (layer) {\n        this._finalizeLayer(layer);\n      }\n    }\n  }\n\n  // / EXCEPTION SAFE LAYER ACCESS\n\n  /** Safely initializes a single layer, calling layer methods */\n  private _initializeLayer(layer: Layer): void {\n    try {\n      layer._initialize();\n      layer.lifecycle = LIFECYCLE.INITIALIZED;\n    } catch (err) {\n      this._handleError('initialization', err as Error, layer);\n      // TODO - what should the lifecycle state be here? LIFECYCLE.INITIALIZATION_FAILED?\n    }\n  }\n\n  /** Transfer state from one layer to a newer version */\n  private _transferLayerState(oldLayer: Layer, newLayer: Layer): void {\n    newLayer._transferState(oldLayer);\n    newLayer.lifecycle = LIFECYCLE.MATCHED;\n\n    if (newLayer !== oldLayer) {\n      oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;\n    }\n  }\n\n  /** Safely updates a single layer, cleaning all flags */\n  private _updateLayer(layer: Layer): void {\n    try {\n      layer._update();\n    } catch (err) {\n      this._handleError('update', err as Error, layer);\n    }\n  }\n\n  /** Safely finalizes a single layer, removing all resources */\n  private _finalizeLayer(layer: Layer): void {\n    this._needsRedraw = this._needsRedraw || `finalized ${layer}`;\n\n    layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;\n\n    try {\n      layer._finalize();\n      layer.lifecycle = LIFECYCLE.FINALIZED;\n    } catch (err) {\n      this._handleError('finalization', err as Error, layer);\n    }\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAGA,SAAQA,QAAQ,QAAO,iBAAiB;AAExC,SAAQC,kBAAkB,EAAEC,aAAa,QAAC;AAC1C,SAAQC,SAAS,QAAC;AAClB,OAAOC,GAAG;AACV,OAAOC,KAAK;AACZ,SAAQC,OAAO,QAAC;AAChB,SAAQC,KAAK,QAAO,iBAAiB;AACrC,OAAOC,eAAe;AAEtB,OAAOC,QAAQ;AAMf,MAAMC,gBAAgB,GAAG,wBAAwB;AACjD,MAAMC,uBAAuB,GAAG,+BAA+B;AA4B/D,eAAc,MAAOC,YAAY;EAa/B;;;;EAIA;EACAC,YAAYC,MAAc,EAAEC,KAAwB;IAb5C,KAAAC,mBAAmB,GAAe,EAAE;IACpC,KAAAC,YAAY,GAAmB,KAAK;IACpC,KAAAC,YAAY,GAAmB,KAAK;IACpC,KAAAC,WAAW,GAAsB,IAAI;IACrC,KAAAC,MAAM,GAAY,KAAK;IAC/B;IACQ,KAAAC,4BAA4B,GAAY,KAAK;IA8JrD;IACA;IACA;IAEA;IACA,KAAAC,gBAAgB,GAAIC,QAAkB,IAAI;MACxClB,KAAK,CAACM,uBAAuB,EAAE,IAAI,EAAEY,QAAQ,CAAC;MAC9C,IAAIA,QAAQ,EAAE;QACZ,IAAI,CAACC,OAAO,CAACD,QAAQ,GAAGA,QAAQ;MAClC;IACF,CAAC;IAhKC,MAAM;MAACE,IAAI;MAAEC,KAAK;MAAEH,QAAQ;MAAEI;IAAQ,CAAC,GAAGZ,KAAK,IAAI,EAAE;IAErD;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA,IAAI,CAACa,MAAM,GAAG,EAAE;IAChB,IAAI,CAACC,eAAe,GAAG,IAAIrB,eAAe,CAAC;MAACM,MAAM;MAAEgB,QAAQ,EAAE;IAAS,CAAC,CAAC;IAEzE,IAAI,CAACN,OAAO,GAAG;MACbO,aAAa,EAAE,IAAI;MACnBC,QAAQ,EAAE,EAAE;MACZC,YAAY,EAAE,IAAI;MAClBnB,MAAM;MACN;MACAoB,EAAE,EAAEpB,MAAM,EAAEoB,EAAE;MACdT,IAAI;MACJU,eAAe,EAAElC,kBAAkB,CAACa,MAAM,EAAEsB,IAAI,EAAEC,eAAe,IAAI,MAAM,CAAC;MAC5EC,oBAAoB,EAAE,CAACpC,aAAa,CAAC;MACrCqC,UAAU,EAAEC,SAAU;MACtBd,KAAK,EAAEA,KAAK,IAAI,IAAInB,KAAK,CAAC;QAACkC,EAAE,EAAE;MAAS,CAAC,CAAC;MAC1C;MACAlB,QAAQ,EAAEA,QAAQ,IAAI,IAAId,QAAQ,CAAC;QAACgC,EAAE,EAAE;MAA0B,CAAC,CAAC;MAAE;MACtEd,QAAQ,EAAEA,QAAQ,IAAI,IAAI3B,QAAQ,EAAE;MACpC6B,eAAe,EAAE,IAAI,CAACA,eAAe;MACrCa,OAAO,EAAEF;KACV;IAEDG,MAAM,CAACC,IAAI,CAAC,IAAI,CAAC;EACnB;EAEA;EACAC,QAAQA,CAAA;IACN,IAAI,CAAChB,eAAe,CAACgB,QAAQ,EAAE;IAC/B;IACA,KAAK,MAAMC,KAAK,IAAI,IAAI,CAAClB,MAAM,EAAE;MAC/B,IAAI,CAACmB,cAAc,CAACD,KAAK,CAAC;IAC5B;EACF;EAEA;EACAE,WAAWA,CACTC,IAAA,GAGI;IAACC,gBAAgB,EAAE;EAAK,CAAC;IAE7B,IAAIC,MAAM,GAAG,IAAI,CAAClC,YAAY;IAC9B,IAAIgC,IAAI,CAACC,gBAAgB,EAAE;MACzB,IAAI,CAACjC,YAAY,GAAG,KAAK;IAC3B;IAEA;IACA,KAAK,MAAM6B,KAAK,IAAI,IAAI,CAAClB,MAAM,EAAE;MAC/B;MACA,MAAMwB,gBAAgB,GAAGN,KAAK,CAACO,cAAc,CAACJ,IAAI,CAAC;MACnDE,MAAM,GAAGA,MAAM,IAAIC,gBAAgB;IACrC;IAEA,OAAOD,MAAM;EACf;EAEA;EACAG,WAAWA,CAAA;IACT,IAAI,IAAI,CAACnC,WAAW,IAAI,IAAI,CAACA,WAAW,KAAK,IAAI,CAACH,mBAAmB,EAAE;MACrE;MACA,OAAO,gBAAgB;IACzB;IACA,IAAI,IAAI,CAACK,4BAA4B,EAAE;MACrC,OAAO,wBAAwB;IACjC;IACA,OAAO,IAAI,CAACH,YAAY;EAC1B;EAEA;EACAqC,cAAcA,CAACC,MAAc;IAC3B,IAAI,CAACvC,YAAY,GAAG,IAAI,CAACA,YAAY,IAAIuC,MAAM;EACjD;EAEA;;EAEAC,cAAcA,CAACD,MAAc;IAC3B,IAAI,CAACtC,YAAY,GAAG,IAAI,CAACA,YAAY,IAAIsC,MAAM;EACjD;EAEA;EACAE,SAASA,CAAC;IAACC;EAAQ,IAA2B,EAAE;IAC9C;IACA;IACA,OAAOA,QAAQ,GACX,IAAI,CAAC/B,MAAM,CAACgC,MAAM,CAACd,KAAK,IAAIa,QAAQ,CAACE,IAAI,CAACC,OAAO,IAAIhB,KAAK,CAACL,EAAE,CAACsB,OAAO,CAACD,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,GACtF,IAAI,CAAClC,MAAM;EACjB;EAEA;EACAoC,QAAQA,CAACjD,KAAU;IACjB,IAAI,OAAO,IAAIA,KAAK,EAAE;MACpB,IAAI,CAACK,MAAM,GAAGL,KAAK,CAACV,KAAK;IAC3B;IAEA;IACA,IAAI,UAAU,IAAIU,KAAK,EAAE;MACvB,IAAI,CAACS,OAAO,CAACQ,QAAQ,GAAGjB,KAAK,CAACiB,QAAQ;IACxC;IAEA;IACA,IAAI,QAAQ,IAAIjB,KAAK,EAAE;MACrB,IAAI,CAACI,WAAW,GAAGJ,KAAK,CAACa,MAAM;IACjC;IAEA,IAAI,SAAS,IAAIb,KAAK,EAAE;MACtB,IAAI,CAACS,OAAO,CAACkB,OAAO,GAAG3B,KAAK,CAAC2B,OAAO;IACtC;EACF;EAEA;EACAuB,SAASA,CAACC,SAAqB,EAAEV,MAAe;IAC9CnD,KAAK,CAACK,gBAAgB,EAAE,IAAI,EAAE8C,MAAM,EAAEU,SAAS,CAAC;IAEhD,IAAI,CAAClD,mBAAmB,GAAGkD,SAAS;IAEpC,MAAMC,UAAU,GAAG7D,OAAO,CAAC4D,SAAS,EAAEE,OAAO,CAAY;IAEzD,KAAK,MAAMtB,KAAK,IAAIqB,UAAU,EAAE;MAC9BrB,KAAK,CAACtB,OAAO,GAAG,IAAI,CAACA,OAAO;IAC9B;IAEA,IAAI,CAAC6C,aAAa,CAAC,IAAI,CAACzC,MAAM,EAAEuC,UAAU,CAAC;EAC7C;EAEA;EACAG,YAAYA,CAAA;IACV;IACA;IACA;IACA,MAAMd,MAAM,GAAG,IAAI,CAACF,WAAW,EAAE;IACjC,IAAIE,MAAM,EAAE;MACV,IAAI,CAACD,cAAc,CAAC,oBAAoBC,MAAM,EAAE,CAAC;MACjD;MACA,IAAI,CAACS,SAAS,CAAC,IAAI,CAAC9C,WAAW,IAAI,IAAI,CAACH,mBAAmB,EAAEwC,MAAM,CAAC;IACtE;IACA;IACA,IAAI,CAACrC,WAAW,GAAG,IAAI;EACzB;EAcA;EACAoD,sBAAsBA,CAACC,MAAoB;IACzC,MAAM;MAAClC;IAAoB,CAAC,GAAG,IAAI,CAACd,OAAO;IAC3C,IAAI,CAACc,oBAAoB,CAACuB,IAAI,CAACY,CAAC,IAAIA,CAAC,CAACC,IAAI,KAAKF,MAAM,CAACE,IAAI,CAAC,EAAE;MAC3DpC,oBAAoB,CAACqC,IAAI,CAACH,MAAM,CAAC;MACjC,IAAI,CAACnD,4BAA4B,GAAG,IAAI;IAC1C;EACF;EAEA;EACAuD,yBAAyBA,CAACJ,MAAoB;IAC5C,MAAM;MAAClC;IAAoB,CAAC,GAAG,IAAI,CAACd,OAAO;IAC3C,MAAMqD,CAAC,GAAGvC,oBAAoB,CAACwC,SAAS,CAACL,CAAC,IAAIA,CAAC,CAACC,IAAI,KAAKF,MAAM,CAACE,IAAI,CAAC;IACrE,IAAIG,CAAC,IAAI,CAAC,EAAE;MACVvC,oBAAoB,CAACyC,MAAM,CAACF,CAAC,EAAE,CAAC,CAAC;MACjC,IAAI,CAACxD,4BAA4B,GAAG,IAAI;IAC1C;EACF;EAEQ2D,YAAYA,CAACC,KAAa,EAAEC,KAAY,EAAEpC,KAAY;IAC5DA,KAAK,CAACqC,UAAU,CAACD,KAAK,EAAE,GAAGD,KAAK,OAAOnC,KAAK,EAAE,CAAC;EACjD;EAEA;EACA;;EAEQuB,aAAaA,CAACe,SAAkB,EAAElB,SAAkB;IAC1D;IACA,MAAMmB,WAAW,GAAsC,EAAE;IACzD,KAAK,MAAMC,QAAQ,IAAIF,SAAS,EAAE;MAChC,IAAIC,WAAW,CAACC,QAAQ,CAAC7C,EAAE,CAAC,EAAE;QAC5BrC,GAAG,CAACmF,IAAI,CAAC,oCAAoCD,QAAQ,CAAC7C,EAAE,EAAE,CAAC,EAAE;MAC/D,CAAC,MAAM;QACL4C,WAAW,CAACC,QAAQ,CAAC7C,EAAE,CAAC,GAAG6C,QAAQ;MACrC;IACF;IAEA,IAAI,IAAI,CAACjE,4BAA4B,EAAE;MACrC,KAAK,MAAMyB,KAAK,IAAIsC,SAAS,EAAE;QAC7BtC,KAAK,CAACW,cAAc,EAAE;QACtBX,KAAK,CAAC0C,cAAc,CAAC;UAACC,iBAAiB,EAAE;QAAI,CAAC,CAAC;MACjD;MACA,IAAI,CAACpE,4BAA4B,GAAG,KAAK;IAC3C;IAEA;IACA,MAAMqE,eAAe,GAAY,EAAE;IAEnC;IACA,IAAI,CAACC,2BAA2B,CAACzB,SAAS,EAAEmB,WAAW,EAAEK,eAAe,CAAC;IAEzE;IACA,IAAI,CAACE,kBAAkB,CAACP,WAAW,CAAC;IAEpC,IAAI/B,WAAW,GAAmB,KAAK;IACvC,KAAK,MAAMR,KAAK,IAAI4C,eAAe,EAAE;MACnC,IAAI5C,KAAK,CAAC+C,oBAAoB,EAAE,EAAE;QAChCvC,WAAW,GAAG,yBAAyBR,KAAK,EAAE;QAC9C;MACF;IACF;IAEA,IAAI,CAAC5B,YAAY,GAAGoC,WAAW;IAC/B,IAAI,CAAC1B,MAAM,GAAG8D,eAAe;EAC/B;EAEA;EACA;EACQC,2BAA2BA,CACjCzB,SAAkB,EAClBmB,WAA8C,EAC9CK,eAAwB;IAExB,KAAK,MAAMI,QAAQ,IAAI5B,SAAS,EAAE;MAChC4B,QAAQ,CAACtE,OAAO,GAAG,IAAI,CAACA,OAAO;MAE/B;MACA,MAAM8D,QAAQ,GAAGD,WAAW,CAACS,QAAQ,CAACrD,EAAE,CAAC;MACzC,IAAI6C,QAAQ,KAAK,IAAI,EAAE;QACrB;QACAlF,GAAG,CAACmF,IAAI,CAAC,oCAAoCO,QAAQ,CAACrD,EAAE,EAAE,CAAC,EAAE;MAC/D;MACA;MACA4C,WAAW,CAACS,QAAQ,CAACrD,EAAE,CAAC,GAAG,IAAI;MAE/B,IAAIsD,SAAS,GAAmB,IAAI;MAEpC;MACA,IAAI;QACF,IAAI,IAAI,CAAC3E,MAAM,IAAIkE,QAAQ,KAAKQ,QAAQ,EAAE;UACxCA,QAAQ,CAACE,aAAa,EAAE;QAC1B;QAEA,IAAI,CAACV,QAAQ,EAAE;UACb,IAAI,CAACW,gBAAgB,CAACH,QAAQ,CAAC;QACjC,CAAC,MAAM;UACL,IAAI,CAACI,mBAAmB,CAACZ,QAAQ,EAAEQ,QAAQ,CAAC;UAC5C,IAAI,CAACK,YAAY,CAACL,QAAQ,CAAC;QAC7B;QACAJ,eAAe,CAACf,IAAI,CAACmB,QAAQ,CAAC;QAE9B;QACAC,SAAS,GAAGD,QAAQ,CAACM,WAAW,GAAIN,QAA2B,CAACO,YAAY,EAAE,GAAG,IAAI;QACrF;MACF,CAAC,CAAC,OAAOC,GAAG,EAAE;QACZ,IAAI,CAACtB,YAAY,CAAC,UAAU,EAAEsB,GAAY,EAAER,QAAQ,CAAC,CAAC,CAAC;MACzD;MAEA,IAAIC,SAAS,EAAE;QACb,IAAI,CAACJ,2BAA2B,CAACI,SAAS,EAAEV,WAAW,EAAEK,eAAe,CAAC;MAC3E;IACF;EACF;EACA;EAEA;EACQE,kBAAkBA,CAACP,WAA8C;IACvE,KAAK,MAAMvB,OAAO,IAAIuB,WAAW,EAAE;MACjC,MAAMvC,KAAK,GAAGuC,WAAW,CAACvB,OAAO,CAAC;MAClC,IAAIhB,KAAK,EAAE;QACT,IAAI,CAACC,cAAc,CAACD,KAAK,CAAC;MAC5B;IACF;EACF;EAEA;EAEA;EACQmD,gBAAgBA,CAACnD,KAAY;IACnC,IAAI;MACFA,KAAK,CAACyD,WAAW,EAAE;MACnBzD,KAAK,CAAC0D,SAAS,GAAGrG,SAAS,CAACsG,WAAW;IACzC,CAAC,CAAC,OAAOH,GAAG,EAAE;MACZ,IAAI,CAACtB,YAAY,CAAC,gBAAgB,EAAEsB,GAAY,EAAExD,KAAK,CAAC;MACxD;IACF;EACF;EAEA;EACQoD,mBAAmBA,CAACZ,QAAe,EAAEQ,QAAe;IAC1DA,QAAQ,CAACY,cAAc,CAACpB,QAAQ,CAAC;IACjCQ,QAAQ,CAACU,SAAS,GAAGrG,SAAS,CAACwG,OAAO;IAEtC,IAAIb,QAAQ,KAAKR,QAAQ,EAAE;MACzBA,QAAQ,CAACkB,SAAS,GAAGrG,SAAS,CAACyG,WAAW;IAC5C;EACF;EAEA;EACQT,YAAYA,CAACrD,KAAY;IAC/B,IAAI;MACFA,KAAK,CAAC+D,OAAO,EAAE;IACjB,CAAC,CAAC,OAAOP,GAAG,EAAE;MACZ,IAAI,CAACtB,YAAY,CAAC,QAAQ,EAAEsB,GAAY,EAAExD,KAAK,CAAC;IAClD;EACF;EAEA;EACQC,cAAcA,CAACD,KAAY;IACjC,IAAI,CAAC7B,YAAY,GAAG,IAAI,CAACA,YAAY,IAAI,aAAa6B,KAAK,EAAE;IAE7DA,KAAK,CAAC0D,SAAS,GAAGrG,SAAS,CAAC2G,qBAAqB;IAEjD,IAAI;MACFhE,KAAK,CAACiE,SAAS,EAAE;MACjBjE,KAAK,CAAC0D,SAAS,GAAGrG,SAAS,CAAC6G,SAAS;IACvC,CAAC,CAAC,OAAOV,GAAG,EAAE;MACZ,IAAI,CAACtB,YAAY,CAAC,cAAc,EAAEsB,GAAY,EAAExD,KAAK,CAAC;IACxD;EACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}