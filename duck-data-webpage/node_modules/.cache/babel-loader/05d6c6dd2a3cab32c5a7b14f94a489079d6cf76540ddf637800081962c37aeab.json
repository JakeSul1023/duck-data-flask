{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* eslint-disable guard-for-in */\nimport Attribute from \"./attribute.js\";\nimport log from \"../../utils/log.js\";\nimport memoize from \"../../utils/memoize.js\";\nimport { mergeBounds } from \"../../utils/math-utils.js\";\nimport debug from \"../../debug/index.js\";\nimport AttributeTransitionManager from \"./attribute-transition-manager.js\";\nconst TRACE_INVALIDATE = 'attributeManager.invalidate';\nconst TRACE_UPDATE_START = 'attributeManager.updateStart';\nconst TRACE_UPDATE_END = 'attributeManager.updateEnd';\nconst TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';\nconst TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';\nconst TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';\nexport default class AttributeManager {\n  constructor(device, {\n    id = 'attribute-manager',\n    stats,\n    timeline\n  } = {}) {\n    this.mergeBoundsMemoized = memoize(mergeBounds);\n    this.id = id;\n    this.device = device;\n    this.attributes = {};\n    this.updateTriggers = {};\n    this.needsRedraw = true;\n    this.userData = {};\n    this.stats = stats;\n    this.attributeTransitionManager = new AttributeTransitionManager(device, {\n      id: `${id}-transitions`,\n      timeline\n    });\n    // For debugging sanity, prevent uninitialized members\n    Object.seal(this);\n  }\n  finalize() {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].delete();\n    }\n    this.attributeTransitionManager.finalize();\n  }\n  // Returns the redraw flag, optionally clearing it.\n  // Redraw flag will be set if any attributes attributes changed since\n  // flag was last cleared.\n  //\n  // @param {String} [clearRedrawFlags=false] - whether to clear the flag\n  // @return {false|String} - reason a redraw is needed.\n  getNeedsRedraw(opts = {\n    clearRedrawFlags: false\n  }) {\n    const redraw = this.needsRedraw;\n    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;\n    return redraw && this.id;\n  }\n  // Sets the redraw flag.\n  // @param {Boolean} redraw=true\n  setNeedsRedraw() {\n    this.needsRedraw = true;\n  }\n  // Adds attributes\n  add(attributes) {\n    this._add(attributes);\n  }\n  // Adds attributes\n  addInstanced(attributes) {\n    this._add(attributes, {\n      stepMode: 'instance'\n    });\n  }\n  /**\n   * Removes attributes\n   * Takes an array of attribute names and delete them from\n   * the attribute map if they exists\n   *\n   * @example\n   * attributeManager.remove(['position']);\n   *\n   * @param {Object} attributeNameArray - attribute name array (see above)\n   */\n  remove(attributeNameArray) {\n    for (const name of attributeNameArray) {\n      if (this.attributes[name] !== undefined) {\n        this.attributes[name].delete();\n        delete this.attributes[name];\n      }\n    }\n  }\n  // Marks an attribute for update\n  invalidate(triggerName, dataRange) {\n    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);\n  }\n  invalidateAll(dataRange) {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);\n    }\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, 'all');\n  }\n  // Ensure all attribute buffers are updated from props or data.\n  // eslint-disable-next-line complexity\n  update({\n    data,\n    numInstances,\n    startIndices = null,\n    transitions,\n    props = {},\n    buffers = {},\n    context = {}\n  }) {\n    // keep track of whether some attributes are updated\n    let updated = false;\n    debug(TRACE_UPDATE_START, this);\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeStart();\n    }\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      const accessorName = attribute.settings.accessor;\n      attribute.startIndices = startIndices;\n      attribute.numInstances = numInstances;\n      if (props[attributeName]) {\n        log.removed(`props.${attributeName}`, `data.attributes.${attributeName}`)();\n      }\n      if (attribute.setExternalBuffer(buffers[attributeName])) {\n        // Step 1: try update attribute directly from external buffers\n      } else if (attribute.setBinaryValue(typeof accessorName === 'string' ? buffers[accessorName] : undefined, data.startIndices)) {\n        // Step 2: try set packed value from external typed array\n      } else if (typeof accessorName === 'string' && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {\n        // Step 3: try set constant value from props\n        // Note: if buffers[accessorName] is supplied, ignore props[accessorName]\n        // This may happen when setBinaryValue falls through to use the auto updater\n      } else if (attribute.needsUpdate()) {\n        // Step 4: update via updater callback\n        updated = true;\n        this._updateAttribute({\n          attribute,\n          numInstances,\n          data,\n          props,\n          context\n        });\n      }\n      this.needsRedraw = this.needsRedraw || attribute.needsRedraw();\n    }\n    if (updated) {\n      // Only initiate alloc/update (and logging) if actually needed\n      debug(TRACE_UPDATE_END, this, numInstances);\n    }\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeEnd();\n    }\n    this.attributeTransitionManager.update({\n      attributes: this.attributes,\n      numInstances,\n      transitions\n    });\n  }\n  // Update attribute transition to the current timestamp\n  // Returns `true` if any transition is in progress\n  updateTransition() {\n    const {\n      attributeTransitionManager\n    } = this;\n    const transitionUpdated = attributeTransitionManager.run();\n    this.needsRedraw = this.needsRedraw || transitionUpdated;\n    return transitionUpdated;\n  }\n  /**\n   * Returns all attribute descriptors\n   * Note: Format matches luma.gl Model/Program.setAttributes()\n   * @return {Object} attributes - descriptors\n   */\n  getAttributes() {\n    return {\n      ...this.attributes,\n      ...this.attributeTransitionManager.getAttributes()\n    };\n  }\n  /**\n   * Computes the spatial bounds of a given set of attributes\n   */\n  getBounds(attributeNames) {\n    const bounds = attributeNames.map(attributeName => this.attributes[attributeName]?.getBounds());\n    return this.mergeBoundsMemoized(bounds);\n  }\n  /**\n   * Returns changed attribute descriptors\n   * This indicates which WebGLBuffers need to be updated\n   * @return {Object} attributes - descriptors\n   */\n  getChangedAttributes(opts = {\n    clearChangedFlags: false\n  }) {\n    const {\n      attributes,\n      attributeTransitionManager\n    } = this;\n    const changedAttributes = {\n      ...attributeTransitionManager.getAttributes()\n    };\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {\n        changedAttributes[attributeName] = attribute;\n      }\n    }\n    return changedAttributes;\n  }\n  /** Generate WebGPU-style buffer layout descriptors from all attributes */\n  getBufferLayouts(/** A luma.gl Model-shaped object that supplies additional hint to attribute resolution */\n  modelInfo) {\n    return Object.values(this.getAttributes()).map(attribute => attribute.getBufferLayout(modelInfo));\n  }\n  // PRIVATE METHODS\n  /** Register new attributes */\n  _add(/** A map from attribute name to attribute descriptors */\n  attributes, /** Additional attribute settings to pass to all attributes */\n  overrideOptions) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const props = {\n        ...attribute,\n        id: attributeName,\n        size: attribute.isIndexed && 1 || attribute.size || 1,\n        ...overrideOptions\n      };\n      // Initialize the attribute descriptor, with WebGL and metadata fields\n      this.attributes[attributeName] = new Attribute(this.device, props);\n    }\n    this._mapUpdateTriggersToAttributes();\n  }\n  // build updateTrigger name to attribute name mapping\n  _mapUpdateTriggersToAttributes() {\n    const triggers = {};\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      attribute.getUpdateTriggers().forEach(triggerName => {\n        if (!triggers[triggerName]) {\n          triggers[triggerName] = [];\n        }\n        triggers[triggerName].push(attributeName);\n      });\n    }\n    this.updateTriggers = triggers;\n  }\n  _invalidateTrigger(triggerName, dataRange) {\n    const {\n      attributes,\n      updateTriggers\n    } = this;\n    const invalidatedAttributes = updateTriggers[triggerName];\n    if (invalidatedAttributes) {\n      invalidatedAttributes.forEach(name => {\n        const attribute = attributes[name];\n        if (attribute) {\n          attribute.setNeedsUpdate(attribute.id, dataRange);\n        }\n      });\n    }\n    return invalidatedAttributes;\n  }\n  _updateAttribute(opts) {\n    const {\n      attribute,\n      numInstances\n    } = opts;\n    debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);\n    if (attribute.constant) {\n      // The attribute is flagged as constant outside of an update cycle\n      // Skip allocation and updater call\n      // @ts-ignore value can be set to an array by user but always cast to typed array during attribute update\n      attribute.setConstantValue(attribute.value);\n      return;\n    }\n    if (attribute.allocate(numInstances)) {\n      debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);\n    }\n    // Calls update on any buffers that need update\n    const updated = attribute.updateBuffer(opts);\n    if (updated) {\n      this.needsRedraw = true;\n      debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);\n    }\n  }\n}","map":{"version":3,"names":["Attribute","log","memoize","mergeBounds","debug","AttributeTransitionManager","TRACE_INVALIDATE","TRACE_UPDATE_START","TRACE_UPDATE_END","TRACE_ATTRIBUTE_UPDATE_START","TRACE_ATTRIBUTE_ALLOCATE","TRACE_ATTRIBUTE_UPDATE_END","AttributeManager","constructor","device","id","stats","timeline","mergeBoundsMemoized","attributes","updateTriggers","needsRedraw","userData","attributeTransitionManager","Object","seal","finalize","attributeName","delete","getNeedsRedraw","opts","clearRedrawFlags","redraw","setNeedsRedraw","add","_add","addInstanced","stepMode","remove","attributeNameArray","name","undefined","invalidate","triggerName","dataRange","invalidatedAttributes","_invalidateTrigger","invalidateAll","setNeedsUpdate","update","data","numInstances","startIndices","transitions","props","buffers","context","updated","get","timeStart","attribute","accessorName","settings","accessor","removed","setExternalBuffer","setBinaryValue","setConstantValue","needsUpdate","_updateAttribute","timeEnd","updateTransition","transitionUpdated","run","getAttributes","getBounds","attributeNames","bounds","map","getChangedAttributes","clearChangedFlags","changedAttributes","hasAttribute","getBufferLayouts","modelInfo","values","getBufferLayout","overrideOptions","size","isIndexed","_mapUpdateTriggersToAttributes","triggers","getUpdateTriggers","forEach","push","constant","value","allocate","updateBuffer"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\lib\\attribute\\attribute-manager.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable guard-for-in */\nimport Attribute, {AttributeOptions} from './attribute';\nimport log from '../../utils/log';\nimport memoize from '../../utils/memoize';\nimport {mergeBounds} from '../../utils/math-utils';\nimport debug from '../../debug/index';\nimport {NumericArray} from '../../types/types';\n\nimport AttributeTransitionManager from './attribute-transition-manager';\n\nimport type {Device, BufferLayout} from '@luma.gl/core';\nimport type {Stats} from '@probe.gl/stats';\nimport type {Timeline} from '@luma.gl/engine';\n\nconst TRACE_INVALIDATE = 'attributeManager.invalidate';\nconst TRACE_UPDATE_START = 'attributeManager.updateStart';\nconst TRACE_UPDATE_END = 'attributeManager.updateEnd';\nconst TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';\nconst TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';\nconst TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';\n\nexport default class AttributeManager {\n  /**\n   * @classdesc\n   * Automated attribute generation and management. Suitable when a set of\n   * vertex shader attributes are generated by iteration over a data array,\n   * and updates to these attributes are needed either when the data itself\n   * changes, or when other data relevant to the calculations change.\n   *\n   * - First the application registers descriptions of its dynamic vertex\n   *   attributes using AttributeManager.add().\n   * - Then, when any change that affects attributes is detected by the\n   *   application, the app will call AttributeManager.invalidate().\n   * - Finally before it renders, it calls AttributeManager.update() to\n   *   ensure that attributes are automatically rebuilt if anything has been\n   *   invalidated.\n   *\n   * The application provided update functions describe how attributes\n   * should be updated from a data array and are expected to traverse\n   * that data array (or iterable) and fill in the attribute's typed array.\n   *\n   * Note that the attribute manager intentionally does not do advanced\n   * change detection, but instead makes it easy to build such detection\n   * by offering the ability to \"invalidate\" each attribute separately.\n   */\n  id: string;\n  device: Device;\n  attributes: Record<string, Attribute>;\n  updateTriggers: {[name: string]: string[]};\n  needsRedraw: string | boolean;\n  userData: any;\n\n  private stats?: Stats;\n  private attributeTransitionManager: AttributeTransitionManager;\n  private mergeBoundsMemoized: any = memoize(mergeBounds);\n\n  constructor(\n    device: Device,\n    {\n      id = 'attribute-manager',\n      stats,\n      timeline\n    }: {\n      id?: string;\n      stats?: Stats;\n      timeline?: Timeline;\n    } = {}\n  ) {\n    this.id = id;\n    this.device = device;\n\n    this.attributes = {};\n\n    this.updateTriggers = {};\n    this.needsRedraw = true;\n\n    this.userData = {};\n    this.stats = stats;\n\n    this.attributeTransitionManager = new AttributeTransitionManager(device, {\n      id: `${id}-transitions`,\n      timeline\n    });\n\n    // For debugging sanity, prevent uninitialized members\n    Object.seal(this);\n  }\n\n  finalize() {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].delete();\n    }\n    this.attributeTransitionManager.finalize();\n  }\n\n  // Returns the redraw flag, optionally clearing it.\n  // Redraw flag will be set if any attributes attributes changed since\n  // flag was last cleared.\n  //\n  // @param {String} [clearRedrawFlags=false] - whether to clear the flag\n  // @return {false|String} - reason a redraw is needed.\n  getNeedsRedraw(opts: {clearRedrawFlags?: boolean} = {clearRedrawFlags: false}): string | false {\n    const redraw = this.needsRedraw;\n    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;\n    return redraw && this.id;\n  }\n\n  // Sets the redraw flag.\n  // @param {Boolean} redraw=true\n  setNeedsRedraw() {\n    this.needsRedraw = true;\n  }\n\n  // Adds attributes\n  add(attributes: {[id: string]: AttributeOptions}) {\n    this._add(attributes);\n  }\n\n  // Adds attributes\n  addInstanced(attributes: {[id: string]: AttributeOptions}) {\n    this._add(attributes, {stepMode: 'instance'});\n  }\n\n  /**\n   * Removes attributes\n   * Takes an array of attribute names and delete them from\n   * the attribute map if they exists\n   *\n   * @example\n   * attributeManager.remove(['position']);\n   *\n   * @param {Object} attributeNameArray - attribute name array (see above)\n   */\n  remove(attributeNameArray: string[]) {\n    for (const name of attributeNameArray) {\n      if (this.attributes[name] !== undefined) {\n        this.attributes[name].delete();\n        delete this.attributes[name];\n      }\n    }\n  }\n\n  // Marks an attribute for update\n  invalidate(triggerName: string, dataRange?: {startRow?: number; endRow?: number}) {\n    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);\n  }\n\n  invalidateAll(dataRange?: {startRow?: number; endRow?: number}) {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);\n    }\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, 'all');\n  }\n\n  // Ensure all attribute buffers are updated from props or data.\n  // eslint-disable-next-line complexity\n  update({\n    data,\n    numInstances,\n    startIndices = null,\n    transitions,\n    props = {},\n    buffers = {},\n    context = {}\n  }: {\n    data: any;\n    numInstances: number;\n    startIndices?: NumericArray | null;\n    transitions: any;\n    props: any;\n    buffers: any;\n    context: any;\n  }) {\n    // keep track of whether some attributes are updated\n    let updated = false;\n\n    debug(TRACE_UPDATE_START, this);\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeStart();\n    }\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      const accessorName = attribute.settings.accessor;\n      attribute.startIndices = startIndices;\n      attribute.numInstances = numInstances;\n\n      if (props[attributeName]) {\n        log.removed(`props.${attributeName}`, `data.attributes.${attributeName}`)();\n      }\n\n      if (attribute.setExternalBuffer(buffers[attributeName])) {\n        // Step 1: try update attribute directly from external buffers\n      } else if (\n        attribute.setBinaryValue(\n          typeof accessorName === 'string' ? buffers[accessorName] : undefined,\n          data.startIndices\n        )\n      ) {\n        // Step 2: try set packed value from external typed array\n      } else if (\n        typeof accessorName === 'string' &&\n        !buffers[accessorName] &&\n        attribute.setConstantValue(props[accessorName])\n      ) {\n        // Step 3: try set constant value from props\n        // Note: if buffers[accessorName] is supplied, ignore props[accessorName]\n        // This may happen when setBinaryValue falls through to use the auto updater\n      } else if (attribute.needsUpdate()) {\n        // Step 4: update via updater callback\n        updated = true;\n        this._updateAttribute({\n          attribute,\n          numInstances,\n          data,\n          props,\n          context\n        });\n      }\n\n      this.needsRedraw = this.needsRedraw || attribute.needsRedraw();\n    }\n\n    if (updated) {\n      // Only initiate alloc/update (and logging) if actually needed\n      debug(TRACE_UPDATE_END, this, numInstances);\n    }\n\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeEnd();\n    }\n\n    this.attributeTransitionManager.update({\n      attributes: this.attributes,\n      numInstances,\n      transitions\n    });\n  }\n\n  // Update attribute transition to the current timestamp\n  // Returns `true` if any transition is in progress\n  updateTransition() {\n    const {attributeTransitionManager} = this;\n    const transitionUpdated = attributeTransitionManager.run();\n    this.needsRedraw = this.needsRedraw || transitionUpdated;\n    return transitionUpdated;\n  }\n\n  /**\n   * Returns all attribute descriptors\n   * Note: Format matches luma.gl Model/Program.setAttributes()\n   * @return {Object} attributes - descriptors\n   */\n  getAttributes(): {[id: string]: Attribute} {\n    return {...this.attributes, ...this.attributeTransitionManager.getAttributes()};\n  }\n\n  /**\n   * Computes the spatial bounds of a given set of attributes\n   */\n  getBounds(attributeNames: string[]) {\n    const bounds = attributeNames.map(attributeName => this.attributes[attributeName]?.getBounds());\n    return this.mergeBoundsMemoized(bounds);\n  }\n\n  /**\n   * Returns changed attribute descriptors\n   * This indicates which WebGLBuffers need to be updated\n   * @return {Object} attributes - descriptors\n   */\n  getChangedAttributes(opts: {clearChangedFlags?: boolean} = {clearChangedFlags: false}): {\n    [id: string]: Attribute;\n  } {\n    const {attributes, attributeTransitionManager} = this;\n\n    const changedAttributes = {...attributeTransitionManager.getAttributes()};\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {\n        changedAttributes[attributeName] = attribute;\n      }\n    }\n\n    return changedAttributes;\n  }\n\n  /** Generate WebGPU-style buffer layout descriptors from all attributes */\n  getBufferLayouts(\n    /** A luma.gl Model-shaped object that supplies additional hint to attribute resolution */\n    modelInfo?: {\n      /** Whether the model is instanced */\n      isInstanced?: boolean;\n    }\n  ): BufferLayout[] {\n    return Object.values(this.getAttributes()).map(attribute =>\n      attribute.getBufferLayout(modelInfo)\n    );\n  }\n\n  // PRIVATE METHODS\n\n  /** Register new attributes */\n  private _add(\n    /** A map from attribute name to attribute descriptors */\n    attributes: {[id: string]: AttributeOptions},\n    /** Additional attribute settings to pass to all attributes */\n    overrideOptions?: Partial<AttributeOptions>\n  ) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n\n      const props: AttributeOptions = {\n        ...attribute,\n        id: attributeName,\n        size: (attribute.isIndexed && 1) || attribute.size || 1,\n        ...overrideOptions\n      };\n\n      // Initialize the attribute descriptor, with WebGL and metadata fields\n      this.attributes[attributeName] = new Attribute(this.device, props);\n    }\n\n    this._mapUpdateTriggersToAttributes();\n  }\n\n  // build updateTrigger name to attribute name mapping\n  private _mapUpdateTriggersToAttributes() {\n    const triggers: {[name: string]: string[]} = {};\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      attribute.getUpdateTriggers().forEach(triggerName => {\n        if (!triggers[triggerName]) {\n          triggers[triggerName] = [];\n        }\n        triggers[triggerName].push(attributeName);\n      });\n    }\n\n    this.updateTriggers = triggers;\n  }\n\n  private _invalidateTrigger(\n    triggerName: string,\n    dataRange?: {startRow?: number; endRow?: number}\n  ): string[] {\n    const {attributes, updateTriggers} = this;\n    const invalidatedAttributes = updateTriggers[triggerName];\n\n    if (invalidatedAttributes) {\n      invalidatedAttributes.forEach(name => {\n        const attribute = attributes[name];\n        if (attribute) {\n          attribute.setNeedsUpdate(attribute.id, dataRange);\n        }\n      });\n    }\n    return invalidatedAttributes;\n  }\n\n  private _updateAttribute(opts: {\n    attribute: Attribute;\n    numInstances: number;\n    data: any;\n    props: any;\n    context: any;\n  }) {\n    const {attribute, numInstances} = opts;\n    debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);\n\n    if (attribute.constant) {\n      // The attribute is flagged as constant outside of an update cycle\n      // Skip allocation and updater call\n      // @ts-ignore value can be set to an array by user but always cast to typed array during attribute update\n      attribute.setConstantValue(attribute.value);\n      return;\n    }\n\n    if (attribute.allocate(numInstances)) {\n      debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);\n    }\n\n    // Calls update on any buffers that need update\n    const updated = attribute.updateBuffer(opts);\n    if (updated) {\n      this.needsRedraw = true;\n      debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}