{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst a = new Uint32Array([0x12345678]);\nconst b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\nconst isLittleEndian = !(b[0] === 0x12);\nconst LITTLE_ENDIAN_OS = isLittleEndian;\n/**\n * The basic string format consists of 3 characters:\n * 1. a character describing the byteorder of the data (<: little-endian, >: big-endian, |: not-relevant)\n * 2. a character code giving the basic type of the array\n * 3. an integer providing the number of bytes the type uses.\n * https://numpy.org/doc/stable/reference/arrays.interface.html\n *\n * Here I only include the second and third characters, and check endianness separately\n */\nconst DTYPES = {\n  u1: Uint8Array,\n  i1: Int8Array,\n  u2: Uint16Array,\n  i2: Int16Array,\n  u4: Uint32Array,\n  i4: Int32Array,\n  f4: Float32Array,\n  f8: Float64Array\n};\nexport function parseNPY(arrayBuffer, options) {\n  const view = new DataView(arrayBuffer);\n  const {\n    header,\n    headerEndOffset\n  } = parseHeader(view);\n  const numpyType = header.descr;\n  const ArrayType = DTYPES[numpyType.slice(1, 3)];\n  if (!ArrayType) {\n    throw new Error(`Unimplemented type ${numpyType}`);\n  }\n  const nArrayElements = header.shape?.reduce((a, b) => a * b);\n  const arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;\n  if (arrayBuffer.byteLength < headerEndOffset + arrayByteLength) {\n    throw new Error('Buffer overflow');\n  }\n  const data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));\n  // Swap endianness if needed\n  if (numpyType[0] === '>' && LITTLE_ENDIAN_OS || numpyType[0] === '<' && !LITTLE_ENDIAN_OS) {\n    throw new Error('Incorrect endianness');\n  }\n  return {\n    data,\n    header\n  };\n}\n/**\n * Parse NPY header\n *\n * @param  view\n * @return\n */\nfunction parseHeader(view) {\n  const majorVersion = view.getUint8(6);\n  // const minorVersion = view.getUint8(7);\n  let offset = 8;\n  let headerLength;\n  if (majorVersion >= 2) {\n    headerLength = view.getUint32(offset, true);\n    offset += 4;\n  } else {\n    headerLength = view.getUint16(offset, true);\n    offset += 2;\n  }\n  const encoding = majorVersion <= 2 ? 'latin1' : 'utf-8';\n  const decoder = new TextDecoder(encoding);\n  const headerArray = new Uint8Array(view.buffer, offset, headerLength);\n  const headerText = decoder.decode(headerArray);\n  offset += headerLength;\n  const header = JSON.parse(headerText.replace(/'/g, '\"').replace('False', 'false').replace('(', '[').replace(/,*\\),*/g, ']'));\n  return {\n    header,\n    headerEndOffset: offset\n  };\n}","map":{"version":3,"names":["a","Uint32Array","b","Uint8Array","buffer","byteOffset","byteLength","isLittleEndian","LITTLE_ENDIAN_OS","DTYPES","u1","i1","Int8Array","u2","Uint16Array","i2","Int16Array","u4","i4","Int32Array","f4","Float32Array","f8","Float64Array","parseNPY","arrayBuffer","options","view","DataView","header","headerEndOffset","parseHeader","numpyType","descr","ArrayType","slice","Error","nArrayElements","shape","reduce","arrayByteLength","BYTES_PER_ELEMENT","data","majorVersion","getUint8","offset","headerLength","getUint32","getUint16","encoding","decoder","TextDecoder","headerArray","headerText","decode","JSON","parse","replace"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/textures/dist/lib/parsers/parse-npy.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst a = new Uint32Array([0x12345678]);\nconst b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\nconst isLittleEndian = !(b[0] === 0x12);\nconst LITTLE_ENDIAN_OS = isLittleEndian;\n/**\n * The basic string format consists of 3 characters:\n * 1. a character describing the byteorder of the data (<: little-endian, >: big-endian, |: not-relevant)\n * 2. a character code giving the basic type of the array\n * 3. an integer providing the number of bytes the type uses.\n * https://numpy.org/doc/stable/reference/arrays.interface.html\n *\n * Here I only include the second and third characters, and check endianness separately\n */\nconst DTYPES = {\n    u1: Uint8Array,\n    i1: Int8Array,\n    u2: Uint16Array,\n    i2: Int16Array,\n    u4: Uint32Array,\n    i4: Int32Array,\n    f4: Float32Array,\n    f8: Float64Array\n};\nexport function parseNPY(arrayBuffer, options) {\n    const view = new DataView(arrayBuffer);\n    const { header, headerEndOffset } = parseHeader(view);\n    const numpyType = header.descr;\n    const ArrayType = DTYPES[numpyType.slice(1, 3)];\n    if (!ArrayType) {\n        throw new Error(`Unimplemented type ${numpyType}`);\n    }\n    const nArrayElements = header.shape?.reduce((a, b) => a * b);\n    const arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;\n    if (arrayBuffer.byteLength < headerEndOffset + arrayByteLength) {\n        throw new Error('Buffer overflow');\n    }\n    const data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));\n    // Swap endianness if needed\n    if ((numpyType[0] === '>' && LITTLE_ENDIAN_OS) || (numpyType[0] === '<' && !LITTLE_ENDIAN_OS)) {\n        throw new Error('Incorrect endianness');\n    }\n    return {\n        data,\n        header\n    };\n}\n/**\n * Parse NPY header\n *\n * @param  view\n * @return\n */\nfunction parseHeader(view) {\n    const majorVersion = view.getUint8(6);\n    // const minorVersion = view.getUint8(7);\n    let offset = 8;\n    let headerLength;\n    if (majorVersion >= 2) {\n        headerLength = view.getUint32(offset, true);\n        offset += 4;\n    }\n    else {\n        headerLength = view.getUint16(offset, true);\n        offset += 2;\n    }\n    const encoding = majorVersion <= 2 ? 'latin1' : 'utf-8';\n    const decoder = new TextDecoder(encoding);\n    const headerArray = new Uint8Array(view.buffer, offset, headerLength);\n    const headerText = decoder.decode(headerArray);\n    offset += headerLength;\n    const header = JSON.parse(headerText\n        .replace(/'/g, '\"')\n        .replace('False', 'false')\n        .replace('(', '[')\n        .replace(/,*\\),*/g, ']'));\n    return { header, headerEndOffset: offset };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}