{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isAsyncIterable } from \"../utils/iterable-utils.js\";\nimport { COMPONENT_SYMBOL, PROP_TYPES_SYMBOL, ASYNC_ORIGINAL_SYMBOL, ASYNC_RESOLVED_SYMBOL, ASYNC_DEFAULTS_SYMBOL } from \"./constants.js\";\nconst EMPTY_PROPS = Object.freeze({});\nexport default class ComponentState {\n  constructor(component) {\n    this.component = component;\n    this.asyncProps = {}; // Prop values that the layer sees\n    this.onAsyncPropUpdated = () => {};\n    this.oldProps = null; // Last props before update\n    this.oldAsyncProps = null; // Last props before update, with async values copied.\n  }\n  finalize() {\n    for (const propName in this.asyncProps) {\n      const asyncProp = this.asyncProps[propName];\n      if (asyncProp && asyncProp.type && asyncProp.type.release) {\n        // Release any resources created by transforms\n        asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);\n      }\n    }\n    this.asyncProps = {};\n    this.component = null;\n    this.resetOldProps();\n  }\n  /* Layer-facing props API */\n  getOldProps() {\n    return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;\n  }\n  resetOldProps() {\n    this.oldAsyncProps = null;\n    this.oldProps = this.component ? this.component.props : null;\n  }\n  // Checks if a prop is overridden\n  hasAsyncProp(propName) {\n    return propName in this.asyncProps;\n  }\n  // Returns value of an overriden prop\n  getAsyncProp(propName) {\n    const asyncProp = this.asyncProps[propName];\n    return asyncProp && asyncProp.resolvedValue;\n  }\n  isAsyncPropLoading(propName) {\n    if (propName) {\n      const asyncProp = this.asyncProps[propName];\n      return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);\n    }\n    for (const key in this.asyncProps) {\n      if (this.isAsyncPropLoading(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  // Without changing the original prop value, swap out the data resolution under the hood\n  reloadAsyncProp(propName, value) {\n    this._watchPromise(propName, Promise.resolve(value));\n  }\n  // Updates all async/overridden props (when new props come in)\n  // Checks if urls have changed, starts loading, or removes override\n  setAsyncProps(props) {\n    this.component = props[COMPONENT_SYMBOL] || this.component;\n    // NOTE: prop param and default values are only support for testing\n    const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};\n    const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;\n    const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};\n    // TODO - use async props from the layer's prop types\n    for (const propName in resolvedValues) {\n      const value = resolvedValues[propName];\n      this._createAsyncPropData(propName, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n      // Use transformed value\n      resolvedValues[propName] = this.getAsyncProp(propName);\n    }\n    for (const propName in originalValues) {\n      const value = originalValues[propName];\n      // Makes sure a record exists for this prop\n      this._createAsyncPropData(propName, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n    }\n  }\n  /* Placeholder methods for subclassing */\n  _fetch(propName, url) {\n    return null;\n  }\n  _onResolve(propName, value) {} // eslint-disable-line @typescript-eslint/no-empty-function\n  _onError(propName, error) {} // eslint-disable-line @typescript-eslint/no-empty-function\n  // Intercept strings (URLs) and Promises and activates loading and prop rewriting\n  _updateAsyncProp(propName, value) {\n    if (!this._didAsyncInputValueChange(propName, value)) {\n      return;\n    }\n    // interpret value string as url and start a new load tracked by a promise\n    if (typeof value === 'string') {\n      value = this._fetch(propName, value);\n    }\n    // interprets promise and track the \"loading\"\n    if (value instanceof Promise) {\n      this._watchPromise(propName, value);\n      return;\n    }\n    if (isAsyncIterable(value)) {\n      this._resolveAsyncIterable(propName, value); // eslint-disable-line @typescript-eslint/no-floating-promises\n      return;\n    }\n    // else, normal, non-async value. Just store value for now\n    this._setPropValue(propName, value);\n  }\n  // Whenever async props are changing, we need to make a copy of oldProps\n  // otherwise the prop rewriting will affect the value both in props and oldProps.\n  // While the copy is relatively expensive, this only happens on load completion.\n  _freezeAsyncOldProps() {\n    if (!this.oldAsyncProps && this.oldProps) {\n      // 1. inherit all synchronous props from oldProps\n      // 2. reconfigure the async prop descriptors to fixed values\n      this.oldAsyncProps = Object.create(this.oldProps);\n      for (const propName in this.asyncProps) {\n        Object.defineProperty(this.oldAsyncProps, propName, {\n          enumerable: true,\n          value: this.oldProps[propName]\n        });\n      }\n    }\n  }\n  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)\n  _didAsyncInputValueChange(propName, value) {\n    // @ts-ignore\n    const asyncProp = this.asyncProps[propName];\n    if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {\n      return false;\n    }\n    asyncProp.lastValue = value;\n    return true;\n  }\n  // Set normal, non-async value\n  _setPropValue(propName, value) {\n    // Save the current value before overwriting so that diffProps can access both\n    this._freezeAsyncOldProps();\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp) {\n      value = this._postProcessValue(asyncProp, value);\n      asyncProp.resolvedValue = value;\n      asyncProp.pendingLoadCount++;\n      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;\n    }\n  }\n  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously\n  _setAsyncPropValue(propName, value, loadCount) {\n    // Only update if loadCount is larger or equal to resolvedLoadCount\n    // otherwise a more recent load has already completed\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== undefined) {\n      // Save the current value before overwriting so that diffProps can access both\n      this._freezeAsyncOldProps();\n      asyncProp.resolvedValue = value;\n      asyncProp.resolvedLoadCount = loadCount;\n      // Call callback to inform listener\n      this.onAsyncPropUpdated(propName, value);\n    }\n  }\n  // Tracks a promise, sets the prop when loaded, handles load count\n  _watchPromise(propName, promise) {\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp) {\n      asyncProp.pendingLoadCount++;\n      const loadCount = asyncProp.pendingLoadCount;\n      promise.then(data => {\n        if (!this.component) {\n          // This component state has been finalized\n          return;\n        }\n        data = this._postProcessValue(asyncProp, data);\n        this._setAsyncPropValue(propName, data, loadCount);\n        this._onResolve(propName, data);\n      }).catch(error => {\n        this._onError(propName, error);\n      });\n    }\n  }\n  async _resolveAsyncIterable(propName, iterable) {\n    if (propName !== 'data') {\n      // we only support data as async iterable\n      this._setPropValue(propName, iterable);\n      return;\n    }\n    const asyncProp = this.asyncProps[propName];\n    if (!asyncProp) {\n      return;\n    }\n    asyncProp.pendingLoadCount++;\n    const loadCount = asyncProp.pendingLoadCount;\n    let data = [];\n    let count = 0;\n    for await (const chunk of iterable) {\n      if (!this.component) {\n        // This component state has been finalized\n        return;\n      }\n      // @ts-expect-error (2339) dataTransform is not decared in base component props\n      const {\n        dataTransform\n      } = this.component.props;\n      if (dataTransform) {\n        data = dataTransform(chunk, data);\n      } else {\n        data = data.concat(chunk);\n      }\n      // Used by the default _dataDiff function\n      Object.defineProperty(data, '__diff', {\n        enumerable: false,\n        value: [{\n          startRow: count,\n          endRow: data.length\n        }]\n      });\n      count = data.length;\n      this._setAsyncPropValue(propName, data, loadCount);\n    }\n    this._onResolve(propName, data);\n  }\n  // Give the app a chance to post process the loaded data\n  _postProcessValue(asyncProp, value) {\n    const propType = asyncProp.type;\n    if (propType && this.component) {\n      if (propType.release) {\n        propType.release(asyncProp.resolvedValue, propType, this.component);\n      }\n      if (propType.transform) {\n        return propType.transform(value, propType, this.component);\n      }\n    }\n    return value;\n  }\n  // Creating an asyncProp record if needed\n  _createAsyncPropData(propName, defaultValue) {\n    const asyncProp = this.asyncProps[propName];\n    if (!asyncProp) {\n      const propTypes = this.component && this.component.props[PROP_TYPES_SYMBOL];\n      // assert(defaultValue !== undefined);\n      this.asyncProps[propName] = {\n        type: propTypes && propTypes[propName],\n        lastValue: null,\n        resolvedValue: defaultValue,\n        pendingLoadCount: 0,\n        resolvedLoadCount: 0\n      };\n    }\n  }\n}","map":{"version":3,"names":["isAsyncIterable","COMPONENT_SYMBOL","PROP_TYPES_SYMBOL","ASYNC_ORIGINAL_SYMBOL","ASYNC_RESOLVED_SYMBOL","ASYNC_DEFAULTS_SYMBOL","EMPTY_PROPS","Object","freeze","ComponentState","constructor","component","asyncProps","onAsyncPropUpdated","oldProps","oldAsyncProps","finalize","propName","asyncProp","type","release","resolvedValue","resetOldProps","getOldProps","props","hasAsyncProp","getAsyncProp","isAsyncPropLoading","Boolean","pendingLoadCount","resolvedLoadCount","key","reloadAsyncProp","value","_watchPromise","Promise","resolve","setAsyncProps","resolvedValues","originalValues","defaultValues","_createAsyncPropData","_updateAsyncProp","_fetch","url","_onResolve","_onError","error","_didAsyncInputValueChange","_resolveAsyncIterable","_setPropValue","_freezeAsyncOldProps","create","defineProperty","enumerable","lastValue","_postProcessValue","_setAsyncPropValue","loadCount","undefined","promise","then","data","catch","iterable","count","chunk","dataTransform","concat","startRow","endRow","length","propType","transform","defaultValue","propTypes"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\lifecycle\\component-state.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {isAsyncIterable} from '../utils/iterable-utils';\nimport {\n  COMPONENT_SYMBOL,\n  PROP_TYPES_SYMBOL,\n  ASYNC_ORIGINAL_SYMBOL,\n  ASYNC_RESOLVED_SYMBOL,\n  ASYNC_DEFAULTS_SYMBOL\n} from './constants';\nimport type Component from './component';\nimport {PropType} from './prop-types';\n\nconst EMPTY_PROPS = Object.freeze({});\n\n/** Internal state of an async prop */\ntype AsyncPropState = {\n  /** The prop type definition from component.defaultProps, if exists */\n  type: PropType | null;\n  /** Supplied prop value (can be url/promise, not visible to the component) */\n  lastValue: any;\n  /** Resolved prop value (valid data, can be \"shown\" to the component) */\n  resolvedValue: any;\n  /** How many loads have been issued */\n  pendingLoadCount: number;\n  /** Latest resolved load, (earlier loads will be ignored) */\n  resolvedLoadCount: number;\n};\n\nexport default class ComponentState<ComponentT extends Component> {\n  /** The component that this state instance belongs to. `null` if this state has been finalized. */\n  component: ComponentT | null;\n  onAsyncPropUpdated: (propName: string, value: any) => void;\n\n  private asyncProps: Partial<Record<string, AsyncPropState>>;\n  private oldProps: ComponentT['props'] | null;\n  private oldAsyncProps: ComponentT['props'] | null;\n\n  constructor(component: ComponentT) {\n    this.component = component;\n    this.asyncProps = {}; // Prop values that the layer sees\n    this.onAsyncPropUpdated = () => {};\n    this.oldProps = null; // Last props before update\n    this.oldAsyncProps = null; // Last props before update, with async values copied.\n  }\n\n  finalize() {\n    for (const propName in this.asyncProps) {\n      const asyncProp = this.asyncProps[propName];\n      if (asyncProp && asyncProp.type && asyncProp.type.release) {\n        // Release any resources created by transforms\n        asyncProp.type.release(\n          asyncProp.resolvedValue,\n          asyncProp.type,\n          this.component as Component\n        );\n      }\n    }\n    this.asyncProps = {};\n    this.component = null;\n    this.resetOldProps();\n  }\n\n  /* Layer-facing props API */\n\n  getOldProps(): ComponentT['props'] | typeof EMPTY_PROPS {\n    return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;\n  }\n\n  resetOldProps() {\n    this.oldAsyncProps = null;\n    this.oldProps = this.component ? this.component.props : null;\n  }\n\n  // Checks if a prop is overridden\n  hasAsyncProp(propName: string): boolean {\n    return propName in this.asyncProps;\n  }\n\n  // Returns value of an overriden prop\n  getAsyncProp(propName: string): any {\n    const asyncProp = this.asyncProps[propName];\n    return asyncProp && asyncProp.resolvedValue;\n  }\n\n  isAsyncPropLoading(propName?: string): boolean {\n    if (propName) {\n      const asyncProp = this.asyncProps[propName];\n      return Boolean(\n        asyncProp &&\n          asyncProp.pendingLoadCount > 0 &&\n          asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount\n      );\n    }\n    for (const key in this.asyncProps) {\n      if (this.isAsyncPropLoading(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Without changing the original prop value, swap out the data resolution under the hood\n  reloadAsyncProp(propName: string, value: any) {\n    this._watchPromise(propName, Promise.resolve(value));\n  }\n\n  // Updates all async/overridden props (when new props come in)\n  // Checks if urls have changed, starts loading, or removes override\n  setAsyncProps(props: ComponentT['props']) {\n    this.component = (props[COMPONENT_SYMBOL] as ComponentT) || this.component;\n\n    // NOTE: prop param and default values are only support for testing\n    const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};\n    const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;\n    const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};\n\n    // TODO - use async props from the layer's prop types\n    for (const propName in resolvedValues) {\n      const value = resolvedValues[propName];\n      this._createAsyncPropData(propName, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n      // Use transformed value\n      resolvedValues[propName] = this.getAsyncProp(propName);\n    }\n\n    for (const propName in originalValues) {\n      const value = originalValues[propName];\n      // Makes sure a record exists for this prop\n      this._createAsyncPropData(propName, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n    }\n  }\n\n  /* Placeholder methods for subclassing */\n\n  protected _fetch(propName: string, url: string): any {\n    return null;\n  }\n\n  protected _onResolve(propName: string, value: any) {} // eslint-disable-line @typescript-eslint/no-empty-function\n\n  protected _onError(propName: string, error: Error) {} // eslint-disable-line @typescript-eslint/no-empty-function\n\n  // Intercept strings (URLs) and Promises and activates loading and prop rewriting\n  private _updateAsyncProp(propName: string, value: any) {\n    if (!this._didAsyncInputValueChange(propName, value)) {\n      return;\n    }\n\n    // interpret value string as url and start a new load tracked by a promise\n    if (typeof value === 'string') {\n      value = this._fetch(propName, value);\n    }\n\n    // interprets promise and track the \"loading\"\n    if (value instanceof Promise) {\n      this._watchPromise(propName, value);\n      return;\n    }\n\n    if (isAsyncIterable(value)) {\n      this._resolveAsyncIterable(propName, value); // eslint-disable-line @typescript-eslint/no-floating-promises\n      return;\n    }\n\n    // else, normal, non-async value. Just store value for now\n    this._setPropValue(propName, value);\n  }\n\n  // Whenever async props are changing, we need to make a copy of oldProps\n  // otherwise the prop rewriting will affect the value both in props and oldProps.\n  // While the copy is relatively expensive, this only happens on load completion.\n  private _freezeAsyncOldProps() {\n    if (!this.oldAsyncProps && this.oldProps) {\n      // 1. inherit all synchronous props from oldProps\n      // 2. reconfigure the async prop descriptors to fixed values\n      this.oldAsyncProps = Object.create(this.oldProps);\n      for (const propName in this.asyncProps) {\n        Object.defineProperty(this.oldAsyncProps, propName, {\n          enumerable: true,\n          value: this.oldProps[propName]\n        });\n      }\n    }\n  }\n\n  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)\n  private _didAsyncInputValueChange(propName: string, value: any): boolean {\n    // @ts-ignore\n    const asyncProp: AsyncPropState = this.asyncProps[propName];\n    if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {\n      return false;\n    }\n    asyncProp.lastValue = value;\n    return true;\n  }\n\n  // Set normal, non-async value\n  private _setPropValue(propName: string, value: any) {\n    // Save the current value before overwriting so that diffProps can access both\n    this._freezeAsyncOldProps();\n\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp) {\n      value = this._postProcessValue(asyncProp, value);\n      asyncProp.resolvedValue = value;\n      asyncProp.pendingLoadCount++;\n      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;\n    }\n  }\n\n  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously\n  private _setAsyncPropValue(propName: string, value: any, loadCount: number) {\n    // Only update if loadCount is larger or equal to resolvedLoadCount\n    // otherwise a more recent load has already completed\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== undefined) {\n      // Save the current value before overwriting so that diffProps can access both\n      this._freezeAsyncOldProps();\n\n      asyncProp.resolvedValue = value;\n      asyncProp.resolvedLoadCount = loadCount;\n\n      // Call callback to inform listener\n      this.onAsyncPropUpdated(propName, value);\n    }\n  }\n\n  // Tracks a promise, sets the prop when loaded, handles load count\n  private _watchPromise(propName: string, promise: Promise<any>) {\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp) {\n      asyncProp.pendingLoadCount++;\n      const loadCount = asyncProp.pendingLoadCount;\n      promise\n        .then(data => {\n          if (!this.component) {\n            // This component state has been finalized\n            return;\n          }\n          data = this._postProcessValue(asyncProp, data);\n          this._setAsyncPropValue(propName, data, loadCount);\n          this._onResolve(propName, data);\n        })\n        .catch(error => {\n          this._onError(propName, error);\n        });\n    }\n  }\n\n  private async _resolveAsyncIterable(\n    propName: string,\n    iterable: AsyncIterable<any>\n  ): Promise<void> {\n    if (propName !== 'data') {\n      // we only support data as async iterable\n      this._setPropValue(propName, iterable);\n      return;\n    }\n\n    const asyncProp = this.asyncProps[propName];\n    if (!asyncProp) {\n      return;\n    }\n\n    asyncProp.pendingLoadCount++;\n    const loadCount = asyncProp.pendingLoadCount;\n    let data: any[] = [];\n    let count = 0;\n\n    for await (const chunk of iterable) {\n      if (!this.component) {\n        // This component state has been finalized\n        return;\n      }\n\n      // @ts-expect-error (2339) dataTransform is not decared in base component props\n      const {dataTransform} = this.component.props;\n      if (dataTransform) {\n        data = dataTransform(chunk, data) as any[];\n      } else {\n        data = data.concat(chunk);\n      }\n\n      // Used by the default _dataDiff function\n      Object.defineProperty(data, '__diff', {\n        enumerable: false,\n        value: [{startRow: count, endRow: data.length}]\n      });\n\n      count = data.length;\n      this._setAsyncPropValue(propName, data, loadCount);\n    }\n\n    this._onResolve(propName, data);\n  }\n\n  // Give the app a chance to post process the loaded data\n  private _postProcessValue(asyncProp: AsyncPropState, value: any) {\n    const propType = asyncProp.type;\n    if (propType && this.component) {\n      if (propType.release) {\n        propType.release(asyncProp.resolvedValue, propType, this.component);\n      }\n      if (propType.transform) {\n        return propType.transform(value, propType, this.component);\n      }\n    }\n    return value;\n  }\n\n  // Creating an asyncProp record if needed\n  private _createAsyncPropData(propName: string, defaultValue: any) {\n    const asyncProp = this.asyncProps[propName];\n    if (!asyncProp) {\n      const propTypes = this.component && this.component.props[PROP_TYPES_SYMBOL];\n      // assert(defaultValue !== undefined);\n      this.asyncProps[propName] = {\n        type: propTypes && propTypes[propName],\n        lastValue: null,\n        resolvedValue: defaultValue,\n        pendingLoadCount: 0,\n        resolvedLoadCount: 0\n      };\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}