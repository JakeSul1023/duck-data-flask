{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst a = new Uint32Array([0x12345678]);\nconst b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\nconst isLittleEndian = !(b[0] === 0x12);\nconst LITTLE_ENDIAN_OS = isLittleEndian;\n/**\n * The basic string format consists of 3 characters:\n * 1. a character describing the byteorder of the data (<: little-endian, >: big-endian, |: not-relevant)\n * 2. a character code giving the basic type of the array\n * 3. an integer providing the number of bytes the type uses.\n * https://numpy.org/doc/stable/reference/arrays.interface.html\n *\n * Here I only include the second and third characters, and check endianness separately\n */\nconst DTYPES = {\n  u1: Uint8Array,\n  i1: Int8Array,\n  u2: Uint16Array,\n  i2: Int16Array,\n  u4: Uint32Array,\n  i4: Int32Array,\n  f4: Float32Array,\n  f8: Float64Array\n};\nexport function parseNPY(arrayBuffer, options) {\n  const view = new DataView(arrayBuffer);\n  const {\n    header,\n    headerEndOffset\n  } = parseHeader(view);\n  const numpyType = header.descr;\n  const ArrayType = DTYPES[numpyType.slice(1, 3)];\n  if (!ArrayType) {\n    throw new Error(`Unimplemented type ${numpyType}`);\n  }\n  const nArrayElements = header.shape?.reduce((a, b) => a * b);\n  const arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;\n  if (arrayBuffer.byteLength < headerEndOffset + arrayByteLength) {\n    throw new Error('Buffer overflow');\n  }\n  const data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));\n  // Swap endianness if needed\n  if (numpyType[0] === '>' && LITTLE_ENDIAN_OS || numpyType[0] === '<' && !LITTLE_ENDIAN_OS) {\n    throw new Error('Incorrect endianness');\n  }\n  return {\n    data,\n    header\n  };\n}\n/**\n * Parse NPY header\n *\n * @param  view\n * @return\n */\nfunction parseHeader(view) {\n  const majorVersion = view.getUint8(6);\n  // const minorVersion = view.getUint8(7);\n  let offset = 8;\n  let headerLength;\n  if (majorVersion >= 2) {\n    headerLength = view.getUint32(offset, true);\n    offset += 4;\n  } else {\n    headerLength = view.getUint16(offset, true);\n    offset += 2;\n  }\n  const encoding = majorVersion <= 2 ? 'latin1' : 'utf-8';\n  const decoder = new TextDecoder(encoding);\n  const headerArray = new Uint8Array(view.buffer, offset, headerLength);\n  const headerText = decoder.decode(headerArray);\n  offset += headerLength;\n  const header = JSON.parse(headerText.replace(/'/g, '\"').replace('False', 'false').replace('(', '[').replace(/,*\\),*/g, ']'));\n  return {\n    header,\n    headerEndOffset: offset\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}