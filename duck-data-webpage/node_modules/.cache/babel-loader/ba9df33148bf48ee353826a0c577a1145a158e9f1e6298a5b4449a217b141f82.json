{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\nimport { Vector3, toRadians, toDegrees, config } from '@math.gl/core';\nimport { WGS84_CONSTANTS } from \"./constants.js\";\nfunction identity(x) {\n  return x;\n}\nconst scratchVector = new Vector3();\nexport function fromCartographic(cartographic, result = [], map = identity) {\n  if ('longitude' in cartographic) {\n    result[0] = map(cartographic.longitude);\n    result[1] = map(cartographic.latitude);\n    result[2] = cartographic.height;\n  } else if ('x' in cartographic) {\n    result[0] = map(cartographic.x);\n    result[1] = map(cartographic.y);\n    result[2] = cartographic.z;\n  } else {\n    result[0] = map(cartographic[0]);\n    result[1] = map(cartographic[1]);\n    result[2] = cartographic[2];\n  }\n  return result;\n}\nexport function fromCartographicToRadians(cartographic, vector = []) {\n  return fromCartographic(cartographic, vector, config._cartographicRadians ? identity : toRadians);\n}\nexport function fromCartographicToDegrees(cartographic, vector = []) {\n  return fromCartographic(cartographic, vector, config._cartographicRadians ? toDegrees : identity);\n}\nexport function toCartographic(vector, cartographic, map = identity) {\n  if ('longitude' in cartographic) {\n    cartographic.longitude = map(vector[0]);\n    cartographic.latitude = map(vector[1]);\n    cartographic.height = vector[2];\n  } else if ('x' in cartographic) {\n    cartographic.x = map(vector[0]);\n    cartographic.y = map(vector[1]);\n    cartographic.z = vector[2];\n  } else {\n    cartographic[0] = map(vector[0]);\n    cartographic[1] = map(vector[1]);\n    cartographic[2] = vector[2];\n  }\n  return cartographic;\n}\nexport function toCartographicFromRadians(vector, cartographic) {\n  return toCartographic(vector, cartographic, config._cartographicRadians ? identity : toDegrees);\n}\nexport function toCartographicFromDegrees(vector, cartographic) {\n  return toCartographic(vector, cartographic, config._cartographicRadians ? toRadians : identity);\n}\n// Estimates if a vector is close to the surface of the WGS84 Ellipsoid\nexport function isWGS84(vector) {\n  if (!vector) {\n    return false;\n  }\n  scratchVector.from(vector);\n  const {\n    oneOverRadiiSquared,\n    centerToleranceSquared\n  } = WGS84_CONSTANTS;\n  const x2 = vector[0] * vector[0] * oneOverRadiiSquared[0];\n  const y2 = vector[1] * vector[1] * oneOverRadiiSquared[1];\n  const z2 = vector[2] * vector[2] * oneOverRadiiSquared[2];\n  return Math.abs(x2 + y2 + z2 - 1) < centerToleranceSquared;\n}\n/*\n\nexport function fromCartographic(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographic(cartographic: Cartographic, result: TypedArray): TypedArray;\nexport function fromCartographicToRadians(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToRadians(\n  cartographic: Cartographic,\n  result: TypedArray\n): TypedArray;\nexport function fromCartographicToDegrees(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToDegrees(\n  cartographic: Cartographic,\n  result: TypedArray\n): TypedArray;\n\nexport function toCartographic(vector: number[] | TypedArray, result: Cartographic): number[];\nexport function toCartographicFromRadians(\n  vector: number[] | TypedArray,\n  result: Cartographic\n): number[];\nexport function toCartographicFromDegrees(\n  vector: number[] | TypedArray,\n  result: Cartographic\n): number[];\n\n// Estimates if a vector is close to the surface of the WGS84 Ellipsoid\nexport function isWGS84(vector: number[] | TypedArray): boolean;\n*/","map":{"version":3,"names":["Vector3","toRadians","toDegrees","config","WGS84_CONSTANTS","identity","x","scratchVector","fromCartographic","cartographic","result","map","longitude","latitude","height","y","z","fromCartographicToRadians","vector","_cartographicRadians","fromCartographicToDegrees","toCartographic","toCartographicFromRadians","toCartographicFromDegrees","isWGS84","from","oneOverRadiiSquared","centerToleranceSquared","x2","y2","z2","Math","abs"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\geospatial\\src\\type-utils.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport type {NumericArray} from '@math.gl/core';\nimport {Vector3, toRadians, toDegrees, config} from '@math.gl/core';\nimport {WGS84_CONSTANTS} from './constants';\n\ntype LngLatHeightObject = {\n  longitude: number;\n  latitude: number;\n  height: number;\n};\n\ntype XYZObject = {\n  x: number;\n  y: number;\n  z: number;\n};\n\ntype Cartographic = LngLatHeightObject | XYZObject | NumericArray;\n\nfunction identity(x: number): number {\n  return x;\n}\n\nconst scratchVector = new Vector3();\n\nexport function fromCartographic(cartographic: Readonly<Cartographic>): number[];\nexport function fromCartographic<NumArrayT>(\n  cartographic: Readonly<Cartographic>,\n  result: NumArrayT,\n  map?: (x: number) => number\n): NumArrayT;\nexport function fromCartographic(\n  cartographic: Readonly<Cartographic>,\n  result = [] as number[],\n  map = identity\n): number[] {\n  if ('longitude' in cartographic) {\n    result[0] = map(cartographic.longitude);\n    result[1] = map(cartographic.latitude);\n    result[2] = cartographic.height;\n  } else if ('x' in cartographic) {\n    result[0] = map(cartographic.x);\n    result[1] = map(cartographic.y);\n    result[2] = cartographic.z;\n  } else {\n    result[0] = map(cartographic[0]);\n    result[1] = map(cartographic[1]);\n    result[2] = cartographic[2];\n  }\n  return result;\n}\n\nexport function fromCartographicToRadians(\n  cartographic: Readonly<Cartographic>,\n  result?: number[]\n): number[];\nexport function fromCartographicToRadians<TArray>(\n  cartographic: Readonly<Cartographic>,\n  result: TArray\n): TArray;\nexport function fromCartographicToRadians(\n  cartographic: Readonly<Cartographic>,\n  vector = [] as number[]\n): number[] {\n  return fromCartographic(cartographic, vector, config._cartographicRadians ? identity : toRadians);\n}\n\nexport function fromCartographicToDegrees(\n  cartographic: Readonly<Cartographic>,\n  result?: number[]\n): number[];\nexport function fromCartographicToDegrees<TArray>(\n  cartographic: Readonly<Cartographic>,\n  result: TArray\n): TArray;\nexport function fromCartographicToDegrees(\n  cartographic: Readonly<Cartographic>,\n  vector = [] as number[]\n): number[] {\n  return fromCartographic(cartographic, vector, config._cartographicRadians ? toDegrees : identity);\n}\n\nexport function toCartographic<T extends Cartographic>(\n  vector: Readonly<NumericArray>,\n  cartographic: T,\n  map: (x: number) => number = identity\n): T {\n  if ('longitude' in cartographic) {\n    cartographic.longitude = map(vector[0]);\n    cartographic.latitude = map(vector[1]);\n    cartographic.height = vector[2];\n  } else if ('x' in cartographic) {\n    cartographic.x = map(vector[0]);\n    cartographic.y = map(vector[1]);\n    cartographic.z = vector[2];\n  } else {\n    cartographic[0] = map(vector[0]);\n    cartographic[1] = map(vector[1]);\n    cartographic[2] = vector[2];\n  }\n  return cartographic;\n}\n\nexport function toCartographicFromRadians<T extends Cartographic>(\n  vector: Readonly<NumericArray>,\n  cartographic: T\n): T {\n  return toCartographic(vector, cartographic, config._cartographicRadians ? identity : toDegrees);\n}\n\nexport function toCartographicFromDegrees<T extends Cartographic>(\n  vector: Readonly<NumericArray>,\n  cartographic: T\n): T {\n  return toCartographic(vector, cartographic, config._cartographicRadians ? toRadians : identity);\n}\n\n// Estimates if a vector is close to the surface of the WGS84 Ellipsoid\nexport function isWGS84(vector: Readonly<NumericArray>): boolean {\n  if (!vector) {\n    return false;\n  }\n  scratchVector.from(vector);\n  const {oneOverRadiiSquared, centerToleranceSquared} = WGS84_CONSTANTS;\n  const x2 = vector[0] * vector[0] * oneOverRadiiSquared[0];\n  const y2 = vector[1] * vector[1] * oneOverRadiiSquared[1];\n  const z2 = vector[2] * vector[2] * oneOverRadiiSquared[2];\n  return Math.abs(x2 + y2 + z2 - 1) < centerToleranceSquared;\n}\n\n/*\n\nexport function fromCartographic(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographic(cartographic: Cartographic, result: TypedArray): TypedArray;\nexport function fromCartographicToRadians(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToRadians(\n  cartographic: Cartographic,\n  result: TypedArray\n): TypedArray;\nexport function fromCartographicToDegrees(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToDegrees(\n  cartographic: Cartographic,\n  result: TypedArray\n): TypedArray;\n\nexport function toCartographic(vector: number[] | TypedArray, result: Cartographic): number[];\nexport function toCartographicFromRadians(\n  vector: number[] | TypedArray,\n  result: Cartographic\n): number[];\nexport function toCartographicFromDegrees(\n  vector: number[] | TypedArray,\n  result: Cartographic\n): number[];\n\n// Estimates if a vector is close to the surface of the WGS84 Ellipsoid\nexport function isWGS84(vector: number[] | TypedArray): boolean;\n*/\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}