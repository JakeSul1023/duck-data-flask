{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport Controller from \"./controller.js\";\nimport ViewState from \"./view-state.js\";\nimport { mod } from \"../utils/math-utils.js\";\nimport LinearInterpolator from \"../transitions/linear-interpolator.js\";\nimport { Vector3, _SphericalCoordinates as SphericalCoordinates, clamp } from '@math.gl/core';\nconst MOVEMENT_SPEED = 20;\nconst PAN_SPEED = 500;\nclass FirstPersonState extends ViewState {\n  constructor(options) {\n    const {\n      /* Viewport arguments */\n      width,\n      // Width of viewport\n      height,\n      // Height of viewport\n      // Position and orientation\n      position = [0, 0, 0],\n      // typically in meters from anchor point\n      bearing = 0,\n      // Rotation around y axis\n      pitch = 0,\n      // Rotation around x axis\n      // Geospatial anchor\n      longitude = null,\n      latitude = null,\n      maxPitch = 90,\n      minPitch = -90,\n      // Model state when the rotate operation first started\n      startRotatePos,\n      startBearing,\n      startPitch,\n      startZoomPosition,\n      startPanPos,\n      startPanPosition\n    } = options;\n    super({\n      width,\n      height,\n      position,\n      bearing,\n      pitch,\n      longitude,\n      latitude,\n      maxPitch,\n      minPitch\n    }, {\n      startRotatePos,\n      startBearing,\n      startPitch,\n      startZoomPosition,\n      startPanPos,\n      startPanPosition\n    });\n    this.makeViewport = options.makeViewport;\n  }\n  /* Public API */\n  /**\n   * Start panning\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  panStart(_ref) {\n    let {\n      pos\n    } = _ref;\n    const {\n      position\n    } = this.getViewportProps();\n    return this._getUpdatedState({\n      startPanPos: pos,\n      startPanPosition: position\n    });\n  }\n  /**\n   * Pan\n   * @param {[Number, Number]} pos - position on screen where the pointer is\n   */\n  pan(_ref2) {\n    let {\n      pos\n    } = _ref2;\n    if (!pos) {\n      return this;\n    }\n    const {\n      startPanPos = [0, 0],\n      startPanPosition = [0, 0]\n    } = this.getState();\n    const {\n      width,\n      height,\n      bearing,\n      pitch\n    } = this.getViewportProps();\n    const deltaScaleX = PAN_SPEED * (pos[0] - startPanPos[0]) / width;\n    const deltaScaleY = PAN_SPEED * (pos[1] - startPanPos[1]) / height;\n    const up = new SphericalCoordinates({\n      bearing,\n      pitch\n    });\n    const forward = new SphericalCoordinates({\n      bearing,\n      pitch: -90\n    });\n    const yDirection = up.toVector3().normalize();\n    const xDirection = forward.toVector3().cross(yDirection).normalize();\n    return this._getUpdatedState({\n      position: new Vector3(startPanPosition).add(xDirection.scale(deltaScaleX)).add(yDirection.scale(deltaScaleY))\n    });\n  }\n  /**\n   * End panning\n   * Must call if `panStart()` was called\n   */\n  panEnd() {\n    return this._getUpdatedState({\n      startPanPos: null,\n      startPanPosition: null\n    });\n  }\n  /**\n   * Start rotating\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  rotateStart(_ref3) {\n    let {\n      pos\n    } = _ref3;\n    return this._getUpdatedState({\n      startRotatePos: pos,\n      startBearing: this.getViewportProps().bearing,\n      startPitch: this.getViewportProps().pitch\n    });\n  }\n  /**\n   * Rotate\n   * @param {[Number, Number]} pos - position on screen where the pointer is\n   */\n  rotate(_ref4) {\n    let {\n      pos,\n      deltaAngleX = 0,\n      deltaAngleY = 0\n    } = _ref4;\n    const {\n      startRotatePos,\n      startBearing,\n      startPitch\n    } = this.getState();\n    const {\n      width,\n      height\n    } = this.getViewportProps();\n    if (!startRotatePos || startBearing === undefined || startPitch === undefined) {\n      return this;\n    }\n    let newRotation;\n    if (pos) {\n      const deltaScaleX = (pos[0] - startRotatePos[0]) / width;\n      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;\n      newRotation = {\n        bearing: startBearing - deltaScaleX * 180,\n        pitch: startPitch - deltaScaleY * 90\n      };\n    } else {\n      newRotation = {\n        bearing: startBearing - deltaAngleX,\n        pitch: startPitch - deltaAngleY\n      };\n    }\n    return this._getUpdatedState(newRotation);\n  }\n  /**\n   * End rotating\n   * Must call if `rotateStart()` was called\n   */\n  rotateEnd() {\n    return this._getUpdatedState({\n      startRotatePos: null,\n      startBearing: null,\n      startPitch: null\n    });\n  }\n  /**\n   * Start zooming\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  zoomStart() {\n    return this._getUpdatedState({\n      startZoomPosition: this.getViewportProps().position\n    });\n  }\n  /**\n   * Zoom\n   * @param {[Number, Number]} pos - position on screen where the current center is\n   * @param {[Number, Number]} startPos - the center position at\n   *   the start of the operation. Must be supplied of `zoomStart()` was not called\n   * @param {Number} scale - a number between [0, 1] specifying the accumulated\n   *   relative scale.\n   */\n  zoom(_ref5) {\n    let {\n      pos,\n      scale\n    } = _ref5;\n    const viewportProps = this.getViewportProps();\n    const startZoomPosition = this.getState().startZoomPosition || viewportProps.position;\n    const viewport = this.makeViewport(viewportProps);\n    const {\n      projectionMatrix,\n      width\n    } = viewport;\n    const fovxRadians = 2.0 * Math.atan(1.0 / projectionMatrix[0]);\n    const angle = fovxRadians * (pos[0] / width - 0.5);\n    const direction = this.getDirection(true);\n    return this._move(direction.rotateZ({\n      radians: -angle\n    }), Math.log2(scale) * MOVEMENT_SPEED, startZoomPosition);\n  }\n  /**\n   * End zooming\n   * Must call if `zoomStart()` was called\n   */\n  zoomEnd() {\n    return this._getUpdatedState({\n      startZoomPosition: null\n    });\n  }\n  moveLeft() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MOVEMENT_SPEED;\n    const direction = this.getDirection(true);\n    return this._move(direction.rotateZ({\n      radians: Math.PI / 2\n    }), speed);\n  }\n  moveRight() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MOVEMENT_SPEED;\n    const direction = this.getDirection(true);\n    return this._move(direction.rotateZ({\n      radians: -Math.PI / 2\n    }), speed);\n  }\n  // forward\n  moveUp() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MOVEMENT_SPEED;\n    const direction = this.getDirection(true);\n    return this._move(direction, speed);\n  }\n  // backward\n  moveDown() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MOVEMENT_SPEED;\n    const direction = this.getDirection(true);\n    return this._move(direction.negate(), speed);\n  }\n  rotateLeft() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 15;\n    return this._getUpdatedState({\n      bearing: this.getViewportProps().bearing - speed\n    });\n  }\n  rotateRight() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 15;\n    return this._getUpdatedState({\n      bearing: this.getViewportProps().bearing + speed\n    });\n  }\n  rotateUp() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    return this._getUpdatedState({\n      pitch: this.getViewportProps().pitch + speed\n    });\n  }\n  rotateDown() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    return this._getUpdatedState({\n      pitch: this.getViewportProps().pitch - speed\n    });\n  }\n  zoomIn() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MOVEMENT_SPEED;\n    return this._move(new Vector3(0, 0, 1), speed);\n  }\n  zoomOut() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MOVEMENT_SPEED;\n    return this._move(new Vector3(0, 0, -1), speed);\n  }\n  // shortest path between two view states\n  shortestPathFrom(viewState) {\n    const fromProps = viewState.getViewportProps();\n    const props = {\n      ...this.getViewportProps()\n    };\n    const {\n      bearing,\n      longitude\n    } = props;\n    if (Math.abs(bearing - fromProps.bearing) > 180) {\n      props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;\n    }\n    if (longitude !== null && fromProps.longitude !== null && Math.abs(longitude - fromProps.longitude) > 180) {\n      props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;\n    }\n    return props;\n  }\n  /* Private methods */\n  _move(direction, speed) {\n    let fromPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.getViewportProps().position;\n    const delta = direction.scale(speed);\n    return this._getUpdatedState({\n      position: new Vector3(fromPosition).add(delta)\n    });\n  }\n  getDirection() {\n    let use2D = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const spherical = new SphericalCoordinates({\n      bearing: this.getViewportProps().bearing,\n      pitch: use2D ? 90 : 90 + this.getViewportProps().pitch\n    });\n    const direction = spherical.toVector3().normalize();\n    return direction;\n  }\n  _getUpdatedState(newProps) {\n    // Update _viewportProps\n    return new FirstPersonState({\n      makeViewport: this.makeViewport,\n      ...this.getViewportProps(),\n      ...this.getState(),\n      ...newProps\n    });\n  }\n  // Apply any constraints (mathematical or defined by _viewportProps) to map state\n  applyConstraints(props) {\n    // Ensure pitch and zoom are within specified range\n    const {\n      pitch,\n      maxPitch,\n      minPitch,\n      longitude,\n      bearing\n    } = props;\n    props.pitch = clamp(pitch, minPitch, maxPitch);\n    // Normalize degrees\n    if (longitude !== null && (longitude < -180 || longitude > 180)) {\n      props.longitude = mod(longitude + 180, 360) - 180;\n    }\n    if (bearing < -180 || bearing > 180) {\n      props.bearing = mod(bearing + 180, 360) - 180;\n    }\n    return props;\n  }\n}\nexport default class FirstPersonController extends Controller {\n  constructor() {\n    super(...arguments);\n    this.ControllerState = FirstPersonState;\n    this.transition = {\n      transitionDuration: 300,\n      transitionInterpolator: new LinearInterpolator(['position', 'pitch', 'bearing'])\n    };\n  }\n}\n//# sourceMappingURL=first-person-controller.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}