{"ast":null,"code":"/* eslint-disable camelcase */\nimport { getMeshBoundingBox } from '@loaders.gl/schema';\nimport { getDracoSchema } from \"./utils/get-draco-schema.js\";\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  // 7: BigInt64Array,\n  // 8: BigUint64Array,\n  9: Float32Array\n  // 10: Float64Array\n  // 11: BOOL - What array type do we use for this?\n};\nconst INDEX_ITEM_SIZE = 4;\nexport default class DracoParser {\n  draco;\n  decoder;\n  metadataQuerier;\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco) {\n    this.draco = draco;\n    this.decoder = new this.draco.Decoder();\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n  /**\n   * Destroy draco resources\n   */\n  destroy() {\n    this.draco.destroy(this.decoder);\n    this.draco.destroy(this.metadataQuerier);\n  }\n  /**\n   * NOTE: caller must call `destroyGeometry` on the return value after using it\n   * @param arrayBuffer\n   * @param options\n   */\n  parseSync(arrayBuffer, options = {}) {\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n    this._disableAttributeTransforms(options);\n    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n    const dracoGeometry = geometry_type === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();\n    try {\n      let dracoStatus;\n      switch (geometry_type) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry);\n          break;\n        case this.draco.POINT_CLOUD:\n          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          break;\n        default:\n          throw new Error('DRACO: Unknown geometry type.');\n      }\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n        // console.error(message);\n        throw new Error(message);\n      }\n      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n      const geometry = this._getMeshData(dracoGeometry, loaderData, options);\n      const boundingBox = getMeshBoundingBox(geometry.attributes);\n      const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);\n      const data = {\n        loader: 'draco',\n        loaderData,\n        header: {\n          vertexCount: dracoGeometry.num_points(),\n          boundingBox\n        },\n        ...geometry,\n        schema\n      };\n      return data;\n    } finally {\n      this.draco.destroy(buffer);\n      if (dracoGeometry) {\n        this.draco.destroy(dracoGeometry);\n      }\n    }\n  }\n  // Draco specific \"loader data\"\n  /**\n   * Extract\n   * @param dracoGeometry\n   * @param geometry_type\n   * @param options\n   * @returns\n   */\n  _getDracoLoaderData(dracoGeometry, geometry_type, options) {\n    const metadata = this._getTopLevelMetadata(dracoGeometry);\n    const attributes = this._getDracoAttributes(dracoGeometry, options);\n    return {\n      geometry_type,\n      num_attributes: dracoGeometry.num_attributes(),\n      num_points: dracoGeometry.num_points(),\n      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n      metadata,\n      attributes\n    };\n  }\n  /**\n   * Extract all draco provided information and metadata for each attribute\n   * @param dracoGeometry\n   * @param options\n   * @returns\n   */\n  _getDracoAttributes(dracoGeometry, options) {\n    const dracoAttributes = {};\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      // Note: Draco docs do not seem clear on `GetAttribute` ids just being a zero-based index,\n      // but it does seems to work this way\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n      dracoAttributes[dracoAttribute.unique_id()] = {\n        unique_id: dracoAttribute.unique_id(),\n        attribute_type: dracoAttribute.attribute_type(),\n        data_type: dracoAttribute.data_type(),\n        num_components: dracoAttribute.num_components(),\n        byte_offset: dracoAttribute.byte_offset(),\n        byte_stride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        attribute_index: attributeId,\n        metadata\n      };\n      // Add transformation parameters for any attributes app wants untransformed\n      const quantization = this._getQuantizationTransform(dracoAttribute, options);\n      if (quantization) {\n        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n      }\n      const octahedron = this._getOctahedronTransform(dracoAttribute, options);\n      if (octahedron) {\n        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n      }\n    }\n    return dracoAttributes;\n  }\n  /**\n   * Get standard loaders.gl mesh category data\n   * Extracts the geometry from draco\n   * @param dracoGeometry\n   * @param options\n   */\n  _getMeshData(dracoGeometry, loaderData, options) {\n    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n    const positionAttribute = attributes.POSITION;\n    if (!positionAttribute) {\n      throw new Error('DRACO: No position attribute found.');\n    }\n    // For meshes, we need indices to define the faces.\n    if (dracoGeometry instanceof this.draco.Mesh) {\n      switch (options.topology) {\n        case 'triangle-strip':\n          return {\n            topology: 'triangle-strip',\n            mode: 4,\n            // GL.TRIANGLES\n            attributes,\n            indices: {\n              value: this._getTriangleStripIndices(dracoGeometry),\n              size: 1\n            }\n          };\n        case 'triangle-list':\n        default:\n          return {\n            topology: 'triangle-list',\n            mode: 5,\n            // GL.TRIANGLE_STRIP\n            attributes,\n            indices: {\n              value: this._getTriangleListIndices(dracoGeometry),\n              size: 1\n            }\n          };\n      }\n    }\n    // PointCloud - must come last as Mesh inherits from PointCloud\n    return {\n      topology: 'point-list',\n      mode: 0,\n      // GL.POINTS\n      attributes\n    };\n  }\n  _getMeshAttributes(loaderData, dracoGeometry, options) {\n    const attributes = {};\n    for (const loaderAttribute of Object.values(loaderData.attributes)) {\n      const attributeName = this._deduceAttributeName(loaderAttribute, options);\n      loaderAttribute.name = attributeName;\n      const values = this._getAttributeValues(dracoGeometry, loaderAttribute);\n      if (values) {\n        const {\n          value,\n          size\n        } = values;\n        attributes[attributeName] = {\n          value,\n          size,\n          byteOffset: loaderAttribute.byte_offset,\n          byteStride: loaderAttribute.byte_stride,\n          normalized: loaderAttribute.normalized\n        };\n      }\n    }\n    return attributes;\n  }\n  // MESH INDICES EXTRACTION\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleListIndices(dracoGeometry) {\n    // Example on how to retrieve mesh and attributes.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * INDEX_ITEM_SIZE;\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n  }\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleStripIndices(dracoGeometry) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      /* const numStrips = */this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n      return getUint32Array(dracoArray);\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n  /**\n   *\n   * @param dracoGeometry\n   * @param dracoAttribute\n   * @param attributeName\n   */\n  _getAttributeValues(dracoGeometry, attribute) {\n    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n    if (!TypedArrayCtor) {\n      // eslint-disable-next-line no-console\n      console.warn(`DRACO: Unsupported attribute type ${attribute.data_type}`);\n      return null;\n    }\n    const numComponents = attribute.num_components;\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(this.draco, TypedArrayCtor);\n    let value;\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, dracoAttribute, dataType, byteLength, ptr);\n      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n    return {\n      value,\n      size: numComponents\n    };\n  }\n  // Attribute names\n  /**\n   * DRACO does not store attribute names - We need to deduce an attribute name\n   * for each attribute\n  _getAttributeNames(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: string} {\n    const attributeNames: {[unique_id: number]: string} = {};\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n      const attributeName = this._deduceAttributeName(dracoAttribute, options);\n      attributeNames[attributeName] = attributeName;\n    }\n    return attributeNames;\n  }\n   */\n  /**\n   * Deduce an attribute name.\n   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n   * types\n   * @param attributeData\n   */\n  _deduceAttributeName(attribute, options) {\n    // Deduce name based on application provided map\n    const uniqueId = attribute.unique_id;\n    for (const [attributeName, attributeUniqueId] of Object.entries(options.extraAttributes || {})) {\n      if (attributeUniqueId === uniqueId) {\n        return attributeName;\n      }\n    }\n    // Deduce name based on attribute type\n    const thisAttributeType = attribute.attribute_type;\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n      if (attributeType === thisAttributeType) {\n        // TODO - Return unique names if there multiple attributes per type\n        // (e.g. multiple TEX_COORDS or COLORS)\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n    // Look up in metadata\n    // TODO - shouldn't this have priority?\n    const entryName = options.attributeNameEntry || 'name';\n    if (attribute.metadata[entryName]) {\n      return attribute.metadata[entryName].string;\n    }\n    // Attribute of \"GENERIC\" type, we need to assign some name\n    return `CUSTOM_ATTRIBUTE_${uniqueId}`;\n  }\n  // METADATA EXTRACTION\n  /** Get top level metadata */\n  _getTopLevelMetadata(dracoGeometry) {\n    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n  /** Get per attribute metadata */\n  _getAttributeMetadata(dracoGeometry, attributeId) {\n    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n  /**\n   * Extract metadata field values\n   * @param dracoMetadata\n   * @returns\n   */\n  _getDracoMetadata(dracoMetadata) {\n    // The not so wonderful world of undocumented Draco APIs :(\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n    }\n    return result;\n  }\n  /**\n   * Extracts possible values for one metadata entry by name\n   * @param dracoMetadata\n   * @param entryName\n   */\n  _getDracoMetadataField(dracoMetadata, entryName) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      // Draco metadata fields can hold int32 arrays\n      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n      const intArray = getInt32Array(dracoArray);\n      return {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray\n      };\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)\n  /** Skip transforms for specific attribute types */\n  _disableAttributeTransforms(options) {\n    const {\n      quantizedAttributes = [],\n      octahedronAttributes = []\n    } = options;\n    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];\n    for (const dracoAttributeName of skipAttributes) {\n      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n    }\n  }\n  /**\n   * Extract (and apply?) Position Transform\n   * @todo not used\n   */\n  _getQuantizationTransform(dracoAttribute, options) {\n    const {\n      quantizedAttributes = []\n    } = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const skip = quantizedAttributes.map(type => this.decoder[type]).includes(attribute_type);\n    if (skip) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits(),\n            range: transform.range(),\n            min_values: new Float32Array([1, 2, 3]).map(i => transform.min_value(i))\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n  _getOctahedronTransform(dracoAttribute, options) {\n    const {\n      octahedronAttributes = []\n    } = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const octahedron = octahedronAttributes.map(type => this.decoder[type]).includes(attribute_type);\n    if (octahedron) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits()\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n}\n/**\n * Get draco specific data type by TypedArray constructor type\n * @param attributeType\n * @returns draco specific data type\n */\nfunction getDracoDataType(draco, attributeType) {\n  switch (attributeType) {\n    case Float32Array:\n      return draco.DT_FLOAT32;\n    case Int8Array:\n      return draco.DT_INT8;\n    case Int16Array:\n      return draco.DT_INT16;\n    case Int32Array:\n      return draco.DT_INT32;\n    case Uint8Array:\n      return draco.DT_UINT8;\n    case Uint16Array:\n      return draco.DT_UINT16;\n    case Uint32Array:\n      return draco.DT_UINT32;\n    default:\n      return draco.DT_INVALID;\n  }\n}\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getInt32Array(dracoArray) {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getUint32Array(dracoArray) {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}","map":{"version":3,"names":["getMeshBoundingBox","getDracoSchema","GEOMETRY_TYPE","TRIANGULAR_MESH","POINT_CLOUD","DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP","POSITION","NORMAL","COLOR","TEX_COORD","DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","INDEX_ITEM_SIZE","DracoParser","draco","decoder","metadataQuerier","constructor","Decoder","MetadataQuerier","destroy","parseSync","arrayBuffer","options","buffer","DecoderBuffer","Init","byteLength","_disableAttributeTransforms","geometry_type","GetEncodedGeometryType","dracoGeometry","Mesh","PointCloud","dracoStatus","DecodeBufferToMesh","DecodeBufferToPointCloud","Error","ok","ptr","message","error_msg","loaderData","_getDracoLoaderData","geometry","_getMeshData","boundingBox","attributes","schema","indices","data","loader","header","vertexCount","num_points","metadata","_getTopLevelMetadata","_getDracoAttributes","num_attributes","num_faces","dracoAttributes","attributeId","dracoAttribute","GetAttribute","_getAttributeMetadata","unique_id","attribute_type","data_type","num_components","byte_offset","byte_stride","normalized","attribute_index","quantization","_getQuantizationTransform","quantization_transform","octahedron","_getOctahedronTransform","octahedron_transform","_getMeshAttributes","positionAttribute","topology","mode","value","_getTriangleStripIndices","size","_getTriangleListIndices","loaderAttribute","Object","values","attributeName","_deduceAttributeName","name","_getAttributeValues","byteOffset","byteStride","numFaces","numIndices","_malloc","GetTrianglesUInt32Array","HEAPF32","slice","_free","dracoArray","DracoInt32Array","GetTriangleStripsFromMesh","getUint32Array","attribute","TypedArrayCtor","console","warn","numComponents","numPoints","numValues","BYTES_PER_ELEMENT","dataType","getDracoDataType","GetAttributeDataArrayForAllPoints","uniqueId","attributeUniqueId","entries","extraAttributes","thisAttributeType","dracoAttributeConstant","attributeType","entryName","attributeNameEntry","string","dracoMetadata","GetMetadata","_getDracoMetadata","GetAttributeMetadata","result","numEntries","NumEntries","entryIndex","GetEntryName","_getDracoMetadataField","GetIntEntryArray","intArray","getInt32Array","int","GetIntEntry","GetStringEntry","double","GetDoubleEntry","quantizedAttributes","octahedronAttributes","skipAttributes","dracoAttributeName","SkipAttributeTransform","skip","map","type","includes","transform","AttributeQuantizationTransform","InitFromAttribute","quantization_bits","range","min_values","i","min_value","DT_FLOAT32","DT_INT8","DT_INT16","DT_INT32","DT_UINT8","DT_UINT16","DT_UINT32","DT_INVALID","GetValue"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/draco/dist/lib/draco-parser.js"],"sourcesContent":["/* eslint-disable camelcase */\nimport { getMeshBoundingBox } from '@loaders.gl/schema';\nimport { getDracoSchema } from \"./utils/get-draco-schema.js\";\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst GEOMETRY_TYPE = {\n    TRIANGULAR_MESH: 0,\n    POINT_CLOUD: 1\n};\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n    POSITION: 'POSITION',\n    NORMAL: 'NORMAL',\n    COLOR: 'COLOR_0',\n    TEX_COORD: 'TEXCOORD_0'\n};\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n    1: Int8Array,\n    2: Uint8Array,\n    3: Int16Array,\n    4: Uint16Array,\n    5: Int32Array,\n    6: Uint32Array,\n    // 7: BigInt64Array,\n    // 8: BigUint64Array,\n    9: Float32Array\n    // 10: Float64Array\n    // 11: BOOL - What array type do we use for this?\n};\nconst INDEX_ITEM_SIZE = 4;\nexport default class DracoParser {\n    draco;\n    decoder;\n    metadataQuerier;\n    // draco - the draco decoder, either import `draco3d` or load dynamically\n    constructor(draco) {\n        this.draco = draco;\n        this.decoder = new this.draco.Decoder();\n        this.metadataQuerier = new this.draco.MetadataQuerier();\n    }\n    /**\n     * Destroy draco resources\n     */\n    destroy() {\n        this.draco.destroy(this.decoder);\n        this.draco.destroy(this.metadataQuerier);\n    }\n    /**\n     * NOTE: caller must call `destroyGeometry` on the return value after using it\n     * @param arrayBuffer\n     * @param options\n     */\n    parseSync(arrayBuffer, options = {}) {\n        const buffer = new this.draco.DecoderBuffer();\n        buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n        this._disableAttributeTransforms(options);\n        const geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n        const dracoGeometry = geometry_type === this.draco.TRIANGULAR_MESH\n            ? new this.draco.Mesh()\n            : new this.draco.PointCloud();\n        try {\n            let dracoStatus;\n            switch (geometry_type) {\n                case this.draco.TRIANGULAR_MESH:\n                    dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry);\n                    break;\n                case this.draco.POINT_CLOUD:\n                    dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n                    break;\n                default:\n                    throw new Error('DRACO: Unknown geometry type.');\n            }\n            if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n                const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n                // console.error(message);\n                throw new Error(message);\n            }\n            const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n            const geometry = this._getMeshData(dracoGeometry, loaderData, options);\n            const boundingBox = getMeshBoundingBox(geometry.attributes);\n            const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);\n            const data = {\n                loader: 'draco',\n                loaderData,\n                header: {\n                    vertexCount: dracoGeometry.num_points(),\n                    boundingBox\n                },\n                ...geometry,\n                schema\n            };\n            return data;\n        }\n        finally {\n            this.draco.destroy(buffer);\n            if (dracoGeometry) {\n                this.draco.destroy(dracoGeometry);\n            }\n        }\n    }\n    // Draco specific \"loader data\"\n    /**\n     * Extract\n     * @param dracoGeometry\n     * @param geometry_type\n     * @param options\n     * @returns\n     */\n    _getDracoLoaderData(dracoGeometry, geometry_type, options) {\n        const metadata = this._getTopLevelMetadata(dracoGeometry);\n        const attributes = this._getDracoAttributes(dracoGeometry, options);\n        return {\n            geometry_type,\n            num_attributes: dracoGeometry.num_attributes(),\n            num_points: dracoGeometry.num_points(),\n            num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n            metadata,\n            attributes\n        };\n    }\n    /**\n     * Extract all draco provided information and metadata for each attribute\n     * @param dracoGeometry\n     * @param options\n     * @returns\n     */\n    _getDracoAttributes(dracoGeometry, options) {\n        const dracoAttributes = {};\n        for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n            // Note: Draco docs do not seem clear on `GetAttribute` ids just being a zero-based index,\n            // but it does seems to work this way\n            const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n            const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n            dracoAttributes[dracoAttribute.unique_id()] = {\n                unique_id: dracoAttribute.unique_id(),\n                attribute_type: dracoAttribute.attribute_type(),\n                data_type: dracoAttribute.data_type(),\n                num_components: dracoAttribute.num_components(),\n                byte_offset: dracoAttribute.byte_offset(),\n                byte_stride: dracoAttribute.byte_stride(),\n                normalized: dracoAttribute.normalized(),\n                attribute_index: attributeId,\n                metadata\n            };\n            // Add transformation parameters for any attributes app wants untransformed\n            const quantization = this._getQuantizationTransform(dracoAttribute, options);\n            if (quantization) {\n                dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n            }\n            const octahedron = this._getOctahedronTransform(dracoAttribute, options);\n            if (octahedron) {\n                dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n            }\n        }\n        return dracoAttributes;\n    }\n    /**\n     * Get standard loaders.gl mesh category data\n     * Extracts the geometry from draco\n     * @param dracoGeometry\n     * @param options\n     */\n    _getMeshData(dracoGeometry, loaderData, options) {\n        const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n        const positionAttribute = attributes.POSITION;\n        if (!positionAttribute) {\n            throw new Error('DRACO: No position attribute found.');\n        }\n        // For meshes, we need indices to define the faces.\n        if (dracoGeometry instanceof this.draco.Mesh) {\n            switch (options.topology) {\n                case 'triangle-strip':\n                    return {\n                        topology: 'triangle-strip',\n                        mode: 4, // GL.TRIANGLES\n                        attributes,\n                        indices: {\n                            value: this._getTriangleStripIndices(dracoGeometry),\n                            size: 1\n                        }\n                    };\n                case 'triangle-list':\n                default:\n                    return {\n                        topology: 'triangle-list',\n                        mode: 5, // GL.TRIANGLE_STRIP\n                        attributes,\n                        indices: {\n                            value: this._getTriangleListIndices(dracoGeometry),\n                            size: 1\n                        }\n                    };\n            }\n        }\n        // PointCloud - must come last as Mesh inherits from PointCloud\n        return {\n            topology: 'point-list',\n            mode: 0, // GL.POINTS\n            attributes\n        };\n    }\n    _getMeshAttributes(loaderData, dracoGeometry, options) {\n        const attributes = {};\n        for (const loaderAttribute of Object.values(loaderData.attributes)) {\n            const attributeName = this._deduceAttributeName(loaderAttribute, options);\n            loaderAttribute.name = attributeName;\n            const values = this._getAttributeValues(dracoGeometry, loaderAttribute);\n            if (values) {\n                const { value, size } = values;\n                attributes[attributeName] = {\n                    value,\n                    size,\n                    byteOffset: loaderAttribute.byte_offset,\n                    byteStride: loaderAttribute.byte_stride,\n                    normalized: loaderAttribute.normalized\n                };\n            }\n        }\n        return attributes;\n    }\n    // MESH INDICES EXTRACTION\n    /**\n     * For meshes, we need indices to define the faces.\n     * @param dracoGeometry\n     */\n    _getTriangleListIndices(dracoGeometry) {\n        // Example on how to retrieve mesh and attributes.\n        const numFaces = dracoGeometry.num_faces();\n        const numIndices = numFaces * 3;\n        const byteLength = numIndices * INDEX_ITEM_SIZE;\n        const ptr = this.draco._malloc(byteLength);\n        try {\n            this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n            return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n        }\n        finally {\n            this.draco._free(ptr);\n        }\n    }\n    /**\n     * For meshes, we need indices to define the faces.\n     * @param dracoGeometry\n     */\n    _getTriangleStripIndices(dracoGeometry) {\n        const dracoArray = new this.draco.DracoInt32Array();\n        try {\n            /* const numStrips = */ this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n            return getUint32Array(dracoArray);\n        }\n        finally {\n            this.draco.destroy(dracoArray);\n        }\n    }\n    /**\n     *\n     * @param dracoGeometry\n     * @param dracoAttribute\n     * @param attributeName\n     */\n    _getAttributeValues(dracoGeometry, attribute) {\n        const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n        if (!TypedArrayCtor) {\n            // eslint-disable-next-line no-console\n            console.warn(`DRACO: Unsupported attribute type ${attribute.data_type}`);\n            return null;\n        }\n        const numComponents = attribute.num_components;\n        const numPoints = dracoGeometry.num_points();\n        const numValues = numPoints * numComponents;\n        const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n        const dataType = getDracoDataType(this.draco, TypedArrayCtor);\n        let value;\n        const ptr = this.draco._malloc(byteLength);\n        try {\n            const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n            this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, dracoAttribute, dataType, byteLength, ptr);\n            value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n        }\n        finally {\n            this.draco._free(ptr);\n        }\n        return { value, size: numComponents };\n    }\n    // Attribute names\n    /**\n     * DRACO does not store attribute names - We need to deduce an attribute name\n     * for each attribute\n    _getAttributeNames(\n      dracoGeometry: Mesh | PointCloud,\n      options: DracoParseOptions\n    ): {[unique_id: number]: string} {\n      const attributeNames: {[unique_id: number]: string} = {};\n      for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n        const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n        const attributeName = this._deduceAttributeName(dracoAttribute, options);\n        attributeNames[attributeName] = attributeName;\n      }\n      return attributeNames;\n    }\n     */\n    /**\n     * Deduce an attribute name.\n     * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n     * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n     * types\n     * @param attributeData\n     */\n    _deduceAttributeName(attribute, options) {\n        // Deduce name based on application provided map\n        const uniqueId = attribute.unique_id;\n        for (const [attributeName, attributeUniqueId] of Object.entries(options.extraAttributes || {})) {\n            if (attributeUniqueId === uniqueId) {\n                return attributeName;\n            }\n        }\n        // Deduce name based on attribute type\n        const thisAttributeType = attribute.attribute_type;\n        for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n            const attributeType = this.draco[dracoAttributeConstant];\n            if (attributeType === thisAttributeType) {\n                // TODO - Return unique names if there multiple attributes per type\n                // (e.g. multiple TEX_COORDS or COLORS)\n                return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n            }\n        }\n        // Look up in metadata\n        // TODO - shouldn't this have priority?\n        const entryName = options.attributeNameEntry || 'name';\n        if (attribute.metadata[entryName]) {\n            return attribute.metadata[entryName].string;\n        }\n        // Attribute of \"GENERIC\" type, we need to assign some name\n        return `CUSTOM_ATTRIBUTE_${uniqueId}`;\n    }\n    // METADATA EXTRACTION\n    /** Get top level metadata */\n    _getTopLevelMetadata(dracoGeometry) {\n        const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n        return this._getDracoMetadata(dracoMetadata);\n    }\n    /** Get per attribute metadata */\n    _getAttributeMetadata(dracoGeometry, attributeId) {\n        const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n        return this._getDracoMetadata(dracoMetadata);\n    }\n    /**\n     * Extract metadata field values\n     * @param dracoMetadata\n     * @returns\n     */\n    _getDracoMetadata(dracoMetadata) {\n        // The not so wonderful world of undocumented Draco APIs :(\n        if (!dracoMetadata || !dracoMetadata.ptr) {\n            return {};\n        }\n        const result = {};\n        const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n        for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n            const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n            result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n        }\n        return result;\n    }\n    /**\n     * Extracts possible values for one metadata entry by name\n     * @param dracoMetadata\n     * @param entryName\n     */\n    _getDracoMetadataField(dracoMetadata, entryName) {\n        const dracoArray = new this.draco.DracoInt32Array();\n        try {\n            // Draco metadata fields can hold int32 arrays\n            this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n            const intArray = getInt32Array(dracoArray);\n            return {\n                int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n                string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n                double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n                intArray\n            };\n        }\n        finally {\n            this.draco.destroy(dracoArray);\n        }\n    }\n    // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)\n    /** Skip transforms for specific attribute types */\n    _disableAttributeTransforms(options) {\n        const { quantizedAttributes = [], octahedronAttributes = [] } = options;\n        const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];\n        for (const dracoAttributeName of skipAttributes) {\n            this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n        }\n    }\n    /**\n     * Extract (and apply?) Position Transform\n     * @todo not used\n     */\n    _getQuantizationTransform(dracoAttribute, options) {\n        const { quantizedAttributes = [] } = options;\n        const attribute_type = dracoAttribute.attribute_type();\n        const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);\n        if (skip) {\n            const transform = new this.draco.AttributeQuantizationTransform();\n            try {\n                if (transform.InitFromAttribute(dracoAttribute)) {\n                    return {\n                        quantization_bits: transform.quantization_bits(),\n                        range: transform.range(),\n                        min_values: new Float32Array([1, 2, 3]).map((i) => transform.min_value(i))\n                    };\n                }\n            }\n            finally {\n                this.draco.destroy(transform);\n            }\n        }\n        return null;\n    }\n    _getOctahedronTransform(dracoAttribute, options) {\n        const { octahedronAttributes = [] } = options;\n        const attribute_type = dracoAttribute.attribute_type();\n        const octahedron = octahedronAttributes\n            .map((type) => this.decoder[type])\n            .includes(attribute_type);\n        if (octahedron) {\n            const transform = new this.draco.AttributeQuantizationTransform();\n            try {\n                if (transform.InitFromAttribute(dracoAttribute)) {\n                    return {\n                        quantization_bits: transform.quantization_bits()\n                    };\n                }\n            }\n            finally {\n                this.draco.destroy(transform);\n            }\n        }\n        return null;\n    }\n}\n/**\n * Get draco specific data type by TypedArray constructor type\n * @param attributeType\n * @returns draco specific data type\n */\nfunction getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n        case Float32Array:\n            return draco.DT_FLOAT32;\n        case Int8Array:\n            return draco.DT_INT8;\n        case Int16Array:\n            return draco.DT_INT16;\n        case Int32Array:\n            return draco.DT_INT32;\n        case Uint8Array:\n            return draco.DT_UINT8;\n        case Uint16Array:\n            return draco.DT_UINT16;\n        case Uint32Array:\n            return draco.DT_UINT32;\n        default:\n            return draco.DT_INVALID;\n    }\n}\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getInt32Array(dracoArray) {\n    const numValues = dracoArray.size();\n    const intArray = new Int32Array(numValues);\n    for (let i = 0; i < numValues; i++) {\n        intArray[i] = dracoArray.GetValue(i);\n    }\n    return intArray;\n}\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getUint32Array(dracoArray) {\n    const numValues = dracoArray.size();\n    const intArray = new Int32Array(numValues);\n    for (let i = 0; i < numValues; i++) {\n        intArray[i] = dracoArray.GetValue(i);\n    }\n    return intArray;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}