{"ast":null,"code":"// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\n/* eslint-disable camelcase */\nimport { sliceArrayBuffer, parseFromContext } from '@loaders.gl/loader-utils';\nimport { DracoLoader } from '@loaders.gl/draco';\nimport { GLTFScenegraph } from \"../api/gltf-scenegraph.js\";\nimport { getGLTFAccessors, getGLTFAccessor } from \"../gltf-utils/gltf-attribute-utils.js\";\nconst KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\n/** Extension name */\nexport const name = KHR_DRACO_MESH_COMPRESSION;\nexport function preprocess(gltfData, options, context) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      // TODO - Remove fallback accessors to make sure we don't load unnecessary buffers\n    }\n  }\n}\nexport async function decode(gltfData, options, context) {\n  if (!options?.gltf?.decompressMeshes) {\n    return;\n  }\n  const scenegraph = new GLTFScenegraph(gltfData);\n  const promises = [];\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      promises.push(decompressPrimitive(scenegraph, primitive, options, context));\n    }\n  }\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n  // We have now decompressed all primitives, so remove the top-level extension\n  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\nexport function encode(gltfData) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const scenegraph = new GLTFScenegraph(gltfData);\n  for (const mesh of scenegraph.json.meshes || []) {\n    // eslint-disable-next-line camelcase\n    // @ts-ignore\n    compressMesh(mesh, options);\n    // NOTE: Only add the extension if something was actually compressed\n    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n}\n// DECODE\n// Unpacks one mesh primitive and removes the extension from the primitive\n// DracoDecoder needs to be imported and registered by app\n// Returns: Promise that resolves when all pending draco decoder jobs for this mesh complete\n// TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\nasync function decompressPrimitive(scenegraph, primitive, options, context) {\n  const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n  if (!dracoExtension) {\n    return;\n  }\n  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);\n  // TODO - parse does not yet deal well with byte offsets embedded in typed arrays. Copy buffer\n  // TODO - remove when `parse` is fixed to handle `byteOffset`s\n  const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset); // , buffer.byteLength);\n  const dracoOptions = {\n    ...options\n  };\n  // TODO - remove hack: The entire tileset might be included, too expensive to serialize\n  delete dracoOptions['3d-tiles'];\n  const decodedData = await parseFromContext(bufferCopy, DracoLoader, dracoOptions, context);\n  const decodedAttributes = getGLTFAccessors(decodedData.attributes);\n  // Restore min/max values\n  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {\n    if (attributeName in primitive.attributes) {\n      const accessorIndex = primitive.attributes[attributeName];\n      const accessor = scenegraph.getAccessor(accessorIndex);\n      if (accessor?.min && accessor?.max) {\n        decodedAttribute.min = accessor.min;\n        decodedAttribute.max = accessor.max;\n      }\n    }\n  }\n  // @ts-ignore\n  primitive.attributes = decodedAttributes;\n  if (decodedData.indices) {\n    // @ts-ignore\n    primitive.indices = getGLTFAccessor(decodedData.indices);\n  }\n  // Extension has been processed, delete it\n  scenegraph.removeObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n  checkPrimitive(primitive);\n}\n// ENCODE\n// eslint-disable-next-line max-len\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\nfunction compressMesh(attributes, indices) {\n  let mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;\n  let options = arguments.length > 3 ? arguments[3] : undefined;\n  let context = arguments.length > 4 ? arguments[4] : undefined;\n  if (!options.DracoWriter) {\n    throw new Error('options.gltf.DracoWriter not provided');\n  }\n  // TODO - use DracoWriter using encode w/ registered DracoWriter...\n  const compressedData = options.DracoWriter.encodeSync({\n    attributes\n  });\n  // Draco compression may change the order and number of vertices in a mesh.\n  // To satisfy the requirement that accessors properties be correct for both\n  // compressed and uncompressed data, generators should create uncompressed\n  // attributes and indices using data that has been decompressed from the Draco buffer,\n  // rather than the original source data.\n  // @ts-ignore TODO this needs to be fixed\n  const decodedData = context?.parseSync?.({\n    attributes\n  });\n  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n  const bufferViewIndex = options.addBufferView(compressedData);\n  const glTFMesh = {\n    primitives: [{\n      attributes: fauxAccessors,\n      // TODO - verify with spec\n      mode,\n      // GL.POINTS\n      extensions: {\n        [KHR_DRACO_MESH_COMPRESSION]: {\n          bufferView: bufferViewIndex,\n          attributes: fauxAccessors // TODO - verify with spec\n        }\n      }\n    }]\n  };\n  return glTFMesh;\n}\n// UTILS\nfunction checkPrimitive(primitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('glTF: Empty primitive detected: Draco decompression failure?');\n  }\n}\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n  for (const mesh of scenegraph.json.meshes || []) {\n    for (const primitive of mesh.primitives) {\n      yield primitive;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}