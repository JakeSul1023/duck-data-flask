{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getDataTypeFromArray, getDataTypeFromValue } from \"./data-type.js\";\n/**\n * SCHEMA SUPPORT - AUTODEDUCTION\n * @param {*} table\n * @param {*} schema\n * @returns\n */\nexport function deduceTableSchema(table) {\n  switch (table.shape) {\n    case 'array-row-table':\n    case 'object-row-table':\n      return deduceSchemaFromRows(table.data);\n    case 'geojson-table':\n      return deduceSchemaFromGeoJSON(table.features);\n    case 'columnar-table':\n      return deduceSchemaFromColumns(table.data);\n    case 'arrow-table':\n    default:\n      throw new Error('Deduce schema');\n  }\n}\nexport function deduceSchema(data) {\n  return Array.isArray(data) ? deduceSchemaFromRows(data) : deduceSchemaFromColumns(data);\n}\n/** Given an object with columnar arrays, try to deduce a schema */\nfunction deduceSchemaFromColumns(columnarTable) {\n  const fields = [];\n  for (const [columnName, column] of Object.entries(columnarTable)) {\n    const field = deduceFieldFromColumn(column, columnName);\n    fields.push(field);\n  }\n  return {\n    fields,\n    metadata: {}\n  };\n}\n/** Given an array of rows, try to deduce a schema */\nfunction deduceSchemaFromRows(rowTable) {\n  if (!rowTable.length) {\n    throw new Error('deduce from empty table');\n  }\n  const fields = [];\n  const row0 = rowTable[0];\n  // TODO - fields can be nullable, false detection...\n  // Could look at additional rows if nulls in first row\n  // TODO - if array, column names will be numbers\n  for (const [columnName, value] of Object.entries(row0)) {\n    fields.push(deduceFieldFromValue(value, columnName));\n  }\n  return {\n    fields,\n    metadata: {}\n  };\n}\n/** Given a GeoJSON, try to deduce a schema */\nfunction deduceSchemaFromGeoJSON(features) {\n  if (!features.length) {\n    throw new Error('deduce from empty table');\n  }\n  const fields = [];\n  const row0 = features[0].properties || {};\n  // TODO - fields can be nullable, false detection...\n  // Could look at additional rows if nulls in first row\n  // TODO - if array, column names will be numbers\n  for (const [columnName, value] of Object.entries(row0)) {\n    fields.push(deduceFieldFromValue(value, columnName));\n  }\n  return {\n    fields,\n    metadata: {}\n  };\n}\n/** Given a column (i.e. array), attempt to deduce an appropriate `Field` */\nfunction deduceFieldFromColumn(column, name) {\n  if (ArrayBuffer.isView(column)) {\n    const type = getDataTypeFromArray(column);\n    return {\n      name,\n      type: type.type || 'null',\n      nullable: type.nullable\n      // metadata: {}\n    };\n  }\n  if (Array.isArray(column) && column.length > 0) {\n    const value = column[0];\n    const type = getDataTypeFromValue(value);\n    // TODO - support nested schemas?\n    return {\n      name,\n      type,\n      nullable: true\n      // metadata: {},\n    };\n  }\n  throw new Error('empty table');\n}\n/** Given a value, attempt to deduce an appropriate `Field` */\nfunction deduceFieldFromValue(value, name) {\n  const type = getDataTypeFromValue(value);\n  return {\n    name,\n    type,\n    nullable: true\n    // metadata: {}\n  };\n}","map":{"version":3,"names":["getDataTypeFromArray","getDataTypeFromValue","deduceTableSchema","table","shape","deduceSchemaFromRows","data","deduceSchemaFromGeoJSON","features","deduceSchemaFromColumns","Error","deduceSchema","Array","isArray","columnarTable","fields","columnName","column","Object","entries","field","deduceFieldFromColumn","push","metadata","rowTable","length","row0","value","deduceFieldFromValue","properties","name","ArrayBuffer","isView","type","nullable"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/schema/dist/lib/table/simple-table/table-schema.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getDataTypeFromArray, getDataTypeFromValue } from \"./data-type.js\";\n/**\n * SCHEMA SUPPORT - AUTODEDUCTION\n * @param {*} table\n * @param {*} schema\n * @returns\n */\nexport function deduceTableSchema(table) {\n    switch (table.shape) {\n        case 'array-row-table':\n        case 'object-row-table':\n            return deduceSchemaFromRows(table.data);\n        case 'geojson-table':\n            return deduceSchemaFromGeoJSON(table.features);\n        case 'columnar-table':\n            return deduceSchemaFromColumns(table.data);\n        case 'arrow-table':\n        default:\n            throw new Error('Deduce schema');\n    }\n}\nexport function deduceSchema(data) {\n    return Array.isArray(data) ? deduceSchemaFromRows(data) : deduceSchemaFromColumns(data);\n}\n/** Given an object with columnar arrays, try to deduce a schema */\nfunction deduceSchemaFromColumns(columnarTable) {\n    const fields = [];\n    for (const [columnName, column] of Object.entries(columnarTable)) {\n        const field = deduceFieldFromColumn(column, columnName);\n        fields.push(field);\n    }\n    return { fields, metadata: {} };\n}\n/** Given an array of rows, try to deduce a schema */\nfunction deduceSchemaFromRows(rowTable) {\n    if (!rowTable.length) {\n        throw new Error('deduce from empty table');\n    }\n    const fields = [];\n    const row0 = rowTable[0];\n    // TODO - fields can be nullable, false detection...\n    // Could look at additional rows if nulls in first row\n    // TODO - if array, column names will be numbers\n    for (const [columnName, value] of Object.entries(row0)) {\n        fields.push(deduceFieldFromValue(value, columnName));\n    }\n    return { fields, metadata: {} };\n}\n/** Given a GeoJSON, try to deduce a schema */\nfunction deduceSchemaFromGeoJSON(features) {\n    if (!features.length) {\n        throw new Error('deduce from empty table');\n    }\n    const fields = [];\n    const row0 = features[0].properties || {};\n    // TODO - fields can be nullable, false detection...\n    // Could look at additional rows if nulls in first row\n    // TODO - if array, column names will be numbers\n    for (const [columnName, value] of Object.entries(row0)) {\n        fields.push(deduceFieldFromValue(value, columnName));\n    }\n    return { fields, metadata: {} };\n}\n/** Given a column (i.e. array), attempt to deduce an appropriate `Field` */\nfunction deduceFieldFromColumn(column, name) {\n    if (ArrayBuffer.isView(column)) {\n        const type = getDataTypeFromArray(column);\n        return {\n            name,\n            type: type.type || 'null',\n            nullable: type.nullable\n            // metadata: {}\n        };\n    }\n    if (Array.isArray(column) && column.length > 0) {\n        const value = column[0];\n        const type = getDataTypeFromValue(value);\n        // TODO - support nested schemas?\n        return {\n            name,\n            type,\n            nullable: true\n            // metadata: {},\n        };\n    }\n    throw new Error('empty table');\n}\n/** Given a value, attempt to deduce an appropriate `Field` */\nfunction deduceFieldFromValue(value, name) {\n    const type = getDataTypeFromValue(value);\n    return {\n        name,\n        type,\n        nullable: true\n        // metadata: {}\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}