{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// TRANSPILATION TABLES\n/**\n * Transpiles GLSL 3.00 shader source code to target GLSL version (3.00 or 1.00)\n *\n * @note We always run transpiler even if same version e.g. 3.00 => 3.00\n * @note For texture sampling transpilation, apps need to use non-standard texture* calls in GLSL 3.00 source\n * RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md\n */\nexport function transpileGLSLShader(source, stage) {\n  const sourceGLSLVersion = Number(source.match(/^#version[ \\t]+(\\d+)/m)?.[1] || 100);\n  if (sourceGLSLVersion !== 300) {\n    // TODO - we splurge on a longer error message to help deck.gl custom layer developers\n    throw new Error('luma.gl v9 only supports GLSL 3.00 shader sources');\n  }\n  switch (stage) {\n    case 'vertex':\n      source = convertShader(source, ES300_VERTEX_REPLACEMENTS);\n      return source;\n    case 'fragment':\n      source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);\n      return source;\n    default:\n      // Unknown shader stage\n      throw new Error(stage);\n  }\n}\n/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */\nconst ES300_REPLACEMENTS = [\n// Fix poorly formatted version directive\n[/^(#version[ \\t]+(100|300[ \\t]+es))?[ \\t]*\\n/, '#version 300 es\\n'],\n// The individual `texture...()` functions were replaced with `texture()` overloads\n[/\\btexture(2D|2DProj|Cube)Lod(EXT)?\\(/g, 'textureLod('], [/\\btexture(2D|2DProj|Cube)(EXT)?\\(/g, 'texture(']];\nconst ES300_VERTEX_REPLACEMENTS = [...ES300_REPLACEMENTS,\n// `attribute` keyword replaced with `in`\n[makeVariableTextRegExp('attribute'), 'in $1'],\n// `varying` keyword replaced with `out`\n[makeVariableTextRegExp('varying'), 'out $1']];\n/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */\nconst ES300_FRAGMENT_REPLACEMENTS = [...ES300_REPLACEMENTS,\n// `varying` keyword replaced with `in`\n[makeVariableTextRegExp('varying'), 'in $1']];\nfunction convertShader(source, replacements) {\n  for (const [pattern, replacement] of replacements) {\n    source = source.replace(pattern, replacement);\n  }\n  return source;\n}\n/**\n * Creates a regexp that tests for a specific variable type\n * @example\n *   should match:\n *     in float weight;\n *     out vec4 positions[2];\n *   should not match:\n *     void f(out float a, in float b) {}\n */\nfunction makeVariableTextRegExp(qualifier) {\n  return new RegExp(`\\\\b${qualifier}[ \\\\t]+(\\\\w+[ \\\\t]+\\\\w+(\\\\[\\\\w+\\\\])?;)`, 'g');\n}","map":{"version":3,"names":["transpileGLSLShader","source","stage","sourceGLSLVersion","Number","match","Error","convertShader","ES300_VERTEX_REPLACEMENTS","ES300_FRAGMENT_REPLACEMENTS","ES300_REPLACEMENTS","makeVariableTextRegExp","replacements","pattern","replacement","replace","qualifier","RegExp"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\shadertools\\src\\lib\\shader-transpiler\\transpile-glsl-shader.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// TRANSPILATION TABLES\n\n/**\n * Transpiles GLSL 3.00 shader source code to target GLSL version (3.00 or 1.00)\n *\n * @note We always run transpiler even if same version e.g. 3.00 => 3.00\n * @note For texture sampling transpilation, apps need to use non-standard texture* calls in GLSL 3.00 source\n * RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md\n */\nexport function transpileGLSLShader(source: string, stage: 'vertex' | 'fragment'): string {\n  const sourceGLSLVersion = Number(source.match(/^#version[ \\t]+(\\d+)/m)?.[1] || 100);\n  if (sourceGLSLVersion !== 300) {\n    // TODO - we splurge on a longer error message to help deck.gl custom layer developers\n    throw new Error('luma.gl v9 only supports GLSL 3.00 shader sources');\n  }\n\n  switch (stage) {\n    case 'vertex':\n      source = convertShader(source, ES300_VERTEX_REPLACEMENTS);\n      return source;\n    case 'fragment':\n      source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);\n      return source;\n    default:\n      // Unknown shader stage\n      throw new Error(stage);\n  }\n}\n\ntype GLSLReplacement = [RegExp, string];\n\n/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */\nconst ES300_REPLACEMENTS: GLSLReplacement[] = [\n  // Fix poorly formatted version directive\n  [/^(#version[ \\t]+(100|300[ \\t]+es))?[ \\t]*\\n/, '#version 300 es\\n'],\n  // The individual `texture...()` functions were replaced with `texture()` overloads\n  [/\\btexture(2D|2DProj|Cube)Lod(EXT)?\\(/g, 'textureLod('],\n  [/\\btexture(2D|2DProj|Cube)(EXT)?\\(/g, 'texture(']\n];\n\nconst ES300_VERTEX_REPLACEMENTS: GLSLReplacement[] = [\n  ...ES300_REPLACEMENTS,\n  // `attribute` keyword replaced with `in`\n  [makeVariableTextRegExp('attribute'), 'in $1'],\n  // `varying` keyword replaced with `out`\n  [makeVariableTextRegExp('varying'), 'out $1']\n];\n\n/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */\nconst ES300_FRAGMENT_REPLACEMENTS: GLSLReplacement[] = [\n  ...ES300_REPLACEMENTS,\n  // `varying` keyword replaced with `in`\n  [makeVariableTextRegExp('varying'), 'in $1']\n];\n\nfunction convertShader(source: string, replacements: GLSLReplacement[]) {\n  for (const [pattern, replacement] of replacements) {\n    source = source.replace(pattern, replacement);\n  }\n  return source;\n}\n\n/**\n * Creates a regexp that tests for a specific variable type\n * @example\n *   should match:\n *     in float weight;\n *     out vec4 positions[2];\n *   should not match:\n *     void f(out float a, in float b) {}\n */\nfunction makeVariableTextRegExp(qualifier: 'attribute' | 'varying' | 'in' | 'out'): RegExp {\n  return new RegExp(`\\\\b${qualifier}[ \\\\t]+(\\\\w+[ \\\\t]+\\\\w+(\\\\[\\\\w+\\\\])?;)`, 'g');\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA;AAEA;;;;;;;AAOA,OAAM,SAAUA,mBAAmBA,CAACC,MAAc,EAAEC,KAA4B;EAC9E,MAAMC,iBAAiB,GAAGC,MAAM,CAACH,MAAM,CAACI,KAAK,CAAC,uBAAuB,CAAC,GAAG,CAAC,CAAC,IAAI,GAAG,CAAC;EACnF,IAAIF,iBAAiB,KAAK,GAAG,EAAE;IAC7B;IACA,MAAM,IAAIG,KAAK,CAAC,mDAAmD,CAAC;EACtE;EAEA,QAAQJ,KAAK;IACX,KAAK,QAAQ;MACXD,MAAM,GAAGM,aAAa,CAACN,MAAM,EAAEO,yBAAyB,CAAC;MACzD,OAAOP,MAAM;IACf,KAAK,UAAU;MACbA,MAAM,GAAGM,aAAa,CAACN,MAAM,EAAEQ,2BAA2B,CAAC;MAC3D,OAAOR,MAAM;IACf;MACE;MACA,MAAM,IAAIK,KAAK,CAACJ,KAAK,CAAC;EAC1B;AACF;AAIA;AACA,MAAMQ,kBAAkB,GAAsB;AAC5C;AACA,CAAC,6CAA6C,EAAE,mBAAmB,CAAC;AACpE;AACA,CAAC,uCAAuC,EAAE,aAAa,CAAC,EACxD,CAAC,oCAAoC,EAAE,UAAU,CAAC,CACnD;AAED,MAAMF,yBAAyB,GAAsB,CACnD,GAAGE,kBAAkB;AACrB;AACA,CAACC,sBAAsB,CAAC,WAAW,CAAC,EAAE,OAAO,CAAC;AAC9C;AACA,CAACA,sBAAsB,CAAC,SAAS,CAAC,EAAE,QAAQ,CAAC,CAC9C;AAED;AACA,MAAMF,2BAA2B,GAAsB,CACrD,GAAGC,kBAAkB;AACrB;AACA,CAACC,sBAAsB,CAAC,SAAS,CAAC,EAAE,OAAO,CAAC,CAC7C;AAED,SAASJ,aAAaA,CAACN,MAAc,EAAEW,YAA+B;EACpE,KAAK,MAAM,CAACC,OAAO,EAAEC,WAAW,CAAC,IAAIF,YAAY,EAAE;IACjDX,MAAM,GAAGA,MAAM,CAACc,OAAO,CAACF,OAAO,EAAEC,WAAW,CAAC;EAC/C;EACA,OAAOb,MAAM;AACf;AAEA;;;;;;;;;AASA,SAASU,sBAAsBA,CAACK,SAAiD;EAC/E,OAAO,IAAIC,MAAM,CAAC,MAAMD,SAAS,wCAAwC,EAAE,GAAG,CAAC;AACjF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}