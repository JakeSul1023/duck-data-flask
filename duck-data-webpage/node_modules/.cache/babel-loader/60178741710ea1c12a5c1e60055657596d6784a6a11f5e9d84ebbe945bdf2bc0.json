{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { GL } from '@luma.gl/constants';\nimport { getWebGLExtension } from \"../../context/helpers/webgl-extensions.js\";\n/** @returns strings identifying the GPU vendor and driver. */\nexport function getDeviceInfo(gl, extensions) {\n  // \"Masked\" info is always available, but don't contain much useful information\n  const vendorMasked = gl.getParameter(7936);\n  const rendererMasked = gl.getParameter(7937);\n  // If we are lucky, unmasked info is available\n  // https://www.khronos.org/registry/webgl/extensions/WEBGL_debug_renderer_info/\n  getWebGLExtension(gl, 'WEBGL_debug_renderer_info', extensions);\n  const ext = extensions.WEBGL_debug_renderer_info;\n  const vendorUnmasked = gl.getParameter(ext ? ext.UNMASKED_VENDOR_WEBGL : 7936);\n  const rendererUnmasked = gl.getParameter(ext ? ext.UNMASKED_RENDERER_WEBGL : 7937);\n  const vendor = vendorUnmasked || vendorMasked;\n  const renderer = rendererUnmasked || rendererMasked;\n  // Driver version\n  const version = gl.getParameter(7938);\n  // \"Sniff\" the GPU type and backend from the info. This works best if unmasked info is available.\n  const gpu = identifyGPUVendor(vendor, renderer);\n  const gpuBackend = identifyGPUBackend(vendor, renderer);\n  const gpuType = identifyGPUType(vendor, renderer);\n  // Determine GLSL version\n  // For now, skip parsing of the long version string, just use context type below to deduce version\n  // const version = gl.getParameter(GL.SHADING_LANGUAGE_VERSION) as string;\n  // const shadingLanguageVersion = parseGLSLVersion(version);\n  const shadingLanguage = 'glsl';\n  const shadingLanguageVersion = 300;\n  return {\n    type: 'webgl',\n    gpu,\n    gpuType,\n    gpuBackend,\n    vendor,\n    renderer,\n    version,\n    shadingLanguage,\n    shadingLanguageVersion\n  };\n}\n/** \"Sniff\" the GPU type from the info. This works best if unmasked info is available. */\nfunction identifyGPUVendor(vendor, renderer) {\n  if (/NVIDIA/i.exec(vendor) || /NVIDIA/i.exec(renderer)) {\n    return 'nvidia';\n  }\n  if (/INTEL/i.exec(vendor) || /INTEL/i.exec(renderer)) {\n    return 'intel';\n  }\n  if (/Apple/i.exec(vendor) || /Apple/i.exec(renderer)) {\n    return 'apple';\n  }\n  if (/AMD/i.exec(vendor) || /AMD/i.exec(renderer) || /ATI/i.exec(vendor) || /ATI/i.exec(renderer)) {\n    return 'amd';\n  }\n  if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {\n    return 'software';\n  }\n  return 'unknown';\n}\n/** \"Sniff\" the GPU backend from the info. This works best if unmasked info is available. */\nfunction identifyGPUBackend(vendor, renderer) {\n  if (/Metal/i.exec(vendor) || /Metal/i.exec(renderer)) {\n    return 'metal';\n  }\n  if (/ANGLE/i.exec(vendor) || /ANGLE/i.exec(renderer)) {\n    return 'opengl';\n  }\n  return 'unknown';\n}\nfunction identifyGPUType(vendor, renderer) {\n  if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {\n    return 'cpu';\n  }\n  const gpuVendor = identifyGPUVendor(vendor, renderer);\n  switch (gpuVendor) {\n    case 'intel':\n      return 'integrated';\n    case 'software':\n      return 'cpu';\n    case 'unknown':\n      return 'unknown';\n    default:\n      return 'discrete';\n  }\n}","map":{"version":3,"names":["GL","getWebGLExtension","getDeviceInfo","gl","extensions","vendorMasked","getParameter","rendererMasked","ext","WEBGL_debug_renderer_info","vendorUnmasked","UNMASKED_VENDOR_WEBGL","rendererUnmasked","UNMASKED_RENDERER_WEBGL","vendor","renderer","version","gpu","identifyGPUVendor","gpuBackend","identifyGPUBackend","gpuType","identifyGPUType","shadingLanguage","shadingLanguageVersion","type","exec","gpuVendor"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\webgl\\src\\adapter\\device-helpers\\webgl-device-info.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {DeviceInfo} from '@luma.gl/core';\nimport {GL, GLExtensions} from '@luma.gl/constants';\nimport {getWebGLExtension} from '../../context/helpers/webgl-extensions';\n\n/** @returns strings identifying the GPU vendor and driver. */\nexport function getDeviceInfo(gl: WebGL2RenderingContext, extensions: GLExtensions): DeviceInfo {\n  // \"Masked\" info is always available, but don't contain much useful information\n  const vendorMasked = gl.getParameter(GL.VENDOR);\n  const rendererMasked = gl.getParameter(GL.RENDERER);\n\n  // If we are lucky, unmasked info is available\n  // https://www.khronos.org/registry/webgl/extensions/WEBGL_debug_renderer_info/\n  getWebGLExtension(gl, 'WEBGL_debug_renderer_info', extensions);\n  const ext = extensions.WEBGL_debug_renderer_info;\n  const vendorUnmasked = gl.getParameter(ext ? ext.UNMASKED_VENDOR_WEBGL : GL.VENDOR);\n  const rendererUnmasked = gl.getParameter(ext ? ext.UNMASKED_RENDERER_WEBGL : GL.RENDERER);\n  const vendor = vendorUnmasked || vendorMasked;\n  const renderer = rendererUnmasked || rendererMasked;\n\n  // Driver version\n  const version = gl.getParameter(GL.VERSION) as string;\n\n  // \"Sniff\" the GPU type and backend from the info. This works best if unmasked info is available.\n  const gpu = identifyGPUVendor(vendor, renderer);\n  const gpuBackend = identifyGPUBackend(vendor, renderer);\n  const gpuType = identifyGPUType(vendor, renderer);\n\n  // Determine GLSL version\n  // For now, skip parsing of the long version string, just use context type below to deduce version\n  // const version = gl.getParameter(GL.SHADING_LANGUAGE_VERSION) as string;\n  // const shadingLanguageVersion = parseGLSLVersion(version);\n  const shadingLanguage = 'glsl';\n  const shadingLanguageVersion = 300;\n\n  return {\n    type: 'webgl',\n    gpu,\n    gpuType,\n    gpuBackend,\n    vendor,\n    renderer,\n    version,\n    shadingLanguage,\n    shadingLanguageVersion\n  };\n}\n\n/** \"Sniff\" the GPU type from the info. This works best if unmasked info is available. */\nfunction identifyGPUVendor(\n  vendor: string,\n  renderer: string\n): 'nvidia' | 'intel' | 'apple' | 'amd' | 'software' | 'unknown' {\n  if (/NVIDIA/i.exec(vendor) || /NVIDIA/i.exec(renderer)) {\n    return 'nvidia';\n  }\n  if (/INTEL/i.exec(vendor) || /INTEL/i.exec(renderer)) {\n    return 'intel';\n  }\n  if (/Apple/i.exec(vendor) || /Apple/i.exec(renderer)) {\n    return 'apple';\n  }\n  if (\n    /AMD/i.exec(vendor) ||\n    /AMD/i.exec(renderer) ||\n    /ATI/i.exec(vendor) ||\n    /ATI/i.exec(renderer)\n  ) {\n    return 'amd';\n  }\n  if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {\n    return 'software';\n  }\n\n  return 'unknown';\n}\n\n/** \"Sniff\" the GPU backend from the info. This works best if unmasked info is available. */\nfunction identifyGPUBackend(vendor: string, renderer: string): 'opengl' | 'metal' | 'unknown' {\n  if (/Metal/i.exec(vendor) || /Metal/i.exec(renderer)) {\n    return 'metal';\n  }\n  if (/ANGLE/i.exec(vendor) || /ANGLE/i.exec(renderer)) {\n    return 'opengl';\n  }\n  return 'unknown';\n}\n\nfunction identifyGPUType(\n  vendor: string,\n  renderer: string\n): 'discrete' | 'integrated' | 'cpu' | 'unknown' {\n  if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {\n    return 'cpu';\n  }\n\n  const gpuVendor = identifyGPUVendor(vendor, renderer);\n  switch (gpuVendor) {\n    case 'intel':\n      return 'integrated';\n    case 'software':\n      return 'cpu';\n    case 'unknown':\n      return 'unknown';\n    default:\n      return 'discrete';\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAGA,SAAQA,EAAE,QAAqB,oBAAoB;AACnD,SAAQC,iBAAiB,QAAC;AAE1B;AACA,OAAM,SAAUC,aAAaA,CAACC,EAA0B,EAAEC,UAAwB;EAChF;EACA,MAAMC,YAAY,GAAGF,EAAE,CAACG,YAAY,MAAW;EAC/C,MAAMC,cAAc,GAAGJ,EAAE,CAACG,YAAY,MAAa;EAEnD;EACA;EACAL,iBAAiB,CAACE,EAAE,EAAE,2BAA2B,EAAEC,UAAU,CAAC;EAC9D,MAAMI,GAAG,GAAGJ,UAAU,CAACK,yBAAyB;EAChD,MAAMC,cAAc,GAAGP,EAAE,CAACG,YAAY,CAACE,GAAG,GAAGA,GAAG,CAACG,qBAAqB,GAAE,IAAU,CAAC;EACnF,MAAMC,gBAAgB,GAAGT,EAAE,CAACG,YAAY,CAACE,GAAG,GAAGA,GAAG,CAACK,uBAAuB,GAAE,IAAY,CAAC;EACzF,MAAMC,MAAM,GAAGJ,cAAc,IAAIL,YAAY;EAC7C,MAAMU,QAAQ,GAAGH,gBAAgB,IAAIL,cAAc;EAEnD;EACA,MAAMS,OAAO,GAAGb,EAAE,CAACG,YAAY,MAAsB;EAErD;EACA,MAAMW,GAAG,GAAGC,iBAAiB,CAACJ,MAAM,EAAEC,QAAQ,CAAC;EAC/C,MAAMI,UAAU,GAAGC,kBAAkB,CAACN,MAAM,EAAEC,QAAQ,CAAC;EACvD,MAAMM,OAAO,GAAGC,eAAe,CAACR,MAAM,EAAEC,QAAQ,CAAC;EAEjD;EACA;EACA;EACA;EACA,MAAMQ,eAAe,GAAG,MAAM;EAC9B,MAAMC,sBAAsB,GAAG,GAAG;EAElC,OAAO;IACLC,IAAI,EAAE,OAAO;IACbR,GAAG;IACHI,OAAO;IACPF,UAAU;IACVL,MAAM;IACNC,QAAQ;IACRC,OAAO;IACPO,eAAe;IACfC;GACD;AACH;AAEA;AACA,SAASN,iBAAiBA,CACxBJ,MAAc,EACdC,QAAgB;EAEhB,IAAI,SAAS,CAACW,IAAI,CAACZ,MAAM,CAAC,IAAI,SAAS,CAACY,IAAI,CAACX,QAAQ,CAAC,EAAE;IACtD,OAAO,QAAQ;EACjB;EACA,IAAI,QAAQ,CAACW,IAAI,CAACZ,MAAM,CAAC,IAAI,QAAQ,CAACY,IAAI,CAACX,QAAQ,CAAC,EAAE;IACpD,OAAO,OAAO;EAChB;EACA,IAAI,QAAQ,CAACW,IAAI,CAACZ,MAAM,CAAC,IAAI,QAAQ,CAACY,IAAI,CAACX,QAAQ,CAAC,EAAE;IACpD,OAAO,OAAO;EAChB;EACA,IACE,MAAM,CAACW,IAAI,CAACZ,MAAM,CAAC,IACnB,MAAM,CAACY,IAAI,CAACX,QAAQ,CAAC,IACrB,MAAM,CAACW,IAAI,CAACZ,MAAM,CAAC,IACnB,MAAM,CAACY,IAAI,CAACX,QAAQ,CAAC,EACrB;IACA,OAAO,KAAK;EACd;EACA,IAAI,cAAc,CAACW,IAAI,CAACZ,MAAM,CAAC,IAAI,cAAc,CAACY,IAAI,CAACX,QAAQ,CAAC,EAAE;IAChE,OAAO,UAAU;EACnB;EAEA,OAAO,SAAS;AAClB;AAEA;AACA,SAASK,kBAAkBA,CAACN,MAAc,EAAEC,QAAgB;EAC1D,IAAI,QAAQ,CAACW,IAAI,CAACZ,MAAM,CAAC,IAAI,QAAQ,CAACY,IAAI,CAACX,QAAQ,CAAC,EAAE;IACpD,OAAO,OAAO;EAChB;EACA,IAAI,QAAQ,CAACW,IAAI,CAACZ,MAAM,CAAC,IAAI,QAAQ,CAACY,IAAI,CAACX,QAAQ,CAAC,EAAE;IACpD,OAAO,QAAQ;EACjB;EACA,OAAO,SAAS;AAClB;AAEA,SAASO,eAAeA,CACtBR,MAAc,EACdC,QAAgB;EAEhB,IAAI,cAAc,CAACW,IAAI,CAACZ,MAAM,CAAC,IAAI,cAAc,CAACY,IAAI,CAACX,QAAQ,CAAC,EAAE;IAChE,OAAO,KAAK;EACd;EAEA,MAAMY,SAAS,GAAGT,iBAAiB,CAACJ,MAAM,EAAEC,QAAQ,CAAC;EACrD,QAAQY,SAAS;IACf,KAAK,OAAO;MACV,OAAO,YAAY;IACrB,KAAK,UAAU;MACb,OAAO,KAAK;IACd,KAAK,SAAS;MACZ,OAAO,SAAS;IAClB;MACE,OAAO,UAAU;EACrB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}