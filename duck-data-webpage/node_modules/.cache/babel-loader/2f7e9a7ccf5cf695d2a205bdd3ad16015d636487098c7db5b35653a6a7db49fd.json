{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { COORDINATE_SYSTEM, LayerExtension, log } from '@deck.gl/core';\nimport mask from \"./shader-module.js\";\nimport MaskEffect from \"./mask-effect.js\";\nconst defaultProps = {\n  maskId: '',\n  maskByInstance: undefined,\n  maskInverted: false\n};\n/** Allows layers to show/hide objects by a geofence. */\nclass MaskExtension extends LayerExtension {\n  initializeState() {\n    this.context.deck?._addDefaultEffect(new MaskEffect());\n  }\n  getShaders() {\n    // Infer by geometry if 'maskByInstance' prop isn't explictly set\n    let maskByInstance = 'instancePositions' in this.getAttributeManager().attributes;\n    // Users can override by setting the `maskByInstance` prop\n    if (this.props.maskByInstance !== undefined) {\n      maskByInstance = Boolean(this.props.maskByInstance);\n    }\n    this.state.maskByInstance = maskByInstance;\n    return {\n      modules: [mask]\n    };\n  }\n  /* eslint-disable camelcase */\n  draw({\n    context,\n    shaderModuleProps\n  }) {\n    const maskProps = {};\n    maskProps.maskByInstance = Boolean(this.state.maskByInstance);\n    const {\n      maskId,\n      maskInverted\n    } = this.props;\n    const {\n      maskChannels\n    } = shaderModuleProps.mask || {};\n    const {\n      viewport\n    } = context;\n    if (maskChannels && maskChannels[maskId]) {\n      const {\n        index,\n        bounds,\n        coordinateOrigin: fromCoordinateOrigin\n      } = maskChannels[maskId];\n      let {\n        coordinateSystem: fromCoordinateSystem\n      } = maskChannels[maskId];\n      maskProps.enabled = true;\n      maskProps.channel = index;\n      maskProps.inverted = maskInverted;\n      if (fromCoordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n        fromCoordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;\n      }\n      const opts = {\n        modelMatrix: null,\n        fromCoordinateOrigin,\n        fromCoordinateSystem\n      };\n      const bl = this.projectPosition([bounds[0], bounds[1], 0], opts);\n      const tr = this.projectPosition([bounds[2], bounds[3], 0], opts);\n      maskProps.bounds = [bl[0], bl[1], tr[0], tr[1]];\n    } else {\n      if (maskId) {\n        log.warn(`Could not find a mask layer with id: ${maskId}`)();\n      }\n      maskProps.enabled = false;\n    }\n    this.setShaderModuleProps({\n      mask: maskProps\n    });\n  }\n}\nMaskExtension.defaultProps = defaultProps;\nMaskExtension.extensionName = 'MaskExtension';\nexport default MaskExtension;","map":{"version":3,"names":["COORDINATE_SYSTEM","LayerExtension","log","mask","MaskEffect","defaultProps","maskId","maskByInstance","undefined","maskInverted","MaskExtension","initializeState","context","deck","_addDefaultEffect","getShaders","getAttributeManager","attributes","props","Boolean","state","modules","draw","shaderModuleProps","maskProps","maskChannels","viewport","index","bounds","coordinateOrigin","fromCoordinateOrigin","coordinateSystem","fromCoordinateSystem","enabled","channel","inverted","DEFAULT","isGeospatial","LNGLAT","CARTESIAN","opts","modelMatrix","bl","projectPosition","tr","warn","setShaderModuleProps","extensionName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\extensions\\src\\mask\\mask-extension.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {COORDINATE_SYSTEM, Layer, LayerExtension, log} from '@deck.gl/core';\nimport mask, {MaskProps} from './shader-module';\nimport MaskEffect from './mask-effect';\n\nconst defaultProps = {\n  maskId: '',\n  maskByInstance: undefined,\n  maskInverted: false\n};\n\nexport type MaskExtensionProps = {\n  /**\n   * Id of the layer that defines the mask. The mask layer must use the prop `operation: 'mask'`.\n   * Masking is disabled if `maskId` is empty or no valid mask layer with the specified id is found.\n   */\n  maskId?: string;\n  /**\n   * controls whether an object is clipped by its anchor (usually defined by an accessor called `getPosition`, e.g. icon, scatterplot) or by its geometry (e.g. path, polygon).\n   * If not specified, it is automatically deduced from the layer.\n   */\n  maskByInstance?: boolean;\n  /**\n   * Inverts the masking operation\n   */\n  maskInverted?: boolean;\n};\n\n/** Allows layers to show/hide objects by a geofence. */\nexport default class MaskExtension extends LayerExtension {\n  static defaultProps = defaultProps;\n  static extensionName = 'MaskExtension';\n\n  initializeState(this: Layer<MaskExtensionProps>) {\n    this.context.deck?._addDefaultEffect(new MaskEffect());\n  }\n\n  getShaders(this: Layer<MaskExtensionProps>): any {\n    // Infer by geometry if 'maskByInstance' prop isn't explictly set\n    let maskByInstance = 'instancePositions' in this.getAttributeManager()!.attributes;\n    // Users can override by setting the `maskByInstance` prop\n    if (this.props.maskByInstance !== undefined) {\n      maskByInstance = Boolean(this.props.maskByInstance);\n    }\n    this.state.maskByInstance = maskByInstance;\n\n    return {\n      modules: [mask]\n    };\n  }\n\n  /* eslint-disable camelcase */\n  draw(this: Layer<Required<MaskExtensionProps>>, {context, shaderModuleProps}: any) {\n    const maskProps = {} as MaskProps;\n    maskProps.maskByInstance = Boolean(this.state.maskByInstance);\n    const {maskId, maskInverted} = this.props;\n    const {maskChannels} = shaderModuleProps.mask || {};\n    const {viewport} = context;\n    if (maskChannels && maskChannels[maskId]) {\n      const {index, bounds, coordinateOrigin: fromCoordinateOrigin} = maskChannels[maskId];\n      let {coordinateSystem: fromCoordinateSystem} = maskChannels[maskId];\n      maskProps.enabled = true;\n      maskProps.channel = index;\n      maskProps.inverted = maskInverted;\n\n      if (fromCoordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n        fromCoordinateSystem = viewport.isGeospatial\n          ? COORDINATE_SYSTEM.LNGLAT\n          : COORDINATE_SYSTEM.CARTESIAN;\n      }\n      const opts = {modelMatrix: null, fromCoordinateOrigin, fromCoordinateSystem};\n      const bl = this.projectPosition([bounds[0], bounds[1], 0], opts);\n      const tr = this.projectPosition([bounds[2], bounds[3], 0], opts);\n      maskProps.bounds = [bl[0], bl[1], tr[0], tr[1]];\n    } else {\n      if (maskId) {\n        log.warn(`Could not find a mask layer with id: ${maskId}`)();\n      }\n      maskProps.enabled = false;\n    }\n\n    this.setShaderModuleProps({mask: maskProps});\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}