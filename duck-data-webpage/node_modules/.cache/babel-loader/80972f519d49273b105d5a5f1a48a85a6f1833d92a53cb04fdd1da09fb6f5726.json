{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Vector3, Matrix4 } from '@math.gl/core';\nimport { CullingVolume } from '@math.gl/culling';\nimport { load } from '@loaders.gl/core';\nimport { TILE_REFINEMENT, TILE_CONTENT_STATE, TILESET_TYPE } from \"../constants.js\";\nimport { createBoundingVolume, getCartographicBounds } from \"./helpers/bounding-volume.js\";\nimport { getTiles3DScreenSpaceError } from \"./helpers/tiles-3d-lod.js\";\nimport { getProjectedRadius } from \"./helpers/i3s-lod.js\";\nimport { get3dTilesOptions } from \"./helpers/3d-tiles-options.js\";\nimport { TilesetTraverser } from \"./tileset-traverser.js\";\nconst scratchVector = new Vector3();\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n/**\n * A Tile3DHeader represents a tile as Tileset3D. When a tile is first created, its content is not loaded;\n * the content is loaded on-demand when needed based on the view.\n * Do not construct this directly, instead access tiles through {@link Tileset3D#tileVisible}.\n */\nexport class Tile3D {\n  tileset;\n  header;\n  id;\n  url;\n  parent;\n  /* Specifies the type of refine that is used when traversing this tile for rendering. */\n  refine;\n  type;\n  contentUrl;\n  /** Different refinement algorithms used by I3S and 3D tiles */\n  lodMetricType = 'geometricError';\n  /** The error, in meters, introduced if this tile is rendered and its children are not. */\n  lodMetricValue = 0;\n  /** @todo math.gl is not exporting BoundingVolume base type? */\n  boundingVolume = null;\n  /**\n   * The tile's content.  This represents the actual tile's payload,\n   * not the content's metadata in the tileset JSON file.\n   */\n  content = null;\n  contentState = TILE_CONTENT_STATE.UNLOADED;\n  gpuMemoryUsageInBytes = 0;\n  /** The tile's children - an array of Tile3D objects. */\n  children = [];\n  depth = 0;\n  viewportIds = [];\n  transform = new Matrix4();\n  extensions = null;\n  /** TODO Cesium 3d tiles specific */\n  implicitTiling = null;\n  /** Container to store application specific data */\n  userData = {};\n  computedTransform;\n  hasEmptyContent = false;\n  hasTilesetContent = false;\n  traverser = new TilesetTraverser({});\n  /** Used by TilesetCache */\n  _cacheNode = null;\n  _frameNumber = null;\n  // TODO Cesium 3d tiles specific\n  _expireDate = null;\n  _expiredContent = null;\n  _boundingBox = undefined;\n  /** updated every frame for tree traversal and rendering optimizations: */\n  _distanceToCamera = 0;\n  _screenSpaceError = 0;\n  _visibilityPlaneMask;\n  _visible = undefined;\n  _contentBoundingVolume;\n  _viewerRequestVolume;\n  _initialTransform = new Matrix4();\n  // Used by traverser, cannot be marked private\n  _priority = 0;\n  _selectedFrame = 0;\n  _requestedFrame = 0;\n  _selectionDepth = 0;\n  _touchedFrame = 0;\n  _centerZDepth = 0;\n  _shouldRefine = false;\n  _stackLength = 0;\n  _visitedFrame = 0;\n  _inRequestVolume = false;\n  _lodJudge = null; // TODO i3s specific, needs to remove\n  /**\n   * @constructs\n   * Create a Tile3D instance\n   * @param tileset - Tileset3D instance\n   * @param header - tile header - JSON loaded from a dataset\n   * @param parentHeader - parent Tile3D instance\n   * @param extendedId - optional ID to separate copies of a tile for different viewports.\n   *    const extendedId = `${tile.id}-${frameState.viewport.id}`;\n   */\n  // eslint-disable-next-line max-statements\n  constructor(tileset, header, parentHeader, extendedId = '') {\n    // PUBLIC MEMBERS\n    // original tile data\n    this.header = header;\n    // The tileset containing this tile.\n    this.tileset = tileset;\n    this.id = extendedId || header.id;\n    this.url = header.url;\n    // This tile's parent or `undefined` if this tile is the root.\n    // @ts-ignore\n    this.parent = parentHeader;\n    this.refine = this._getRefine(header.refine);\n    this.type = header.type;\n    this.contentUrl = header.contentUrl;\n    this._initializeLodMetric(header);\n    this._initializeTransforms(header);\n    this._initializeBoundingVolumes(header);\n    this._initializeContent(header);\n    this._initializeRenderingState(header);\n    Object.seal(this);\n  }\n  destroy() {\n    this.header = null;\n  }\n  isDestroyed() {\n    return this.header === null;\n  }\n  get selected() {\n    return this._selectedFrame === this.tileset._frameNumber;\n  }\n  get isVisible() {\n    return this._visible;\n  }\n  get isVisibleAndInRequestVolume() {\n    return this._visible && this._inRequestVolume;\n  }\n  /** Returns true if tile is not an empty tile and not an external tileset */\n  get hasRenderContent() {\n    return !this.hasEmptyContent && !this.hasTilesetContent;\n  }\n  /** Returns true if tile has children */\n  get hasChildren() {\n    return this.children.length > 0 || this.header.children && this.header.children.length > 0;\n  }\n  /**\n   * Determines if the tile's content is ready. This is automatically `true` for\n   * tiles with empty content.\n   */\n  get contentReady() {\n    return this.contentState === TILE_CONTENT_STATE.READY || this.hasEmptyContent;\n  }\n  /**\n   * Determines if the tile has available content to render.  `true` if the tile's\n   * content is ready or if it has expired content this renders while new content loads; otherwise,\n   */\n  get contentAvailable() {\n    return Boolean(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);\n  }\n  /** Returns true if tile has renderable content but it's unloaded */\n  get hasUnloadedContent() {\n    return this.hasRenderContent && this.contentUnloaded;\n  }\n  /**\n   * Determines if the tile's content has not be requested. `true` if tile's\n   * content has not be requested; otherwise, `false`.\n   */\n  get contentUnloaded() {\n    return this.contentState === TILE_CONTENT_STATE.UNLOADED;\n  }\n  /**\n   * Determines if the tile's content is expired. `true` if tile's\n   * content is expired; otherwise, `false`.\n   */\n  get contentExpired() {\n    return this.contentState === TILE_CONTENT_STATE.EXPIRED;\n  }\n  // Determines if the tile's content failed to load.  `true` if the tile's\n  // content failed to load; otherwise, `false`.\n  get contentFailed() {\n    return this.contentState === TILE_CONTENT_STATE.FAILED;\n  }\n  /**\n   * Distance from the tile's bounding volume center to the camera\n   */\n  get distanceToCamera() {\n    return this._distanceToCamera;\n  }\n  /**\n   * Screen space error for LOD selection\n   */\n  get screenSpaceError() {\n    return this._screenSpaceError;\n  }\n  /**\n   * Get bounding box in cartographic coordinates\n   * @returns [min, max] each in [longitude, latitude, altitude]\n   */\n  get boundingBox() {\n    if (!this._boundingBox) {\n      this._boundingBox = getCartographicBounds(this.header.boundingVolume, this.boundingVolume);\n    }\n    return this._boundingBox;\n  }\n  /** Get the tile's screen space error. */\n  getScreenSpaceError(frameState, useParentLodMetric) {\n    switch (this.tileset.type) {\n      case TILESET_TYPE.I3S:\n        return getProjectedRadius(this, frameState);\n      case TILESET_TYPE.TILES3D:\n        return getTiles3DScreenSpaceError(this, frameState, useParentLodMetric);\n      default:\n        // eslint-disable-next-line\n        throw new Error('Unsupported tileset type');\n    }\n  }\n  /**\n   * Make tile unselected than means it won't be shown\n   * but it can be still loaded in memory\n   */\n  unselect() {\n    this._selectedFrame = 0;\n  }\n  /**\n   * Memory usage of tile on GPU\n   */\n  _getGpuMemoryUsageInBytes() {\n    return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;\n  }\n  /*\n   * If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.\n   * Tiles are prioritized by screen space error.\n   */\n  // eslint-disable-next-line complexity\n  _getPriority() {\n    const traverser = this.tileset._traverser;\n    const {\n      skipLevelOfDetail\n    } = traverser.options;\n    /*\n     * Tiles that are outside of the camera's frustum could be skipped if we are in 'ADD' mode\n     * or if we are using 'Skip Traversal' in 'REPLACE' mode.\n     * Otherewise, all 'touched' child tiles have to be loaded and displayed,\n     * this may include tiles that are outide of the camera frustum (so that we can hide the parent tile).\n     */\n    const maySkipTile = this.refine === TILE_REFINEMENT.ADD || skipLevelOfDetail;\n    // Check if any reason to abort\n    if (maySkipTile && !this.isVisible && this._visible !== undefined) {\n      return -1;\n    }\n    // Condition used in `cancelOutOfViewRequests` function in CesiumJS/Cesium3DTileset.js\n    if (this.tileset._frameNumber - this._touchedFrame >= 1) {\n      return -1;\n    }\n    if (this.contentState === TILE_CONTENT_STATE.UNLOADED) {\n      return -1;\n    }\n    // Based on the priority function `getPriorityReverseScreenSpaceError` in CesiumJS. Scheduling priority is based on the parent's screen space error when possible.\n    const parent = this.parent;\n    const useParentScreenSpaceError = parent && (!maySkipTile || this._screenSpaceError === 0.0 || parent.hasTilesetContent);\n    const screenSpaceError = useParentScreenSpaceError ? parent._screenSpaceError : this._screenSpaceError;\n    const rootScreenSpaceError = traverser.root ? traverser.root._screenSpaceError : 0.0;\n    // Map higher SSE to lower values (e.g. root tile is highest priority)\n    return Math.max(rootScreenSpaceError - screenSpaceError, 0);\n  }\n  /**\n   *  Requests the tile's content.\n   * The request may not be made if the Request Scheduler can't prioritize it.\n   */\n  // eslint-disable-next-line max-statements, complexity\n  async loadContent() {\n    if (this.hasEmptyContent) {\n      return false;\n    }\n    if (this.content) {\n      return true;\n    }\n    const expired = this.contentExpired;\n    if (expired) {\n      this._expireDate = null;\n    }\n    this.contentState = TILE_CONTENT_STATE.LOADING;\n    const requestToken = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));\n    if (!requestToken) {\n      // cancelled\n      this.contentState = TILE_CONTENT_STATE.UNLOADED;\n      return false;\n    }\n    try {\n      const contentUrl = this.tileset.getTileUrl(this.contentUrl);\n      // The content can be a binary tile ot a JSON tileset\n      const loader = this.tileset.loader;\n      const options = {\n        ...this.tileset.loadOptions,\n        [loader.id]: {\n          // @ts-expect-error\n          ...this.tileset.loadOptions[loader.id],\n          isTileset: this.type === 'json',\n          ...this._getLoaderSpecificOptions(loader.id)\n        }\n      };\n      this.content = await load(contentUrl, loader, options);\n      if (this.tileset.options.contentLoader) {\n        await this.tileset.options.contentLoader(this);\n      }\n      if (this._isTileset()) {\n        // Add tile headers for the nested tilset's subtree\n        // Async update of the tree should be fine since there would never be edits to the same node\n        // TODO - we need to capture the child tileset's URL\n        this.tileset._initializeTileHeaders(this.content, this);\n      }\n      this.contentState = TILE_CONTENT_STATE.READY;\n      this._onContentLoaded();\n      return true;\n    } catch (error) {\n      // Tile is unloaded before the content finishes loading\n      this.contentState = TILE_CONTENT_STATE.FAILED;\n      throw error;\n    } finally {\n      requestToken.done();\n    }\n  }\n  // Unloads the tile's content.\n  unloadContent() {\n    if (this.content && this.content.destroy) {\n      this.content.destroy();\n    }\n    this.content = null;\n    if (this.header.content && this.header.content.destroy) {\n      this.header.content.destroy();\n    }\n    this.header.content = null;\n    this.contentState = TILE_CONTENT_STATE.UNLOADED;\n    return true;\n  }\n  /**\n   * Update the tile's visibility\n   * @param {Object} frameState - frame state for tile culling\n   * @param {string[]} viewportIds - a list of viewport ids that show this tile\n   * @return {void}\n   */\n  updateVisibility(frameState, viewportIds) {\n    if (this._frameNumber === frameState.frameNumber) {\n      // Return early if visibility has already been checked during the traversal.\n      // The visibility may have already been checked if the cullWithChildrenBounds optimization is used.\n      return;\n    }\n    const parent = this.parent;\n    const parentVisibilityPlaneMask = parent ? parent._visibilityPlaneMask : CullingVolume.MASK_INDETERMINATE;\n    if (this.tileset._traverser.options.updateTransforms) {\n      const parentTransform = parent ? parent.computedTransform : this.tileset.modelMatrix;\n      this._updateTransform(parentTransform);\n    }\n    this._distanceToCamera = this.distanceToTile(frameState);\n    this._screenSpaceError = this.getScreenSpaceError(frameState, false);\n    this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask); // Use parent's plane mask to speed up visibility test\n    this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;\n    this._inRequestVolume = this.insideViewerRequestVolume(frameState);\n    this._frameNumber = frameState.frameNumber;\n    this.viewportIds = viewportIds;\n  }\n  // Determines whether the tile's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.\n  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.\n  visibility(frameState, parentVisibilityPlaneMask) {\n    const {\n      cullingVolume\n    } = frameState;\n    const {\n      boundingVolume\n    } = this;\n    // TODO Cesium specific - restore clippingPlanes\n    // const {clippingPlanes, clippingPlanesOriginMatrix} = tileset;\n    // if (clippingPlanes && clippingPlanes.enabled) {\n    //   const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n    //     boundingVolume,\n    //     clippingPlanesOriginMatrix\n    //   );\n    //   this._isClipped = intersection !== Intersect.INSIDE;\n    //   if (intersection === Intersect.OUTSIDE) {\n    //     return CullingVolume.MASK_OUTSIDE;\n    //   }\n    // }\n    // return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n    return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n  }\n  // Assuming the tile's bounding volume intersects the culling volume, determines\n  // whether the tile's content's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.\n  contentVisibility() {\n    return true;\n    // TODO restore\n    /*\n    // Assumes the tile's bounding volume intersects the culling volume already, so\n    // just return Intersect.INSIDE if there is no content bounding volume.\n    if (!defined(this.contentBoundingVolume)) {\n      return Intersect.INSIDE;\n    }\n         if (this._visibilityPlaneMask === CullingVolume.MASK_INSIDE) {\n      // The tile's bounding volume is completely inside the culling volume so\n      // the content bounding volume must also be inside.\n      return Intersect.INSIDE;\n    }\n         // PERFORMANCE_IDEA: is it possible to burn less CPU on this test since we know the\n    // tile's (not the content's) bounding volume intersects the culling volume?\n    const cullingVolume = frameState.cullingVolume;\n    const boundingVolume = tile.contentBoundingVolume;\n         const tileset = this.tileset;\n    const clippingPlanes = tileset.clippingPlanes;\n    if (defined(clippingPlanes) && clippingPlanes.enabled) {\n      const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n        boundingVolume,\n        tileset.clippingPlanesOriginMatrix\n      );\n      this._isClipped = intersection !== Intersect.INSIDE;\n      if (intersection === Intersect.OUTSIDE) {\n        return Intersect.OUTSIDE;\n      }\n    }\n         return cullingVolume.computeVisibility(boundingVolume);\n    */\n  }\n  /**\n   * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.\n   * @param frameState The frame state.\n   * @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.\n   */\n  distanceToTile(frameState) {\n    const boundingVolume = this.boundingVolume;\n    return Math.sqrt(Math.max(boundingVolume.distanceSquaredTo(frameState.camera.position), 0));\n  }\n  /**\n   * Computes the tile's camera-space z-depth.\n   * @param frameState The frame state.\n   * @returns The distance, in meters.\n   */\n  cameraSpaceZDepth({\n    camera\n  }) {\n    const boundingVolume = this.boundingVolume; // Gets the underlying OrientedBoundingBox or BoundingSphere\n    scratchVector.subVectors(boundingVolume.center, camera.position);\n    return camera.direction.dot(scratchVector);\n  }\n  /**\n   * Checks if the camera is inside the viewer request volume.\n   * @param {FrameState} frameState The frame state.\n   * @returns {Boolean} Whether the camera is inside the volume.\n   */\n  insideViewerRequestVolume(frameState) {\n    const viewerRequestVolume = this._viewerRequestVolume;\n    return !viewerRequestVolume || viewerRequestVolume.distanceSquaredTo(frameState.camera.position) <= 0;\n  }\n  // TODO Cesium specific\n  // Update whether the tile has expired.\n  updateExpiration() {\n    if (defined(this._expireDate) && this.contentReady && !this.hasEmptyContent) {\n      const now = Date.now();\n      // @ts-ignore Date.lessThan - replace with ms compare?\n      if (Date.lessThan(this._expireDate, now)) {\n        this.contentState = TILE_CONTENT_STATE.EXPIRED;\n        this._expiredContent = this.content;\n      }\n    }\n  }\n  get extras() {\n    return this.header.extras;\n  }\n  // INTERNAL METHODS\n  _initializeLodMetric(header) {\n    if ('lodMetricType' in header) {\n      this.lodMetricType = header.lodMetricType;\n    } else {\n      this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType;\n      // eslint-disable-next-line\n      console.warn(`3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType`);\n    }\n    // This is used to compute screen space error, i.e., the error measured in pixels.\n    if ('lodMetricValue' in header) {\n      this.lodMetricValue = header.lodMetricValue;\n    } else {\n      this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue;\n      // eslint-disable-next-line\n      console.warn('3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue');\n    }\n  }\n  _initializeTransforms(tileHeader) {\n    // The local transform of this tile.\n    this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();\n    const parent = this.parent;\n    const tileset = this.tileset;\n    const parentTransform = parent && parent.computedTransform ? parent.computedTransform.clone() : tileset.modelMatrix.clone();\n    this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);\n    const parentInitialTransform = parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();\n    this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);\n  }\n  _initializeBoundingVolumes(tileHeader) {\n    this._contentBoundingVolume = null;\n    this._viewerRequestVolume = null;\n    this._updateBoundingVolume(tileHeader);\n  }\n  _initializeContent(tileHeader) {\n    // Empty tile by default\n    this.content = {\n      _tileset: this.tileset,\n      _tile: this\n    };\n    this.hasEmptyContent = true;\n    this.contentState = TILE_CONTENT_STATE.UNLOADED;\n    // When `true`, the tile's content points to an external tileset.\n    // This is `false` until the tile's content is loaded.\n    this.hasTilesetContent = false;\n    if (tileHeader.contentUrl) {\n      this.content = null;\n      this.hasEmptyContent = false;\n    }\n  }\n  // TODO - remove anything not related to basic visibility detection\n  _initializeRenderingState(header) {\n    this.depth = header.level || (this.parent ? this.parent.depth + 1 : 0);\n    this._shouldRefine = false;\n    // Members this are updated every frame for tree traversal and rendering optimizations:\n    this._distanceToCamera = 0;\n    this._centerZDepth = 0;\n    this._screenSpaceError = 0;\n    this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;\n    this._visible = undefined;\n    this._inRequestVolume = false;\n    this._stackLength = 0;\n    this._selectionDepth = 0;\n    this._frameNumber = 0;\n    this._touchedFrame = 0;\n    this._visitedFrame = 0;\n    this._selectedFrame = 0;\n    this._requestedFrame = 0;\n    this._priority = 0.0;\n  }\n  _getRefine(refine) {\n    // Inherit from parent tile if omitted.\n    return refine || this.parent && this.parent.refine || TILE_REFINEMENT.REPLACE;\n  }\n  _isTileset() {\n    return this.contentUrl.indexOf('.json') !== -1;\n  }\n  _onContentLoaded() {\n    // Vector and Geometry tile rendering do not support the skip LOD optimization.\n    switch (this.content && this.content.type) {\n      case 'vctr':\n      case 'geom':\n        // @ts-ignore\n        this.tileset._traverser.disableSkipLevelOfDetail = true;\n        break;\n      default:\n    }\n    // The content may be tileset json\n    if (this._isTileset()) {\n      this.hasTilesetContent = true;\n    } else {\n      this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();\n    }\n  }\n  _updateBoundingVolume(header) {\n    // Update the bounding volumes\n    this.boundingVolume = createBoundingVolume(header.boundingVolume, this.computedTransform, this.boundingVolume);\n    const content = header.content;\n    if (!content) {\n      return;\n    }\n    // TODO Cesium specific\n    // Non-leaf tiles may have a content bounding-volume, which is a tight-fit bounding volume\n    // around only the features in the tile. This box is useful for culling for rendering,\n    // but not for culling for traversing the tree since it does not guarantee spatial coherence, i.e.,\n    // since it only bounds features in the tile, not the entire tile, children may be\n    // outside of this box.\n    if (content.boundingVolume) {\n      this._contentBoundingVolume = createBoundingVolume(content.boundingVolume, this.computedTransform, this._contentBoundingVolume);\n    }\n    if (header.viewerRequestVolume) {\n      this._viewerRequestVolume = createBoundingVolume(header.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume);\n    }\n  }\n  // Update the tile's transform. The transform is applied to the tile's bounding volumes.\n  _updateTransform(parentTransform = new Matrix4()) {\n    const computedTransform = parentTransform.clone().multiplyRight(this.transform);\n    const didTransformChange = !computedTransform.equals(this.computedTransform);\n    if (!didTransformChange) {\n      return;\n    }\n    this.computedTransform = computedTransform;\n    this._updateBoundingVolume(this.header);\n  }\n  // Get options which are applicable only for the particular loader\n  _getLoaderSpecificOptions(loaderId) {\n    switch (loaderId) {\n      case 'i3s':\n        return {\n          ...this.tileset.options.i3s,\n          _tileOptions: {\n            attributeUrls: this.header.attributeUrls,\n            textureUrl: this.header.textureUrl,\n            textureFormat: this.header.textureFormat,\n            textureLoaderOptions: this.header.textureLoaderOptions,\n            materialDefinition: this.header.materialDefinition,\n            isDracoGeometry: this.header.isDracoGeometry,\n            mbs: this.header.mbs\n          },\n          _tilesetOptions: {\n            store: this.tileset.tileset.store,\n            attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,\n            fields: this.tileset.tileset.fields\n          },\n          isTileHeader: false\n        };\n      case '3d-tiles':\n      case 'cesium-ion':\n      default:\n        return get3dTilesOptions(this.tileset.tileset);\n    }\n  }\n}","map":{"version":3,"names":["Vector3","Matrix4","CullingVolume","load","TILE_REFINEMENT","TILE_CONTENT_STATE","TILESET_TYPE","createBoundingVolume","getCartographicBounds","getTiles3DScreenSpaceError","getProjectedRadius","get3dTilesOptions","TilesetTraverser","scratchVector","defined","x","undefined","Tile3D","tileset","header","id","url","parent","refine","type","contentUrl","lodMetricType","lodMetricValue","boundingVolume","content","contentState","UNLOADED","gpuMemoryUsageInBytes","children","depth","viewportIds","transform","extensions","implicitTiling","userData","computedTransform","hasEmptyContent","hasTilesetContent","traverser","_cacheNode","_frameNumber","_expireDate","_expiredContent","_boundingBox","_distanceToCamera","_screenSpaceError","_visibilityPlaneMask","_visible","_contentBoundingVolume","_viewerRequestVolume","_initialTransform","_priority","_selectedFrame","_requestedFrame","_selectionDepth","_touchedFrame","_centerZDepth","_shouldRefine","_stackLength","_visitedFrame","_inRequestVolume","_lodJudge","constructor","parentHeader","extendedId","_getRefine","_initializeLodMetric","_initializeTransforms","_initializeBoundingVolumes","_initializeContent","_initializeRenderingState","Object","seal","destroy","isDestroyed","selected","isVisible","isVisibleAndInRequestVolume","hasRenderContent","hasChildren","length","contentReady","READY","contentAvailable","Boolean","contentFailed","hasUnloadedContent","contentUnloaded","contentExpired","EXPIRED","FAILED","distanceToCamera","screenSpaceError","boundingBox","getScreenSpaceError","frameState","useParentLodMetric","I3S","TILES3D","Error","unselect","_getGpuMemoryUsageInBytes","byteLength","_getPriority","_traverser","skipLevelOfDetail","options","maySkipTile","ADD","useParentScreenSpaceError","rootScreenSpaceError","root","Math","max","loadContent","expired","LOADING","requestToken","_requestScheduler","scheduleRequest","bind","getTileUrl","loader","loadOptions","isTileset","_getLoaderSpecificOptions","contentLoader","_isTileset","_initializeTileHeaders","_onContentLoaded","error","done","unloadContent","updateVisibility","frameNumber","parentVisibilityPlaneMask","MASK_INDETERMINATE","updateTransforms","parentTransform","modelMatrix","_updateTransform","distanceToTile","visibility","MASK_OUTSIDE","insideViewerRequestVolume","cullingVolume","computeVisibilityWithPlaneMask","contentVisibility","sqrt","distanceSquaredTo","camera","position","cameraSpaceZDepth","subVectors","center","direction","dot","viewerRequestVolume","updateExpiration","now","Date","lessThan","extras","console","warn","tileHeader","clone","multiplyRight","parentInitialTransform","_updateBoundingVolume","_tileset","_tile","level","REPLACE","indexOf","disableSkipLevelOfDetail","didTransformChange","equals","loaderId","i3s","_tileOptions","attributeUrls","textureUrl","textureFormat","textureLoaderOptions","materialDefinition","isDracoGeometry","mbs","_tilesetOptions","store","attributeStorageInfo","fields","isTileHeader"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/tiles/dist/tileset/tile-3d.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Vector3, Matrix4 } from '@math.gl/core';\nimport { CullingVolume } from '@math.gl/culling';\nimport { load } from '@loaders.gl/core';\nimport { TILE_REFINEMENT, TILE_CONTENT_STATE, TILESET_TYPE } from \"../constants.js\";\nimport { createBoundingVolume, getCartographicBounds } from \"./helpers/bounding-volume.js\";\nimport { getTiles3DScreenSpaceError } from \"./helpers/tiles-3d-lod.js\";\nimport { getProjectedRadius } from \"./helpers/i3s-lod.js\";\nimport { get3dTilesOptions } from \"./helpers/3d-tiles-options.js\";\nimport { TilesetTraverser } from \"./tileset-traverser.js\";\nconst scratchVector = new Vector3();\nfunction defined(x) {\n    return x !== undefined && x !== null;\n}\n/**\n * A Tile3DHeader represents a tile as Tileset3D. When a tile is first created, its content is not loaded;\n * the content is loaded on-demand when needed based on the view.\n * Do not construct this directly, instead access tiles through {@link Tileset3D#tileVisible}.\n */\nexport class Tile3D {\n    tileset;\n    header;\n    id;\n    url;\n    parent;\n    /* Specifies the type of refine that is used when traversing this tile for rendering. */\n    refine;\n    type;\n    contentUrl;\n    /** Different refinement algorithms used by I3S and 3D tiles */\n    lodMetricType = 'geometricError';\n    /** The error, in meters, introduced if this tile is rendered and its children are not. */\n    lodMetricValue = 0;\n    /** @todo math.gl is not exporting BoundingVolume base type? */\n    boundingVolume = null;\n    /**\n     * The tile's content.  This represents the actual tile's payload,\n     * not the content's metadata in the tileset JSON file.\n     */\n    content = null;\n    contentState = TILE_CONTENT_STATE.UNLOADED;\n    gpuMemoryUsageInBytes = 0;\n    /** The tile's children - an array of Tile3D objects. */\n    children = [];\n    depth = 0;\n    viewportIds = [];\n    transform = new Matrix4();\n    extensions = null;\n    /** TODO Cesium 3d tiles specific */\n    implicitTiling = null;\n    /** Container to store application specific data */\n    userData = {};\n    computedTransform;\n    hasEmptyContent = false;\n    hasTilesetContent = false;\n    traverser = new TilesetTraverser({});\n    /** Used by TilesetCache */\n    _cacheNode = null;\n    _frameNumber = null;\n    // TODO Cesium 3d tiles specific\n    _expireDate = null;\n    _expiredContent = null;\n    _boundingBox = undefined;\n    /** updated every frame for tree traversal and rendering optimizations: */\n    _distanceToCamera = 0;\n    _screenSpaceError = 0;\n    _visibilityPlaneMask;\n    _visible = undefined;\n    _contentBoundingVolume;\n    _viewerRequestVolume;\n    _initialTransform = new Matrix4();\n    // Used by traverser, cannot be marked private\n    _priority = 0;\n    _selectedFrame = 0;\n    _requestedFrame = 0;\n    _selectionDepth = 0;\n    _touchedFrame = 0;\n    _centerZDepth = 0;\n    _shouldRefine = false;\n    _stackLength = 0;\n    _visitedFrame = 0;\n    _inRequestVolume = false;\n    _lodJudge = null; // TODO i3s specific, needs to remove\n    /**\n     * @constructs\n     * Create a Tile3D instance\n     * @param tileset - Tileset3D instance\n     * @param header - tile header - JSON loaded from a dataset\n     * @param parentHeader - parent Tile3D instance\n     * @param extendedId - optional ID to separate copies of a tile for different viewports.\n     *    const extendedId = `${tile.id}-${frameState.viewport.id}`;\n     */\n    // eslint-disable-next-line max-statements\n    constructor(tileset, header, parentHeader, extendedId = '') {\n        // PUBLIC MEMBERS\n        // original tile data\n        this.header = header;\n        // The tileset containing this tile.\n        this.tileset = tileset;\n        this.id = extendedId || header.id;\n        this.url = header.url;\n        // This tile's parent or `undefined` if this tile is the root.\n        // @ts-ignore\n        this.parent = parentHeader;\n        this.refine = this._getRefine(header.refine);\n        this.type = header.type;\n        this.contentUrl = header.contentUrl;\n        this._initializeLodMetric(header);\n        this._initializeTransforms(header);\n        this._initializeBoundingVolumes(header);\n        this._initializeContent(header);\n        this._initializeRenderingState(header);\n        Object.seal(this);\n    }\n    destroy() {\n        this.header = null;\n    }\n    isDestroyed() {\n        return this.header === null;\n    }\n    get selected() {\n        return this._selectedFrame === this.tileset._frameNumber;\n    }\n    get isVisible() {\n        return this._visible;\n    }\n    get isVisibleAndInRequestVolume() {\n        return this._visible && this._inRequestVolume;\n    }\n    /** Returns true if tile is not an empty tile and not an external tileset */\n    get hasRenderContent() {\n        return !this.hasEmptyContent && !this.hasTilesetContent;\n    }\n    /** Returns true if tile has children */\n    get hasChildren() {\n        return this.children.length > 0 || (this.header.children && this.header.children.length > 0);\n    }\n    /**\n     * Determines if the tile's content is ready. This is automatically `true` for\n     * tiles with empty content.\n     */\n    get contentReady() {\n        return this.contentState === TILE_CONTENT_STATE.READY || this.hasEmptyContent;\n    }\n    /**\n     * Determines if the tile has available content to render.  `true` if the tile's\n     * content is ready or if it has expired content this renders while new content loads; otherwise,\n     */\n    get contentAvailable() {\n        return Boolean((this.contentReady && this.hasRenderContent) || (this._expiredContent && !this.contentFailed));\n    }\n    /** Returns true if tile has renderable content but it's unloaded */\n    get hasUnloadedContent() {\n        return this.hasRenderContent && this.contentUnloaded;\n    }\n    /**\n     * Determines if the tile's content has not be requested. `true` if tile's\n     * content has not be requested; otherwise, `false`.\n     */\n    get contentUnloaded() {\n        return this.contentState === TILE_CONTENT_STATE.UNLOADED;\n    }\n    /**\n     * Determines if the tile's content is expired. `true` if tile's\n     * content is expired; otherwise, `false`.\n     */\n    get contentExpired() {\n        return this.contentState === TILE_CONTENT_STATE.EXPIRED;\n    }\n    // Determines if the tile's content failed to load.  `true` if the tile's\n    // content failed to load; otherwise, `false`.\n    get contentFailed() {\n        return this.contentState === TILE_CONTENT_STATE.FAILED;\n    }\n    /**\n     * Distance from the tile's bounding volume center to the camera\n     */\n    get distanceToCamera() {\n        return this._distanceToCamera;\n    }\n    /**\n     * Screen space error for LOD selection\n     */\n    get screenSpaceError() {\n        return this._screenSpaceError;\n    }\n    /**\n     * Get bounding box in cartographic coordinates\n     * @returns [min, max] each in [longitude, latitude, altitude]\n     */\n    get boundingBox() {\n        if (!this._boundingBox) {\n            this._boundingBox = getCartographicBounds(this.header.boundingVolume, this.boundingVolume);\n        }\n        return this._boundingBox;\n    }\n    /** Get the tile's screen space error. */\n    getScreenSpaceError(frameState, useParentLodMetric) {\n        switch (this.tileset.type) {\n            case TILESET_TYPE.I3S:\n                return getProjectedRadius(this, frameState);\n            case TILESET_TYPE.TILES3D:\n                return getTiles3DScreenSpaceError(this, frameState, useParentLodMetric);\n            default:\n                // eslint-disable-next-line\n                throw new Error('Unsupported tileset type');\n        }\n    }\n    /**\n     * Make tile unselected than means it won't be shown\n     * but it can be still loaded in memory\n     */\n    unselect() {\n        this._selectedFrame = 0;\n    }\n    /**\n     * Memory usage of tile on GPU\n     */\n    _getGpuMemoryUsageInBytes() {\n        return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;\n    }\n    /*\n     * If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.\n     * Tiles are prioritized by screen space error.\n     */\n    // eslint-disable-next-line complexity\n    _getPriority() {\n        const traverser = this.tileset._traverser;\n        const { skipLevelOfDetail } = traverser.options;\n        /*\n         * Tiles that are outside of the camera's frustum could be skipped if we are in 'ADD' mode\n         * or if we are using 'Skip Traversal' in 'REPLACE' mode.\n         * Otherewise, all 'touched' child tiles have to be loaded and displayed,\n         * this may include tiles that are outide of the camera frustum (so that we can hide the parent tile).\n         */\n        const maySkipTile = this.refine === TILE_REFINEMENT.ADD || skipLevelOfDetail;\n        // Check if any reason to abort\n        if (maySkipTile && !this.isVisible && this._visible !== undefined) {\n            return -1;\n        }\n        // Condition used in `cancelOutOfViewRequests` function in CesiumJS/Cesium3DTileset.js\n        if (this.tileset._frameNumber - this._touchedFrame >= 1) {\n            return -1;\n        }\n        if (this.contentState === TILE_CONTENT_STATE.UNLOADED) {\n            return -1;\n        }\n        // Based on the priority function `getPriorityReverseScreenSpaceError` in CesiumJS. Scheduling priority is based on the parent's screen space error when possible.\n        const parent = this.parent;\n        const useParentScreenSpaceError = parent && (!maySkipTile || this._screenSpaceError === 0.0 || parent.hasTilesetContent);\n        const screenSpaceError = useParentScreenSpaceError\n            ? parent._screenSpaceError\n            : this._screenSpaceError;\n        const rootScreenSpaceError = traverser.root ? traverser.root._screenSpaceError : 0.0;\n        // Map higher SSE to lower values (e.g. root tile is highest priority)\n        return Math.max(rootScreenSpaceError - screenSpaceError, 0);\n    }\n    /**\n     *  Requests the tile's content.\n     * The request may not be made if the Request Scheduler can't prioritize it.\n     */\n    // eslint-disable-next-line max-statements, complexity\n    async loadContent() {\n        if (this.hasEmptyContent) {\n            return false;\n        }\n        if (this.content) {\n            return true;\n        }\n        const expired = this.contentExpired;\n        if (expired) {\n            this._expireDate = null;\n        }\n        this.contentState = TILE_CONTENT_STATE.LOADING;\n        const requestToken = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));\n        if (!requestToken) {\n            // cancelled\n            this.contentState = TILE_CONTENT_STATE.UNLOADED;\n            return false;\n        }\n        try {\n            const contentUrl = this.tileset.getTileUrl(this.contentUrl);\n            // The content can be a binary tile ot a JSON tileset\n            const loader = this.tileset.loader;\n            const options = {\n                ...this.tileset.loadOptions,\n                [loader.id]: {\n                    // @ts-expect-error\n                    ...this.tileset.loadOptions[loader.id],\n                    isTileset: this.type === 'json',\n                    ...this._getLoaderSpecificOptions(loader.id)\n                }\n            };\n            this.content = await load(contentUrl, loader, options);\n            if (this.tileset.options.contentLoader) {\n                await this.tileset.options.contentLoader(this);\n            }\n            if (this._isTileset()) {\n                // Add tile headers for the nested tilset's subtree\n                // Async update of the tree should be fine since there would never be edits to the same node\n                // TODO - we need to capture the child tileset's URL\n                this.tileset._initializeTileHeaders(this.content, this);\n            }\n            this.contentState = TILE_CONTENT_STATE.READY;\n            this._onContentLoaded();\n            return true;\n        }\n        catch (error) {\n            // Tile is unloaded before the content finishes loading\n            this.contentState = TILE_CONTENT_STATE.FAILED;\n            throw error;\n        }\n        finally {\n            requestToken.done();\n        }\n    }\n    // Unloads the tile's content.\n    unloadContent() {\n        if (this.content && this.content.destroy) {\n            this.content.destroy();\n        }\n        this.content = null;\n        if (this.header.content && this.header.content.destroy) {\n            this.header.content.destroy();\n        }\n        this.header.content = null;\n        this.contentState = TILE_CONTENT_STATE.UNLOADED;\n        return true;\n    }\n    /**\n     * Update the tile's visibility\n     * @param {Object} frameState - frame state for tile culling\n     * @param {string[]} viewportIds - a list of viewport ids that show this tile\n     * @return {void}\n     */\n    updateVisibility(frameState, viewportIds) {\n        if (this._frameNumber === frameState.frameNumber) {\n            // Return early if visibility has already been checked during the traversal.\n            // The visibility may have already been checked if the cullWithChildrenBounds optimization is used.\n            return;\n        }\n        const parent = this.parent;\n        const parentVisibilityPlaneMask = parent\n            ? parent._visibilityPlaneMask\n            : CullingVolume.MASK_INDETERMINATE;\n        if (this.tileset._traverser.options.updateTransforms) {\n            const parentTransform = parent ? parent.computedTransform : this.tileset.modelMatrix;\n            this._updateTransform(parentTransform);\n        }\n        this._distanceToCamera = this.distanceToTile(frameState);\n        this._screenSpaceError = this.getScreenSpaceError(frameState, false);\n        this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask); // Use parent's plane mask to speed up visibility test\n        this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;\n        this._inRequestVolume = this.insideViewerRequestVolume(frameState);\n        this._frameNumber = frameState.frameNumber;\n        this.viewportIds = viewportIds;\n    }\n    // Determines whether the tile's bounding volume intersects the culling volume.\n    // @param {FrameState} frameState The frame state.\n    // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.\n    // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.\n    visibility(frameState, parentVisibilityPlaneMask) {\n        const { cullingVolume } = frameState;\n        const { boundingVolume } = this;\n        // TODO Cesium specific - restore clippingPlanes\n        // const {clippingPlanes, clippingPlanesOriginMatrix} = tileset;\n        // if (clippingPlanes && clippingPlanes.enabled) {\n        //   const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n        //     boundingVolume,\n        //     clippingPlanesOriginMatrix\n        //   );\n        //   this._isClipped = intersection !== Intersect.INSIDE;\n        //   if (intersection === Intersect.OUTSIDE) {\n        //     return CullingVolume.MASK_OUTSIDE;\n        //   }\n        // }\n        // return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n        return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n    }\n    // Assuming the tile's bounding volume intersects the culling volume, determines\n    // whether the tile's content's bounding volume intersects the culling volume.\n    // @param {FrameState} frameState The frame state.\n    // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.\n    contentVisibility() {\n        return true;\n        // TODO restore\n        /*\n        // Assumes the tile's bounding volume intersects the culling volume already, so\n        // just return Intersect.INSIDE if there is no content bounding volume.\n        if (!defined(this.contentBoundingVolume)) {\n          return Intersect.INSIDE;\n        }\n    \n        if (this._visibilityPlaneMask === CullingVolume.MASK_INSIDE) {\n          // The tile's bounding volume is completely inside the culling volume so\n          // the content bounding volume must also be inside.\n          return Intersect.INSIDE;\n        }\n    \n        // PERFORMANCE_IDEA: is it possible to burn less CPU on this test since we know the\n        // tile's (not the content's) bounding volume intersects the culling volume?\n        const cullingVolume = frameState.cullingVolume;\n        const boundingVolume = tile.contentBoundingVolume;\n    \n        const tileset = this.tileset;\n        const clippingPlanes = tileset.clippingPlanes;\n        if (defined(clippingPlanes) && clippingPlanes.enabled) {\n          const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n            boundingVolume,\n            tileset.clippingPlanesOriginMatrix\n          );\n          this._isClipped = intersection !== Intersect.INSIDE;\n          if (intersection === Intersect.OUTSIDE) {\n            return Intersect.OUTSIDE;\n          }\n        }\n    \n        return cullingVolume.computeVisibility(boundingVolume);\n        */\n    }\n    /**\n     * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.\n     * @param frameState The frame state.\n     * @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.\n     */\n    distanceToTile(frameState) {\n        const boundingVolume = this.boundingVolume;\n        return Math.sqrt(Math.max(boundingVolume.distanceSquaredTo(frameState.camera.position), 0));\n    }\n    /**\n     * Computes the tile's camera-space z-depth.\n     * @param frameState The frame state.\n     * @returns The distance, in meters.\n     */\n    cameraSpaceZDepth({ camera }) {\n        const boundingVolume = this.boundingVolume; // Gets the underlying OrientedBoundingBox or BoundingSphere\n        scratchVector.subVectors(boundingVolume.center, camera.position);\n        return camera.direction.dot(scratchVector);\n    }\n    /**\n     * Checks if the camera is inside the viewer request volume.\n     * @param {FrameState} frameState The frame state.\n     * @returns {Boolean} Whether the camera is inside the volume.\n     */\n    insideViewerRequestVolume(frameState) {\n        const viewerRequestVolume = this._viewerRequestVolume;\n        return (!viewerRequestVolume || viewerRequestVolume.distanceSquaredTo(frameState.camera.position) <= 0);\n    }\n    // TODO Cesium specific\n    // Update whether the tile has expired.\n    updateExpiration() {\n        if (defined(this._expireDate) && this.contentReady && !this.hasEmptyContent) {\n            const now = Date.now();\n            // @ts-ignore Date.lessThan - replace with ms compare?\n            if (Date.lessThan(this._expireDate, now)) {\n                this.contentState = TILE_CONTENT_STATE.EXPIRED;\n                this._expiredContent = this.content;\n            }\n        }\n    }\n    get extras() {\n        return this.header.extras;\n    }\n    // INTERNAL METHODS\n    _initializeLodMetric(header) {\n        if ('lodMetricType' in header) {\n            this.lodMetricType = header.lodMetricType;\n        }\n        else {\n            this.lodMetricType = (this.parent && this.parent.lodMetricType) || this.tileset.lodMetricType;\n            // eslint-disable-next-line\n            console.warn(`3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType`);\n        }\n        // This is used to compute screen space error, i.e., the error measured in pixels.\n        if ('lodMetricValue' in header) {\n            this.lodMetricValue = header.lodMetricValue;\n        }\n        else {\n            this.lodMetricValue =\n                (this.parent && this.parent.lodMetricValue) || this.tileset.lodMetricValue;\n            // eslint-disable-next-line\n            console.warn('3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue');\n        }\n    }\n    _initializeTransforms(tileHeader) {\n        // The local transform of this tile.\n        this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();\n        const parent = this.parent;\n        const tileset = this.tileset;\n        const parentTransform = parent && parent.computedTransform\n            ? parent.computedTransform.clone()\n            : tileset.modelMatrix.clone();\n        this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);\n        const parentInitialTransform = parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();\n        this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);\n    }\n    _initializeBoundingVolumes(tileHeader) {\n        this._contentBoundingVolume = null;\n        this._viewerRequestVolume = null;\n        this._updateBoundingVolume(tileHeader);\n    }\n    _initializeContent(tileHeader) {\n        // Empty tile by default\n        this.content = { _tileset: this.tileset, _tile: this };\n        this.hasEmptyContent = true;\n        this.contentState = TILE_CONTENT_STATE.UNLOADED;\n        // When `true`, the tile's content points to an external tileset.\n        // This is `false` until the tile's content is loaded.\n        this.hasTilesetContent = false;\n        if (tileHeader.contentUrl) {\n            this.content = null;\n            this.hasEmptyContent = false;\n        }\n    }\n    // TODO - remove anything not related to basic visibility detection\n    _initializeRenderingState(header) {\n        this.depth = header.level || (this.parent ? this.parent.depth + 1 : 0);\n        this._shouldRefine = false;\n        // Members this are updated every frame for tree traversal and rendering optimizations:\n        this._distanceToCamera = 0;\n        this._centerZDepth = 0;\n        this._screenSpaceError = 0;\n        this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;\n        this._visible = undefined;\n        this._inRequestVolume = false;\n        this._stackLength = 0;\n        this._selectionDepth = 0;\n        this._frameNumber = 0;\n        this._touchedFrame = 0;\n        this._visitedFrame = 0;\n        this._selectedFrame = 0;\n        this._requestedFrame = 0;\n        this._priority = 0.0;\n    }\n    _getRefine(refine) {\n        // Inherit from parent tile if omitted.\n        return refine || (this.parent && this.parent.refine) || TILE_REFINEMENT.REPLACE;\n    }\n    _isTileset() {\n        return this.contentUrl.indexOf('.json') !== -1;\n    }\n    _onContentLoaded() {\n        // Vector and Geometry tile rendering do not support the skip LOD optimization.\n        switch (this.content && this.content.type) {\n            case 'vctr':\n            case 'geom':\n                // @ts-ignore\n                this.tileset._traverser.disableSkipLevelOfDetail = true;\n                break;\n            default:\n        }\n        // The content may be tileset json\n        if (this._isTileset()) {\n            this.hasTilesetContent = true;\n        }\n        else {\n            this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();\n        }\n    }\n    _updateBoundingVolume(header) {\n        // Update the bounding volumes\n        this.boundingVolume = createBoundingVolume(header.boundingVolume, this.computedTransform, this.boundingVolume);\n        const content = header.content;\n        if (!content) {\n            return;\n        }\n        // TODO Cesium specific\n        // Non-leaf tiles may have a content bounding-volume, which is a tight-fit bounding volume\n        // around only the features in the tile. This box is useful for culling for rendering,\n        // but not for culling for traversing the tree since it does not guarantee spatial coherence, i.e.,\n        // since it only bounds features in the tile, not the entire tile, children may be\n        // outside of this box.\n        if (content.boundingVolume) {\n            this._contentBoundingVolume = createBoundingVolume(content.boundingVolume, this.computedTransform, this._contentBoundingVolume);\n        }\n        if (header.viewerRequestVolume) {\n            this._viewerRequestVolume = createBoundingVolume(header.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume);\n        }\n    }\n    // Update the tile's transform. The transform is applied to the tile's bounding volumes.\n    _updateTransform(parentTransform = new Matrix4()) {\n        const computedTransform = parentTransform.clone().multiplyRight(this.transform);\n        const didTransformChange = !computedTransform.equals(this.computedTransform);\n        if (!didTransformChange) {\n            return;\n        }\n        this.computedTransform = computedTransform;\n        this._updateBoundingVolume(this.header);\n    }\n    // Get options which are applicable only for the particular loader\n    _getLoaderSpecificOptions(loaderId) {\n        switch (loaderId) {\n            case 'i3s':\n                return {\n                    ...this.tileset.options.i3s,\n                    _tileOptions: {\n                        attributeUrls: this.header.attributeUrls,\n                        textureUrl: this.header.textureUrl,\n                        textureFormat: this.header.textureFormat,\n                        textureLoaderOptions: this.header.textureLoaderOptions,\n                        materialDefinition: this.header.materialDefinition,\n                        isDracoGeometry: this.header.isDracoGeometry,\n                        mbs: this.header.mbs\n                    },\n                    _tilesetOptions: {\n                        store: this.tileset.tileset.store,\n                        attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,\n                        fields: this.tileset.tileset.fields\n                    },\n                    isTileHeader: false\n                };\n            case '3d-tiles':\n            case 'cesium-ion':\n            default:\n                return get3dTilesOptions(this.tileset.tileset);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}