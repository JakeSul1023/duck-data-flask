{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Timeline } from '@luma.gl/engine';\nimport { getShaderAssembler, layerUniforms } from \"../shaderlib/index.js\";\nimport { LIFECYCLE } from \"../lifecycle/constants.js\";\nimport log from \"../utils/log.js\";\nimport debug from \"../debug/index.js\";\nimport { flatten } from \"../utils/flatten.js\";\nimport { Stats } from '@probe.gl/stats';\nimport ResourceManager from \"./resource/resource-manager.js\";\nimport Viewport from \"../viewports/viewport.js\";\nconst TRACE_SET_LAYERS = 'layerManager.setLayers';\nconst TRACE_ACTIVATE_VIEWPORT = 'layerManager.activateViewport';\nexport default class LayerManager {\n  /**\n   * @param device\n   * @param param1\n   */\n  // eslint-disable-next-line\n  constructor(device, props) {\n    this._lastRenderedLayers = [];\n    this._needsRedraw = false;\n    this._needsUpdate = false;\n    this._nextLayers = null;\n    this._debug = false;\n    // This flag is separate from _needsUpdate because it can be set during an update and should trigger another full update\n    this._defaultShaderModulesChanged = false;\n    //\n    // INTERNAL METHODS\n    //\n    /** Make a viewport \"current\" in layer context, updating viewportChanged flags */\n    this.activateViewport = viewport => {\n      debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);\n      if (viewport) {\n        this.context.viewport = viewport;\n      }\n    };\n    const {\n      deck,\n      stats,\n      viewport,\n      timeline\n    } = props || {};\n    // Currently deck.gl expects the DeckGL.layers array to be different\n    // whenever React rerenders. If the same layers array is used, the\n    // LayerManager's diffing algorithm will generate a fatal error and\n    // break the rendering.\n    // `this._lastRenderedLayers` stores the UNFILTERED layers sent\n    // down to LayerManager, so that `layers` reference can be compared.\n    // If it's the same across two React render calls, the diffing logic\n    // will be skipped.\n    this.layers = [];\n    this.resourceManager = new ResourceManager({\n      device,\n      protocol: 'deck://'\n    });\n    this.context = {\n      mousePosition: null,\n      userData: {},\n      layerManager: this,\n      device,\n      // @ts-expect-error\n      gl: device?.gl,\n      deck,\n      shaderAssembler: getShaderAssembler(device?.info?.shadingLanguage || 'glsl'),\n      defaultShaderModules: [layerUniforms],\n      renderPass: undefined,\n      stats: stats || new Stats({\n        id: 'deck.gl'\n      }),\n      // Make sure context.viewport is not empty on the first layer initialization\n      viewport: viewport || new Viewport({\n        id: 'DEFAULT-INITIAL-VIEWPORT'\n      }),\n      // Current viewport, exposed to layers for project* function\n      timeline: timeline || new Timeline(),\n      resourceManager: this.resourceManager,\n      onError: undefined\n    };\n    Object.seal(this);\n  }\n  /** Method to call when the layer manager is not needed anymore. */\n  finalize() {\n    this.resourceManager.finalize();\n    // Finalize all layers\n    for (const layer of this.layers) {\n      this._finalizeLayer(layer);\n    }\n  }\n  /** Check if a redraw is needed */\n  needsRedraw(opts = {\n    clearRedrawFlags: false\n  }) {\n    let redraw = this._needsRedraw;\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n    // This layers list doesn't include sublayers, relying on composite layers\n    for (const layer of this.layers) {\n      // Call every layer to clear their flags\n      const layerNeedsRedraw = layer.getNeedsRedraw(opts);\n      redraw = redraw || layerNeedsRedraw;\n    }\n    return redraw;\n  }\n  /** Check if a deep update of all layers is needed */\n  needsUpdate() {\n    if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {\n      // New layers array may be the same as the old one if `setProps` is called by React\n      return 'layers changed';\n    }\n    if (this._defaultShaderModulesChanged) {\n      return 'shader modules changed';\n    }\n    return this._needsUpdate;\n  }\n  /** Layers will be redrawn (in next animation frame) */\n  setNeedsRedraw(reason) {\n    this._needsRedraw = this._needsRedraw || reason;\n  }\n  /** Layers will be updated deeply (in next animation frame)\n    Potentially regenerating attributes and sub layers */\n  setNeedsUpdate(reason) {\n    this._needsUpdate = this._needsUpdate || reason;\n  }\n  /** Gets a list of currently rendered layers. Optionally filter by id. */\n  getLayers({\n    layerIds\n  } = {}) {\n    // Filtering by layerId compares beginning of strings, so that sublayers will be included\n    // Dependes on the convention of adding suffixes to the parent's layer name\n    return layerIds ? this.layers.filter(layer => layerIds.find(layerId => layer.id.indexOf(layerId) === 0)) : this.layers;\n  }\n  /** Set props needed for layer rendering and picking. */\n  setProps(props) {\n    if ('debug' in props) {\n      this._debug = props.debug;\n    }\n    // A way for apps to add data to context that can be accessed in layers\n    if ('userData' in props) {\n      this.context.userData = props.userData;\n    }\n    // New layers will be processed in `updateLayers` in the next update cycle\n    if ('layers' in props) {\n      this._nextLayers = props.layers;\n    }\n    if ('onError' in props) {\n      this.context.onError = props.onError;\n    }\n  }\n  /** Supply a new layer list, initiating sublayer generation and layer matching */\n  setLayers(newLayers, reason) {\n    debug(TRACE_SET_LAYERS, this, reason, newLayers);\n    this._lastRenderedLayers = newLayers;\n    const flatLayers = flatten(newLayers, Boolean);\n    for (const layer of flatLayers) {\n      layer.context = this.context;\n    }\n    this._updateLayers(this.layers, flatLayers);\n  }\n  /** Update layers from last cycle if `setNeedsUpdate()` has been called */\n  updateLayers() {\n    // NOTE: For now, even if only some layer has changed, we update all layers\n    // to ensure that layer id maps etc remain consistent even if different\n    // sublayers are rendered\n    const reason = this.needsUpdate();\n    if (reason) {\n      this.setNeedsRedraw(`updating layers: ${reason}`);\n      // Force a full update\n      this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);\n    }\n    // Updated, clear the backlog\n    this._nextLayers = null;\n  }\n  /** Register a default shader module */\n  addDefaultShaderModule(module) {\n    const {\n      defaultShaderModules\n    } = this.context;\n    if (!defaultShaderModules.find(m => m.name === module.name)) {\n      defaultShaderModules.push(module);\n      this._defaultShaderModulesChanged = true;\n    }\n  }\n  /** Deregister a default shader module */\n  removeDefaultShaderModule(module) {\n    const {\n      defaultShaderModules\n    } = this.context;\n    const i = defaultShaderModules.findIndex(m => m.name === module.name);\n    if (i >= 0) {\n      defaultShaderModules.splice(i, 1);\n      this._defaultShaderModulesChanged = true;\n    }\n  }\n  _handleError(stage, error, layer) {\n    layer.raiseError(error, `${stage} of ${layer}`);\n  }\n  // TODO - mark layers with exceptions as bad and remove from rendering cycle?\n  /** Match all layers, checking for caught errors\n    to avoid having an exception in one layer disrupt other layers */\n  _updateLayers(oldLayers, newLayers) {\n    // Create old layer map\n    const oldLayerMap = {};\n    for (const oldLayer of oldLayers) {\n      if (oldLayerMap[oldLayer.id]) {\n        log.warn(`Multiple old layers with same id ${oldLayer.id}`)();\n      } else {\n        oldLayerMap[oldLayer.id] = oldLayer;\n      }\n    }\n    if (this._defaultShaderModulesChanged) {\n      for (const layer of oldLayers) {\n        layer.setNeedsUpdate();\n        layer.setChangeFlags({\n          extensionsChanged: true\n        });\n      }\n      this._defaultShaderModulesChanged = false;\n    }\n    // Allocate array for generated layers\n    const generatedLayers = [];\n    // Match sublayers\n    this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);\n    // Finalize unmatched layers\n    this._finalizeOldLayers(oldLayerMap);\n    let needsUpdate = false;\n    for (const layer of generatedLayers) {\n      if (layer.hasUniformTransition()) {\n        needsUpdate = `Uniform transition in ${layer}`;\n        break;\n      }\n    }\n    this._needsUpdate = needsUpdate;\n    this.layers = generatedLayers;\n  }\n  /* eslint-disable complexity,max-statements */\n  // Note: adds generated layers to `generatedLayers` array parameter\n  _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {\n    for (const newLayer of newLayers) {\n      newLayer.context = this.context;\n      // Given a new coming layer, find its matching old layer (if any)\n      const oldLayer = oldLayerMap[newLayer.id];\n      if (oldLayer === null) {\n        // null, rather than undefined, means this id was originally there\n        log.warn(`Multiple new layers with same id ${newLayer.id}`)();\n      }\n      // Remove the old layer from candidates, as it has been matched with this layer\n      oldLayerMap[newLayer.id] = null;\n      let sublayers = null;\n      // We must not generate exceptions until after layer matching is complete\n      try {\n        if (this._debug && oldLayer !== newLayer) {\n          newLayer.validateProps();\n        }\n        if (!oldLayer) {\n          this._initializeLayer(newLayer);\n        } else {\n          this._transferLayerState(oldLayer, newLayer);\n          this._updateLayer(newLayer);\n        }\n        generatedLayers.push(newLayer);\n        // Call layer lifecycle method: render sublayers\n        sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;\n        // End layer lifecycle method: render sublayers\n      } catch (err) {\n        this._handleError('matching', err, newLayer); // Record first exception\n      }\n      if (sublayers) {\n        this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);\n      }\n    }\n  }\n  /* eslint-enable complexity,max-statements */\n  // Finalize any old layers that were not matched\n  _finalizeOldLayers(oldLayerMap) {\n    for (const layerId in oldLayerMap) {\n      const layer = oldLayerMap[layerId];\n      if (layer) {\n        this._finalizeLayer(layer);\n      }\n    }\n  }\n  // / EXCEPTION SAFE LAYER ACCESS\n  /** Safely initializes a single layer, calling layer methods */\n  _initializeLayer(layer) {\n    try {\n      layer._initialize();\n      layer.lifecycle = LIFECYCLE.INITIALIZED;\n    } catch (err) {\n      this._handleError('initialization', err, layer);\n      // TODO - what should the lifecycle state be here? LIFECYCLE.INITIALIZATION_FAILED?\n    }\n  }\n  /** Transfer state from one layer to a newer version */\n  _transferLayerState(oldLayer, newLayer) {\n    newLayer._transferState(oldLayer);\n    newLayer.lifecycle = LIFECYCLE.MATCHED;\n    if (newLayer !== oldLayer) {\n      oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;\n    }\n  }\n  /** Safely updates a single layer, cleaning all flags */\n  _updateLayer(layer) {\n    try {\n      layer._update();\n    } catch (err) {\n      this._handleError('update', err, layer);\n    }\n  }\n  /** Safely finalizes a single layer, removing all resources */\n  _finalizeLayer(layer) {\n    this._needsRedraw = this._needsRedraw || `finalized ${layer}`;\n    layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;\n    try {\n      layer._finalize();\n      layer.lifecycle = LIFECYCLE.FINALIZED;\n    } catch (err) {\n      this._handleError('finalization', err, layer);\n    }\n  }\n}\n//# sourceMappingURL=layer-manager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}