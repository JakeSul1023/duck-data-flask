{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Extract mipmap images from compressed texture buffer\n * @param data - binary data of compressed texture or Array of level objects\n * @param options.mipMapLevels - number of mipmap level inside image\n * @param options.width - width of 0 - level\n * @param options.height - height of 0 - level\n * @param options.sizeFunction - format-related function to calculate level size in bytes\n * @param options.internalFormat - WebGL compatible format code\n * @returns Array of the texture levels\n */\nexport function extractMipmapImages(data, options) {\n  const images = new Array(options.mipMapLevels);\n  let levelWidth = options.width;\n  let levelHeight = options.height;\n  let offset = 0;\n  for (let i = 0; i < options.mipMapLevels; ++i) {\n    // @ts-expect-error\n    const levelSize = getLevelSize(options, levelWidth, levelHeight, data, i);\n    // @ts-expect-error\n    const levelData = getLevelData(data, i, offset, levelSize);\n    images[i] = {\n      compressed: true,\n      format: options.internalFormat,\n      data: levelData,\n      width: levelWidth,\n      height: levelHeight,\n      levelSize\n    };\n    levelWidth = Math.max(1, levelWidth >> 1);\n    levelHeight = Math.max(1, levelHeight >> 1);\n    offset += levelSize;\n  }\n  return images;\n}\nfunction getLevelData(data, index, offset, levelSize) {\n  if (!Array.isArray(data)) {\n    return new Uint8Array(data.buffer, data.byteOffset + offset, levelSize);\n  }\n  return data[index].levelData;\n}\nfunction getLevelSize(options, levelWidth, levelHeight, data, index) {\n  if (!Array.isArray(data)) {\n    return options.sizeFunction(levelWidth, levelHeight);\n  }\n  return options.sizeFunction(data[index]);\n}","map":{"version":3,"names":["extractMipmapImages","data","options","images","Array","mipMapLevels","levelWidth","width","levelHeight","height","offset","i","levelSize","getLevelSize","levelData","getLevelData","compressed","format","internalFormat","Math","max","index","isArray","Uint8Array","buffer","byteOffset","sizeFunction"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/textures/dist/lib/utils/extract-mipmap-images.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Extract mipmap images from compressed texture buffer\n * @param data - binary data of compressed texture or Array of level objects\n * @param options.mipMapLevels - number of mipmap level inside image\n * @param options.width - width of 0 - level\n * @param options.height - height of 0 - level\n * @param options.sizeFunction - format-related function to calculate level size in bytes\n * @param options.internalFormat - WebGL compatible format code\n * @returns Array of the texture levels\n */\nexport function extractMipmapImages(data, options) {\n    const images = new Array(options.mipMapLevels);\n    let levelWidth = options.width;\n    let levelHeight = options.height;\n    let offset = 0;\n    for (let i = 0; i < options.mipMapLevels; ++i) {\n        // @ts-expect-error\n        const levelSize = getLevelSize(options, levelWidth, levelHeight, data, i);\n        // @ts-expect-error\n        const levelData = getLevelData(data, i, offset, levelSize);\n        images[i] = {\n            compressed: true,\n            format: options.internalFormat,\n            data: levelData,\n            width: levelWidth,\n            height: levelHeight,\n            levelSize\n        };\n        levelWidth = Math.max(1, levelWidth >> 1);\n        levelHeight = Math.max(1, levelHeight >> 1);\n        offset += levelSize;\n    }\n    return images;\n}\nfunction getLevelData(data, index, offset, levelSize) {\n    if (!Array.isArray(data)) {\n        return new Uint8Array(data.buffer, data.byteOffset + offset, levelSize);\n    }\n    return data[index].levelData;\n}\nfunction getLevelSize(options, levelWidth, levelHeight, data, index) {\n    if (!Array.isArray(data)) {\n        return options.sizeFunction(levelWidth, levelHeight);\n    }\n    return options.sizeFunction(data[index]);\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,mBAAmBA,CAACC,IAAI,EAAEC,OAAO,EAAE;EAC/C,MAAMC,MAAM,GAAG,IAAIC,KAAK,CAACF,OAAO,CAACG,YAAY,CAAC;EAC9C,IAAIC,UAAU,GAAGJ,OAAO,CAACK,KAAK;EAC9B,IAAIC,WAAW,GAAGN,OAAO,CAACO,MAAM;EAChC,IAAIC,MAAM,GAAG,CAAC;EACd,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,OAAO,CAACG,YAAY,EAAE,EAAEM,CAAC,EAAE;IAC3C;IACA,MAAMC,SAAS,GAAGC,YAAY,CAACX,OAAO,EAAEI,UAAU,EAAEE,WAAW,EAAEP,IAAI,EAAEU,CAAC,CAAC;IACzE;IACA,MAAMG,SAAS,GAAGC,YAAY,CAACd,IAAI,EAAEU,CAAC,EAAED,MAAM,EAAEE,SAAS,CAAC;IAC1DT,MAAM,CAACQ,CAAC,CAAC,GAAG;MACRK,UAAU,EAAE,IAAI;MAChBC,MAAM,EAAEf,OAAO,CAACgB,cAAc;MAC9BjB,IAAI,EAAEa,SAAS;MACfP,KAAK,EAAED,UAAU;MACjBG,MAAM,EAAED,WAAW;MACnBI;IACJ,CAAC;IACDN,UAAU,GAAGa,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEd,UAAU,IAAI,CAAC,CAAC;IACzCE,WAAW,GAAGW,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEZ,WAAW,IAAI,CAAC,CAAC;IAC3CE,MAAM,IAAIE,SAAS;EACvB;EACA,OAAOT,MAAM;AACjB;AACA,SAASY,YAAYA,CAACd,IAAI,EAAEoB,KAAK,EAAEX,MAAM,EAAEE,SAAS,EAAE;EAClD,IAAI,CAACR,KAAK,CAACkB,OAAO,CAACrB,IAAI,CAAC,EAAE;IACtB,OAAO,IAAIsB,UAAU,CAACtB,IAAI,CAACuB,MAAM,EAAEvB,IAAI,CAACwB,UAAU,GAAGf,MAAM,EAAEE,SAAS,CAAC;EAC3E;EACA,OAAOX,IAAI,CAACoB,KAAK,CAAC,CAACP,SAAS;AAChC;AACA,SAASD,YAAYA,CAACX,OAAO,EAAEI,UAAU,EAAEE,WAAW,EAAEP,IAAI,EAAEoB,KAAK,EAAE;EACjE,IAAI,CAACjB,KAAK,CAACkB,OAAO,CAACrB,IAAI,CAAC,EAAE;IACtB,OAAOC,OAAO,CAACwB,YAAY,CAACpB,UAAU,EAAEE,WAAW,CAAC;EACxD;EACA,OAAON,OAAO,CAACwB,YAAY,CAACzB,IAAI,CAACoB,KAAK,CAAC,CAAC;AAC5C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}