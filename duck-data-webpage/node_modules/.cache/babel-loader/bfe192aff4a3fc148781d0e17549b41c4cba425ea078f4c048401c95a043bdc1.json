{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getMeshBoundingBox } from '@loaders.gl/schema';\nimport decode, { DECODING_STEPS } from \"./decode-quantized-mesh.js\";\nimport { addSkirt } from \"./helpers/skirt.js\";\nexport function parseQuantizedMesh(arrayBuffer, options = {}) {\n  const {\n    bounds\n  } = options;\n  // Don't parse edge indices or format extensions\n  const {\n    header,\n    vertexData,\n    triangleIndices: originalTriangleIndices,\n    westIndices,\n    northIndices,\n    eastIndices,\n    southIndices\n  } = decode(arrayBuffer, DECODING_STEPS.triangleIndices);\n  let triangleIndices = originalTriangleIndices;\n  let attributes = getMeshAttributes(vertexData, header, bounds);\n  // Compute bounding box before adding skirt so that z values are not skewed\n  // TODO: Find bounding box from header, instead of doing extra pass over\n  // vertices.\n  const boundingBox = getMeshBoundingBox(attributes);\n  if (options?.skirtHeight) {\n    const {\n      attributes: newAttributes,\n      triangles: newTriangles\n    } = addSkirt(attributes, triangleIndices, options.skirtHeight, {\n      westIndices,\n      northIndices,\n      eastIndices,\n      southIndices\n    });\n    attributes = newAttributes;\n    triangleIndices = newTriangles;\n  }\n  return {\n    // Data return by this loader implementation\n    loaderData: {\n      header: {}\n    },\n    header: {\n      // @ts-ignore\n      vertexCount: triangleIndices.length,\n      boundingBox\n    },\n    // TODO\n    schema: undefined,\n    topology: 'triangle-list',\n    mode: 4,\n    // TRIANGLES\n    indices: {\n      value: triangleIndices,\n      size: 1\n    },\n    attributes\n  };\n}\nfunction getMeshAttributes(vertexData, header, bounds) {\n  const {\n    minHeight,\n    maxHeight\n  } = header;\n  const [minX, minY, maxX, maxY] = bounds || [0, 0, 1, 1];\n  const xScale = maxX - minX;\n  const yScale = maxY - minY;\n  const zScale = maxHeight - minHeight;\n  const nCoords = vertexData.length / 3;\n  // vec3. x, y defined by bounds, z in meters\n  const positions = new Float32Array(nCoords * 3);\n  // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n  const texCoords = new Float32Array(nCoords * 2);\n  // Data is not interleaved; all u, then all v, then all heights\n  for (let i = 0; i < nCoords; i++) {\n    const x = vertexData[i] / 32767;\n    const y = vertexData[i + nCoords] / 32767;\n    const z = vertexData[i + nCoords * 2] / 32767;\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = y * yScale + minY;\n    positions[3 * i + 2] = z * zScale + minHeight;\n    texCoords[2 * i + 0] = x;\n    texCoords[2 * i + 1] = y;\n  }\n  return {\n    POSITION: {\n      value: positions,\n      size: 3\n    },\n    TEXCOORD_0: {\n      value: texCoords,\n      size: 2\n    }\n    // TODO: Parse normals if they exist in the file\n    // NORMAL: {}, - optional, but creates the high poly look with lighting\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}