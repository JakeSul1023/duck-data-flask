{"ast":null,"code":"// Attributions\n// * Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng\nimport { getISOBMFFMediaType } from \"./parse-isobmff-binary.js\";\nconst BIG_ENDIAN = false;\nconst LITTLE_ENDIAN = true;\n/**\n * Extracts `{mimeType, width and height}` from a memory buffer containing a known image format\n * Currently supports `image/png`, `image/jpeg`, `image/bmp` and `image/gif`.\n * @param binaryData: DataView | ArrayBuffer image file memory to parse\n * @returns metadata or null if memory is not a valid image file format layout.\n */\nexport function getBinaryImageMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);\n}\n// ISOBMFF\nfunction getISOBMFFMetadata(binaryData) {\n  const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);\n  const mediaType = getISOBMFFMediaType(buffer);\n  if (!mediaType) {\n    return null;\n  }\n  return {\n    mimeType: mediaType.mimeType,\n    // TODO - decode width and height\n    width: 0,\n    height: 0\n  };\n}\n// PNG\nfunction getPngMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check file contains the first 4 bytes of the PNG signature.\n  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;\n  if (!isPng) {\n    return null;\n  }\n  // Extract size from a binary PNG file\n  return {\n    mimeType: 'image/png',\n    width: dataView.getUint32(16, BIG_ENDIAN),\n    height: dataView.getUint32(20, BIG_ENDIAN)\n  };\n}\n// GIF\n// Extract size from a binary GIF file\n// TODO: GIF is not this simple\nfunction getGifMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check first 4 bytes of the GIF signature (\"GIF8\").\n  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;\n  if (!isGif) {\n    return null;\n  }\n  // GIF is little endian.\n  return {\n    mimeType: 'image/gif',\n    width: dataView.getUint16(6, LITTLE_ENDIAN),\n    height: dataView.getUint16(8, LITTLE_ENDIAN)\n  };\n}\n// BMP\n// TODO: BMP is not this simple\nexport function getBmpMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check magic number is valid (first 2 characters should be \"BM\").\n  // The mandatory bitmap file header is 14 bytes long.\n  const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 0x424d && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;\n  if (!isBmp) {\n    return null;\n  }\n  // BMP is little endian.\n  return {\n    mimeType: 'image/bmp',\n    width: dataView.getUint32(18, LITTLE_ENDIAN),\n    height: dataView.getUint32(22, LITTLE_ENDIAN)\n  };\n}\n// JPEG\n// Extract width and height from a binary JPEG file\nfunction getJpegMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check file contains the JPEG \"start of image\" (SOI) marker\n  // followed by another marker.\n  const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 && dataView.getUint8(2) === 0xff;\n  if (!isJpeg) {\n    return null;\n  }\n  const {\n    tableMarkers,\n    sofMarkers\n  } = getJpegMarkers();\n  // Exclude the two byte SOI marker.\n  let i = 2;\n  while (i + 9 < dataView.byteLength) {\n    const marker = dataView.getUint16(i, BIG_ENDIAN);\n    // The frame that contains the width and height of the JPEG image.\n    if (sofMarkers.has(marker)) {\n      return {\n        mimeType: 'image/jpeg',\n        height: dataView.getUint16(i + 5, BIG_ENDIAN),\n        // Number of lines\n        width: dataView.getUint16(i + 7, BIG_ENDIAN) // Number of pixels per line\n      };\n    }\n    // Miscellaneous tables/data preceding the frame header.\n    if (!tableMarkers.has(marker)) {\n      return null;\n    }\n    // Length includes size of length parameter but not the two byte header.\n    i += 2;\n    i += dataView.getUint16(i, BIG_ENDIAN);\n  }\n  return null;\n}\nfunction getJpegMarkers() {\n  // Tables/misc header markers.\n  // DQT, DHT, DAC, DRI, COM, APP_n\n  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);\n  for (let i = 0xffe0; i < 0xfff0; ++i) {\n    tableMarkers.add(i);\n  }\n  // SOF markers and DHP marker.\n  // These markers are after tables/misc data.\n  const sofMarkers = new Set([0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce, 0xffcf, 0xffde]);\n  return {\n    tableMarkers,\n    sofMarkers\n  };\n}\n// TODO - move into image module?\nfunction toDataView(data) {\n  if (data instanceof DataView) {\n    return data;\n  }\n  if (ArrayBuffer.isView(data)) {\n    return new DataView(data.buffer);\n  }\n  // TODO: make these functions work for Node.js buffers?\n  // if (bufferToArrayBuffer) {\n  //   data = bufferToArrayBuffer(data);\n  // }\n  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n  if (data instanceof ArrayBuffer) {\n    return new DataView(data);\n  }\n  throw new Error('toDataView');\n}","map":{"version":3,"names":["getISOBMFFMediaType","BIG_ENDIAN","LITTLE_ENDIAN","getBinaryImageMetadata","binaryData","dataView","toDataView","getPngMetadata","getJpegMetadata","getGifMetadata","getBmpMetadata","getISOBMFFMetadata","buffer","Uint8Array","DataView","mediaType","mimeType","width","height","isPng","byteLength","getUint32","isGif","getUint16","isBmp","isJpeg","getUint8","tableMarkers","sofMarkers","getJpegMarkers","i","marker","has","Set","add","data","ArrayBuffer","isView","Error"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/images/dist/lib/category-api/binary-image-api.js"],"sourcesContent":["// Attributions\n// * Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng\nimport { getISOBMFFMediaType } from \"./parse-isobmff-binary.js\";\nconst BIG_ENDIAN = false;\nconst LITTLE_ENDIAN = true;\n/**\n * Extracts `{mimeType, width and height}` from a memory buffer containing a known image format\n * Currently supports `image/png`, `image/jpeg`, `image/bmp` and `image/gif`.\n * @param binaryData: DataView | ArrayBuffer image file memory to parse\n * @returns metadata or null if memory is not a valid image file format layout.\n */\nexport function getBinaryImageMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    return (getPngMetadata(dataView) ||\n        getJpegMetadata(dataView) ||\n        getGifMetadata(dataView) ||\n        getBmpMetadata(dataView) ||\n        getISOBMFFMetadata(dataView));\n}\n// ISOBMFF\nfunction getISOBMFFMetadata(binaryData) {\n    const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);\n    const mediaType = getISOBMFFMediaType(buffer);\n    if (!mediaType) {\n        return null;\n    }\n    return {\n        mimeType: mediaType.mimeType,\n        // TODO - decode width and height\n        width: 0,\n        height: 0\n    };\n}\n// PNG\nfunction getPngMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    // Check file contains the first 4 bytes of the PNG signature.\n    const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;\n    if (!isPng) {\n        return null;\n    }\n    // Extract size from a binary PNG file\n    return {\n        mimeType: 'image/png',\n        width: dataView.getUint32(16, BIG_ENDIAN),\n        height: dataView.getUint32(20, BIG_ENDIAN)\n    };\n}\n// GIF\n// Extract size from a binary GIF file\n// TODO: GIF is not this simple\nfunction getGifMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    // Check first 4 bytes of the GIF signature (\"GIF8\").\n    const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;\n    if (!isGif) {\n        return null;\n    }\n    // GIF is little endian.\n    return {\n        mimeType: 'image/gif',\n        width: dataView.getUint16(6, LITTLE_ENDIAN),\n        height: dataView.getUint16(8, LITTLE_ENDIAN)\n    };\n}\n// BMP\n// TODO: BMP is not this simple\nexport function getBmpMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    // Check magic number is valid (first 2 characters should be \"BM\").\n    // The mandatory bitmap file header is 14 bytes long.\n    const isBmp = dataView.byteLength >= 14 &&\n        dataView.getUint16(0, BIG_ENDIAN) === 0x424d &&\n        dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;\n    if (!isBmp) {\n        return null;\n    }\n    // BMP is little endian.\n    return {\n        mimeType: 'image/bmp',\n        width: dataView.getUint32(18, LITTLE_ENDIAN),\n        height: dataView.getUint32(22, LITTLE_ENDIAN)\n    };\n}\n// JPEG\n// Extract width and height from a binary JPEG file\nfunction getJpegMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    // Check file contains the JPEG \"start of image\" (SOI) marker\n    // followed by another marker.\n    const isJpeg = dataView.byteLength >= 3 &&\n        dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 &&\n        dataView.getUint8(2) === 0xff;\n    if (!isJpeg) {\n        return null;\n    }\n    const { tableMarkers, sofMarkers } = getJpegMarkers();\n    // Exclude the two byte SOI marker.\n    let i = 2;\n    while (i + 9 < dataView.byteLength) {\n        const marker = dataView.getUint16(i, BIG_ENDIAN);\n        // The frame that contains the width and height of the JPEG image.\n        if (sofMarkers.has(marker)) {\n            return {\n                mimeType: 'image/jpeg',\n                height: dataView.getUint16(i + 5, BIG_ENDIAN), // Number of lines\n                width: dataView.getUint16(i + 7, BIG_ENDIAN) // Number of pixels per line\n            };\n        }\n        // Miscellaneous tables/data preceding the frame header.\n        if (!tableMarkers.has(marker)) {\n            return null;\n        }\n        // Length includes size of length parameter but not the two byte header.\n        i += 2;\n        i += dataView.getUint16(i, BIG_ENDIAN);\n    }\n    return null;\n}\nfunction getJpegMarkers() {\n    // Tables/misc header markers.\n    // DQT, DHT, DAC, DRI, COM, APP_n\n    const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);\n    for (let i = 0xffe0; i < 0xfff0; ++i) {\n        tableMarkers.add(i);\n    }\n    // SOF markers and DHP marker.\n    // These markers are after tables/misc data.\n    const sofMarkers = new Set([\n        0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce,\n        0xffcf, 0xffde\n    ]);\n    return { tableMarkers, sofMarkers };\n}\n// TODO - move into image module?\nfunction toDataView(data) {\n    if (data instanceof DataView) {\n        return data;\n    }\n    if (ArrayBuffer.isView(data)) {\n        return new DataView(data.buffer);\n    }\n    // TODO: make these functions work for Node.js buffers?\n    // if (bufferToArrayBuffer) {\n    //   data = bufferToArrayBuffer(data);\n    // }\n    // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n    if (data instanceof ArrayBuffer) {\n        return new DataView(data);\n    }\n    throw new Error('toDataView');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}