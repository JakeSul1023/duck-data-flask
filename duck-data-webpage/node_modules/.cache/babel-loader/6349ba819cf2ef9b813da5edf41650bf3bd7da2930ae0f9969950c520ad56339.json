{"ast":null,"code":"import { GLTFScenegraph } from \"../../api/gltf-scenegraph.js\";\nimport { convertRawBufferToMetadataArray, getPrimitiveTextureData, primitivePropertyDataToAttributes, getArrayElementByteSize, getOffsetsForProperty, parseVariableLengthArrayNumeric, parseFixedLengthArrayNumeric, getPropertyDataString } from \"../utils/3d-tiles-utils.js\";\n/** Extension name */\nconst EXT_FEATURE_METADATA_NAME = 'EXT_feature_metadata';\nexport const name = EXT_FEATURE_METADATA_NAME;\nexport async function decode(gltfData, options) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  decodeExtFeatureMetadata(scenegraph, options);\n}\n/**\n * Decodes feature metadata from extension.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param options - GLTFLoader options.\n */\nfunction decodeExtFeatureMetadata(scenegraph, options) {\n  // Decoding metadata involves buffers processing.\n  // So, if buffers have not been loaded, there is no reason to process metadata.\n  if (!options.gltf?.loadBuffers) {\n    return;\n  }\n  const extension = scenegraph.getExtension(EXT_FEATURE_METADATA_NAME);\n  if (!extension) {\n    return;\n  }\n  if (options.gltf?.loadImages) {\n    decodePropertyTextures(scenegraph, extension);\n  }\n  decodePropertyTables(scenegraph, extension);\n}\n/**\n * Processes the data stored in the textures\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param extension - Top-level extension.\n */\nfunction decodePropertyTextures(scenegraph, extension) {\n  const schema = extension.schema;\n  if (!schema) {\n    return;\n  }\n  const schemaClasses = schema.classes;\n  const {\n    featureTextures\n  } = extension;\n  if (schemaClasses && featureTextures) {\n    for (const schemaName in schemaClasses) {\n      const schemaClass = schemaClasses[schemaName];\n      const featureTexture = findFeatureTextureByClass(featureTextures, schemaName);\n      if (featureTexture) {\n        handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass);\n      }\n    }\n  }\n}\n/**\n * Processes the data stored in the property tables.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param extension - Top-level extension.\n */\nfunction decodePropertyTables(scenegraph, extension) {\n  const schema = extension.schema;\n  if (!schema) {\n    return;\n  }\n  const schemaClasses = schema.classes;\n  const propertyTables = extension.featureTables;\n  if (schemaClasses && propertyTables) {\n    for (const schemaName in schemaClasses) {\n      const propertyTable = findPropertyTableByClass(propertyTables, schemaName);\n      if (propertyTable) {\n        processPropertyTable(scenegraph, schema, propertyTable);\n      }\n    }\n  }\n}\n/**\n * Finds the property table by class name.\n * @param propertyTables - propertyTable definition taken from the top-level extension.\n * @param schemaClassName - class name in the extension schema.\n */\nfunction findPropertyTableByClass(propertyTables, schemaClassName) {\n  for (const propertyTableName in propertyTables) {\n    const propertyTable = propertyTables[propertyTableName];\n    if (propertyTable.class === schemaClassName) {\n      return propertyTable;\n    }\n  }\n  return null;\n}\nfunction findFeatureTextureByClass(featureTextures, schemaClassName) {\n  for (const featureTexturesName in featureTextures) {\n    const featureTable = featureTextures[featureTexturesName];\n    if (featureTable.class === schemaClassName) {\n      return featureTable;\n    }\n  }\n  return null;\n}\n/**\n * Navigates through all properies in the property table, gets properties data,\n * and put the data to `propertyTable.data` as an array.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param schema - schema object.\n * @param propertyTable - propertyTable definition taken from the top-level extension.\n */\nfunction processPropertyTable(scenegraph, schema, propertyTable) {\n  // Though 'class' is not required by spec, it doesn't make any scence when it's not provided.\n  // So, bale out here.\n  if (!propertyTable.class) {\n    return;\n  }\n  const schemaClass = schema.classes?.[propertyTable.class];\n  if (!schemaClass) {\n    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);\n  }\n  const numberOfElements = propertyTable.count; // `propertyTable.count` is a number of elements in each property array.\n  for (const propertyName in schemaClass.properties) {\n    const classProperty = schemaClass.properties[propertyName];\n    const propertyTableProperty = propertyTable.properties?.[propertyName];\n    if (propertyTableProperty) {\n      // Getting all elements (`numberOfElements`) of the array in the `propertyTableProperty`\n      const data = getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);\n      propertyTableProperty.data = data;\n    }\n  }\n}\n/**\n * Navigates through all properies in feature texture and gets properties data.\n * Data will be stored in featureTexture.properties[propertyName].data.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param featureTexture\n * @param schemaClass\n */\nfunction handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass) {\n  const attributeName = featureTexture.class;\n  for (const propertyName in schemaClass.properties) {\n    const featureTextureProperty = featureTexture?.properties?.[propertyName];\n    if (featureTextureProperty) {\n      const data = getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName);\n      featureTextureProperty.data = data;\n    }\n  }\n}\n/**\n * Decodes properties from binary sourse based on property type.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param schemaProperty\n * @param numberOfFeatures\n * @param featureTableProperty\n */\nfunction getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfFeatures, featureTableProperty) {\n  let data = [];\n  const bufferView = featureTableProperty.bufferView;\n  const dataArray = scenegraph.getTypedArrayForBufferView(bufferView);\n  const arrayOffsets = getArrayOffsetsForProperty(scenegraph, classProperty, featureTableProperty, numberOfFeatures);\n  const stringOffsets = getStringOffsetsForProperty(scenegraph, classProperty, featureTableProperty, numberOfFeatures);\n  if (classProperty.type === 'STRING' || classProperty.componentType === 'STRING') {\n    data = getPropertyDataString(numberOfFeatures, dataArray, arrayOffsets, stringOffsets);\n  } else if (isNumericProperty(classProperty)) {\n    data = getPropertyDataNumeric(classProperty, numberOfFeatures, dataArray, arrayOffsets);\n  }\n  return data;\n}\n/**\n * Parses propertyTable.property.arrayOffsets that are offsets of sub-arrays in a flatten array of values.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param classProperty - class property object.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @returns Typed array with offset values.\n * @see https://github.com/CesiumGS/glTF/blob/2976f1183343a47a29e4059a70961371cd2fcee8/extensions/2.0/Vendor/EXT_structural_metadata/schema/propertyTable.property.schema.json#L21\n */\nfunction getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements) {\n  /*\n   If ARRAY is used, then componentType must also be specified.\n   ARRAY is a fixed-length array when componentCount is defined, and variable-length otherwise.\n  */\n  if (classProperty.type === 'ARRAY' &&\n  // `componentCount` is a number of fixed-length array elements.\n  // If `componentCount` is NOT defined, it's a VARIABLE-length array\n  typeof classProperty.componentCount === 'undefined' &&\n  // `arrayOffsetBufferView` is an index of the buffer view containing offsets for variable-length arrays.\n  typeof propertyTableProperty.arrayOffsetBufferView !== 'undefined') {\n    // Data are in a VARIABLE-length array\n    return getOffsetsForProperty(scenegraph, propertyTableProperty.arrayOffsetBufferView, propertyTableProperty.offsetType || 'UINT32',\n    // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView\n    numberOfElements);\n  }\n  return null;\n}\n/**\n * Parses featureTable.property.stringOffsetBufferView.\n * String offsets is an array of offsets of strings in the united array of characters.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @returns Typed array of offset values. The number of offsets in the array is equal to `numberOfElements` plus one.\n * @see https://github.com/CesiumGS/glTF/blob/c38f7f37e894004353c15cd0481bc5b7381ce841/extensions/2.0/Vendor/EXT_feature_metadata/schema/featureTable.property.schema.json#L50C10-L50C32\n */\nfunction getStringOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements) {\n  if (typeof propertyTableProperty.stringOffsetBufferView !== 'undefined' // `stringOffsetBufferView` is an index of the buffer view containing offsets for strings.\n  ) {\n    // Data are in a FIXED-length array\n    return getOffsetsForProperty(scenegraph, propertyTableProperty.stringOffsetBufferView, propertyTableProperty.offsetType || 'UINT32',\n    // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView\n    numberOfElements);\n  }\n  return null;\n}\n/**\n * Checks if the feature table property is of numeric type.\n * @param schemaPropertyType - feature table property\n * @returns true if property is numeric, else - false\n */\nfunction isNumericProperty(schemaProperty) {\n  const types = ['UINT8', 'INT16', 'UINT16', 'INT32', 'UINT32', 'INT64', 'UINT64', 'FLOAT32', 'FLOAT64'];\n  return types.includes(schemaProperty.type) || typeof schemaProperty.componentType !== 'undefined' && types.includes(schemaProperty.componentType);\n}\n/**\n * Decodes properties of numeric types from binary sourse.\n * @param classProperty - class property object.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param valuesDataBytes - Data taken from values property of the property table property.\n * @param arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @returns Property values in a typed array or in an array of typed arrays.\n */\nfunction getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {\n  const isArray = classProperty.type === 'ARRAY';\n  const arrayCount = classProperty.componentCount;\n  /*\n  We are getting Numeric data. So,\n    the component type can be one of NumericComponentType,\n    the attribute type should be 'SCALAR'\n  */\n  const attributeType = 'SCALAR';\n  const componentType = classProperty.componentType || classProperty.type;\n  const elementSize = getArrayElementByteSize(attributeType, componentType);\n  const elementCount = valuesDataBytes.byteLength / elementSize;\n  const valuesData = convertRawBufferToMetadataArray(valuesDataBytes, attributeType, componentType, elementCount);\n  if (isArray) {\n    if (arrayOffsets) {\n      // VARIABLE-length array\n      return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);\n    }\n    if (arrayCount) {\n      // FIXED-length array\n      return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);\n    }\n    return [];\n  }\n  return valuesData;\n}\n/**\n * Gets properties from texture associated with all mesh primitives.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param featureTextureProperty\n * @param attributeName\n * @returns Feature texture data\n */\nfunction getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName) {\n  const json = scenegraph.gltf.json;\n  if (!json.meshes) {\n    return [];\n  }\n  const featureTextureTable = [];\n  for (const mesh of json.meshes) {\n    for (const primitive of mesh.primitives) {\n      processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive);\n    }\n  }\n  return featureTextureTable;\n}\n/**\n * Processes data encoded in the texture associated with the primitive. This data will be accessible through the attributes.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param attributeName\n * @param featureTextureProperty\n * @param featureTextureTable\n * @param primitive\n */\nfunction processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive) {\n  const textureInfoTopLevel = {\n    channels: featureTextureProperty.channels,\n    ...featureTextureProperty.texture\n  };\n  const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);\n  if (!propertyData) {\n    return;\n  }\n  primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}