{"ast":null,"code":"import { parseJSON, sliceArrayBuffer, parseFromContext } from '@loaders.gl/loader-utils';\nimport { ImageLoader } from '@loaders.gl/images';\nimport { BasisLoader, selectSupportedBasisFormat } from '@loaders.gl/textures';\nimport { assert } from \"../utils/assert.js\";\nimport { isGLB, parseGLBSync } from \"./parse-glb.js\";\nimport { resolveUrl } from \"../gltf-utils/resolve-url.js\";\nimport { getTypedArrayForBufferView } from \"../gltf-utils/get-typed-array.js\";\nimport { preprocessExtensions, decodeExtensions } from \"../api/gltf-extensions.js\";\nimport { normalizeGLTFV1 } from \"../api/normalize-gltf-v1.js\";\n/** Check if an array buffer appears to contain GLTF data */\nexport function isGLTF(arrayBuffer, options) {\n  const byteOffset = 0;\n  return isGLB(arrayBuffer, byteOffset, options);\n}\nexport async function parseGLTF(gltf, arrayBufferOrString, byteOffset = 0, options, context) {\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n  normalizeGLTFV1(gltf, {\n    normalize: options?.gltf?.normalize\n  });\n  preprocessExtensions(gltf, options, context);\n  // Load linked buffers asynchronously and decodes base64 buffers in parallel\n  if (options?.gltf?.loadBuffers && gltf.json.buffers) {\n    await loadBuffers(gltf, options, context);\n  }\n  // loadImages and decodeExtensions should not be running in parallel, because\n  // decodeExtensions uses data from images taken during the loadImages call.\n  if (options?.gltf?.loadImages) {\n    await loadImages(gltf, options, context);\n  }\n  await decodeExtensions(gltf, options, context);\n  return gltf;\n}\n/**\n *\n * @param gltf\n * @param data - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)\n * @param byteOffset\n * @param options\n */\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  // Initialize gltf container\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n  // If data is binary and starting with magic bytes, assume binary JSON text, convert to string\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n  if (typeof data === 'string') {\n    // If string, try to parse as JSON\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    // If still ArrayBuffer, parse as GLB container\n    const glb = {};\n    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n    assert(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, 'GLTF: must be ArrayBuffer or string');\n  }\n  // Populate buffers\n  // Create an external buffers array to hold binary data\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n  // Populates JSON and some bin chunk info\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {\n      binChunks\n    } = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n    // TODO - this modifies JSON and is a post processing thing\n    // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n    // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n  }\n  // Populate images\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n/** Asynchronously fetch and parse buffers, store in buffers array outside of json\n * TODO - traverse gltf and determine which buffers are actually needed\n */\nasync function loadBuffers(gltf, options, context) {\n  // TODO\n  const buffers = gltf.json.buffers || [];\n  for (let i = 0; i < buffers.length; ++i) {\n    const buffer = buffers[i];\n    if (buffer.uri) {\n      const {\n        fetch\n      } = context;\n      assert(fetch);\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await context?.fetch?.(uri);\n      const arrayBuffer = await response?.arrayBuffer?.();\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n      delete buffer.uri;\n    } else if (gltf.buffers[i] === null) {\n      gltf.buffers[i] = {\n        arrayBuffer: new ArrayBuffer(buffer.byteLength),\n        byteOffset: 0,\n        byteLength: buffer.byteLength\n      };\n    }\n  }\n}\n/**\n * Loads all images\n * TODO - traverse gltf and determine which images are actually needed\n * @param gltf\n * @param options\n * @param context\n * @returns\n */\nasync function loadImages(gltf, options, context) {\n  const imageIndices = getReferencesImageIndices(gltf);\n  const images = gltf.json.images || [];\n  const promises = [];\n  for (const imageIndex of imageIndices) {\n    promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));\n  }\n  return await Promise.all(promises);\n}\n/** Make sure we only load images that are actually referenced by textures */\nfunction getReferencesImageIndices(gltf) {\n  const imageIndices = new Set();\n  const textures = gltf.json.textures || [];\n  for (const texture of textures) {\n    if (texture.source !== undefined) {\n      imageIndices.add(texture.source);\n    }\n  }\n  return Array.from(imageIndices).sort();\n}\n/** Asynchronously fetches and parses one image, store in images array outside of json */\nasync function loadImage(gltf, image, index, options, context) {\n  let arrayBuffer;\n  if (image.uri && !image.hasOwnProperty('bufferView')) {\n    const uri = resolveUrl(image.uri, options);\n    const {\n      fetch\n    } = context;\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n    image.bufferView = {\n      data: arrayBuffer\n    };\n  }\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n  }\n  assert(arrayBuffer, 'glTF image has no data');\n  // Call `parse`\n  let parsedImage = await parseFromContext(arrayBuffer, [ImageLoader, BasisLoader], {\n    ...options,\n    mimeType: image.mimeType,\n    basis: options.basis || {\n      format: selectSupportedBasisFormat()\n    }\n  }, context);\n  if (parsedImage && parsedImage[0]) {\n    parsedImage = {\n      compressed: true,\n      // @ts-expect-error\n      mipmaps: false,\n      width: parsedImage[0].width,\n      height: parsedImage[0].height,\n      data: parsedImage[0]\n    };\n  }\n  // TODO making sure ImageLoader is overridable by using array of loaders\n  // const parsedImage = await parse(arrayBuffer, [ImageLoader]);\n  // Store the loaded image\n  gltf.images = gltf.images || [];\n  // @ts-expect-error TODO - sort out image typing asap\n  gltf.images[index] = parsedImage;\n}","map":{"version":3,"names":["parseJSON","sliceArrayBuffer","parseFromContext","ImageLoader","BasisLoader","selectSupportedBasisFormat","assert","isGLB","parseGLBSync","resolveUrl","getTypedArrayForBufferView","preprocessExtensions","decodeExtensions","normalizeGLTFV1","isGLTF","arrayBuffer","options","byteOffset","parseGLTF","gltf","arrayBufferOrString","context","parseGLTFContainerSync","normalize","loadBuffers","json","buffers","loadImages","data","uri","baseUri","ArrayBuffer","textDecoder","TextDecoder","decode","glb","type","_glb","Array","length","fill","header","hasBinChunk","binChunks","byteLength","images","i","buffer","fetch","response","imageIndices","getReferencesImageIndices","promises","imageIndex","push","loadImage","Promise","all","Set","textures","texture","source","undefined","add","from","sort","image","index","hasOwnProperty","bufferView","Number","isFinite","array","parsedImage","mimeType","basis","format","compressed","mipmaps","width","height"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-gltf.js"],"sourcesContent":["import { parseJSON, sliceArrayBuffer, parseFromContext } from '@loaders.gl/loader-utils';\nimport { ImageLoader } from '@loaders.gl/images';\nimport { BasisLoader, selectSupportedBasisFormat } from '@loaders.gl/textures';\nimport { assert } from \"../utils/assert.js\";\nimport { isGLB, parseGLBSync } from \"./parse-glb.js\";\nimport { resolveUrl } from \"../gltf-utils/resolve-url.js\";\nimport { getTypedArrayForBufferView } from \"../gltf-utils/get-typed-array.js\";\nimport { preprocessExtensions, decodeExtensions } from \"../api/gltf-extensions.js\";\nimport { normalizeGLTFV1 } from \"../api/normalize-gltf-v1.js\";\n/** Check if an array buffer appears to contain GLTF data */\nexport function isGLTF(arrayBuffer, options) {\n    const byteOffset = 0;\n    return isGLB(arrayBuffer, byteOffset, options);\n}\nexport async function parseGLTF(gltf, arrayBufferOrString, byteOffset = 0, options, context) {\n    parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n    normalizeGLTFV1(gltf, { normalize: options?.gltf?.normalize });\n    preprocessExtensions(gltf, options, context);\n    // Load linked buffers asynchronously and decodes base64 buffers in parallel\n    if (options?.gltf?.loadBuffers && gltf.json.buffers) {\n        await loadBuffers(gltf, options, context);\n    }\n    // loadImages and decodeExtensions should not be running in parallel, because\n    // decodeExtensions uses data from images taken during the loadImages call.\n    if (options?.gltf?.loadImages) {\n        await loadImages(gltf, options, context);\n    }\n    await decodeExtensions(gltf, options, context);\n    return gltf;\n}\n/**\n *\n * @param gltf\n * @param data - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)\n * @param byteOffset\n * @param options\n */\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n    // Initialize gltf container\n    if (options.uri) {\n        gltf.baseUri = options.uri;\n    }\n    // If data is binary and starting with magic bytes, assume binary JSON text, convert to string\n    if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n        const textDecoder = new TextDecoder();\n        data = textDecoder.decode(data);\n    }\n    if (typeof data === 'string') {\n        // If string, try to parse as JSON\n        gltf.json = parseJSON(data);\n    }\n    else if (data instanceof ArrayBuffer) {\n        // If still ArrayBuffer, parse as GLB container\n        const glb = {};\n        byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n        assert(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);\n        gltf._glb = glb;\n        gltf.json = glb.json;\n    }\n    else {\n        assert(false, 'GLTF: must be ArrayBuffer or string');\n    }\n    // Populate buffers\n    // Create an external buffers array to hold binary data\n    const buffers = gltf.json.buffers || [];\n    gltf.buffers = new Array(buffers.length).fill(null);\n    // Populates JSON and some bin chunk info\n    if (gltf._glb && gltf._glb.header.hasBinChunk) {\n        const { binChunks } = gltf._glb;\n        gltf.buffers[0] = {\n            arrayBuffer: binChunks[0].arrayBuffer,\n            byteOffset: binChunks[0].byteOffset,\n            byteLength: binChunks[0].byteLength\n        };\n        // TODO - this modifies JSON and is a post processing thing\n        // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n        // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n    }\n    // Populate images\n    const images = gltf.json.images || [];\n    gltf.images = new Array(images.length).fill({});\n}\n/** Asynchronously fetch and parse buffers, store in buffers array outside of json\n * TODO - traverse gltf and determine which buffers are actually needed\n */\nasync function loadBuffers(gltf, options, context) {\n    // TODO\n    const buffers = gltf.json.buffers || [];\n    for (let i = 0; i < buffers.length; ++i) {\n        const buffer = buffers[i];\n        if (buffer.uri) {\n            const { fetch } = context;\n            assert(fetch);\n            const uri = resolveUrl(buffer.uri, options);\n            const response = await context?.fetch?.(uri);\n            const arrayBuffer = await response?.arrayBuffer?.();\n            gltf.buffers[i] = {\n                arrayBuffer,\n                byteOffset: 0,\n                byteLength: arrayBuffer.byteLength\n            };\n            delete buffer.uri;\n        }\n        else if (gltf.buffers[i] === null) {\n            gltf.buffers[i] = {\n                arrayBuffer: new ArrayBuffer(buffer.byteLength),\n                byteOffset: 0,\n                byteLength: buffer.byteLength\n            };\n        }\n    }\n}\n/**\n * Loads all images\n * TODO - traverse gltf and determine which images are actually needed\n * @param gltf\n * @param options\n * @param context\n * @returns\n */\nasync function loadImages(gltf, options, context) {\n    const imageIndices = getReferencesImageIndices(gltf);\n    const images = gltf.json.images || [];\n    const promises = [];\n    for (const imageIndex of imageIndices) {\n        promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));\n    }\n    return await Promise.all(promises);\n}\n/** Make sure we only load images that are actually referenced by textures */\nfunction getReferencesImageIndices(gltf) {\n    const imageIndices = new Set();\n    const textures = gltf.json.textures || [];\n    for (const texture of textures) {\n        if (texture.source !== undefined) {\n            imageIndices.add(texture.source);\n        }\n    }\n    return Array.from(imageIndices).sort();\n}\n/** Asynchronously fetches and parses one image, store in images array outside of json */\nasync function loadImage(gltf, image, index, options, context) {\n    let arrayBuffer;\n    if (image.uri && !image.hasOwnProperty('bufferView')) {\n        const uri = resolveUrl(image.uri, options);\n        const { fetch } = context;\n        const response = await fetch(uri);\n        arrayBuffer = await response.arrayBuffer();\n        image.bufferView = {\n            data: arrayBuffer\n        };\n    }\n    if (Number.isFinite(image.bufferView)) {\n        const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n        arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n    }\n    assert(arrayBuffer, 'glTF image has no data');\n    // Call `parse`\n    let parsedImage = (await parseFromContext(arrayBuffer, [ImageLoader, BasisLoader], {\n        ...options,\n        mimeType: image.mimeType,\n        basis: options.basis || { format: selectSupportedBasisFormat() }\n    }, context));\n    if (parsedImage && parsedImage[0]) {\n        parsedImage = {\n            compressed: true,\n            // @ts-expect-error\n            mipmaps: false,\n            width: parsedImage[0].width,\n            height: parsedImage[0].height,\n            data: parsedImage[0]\n        };\n    }\n    // TODO making sure ImageLoader is overridable by using array of loaders\n    // const parsedImage = await parse(arrayBuffer, [ImageLoader]);\n    // Store the loaded image\n    gltf.images = gltf.images || [];\n    // @ts-expect-error TODO - sort out image typing asap\n    gltf.images[index] = parsedImage;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}