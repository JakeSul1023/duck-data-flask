{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport function push(target, source) {\n  const size = source.length;\n  const startIndex = target.length;\n  // dedupe, if source is the same point as the last vertex\n  if (startIndex > 0) {\n    let isDuplicate = true;\n    for (let i = 0; i < size; i++) {\n      if (target[startIndex - size + i] !== source[i]) {\n        isDuplicate = false;\n        break;\n      }\n    }\n    if (isDuplicate) {\n      return false;\n    }\n  }\n  for (let i = 0; i < size; i++) {\n    target[startIndex + i] = source[i];\n  }\n  return true;\n}\nexport function copy(target, source) {\n  const size = source.length;\n  for (let i = 0; i < size; i++) {\n    target[i] = source[i];\n  }\n}\nexport function getPointAtIndex(positions, index, size, offset, out = []) {\n  const startI = offset + index * size;\n  for (let i = 0; i < size; i++) {\n    out[i] = positions[startI + i];\n  }\n  return out;\n}","map":{"version":3,"names":["push","target","source","size","length","startIndex","isDuplicate","i","copy","getPointAtIndex","positions","index","offset","out","startI"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\polygon\\src\\utils.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {NumericArray} from '@math.gl/core';\n\nexport function push(target: number[], source: number[]): boolean {\n  const size = source.length;\n  const startIndex = target.length;\n\n  // dedupe, if source is the same point as the last vertex\n  if (startIndex > 0) {\n    let isDuplicate = true;\n    for (let i = 0; i < size; i++) {\n      if (target[startIndex - size + i] !== source[i]) {\n        isDuplicate = false;\n        break;\n      }\n    }\n    if (isDuplicate) {\n      return false;\n    }\n  }\n\n  for (let i = 0; i < size; i++) {\n    target[startIndex + i] = source[i];\n  }\n  return true;\n}\n\nexport function copy(target: number[], source: Readonly<NumericArray>): void {\n  const size = source.length;\n  for (let i = 0; i < size; i++) {\n    target[i] = source[i];\n  }\n}\n\nexport function getPointAtIndex(\n  positions: Readonly<NumericArray>,\n  index: number,\n  size: number,\n  offset: number,\n  out: number[] = []\n): number[] {\n  const startI = offset + index * size;\n  for (let i = 0; i < size; i++) {\n    out[i] = positions[startI + i];\n  }\n  return out;\n}\n"],"mappings":"AAAA;AACA;AACA;AAIA,OAAM,SAAUA,IAAIA,CAACC,MAAgB,EAAEC,MAAgB;EACrD,MAAMC,IAAI,GAAGD,MAAM,CAACE,MAAM;EAC1B,MAAMC,UAAU,GAAGJ,MAAM,CAACG,MAAM;EAEhC;EACA,IAAIC,UAAU,GAAG,CAAC,EAAE;IAClB,IAAIC,WAAW,GAAG,IAAI;IACtB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,IAAI,EAAEI,CAAC,EAAE,EAAE;MAC7B,IAAIN,MAAM,CAACI,UAAU,GAAGF,IAAI,GAAGI,CAAC,CAAC,KAAKL,MAAM,CAACK,CAAC,CAAC,EAAE;QAC/CD,WAAW,GAAG,KAAK;QACnB;MACF;IACF;IACA,IAAIA,WAAW,EAAE;MACf,OAAO,KAAK;IACd;EACF;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,IAAI,EAAEI,CAAC,EAAE,EAAE;IAC7BN,MAAM,CAACI,UAAU,GAAGE,CAAC,CAAC,GAAGL,MAAM,CAACK,CAAC,CAAC;EACpC;EACA,OAAO,IAAI;AACb;AAEA,OAAM,SAAUC,IAAIA,CAACP,MAAgB,EAAEC,MAA8B;EACnE,MAAMC,IAAI,GAAGD,MAAM,CAACE,MAAM;EAC1B,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,IAAI,EAAEI,CAAC,EAAE,EAAE;IAC7BN,MAAM,CAACM,CAAC,CAAC,GAAGL,MAAM,CAACK,CAAC,CAAC;EACvB;AACF;AAEA,OAAM,SAAUE,eAAeA,CAC7BC,SAAiC,EACjCC,KAAa,EACbR,IAAY,EACZS,MAAc,EACdC,GAAA,GAAgB,EAAE;EAElB,MAAMC,MAAM,GAAGF,MAAM,GAAGD,KAAK,GAAGR,IAAI;EACpC,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,IAAI,EAAEI,CAAC,EAAE,EAAE;IAC7BM,GAAG,CAACN,CAAC,CAAC,GAAGG,SAAS,CAACI,MAAM,GAAGP,CAAC,CAAC;EAChC;EACA,OAAOM,GAAG;AACZ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}