{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport Viewport from \"../viewports/viewport.js\";\nimport { Matrix4, clamp, vec2 } from '@math.gl/core';\nimport { pixelsToWorld } from '@math.gl/web-mercator';\nconst viewMatrix = new Matrix4().lookAt({\n  eye: [0, 0, 1]\n});\nfunction getProjectionMatrix({\n  width,\n  height,\n  near,\n  far,\n  padding\n}) {\n  let left = -width / 2;\n  let right = width / 2;\n  let bottom = -height / 2;\n  let top = height / 2;\n  if (padding) {\n    const {\n      left: l = 0,\n      right: r = 0,\n      top: t = 0,\n      bottom: b = 0\n    } = padding;\n    const offsetX = clamp((l + width - r) / 2, 0, width) - width / 2;\n    const offsetY = clamp((t + height - b) / 2, 0, height) - height / 2;\n    left -= offsetX;\n    right -= offsetX;\n    bottom += offsetY;\n    top += offsetY;\n  }\n  return new Matrix4().ortho({\n    left,\n    right,\n    bottom,\n    top,\n    near,\n    far\n  });\n}\nexport default class OrthographicViewport extends Viewport {\n  constructor(props) {\n    const {\n      width,\n      height,\n      near = 0.1,\n      far = 1000,\n      zoom = 0,\n      target = [0, 0, 0],\n      padding = null,\n      flipY = true\n    } = props;\n    const zoomX = Array.isArray(zoom) ? zoom[0] : zoom;\n    const zoomY = Array.isArray(zoom) ? zoom[1] : zoom;\n    const zoom_ = Math.min(zoomX, zoomY);\n    const scale = Math.pow(2, zoom_);\n    let distanceScales;\n    if (zoomX !== zoomY) {\n      const scaleX = Math.pow(2, zoomX);\n      const scaleY = Math.pow(2, zoomY);\n      distanceScales = {\n        unitsPerMeter: [scaleX / scale, scaleY / scale, 1],\n        metersPerUnit: [scale / scaleX, scale / scaleY, 1]\n      };\n    }\n    super({\n      ...props,\n      // in case viewState contains longitude/latitude values,\n      // make sure that the base Viewport class does not treat this as a geospatial viewport\n      longitude: undefined,\n      position: target,\n      viewMatrix: viewMatrix.clone().scale([scale, scale * (flipY ? -1 : 1), scale]),\n      projectionMatrix: getProjectionMatrix({\n        width: width || 1,\n        height: height || 1,\n        padding,\n        near,\n        far\n      }),\n      zoom: zoom_,\n      distanceScales\n    });\n  }\n  projectFlat([X, Y]) {\n    const {\n      unitsPerMeter\n    } = this.distanceScales;\n    return [X * unitsPerMeter[0], Y * unitsPerMeter[1]];\n  }\n  unprojectFlat([x, y]) {\n    const {\n      metersPerUnit\n    } = this.distanceScales;\n    return [x * metersPerUnit[0], y * metersPerUnit[1]];\n  }\n  /* Needed by LinearInterpolator */\n  panByPosition(coords, pixel) {\n    const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);\n    const toLocation = this.projectFlat(coords);\n    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));\n    const newCenter = vec2.add([], this.center, translate);\n    return {\n      target: this.unprojectFlat(newCenter)\n    };\n  }\n}","map":{"version":3,"names":["Viewport","Matrix4","clamp","vec2","pixelsToWorld","viewMatrix","lookAt","eye","getProjectionMatrix","width","height","near","far","padding","left","right","bottom","top","l","r","t","b","offsetX","offsetY","ortho","OrthographicViewport","constructor","props","zoom","target","flipY","zoomX","Array","isArray","zoomY","zoom_","Math","min","scale","pow","distanceScales","scaleX","scaleY","unitsPerMeter","metersPerUnit","longitude","undefined","position","clone","projectionMatrix","projectFlat","X","Y","unprojectFlat","x","y","panByPosition","coords","pixel","fromLocation","pixelUnprojectionMatrix","toLocation","translate","add","negate","newCenter","center"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\viewports\\orthographic-viewport.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport Viewport from '../viewports/viewport';\n\nimport {Matrix4, clamp, vec2} from '@math.gl/core';\nimport {pixelsToWorld} from '@math.gl/web-mercator';\n\nimport type {Padding} from './viewport';\n\nconst viewMatrix = new Matrix4().lookAt({eye: [0, 0, 1]});\n\nfunction getProjectionMatrix({\n  width,\n  height,\n  near,\n  far,\n  padding\n}: {\n  width: number;\n  height: number;\n  near: number;\n  far: number;\n  padding: Padding | null;\n}) {\n  let left = -width / 2;\n  let right = width / 2;\n  let bottom = -height / 2;\n  let top = height / 2;\n  if (padding) {\n    const {left: l = 0, right: r = 0, top: t = 0, bottom: b = 0} = padding;\n    const offsetX = clamp((l + width - r) / 2, 0, width) - width / 2;\n    const offsetY = clamp((t + height - b) / 2, 0, height) - height / 2;\n    left -= offsetX;\n    right -= offsetX;\n    bottom += offsetY;\n    top += offsetY;\n  }\n\n  return new Matrix4().ortho({\n    left,\n    right,\n    bottom,\n    top,\n    near,\n    far\n  });\n}\n\nexport type OrthographicViewportOptions = {\n  /** Name of the viewport */\n  id?: string;\n  /** Left offset from the canvas edge, in pixels */\n  x?: number;\n  /** Top offset from the canvas edge, in pixels */\n  y?: number;\n  /** Viewport width in pixels */\n  width?: number;\n  /** Viewport height in pixels */\n  height?: number;\n  /** The world position at the center of the viewport. Default `[0, 0, 0]`. */\n  target?: [number, number, number] | [number, number];\n  /**  The zoom level of the viewport. `zoom: 0` maps one unit distance to one pixel on screen, and increasing `zoom` by `1` scales the same object to twice as large.\n   *   To apply independent zoom levels to the X and Y axes, supply an array `[zoomX, zoomY]`. Default `0`. */\n  zoom?: number | [number, number];\n  /** Padding around the viewport, in pixels. */\n  padding?: Padding | null;\n  /** Distance of near clipping plane. Default `0.1`. */\n  near?: number;\n  /** Distance of far clipping plane. Default `1000`. */\n  far?: number;\n  /** Whether to use top-left coordinates (`true`) or bottom-left coordinates (`false`). Default `true`. */\n  flipY?: boolean;\n};\n\nexport default class OrthographicViewport extends Viewport {\n  constructor(props: OrthographicViewportOptions) {\n    const {\n      width,\n      height,\n      near = 0.1,\n      far = 1000,\n      zoom = 0,\n      target = [0, 0, 0],\n      padding = null,\n      flipY = true\n    } = props;\n    const zoomX = Array.isArray(zoom) ? zoom[0] : zoom;\n    const zoomY = Array.isArray(zoom) ? zoom[1] : zoom;\n    const zoom_ = Math.min(zoomX, zoomY);\n    const scale = Math.pow(2, zoom_);\n\n    let distanceScales;\n    if (zoomX !== zoomY) {\n      const scaleX = Math.pow(2, zoomX);\n      const scaleY = Math.pow(2, zoomY);\n\n      distanceScales = {\n        unitsPerMeter: [scaleX / scale, scaleY / scale, 1],\n        metersPerUnit: [scale / scaleX, scale / scaleY, 1]\n      };\n    }\n\n    super({\n      ...props,\n      // in case viewState contains longitude/latitude values,\n      // make sure that the base Viewport class does not treat this as a geospatial viewport\n      longitude: undefined,\n      position: target,\n      viewMatrix: viewMatrix.clone().scale([scale, scale * (flipY ? -1 : 1), scale]),\n      projectionMatrix: getProjectionMatrix({\n        width: width || 1,\n        height: height || 1,\n        padding,\n        near,\n        far\n      }),\n      zoom: zoom_,\n      distanceScales\n    });\n  }\n\n  projectFlat([X, Y]: number[]): [number, number] {\n    const {unitsPerMeter} = this.distanceScales;\n    return [X * unitsPerMeter[0], Y * unitsPerMeter[1]];\n  }\n\n  unprojectFlat([x, y]: number[]): [number, number] {\n    const {metersPerUnit} = this.distanceScales;\n    return [x * metersPerUnit[0], y * metersPerUnit[1]];\n  }\n\n  /* Needed by LinearInterpolator */\n  panByPosition(coords: number[], pixel: number[]): OrthographicViewportOptions {\n    const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);\n    const toLocation = this.projectFlat(coords);\n\n    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));\n    const newCenter = vec2.add([], this.center, translate);\n\n    return {target: this.unprojectFlat(newCenter)};\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}