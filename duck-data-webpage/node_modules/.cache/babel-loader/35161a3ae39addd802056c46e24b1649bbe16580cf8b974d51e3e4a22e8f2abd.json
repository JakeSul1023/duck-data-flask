{"ast":null,"code":"import { Vector3 } from '@math.gl/core';\nimport { CullingVolume, Plane } from '@math.gl/culling';\nimport { Ellipsoid } from '@math.gl/geospatial';\nconst scratchVector = new Vector3();\nconst scratchPosition = new Vector3();\nconst cullingVolume = new CullingVolume([new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()]);\n// Extracts a frame state appropriate for tile culling from a deck.gl viewport\n// TODO - this could likely be generalized and merged back into deck.gl for other culling scenarios\nexport function getFrameState(viewport, frameNumber) {\n  // Traverse and and request. Update _selectedTiles so that we know what to render.\n  // Traverse and and request. Update _selectedTiles so that we know what to render.\n  const {\n    cameraDirection,\n    cameraUp,\n    height\n  } = viewport;\n  const {\n    metersPerUnit\n  } = viewport.distanceScales;\n  // TODO - Ellipsoid.eastNorthUpToFixedFrame() breaks on raw array, create a Vector.\n  // TODO - Ellipsoid.eastNorthUpToFixedFrame() takes a cartesian, is that intuitive?\n  const viewportCenterCartesian = worldToCartesian(viewport, viewport.center);\n  const enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector3());\n  // These should still be normalized as the transform has scale 1 (goes from meters to meters)\n  const cameraDirectionCartesian = new Vector3(\n  // @ts-ignore\n  enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))).normalize();\n  const cameraUpCartesian = new Vector3(\n  // @ts-ignore\n  enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))).normalize();\n  commonSpacePlanesToWGS84(viewport);\n  const ViewportClass = viewport.constructor;\n  const {\n    longitude,\n    latitude,\n    width,\n    bearing,\n    zoom\n  } = viewport;\n  // @ts-ignore\n  const topDownViewport = new ViewportClass({\n    longitude,\n    latitude,\n    height,\n    width,\n    bearing,\n    zoom,\n    pitch: 0\n  });\n  // TODO: make a file/class for frameState and document what needs to be attached to this so that traversal can function\n  return {\n    camera: {\n      position: cameraPositionCartesian,\n      direction: cameraDirectionCartesian,\n      up: cameraUpCartesian\n    },\n    viewport,\n    topDownViewport,\n    height,\n    cullingVolume,\n    frameNumber,\n    // TODO: This can be the same between updates, what number is unique for between updates?\n    sseDenominator: 1.15 // Assumes fovy = 60 degrees\n  };\n}\n/**\n * Limit `tiles` array length with `maximumTilesSelected` number.\n * The criteria for this filtering is distance of a tile center\n * to the `frameState.viewport`'s longitude and latitude\n * @param tiles - tiles array to filter\n * @param frameState - frameState to calculate distances\n * @param maximumTilesSelected - maximal amount of tiles in the output array\n * @returns new tiles array\n */\nexport function limitSelectedTiles(tiles, frameState, maximumTilesSelected) {\n  if (maximumTilesSelected === 0 || tiles.length <= maximumTilesSelected) {\n    return [tiles, []];\n  }\n  // Accumulate distances in couples array: [tileIndex: number, distanceToViewport: number]\n  const tuples = [];\n  const {\n    longitude: viewportLongitude,\n    latitude: viewportLatitude\n  } = frameState.viewport;\n  for (const [index, tile] of tiles.entries()) {\n    const [longitude, latitude] = tile.header.mbs;\n    const deltaLon = Math.abs(viewportLongitude - longitude);\n    const deltaLat = Math.abs(viewportLatitude - latitude);\n    const distance = Math.sqrt(deltaLat * deltaLat + deltaLon * deltaLon);\n    tuples.push([index, distance]);\n  }\n  const tuplesSorted = tuples.sort((a, b) => a[1] - b[1]);\n  const selectedTiles = [];\n  for (let i = 0; i < maximumTilesSelected; i++) {\n    selectedTiles.push(tiles[tuplesSorted[i][0]]);\n  }\n  const unselectedTiles = [];\n  for (let i = maximumTilesSelected; i < tuplesSorted.length; i++) {\n    unselectedTiles.push(tiles[tuplesSorted[i][0]]);\n  }\n  return [selectedTiles, unselectedTiles];\n}\nfunction commonSpacePlanesToWGS84(viewport) {\n  // Extract frustum planes based on current view.\n  const frustumPlanes = viewport.getFrustumPlanes();\n  // Get the near/far plane centers\n  const nearCenterCommon = closestPointOnPlane(frustumPlanes.near, viewport.cameraPosition);\n  const nearCenterCartesian = worldToCartesian(viewport, nearCenterCommon);\n  const cameraCartesian = worldToCartesian(viewport, viewport.cameraPosition, scratchPosition);\n  let i = 0;\n  cullingVolume.planes[i++].fromPointNormal(nearCenterCartesian, scratchVector.copy(nearCenterCartesian).subtract(cameraCartesian));\n  for (const dir in frustumPlanes) {\n    if (dir === 'near') {\n      continue; // eslint-disable-line no-continue\n    }\n    const plane = frustumPlanes[dir];\n    const posCommon = closestPointOnPlane(plane, nearCenterCommon, scratchPosition);\n    const cartesianPos = worldToCartesian(viewport, posCommon, scratchPosition);\n    cullingVolume.planes[i++].fromPointNormal(cartesianPos,\n    // Want the normal to point into the frustum since that's what culling expects\n    scratchVector.copy(nearCenterCartesian).subtract(cartesianPos));\n  }\n}\nfunction closestPointOnPlane(plane, refPoint, out = new Vector3()) {\n  const distanceToRef = plane.normal.dot(refPoint);\n  out.copy(plane.normal).scale(plane.distance - distanceToRef).add(refPoint);\n  return out;\n}\nfunction worldToCartesian(viewport, point, out = new Vector3()) {\n  const cartographicPos = viewport.unprojectPosition(point);\n  return Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, out);\n}","map":{"version":3,"names":["Vector3","CullingVolume","Plane","Ellipsoid","scratchVector","scratchPosition","cullingVolume","getFrameState","viewport","frameNumber","cameraDirection","cameraUp","height","metersPerUnit","distanceScales","viewportCenterCartesian","worldToCartesian","center","enuToFixedTransform","WGS84","eastNorthUpToFixedFrame","cameraPositionCartographic","unprojectPosition","cameraPosition","cameraPositionCartesian","cartographicToCartesian","cameraDirectionCartesian","transformAsVector","scale","normalize","cameraUpCartesian","commonSpacePlanesToWGS84","ViewportClass","constructor","longitude","latitude","width","bearing","zoom","topDownViewport","pitch","camera","position","direction","up","sseDenominator","limitSelectedTiles","tiles","frameState","maximumTilesSelected","length","tuples","viewportLongitude","viewportLatitude","index","tile","entries","header","mbs","deltaLon","Math","abs","deltaLat","distance","sqrt","push","tuplesSorted","sort","a","b","selectedTiles","i","unselectedTiles","frustumPlanes","getFrustumPlanes","nearCenterCommon","closestPointOnPlane","near","nearCenterCartesian","cameraCartesian","planes","fromPointNormal","copy","subtract","dir","plane","posCommon","cartesianPos","refPoint","out","distanceToRef","normal","dot","add","point","cartographicPos"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/tiles/dist/tileset/helpers/frame-state.js"],"sourcesContent":["import { Vector3 } from '@math.gl/core';\nimport { CullingVolume, Plane } from '@math.gl/culling';\nimport { Ellipsoid } from '@math.gl/geospatial';\nconst scratchVector = new Vector3();\nconst scratchPosition = new Vector3();\nconst cullingVolume = new CullingVolume([\n    new Plane(),\n    new Plane(),\n    new Plane(),\n    new Plane(),\n    new Plane(),\n    new Plane()\n]);\n// Extracts a frame state appropriate for tile culling from a deck.gl viewport\n// TODO - this could likely be generalized and merged back into deck.gl for other culling scenarios\nexport function getFrameState(viewport, frameNumber) {\n    // Traverse and and request. Update _selectedTiles so that we know what to render.\n    // Traverse and and request. Update _selectedTiles so that we know what to render.\n    const { cameraDirection, cameraUp, height } = viewport;\n    const { metersPerUnit } = viewport.distanceScales;\n    // TODO - Ellipsoid.eastNorthUpToFixedFrame() breaks on raw array, create a Vector.\n    // TODO - Ellipsoid.eastNorthUpToFixedFrame() takes a cartesian, is that intuitive?\n    const viewportCenterCartesian = worldToCartesian(viewport, viewport.center);\n    const enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);\n    const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n    const cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector3());\n    // These should still be normalized as the transform has scale 1 (goes from meters to meters)\n    const cameraDirectionCartesian = new Vector3(\n    // @ts-ignore\n    enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))).normalize();\n    const cameraUpCartesian = new Vector3(\n    // @ts-ignore\n    enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))).normalize();\n    commonSpacePlanesToWGS84(viewport);\n    const ViewportClass = viewport.constructor;\n    const { longitude, latitude, width, bearing, zoom } = viewport;\n    // @ts-ignore\n    const topDownViewport = new ViewportClass({\n        longitude,\n        latitude,\n        height,\n        width,\n        bearing,\n        zoom,\n        pitch: 0\n    });\n    // TODO: make a file/class for frameState and document what needs to be attached to this so that traversal can function\n    return {\n        camera: {\n            position: cameraPositionCartesian,\n            direction: cameraDirectionCartesian,\n            up: cameraUpCartesian\n        },\n        viewport,\n        topDownViewport,\n        height,\n        cullingVolume,\n        frameNumber, // TODO: This can be the same between updates, what number is unique for between updates?\n        sseDenominator: 1.15 // Assumes fovy = 60 degrees\n    };\n}\n/**\n * Limit `tiles` array length with `maximumTilesSelected` number.\n * The criteria for this filtering is distance of a tile center\n * to the `frameState.viewport`'s longitude and latitude\n * @param tiles - tiles array to filter\n * @param frameState - frameState to calculate distances\n * @param maximumTilesSelected - maximal amount of tiles in the output array\n * @returns new tiles array\n */\nexport function limitSelectedTiles(tiles, frameState, maximumTilesSelected) {\n    if (maximumTilesSelected === 0 || tiles.length <= maximumTilesSelected) {\n        return [tiles, []];\n    }\n    // Accumulate distances in couples array: [tileIndex: number, distanceToViewport: number]\n    const tuples = [];\n    const { longitude: viewportLongitude, latitude: viewportLatitude } = frameState.viewport;\n    for (const [index, tile] of tiles.entries()) {\n        const [longitude, latitude] = tile.header.mbs;\n        const deltaLon = Math.abs(viewportLongitude - longitude);\n        const deltaLat = Math.abs(viewportLatitude - latitude);\n        const distance = Math.sqrt(deltaLat * deltaLat + deltaLon * deltaLon);\n        tuples.push([index, distance]);\n    }\n    const tuplesSorted = tuples.sort((a, b) => a[1] - b[1]);\n    const selectedTiles = [];\n    for (let i = 0; i < maximumTilesSelected; i++) {\n        selectedTiles.push(tiles[tuplesSorted[i][0]]);\n    }\n    const unselectedTiles = [];\n    for (let i = maximumTilesSelected; i < tuplesSorted.length; i++) {\n        unselectedTiles.push(tiles[tuplesSorted[i][0]]);\n    }\n    return [selectedTiles, unselectedTiles];\n}\nfunction commonSpacePlanesToWGS84(viewport) {\n    // Extract frustum planes based on current view.\n    const frustumPlanes = viewport.getFrustumPlanes();\n    // Get the near/far plane centers\n    const nearCenterCommon = closestPointOnPlane(frustumPlanes.near, viewport.cameraPosition);\n    const nearCenterCartesian = worldToCartesian(viewport, nearCenterCommon);\n    const cameraCartesian = worldToCartesian(viewport, viewport.cameraPosition, scratchPosition);\n    let i = 0;\n    cullingVolume.planes[i++].fromPointNormal(nearCenterCartesian, scratchVector.copy(nearCenterCartesian).subtract(cameraCartesian));\n    for (const dir in frustumPlanes) {\n        if (dir === 'near') {\n            continue; // eslint-disable-line no-continue\n        }\n        const plane = frustumPlanes[dir];\n        const posCommon = closestPointOnPlane(plane, nearCenterCommon, scratchPosition);\n        const cartesianPos = worldToCartesian(viewport, posCommon, scratchPosition);\n        cullingVolume.planes[i++].fromPointNormal(cartesianPos, \n        // Want the normal to point into the frustum since that's what culling expects\n        scratchVector.copy(nearCenterCartesian).subtract(cartesianPos));\n    }\n}\nfunction closestPointOnPlane(plane, refPoint, out = new Vector3()) {\n    const distanceToRef = plane.normal.dot(refPoint);\n    out\n        .copy(plane.normal)\n        .scale(plane.distance - distanceToRef)\n        .add(refPoint);\n    return out;\n}\nfunction worldToCartesian(viewport, point, out = new Vector3()) {\n    const cartographicPos = viewport.unprojectPosition(point);\n    return Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, out);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}