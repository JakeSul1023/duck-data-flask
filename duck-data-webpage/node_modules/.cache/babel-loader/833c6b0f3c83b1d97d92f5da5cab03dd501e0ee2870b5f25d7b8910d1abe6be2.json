{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { BufferTransform } from '@luma.gl/engine';\nimport { createRenderTarget } from \"./utils.js\";\nimport { TEXTURE_WIDTH } from \"./webgl-bin-sorter.js\";\nimport { aggregatorTransformUniforms } from \"./aggregation-transform-uniforms.js\";\nconst MAX_FLOAT32 = 3e38;\nexport class WebGLAggregationTransform {\n  constructor(device, props) {\n    /** Packed from bin ids */\n    this.binBuffer = null;\n    /** Packed values from each channel of each bin\n     * Stride is number of channels * 4 bytes (float32)\n     */\n    this.valueBuffer = null;\n    /** Aggregated [min, max] for each channel */\n    this._domains = null;\n    this.device = device;\n    this.channelCount = props.channelCount;\n    this.transform = createTransform(device, props);\n    this.domainFBO = createRenderTarget(device, 2, 1);\n  }\n  destroy() {\n    this.transform.destroy();\n    this.binBuffer?.destroy();\n    this.valueBuffer?.destroy();\n    this.domainFBO.colorAttachments[0].texture.destroy();\n    this.domainFBO.destroy();\n  }\n  get domains() {\n    if (!this._domains) {\n      // Domain model has run, but result has not been read to CPU\n      const buffer = this.device.readPixelsToArrayWebGL(this.domainFBO).buffer;\n      const domain = new Float32Array(buffer);\n      this._domains = [[-domain[4], domain[0]], [-domain[5], domain[1]], [-domain[6], domain[2]]].slice(0, this.channelCount);\n    }\n    return this._domains;\n  }\n  setDimensions(binCount, binIdRange) {\n    const {\n      model,\n      transformFeedback\n    } = this.transform;\n    model.setVertexCount(binCount);\n    const aggregatorTransformProps = {\n      binIdRange: [binIdRange[0][0], binIdRange[0][1], binIdRange[1]?.[0] || 0, binIdRange[1]?.[1] || 0]\n    };\n    model.shaderInputs.setProps({\n      aggregatorTransform: aggregatorTransformProps\n    });\n    // Only destroy existing buffer if it is not large enough\n    const binBufferByteLength = binCount * binIdRange.length * 4;\n    if (!this.binBuffer || this.binBuffer.byteLength < binBufferByteLength) {\n      this.binBuffer?.destroy();\n      this.binBuffer = this.device.createBuffer({\n        byteLength: binBufferByteLength\n      });\n      transformFeedback.setBuffer('binIds', this.binBuffer);\n    }\n    const valueBufferByteLength = binCount * this.channelCount * 4;\n    if (!this.valueBuffer || this.valueBuffer.byteLength < valueBufferByteLength) {\n      this.valueBuffer?.destroy();\n      this.valueBuffer = this.device.createBuffer({\n        byteLength: valueBufferByteLength\n      });\n      transformFeedback.setBuffer('values', this.valueBuffer);\n    }\n  }\n  update(bins, operations) {\n    if (!bins) {\n      return;\n    }\n    const transform = this.transform;\n    const target = this.domainFBO;\n    const isCount = [0, 1, 2].map(i => operations[i] === 'COUNT' ? 1 : 0);\n    const isMean = [0, 1, 2].map(i => operations[i] === 'MEAN' ? 1 : 0);\n    const aggregatorTransformProps = {\n      isCount: isCount,\n      isMean: isMean,\n      bins\n    };\n    transform.model.shaderInputs.setProps({\n      aggregatorTransform: aggregatorTransformProps\n    });\n    transform.run({\n      id: 'gpu-aggregation-domain',\n      framebuffer: target,\n      parameters: {\n        viewport: [0, 0, 2, 1]\n      },\n      clearColor: [-MAX_FLOAT32, -MAX_FLOAT32, -MAX_FLOAT32, 0],\n      clearDepth: false,\n      clearStencil: false\n    });\n    // Clear the last read results. This will be lazy-populated if used.\n    this._domains = null;\n  }\n}\nfunction createTransform(device, props) {\n  const vs = /* glsl */`\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-domain-vertex\n\nuniform sampler2D bins;\n\n#if NUM_DIMS == 1\nout float binIds;\n#else\nout vec2 binIds;\n#endif\n\n#if NUM_CHANNELS == 1\nflat out float values;\n#elif NUM_CHANNELS == 2\nflat out vec2 values;\n#else\nflat out vec3 values;\n#endif\n\nconst float NAN = intBitsToFloat(-1);\n\nvoid main() {\n  int row = gl_VertexID / SAMPLER_WIDTH;\n  int col = gl_VertexID - row * SAMPLER_WIDTH;\n  vec4 weights = texelFetch(bins, ivec2(col, row), 0);\n  vec3 value3 = mix(\n    mix(weights.rgb, vec3(weights.a), aggregatorTransform.isCount),\n    weights.rgb / max(weights.a, 1.0),\n    aggregatorTransform.isMean\n  );\n  if (weights.a == 0.0) {\n    value3 = vec3(NAN);\n  }\n\n#if NUM_DIMS == 1\n  binIds = float(gl_VertexID + aggregatorTransform.binIdRange.x);\n#else\n  int y = gl_VertexID / (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);\n  int x = gl_VertexID - y * (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);\n  binIds.y = float(y + aggregatorTransform.binIdRange.z);\n  binIds.x = float(x + aggregatorTransform.binIdRange.x);\n#endif\n\n#if NUM_CHANNELS == 3\n  values = value3;\n#elif NUM_CHANNELS == 2\n  values = value3.xy;\n#else\n  values = value3.x;\n#endif\n\n  gl_Position = vec4(0., 0., 0., 1.);\n  // This model renders into a 2x1 texture to obtain min and max simultaneously.\n  // See comments in fragment shader\n  gl_PointSize = 2.0;\n}\n`;\n  const fs = /* glsl */`\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-domain-fragment\n\nprecision highp float;\n\n#if NUM_CHANNELS == 1\nflat in float values;\n#elif NUM_CHANNELS == 2\nflat in vec2 values;\n#else\nflat in vec3 values;\n#endif\n\nout vec4 fragColor;\n\nvoid main() {\n  vec3 value3;\n#if NUM_CHANNELS == 3\n  value3 = values;\n#elif NUM_CHANNELS == 2\n  value3.xy = values;\n#else\n  value3.x = values;\n#endif\n  if (isnan(value3.x)) discard;\n  // This shader renders into a 2x1 texture with blending=max\n  // The left pixel yields the max value of each channel\n  // The right pixel yields the min value of each channel\n  if (gl_FragCoord.x < 1.0) {\n    fragColor = vec4(value3, 1.0);\n  } else {\n    fragColor = vec4(-value3, 1.0);\n  }\n}\n`;\n  return new BufferTransform(device, {\n    vs,\n    fs,\n    topology: 'point-list',\n    modules: [aggregatorTransformUniforms],\n    parameters: {\n      blend: true,\n      blendColorSrcFactor: 'one',\n      blendColorDstFactor: 'one',\n      blendColorOperation: 'max',\n      blendAlphaSrcFactor: 'one',\n      blendAlphaDstFactor: 'one',\n      blendAlphaOperation: 'max'\n    },\n    defines: {\n      NUM_DIMS: props.dimensions,\n      NUM_CHANNELS: props.channelCount,\n      SAMPLER_WIDTH: TEXTURE_WIDTH\n    },\n    varyings: ['binIds', 'values'],\n    disableWarnings: true\n  });\n}","map":{"version":3,"names":["BufferTransform","createRenderTarget","TEXTURE_WIDTH","aggregatorTransformUniforms","MAX_FLOAT32","WebGLAggregationTransform","constructor","device","props","binBuffer","valueBuffer","_domains","channelCount","transform","createTransform","domainFBO","destroy","colorAttachments","texture","domains","buffer","readPixelsToArrayWebGL","domain","Float32Array","slice","setDimensions","binCount","binIdRange","model","transformFeedback","setVertexCount","aggregatorTransformProps","shaderInputs","setProps","aggregatorTransform","binBufferByteLength","length","byteLength","createBuffer","setBuffer","valueBufferByteLength","update","bins","operations","target","isCount","map","i","isMean","run","id","framebuffer","parameters","viewport","clearColor","clearDepth","clearStencil","vs","fs","topology","modules","blend","blendColorSrcFactor","blendColorDstFactor","blendColorOperation","blendAlphaSrcFactor","blendAlphaDstFactor","blendAlphaOperation","defines","NUM_DIMS","dimensions","NUM_CHANNELS","SAMPLER_WIDTH","varyings","disableWarnings"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\aggregation-layers\\src\\common\\aggregator\\gpu-aggregator\\webgl-aggregation-transform.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {BufferTransform} from '@luma.gl/engine';\nimport {createRenderTarget} from './utils';\n\nimport type {Device, Framebuffer, Buffer, Texture} from '@luma.gl/core';\nimport type {WebGLAggregatorProps} from './webgl-aggregator';\nimport type {AggregationOperation} from '../aggregator';\n\nimport {TEXTURE_WIDTH} from './webgl-bin-sorter';\nimport {\n  AggregatorTransformProps,\n  aggregatorTransformUniforms\n} from './aggregation-transform-uniforms';\nimport {NumberArray3} from '@math.gl/core';\n\nconst MAX_FLOAT32 = 3e38;\n\nexport class WebGLAggregationTransform {\n  device: Device;\n  channelCount: number;\n\n  /** Packed from bin ids */\n  binBuffer: Buffer | null = null;\n  /** Packed values from each channel of each bin\n   * Stride is number of channels * 4 bytes (float32)\n   */\n  valueBuffer: Buffer | null = null;\n\n  private transform: BufferTransform;\n  /** Render target for calculating domain */\n  private domainFBO: Framebuffer;\n  /** Aggregated [min, max] for each channel */\n  private _domains: [min: number, max: number][] | null = null;\n\n  constructor(device: Device, props: WebGLAggregatorProps) {\n    this.device = device;\n    this.channelCount = props.channelCount;\n    this.transform = createTransform(device, props);\n    this.domainFBO = createRenderTarget(device, 2, 1);\n  }\n\n  destroy() {\n    this.transform.destroy();\n    this.binBuffer?.destroy();\n    this.valueBuffer?.destroy();\n    this.domainFBO.colorAttachments[0].texture.destroy();\n    this.domainFBO.destroy();\n  }\n\n  get domains(): [min: number, max: number][] {\n    if (!this._domains) {\n      // Domain model has run, but result has not been read to CPU\n      const buffer = this.device.readPixelsToArrayWebGL(this.domainFBO).buffer;\n      const domain = new Float32Array(buffer);\n      this._domains = [\n        [-domain[4], domain[0]],\n        [-domain[5], domain[1]],\n        [-domain[6], domain[2]]\n      ].slice(0, this.channelCount) as [number, number][];\n    }\n    return this._domains;\n  }\n\n  setDimensions(binCount: number, binIdRange: [number, number][]) {\n    const {model, transformFeedback} = this.transform;\n    model.setVertexCount(binCount);\n    const aggregatorTransformProps: Partial<AggregatorTransformProps> = {\n      binIdRange: [\n        binIdRange[0][0],\n        binIdRange[0][1],\n        binIdRange[1]?.[0] || 0,\n        binIdRange[1]?.[1] || 0\n      ]\n    };\n    model.shaderInputs.setProps({aggregatorTransform: aggregatorTransformProps});\n\n    // Only destroy existing buffer if it is not large enough\n    const binBufferByteLength = binCount * binIdRange.length * 4;\n    if (!this.binBuffer || this.binBuffer.byteLength < binBufferByteLength) {\n      this.binBuffer?.destroy();\n      this.binBuffer = this.device.createBuffer({byteLength: binBufferByteLength});\n      transformFeedback.setBuffer('binIds', this.binBuffer);\n    }\n\n    const valueBufferByteLength = binCount * this.channelCount * 4;\n    if (!this.valueBuffer || this.valueBuffer.byteLength < valueBufferByteLength) {\n      this.valueBuffer?.destroy();\n      this.valueBuffer = this.device.createBuffer({byteLength: valueBufferByteLength});\n      transformFeedback.setBuffer('values', this.valueBuffer);\n    }\n  }\n\n  update(bins: Texture | null, operations: AggregationOperation[]) {\n    if (!bins) {\n      return;\n    }\n    const transform = this.transform;\n    const target = this.domainFBO;\n\n    const isCount = [0, 1, 2].map(i => (operations[i] === 'COUNT' ? 1 : 0));\n    const isMean = [0, 1, 2].map(i => (operations[i] === 'MEAN' ? 1 : 0));\n    const aggregatorTransformProps: Partial<AggregatorTransformProps> = {\n      isCount: isCount as NumberArray3,\n      isMean: isMean as NumberArray3,\n      bins\n    };\n    transform.model.shaderInputs.setProps({aggregatorTransform: aggregatorTransformProps});\n\n    transform.run({\n      id: 'gpu-aggregation-domain',\n      framebuffer: target,\n      parameters: {\n        viewport: [0, 0, 2, 1]\n      },\n      clearColor: [-MAX_FLOAT32, -MAX_FLOAT32, -MAX_FLOAT32, 0],\n      clearDepth: false,\n      clearStencil: false\n    });\n\n    // Clear the last read results. This will be lazy-populated if used.\n    this._domains = null;\n  }\n}\n\nfunction createTransform(device: Device, props: WebGLAggregatorProps): BufferTransform {\n  const vs = /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-domain-vertex\n\nuniform sampler2D bins;\n\n#if NUM_DIMS == 1\nout float binIds;\n#else\nout vec2 binIds;\n#endif\n\n#if NUM_CHANNELS == 1\nflat out float values;\n#elif NUM_CHANNELS == 2\nflat out vec2 values;\n#else\nflat out vec3 values;\n#endif\n\nconst float NAN = intBitsToFloat(-1);\n\nvoid main() {\n  int row = gl_VertexID / SAMPLER_WIDTH;\n  int col = gl_VertexID - row * SAMPLER_WIDTH;\n  vec4 weights = texelFetch(bins, ivec2(col, row), 0);\n  vec3 value3 = mix(\n    mix(weights.rgb, vec3(weights.a), aggregatorTransform.isCount),\n    weights.rgb / max(weights.a, 1.0),\n    aggregatorTransform.isMean\n  );\n  if (weights.a == 0.0) {\n    value3 = vec3(NAN);\n  }\n\n#if NUM_DIMS == 1\n  binIds = float(gl_VertexID + aggregatorTransform.binIdRange.x);\n#else\n  int y = gl_VertexID / (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);\n  int x = gl_VertexID - y * (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);\n  binIds.y = float(y + aggregatorTransform.binIdRange.z);\n  binIds.x = float(x + aggregatorTransform.binIdRange.x);\n#endif\n\n#if NUM_CHANNELS == 3\n  values = value3;\n#elif NUM_CHANNELS == 2\n  values = value3.xy;\n#else\n  values = value3.x;\n#endif\n\n  gl_Position = vec4(0., 0., 0., 1.);\n  // This model renders into a 2x1 texture to obtain min and max simultaneously.\n  // See comments in fragment shader\n  gl_PointSize = 2.0;\n}\n`;\n\n  const fs = /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-domain-fragment\n\nprecision highp float;\n\n#if NUM_CHANNELS == 1\nflat in float values;\n#elif NUM_CHANNELS == 2\nflat in vec2 values;\n#else\nflat in vec3 values;\n#endif\n\nout vec4 fragColor;\n\nvoid main() {\n  vec3 value3;\n#if NUM_CHANNELS == 3\n  value3 = values;\n#elif NUM_CHANNELS == 2\n  value3.xy = values;\n#else\n  value3.x = values;\n#endif\n  if (isnan(value3.x)) discard;\n  // This shader renders into a 2x1 texture with blending=max\n  // The left pixel yields the max value of each channel\n  // The right pixel yields the min value of each channel\n  if (gl_FragCoord.x < 1.0) {\n    fragColor = vec4(value3, 1.0);\n  } else {\n    fragColor = vec4(-value3, 1.0);\n  }\n}\n`;\n\n  return new BufferTransform(device, {\n    vs,\n    fs,\n    topology: 'point-list',\n    modules: [aggregatorTransformUniforms],\n    parameters: {\n      blend: true,\n      blendColorSrcFactor: 'one',\n      blendColorDstFactor: 'one',\n      blendColorOperation: 'max',\n      blendAlphaSrcFactor: 'one',\n      blendAlphaDstFactor: 'one',\n      blendAlphaOperation: 'max'\n    },\n    defines: {\n      NUM_DIMS: props.dimensions,\n      NUM_CHANNELS: props.channelCount,\n      SAMPLER_WIDTH: TEXTURE_WIDTH\n    },\n    varyings: ['binIds', 'values'],\n    disableWarnings: true\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}