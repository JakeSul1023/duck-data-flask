{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Layer, project32, picking, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { Model } from '@luma.gl/engine';\nimport { lngLatToWorld } from '@math.gl/web-mercator';\nimport createMesh from \"./create-mesh.js\";\nimport { bitmapUniforms } from \"./bitmap-layer-uniforms.js\";\nimport vs from \"./bitmap-layer-vertex.js\";\nimport fs from \"./bitmap-layer-fragment.js\";\nconst defaultProps = {\n  image: {\n    type: 'image',\n    value: null,\n    async: true\n  },\n  bounds: {\n    type: 'array',\n    value: [1, 0, 0, 1],\n    compare: true\n  },\n  _imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n  desaturate: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 0\n  },\n  // More context: because of the blending mode we're using for ground imagery,\n  // alpha is not effective when blending the bitmap layers with the base map.\n  // Instead we need to manually dim/blend rgb values with a background color.\n  transparentColor: {\n    type: 'color',\n    value: [0, 0, 0, 0]\n  },\n  tintColor: {\n    type: 'color',\n    value: [255, 255, 255]\n  },\n  textureParameters: {\n    type: 'object',\n    ignore: true,\n    value: null\n  }\n};\n/** Render a bitmap at specified boundaries. */\nclass BitmapLayer extends Layer {\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, picking, bitmapUniforms]\n    });\n  }\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    attributeManager.remove(['instancePickingColors']);\n    const noAlloc = true;\n    attributeManager.add({\n      indices: {\n        size: 1,\n        isIndexed: true,\n        update: attribute => attribute.value = this.state.mesh.indices,\n        noAlloc\n      },\n      positions: {\n        size: 3,\n        type: 'float64',\n        fp64: this.use64bitPositions(),\n        update: attribute => attribute.value = this.state.mesh.positions,\n        noAlloc\n      },\n      texCoords: {\n        size: 2,\n        update: attribute => attribute.value = this.state.mesh.texCoords,\n        noAlloc\n      }\n    });\n  }\n  updateState(_ref) {\n    let {\n      props,\n      oldProps,\n      changeFlags\n    } = _ref;\n    // setup model first\n    const attributeManager = this.getAttributeManager();\n    if (changeFlags.extensionsChanged) {\n      this.state.model?.destroy();\n      this.state.model = this._getModel();\n      attributeManager.invalidateAll();\n    }\n    if (props.bounds !== oldProps.bounds) {\n      const oldMesh = this.state.mesh;\n      const mesh = this._createMesh();\n      this.state.model.setVertexCount(mesh.vertexCount);\n      for (const key in mesh) {\n        if (oldMesh && oldMesh[key] !== mesh[key]) {\n          attributeManager.invalidate(key);\n        }\n      }\n      this.setState({\n        mesh,\n        ...this._getCoordinateUniforms()\n      });\n    } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {\n      this.setState(this._getCoordinateUniforms());\n    }\n  }\n  getPickingInfo(params) {\n    const {\n      image\n    } = this.props;\n    const info = params.info;\n    if (!info.color || !image) {\n      info.bitmap = null;\n      return info;\n    }\n    const {\n      width,\n      height\n    } = image;\n    // Picking color doesn't represent object index in this layer\n    info.index = 0;\n    // Calculate uv and pixel in bitmap\n    const uv = unpackUVsFromRGB(info.color);\n    info.bitmap = {\n      size: {\n        width,\n        height\n      },\n      uv,\n      pixel: [Math.floor(uv[0] * width), Math.floor(uv[1] * height)]\n    };\n    return info;\n  }\n  // Override base Layer multi-depth picking logic\n  disablePickingIndex() {\n    this.setState({\n      disablePicking: true\n    });\n  }\n  restorePickingColors() {\n    this.setState({\n      disablePicking: false\n    });\n  }\n  _updateAutoHighlight(info) {\n    super._updateAutoHighlight({\n      ...info,\n      color: this.encodePickingColor(0)\n    });\n  }\n  _createMesh() {\n    const {\n      bounds\n    } = this.props;\n    let normalizedBounds = bounds;\n    // bounds as [minX, minY, maxX, maxY]\n    if (isRectangularBounds(bounds)) {\n      /*\n        (minX0, maxY3) ---- (maxX2, maxY3)\n               |                  |\n               |                  |\n               |                  |\n        (minX0, minY1) ---- (maxX2, minY1)\n      */\n      normalizedBounds = [[bounds[0], bounds[1]], [bounds[0], bounds[3]], [bounds[2], bounds[3]], [bounds[2], bounds[1]]];\n    }\n    return createMesh(normalizedBounds, this.context.viewport.resolution);\n  }\n  _getModel() {\n    /*\n      0,0 --- 1,0\n       |       |\n      0,1 --- 1,1\n    */\n    return new Model(this.context.device, {\n      ...this.getShaders(),\n      id: this.props.id,\n      bufferLayout: this.getAttributeManager().getBufferLayouts(),\n      topology: 'triangle-list',\n      isInstanced: false\n    });\n  }\n  draw(opts) {\n    const {\n      shaderModuleProps\n    } = opts;\n    const {\n      model,\n      coordinateConversion,\n      bounds,\n      disablePicking\n    } = this.state;\n    const {\n      image,\n      desaturate,\n      transparentColor,\n      tintColor\n    } = this.props;\n    if (shaderModuleProps.picking.isActive && disablePicking) {\n      return;\n    }\n    // // TODO fix zFighting\n    // Render the image\n    if (image && model) {\n      const bitmapProps = {\n        bitmapTexture: image,\n        bounds,\n        coordinateConversion,\n        desaturate,\n        tintColor: tintColor.slice(0, 3).map(x => x / 255),\n        transparentColor: transparentColor.map(x => x / 255)\n      };\n      model.shaderInputs.setProps({\n        bitmap: bitmapProps\n      });\n      model.draw(this.context.renderPass);\n    }\n  }\n  _getCoordinateUniforms() {\n    const {\n      LNGLAT,\n      CARTESIAN,\n      DEFAULT\n    } = COORDINATE_SYSTEM;\n    let {\n      _imageCoordinateSystem: imageCoordinateSystem\n    } = this.props;\n    if (imageCoordinateSystem !== DEFAULT) {\n      const {\n        bounds\n      } = this.props;\n      if (!isRectangularBounds(bounds)) {\n        throw new Error('_imageCoordinateSystem only supports rectangular bounds');\n      }\n      // The default behavior (linearly interpolated tex coords)\n      const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;\n      imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;\n      if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {\n        // LNGLAT in Mercator, e.g. display LNGLAT-encoded image in WebMercator projection\n        return {\n          coordinateConversion: -1,\n          bounds\n        };\n      }\n      if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {\n        // Mercator in LNGLAT, e.g. display WebMercator encoded image in Globe projection\n        const bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);\n        const topRight = lngLatToWorld([bounds[2], bounds[3]]);\n        return {\n          coordinateConversion: 1,\n          bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]\n        };\n      }\n    }\n    return {\n      coordinateConversion: 0,\n      bounds: [0, 0, 0, 0]\n    };\n  }\n}\nBitmapLayer.layerName = 'BitmapLayer';\nBitmapLayer.defaultProps = defaultProps;\nexport default BitmapLayer;\n/**\n * Decode uv floats from rgb bytes where b contains 4-bit fractions of uv\n * @param {number[]} color\n * @returns {number[]} uvs\n * https://stackoverflow.com/questions/30242013/glsl-compressing-packing-multiple-0-1-colours-var4-into-a-single-var4-variab\n */\nfunction unpackUVsFromRGB(color) {\n  const [u, v, fracUV] = color;\n  const vFrac = (fracUV & 0xf0) / 256;\n  const uFrac = (fracUV & 0x0f) / 16;\n  return [(u + uFrac) / 256, (v + vFrac) / 256];\n}\nfunction isRectangularBounds(bounds) {\n  return Number.isFinite(bounds[0]);\n}\n//# sourceMappingURL=bitmap-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}