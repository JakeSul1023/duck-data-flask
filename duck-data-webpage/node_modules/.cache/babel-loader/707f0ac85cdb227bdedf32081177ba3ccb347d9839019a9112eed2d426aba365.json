{"ast":null,"code":"import { getImageSize } from \"../category-api/parsed-image-api.js\";\n// @ts-ignore TS2339: Property does not exist on type\nconst encodeImageNode = globalThis.loaders?.encodeImageNode;\n/**\n * Returns data bytes representing a compressed image in PNG or JPG format,\n * This data can be saved using file system (f) methods or used in a request.\n * @param image - ImageBitmap Image or Canvas\n * @param options\n * param opt.type='png' - png, jpg or image/png, image/jpg are valid\n * param mimeType= - Whether to include a data URI header\n */\nexport async function encodeImage(image, options) {\n  options = options || {};\n  options.image = options.image || {};\n  return encodeImageNode ? encodeImageNode(image, {\n    type: options.image.mimeType\n  }) : encodeImageInBrowser(image, options);\n}\n// In case we get exceptions from canvas.toBlob(resolve, type, quality)\nlet qualityParamSupported = true;\n/**\n *\n * @param image\n * @param options\n * @note Based on canvas.toBlob\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob\n */\nasync function encodeImageInBrowser(image, options) {\n  const {\n    mimeType,\n    jpegQuality\n  } = options.image;\n  const {\n    width,\n    height\n  } = getImageSize(image);\n  // create a canvas and resize it to the size of our image\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  drawImageToCanvas(image, canvas);\n  // The actual encoding is done asynchronously with `canvas.toBlob()`\n  const blob = await new Promise(resolve => {\n    // get it back as a Blob\n    if (jpegQuality && qualityParamSupported) {\n      try {\n        canvas.toBlob(resolve, mimeType, jpegQuality);\n        return;\n      } catch (error) {\n        qualityParamSupported = false;\n      }\n    }\n    canvas.toBlob(resolve, mimeType);\n  });\n  if (!blob) {\n    throw new Error('image encoding failed');\n  }\n  return await blob.arrayBuffer();\n}\nfunction drawImageToCanvas(image, canvas) {\n  let x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  // Try optimized path for ImageBitmaps via bitmaprenderer context\n  if (x === 0 && y === 0 && typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    const context = canvas.getContext('bitmaprenderer');\n    if (context) {\n      // transfer the ImageBitmap to it\n      context.transferFromImageBitmap(image);\n      return canvas;\n    }\n  }\n  // Available on most platforms, except IE11 and Andriod WebViews...\n  const context = canvas.getContext('2d');\n  if (image.data) {\n    // ImageData constructor expects clamped array even though getImageData does not return a clamped array...\n    const clampedArray = new Uint8ClampedArray(image.data);\n    const imageData = new ImageData(clampedArray, image.width, image.height);\n    context.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n  // Fall back to generic image/image bitmap rendering path\n  context.drawImage(image, 0, 0);\n  return canvas;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}