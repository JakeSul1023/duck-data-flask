{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { DataViewFile, compareArrayBuffers, concatenateArrayBuffers } from '@loaders.gl/loader-utils';\nimport { parseEoCDRecord } from \"./end-of-central-directory.js\";\nimport { createZip64Info, setFieldToNumber } from \"./zip64-info-generation.js\";\n// offsets accroding to https://en.wikipedia.org/wiki/ZIP_(file_format)\nconst CD_COMPRESSED_SIZE_OFFSET = 20;\nconst CD_UNCOMPRESSED_SIZE_OFFSET = 24;\nconst CD_FILE_NAME_LENGTH_OFFSET = 28;\nconst CD_EXTRA_FIELD_LENGTH_OFFSET = 30;\nconst CD_START_DISK_OFFSET = 32;\nconst CD_LOCAL_HEADER_OFFSET_OFFSET = 42;\nconst CD_FILE_NAME_OFFSET = 46n;\nexport const signature = new Uint8Array([0x50, 0x4b, 0x01, 0x02]);\n/**\n * Parses central directory file header of zip file\n * @param headerOffset - offset in the archive where header starts\n * @param buffer - buffer containing whole array\n * @returns Info from the header\n */\nexport const parseZipCDFileHeader = async (headerOffset, file) => {\n  if (headerOffset >= file.length) {\n    return null;\n  }\n  const mainHeader = new DataView(await file.slice(headerOffset, headerOffset + CD_FILE_NAME_OFFSET));\n  const magicBytes = mainHeader.buffer.slice(0, 4);\n  if (!compareArrayBuffers(magicBytes, signature.buffer)) {\n    return null;\n  }\n  const compressedSize = BigInt(mainHeader.getUint32(CD_COMPRESSED_SIZE_OFFSET, true));\n  const uncompressedSize = BigInt(mainHeader.getUint32(CD_UNCOMPRESSED_SIZE_OFFSET, true));\n  const extraFieldLength = mainHeader.getUint16(CD_EXTRA_FIELD_LENGTH_OFFSET, true);\n  const startDisk = BigInt(mainHeader.getUint16(CD_START_DISK_OFFSET, true));\n  const fileNameLength = mainHeader.getUint16(CD_FILE_NAME_LENGTH_OFFSET, true);\n  const additionalHeader = await file.slice(headerOffset + CD_FILE_NAME_OFFSET, headerOffset + CD_FILE_NAME_OFFSET + BigInt(fileNameLength + extraFieldLength));\n  const filenameBytes = additionalHeader.slice(0, fileNameLength);\n  const fileName = new TextDecoder().decode(filenameBytes);\n  const extraOffset = headerOffset + CD_FILE_NAME_OFFSET + BigInt(fileNameLength);\n  const oldFormatOffset = mainHeader.getUint32(CD_LOCAL_HEADER_OFFSET_OFFSET, true);\n  const localHeaderOffset = BigInt(oldFormatOffset);\n  const extraField = new DataView(additionalHeader.slice(fileNameLength, additionalHeader.byteLength));\n  // looking for info that might be also be in zip64 extra field\n  const zip64data = {\n    uncompressedSize,\n    compressedSize,\n    localHeaderOffset,\n    startDisk\n  };\n  const res = findZip64DataInExtra(zip64data, extraField);\n  return {\n    ...zip64data,\n    ...res,\n    extraFieldLength,\n    fileNameLength,\n    fileName,\n    extraOffset\n  };\n};\n/**\n * Create iterator over files of zip archive\n * @param fileProvider - file provider that provider random access to the file\n */\nexport async function* makeZipCDHeaderIterator(fileProvider) {\n  const {\n    cdStartOffset,\n    cdByteSize\n  } = await parseEoCDRecord(fileProvider);\n  const centralDirectory = new DataViewFile(new DataView(await fileProvider.slice(cdStartOffset, cdStartOffset + cdByteSize)));\n  let cdHeader = await parseZipCDFileHeader(0n, centralDirectory);\n  while (cdHeader) {\n    yield cdHeader;\n    cdHeader = await parseZipCDFileHeader(cdHeader.extraOffset + BigInt(cdHeader.extraFieldLength), centralDirectory);\n  }\n}\n/**\n * returns the number written in the provided bytes\n * @param bytes two bytes containing the number\n * @returns the number written in the provided bytes\n */\nconst getUint16 = (...bytes) => {\n  return bytes[0] + bytes[1] * 16;\n};\n/**\n * reads all nesessary data from zip64 record in the extra data\n * @param zip64data values that might be in zip64 record\n * @param extraField full extra data\n * @returns data read from zip64\n */\nconst findZip64DataInExtra = (zip64data, extraField) => {\n  const zip64dataList = findExpectedData(zip64data);\n  const zip64DataRes = {};\n  if (zip64dataList.length > 0) {\n    // total length of data in zip64 notation in bytes\n    const zip64chunkSize = zip64dataList.reduce((sum, curr) => sum + curr.length, 0);\n    // we're looking for the zip64 nontation header (0x0001)\n    // and a size field with a correct value next to it\n    const offsetInExtraData = new Uint8Array(extraField.buffer).findIndex((_val, i, arr) => getUint16(arr[i], arr[i + 1]) === 0x0001 && getUint16(arr[i + 2], arr[i + 3]) === zip64chunkSize);\n    // then we read all the nesessary fields from the zip64 data\n    let bytesRead = 0;\n    for (const note of zip64dataList) {\n      const offset = bytesRead;\n      zip64DataRes[note.name] = extraField.getBigUint64(offsetInExtraData + 4 + offset, true);\n      bytesRead = offset + note.length;\n    }\n  }\n  return zip64DataRes;\n};\n/**\n * frind data that's expected to be in zip64\n * @param zip64data values that might be in zip64 record\n * @returns zip64 data description\n */\nconst findExpectedData = zip64data => {\n  // We define fields that should be in zip64 data\n  const zip64dataList = [];\n  if (zip64data.uncompressedSize === BigInt(0xffffffff)) {\n    zip64dataList.push({\n      name: 'uncompressedSize',\n      length: 8\n    });\n  }\n  if (zip64data.compressedSize === BigInt(0xffffffff)) {\n    zip64dataList.push({\n      name: 'compressedSize',\n      length: 8\n    });\n  }\n  if (zip64data.localHeaderOffset === BigInt(0xffffffff)) {\n    zip64dataList.push({\n      name: 'localHeaderOffset',\n      length: 8\n    });\n  }\n  if (zip64data.startDisk === BigInt(0xffffffff)) {\n    zip64dataList.push({\n      name: 'startDisk',\n      length: 4\n    });\n  }\n  return zip64dataList;\n};\n/**\n * generates cd header for the file\n * @param options info that can be placed into cd header\n * @returns buffer with header\n */\nexport function generateCDHeader(options) {\n  const optionsToUse = {\n    ...options,\n    fnlength: options.fileName.length,\n    extraLength: 0\n  };\n  let zip64header = new ArrayBuffer(0);\n  const optionsToZip64 = {};\n  if (optionsToUse.offset >= 0xffffffff) {\n    optionsToZip64.offset = optionsToUse.offset;\n    optionsToUse.offset = BigInt(0xffffffff);\n  }\n  if (optionsToUse.length >= 0xffffffff) {\n    optionsToZip64.size = optionsToUse.length;\n    optionsToUse.length = 0xffffffff;\n  }\n  if (Object.keys(optionsToZip64).length) {\n    zip64header = createZip64Info(optionsToZip64);\n    optionsToUse.extraLength = zip64header.byteLength;\n  }\n  const header = new DataView(new ArrayBuffer(Number(CD_FILE_NAME_OFFSET)));\n  for (const field of ZIP_HEADER_FIELDS) {\n    setFieldToNumber(header, field.size, field.offset, optionsToUse[field.name ?? ''] ?? field.default ?? 0);\n  }\n  const encodedName = new TextEncoder().encode(optionsToUse.fileName);\n  const resHeader = concatenateArrayBuffers(header.buffer, encodedName, zip64header);\n  return resHeader;\n}\n/** Fields map */\nconst ZIP_HEADER_FIELDS = [\n// Central directory file header signature = 0x02014b50\n{\n  offset: 0,\n  size: 4,\n  default: new DataView(signature.buffer).getUint32(0, true)\n},\n// Version made by\n{\n  offset: 4,\n  size: 2,\n  default: 45\n},\n// Version needed to extract (minimum)\n{\n  offset: 6,\n  size: 2,\n  default: 45\n},\n// General purpose bit flag\n{\n  offset: 8,\n  size: 2,\n  default: 0\n},\n// Compression method\n{\n  offset: 10,\n  size: 2,\n  default: 0\n},\n// File last modification time\n{\n  offset: 12,\n  size: 2,\n  default: 0\n},\n// File last modification date\n{\n  offset: 14,\n  size: 2,\n  default: 0\n},\n// CRC-32 of uncompressed data\n{\n  offset: 16,\n  size: 4,\n  name: 'crc32'\n},\n// Compressed size (or 0xffffffff for ZIP64)\n{\n  offset: 20,\n  size: 4,\n  name: 'length'\n},\n// Uncompressed size (or 0xffffffff for ZIP64)\n{\n  offset: 24,\n  size: 4,\n  name: 'length'\n},\n// File name length (n)\n{\n  offset: 28,\n  size: 2,\n  name: 'fnlength'\n},\n// Extra field length (m)\n{\n  offset: 30,\n  size: 2,\n  default: 0,\n  name: 'extraLength'\n},\n// File comment length (k)\n{\n  offset: 32,\n  size: 2,\n  default: 0\n},\n// Disk number where file starts (or 0xffff for ZIP64)\n{\n  offset: 34,\n  size: 2,\n  default: 0\n},\n// Internal file attributes\n{\n  offset: 36,\n  size: 2,\n  default: 0\n},\n// External file attributes\n{\n  offset: 38,\n  size: 4,\n  default: 0\n},\n// Relative offset of local file header\n{\n  offset: 42,\n  size: 4,\n  name: 'offset'\n}];","map":{"version":3,"names":["DataViewFile","compareArrayBuffers","concatenateArrayBuffers","parseEoCDRecord","createZip64Info","setFieldToNumber","CD_COMPRESSED_SIZE_OFFSET","CD_UNCOMPRESSED_SIZE_OFFSET","CD_FILE_NAME_LENGTH_OFFSET","CD_EXTRA_FIELD_LENGTH_OFFSET","CD_START_DISK_OFFSET","CD_LOCAL_HEADER_OFFSET_OFFSET","CD_FILE_NAME_OFFSET","signature","Uint8Array","parseZipCDFileHeader","headerOffset","file","length","mainHeader","DataView","slice","magicBytes","buffer","compressedSize","BigInt","getUint32","uncompressedSize","extraFieldLength","getUint16","startDisk","fileNameLength","additionalHeader","filenameBytes","fileName","TextDecoder","decode","extraOffset","oldFormatOffset","localHeaderOffset","extraField","byteLength","zip64data","res","findZip64DataInExtra","makeZipCDHeaderIterator","fileProvider","cdStartOffset","cdByteSize","centralDirectory","cdHeader","bytes","zip64dataList","findExpectedData","zip64DataRes","zip64chunkSize","reduce","sum","curr","offsetInExtraData","findIndex","_val","i","arr","bytesRead","note","offset","name","getBigUint64","push","generateCDHeader","options","optionsToUse","fnlength","extraLength","zip64header","ArrayBuffer","optionsToZip64","size","Object","keys","header","Number","field","ZIP_HEADER_FIELDS","default","encodedName","TextEncoder","encode","resHeader"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/zip/dist/parse-zip/cd-file-header.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { DataViewFile, compareArrayBuffers, concatenateArrayBuffers } from '@loaders.gl/loader-utils';\nimport { parseEoCDRecord } from \"./end-of-central-directory.js\";\nimport { createZip64Info, setFieldToNumber } from \"./zip64-info-generation.js\";\n// offsets accroding to https://en.wikipedia.org/wiki/ZIP_(file_format)\nconst CD_COMPRESSED_SIZE_OFFSET = 20;\nconst CD_UNCOMPRESSED_SIZE_OFFSET = 24;\nconst CD_FILE_NAME_LENGTH_OFFSET = 28;\nconst CD_EXTRA_FIELD_LENGTH_OFFSET = 30;\nconst CD_START_DISK_OFFSET = 32;\nconst CD_LOCAL_HEADER_OFFSET_OFFSET = 42;\nconst CD_FILE_NAME_OFFSET = 46n;\nexport const signature = new Uint8Array([0x50, 0x4b, 0x01, 0x02]);\n/**\n * Parses central directory file header of zip file\n * @param headerOffset - offset in the archive where header starts\n * @param buffer - buffer containing whole array\n * @returns Info from the header\n */\nexport const parseZipCDFileHeader = async (headerOffset, file) => {\n    if (headerOffset >= file.length) {\n        return null;\n    }\n    const mainHeader = new DataView(await file.slice(headerOffset, headerOffset + CD_FILE_NAME_OFFSET));\n    const magicBytes = mainHeader.buffer.slice(0, 4);\n    if (!compareArrayBuffers(magicBytes, signature.buffer)) {\n        return null;\n    }\n    const compressedSize = BigInt(mainHeader.getUint32(CD_COMPRESSED_SIZE_OFFSET, true));\n    const uncompressedSize = BigInt(mainHeader.getUint32(CD_UNCOMPRESSED_SIZE_OFFSET, true));\n    const extraFieldLength = mainHeader.getUint16(CD_EXTRA_FIELD_LENGTH_OFFSET, true);\n    const startDisk = BigInt(mainHeader.getUint16(CD_START_DISK_OFFSET, true));\n    const fileNameLength = mainHeader.getUint16(CD_FILE_NAME_LENGTH_OFFSET, true);\n    const additionalHeader = await file.slice(headerOffset + CD_FILE_NAME_OFFSET, headerOffset + CD_FILE_NAME_OFFSET + BigInt(fileNameLength + extraFieldLength));\n    const filenameBytes = additionalHeader.slice(0, fileNameLength);\n    const fileName = new TextDecoder().decode(filenameBytes);\n    const extraOffset = headerOffset + CD_FILE_NAME_OFFSET + BigInt(fileNameLength);\n    const oldFormatOffset = mainHeader.getUint32(CD_LOCAL_HEADER_OFFSET_OFFSET, true);\n    const localHeaderOffset = BigInt(oldFormatOffset);\n    const extraField = new DataView(additionalHeader.slice(fileNameLength, additionalHeader.byteLength));\n    // looking for info that might be also be in zip64 extra field\n    const zip64data = {\n        uncompressedSize,\n        compressedSize,\n        localHeaderOffset,\n        startDisk\n    };\n    const res = findZip64DataInExtra(zip64data, extraField);\n    return {\n        ...zip64data,\n        ...res,\n        extraFieldLength,\n        fileNameLength,\n        fileName,\n        extraOffset\n    };\n};\n/**\n * Create iterator over files of zip archive\n * @param fileProvider - file provider that provider random access to the file\n */\nexport async function* makeZipCDHeaderIterator(fileProvider) {\n    const { cdStartOffset, cdByteSize } = await parseEoCDRecord(fileProvider);\n    const centralDirectory = new DataViewFile(new DataView(await fileProvider.slice(cdStartOffset, cdStartOffset + cdByteSize)));\n    let cdHeader = await parseZipCDFileHeader(0n, centralDirectory);\n    while (cdHeader) {\n        yield cdHeader;\n        cdHeader = await parseZipCDFileHeader(cdHeader.extraOffset + BigInt(cdHeader.extraFieldLength), centralDirectory);\n    }\n}\n/**\n * returns the number written in the provided bytes\n * @param bytes two bytes containing the number\n * @returns the number written in the provided bytes\n */\nconst getUint16 = (...bytes) => {\n    return bytes[0] + bytes[1] * 16;\n};\n/**\n * reads all nesessary data from zip64 record in the extra data\n * @param zip64data values that might be in zip64 record\n * @param extraField full extra data\n * @returns data read from zip64\n */\nconst findZip64DataInExtra = (zip64data, extraField) => {\n    const zip64dataList = findExpectedData(zip64data);\n    const zip64DataRes = {};\n    if (zip64dataList.length > 0) {\n        // total length of data in zip64 notation in bytes\n        const zip64chunkSize = zip64dataList.reduce((sum, curr) => sum + curr.length, 0);\n        // we're looking for the zip64 nontation header (0x0001)\n        // and a size field with a correct value next to it\n        const offsetInExtraData = new Uint8Array(extraField.buffer).findIndex((_val, i, arr) => getUint16(arr[i], arr[i + 1]) === 0x0001 &&\n            getUint16(arr[i + 2], arr[i + 3]) === zip64chunkSize);\n        // then we read all the nesessary fields from the zip64 data\n        let bytesRead = 0;\n        for (const note of zip64dataList) {\n            const offset = bytesRead;\n            zip64DataRes[note.name] = extraField.getBigUint64(offsetInExtraData + 4 + offset, true);\n            bytesRead = offset + note.length;\n        }\n    }\n    return zip64DataRes;\n};\n/**\n * frind data that's expected to be in zip64\n * @param zip64data values that might be in zip64 record\n * @returns zip64 data description\n */\nconst findExpectedData = (zip64data) => {\n    // We define fields that should be in zip64 data\n    const zip64dataList = [];\n    if (zip64data.uncompressedSize === BigInt(0xffffffff)) {\n        zip64dataList.push({ name: 'uncompressedSize', length: 8 });\n    }\n    if (zip64data.compressedSize === BigInt(0xffffffff)) {\n        zip64dataList.push({ name: 'compressedSize', length: 8 });\n    }\n    if (zip64data.localHeaderOffset === BigInt(0xffffffff)) {\n        zip64dataList.push({ name: 'localHeaderOffset', length: 8 });\n    }\n    if (zip64data.startDisk === BigInt(0xffffffff)) {\n        zip64dataList.push({ name: 'startDisk', length: 4 });\n    }\n    return zip64dataList;\n};\n/**\n * generates cd header for the file\n * @param options info that can be placed into cd header\n * @returns buffer with header\n */\nexport function generateCDHeader(options) {\n    const optionsToUse = {\n        ...options,\n        fnlength: options.fileName.length,\n        extraLength: 0\n    };\n    let zip64header = new ArrayBuffer(0);\n    const optionsToZip64 = {};\n    if (optionsToUse.offset >= 0xffffffff) {\n        optionsToZip64.offset = optionsToUse.offset;\n        optionsToUse.offset = BigInt(0xffffffff);\n    }\n    if (optionsToUse.length >= 0xffffffff) {\n        optionsToZip64.size = optionsToUse.length;\n        optionsToUse.length = 0xffffffff;\n    }\n    if (Object.keys(optionsToZip64).length) {\n        zip64header = createZip64Info(optionsToZip64);\n        optionsToUse.extraLength = zip64header.byteLength;\n    }\n    const header = new DataView(new ArrayBuffer(Number(CD_FILE_NAME_OFFSET)));\n    for (const field of ZIP_HEADER_FIELDS) {\n        setFieldToNumber(header, field.size, field.offset, optionsToUse[field.name ?? ''] ?? field.default ?? 0);\n    }\n    const encodedName = new TextEncoder().encode(optionsToUse.fileName);\n    const resHeader = concatenateArrayBuffers(header.buffer, encodedName, zip64header);\n    return resHeader;\n}\n/** Fields map */\nconst ZIP_HEADER_FIELDS = [\n    // Central directory file header signature = 0x02014b50\n    {\n        offset: 0,\n        size: 4,\n        default: new DataView(signature.buffer).getUint32(0, true)\n    },\n    // Version made by\n    {\n        offset: 4,\n        size: 2,\n        default: 45\n    },\n    // Version needed to extract (minimum)\n    {\n        offset: 6,\n        size: 2,\n        default: 45\n    },\n    // General purpose bit flag\n    {\n        offset: 8,\n        size: 2,\n        default: 0\n    },\n    // Compression method\n    {\n        offset: 10,\n        size: 2,\n        default: 0\n    },\n    // File last modification time\n    {\n        offset: 12,\n        size: 2,\n        default: 0\n    },\n    // File last modification date\n    {\n        offset: 14,\n        size: 2,\n        default: 0\n    },\n    // CRC-32 of uncompressed data\n    {\n        offset: 16,\n        size: 4,\n        name: 'crc32'\n    },\n    // Compressed size (or 0xffffffff for ZIP64)\n    {\n        offset: 20,\n        size: 4,\n        name: 'length'\n    },\n    // Uncompressed size (or 0xffffffff for ZIP64)\n    {\n        offset: 24,\n        size: 4,\n        name: 'length'\n    },\n    // File name length (n)\n    {\n        offset: 28,\n        size: 2,\n        name: 'fnlength'\n    },\n    // Extra field length (m)\n    {\n        offset: 30,\n        size: 2,\n        default: 0,\n        name: 'extraLength'\n    },\n    // File comment length (k)\n    {\n        offset: 32,\n        size: 2,\n        default: 0\n    },\n    // Disk number where file starts (or 0xffff for ZIP64)\n    {\n        offset: 34,\n        size: 2,\n        default: 0\n    },\n    // Internal file attributes\n    {\n        offset: 36,\n        size: 2,\n        default: 0\n    },\n    // External file attributes\n    {\n        offset: 38,\n        size: 4,\n        default: 0\n    },\n    // Relative offset of local file header\n    {\n        offset: 42,\n        size: 4,\n        name: 'offset'\n    }\n];\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}