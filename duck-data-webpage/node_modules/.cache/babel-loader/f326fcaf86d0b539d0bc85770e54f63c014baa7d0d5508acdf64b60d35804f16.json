{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport * as React from 'react';\nimport { createElement, useRef, useState, useMemo, useEffect, useImperativeHandle } from 'react';\nimport { Deck } from '@deck.gl/core';\nimport useIsomorphicLayoutEffect from \"./utils/use-isomorphic-layout-effect.js\";\nimport extractJSXLayers from \"./utils/extract-jsx-layers.js\";\nimport positionChildrenUnderViews from \"./utils/position-children-under-views.js\";\nimport extractStyles from \"./utils/extract-styles.js\";\nfunction getRefHandles(thisRef) {\n  return {\n    get deck() {\n      return thisRef.deck;\n    },\n    // The following method can only be called after ref is available, by which point deck is defined in useEffect\n    pickObject: opts => thisRef.deck.pickObject(opts),\n    pickMultipleObjects: opts => thisRef.deck.pickMultipleObjects(opts),\n    pickObjects: opts => thisRef.deck.pickObjects(opts)\n  };\n}\nfunction redrawDeck(thisRef) {\n  if (thisRef.redrawReason) {\n    // Only redraw if we have received a dirty flag\n    // @ts-expect-error accessing protected method\n    thisRef.deck._drawLayers(thisRef.redrawReason);\n    thisRef.redrawReason = null;\n  }\n}\nfunction createDeckInstance(thisRef, DeckClass, props) {\n  const deck = new DeckClass({\n    ...props,\n    // The Deck's animation loop is independent from React's render cycle, causing potential\n    // synchronization issues. We provide this custom render function to make sure that React\n    // and Deck update on the same schedule.\n    // TODO(ibgreen) - Hack to enable WebGPU as it needs to render quickly to avoid CanvasContext texture from going stale\n    _customRender: props.deviceProps?.adapters?.[0]?.type === 'webgpu' ? undefined : redrawReason => {\n      // Save the dirty flag for later\n      thisRef.redrawReason = redrawReason;\n      // Viewport/view state is passed to child components as props.\n      // If they have changed, we need to trigger a React rerender to update children props.\n      const viewports = deck.getViewports();\n      if (thisRef.lastRenderedViewports !== viewports) {\n        // Viewports have changed, update children props first.\n        // This will delay the Deck canvas redraw till after React update (in useLayoutEffect)\n        // so that the canvas does not get rendered before the child components update.\n        thisRef.forceUpdate();\n      } else {\n        redrawDeck(thisRef);\n      }\n    }\n  });\n  return deck;\n}\nfunction DeckGLWithRef(props, ref) {\n  // A mechanism to force redraw\n  const [version, setVersion] = useState(0);\n  // A reference to persistent states\n  const _thisRef = useRef({\n    control: null,\n    version,\n    forceUpdate: () => setVersion(v => v + 1)\n  });\n  const thisRef = _thisRef.current;\n  // DOM refs\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  // extract any deck.gl layers masquerading as react elements from props.children\n  const jsxProps = useMemo(() => extractJSXLayers(props), [props.layers, props.views, props.children]);\n  // Callbacks\n  let inRender = true;\n  const handleViewStateChange = params => {\n    if (inRender && props.viewState) {\n      // Callback may invoke a state update. Defer callback to after render() to avoid React error\n      // In React StrictMode, render is executed twice and useEffect/useLayoutEffect is executed once\n      // Store deferred parameters in ref so that we can access it in another render\n      thisRef.viewStateUpdateRequested = params;\n      return null;\n    }\n    thisRef.viewStateUpdateRequested = null;\n    return props.onViewStateChange?.(params);\n  };\n  const handleInteractionStateChange = params => {\n    if (inRender) {\n      // Callback may invoke a state update. Defer callback to after render() to avoid React error\n      // In React StrictMode, render is executed twice and useEffect/useLayoutEffect is executed once\n      // Store deferred parameters in ref so that we can access it in another render\n      thisRef.interactionStateUpdateRequested = params;\n    } else {\n      thisRef.interactionStateUpdateRequested = null;\n      props.onInteractionStateChange?.(params);\n    }\n  };\n  // Update Deck's props. If Deck needs redraw, this will trigger a call to `_customRender` in\n  // the next animation frame.\n  // Needs to be called both from initial mount, and when new props are received\n  const deckProps = useMemo(() => {\n    const forwardProps = {\n      widgets: [],\n      ...props,\n      // Override user styling props. We will set the canvas style in render()\n      style: null,\n      width: '100%',\n      height: '100%',\n      parent: containerRef.current,\n      canvas: canvasRef.current,\n      layers: jsxProps.layers,\n      views: jsxProps.views,\n      onViewStateChange: handleViewStateChange,\n      onInteractionStateChange: handleInteractionStateChange\n    };\n    // The defaultValue for _customRender is null, which would overwrite the definition\n    // of _customRender. Remove to avoid frequently redeclaring the method here.\n    delete forwardProps._customRender;\n    if (thisRef.deck) {\n      thisRef.deck.setProps(forwardProps);\n    }\n    return forwardProps;\n  }, [props]);\n  useEffect(() => {\n    const DeckClass = props.Deck || Deck;\n    thisRef.deck = createDeckInstance(thisRef, DeckClass, {\n      ...deckProps,\n      parent: containerRef.current,\n      canvas: canvasRef.current\n    });\n    return () => thisRef.deck?.finalize();\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    // render has just been called. The children are positioned based on the current view state.\n    // Redraw Deck canvas immediately, if necessary, using the current view state, so that it\n    // matches the child components.\n    redrawDeck(thisRef);\n    // Execute deferred callbacks\n    const {\n      viewStateUpdateRequested,\n      interactionStateUpdateRequested\n    } = thisRef;\n    if (viewStateUpdateRequested) {\n      handleViewStateChange(viewStateUpdateRequested);\n    }\n    if (interactionStateUpdateRequested) {\n      handleInteractionStateChange(interactionStateUpdateRequested);\n    }\n  });\n  useImperativeHandle(ref, () => getRefHandles(thisRef), []);\n  const currentViewports = thisRef.deck && thisRef.deck.isInitialized ? thisRef.deck.getViewports() : undefined;\n  const {\n    ContextProvider,\n    width = '100%',\n    height = '100%',\n    id,\n    style\n  } = props;\n  const {\n    containerStyle,\n    canvasStyle\n  } = useMemo(() => extractStyles({\n    width,\n    height,\n    style\n  }), [width, height, style]);\n  // Props changes may lead to 3 types of updates:\n  // 1. Only the WebGL canvas - updated in Deck's render cycle (next animation frame)\n  // 2. Only the DOM - updated in React's lifecycle (now)\n  // 3. Both the WebGL canvas and the DOM - defer React rerender to next animation frame just\n  //    before Deck redraw to ensure perfect synchronization & avoid excessive redraw\n  //    This is because multiple changes may happen to Deck between two frames e.g. transition\n  if (!thisRef.viewStateUpdateRequested && thisRef.lastRenderedViewports === currentViewports ||\n  // case 2\n  thisRef.version !== version // case 3 just before deck redraws\n  ) {\n    thisRef.lastRenderedViewports = currentViewports;\n    thisRef.version = version;\n    // Render the background elements (typically react-map-gl instances)\n    // using the view descriptors\n    const childrenUnderViews = positionChildrenUnderViews({\n      children: jsxProps.children,\n      deck: thisRef.deck,\n      ContextProvider\n    });\n    const canvas = createElement('canvas', {\n      key: 'canvas',\n      id: id || 'deckgl-overlay',\n      ref: canvasRef,\n      style: canvasStyle\n    });\n    // Render deck.gl as the last child\n    thisRef.control = createElement('div', {\n      id: `${id || 'deckgl'}-wrapper`,\n      ref: containerRef,\n      style: containerStyle\n    }, [canvas, childrenUnderViews]);\n  }\n  inRender = false;\n  return thisRef.control;\n}\nconst DeckGL = React.forwardRef(DeckGLWithRef);\nexport default DeckGL;","map":{"version":3,"names":["React","createElement","useRef","useState","useMemo","useEffect","useImperativeHandle","Deck","useIsomorphicLayoutEffect","extractJSXLayers","positionChildrenUnderViews","extractStyles","getRefHandles","thisRef","deck","pickObject","opts","pickMultipleObjects","pickObjects","redrawDeck","redrawReason","_drawLayers","createDeckInstance","DeckClass","props","_customRender","deviceProps","adapters","type","undefined","viewports","getViewports","lastRenderedViewports","forceUpdate","DeckGLWithRef","ref","version","setVersion","_thisRef","control","v","current","containerRef","canvasRef","jsxProps","layers","views","children","inRender","handleViewStateChange","params","viewState","viewStateUpdateRequested","onViewStateChange","handleInteractionStateChange","interactionStateUpdateRequested","onInteractionStateChange","deckProps","forwardProps","widgets","style","width","height","parent","canvas","setProps","finalize","currentViewports","isInitialized","ContextProvider","id","containerStyle","canvasStyle","childrenUnderViews","key","DeckGL","forwardRef"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\react\\src\\deckgl.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport * as React from 'react';\nimport {createElement, useRef, useState, useMemo, useEffect, useImperativeHandle} from 'react';\nimport {Deck} from '@deck.gl/core';\nimport useIsomorphicLayoutEffect from './utils/use-isomorphic-layout-effect';\n\nimport extractJSXLayers, {DeckGLRenderCallback} from './utils/extract-jsx-layers';\nimport positionChildrenUnderViews from './utils/position-children-under-views';\nimport extractStyles from './utils/extract-styles';\n\nimport type {DeckGLContextValue} from './utils/deckgl-context';\nimport type {DeckProps, View, Viewport} from '@deck.gl/core';\n\nexport type ViewOrViews = View | View[] | null;\n\n/* eslint-disable max-statements, accessor-pairs */\ntype DeckInstanceRef<ViewsT extends ViewOrViews> = {\n  deck?: Deck<ViewsT>;\n  redrawReason?: string | null;\n  lastRenderedViewports?: Viewport[];\n  viewStateUpdateRequested?: any;\n  interactionStateUpdateRequested?: any;\n  forceUpdate: () => void;\n  version: number;\n  control: React.ReactHTMLElement<HTMLElement> | null;\n};\n\n// Remove prop types in the base Deck class that support externally supplied canvas/WebGLContext\n/** DeckGL React component props */\nexport type DeckGLProps<ViewsT extends ViewOrViews = null> = Omit<\n  DeckProps<ViewsT>,\n  'width' | 'height' | 'gl' | 'parent' | 'canvas' | '_customRender'\n> & {\n  Deck?: typeof Deck;\n  width?: string | number;\n  height?: string | number;\n  children?: React.ReactNode | DeckGLRenderCallback;\n  ref?: React.Ref<DeckGLRef<ViewsT>>;\n  ContextProvider?: React.Context<DeckGLContextValue>['Provider'];\n};\n\nexport type DeckGLRef<ViewsT extends ViewOrViews = null> = {\n  deck?: Deck<ViewsT>;\n  pickObject: Deck['pickObject'];\n  pickObjects: Deck['pickObjects'];\n  pickMultipleObjects: Deck['pickMultipleObjects'];\n};\n\nfunction getRefHandles<ViewsT extends ViewOrViews>(\n  thisRef: DeckInstanceRef<ViewsT>\n): DeckGLRef<ViewsT> {\n  return {\n    get deck() {\n      return thisRef.deck;\n    },\n    // The following method can only be called after ref is available, by which point deck is defined in useEffect\n    pickObject: opts => thisRef.deck!.pickObject(opts),\n    pickMultipleObjects: opts => thisRef.deck!.pickMultipleObjects(opts),\n    pickObjects: opts => thisRef.deck!.pickObjects(opts)\n  };\n}\n\nfunction redrawDeck(thisRef: DeckInstanceRef<any>) {\n  if (thisRef.redrawReason) {\n    // Only redraw if we have received a dirty flag\n    // @ts-expect-error accessing protected method\n    thisRef.deck._drawLayers(thisRef.redrawReason);\n    thisRef.redrawReason = null;\n  }\n}\n\nfunction createDeckInstance<ViewsT extends ViewOrViews>(\n  thisRef: DeckInstanceRef<ViewsT>,\n  DeckClass: typeof Deck,\n  props: DeckProps<ViewsT>\n): Deck<ViewsT> {\n  const deck = new DeckClass({\n    ...props,\n    // The Deck's animation loop is independent from React's render cycle, causing potential\n    // synchronization issues. We provide this custom render function to make sure that React\n    // and Deck update on the same schedule.\n    // TODO(ibgreen) - Hack to enable WebGPU as it needs to render quickly to avoid CanvasContext texture from going stale\n    _customRender:\n      props.deviceProps?.adapters?.[0]?.type === 'webgpu'\n        ? undefined\n        : redrawReason => {\n            // Save the dirty flag for later\n            thisRef.redrawReason = redrawReason;\n\n            // Viewport/view state is passed to child components as props.\n            // If they have changed, we need to trigger a React rerender to update children props.\n            const viewports = deck.getViewports();\n            if (thisRef.lastRenderedViewports !== viewports) {\n              // Viewports have changed, update children props first.\n              // This will delay the Deck canvas redraw till after React update (in useLayoutEffect)\n              // so that the canvas does not get rendered before the child components update.\n              thisRef.forceUpdate();\n            } else {\n              redrawDeck(thisRef);\n            }\n          }\n  });\n  return deck;\n}\n\nfunction DeckGLWithRef<ViewsT extends ViewOrViews = null>(\n  props: DeckGLProps<ViewsT>,\n  ref: React.Ref<DeckGLRef<ViewsT>>\n) {\n  // A mechanism to force redraw\n  const [version, setVersion] = useState(0);\n  // A reference to persistent states\n  const _thisRef = useRef<DeckInstanceRef<ViewsT>>({\n    control: null,\n    version,\n    forceUpdate: () => setVersion(v => v + 1)\n  });\n  const thisRef = _thisRef.current;\n  // DOM refs\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n\n  // extract any deck.gl layers masquerading as react elements from props.children\n  const jsxProps = useMemo(\n    () => extractJSXLayers(props),\n    [props.layers, props.views, props.children]\n  );\n\n  // Callbacks\n  let inRender = true;\n\n  const handleViewStateChange: DeckProps<ViewsT>['onViewStateChange'] = params => {\n    if (inRender && props.viewState) {\n      // Callback may invoke a state update. Defer callback to after render() to avoid React error\n      // In React StrictMode, render is executed twice and useEffect/useLayoutEffect is executed once\n      // Store deferred parameters in ref so that we can access it in another render\n      thisRef.viewStateUpdateRequested = params;\n      return null;\n    }\n    thisRef.viewStateUpdateRequested = null;\n    return props.onViewStateChange?.(params);\n  };\n\n  const handleInteractionStateChange: DeckProps<ViewsT>['onInteractionStateChange'] = params => {\n    if (inRender) {\n      // Callback may invoke a state update. Defer callback to after render() to avoid React error\n      // In React StrictMode, render is executed twice and useEffect/useLayoutEffect is executed once\n      // Store deferred parameters in ref so that we can access it in another render\n      thisRef.interactionStateUpdateRequested = params;\n    } else {\n      thisRef.interactionStateUpdateRequested = null;\n      props.onInteractionStateChange?.(params);\n    }\n  };\n\n  // Update Deck's props. If Deck needs redraw, this will trigger a call to `_customRender` in\n  // the next animation frame.\n  // Needs to be called both from initial mount, and when new props are received\n  const deckProps = useMemo(() => {\n    const forwardProps: DeckProps<ViewsT> = {\n      widgets: [],\n      ...props,\n      // Override user styling props. We will set the canvas style in render()\n      style: null,\n      width: '100%',\n      height: '100%',\n      parent: containerRef.current,\n      canvas: canvasRef.current,\n      layers: jsxProps.layers,\n      views: jsxProps.views as ViewsT,\n      onViewStateChange: handleViewStateChange,\n      onInteractionStateChange: handleInteractionStateChange\n    };\n\n    // The defaultValue for _customRender is null, which would overwrite the definition\n    // of _customRender. Remove to avoid frequently redeclaring the method here.\n    delete forwardProps._customRender;\n\n    if (thisRef.deck) {\n      thisRef.deck.setProps(forwardProps);\n    }\n\n    return forwardProps;\n  }, [props]);\n\n  useEffect(() => {\n    const DeckClass = props.Deck || Deck;\n\n    thisRef.deck = createDeckInstance(thisRef, DeckClass, {\n      ...deckProps,\n      parent: containerRef.current,\n      canvas: canvasRef.current\n    });\n\n    return () => thisRef.deck?.finalize();\n  }, []);\n\n  useIsomorphicLayoutEffect(() => {\n    // render has just been called. The children are positioned based on the current view state.\n    // Redraw Deck canvas immediately, if necessary, using the current view state, so that it\n    // matches the child components.\n    redrawDeck(thisRef);\n\n    // Execute deferred callbacks\n    const {viewStateUpdateRequested, interactionStateUpdateRequested} = thisRef;\n    if (viewStateUpdateRequested) {\n      handleViewStateChange(viewStateUpdateRequested);\n    }\n    if (interactionStateUpdateRequested) {\n      handleInteractionStateChange(interactionStateUpdateRequested);\n    }\n  });\n\n  useImperativeHandle(ref, () => getRefHandles(thisRef), []);\n\n  const currentViewports =\n    thisRef.deck && thisRef.deck.isInitialized ? thisRef.deck.getViewports() : undefined;\n\n  const {ContextProvider, width = '100%', height = '100%', id, style} = props;\n\n  const {containerStyle, canvasStyle} = useMemo(\n    () => extractStyles({width, height, style}),\n    [width, height, style]\n  );\n\n  // Props changes may lead to 3 types of updates:\n  // 1. Only the WebGL canvas - updated in Deck's render cycle (next animation frame)\n  // 2. Only the DOM - updated in React's lifecycle (now)\n  // 3. Both the WebGL canvas and the DOM - defer React rerender to next animation frame just\n  //    before Deck redraw to ensure perfect synchronization & avoid excessive redraw\n  //    This is because multiple changes may happen to Deck between two frames e.g. transition\n  if (\n    (!thisRef.viewStateUpdateRequested && thisRef.lastRenderedViewports === currentViewports) || // case 2\n    thisRef.version !== version // case 3 just before deck redraws\n  ) {\n    thisRef.lastRenderedViewports = currentViewports;\n    thisRef.version = version;\n\n    // Render the background elements (typically react-map-gl instances)\n    // using the view descriptors\n    const childrenUnderViews = positionChildrenUnderViews({\n      children: jsxProps.children,\n      deck: thisRef.deck,\n      ContextProvider\n    });\n\n    const canvas = createElement('canvas', {\n      key: 'canvas',\n      id: id || 'deckgl-overlay',\n      ref: canvasRef,\n      style: canvasStyle\n    });\n\n    // Render deck.gl as the last child\n    thisRef.control = createElement(\n      'div',\n      {id: `${id || 'deckgl'}-wrapper`, ref: containerRef, style: containerStyle},\n      [canvas, childrenUnderViews]\n    );\n  }\n\n  inRender = false;\n  return thisRef.control;\n}\n\nconst DeckGL = React.forwardRef(DeckGLWithRef) as <ViewsT extends ViewOrViews>(\n  props: DeckGLProps<ViewsT>\n) => React.ReactElement;\n\nexport default DeckGL;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}