{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// deck.gl, MIT license\nimport GPUInterpolationTransition from \"../../transitions/gpu-interpolation-transition.js\";\nimport GPUSpringTransition from \"../../transitions/gpu-spring-transition.js\";\nimport log from \"../../utils/log.js\";\nconst TRANSITION_TYPES = {\n  interpolation: GPUInterpolationTransition,\n  spring: GPUSpringTransition\n};\nexport default class AttributeTransitionManager {\n  constructor(device, {\n    id,\n    timeline\n  }) {\n    if (!device) throw new Error('AttributeTransitionManager is constructed without device');\n    this.id = id;\n    this.device = device;\n    this.timeline = timeline;\n    this.transitions = {};\n    this.needsRedraw = false;\n    this.numInstances = 1;\n  }\n  finalize() {\n    for (const attributeName in this.transitions) {\n      this._removeTransition(attributeName);\n    }\n  }\n  /* Public methods */\n  // Called when attribute manager updates\n  // Check the latest attributes for updates.\n  update({\n    attributes,\n    transitions,\n    numInstances\n  }) {\n    // Transform class will crash if elementCount is 0\n    this.numInstances = numInstances || 1;\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const settings = attribute.getTransitionSetting(transitions);\n      // this attribute might not support transitions?\n      if (!settings) continue; // eslint-disable-line no-continue\n      this._updateAttribute(attributeName, attribute, settings);\n    }\n    for (const attributeName in this.transitions) {\n      const attribute = attributes[attributeName];\n      if (!attribute || !attribute.getTransitionSetting(transitions)) {\n        // Animated attribute has been removed\n        this._removeTransition(attributeName);\n      }\n    }\n  }\n  // Returns `true` if attribute is transition-enabled\n  hasAttribute(attributeName) {\n    const transition = this.transitions[attributeName];\n    return transition && transition.inProgress;\n  }\n  // Get all the animated attributes\n  getAttributes() {\n    const animatedAttributes = {};\n    for (const attributeName in this.transitions) {\n      const transition = this.transitions[attributeName];\n      if (transition.inProgress) {\n        animatedAttributes[attributeName] = transition.attributeInTransition;\n      }\n    }\n    return animatedAttributes;\n  }\n  /* eslint-disable max-statements */\n  // Called every render cycle, run transform feedback\n  // Returns `true` if anything changes\n  run() {\n    if (this.numInstances === 0) {\n      return false;\n    }\n    for (const attributeName in this.transitions) {\n      const updated = this.transitions[attributeName].update();\n      if (updated) {\n        this.needsRedraw = true;\n      }\n    }\n    const needsRedraw = this.needsRedraw;\n    this.needsRedraw = false;\n    return needsRedraw;\n  }\n  /* eslint-enable max-statements */\n  /* Private methods */\n  _removeTransition(attributeName) {\n    this.transitions[attributeName].delete();\n    delete this.transitions[attributeName];\n  }\n  // Check an attributes for updates\n  // Returns a transition object if a new transition is triggered.\n  _updateAttribute(attributeName, attribute, settings) {\n    const transition = this.transitions[attributeName];\n    // an attribute can change transition type when it updates\n    // let's remove the transition when that happens so we can create the new transition type\n    // TODO: when switching transition types, make sure to carry over the attribute's\n    // previous buffers, currentLength, startIndices, etc, to be used as the starting point\n    // for the next transition\n    let isNew = !transition || transition.type !== settings.type;\n    if (isNew) {\n      if (transition) {\n        this._removeTransition(attributeName);\n      }\n      const TransitionType = TRANSITION_TYPES[settings.type];\n      if (TransitionType) {\n        this.transitions[attributeName] = new TransitionType({\n          attribute,\n          timeline: this.timeline,\n          device: this.device\n        });\n      } else {\n        log.error(`unsupported transition type '${settings.type}'`)();\n        isNew = false;\n      }\n    }\n    if (isNew || attribute.needsRedraw()) {\n      this.needsRedraw = true;\n      this.transitions[attributeName].start(settings, this.numInstances);\n    }\n  }\n}","map":{"version":3,"names":["GPUInterpolationTransition","GPUSpringTransition","log","TRANSITION_TYPES","interpolation","spring","AttributeTransitionManager","constructor","device","id","timeline","Error","transitions","needsRedraw","numInstances","finalize","attributeName","_removeTransition","update","attributes","attribute","settings","getTransitionSetting","_updateAttribute","hasAttribute","transition","inProgress","getAttributes","animatedAttributes","attributeInTransition","run","updated","delete","isNew","type","TransitionType","error","start"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\lib\\attribute\\attribute-transition-manager.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// deck.gl, MIT license\n\nimport GPUInterpolationTransition from '../../transitions/gpu-interpolation-transition';\nimport GPUSpringTransition from '../../transitions/gpu-spring-transition';\nimport log from '../../utils/log';\n\nimport type {Device} from '@luma.gl/core';\nimport type {Timeline} from '@luma.gl/engine';\nimport type {GPUTransition} from '../../transitions/gpu-transition';\nimport type {ConstructorOf} from '../../types/types';\nimport type Attribute from './attribute';\nimport type {TransitionSettings} from './transition-settings';\n\nconst TRANSITION_TYPES: Record<string, ConstructorOf<GPUTransition>> = {\n  interpolation: GPUInterpolationTransition,\n  spring: GPUSpringTransition\n};\n\nexport default class AttributeTransitionManager {\n  id: string;\n\n  private device: Device;\n  private timeline?: Timeline;\n\n  private transitions: {[id: string]: GPUTransition};\n  private needsRedraw: boolean;\n  private numInstances: number;\n\n  constructor(\n    device: Device,\n    {\n      id,\n      timeline\n    }: {\n      id: string;\n      timeline?: Timeline;\n    }\n  ) {\n    if (!device) throw new Error('AttributeTransitionManager is constructed without device');\n    this.id = id;\n    this.device = device;\n    this.timeline = timeline;\n\n    this.transitions = {};\n    this.needsRedraw = false;\n    this.numInstances = 1;\n  }\n\n  finalize(): void {\n    for (const attributeName in this.transitions) {\n      this._removeTransition(attributeName);\n    }\n  }\n\n  /* Public methods */\n\n  // Called when attribute manager updates\n  // Check the latest attributes for updates.\n  update({\n    attributes,\n    transitions,\n    numInstances\n  }: {\n    attributes: {[id: string]: Attribute};\n    transitions: any;\n    numInstances: number;\n  }): void {\n    // Transform class will crash if elementCount is 0\n    this.numInstances = numInstances || 1;\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const settings = attribute.getTransitionSetting(transitions);\n\n      // this attribute might not support transitions?\n      if (!settings) continue; // eslint-disable-line no-continue\n      this._updateAttribute(attributeName, attribute, settings);\n    }\n\n    for (const attributeName in this.transitions) {\n      const attribute = attributes[attributeName];\n      if (!attribute || !attribute.getTransitionSetting(transitions)) {\n        // Animated attribute has been removed\n        this._removeTransition(attributeName);\n      }\n    }\n  }\n\n  // Returns `true` if attribute is transition-enabled\n  hasAttribute(attributeName: string): boolean {\n    const transition = this.transitions[attributeName];\n    return transition && transition.inProgress;\n  }\n\n  // Get all the animated attributes\n  getAttributes(): {[id: string]: Attribute} {\n    const animatedAttributes = {};\n\n    for (const attributeName in this.transitions) {\n      const transition = this.transitions[attributeName];\n      if (transition.inProgress) {\n        animatedAttributes[attributeName] = transition.attributeInTransition;\n      }\n    }\n\n    return animatedAttributes;\n  }\n\n  /* eslint-disable max-statements */\n  // Called every render cycle, run transform feedback\n  // Returns `true` if anything changes\n  run(): boolean {\n    if (this.numInstances === 0) {\n      return false;\n    }\n\n    for (const attributeName in this.transitions) {\n      const updated = this.transitions[attributeName].update();\n      if (updated) {\n        this.needsRedraw = true;\n      }\n    }\n\n    const needsRedraw = this.needsRedraw;\n    this.needsRedraw = false;\n    return needsRedraw;\n  }\n  /* eslint-enable max-statements */\n\n  /* Private methods */\n  private _removeTransition(attributeName: string): void {\n    this.transitions[attributeName].delete();\n    delete this.transitions[attributeName];\n  }\n\n  // Check an attributes for updates\n  // Returns a transition object if a new transition is triggered.\n  private _updateAttribute(\n    attributeName: string,\n    attribute: Attribute,\n    settings: TransitionSettings\n  ): void {\n    const transition = this.transitions[attributeName];\n    // an attribute can change transition type when it updates\n    // let's remove the transition when that happens so we can create the new transition type\n    // TODO: when switching transition types, make sure to carry over the attribute's\n    // previous buffers, currentLength, startIndices, etc, to be used as the starting point\n    // for the next transition\n    let isNew = !transition || transition.type !== settings.type;\n\n    if (isNew) {\n      if (transition) {\n        this._removeTransition(attributeName);\n      }\n\n      const TransitionType = TRANSITION_TYPES[settings.type];\n      if (TransitionType) {\n        this.transitions[attributeName] = new TransitionType({\n          attribute,\n          timeline: this.timeline,\n          device: this.device\n        });\n      } else {\n        log.error(`unsupported transition type '${settings.type}'`)();\n        isNew = false;\n      }\n    }\n\n    if (isNew || attribute.needsRedraw()) {\n      this.needsRedraw = true;\n      this.transitions[attributeName].start(settings, this.numInstances);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}