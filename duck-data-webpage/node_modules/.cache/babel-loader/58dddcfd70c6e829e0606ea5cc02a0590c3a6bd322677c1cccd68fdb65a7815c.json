{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isAsyncIterable } from \"../utils/iterable-utils.js\";\nimport { COMPONENT_SYMBOL, PROP_TYPES_SYMBOL, ASYNC_ORIGINAL_SYMBOL, ASYNC_RESOLVED_SYMBOL, ASYNC_DEFAULTS_SYMBOL } from \"./constants.js\";\nconst EMPTY_PROPS = Object.freeze({});\nexport default class ComponentState {\n  constructor(component) {\n    this.component = component;\n    this.asyncProps = {}; // Prop values that the layer sees\n    this.onAsyncPropUpdated = () => {};\n    this.oldProps = null; // Last props before update\n    this.oldAsyncProps = null; // Last props before update, with async values copied.\n  }\n  finalize() {\n    for (const propName in this.asyncProps) {\n      const asyncProp = this.asyncProps[propName];\n      if (asyncProp && asyncProp.type && asyncProp.type.release) {\n        // Release any resources created by transforms\n        asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);\n      }\n    }\n    this.asyncProps = {};\n    this.component = null;\n    this.resetOldProps();\n  }\n  /* Layer-facing props API */\n  getOldProps() {\n    return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;\n  }\n  resetOldProps() {\n    this.oldAsyncProps = null;\n    this.oldProps = this.component ? this.component.props : null;\n  }\n  // Checks if a prop is overridden\n  hasAsyncProp(propName) {\n    return propName in this.asyncProps;\n  }\n  // Returns value of an overriden prop\n  getAsyncProp(propName) {\n    const asyncProp = this.asyncProps[propName];\n    return asyncProp && asyncProp.resolvedValue;\n  }\n  isAsyncPropLoading(propName) {\n    if (propName) {\n      const asyncProp = this.asyncProps[propName];\n      return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);\n    }\n    for (const key in this.asyncProps) {\n      if (this.isAsyncPropLoading(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  // Without changing the original prop value, swap out the data resolution under the hood\n  reloadAsyncProp(propName, value) {\n    this._watchPromise(propName, Promise.resolve(value));\n  }\n  // Updates all async/overridden props (when new props come in)\n  // Checks if urls have changed, starts loading, or removes override\n  setAsyncProps(props) {\n    this.component = props[COMPONENT_SYMBOL] || this.component;\n    // NOTE: prop param and default values are only support for testing\n    const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};\n    const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;\n    const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};\n    // TODO - use async props from the layer's prop types\n    for (const propName in resolvedValues) {\n      const value = resolvedValues[propName];\n      this._createAsyncPropData(propName, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n      // Use transformed value\n      resolvedValues[propName] = this.getAsyncProp(propName);\n    }\n    for (const propName in originalValues) {\n      const value = originalValues[propName];\n      // Makes sure a record exists for this prop\n      this._createAsyncPropData(propName, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n    }\n  }\n  /* Placeholder methods for subclassing */\n  _fetch(propName, url) {\n    return null;\n  }\n  _onResolve(propName, value) {} // eslint-disable-line @typescript-eslint/no-empty-function\n  _onError(propName, error) {} // eslint-disable-line @typescript-eslint/no-empty-function\n  // Intercept strings (URLs) and Promises and activates loading and prop rewriting\n  _updateAsyncProp(propName, value) {\n    if (!this._didAsyncInputValueChange(propName, value)) {\n      return;\n    }\n    // interpret value string as url and start a new load tracked by a promise\n    if (typeof value === 'string') {\n      value = this._fetch(propName, value);\n    }\n    // interprets promise and track the \"loading\"\n    if (value instanceof Promise) {\n      this._watchPromise(propName, value);\n      return;\n    }\n    if (isAsyncIterable(value)) {\n      this._resolveAsyncIterable(propName, value); // eslint-disable-line @typescript-eslint/no-floating-promises\n      return;\n    }\n    // else, normal, non-async value. Just store value for now\n    this._setPropValue(propName, value);\n  }\n  // Whenever async props are changing, we need to make a copy of oldProps\n  // otherwise the prop rewriting will affect the value both in props and oldProps.\n  // While the copy is relatively expensive, this only happens on load completion.\n  _freezeAsyncOldProps() {\n    if (!this.oldAsyncProps && this.oldProps) {\n      // 1. inherit all synchronous props from oldProps\n      // 2. reconfigure the async prop descriptors to fixed values\n      this.oldAsyncProps = Object.create(this.oldProps);\n      for (const propName in this.asyncProps) {\n        Object.defineProperty(this.oldAsyncProps, propName, {\n          enumerable: true,\n          value: this.oldProps[propName]\n        });\n      }\n    }\n  }\n  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)\n  _didAsyncInputValueChange(propName, value) {\n    // @ts-ignore\n    const asyncProp = this.asyncProps[propName];\n    if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {\n      return false;\n    }\n    asyncProp.lastValue = value;\n    return true;\n  }\n  // Set normal, non-async value\n  _setPropValue(propName, value) {\n    // Save the current value before overwriting so that diffProps can access both\n    this._freezeAsyncOldProps();\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp) {\n      value = this._postProcessValue(asyncProp, value);\n      asyncProp.resolvedValue = value;\n      asyncProp.pendingLoadCount++;\n      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;\n    }\n  }\n  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously\n  _setAsyncPropValue(propName, value, loadCount) {\n    // Only update if loadCount is larger or equal to resolvedLoadCount\n    // otherwise a more recent load has already completed\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== undefined) {\n      // Save the current value before overwriting so that diffProps can access both\n      this._freezeAsyncOldProps();\n      asyncProp.resolvedValue = value;\n      asyncProp.resolvedLoadCount = loadCount;\n      // Call callback to inform listener\n      this.onAsyncPropUpdated(propName, value);\n    }\n  }\n  // Tracks a promise, sets the prop when loaded, handles load count\n  _watchPromise(propName, promise) {\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp) {\n      asyncProp.pendingLoadCount++;\n      const loadCount = asyncProp.pendingLoadCount;\n      promise.then(data => {\n        if (!this.component) {\n          // This component state has been finalized\n          return;\n        }\n        data = this._postProcessValue(asyncProp, data);\n        this._setAsyncPropValue(propName, data, loadCount);\n        this._onResolve(propName, data);\n      }).catch(error => {\n        this._onError(propName, error);\n      });\n    }\n  }\n  async _resolveAsyncIterable(propName, iterable) {\n    if (propName !== 'data') {\n      // we only support data as async iterable\n      this._setPropValue(propName, iterable);\n      return;\n    }\n    const asyncProp = this.asyncProps[propName];\n    if (!asyncProp) {\n      return;\n    }\n    asyncProp.pendingLoadCount++;\n    const loadCount = asyncProp.pendingLoadCount;\n    let data = [];\n    let count = 0;\n    for await (const chunk of iterable) {\n      if (!this.component) {\n        // This component state has been finalized\n        return;\n      }\n      // @ts-expect-error (2339) dataTransform is not decared in base component props\n      const {\n        dataTransform\n      } = this.component.props;\n      if (dataTransform) {\n        data = dataTransform(chunk, data);\n      } else {\n        data = data.concat(chunk);\n      }\n      // Used by the default _dataDiff function\n      Object.defineProperty(data, '__diff', {\n        enumerable: false,\n        value: [{\n          startRow: count,\n          endRow: data.length\n        }]\n      });\n      count = data.length;\n      this._setAsyncPropValue(propName, data, loadCount);\n    }\n    this._onResolve(propName, data);\n  }\n  // Give the app a chance to post process the loaded data\n  _postProcessValue(asyncProp, value) {\n    const propType = asyncProp.type;\n    if (propType && this.component) {\n      if (propType.release) {\n        propType.release(asyncProp.resolvedValue, propType, this.component);\n      }\n      if (propType.transform) {\n        return propType.transform(value, propType, this.component);\n      }\n    }\n    return value;\n  }\n  // Creating an asyncProp record if needed\n  _createAsyncPropData(propName, defaultValue) {\n    const asyncProp = this.asyncProps[propName];\n    if (!asyncProp) {\n      const propTypes = this.component && this.component.props[PROP_TYPES_SYMBOL];\n      // assert(defaultValue !== undefined);\n      this.asyncProps[propName] = {\n        type: propTypes && propTypes[propName],\n        lastValue: null,\n        resolvedValue: defaultValue,\n        pendingLoadCount: 0,\n        resolvedLoadCount: 0\n      };\n    }\n  }\n}\n//# sourceMappingURL=component-state.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}