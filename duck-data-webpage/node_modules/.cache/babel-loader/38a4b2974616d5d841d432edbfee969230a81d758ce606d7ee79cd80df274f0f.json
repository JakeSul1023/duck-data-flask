{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Geometry } from '@luma.gl/engine';\nimport { CompositeLayer, COORDINATE_SYSTEM, log } from '@deck.gl/core';\nimport { PointCloudLayer } from '@deck.gl/layers';\nimport { ScenegraphLayer } from '@deck.gl/mesh-layers';\nimport { default as MeshLayer } from \"../mesh-layer/mesh-layer.js\";\nimport { load } from '@loaders.gl/core';\nimport { Tileset3D, TILE_TYPE } from '@loaders.gl/tiles';\nimport { Tiles3DLoader } from '@loaders.gl/3d-tiles';\nconst SINGLE_DATA = [0];\nconst defaultProps = {\n  getPointColor: {\n    type: 'accessor',\n    value: [0, 0, 0, 255]\n  },\n  pointSize: 1.0,\n  // Disable async data loading (handling it in _loadTileSet)\n  data: '',\n  loader: Tiles3DLoader,\n  onTilesetLoad: {\n    type: 'function',\n    value: tileset3d => {}\n  },\n  onTileLoad: {\n    type: 'function',\n    value: tileHeader => {}\n  },\n  onTileUnload: {\n    type: 'function',\n    value: tileHeader => {}\n  },\n  onTileError: {\n    type: 'function',\n    value: (tile, message, url) => {}\n  },\n  _getMeshColor: {\n    type: 'function',\n    value: tileHeader => [255, 255, 255]\n  }\n};\n/** Render 3d tiles data formatted according to the [3D Tiles Specification](https://www.opengeospatial.org/standards/3DTiles) and [`ESRI I3S`](https://github.com/Esri/i3s-spec) */\nclass Tile3DLayer extends CompositeLayer {\n  initializeState() {\n    if ('onTileLoadFail' in this.props) {\n      log.removed('onTileLoadFail', 'onTileError')();\n    }\n    // prop verification\n    this.state = {\n      layerMap: {},\n      tileset3d: null,\n      activeViewports: {},\n      lastUpdatedViewports: null\n    };\n  }\n  get isLoaded() {\n    return Boolean(this.state?.tileset3d?.isLoaded() && super.isLoaded);\n  }\n  shouldUpdateState({\n    changeFlags\n  }) {\n    return changeFlags.somethingChanged;\n  }\n  updateState({\n    props,\n    oldProps,\n    changeFlags\n  }) {\n    if (props.data && props.data !== oldProps.data) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._loadTileset(props.data);\n    }\n    if (changeFlags.viewportChanged) {\n      const {\n        activeViewports\n      } = this.state;\n      const viewportsNumber = Object.keys(activeViewports).length;\n      if (viewportsNumber) {\n        this._updateTileset(activeViewports);\n        this.state.lastUpdatedViewports = activeViewports;\n        this.state.activeViewports = {};\n      }\n    }\n    if (changeFlags.propsChanged) {\n      const {\n        layerMap\n      } = this.state;\n      for (const key in layerMap) {\n        layerMap[key].needsUpdate = true;\n      }\n    }\n  }\n  activateViewport(viewport) {\n    const {\n      activeViewports,\n      lastUpdatedViewports\n    } = this.state;\n    this.internalState.viewport = viewport;\n    activeViewports[viewport.id] = viewport;\n    const lastViewport = lastUpdatedViewports?.[viewport.id];\n    if (!lastViewport || !viewport.equals(lastViewport)) {\n      this.setChangeFlags({\n        viewportChanged: true\n      });\n      this.setNeedsUpdate();\n    }\n  }\n  getPickingInfo({\n    info,\n    sourceLayer\n  }) {\n    const sourceTile = sourceLayer && sourceLayer.props.tile;\n    if (info.picked) {\n      info.object = sourceTile;\n    }\n    info.sourceTile = sourceTile;\n    return info;\n  }\n  filterSubLayer({\n    layer,\n    viewport\n  }) {\n    // All sublayers will have a tile prop\n    const {\n      tile\n    } = layer.props;\n    const {\n      id: viewportId\n    } = viewport;\n    return tile.selected && tile.viewportIds.includes(viewportId);\n  }\n  _updateAutoHighlight(info) {\n    const sourceTile = info.sourceTile;\n    const layerCache = this.state.layerMap[sourceTile?.id];\n    if (layerCache && layerCache.layer) {\n      layerCache.layer.updateAutoHighlight(info);\n    }\n  }\n  async _loadTileset(tilesetUrl) {\n    const {\n      loadOptions = {}\n    } = this.props;\n    // TODO: deprecate `loader` in v9.0\n    // @ts-ignore\n    const loaders = this.props.loader || this.props.loaders;\n    const loader = Array.isArray(loaders) ? loaders[0] : loaders;\n    const options = {\n      loadOptions: {\n        ...loadOptions\n      }\n    };\n    let actualTilesetUrl = tilesetUrl;\n    if (loader.preload) {\n      const preloadOptions = await loader.preload(tilesetUrl, loadOptions);\n      if (preloadOptions.url) {\n        actualTilesetUrl = preloadOptions.url;\n      }\n      if (preloadOptions.headers) {\n        options.loadOptions.fetch = {\n          ...options.loadOptions.fetch,\n          headers: preloadOptions.headers\n        };\n      }\n      Object.assign(options, preloadOptions);\n    }\n    const tilesetJson = await load(actualTilesetUrl, loader, options.loadOptions);\n    const tileset3d = new Tileset3D(tilesetJson, {\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileUnload: this._onTileUnload.bind(this),\n      onTileError: this.props.onTileError,\n      ...options\n    });\n    this.setState({\n      tileset3d,\n      layerMap: {}\n    });\n    this._updateTileset(this.state.activeViewports);\n    this.props.onTilesetLoad(tileset3d);\n  }\n  _onTileLoad(tileHeader) {\n    const {\n      lastUpdatedViewports\n    } = this.state;\n    this.props.onTileLoad(tileHeader);\n    this._updateTileset(lastUpdatedViewports);\n    this.setNeedsUpdate();\n  }\n  _onTileUnload(tileHeader) {\n    // Was cleaned up from tileset cache. We no longer need to track it.\n    delete this.state.layerMap[tileHeader.id];\n    this.props.onTileUnload(tileHeader);\n  }\n  _updateTileset(viewports) {\n    if (!viewports) {\n      return;\n    }\n    const {\n      tileset3d\n    } = this.state;\n    const {\n      timeline\n    } = this.context;\n    const viewportsNumber = Object.keys(viewports).length;\n    if (!timeline || !viewportsNumber || !tileset3d) {\n      return;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    tileset3d.selectTiles(Object.values(viewports)).then(frameNumber => {\n      const tilesetChanged = this.state.frameNumber !== frameNumber;\n      if (tilesetChanged) {\n        this.setState({\n          frameNumber\n        });\n      }\n    });\n  }\n  _getSubLayer(tileHeader, oldLayer) {\n    if (!tileHeader.content) {\n      return null;\n    }\n    switch (tileHeader.type) {\n      case TILE_TYPE.POINTCLOUD:\n        return this._makePointCloudLayer(tileHeader, oldLayer);\n      case TILE_TYPE.SCENEGRAPH:\n        return this._make3DModelLayer(tileHeader);\n      case TILE_TYPE.MESH:\n        return this._makeSimpleMeshLayer(tileHeader, oldLayer);\n      default:\n        throw new Error(`Tile3DLayer: Failed to render layer of type ${tileHeader.content.type}`);\n    }\n  }\n  _makePointCloudLayer(tileHeader, oldLayer) {\n    const {\n      attributes,\n      pointCount,\n      constantRGBA,\n      cartographicOrigin,\n      modelMatrix\n    } = tileHeader.content;\n    const {\n      positions,\n      normals,\n      colors\n    } = attributes;\n    if (!positions) {\n      return null;\n    }\n    const data = oldLayer && oldLayer.props.data || {\n      header: {\n        vertexCount: pointCount\n      },\n      attributes: {\n        POSITION: positions,\n        NORMAL: normals,\n        COLOR_0: colors\n      }\n    };\n    const {\n      pointSize,\n      getPointColor\n    } = this.props;\n    const SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n    return new SubLayerClass({\n      pointSize\n    }, this.getSubLayerProps({\n      id: 'pointcloud'\n    }), {\n      id: `${this.id}-pointcloud-${tileHeader.id}`,\n      tile: tileHeader,\n      data,\n      coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n      coordinateOrigin: cartographicOrigin,\n      modelMatrix,\n      getColor: constantRGBA || getPointColor,\n      _offset: 0\n    });\n  }\n  _make3DModelLayer(tileHeader) {\n    const {\n      gltf,\n      instances,\n      cartographicOrigin,\n      modelMatrix\n    } = tileHeader.content;\n    const SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n    return new SubLayerClass({\n      _lighting: 'pbr'\n    }, this.getSubLayerProps({\n      id: 'scenegraph'\n    }), {\n      id: `${this.id}-scenegraph-${tileHeader.id}`,\n      tile: tileHeader,\n      data: instances || SINGLE_DATA,\n      scenegraph: gltf,\n      coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n      coordinateOrigin: cartographicOrigin,\n      modelMatrix,\n      getTransformMatrix: instance => instance.modelMatrix,\n      getPosition: [0, 0, 0],\n      _offset: 0\n    });\n  }\n  _makeSimpleMeshLayer(tileHeader, oldLayer) {\n    const content = tileHeader.content;\n    const {\n      attributes,\n      indices,\n      modelMatrix,\n      cartographicOrigin,\n      coordinateSystem = COORDINATE_SYSTEM.METER_OFFSETS,\n      material,\n      featureIds\n    } = content;\n    const {\n      _getMeshColor\n    } = this.props;\n    const geometry = oldLayer && oldLayer.props.mesh || new Geometry({\n      topology: 'triangle-list',\n      attributes: getMeshGeometry(attributes),\n      indices\n    });\n    const SubLayerClass = this.getSubLayerClass('mesh', MeshLayer);\n    return new SubLayerClass(this.getSubLayerProps({\n      id: 'mesh'\n    }), {\n      id: `${this.id}-mesh-${tileHeader.id}`,\n      tile: tileHeader,\n      mesh: geometry,\n      data: SINGLE_DATA,\n      getColor: _getMeshColor(tileHeader),\n      pbrMaterial: material,\n      modelMatrix,\n      coordinateOrigin: cartographicOrigin,\n      coordinateSystem,\n      featureIds,\n      _offset: 0\n    });\n  }\n  renderLayers() {\n    const {\n      tileset3d,\n      layerMap\n    } = this.state;\n    if (!tileset3d) {\n      return null;\n    }\n    // loaders.gl doesn't provide a type for tileset3d.tiles\n    return tileset3d.tiles.map(tile => {\n      const layerCache = layerMap[tile.id] = layerMap[tile.id] || {\n        tile\n      };\n      let {\n        layer\n      } = layerCache;\n      if (tile.selected) {\n        // render selected tiles\n        if (!layer) {\n          // create layer\n          layer = this._getSubLayer(tile);\n        } else if (layerCache.needsUpdate) {\n          // props have changed, rerender layer\n          layer = this._getSubLayer(tile, layer);\n          layerCache.needsUpdate = false;\n        }\n      }\n      layerCache.layer = layer;\n      return layer;\n    }).filter(Boolean);\n  }\n}\nTile3DLayer.defaultProps = defaultProps;\nTile3DLayer.layerName = 'Tile3DLayer';\nexport default Tile3DLayer;\nfunction getMeshGeometry(contentAttributes) {\n  const attributes = {};\n  attributes.positions = {\n    ...contentAttributes.positions,\n    value: new Float32Array(contentAttributes.positions.value)\n  };\n  if (contentAttributes.normals) {\n    attributes.normals = contentAttributes.normals;\n  }\n  if (contentAttributes.texCoords) {\n    attributes.texCoords = contentAttributes.texCoords;\n  }\n  if (contentAttributes.colors) {\n    attributes.colors = contentAttributes.colors;\n  }\n  if (contentAttributes.uvRegions) {\n    attributes.uvRegions = contentAttributes.uvRegions;\n  }\n  return attributes;\n}","map":{"version":3,"names":["Geometry","CompositeLayer","COORDINATE_SYSTEM","log","PointCloudLayer","ScenegraphLayer","default","MeshLayer","load","Tileset3D","TILE_TYPE","Tiles3DLoader","SINGLE_DATA","defaultProps","getPointColor","type","value","pointSize","data","loader","onTilesetLoad","tileset3d","onTileLoad","tileHeader","onTileUnload","onTileError","tile","message","url","_getMeshColor","Tile3DLayer","initializeState","props","removed","state","layerMap","activeViewports","lastUpdatedViewports","isLoaded","Boolean","shouldUpdateState","changeFlags","somethingChanged","updateState","oldProps","_loadTileset","viewportChanged","viewportsNumber","Object","keys","length","_updateTileset","propsChanged","key","needsUpdate","activateViewport","viewport","internalState","id","lastViewport","equals","setChangeFlags","setNeedsUpdate","getPickingInfo","info","sourceLayer","sourceTile","picked","object","filterSubLayer","layer","viewportId","selected","viewportIds","includes","_updateAutoHighlight","layerCache","updateAutoHighlight","tilesetUrl","loadOptions","loaders","Array","isArray","options","actualTilesetUrl","preload","preloadOptions","headers","fetch","assign","tilesetJson","_onTileLoad","bind","_onTileUnload","setState","viewports","timeline","context","selectTiles","values","then","frameNumber","tilesetChanged","_getSubLayer","oldLayer","content","POINTCLOUD","_makePointCloudLayer","SCENEGRAPH","_make3DModelLayer","MESH","_makeSimpleMeshLayer","Error","attributes","pointCount","constantRGBA","cartographicOrigin","modelMatrix","positions","normals","colors","header","vertexCount","POSITION","NORMAL","COLOR_0","SubLayerClass","getSubLayerClass","getSubLayerProps","coordinateSystem","METER_OFFSETS","coordinateOrigin","getColor","_offset","gltf","instances","_lighting","scenegraph","getTransformMatrix","instance","getPosition","indices","material","featureIds","geometry","mesh","topology","getMeshGeometry","pbrMaterial","renderLayers","tiles","map","filter","layerName","contentAttributes","Float32Array","texCoords","uvRegions"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\geo-layers\\src\\tile-3d-layer\\tile-3d-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Geometry} from '@luma.gl/engine';\n\nimport {\n  Accessor,\n  Color,\n  CompositeLayer,\n  CompositeLayerProps,\n  COORDINATE_SYSTEM,\n  FilterContext,\n  GetPickingInfoParams,\n  Layer,\n  LayersList,\n  log,\n  PickingInfo,\n  UpdateParameters,\n  Viewport,\n  DefaultProps\n} from '@deck.gl/core';\nimport {PointCloudLayer} from '@deck.gl/layers';\nimport {ScenegraphLayer} from '@deck.gl/mesh-layers';\nimport {default as MeshLayer} from '../mesh-layer/mesh-layer';\n\nimport {load} from '@loaders.gl/core';\nimport {MeshAttributes} from '@loaders.gl/schema';\nimport {Tileset3D, Tile3D, TILE_TYPE} from '@loaders.gl/tiles';\nimport {Tiles3DLoader} from '@loaders.gl/3d-tiles';\n\nconst SINGLE_DATA = [0];\n\nconst defaultProps: DefaultProps<Tile3DLayerProps> = {\n  getPointColor: {type: 'accessor', value: [0, 0, 0, 255]},\n  pointSize: 1.0,\n\n  // Disable async data loading (handling it in _loadTileSet)\n  data: '',\n  loader: Tiles3DLoader,\n\n  onTilesetLoad: {type: 'function', value: tileset3d => {}},\n  onTileLoad: {type: 'function', value: tileHeader => {}},\n  onTileUnload: {type: 'function', value: tileHeader => {}},\n  onTileError: {type: 'function', value: (tile, message, url) => {}},\n  _getMeshColor: {type: 'function', value: tileHeader => [255, 255, 255]}\n};\n\n/** All properties supported by Tile3DLayer */\nexport type Tile3DLayerProps<DataT = unknown> = _Tile3DLayerProps<DataT> & CompositeLayerProps;\n\n/** Props added by the Tile3DLayer */\ntype _Tile3DLayerProps<DataT> = {\n  data: string;\n  /** Color Accessor for point clouds. **/\n  getPointColor?: Accessor<DataT, Color>;\n\n  /** Global radius of all points in pixels. **/\n  pointSize?: number;\n\n  /** A loader which is used to decode the fetched tiles.\n   * @deprecated Use `loaders` instead\n   */\n  loader?: typeof Tiles3DLoader;\n\n  /** Called when Tileset JSON file is loaded. **/\n  onTilesetLoad?: (tile: Tileset3D) => void;\n\n  /** Called when a tile in the tileset hierarchy is loaded. **/\n  onTileLoad?: (tile: Tile3D) => void;\n\n  /** Called when a tile is unloaded. **/\n  onTileUnload?: (tile: Tile3D) => void;\n\n  /** Called when a tile fails to load. **/\n  onTileError?: (tile: Tile3D, url: string, message: string) => void;\n\n  /** (Experimental) Accessor to change color of mesh based on properties. **/\n  _getMeshColor?: (tile: Tile3D) => Color;\n};\n\n/** Render 3d tiles data formatted according to the [3D Tiles Specification](https://www.opengeospatial.org/standards/3DTiles) and [`ESRI I3S`](https://github.com/Esri/i3s-spec) */\nexport default class Tile3DLayer<DataT = any, ExtraPropsT extends {} = {}> extends CompositeLayer<\n  ExtraPropsT & Required<_Tile3DLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'Tile3DLayer';\n\n  state!: {\n    activeViewports: {};\n    frameNumber?: number;\n    lastUpdatedViewports: {[viewportId: string]: Viewport} | null;\n    layerMap: {[layerId: string]: any};\n    tileset3d: Tileset3D | null;\n  };\n\n  initializeState() {\n    if ('onTileLoadFail' in this.props) {\n      log.removed('onTileLoadFail', 'onTileError')();\n    }\n    // prop verification\n    this.state = {\n      layerMap: {},\n      tileset3d: null,\n      activeViewports: {},\n      lastUpdatedViewports: null\n    };\n  }\n\n  get isLoaded(): boolean {\n    return Boolean(this.state?.tileset3d?.isLoaded() && super.isLoaded);\n  }\n\n  shouldUpdateState({changeFlags}: UpdateParameters<this>): boolean {\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({props, oldProps, changeFlags}: UpdateParameters<this>): void {\n    if (props.data && props.data !== oldProps.data) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._loadTileset(props.data);\n    }\n\n    if (changeFlags.viewportChanged) {\n      const {activeViewports} = this.state;\n      const viewportsNumber = Object.keys(activeViewports).length;\n      if (viewportsNumber) {\n        this._updateTileset(activeViewports);\n        this.state.lastUpdatedViewports = activeViewports;\n        this.state.activeViewports = {};\n      }\n    }\n    if (changeFlags.propsChanged) {\n      const {layerMap} = this.state;\n      for (const key in layerMap) {\n        layerMap[key].needsUpdate = true;\n      }\n    }\n  }\n\n  activateViewport(viewport: Viewport): void {\n    const {activeViewports, lastUpdatedViewports} = this.state;\n    this.internalState!.viewport = viewport;\n\n    activeViewports[viewport.id] = viewport;\n    const lastViewport = lastUpdatedViewports?.[viewport.id];\n    if (!lastViewport || !viewport.equals(lastViewport)) {\n      this.setChangeFlags({viewportChanged: true});\n      this.setNeedsUpdate();\n    }\n  }\n\n  getPickingInfo({info, sourceLayer}: GetPickingInfoParams) {\n    const sourceTile = sourceLayer && (sourceLayer.props as any).tile;\n    if (info.picked) {\n      info.object = sourceTile;\n    }\n    (info as any).sourceTile = sourceTile;\n\n    return info;\n  }\n\n  filterSubLayer({layer, viewport}: FilterContext): boolean {\n    // All sublayers will have a tile prop\n    const {tile} = layer.props as unknown as {tile: Tile3D};\n    const {id: viewportId} = viewport;\n    return tile.selected && tile.viewportIds.includes(viewportId);\n  }\n\n  protected _updateAutoHighlight(info: PickingInfo): void {\n    const sourceTile = (info as any).sourceTile;\n    const layerCache = this.state.layerMap[sourceTile?.id];\n    if (layerCache && layerCache.layer) {\n      layerCache.layer.updateAutoHighlight(info);\n    }\n  }\n\n  private async _loadTileset(tilesetUrl) {\n    const {loadOptions = {}} = this.props;\n\n    // TODO: deprecate `loader` in v9.0\n    // @ts-ignore\n    const loaders = this.props.loader || this.props.loaders;\n    const loader = Array.isArray(loaders) ? loaders[0] : loaders;\n\n    const options = {loadOptions: {...loadOptions}};\n    let actualTilesetUrl = tilesetUrl;\n    if (loader.preload) {\n      const preloadOptions = await loader.preload(tilesetUrl, loadOptions);\n      if (preloadOptions.url) {\n        actualTilesetUrl = preloadOptions.url;\n      }\n\n      if (preloadOptions.headers) {\n        options.loadOptions.fetch = {\n          ...options.loadOptions.fetch,\n          headers: preloadOptions.headers\n        };\n      }\n      Object.assign(options, preloadOptions);\n    }\n    const tilesetJson = await load(actualTilesetUrl, loader, options.loadOptions);\n\n    const tileset3d = new Tileset3D(tilesetJson, {\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileUnload: this._onTileUnload.bind(this),\n      onTileError: this.props.onTileError,\n      ...options\n    });\n\n    this.setState({\n      tileset3d,\n      layerMap: {}\n    });\n\n    this._updateTileset(this.state.activeViewports);\n    this.props.onTilesetLoad(tileset3d);\n  }\n\n  private _onTileLoad(tileHeader: Tile3D): void {\n    const {lastUpdatedViewports} = this.state;\n    this.props.onTileLoad(tileHeader);\n    this._updateTileset(lastUpdatedViewports);\n    this.setNeedsUpdate();\n  }\n\n  private _onTileUnload(tileHeader: Tile3D): void {\n    // Was cleaned up from tileset cache. We no longer need to track it.\n    delete this.state.layerMap[tileHeader.id];\n    this.props.onTileUnload(tileHeader);\n  }\n\n  private _updateTileset(viewports: {[viewportId: string]: Viewport} | null): void {\n    if (!viewports) {\n      return;\n    }\n    const {tileset3d} = this.state;\n    const {timeline} = this.context;\n    const viewportsNumber = Object.keys(viewports).length;\n    if (!timeline || !viewportsNumber || !tileset3d) {\n      return;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    tileset3d.selectTiles(Object.values(viewports)).then(frameNumber => {\n      const tilesetChanged = this.state.frameNumber !== frameNumber;\n      if (tilesetChanged) {\n        this.setState({frameNumber});\n      }\n    });\n  }\n\n  private _getSubLayer(\n    tileHeader: Tile3D,\n    oldLayer?: Layer\n  ): MeshLayer<DataT> | PointCloudLayer<DataT> | ScenegraphLayer<DataT> | null {\n    if (!tileHeader.content) {\n      return null;\n    }\n\n    switch (tileHeader.type as TILE_TYPE) {\n      case TILE_TYPE.POINTCLOUD:\n        return this._makePointCloudLayer(tileHeader, oldLayer as PointCloudLayer<DataT>);\n      case TILE_TYPE.SCENEGRAPH:\n        return this._make3DModelLayer(tileHeader);\n      case TILE_TYPE.MESH:\n        return this._makeSimpleMeshLayer(tileHeader, oldLayer as MeshLayer<DataT>);\n      default:\n        throw new Error(`Tile3DLayer: Failed to render layer of type ${tileHeader.content.type}`);\n    }\n  }\n\n  private _makePointCloudLayer(\n    tileHeader: Tile3D,\n    oldLayer?: PointCloudLayer<DataT>\n  ): PointCloudLayer<DataT> | null {\n    const {attributes, pointCount, constantRGBA, cartographicOrigin, modelMatrix} =\n      tileHeader.content;\n    const {positions, normals, colors} = attributes;\n\n    if (!positions) {\n      return null;\n    }\n    const data = (oldLayer && oldLayer.props.data) || {\n      header: {\n        vertexCount: pointCount\n      },\n      attributes: {\n        POSITION: positions,\n        NORMAL: normals,\n        COLOR_0: colors\n      }\n    };\n\n    const {pointSize, getPointColor} = this.props;\n    const SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n    return new SubLayerClass(\n      {\n        pointSize\n      },\n      this.getSubLayerProps({\n        id: 'pointcloud'\n      }),\n      {\n        id: `${this.id}-pointcloud-${tileHeader.id}`,\n        tile: tileHeader,\n        data,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix,\n        getColor: constantRGBA || getPointColor,\n        _offset: 0\n      }\n    );\n  }\n\n  private _make3DModelLayer(tileHeader: Tile3D): ScenegraphLayer<DataT> {\n    const {gltf, instances, cartographicOrigin, modelMatrix} = tileHeader.content;\n\n    const SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n\n    return new SubLayerClass(\n      {\n        _lighting: 'pbr'\n      },\n      this.getSubLayerProps({\n        id: 'scenegraph'\n      }),\n      {\n        id: `${this.id}-scenegraph-${tileHeader.id}`,\n        tile: tileHeader,\n        data: instances || SINGLE_DATA,\n        scenegraph: gltf,\n\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix,\n        getTransformMatrix: instance => instance.modelMatrix,\n        getPosition: [0, 0, 0],\n        _offset: 0\n      }\n    );\n  }\n\n  private _makeSimpleMeshLayer(tileHeader: Tile3D, oldLayer?: MeshLayer<DataT>): MeshLayer<DataT> {\n    const content = tileHeader.content;\n    const {\n      attributes,\n      indices,\n      modelMatrix,\n      cartographicOrigin,\n      coordinateSystem = COORDINATE_SYSTEM.METER_OFFSETS,\n      material,\n      featureIds\n    } = content;\n    const {_getMeshColor} = this.props;\n\n    const geometry =\n      (oldLayer && oldLayer.props.mesh) ||\n      new Geometry({\n        topology: 'triangle-list',\n        attributes: getMeshGeometry(attributes),\n        indices\n      });\n\n    const SubLayerClass = this.getSubLayerClass('mesh', MeshLayer);\n\n    return new SubLayerClass(\n      this.getSubLayerProps({\n        id: 'mesh'\n      }),\n      {\n        id: `${this.id}-mesh-${tileHeader.id}`,\n        tile: tileHeader,\n        mesh: geometry,\n        data: SINGLE_DATA,\n        getColor: _getMeshColor(tileHeader),\n        pbrMaterial: material,\n        modelMatrix,\n        coordinateOrigin: cartographicOrigin,\n        coordinateSystem,\n        featureIds,\n        _offset: 0\n      }\n    );\n  }\n\n  renderLayers(): Layer | null | LayersList {\n    const {tileset3d, layerMap} = this.state;\n    if (!tileset3d) {\n      return null;\n    }\n\n    // loaders.gl doesn't provide a type for tileset3d.tiles\n    return (tileset3d.tiles as Tile3D[])\n      .map(tile => {\n        const layerCache = (layerMap[tile.id] = layerMap[tile.id] || {tile});\n        let {layer} = layerCache;\n        if (tile.selected) {\n          // render selected tiles\n          if (!layer) {\n            // create layer\n            layer = this._getSubLayer(tile);\n          } else if (layerCache.needsUpdate) {\n            // props have changed, rerender layer\n            layer = this._getSubLayer(tile, layer);\n            layerCache.needsUpdate = false;\n          }\n        }\n        layerCache.layer = layer;\n        return layer;\n      })\n      .filter(Boolean);\n  }\n}\n\nfunction getMeshGeometry(contentAttributes: MeshAttributes): MeshAttributes {\n  const attributes: MeshAttributes = {};\n  attributes.positions = {\n    ...contentAttributes.positions,\n    value: new Float32Array(contentAttributes.positions.value)\n  };\n  if (contentAttributes.normals) {\n    attributes.normals = contentAttributes.normals;\n  }\n  if (contentAttributes.texCoords) {\n    attributes.texCoords = contentAttributes.texCoords;\n  }\n  if (contentAttributes.colors) {\n    attributes.colors = contentAttributes.colors;\n  }\n  if (contentAttributes.uvRegions) {\n    attributes.uvRegions = contentAttributes.uvRegions;\n  }\n  return attributes;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}