{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { DracoLoader } from '@loaders.gl/draco';\nimport { parseFromContext } from '@loaders.gl/loader-utils';\nimport { GL } from '@loaders.gl/math';\nimport { Vector3 } from '@math.gl/core';\nimport Tile3DFeatureTable from \"../classes/tile-3d-feature-table.js\";\nimport Tile3DBatchTable from \"../classes/tile-3d-batch-table.js\";\nimport { parse3DTileHeaderSync } from \"./helpers/parse-3d-tile-header.js\";\nimport { parse3DTileTablesHeaderSync, parse3DTileTablesSync } from \"./helpers/parse-3d-tile-tables.js\";\nimport { normalize3DTileColorAttribute } from \"./helpers/normalize-3d-tile-colors.js\";\nimport { normalize3DTileNormalAttribute } from \"./helpers/normalize-3d-tile-normals.js\";\nimport { normalize3DTilePositionAttribute } from \"./helpers/normalize-3d-tile-positions.js\";\nexport async function parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n  initializeTile(tile);\n  const {\n    featureTable,\n    batchTable\n  } = parsePointCloudTables(tile);\n  await parseDraco(tile, featureTable, batchTable, options, context);\n  parsePositions(tile, featureTable, options);\n  // @ts-expect-error TODO - do we need to assert on the batch table?\n  parseColors(tile, featureTable, batchTable);\n  parseNormals(tile, featureTable);\n  return byteOffset;\n}\nfunction initializeTile(tile) {\n  // Initialize point cloud tile defaults\n  tile.attributes = {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  };\n  tile.isQuantized = false;\n  tile.isTranslucent = false;\n  tile.isRGB565 = false;\n  tile.isOctEncoded16P = false;\n}\nfunction parsePointCloudTables(tile) {\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n  const pointsLength = featureTable.getGlobalProperty('POINTS_LENGTH');\n  if (!Number.isFinite(pointsLength)) {\n    throw new Error('POINTS_LENGTH must be defined');\n  }\n  featureTable.featuresLength = pointsLength;\n  tile.featuresLength = pointsLength;\n  tile.pointsLength = pointsLength;\n  tile.pointCount = pointsLength;\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n  const batchTable = parseBatchIds(tile, featureTable);\n  return {\n    featureTable,\n    batchTable\n  };\n}\nfunction parsePositions(tile, featureTable, options) {\n  tile.attributes = tile.attributes || {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  };\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      const positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n      tile.isQuantized = true;\n      tile.quantizedRange = (1 << 16) - 1;\n      tile.quantizedVolumeScale = featureTable.getGlobalProperty('QUANTIZED_VOLUME_SCALE', GL.FLOAT, 3);\n      if (!tile.quantizedVolumeScale) {\n        throw new Error('QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n      }\n      tile.quantizedVolumeOffset = featureTable.getGlobalProperty('QUANTIZED_VOLUME_OFFSET', GL.FLOAT, 3);\n      if (!tile.quantizedVolumeOffset) {\n        throw new Error('QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n      }\n      tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);\n    }\n  }\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\nfunction parseColors(tile, featureTable, batchTable) {\n  tile.attributes = tile.attributes || {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  };\n  if (!tile.attributes.colors) {\n    let colors = null;\n    if (featureTable.hasProperty('RGBA')) {\n      colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasProperty('RGB565')) {\n      colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n    tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);\n  }\n  if (featureTable.hasProperty('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n}\nfunction parseNormals(tile, featureTable) {\n  tile.attributes = tile.attributes || {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  };\n  if (!tile.attributes.normals) {\n    let normals = null;\n    if (featureTable.hasProperty('NORMAL')) {\n      normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('NORMAL_OCT16P')) {\n      normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n    tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);\n  }\n}\nfunction parseBatchIds(tile, featureTable) {\n  let batchTable = null;\n  if (!tile.batchIds && featureTable.hasProperty('BATCH_ID')) {\n    tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n    if (tile.batchIds) {\n      const batchFeatureLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n      if (!batchFeatureLength) {\n        throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n      }\n      const {\n        batchTableJson,\n        batchTableBinary\n      } = tile;\n      batchTable = new Tile3DBatchTable(batchTableJson, batchTableBinary, batchFeatureLength);\n    }\n  }\n  return batchTable;\n}\n// eslint-disable-next-line complexity\nasync function parseDraco(tile, featureTable, batchTable, options, context) {\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n  const batchTableDraco = tile.batchTableJson && tile.batchTableJson.extensions && tile.batchTableJson.extensions['3DTILES_draco_point_compression'];\n  if (batchTableDraco) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n  if (featureTableDraco) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {\n      throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n    }\n    dracoBuffer = (tile.featureTableBinary || []).slice(dracoByteOffset, dracoByteOffset + dracoByteLength);\n    tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);\n    tile.hasColors = Number.isFinite(dracoFeatureTableProperties.RGB) || Number.isFinite(dracoFeatureTableProperties.RGBA);\n    tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);\n    tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);\n    tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);\n  }\n  if (!dracoBuffer) {\n    return true;\n  }\n  const dracoData = {\n    buffer: dracoBuffer,\n    properties: {\n      ...dracoFeatureTableProperties,\n      ...dracoBatchTableProperties\n    },\n    featureTableProperties: dracoFeatureTableProperties,\n    batchTableProperties: dracoBatchTableProperties,\n    dequantizeInShader: false\n  };\n  return await loadDraco(tile, dracoData, options, context);\n}\n// eslint-disable-next-line complexity, max-statements\nexport async function loadDraco(tile, dracoData, options, context) {\n  if (!context) {\n    return;\n  }\n  const dracoOptions = {\n    ...options,\n    draco: {\n      ...options?.draco,\n      extraAttributes: dracoData.batchTableProperties || {}\n    }\n  };\n  // The entire tileset might be included, too expensive to serialize\n  delete dracoOptions['3d-tiles'];\n  const data = await parseFromContext(dracoData.buffer, DracoLoader, dracoOptions, context);\n  const decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;\n  const decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;\n  const decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;\n  const decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;\n  // @ts-expect-error\n  const isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;\n  // @ts-expect-error\n  const isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;\n  if (isQuantizedDraco) {\n    // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n    // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n    // @ts-expect-error This doesn't look right\n    const quantization = data.POSITION.data.quantization;\n    const range = quantization.range;\n    tile.quantizedVolumeScale = new Vector3(range, range, range);\n    tile.quantizedVolumeOffset = new Vector3(quantization.minValues);\n    tile.quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n    tile.isQuantizedDraco = true;\n  }\n  if (isOctEncodedDraco) {\n    // @ts-expect-error This doesn't look right\n    tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1.0;\n    tile.isOctEncodedDraco = true;\n  }\n  // Extra batch table attributes\n  const batchTableAttributes = {};\n  if (dracoData.batchTableProperties) {\n    for (const attributeName of Object.keys(dracoData.batchTableProperties)) {\n      if (data.attributes[attributeName] && data.attributes[attributeName].value) {\n        batchTableAttributes[attributeName.toLowerCase()] = data.attributes[attributeName].value;\n      }\n    }\n  }\n  tile.attributes = {\n    // @ts-expect-error\n    positions: decodedPositions,\n    // @ts-expect-error\n    colors: normalize3DTileColorAttribute(tile, decodedColors, undefined),\n    // @ts-expect-error\n    normals: decodedNormals,\n    // @ts-expect-error\n    batchIds: decodedBatchIds,\n    ...batchTableAttributes\n  };\n}\n// TODO - this is the remaining code from Cesium's parser\n/*\n  const batchTable = new Tile3DBatchTable(tile);\n\n  // parseDracoBuffer(tile, featureTable, batchTable);\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\n/*\n\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n\n\n  if (!tile.colors) {\n    if (featureTable.hasProperty('RGBA')) {\n      tile.colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      tile.colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasPropertry('RGB565')) {\n      tile.colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n  }\n\n  if (!tile.attributes.normals) {\n    if (featureTable.getPropertry('NORMAL')) {\n      tile.attributes.normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.getProperty('NORMAL_OCT16P')) {\n      tile.attributes.normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n  }\n\n  if (!tile.batchIds) {\n    if (featureTable.hasProperty('BATCH_ID')) {\n      tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n    }\n  }\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n\n  if (featureTable.getPropertry('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n\n  if (tile.batchIds) {\n    const batchLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n    if (!defined(batchLength)) {\n      throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n    }\n\n    if (defined(batchTableBinary)) {\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n    }\n\n    if (defined(pointCloud._batchTableLoaded)) {\n      pointCloud._batchTableLoaded(batchLength, batchTableJson, batchTableBinary);\n    }\n  }\n\n  // If points are not batched and there are per-point properties, use these properties for styling purposes\n  var styleableProperties;\n  if (!hasBatchIds && defined(batchTableBinary)) {\n    tile.styleableProperties = Cesium3DTileBatchTable.getBinaryProperties(\n      pointsLength,\n      batchTableJson,\n      batchTableBinary\n    );\n  }\n\n  tile.draco = draco;\n}\n\n// Separate parsing and decoding of Draco\nexport function parseDracoBuffer(tile, featureTable, batchTable) {\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n\n  const batchTableDraco = batchTable.getExtension('3DTILES_draco_point_compression');\n  if (batchTableDraco) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n  if (featureTableDraco) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!dracoFeatureTableProperties || !dracoByteOffset || !dracoByteLength) {\n      throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n    }\n\n    dracoBuffer = arraySlice(\n      featureTableBinary,\n      dracoByteOffset,\n      dracoByteOffset + dracoByteLength\n    );\n    tile.hasPositions = dracoFeatureTableProperties.POSITION;\n    tile.hasColors = dracoFeatureTableProperties.RGB || dracoFeatureTableProperties.RGBA;\n    tile.hasNormals = dracoFeatureTableProperties.NORMAL;\n    tile.hasBatchIds = dracoFeatureTableProperties.BATCH_ID;\n    tile.isTranslucent = dracoFeatureTableProperties.RGBA;\n  }\n\n  if (dracoBuffer) {\n    tile.draco = {\n      buffer: dracoBuffer,\n      properties: {...dracoFeatureTableProperties, ...dracoBatchTableProperties},\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      dequantizeInShader: false\n    };\n\n    tile.decodingState = DECODING_STATE.NEEDS_DECODE;\n  }\n}\n\n/*\nfunction decodeDraco(tile, context) {\n  if (tile.decodingState === DECODING_STATE.READY) {\n    return false;\n  }\n  if (tile.decodingState === DECODING_STATE.NEEDS_DECODE) {\n    var parsedContent = tile._parsedContent;\n    var draco = parsedContent.draco;\n    var decodePromise = DracoLoader.decodePointCloud(draco, context);\n    if (defined(decodePromise)) {\n      tile.decodingState = DECODING_STATE.DECODING;\n      decodePromise.then(function(result) {\n        tile.decodingState = DECODING_STATE.READY;\n        var decodedPositions = defined(result.POSITION) ? result.POSITION.array : undefined;\n        var decodedRgb = defined(result.RGB) ? result.RGB.array : undefined;\n        var decodedRgba = defined(result.RGBA) ? result.RGBA.array : undefined;\n        var decodedNormals = defined(result.NORMAL) ? result.NORMAL.array : undefined;\n        var decodedBatchIds = defined(result.BATCH_ID) ? result.BATCH_ID.array : undefined;\n        var isQuantizedDraco = defined(decodedPositions) && defined(result.POSITION.data.quantization);\n        var isOctEncodedDraco = defined(decodedNormals) && defined(result.NORMAL.data.quantization);\n        if (isQuantizedDraco) {\n          // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n          // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n          var quantization = result.POSITION.data.quantization;\n          var range = quantization.range;\n          tile._quantizedVolumeScale = Cartesian3.fromElements(range, range, range);\n          tile._quantizedVolumeOffset = Cartesian3.unpack(quantization.minValues);\n          tile._quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n          tile._isQuantizedDraco = true;\n        }\n        if (isOctEncodedDraco) {\n          tile._octEncodedRange = (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n          tile._isOctEncodedDraco = true;\n        }\n        var styleableProperties = parsedContent.styleableProperties;\n        var batchTableProperties = draco.batchTableProperties;\n        for (var name in batchTableProperties) {\n          if (batchTableProperties.hasOwnProperty(name)) {\n            var property = result[name];\n            if (!defined(styleableProperties)) {\n              styleableProperties = {};\n            }\n            styleableProperties[name] = {\n              typedArray : property.array,\n              componentCount : property.data.componentsPerAttribute\n            };\n          }\n        }\n        parsedContent.positions = defaultValue(decodedPositions, parsedContent.positions);\n        parsedContent.colors = defaultValue(defaultValue(decodedRgba, decodedRgb), parsedContent.colors);\n        parsedContent.normals = defaultValue(decodedNormals, parsedContent.normals);\n        parsedContent.batchIds = defaultValue(decodedBatchIds, parsedContent.batchIds);\n        parsedContent.styleableProperties = styleableProperties;\n      }).otherwise(function(error) {\n        tile.decodingState = DECODING_STATE.FAILED;\n        tile._readyPromise.reject(error);\n      });\n    }\n  }\n  return true;\n}\n*/","map":{"version":3,"names":["DracoLoader","parseFromContext","GL","Vector3","Tile3DFeatureTable","Tile3DBatchTable","parse3DTileHeaderSync","parse3DTileTablesHeaderSync","parse3DTileTablesSync","normalize3DTileColorAttribute","normalize3DTileNormalAttribute","normalize3DTilePositionAttribute","parsePointCloud3DTile","tile","arrayBuffer","byteOffset","options","context","initializeTile","featureTable","batchTable","parsePointCloudTables","parseDraco","parsePositions","parseColors","parseNormals","attributes","positions","colors","normals","batchIds","isQuantized","isTranslucent","isRGB565","isOctEncoded16P","featureTableJson","featureTableBinary","pointsLength","getGlobalProperty","Number","isFinite","Error","featuresLength","pointCount","rtcCenter","FLOAT","parseBatchIds","hasProperty","getPropertyArray","UNSIGNED_SHORT","quantizedRange","quantizedVolumeScale","quantizedVolumeOffset","UNSIGNED_BYTE","constantRGBA","batchFeatureLength","batchTableJson","batchTableBinary","dracoBuffer","dracoFeatureTableProperties","dracoBatchTableProperties","batchTableDraco","extensions","properties","featureTableDraco","getExtension","dracoByteOffset","dracoByteLength","byteLength","slice","hasPositions","POSITION","hasColors","RGB","RGBA","hasNormals","NORMAL","hasBatchIds","BATCH_ID","dracoData","buffer","featureTableProperties","batchTableProperties","dequantizeInShader","loadDraco","dracoOptions","draco","extraAttributes","data","decodedPositions","value","decodedColors","COLOR_0","decodedNormals","decodedBatchIds","isQuantizedDraco","quantization","isOctEncodedDraco","range","minValues","quantizationBits","octEncodedRange","batchTableAttributes","attributeName","Object","keys","toLowerCase","undefined"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-point-cloud.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { DracoLoader } from '@loaders.gl/draco';\nimport { parseFromContext } from '@loaders.gl/loader-utils';\nimport { GL } from '@loaders.gl/math';\nimport { Vector3 } from '@math.gl/core';\nimport Tile3DFeatureTable from \"../classes/tile-3d-feature-table.js\";\nimport Tile3DBatchTable from \"../classes/tile-3d-batch-table.js\";\nimport { parse3DTileHeaderSync } from \"./helpers/parse-3d-tile-header.js\";\nimport { parse3DTileTablesHeaderSync, parse3DTileTablesSync } from \"./helpers/parse-3d-tile-tables.js\";\nimport { normalize3DTileColorAttribute } from \"./helpers/normalize-3d-tile-colors.js\";\nimport { normalize3DTileNormalAttribute } from \"./helpers/normalize-3d-tile-normals.js\";\nimport { normalize3DTilePositionAttribute } from \"./helpers/normalize-3d-tile-positions.js\";\nexport async function parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context) {\n    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n    byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n    byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n    initializeTile(tile);\n    const { featureTable, batchTable } = parsePointCloudTables(tile);\n    await parseDraco(tile, featureTable, batchTable, options, context);\n    parsePositions(tile, featureTable, options);\n    // @ts-expect-error TODO - do we need to assert on the batch table?\n    parseColors(tile, featureTable, batchTable);\n    parseNormals(tile, featureTable);\n    return byteOffset;\n}\nfunction initializeTile(tile) {\n    // Initialize point cloud tile defaults\n    tile.attributes = {\n        positions: null,\n        colors: null,\n        normals: null,\n        batchIds: null\n    };\n    tile.isQuantized = false;\n    tile.isTranslucent = false;\n    tile.isRGB565 = false;\n    tile.isOctEncoded16P = false;\n}\nfunction parsePointCloudTables(tile) {\n    const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n    const pointsLength = featureTable.getGlobalProperty('POINTS_LENGTH');\n    if (!Number.isFinite(pointsLength)) {\n        throw new Error('POINTS_LENGTH must be defined');\n    }\n    featureTable.featuresLength = pointsLength;\n    tile.featuresLength = pointsLength;\n    tile.pointsLength = pointsLength;\n    tile.pointCount = pointsLength;\n    tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n    const batchTable = parseBatchIds(tile, featureTable);\n    return { featureTable, batchTable };\n}\nfunction parsePositions(tile, featureTable, options) {\n    tile.attributes = tile.attributes || {\n        positions: null,\n        colors: null,\n        normals: null,\n        batchIds: null\n    };\n    if (!tile.attributes.positions) {\n        if (featureTable.hasProperty('POSITION')) {\n            tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n        }\n        else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n            const positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n            tile.isQuantized = true;\n            tile.quantizedRange = (1 << 16) - 1;\n            tile.quantizedVolumeScale = featureTable.getGlobalProperty('QUANTIZED_VOLUME_SCALE', GL.FLOAT, 3);\n            if (!tile.quantizedVolumeScale) {\n                throw new Error('QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n            }\n            tile.quantizedVolumeOffset = featureTable.getGlobalProperty('QUANTIZED_VOLUME_OFFSET', GL.FLOAT, 3);\n            if (!tile.quantizedVolumeOffset) {\n                throw new Error('QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n            }\n            tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);\n        }\n    }\n    if (!tile.attributes.positions) {\n        throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n    }\n}\nfunction parseColors(tile, featureTable, batchTable) {\n    tile.attributes = tile.attributes || {\n        positions: null,\n        colors: null,\n        normals: null,\n        batchIds: null\n    };\n    if (!tile.attributes.colors) {\n        let colors = null;\n        if (featureTable.hasProperty('RGBA')) {\n            colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n            tile.isTranslucent = true;\n        }\n        else if (featureTable.hasProperty('RGB')) {\n            colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n        }\n        else if (featureTable.hasProperty('RGB565')) {\n            colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n            tile.isRGB565 = true;\n        }\n        tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);\n    }\n    if (featureTable.hasProperty('CONSTANT_RGBA')) {\n        tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n    }\n}\nfunction parseNormals(tile, featureTable) {\n    tile.attributes = tile.attributes || {\n        positions: null,\n        colors: null,\n        normals: null,\n        batchIds: null\n    };\n    if (!tile.attributes.normals) {\n        let normals = null;\n        if (featureTable.hasProperty('NORMAL')) {\n            normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n        }\n        else if (featureTable.hasProperty('NORMAL_OCT16P')) {\n            normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n            tile.isOctEncoded16P = true;\n        }\n        tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);\n    }\n}\nfunction parseBatchIds(tile, featureTable) {\n    let batchTable = null;\n    if (!tile.batchIds && featureTable.hasProperty('BATCH_ID')) {\n        tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n        if (tile.batchIds) {\n            const batchFeatureLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n            if (!batchFeatureLength) {\n                throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n            }\n            const { batchTableJson, batchTableBinary } = tile;\n            batchTable = new Tile3DBatchTable(batchTableJson, batchTableBinary, batchFeatureLength);\n        }\n    }\n    return batchTable;\n}\n// eslint-disable-next-line complexity\nasync function parseDraco(tile, featureTable, batchTable, options, context) {\n    let dracoBuffer;\n    let dracoFeatureTableProperties;\n    let dracoBatchTableProperties;\n    const batchTableDraco = tile.batchTableJson &&\n        tile.batchTableJson.extensions &&\n        tile.batchTableJson.extensions['3DTILES_draco_point_compression'];\n    if (batchTableDraco) {\n        dracoBatchTableProperties = batchTableDraco.properties;\n    }\n    const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n    if (featureTableDraco) {\n        dracoFeatureTableProperties = featureTableDraco.properties;\n        const dracoByteOffset = featureTableDraco.byteOffset;\n        const dracoByteLength = featureTableDraco.byteLength;\n        if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {\n            throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n        }\n        dracoBuffer = (tile.featureTableBinary || []).slice(dracoByteOffset, dracoByteOffset + dracoByteLength);\n        tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);\n        tile.hasColors =\n            Number.isFinite(dracoFeatureTableProperties.RGB) ||\n                Number.isFinite(dracoFeatureTableProperties.RGBA);\n        tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);\n        tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);\n        tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);\n    }\n    if (!dracoBuffer) {\n        return true;\n    }\n    const dracoData = {\n        buffer: dracoBuffer,\n        properties: { ...dracoFeatureTableProperties, ...dracoBatchTableProperties },\n        featureTableProperties: dracoFeatureTableProperties,\n        batchTableProperties: dracoBatchTableProperties,\n        dequantizeInShader: false\n    };\n    return await loadDraco(tile, dracoData, options, context);\n}\n// eslint-disable-next-line complexity, max-statements\nexport async function loadDraco(tile, dracoData, options, context) {\n    if (!context) {\n        return;\n    }\n    const dracoOptions = {\n        ...options,\n        draco: {\n            ...options?.draco,\n            extraAttributes: dracoData.batchTableProperties || {}\n        }\n    };\n    // The entire tileset might be included, too expensive to serialize\n    delete dracoOptions['3d-tiles'];\n    const data = await parseFromContext(dracoData.buffer, DracoLoader, dracoOptions, context);\n    const decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;\n    const decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;\n    const decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;\n    const decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;\n    // @ts-expect-error\n    const isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;\n    // @ts-expect-error\n    const isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;\n    if (isQuantizedDraco) {\n        // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n        // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n        // @ts-expect-error This doesn't look right\n        const quantization = data.POSITION.data.quantization;\n        const range = quantization.range;\n        tile.quantizedVolumeScale = new Vector3(range, range, range);\n        tile.quantizedVolumeOffset = new Vector3(quantization.minValues);\n        tile.quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n        tile.isQuantizedDraco = true;\n    }\n    if (isOctEncodedDraco) {\n        // @ts-expect-error This doesn't look right\n        tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1.0;\n        tile.isOctEncodedDraco = true;\n    }\n    // Extra batch table attributes\n    const batchTableAttributes = {};\n    if (dracoData.batchTableProperties) {\n        for (const attributeName of Object.keys(dracoData.batchTableProperties)) {\n            if (data.attributes[attributeName] && data.attributes[attributeName].value) {\n                batchTableAttributes[attributeName.toLowerCase()] = data.attributes[attributeName].value;\n            }\n        }\n    }\n    tile.attributes = {\n        // @ts-expect-error\n        positions: decodedPositions,\n        // @ts-expect-error\n        colors: normalize3DTileColorAttribute(tile, decodedColors, undefined),\n        // @ts-expect-error\n        normals: decodedNormals,\n        // @ts-expect-error\n        batchIds: decodedBatchIds,\n        ...batchTableAttributes\n    };\n}\n// TODO - this is the remaining code from Cesium's parser\n/*\n  const batchTable = new Tile3DBatchTable(tile);\n\n  // parseDracoBuffer(tile, featureTable, batchTable);\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\n/*\n\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n\n\n  if (!tile.colors) {\n    if (featureTable.hasProperty('RGBA')) {\n      tile.colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      tile.colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasPropertry('RGB565')) {\n      tile.colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n  }\n\n  if (!tile.attributes.normals) {\n    if (featureTable.getPropertry('NORMAL')) {\n      tile.attributes.normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.getProperty('NORMAL_OCT16P')) {\n      tile.attributes.normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n  }\n\n  if (!tile.batchIds) {\n    if (featureTable.hasProperty('BATCH_ID')) {\n      tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n    }\n  }\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n\n  if (featureTable.getPropertry('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n\n  if (tile.batchIds) {\n    const batchLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n    if (!defined(batchLength)) {\n      throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n    }\n\n    if (defined(batchTableBinary)) {\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n    }\n\n    if (defined(pointCloud._batchTableLoaded)) {\n      pointCloud._batchTableLoaded(batchLength, batchTableJson, batchTableBinary);\n    }\n  }\n\n  // If points are not batched and there are per-point properties, use these properties for styling purposes\n  var styleableProperties;\n  if (!hasBatchIds && defined(batchTableBinary)) {\n    tile.styleableProperties = Cesium3DTileBatchTable.getBinaryProperties(\n      pointsLength,\n      batchTableJson,\n      batchTableBinary\n    );\n  }\n\n  tile.draco = draco;\n}\n\n// Separate parsing and decoding of Draco\nexport function parseDracoBuffer(tile, featureTable, batchTable) {\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n\n  const batchTableDraco = batchTable.getExtension('3DTILES_draco_point_compression');\n  if (batchTableDraco) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n  if (featureTableDraco) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!dracoFeatureTableProperties || !dracoByteOffset || !dracoByteLength) {\n      throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n    }\n\n    dracoBuffer = arraySlice(\n      featureTableBinary,\n      dracoByteOffset,\n      dracoByteOffset + dracoByteLength\n    );\n    tile.hasPositions = dracoFeatureTableProperties.POSITION;\n    tile.hasColors = dracoFeatureTableProperties.RGB || dracoFeatureTableProperties.RGBA;\n    tile.hasNormals = dracoFeatureTableProperties.NORMAL;\n    tile.hasBatchIds = dracoFeatureTableProperties.BATCH_ID;\n    tile.isTranslucent = dracoFeatureTableProperties.RGBA;\n  }\n\n  if (dracoBuffer) {\n    tile.draco = {\n      buffer: dracoBuffer,\n      properties: {...dracoFeatureTableProperties, ...dracoBatchTableProperties},\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      dequantizeInShader: false\n    };\n\n    tile.decodingState = DECODING_STATE.NEEDS_DECODE;\n  }\n}\n\n/*\nfunction decodeDraco(tile, context) {\n  if (tile.decodingState === DECODING_STATE.READY) {\n    return false;\n  }\n  if (tile.decodingState === DECODING_STATE.NEEDS_DECODE) {\n    var parsedContent = tile._parsedContent;\n    var draco = parsedContent.draco;\n    var decodePromise = DracoLoader.decodePointCloud(draco, context);\n    if (defined(decodePromise)) {\n      tile.decodingState = DECODING_STATE.DECODING;\n      decodePromise.then(function(result) {\n        tile.decodingState = DECODING_STATE.READY;\n        var decodedPositions = defined(result.POSITION) ? result.POSITION.array : undefined;\n        var decodedRgb = defined(result.RGB) ? result.RGB.array : undefined;\n        var decodedRgba = defined(result.RGBA) ? result.RGBA.array : undefined;\n        var decodedNormals = defined(result.NORMAL) ? result.NORMAL.array : undefined;\n        var decodedBatchIds = defined(result.BATCH_ID) ? result.BATCH_ID.array : undefined;\n        var isQuantizedDraco = defined(decodedPositions) && defined(result.POSITION.data.quantization);\n        var isOctEncodedDraco = defined(decodedNormals) && defined(result.NORMAL.data.quantization);\n        if (isQuantizedDraco) {\n          // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n          // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n          var quantization = result.POSITION.data.quantization;\n          var range = quantization.range;\n          tile._quantizedVolumeScale = Cartesian3.fromElements(range, range, range);\n          tile._quantizedVolumeOffset = Cartesian3.unpack(quantization.minValues);\n          tile._quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n          tile._isQuantizedDraco = true;\n        }\n        if (isOctEncodedDraco) {\n          tile._octEncodedRange = (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n          tile._isOctEncodedDraco = true;\n        }\n        var styleableProperties = parsedContent.styleableProperties;\n        var batchTableProperties = draco.batchTableProperties;\n        for (var name in batchTableProperties) {\n          if (batchTableProperties.hasOwnProperty(name)) {\n            var property = result[name];\n            if (!defined(styleableProperties)) {\n              styleableProperties = {};\n            }\n            styleableProperties[name] = {\n              typedArray : property.array,\n              componentCount : property.data.componentsPerAttribute\n            };\n          }\n        }\n        parsedContent.positions = defaultValue(decodedPositions, parsedContent.positions);\n        parsedContent.colors = defaultValue(defaultValue(decodedRgba, decodedRgb), parsedContent.colors);\n        parsedContent.normals = defaultValue(decodedNormals, parsedContent.normals);\n        parsedContent.batchIds = defaultValue(decodedBatchIds, parsedContent.batchIds);\n        parsedContent.styleableProperties = styleableProperties;\n      }).otherwise(function(error) {\n        tile.decodingState = DECODING_STATE.FAILED;\n        tile._readyPromise.reject(error);\n      });\n    }\n  }\n  return true;\n}\n*/\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,SAASA,WAAW,QAAQ,mBAAmB;AAC/C,SAASC,gBAAgB,QAAQ,0BAA0B;AAC3D,SAASC,EAAE,QAAQ,kBAAkB;AACrC,SAASC,OAAO,QAAQ,eAAe;AACvC,OAAOC,kBAAkB,MAAM,qCAAqC;AACpE,OAAOC,gBAAgB,MAAM,mCAAmC;AAChE,SAASC,qBAAqB,QAAQ,mCAAmC;AACzE,SAASC,2BAA2B,EAAEC,qBAAqB,QAAQ,mCAAmC;AACtG,SAASC,6BAA6B,QAAQ,uCAAuC;AACrF,SAASC,8BAA8B,QAAQ,wCAAwC;AACvF,SAASC,gCAAgC,QAAQ,0CAA0C;AAC3F,OAAO,eAAeC,qBAAqBA,CAACC,IAAI,EAAEC,WAAW,EAAEC,UAAU,EAAEC,OAAO,EAAEC,OAAO,EAAE;EACzFF,UAAU,GAAGT,qBAAqB,CAACO,IAAI,EAAEC,WAAW,EAAEC,UAAU,CAAC;EACjEA,UAAU,GAAGR,2BAA2B,CAACM,IAAI,EAAEC,WAAW,EAAEC,UAAU,CAAC;EACvEA,UAAU,GAAGP,qBAAqB,CAACK,IAAI,EAAEC,WAAW,EAAEC,UAAU,EAAEC,OAAO,CAAC;EAC1EE,cAAc,CAACL,IAAI,CAAC;EACpB,MAAM;IAAEM,YAAY;IAAEC;EAAW,CAAC,GAAGC,qBAAqB,CAACR,IAAI,CAAC;EAChE,MAAMS,UAAU,CAACT,IAAI,EAAEM,YAAY,EAAEC,UAAU,EAAEJ,OAAO,EAAEC,OAAO,CAAC;EAClEM,cAAc,CAACV,IAAI,EAAEM,YAAY,EAAEH,OAAO,CAAC;EAC3C;EACAQ,WAAW,CAACX,IAAI,EAAEM,YAAY,EAAEC,UAAU,CAAC;EAC3CK,YAAY,CAACZ,IAAI,EAAEM,YAAY,CAAC;EAChC,OAAOJ,UAAU;AACrB;AACA,SAASG,cAAcA,CAACL,IAAI,EAAE;EAC1B;EACAA,IAAI,CAACa,UAAU,GAAG;IACdC,SAAS,EAAE,IAAI;IACfC,MAAM,EAAE,IAAI;IACZC,OAAO,EAAE,IAAI;IACbC,QAAQ,EAAE;EACd,CAAC;EACDjB,IAAI,CAACkB,WAAW,GAAG,KAAK;EACxBlB,IAAI,CAACmB,aAAa,GAAG,KAAK;EAC1BnB,IAAI,CAACoB,QAAQ,GAAG,KAAK;EACrBpB,IAAI,CAACqB,eAAe,GAAG,KAAK;AAChC;AACA,SAASb,qBAAqBA,CAACR,IAAI,EAAE;EACjC,MAAMM,YAAY,GAAG,IAAIf,kBAAkB,CAACS,IAAI,CAACsB,gBAAgB,EAAEtB,IAAI,CAACuB,kBAAkB,CAAC;EAC3F,MAAMC,YAAY,GAAGlB,YAAY,CAACmB,iBAAiB,CAAC,eAAe,CAAC;EACpE,IAAI,CAACC,MAAM,CAACC,QAAQ,CAACH,YAAY,CAAC,EAAE;IAChC,MAAM,IAAII,KAAK,CAAC,+BAA+B,CAAC;EACpD;EACAtB,YAAY,CAACuB,cAAc,GAAGL,YAAY;EAC1CxB,IAAI,CAAC6B,cAAc,GAAGL,YAAY;EAClCxB,IAAI,CAACwB,YAAY,GAAGA,YAAY;EAChCxB,IAAI,CAAC8B,UAAU,GAAGN,YAAY;EAC9BxB,IAAI,CAAC+B,SAAS,GAAGzB,YAAY,CAACmB,iBAAiB,CAAC,YAAY,EAAEpC,EAAE,CAAC2C,KAAK,EAAE,CAAC,CAAC;EAC1E,MAAMzB,UAAU,GAAG0B,aAAa,CAACjC,IAAI,EAAEM,YAAY,CAAC;EACpD,OAAO;IAAEA,YAAY;IAAEC;EAAW,CAAC;AACvC;AACA,SAASG,cAAcA,CAACV,IAAI,EAAEM,YAAY,EAAEH,OAAO,EAAE;EACjDH,IAAI,CAACa,UAAU,GAAGb,IAAI,CAACa,UAAU,IAAI;IACjCC,SAAS,EAAE,IAAI;IACfC,MAAM,EAAE,IAAI;IACZC,OAAO,EAAE,IAAI;IACbC,QAAQ,EAAE;EACd,CAAC;EACD,IAAI,CAACjB,IAAI,CAACa,UAAU,CAACC,SAAS,EAAE;IAC5B,IAAIR,YAAY,CAAC4B,WAAW,CAAC,UAAU,CAAC,EAAE;MACtClC,IAAI,CAACa,UAAU,CAACC,SAAS,GAAGR,YAAY,CAAC6B,gBAAgB,CAAC,UAAU,EAAE9C,EAAE,CAAC2C,KAAK,EAAE,CAAC,CAAC;IACtF,CAAC,MACI,IAAI1B,YAAY,CAAC4B,WAAW,CAAC,oBAAoB,CAAC,EAAE;MACrD,MAAMpB,SAAS,GAAGR,YAAY,CAAC6B,gBAAgB,CAAC,oBAAoB,EAAE9C,EAAE,CAAC+C,cAAc,EAAE,CAAC,CAAC;MAC3FpC,IAAI,CAACkB,WAAW,GAAG,IAAI;MACvBlB,IAAI,CAACqC,cAAc,GAAG,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC;MACnCrC,IAAI,CAACsC,oBAAoB,GAAGhC,YAAY,CAACmB,iBAAiB,CAAC,wBAAwB,EAAEpC,EAAE,CAAC2C,KAAK,EAAE,CAAC,CAAC;MACjG,IAAI,CAAChC,IAAI,CAACsC,oBAAoB,EAAE;QAC5B,MAAM,IAAIV,KAAK,CAAC,iEAAiE,CAAC;MACtF;MACA5B,IAAI,CAACuC,qBAAqB,GAAGjC,YAAY,CAACmB,iBAAiB,CAAC,yBAAyB,EAAEpC,EAAE,CAAC2C,KAAK,EAAE,CAAC,CAAC;MACnG,IAAI,CAAChC,IAAI,CAACuC,qBAAqB,EAAE;QAC7B,MAAM,IAAIX,KAAK,CAAC,kEAAkE,CAAC;MACvF;MACA5B,IAAI,CAACa,UAAU,CAACC,SAAS,GAAGhB,gCAAgC,CAACE,IAAI,EAAEc,SAAS,EAAEX,OAAO,CAAC;IAC1F;EACJ;EACA,IAAI,CAACH,IAAI,CAACa,UAAU,CAACC,SAAS,EAAE;IAC5B,MAAM,IAAIc,KAAK,CAAC,wDAAwD,CAAC;EAC7E;AACJ;AACA,SAASjB,WAAWA,CAACX,IAAI,EAAEM,YAAY,EAAEC,UAAU,EAAE;EACjDP,IAAI,CAACa,UAAU,GAAGb,IAAI,CAACa,UAAU,IAAI;IACjCC,SAAS,EAAE,IAAI;IACfC,MAAM,EAAE,IAAI;IACZC,OAAO,EAAE,IAAI;IACbC,QAAQ,EAAE;EACd,CAAC;EACD,IAAI,CAACjB,IAAI,CAACa,UAAU,CAACE,MAAM,EAAE;IACzB,IAAIA,MAAM,GAAG,IAAI;IACjB,IAAIT,YAAY,CAAC4B,WAAW,CAAC,MAAM,CAAC,EAAE;MAClCnB,MAAM,GAAGT,YAAY,CAAC6B,gBAAgB,CAAC,MAAM,EAAE9C,EAAE,CAACmD,aAAa,EAAE,CAAC,CAAC;MACnExC,IAAI,CAACmB,aAAa,GAAG,IAAI;IAC7B,CAAC,MACI,IAAIb,YAAY,CAAC4B,WAAW,CAAC,KAAK,CAAC,EAAE;MACtCnB,MAAM,GAAGT,YAAY,CAAC6B,gBAAgB,CAAC,KAAK,EAAE9C,EAAE,CAACmD,aAAa,EAAE,CAAC,CAAC;IACtE,CAAC,MACI,IAAIlC,YAAY,CAAC4B,WAAW,CAAC,QAAQ,CAAC,EAAE;MACzCnB,MAAM,GAAGT,YAAY,CAAC6B,gBAAgB,CAAC,QAAQ,EAAE9C,EAAE,CAAC+C,cAAc,EAAE,CAAC,CAAC;MACtEpC,IAAI,CAACoB,QAAQ,GAAG,IAAI;IACxB;IACApB,IAAI,CAACa,UAAU,CAACE,MAAM,GAAGnB,6BAA6B,CAACI,IAAI,EAAEe,MAAM,EAAER,UAAU,CAAC;EACpF;EACA,IAAID,YAAY,CAAC4B,WAAW,CAAC,eAAe,CAAC,EAAE;IAC3ClC,IAAI,CAACyC,YAAY,GAAGnC,YAAY,CAACmB,iBAAiB,CAAC,eAAe,EAAEpC,EAAE,CAACmD,aAAa,EAAE,CAAC,CAAC;EAC5F;AACJ;AACA,SAAS5B,YAAYA,CAACZ,IAAI,EAAEM,YAAY,EAAE;EACtCN,IAAI,CAACa,UAAU,GAAGb,IAAI,CAACa,UAAU,IAAI;IACjCC,SAAS,EAAE,IAAI;IACfC,MAAM,EAAE,IAAI;IACZC,OAAO,EAAE,IAAI;IACbC,QAAQ,EAAE;EACd,CAAC;EACD,IAAI,CAACjB,IAAI,CAACa,UAAU,CAACG,OAAO,EAAE;IAC1B,IAAIA,OAAO,GAAG,IAAI;IAClB,IAAIV,YAAY,CAAC4B,WAAW,CAAC,QAAQ,CAAC,EAAE;MACpClB,OAAO,GAAGV,YAAY,CAAC6B,gBAAgB,CAAC,QAAQ,EAAE9C,EAAE,CAAC2C,KAAK,EAAE,CAAC,CAAC;IAClE,CAAC,MACI,IAAI1B,YAAY,CAAC4B,WAAW,CAAC,eAAe,CAAC,EAAE;MAChDlB,OAAO,GAAGV,YAAY,CAAC6B,gBAAgB,CAAC,eAAe,EAAE9C,EAAE,CAACmD,aAAa,EAAE,CAAC,CAAC;MAC7ExC,IAAI,CAACqB,eAAe,GAAG,IAAI;IAC/B;IACArB,IAAI,CAACa,UAAU,CAACG,OAAO,GAAGnB,8BAA8B,CAACG,IAAI,EAAEgB,OAAO,CAAC;EAC3E;AACJ;AACA,SAASiB,aAAaA,CAACjC,IAAI,EAAEM,YAAY,EAAE;EACvC,IAAIC,UAAU,GAAG,IAAI;EACrB,IAAI,CAACP,IAAI,CAACiB,QAAQ,IAAIX,YAAY,CAAC4B,WAAW,CAAC,UAAU,CAAC,EAAE;IACxDlC,IAAI,CAACiB,QAAQ,GAAGX,YAAY,CAAC6B,gBAAgB,CAAC,UAAU,EAAE9C,EAAE,CAAC+C,cAAc,EAAE,CAAC,CAAC;IAC/E,IAAIpC,IAAI,CAACiB,QAAQ,EAAE;MACf,MAAMyB,kBAAkB,GAAGpC,YAAY,CAACmB,iBAAiB,CAAC,cAAc,CAAC;MACzE,IAAI,CAACiB,kBAAkB,EAAE;QACrB,MAAM,IAAId,KAAK,CAAC,yEAAyE,CAAC;MAC9F;MACA,MAAM;QAAEe,cAAc;QAAEC;MAAiB,CAAC,GAAG5C,IAAI;MACjDO,UAAU,GAAG,IAAIf,gBAAgB,CAACmD,cAAc,EAAEC,gBAAgB,EAAEF,kBAAkB,CAAC;IAC3F;EACJ;EACA,OAAOnC,UAAU;AACrB;AACA;AACA,eAAeE,UAAUA,CAACT,IAAI,EAAEM,YAAY,EAAEC,UAAU,EAAEJ,OAAO,EAAEC,OAAO,EAAE;EACxE,IAAIyC,WAAW;EACf,IAAIC,2BAA2B;EAC/B,IAAIC,yBAAyB;EAC7B,MAAMC,eAAe,GAAGhD,IAAI,CAAC2C,cAAc,IACvC3C,IAAI,CAAC2C,cAAc,CAACM,UAAU,IAC9BjD,IAAI,CAAC2C,cAAc,CAACM,UAAU,CAAC,iCAAiC,CAAC;EACrE,IAAID,eAAe,EAAE;IACjBD,yBAAyB,GAAGC,eAAe,CAACE,UAAU;EAC1D;EACA,MAAMC,iBAAiB,GAAG7C,YAAY,CAAC8C,YAAY,CAAC,iCAAiC,CAAC;EACtF,IAAID,iBAAiB,EAAE;IACnBL,2BAA2B,GAAGK,iBAAiB,CAACD,UAAU;IAC1D,MAAMG,eAAe,GAAGF,iBAAiB,CAACjD,UAAU;IACpD,MAAMoD,eAAe,GAAGH,iBAAiB,CAACI,UAAU;IACpD,IAAI,CAACT,2BAA2B,IAAI,CAACpB,MAAM,CAACC,QAAQ,CAAC0B,eAAe,CAAC,IAAI,CAACC,eAAe,EAAE;MACvF,MAAM,IAAI1B,KAAK,CAAC,8DAA8D,CAAC;IACnF;IACAiB,WAAW,GAAG,CAAC7C,IAAI,CAACuB,kBAAkB,IAAI,EAAE,EAAEiC,KAAK,CAACH,eAAe,EAAEA,eAAe,GAAGC,eAAe,CAAC;IACvGtD,IAAI,CAACyD,YAAY,GAAG/B,MAAM,CAACC,QAAQ,CAACmB,2BAA2B,CAACY,QAAQ,CAAC;IACzE1D,IAAI,CAAC2D,SAAS,GACVjC,MAAM,CAACC,QAAQ,CAACmB,2BAA2B,CAACc,GAAG,CAAC,IAC5ClC,MAAM,CAACC,QAAQ,CAACmB,2BAA2B,CAACe,IAAI,CAAC;IACzD7D,IAAI,CAAC8D,UAAU,GAAGpC,MAAM,CAACC,QAAQ,CAACmB,2BAA2B,CAACiB,MAAM,CAAC;IACrE/D,IAAI,CAACgE,WAAW,GAAGtC,MAAM,CAACC,QAAQ,CAACmB,2BAA2B,CAACmB,QAAQ,CAAC;IACxEjE,IAAI,CAACmB,aAAa,GAAGO,MAAM,CAACC,QAAQ,CAACmB,2BAA2B,CAACe,IAAI,CAAC;EAC1E;EACA,IAAI,CAAChB,WAAW,EAAE;IACd,OAAO,IAAI;EACf;EACA,MAAMqB,SAAS,GAAG;IACdC,MAAM,EAAEtB,WAAW;IACnBK,UAAU,EAAE;MAAE,GAAGJ,2BAA2B;MAAE,GAAGC;IAA0B,CAAC;IAC5EqB,sBAAsB,EAAEtB,2BAA2B;IACnDuB,oBAAoB,EAAEtB,yBAAyB;IAC/CuB,kBAAkB,EAAE;EACxB,CAAC;EACD,OAAO,MAAMC,SAAS,CAACvE,IAAI,EAAEkE,SAAS,EAAE/D,OAAO,EAAEC,OAAO,CAAC;AAC7D;AACA;AACA,OAAO,eAAemE,SAASA,CAACvE,IAAI,EAAEkE,SAAS,EAAE/D,OAAO,EAAEC,OAAO,EAAE;EAC/D,IAAI,CAACA,OAAO,EAAE;IACV;EACJ;EACA,MAAMoE,YAAY,GAAG;IACjB,GAAGrE,OAAO;IACVsE,KAAK,EAAE;MACH,GAAGtE,OAAO,EAAEsE,KAAK;MACjBC,eAAe,EAAER,SAAS,CAACG,oBAAoB,IAAI,CAAC;IACxD;EACJ,CAAC;EACD;EACA,OAAOG,YAAY,CAAC,UAAU,CAAC;EAC/B,MAAMG,IAAI,GAAG,MAAMvF,gBAAgB,CAAC8E,SAAS,CAACC,MAAM,EAAEhF,WAAW,EAAEqF,YAAY,EAAEpE,OAAO,CAAC;EACzF,MAAMwE,gBAAgB,GAAGD,IAAI,CAAC9D,UAAU,CAAC6C,QAAQ,IAAIiB,IAAI,CAAC9D,UAAU,CAAC6C,QAAQ,CAACmB,KAAK;EACnF,MAAMC,aAAa,GAAGH,IAAI,CAAC9D,UAAU,CAACkE,OAAO,IAAIJ,IAAI,CAAC9D,UAAU,CAACkE,OAAO,CAACF,KAAK;EAC9E,MAAMG,cAAc,GAAGL,IAAI,CAAC9D,UAAU,CAACkD,MAAM,IAAIY,IAAI,CAAC9D,UAAU,CAACkD,MAAM,CAACc,KAAK;EAC7E,MAAMI,eAAe,GAAGN,IAAI,CAAC9D,UAAU,CAACoD,QAAQ,IAAIU,IAAI,CAAC9D,UAAU,CAACoD,QAAQ,CAACY,KAAK;EAClF;EACA,MAAMK,gBAAgB,GAAGN,gBAAgB,IAAID,IAAI,CAAC9D,UAAU,CAAC6C,QAAQ,CAACmB,KAAK,CAACM,YAAY;EACxF;EACA,MAAMC,iBAAiB,GAAGJ,cAAc,IAAIL,IAAI,CAAC9D,UAAU,CAACkD,MAAM,CAACc,KAAK,CAACM,YAAY;EACrF,IAAID,gBAAgB,EAAE;IAClB;IACA;IACA;IACA,MAAMC,YAAY,GAAGR,IAAI,CAACjB,QAAQ,CAACiB,IAAI,CAACQ,YAAY;IACpD,MAAME,KAAK,GAAGF,YAAY,CAACE,KAAK;IAChCrF,IAAI,CAACsC,oBAAoB,GAAG,IAAIhD,OAAO,CAAC+F,KAAK,EAAEA,KAAK,EAAEA,KAAK,CAAC;IAC5DrF,IAAI,CAACuC,qBAAqB,GAAG,IAAIjD,OAAO,CAAC6F,YAAY,CAACG,SAAS,CAAC;IAChEtF,IAAI,CAACqC,cAAc,GAAG,CAAC,CAAC,IAAI8C,YAAY,CAACI,gBAAgB,IAAI,GAAG;IAChEvF,IAAI,CAACkF,gBAAgB,GAAG,IAAI;EAChC;EACA,IAAIE,iBAAiB,EAAE;IACnB;IACApF,IAAI,CAACwF,eAAe,GAAG,CAAC,CAAC,IAAIb,IAAI,CAACZ,MAAM,CAACY,IAAI,CAACQ,YAAY,CAACI,gBAAgB,IAAI,GAAG;IAClFvF,IAAI,CAACoF,iBAAiB,GAAG,IAAI;EACjC;EACA;EACA,MAAMK,oBAAoB,GAAG,CAAC,CAAC;EAC/B,IAAIvB,SAAS,CAACG,oBAAoB,EAAE;IAChC,KAAK,MAAMqB,aAAa,IAAIC,MAAM,CAACC,IAAI,CAAC1B,SAAS,CAACG,oBAAoB,CAAC,EAAE;MACrE,IAAIM,IAAI,CAAC9D,UAAU,CAAC6E,aAAa,CAAC,IAAIf,IAAI,CAAC9D,UAAU,CAAC6E,aAAa,CAAC,CAACb,KAAK,EAAE;QACxEY,oBAAoB,CAACC,aAAa,CAACG,WAAW,CAAC,CAAC,CAAC,GAAGlB,IAAI,CAAC9D,UAAU,CAAC6E,aAAa,CAAC,CAACb,KAAK;MAC5F;IACJ;EACJ;EACA7E,IAAI,CAACa,UAAU,GAAG;IACd;IACAC,SAAS,EAAE8D,gBAAgB;IAC3B;IACA7D,MAAM,EAAEnB,6BAA6B,CAACI,IAAI,EAAE8E,aAAa,EAAEgB,SAAS,CAAC;IACrE;IACA9E,OAAO,EAAEgE,cAAc;IACvB;IACA/D,QAAQ,EAAEgE,eAAe;IACzB,GAAGQ;EACP,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}