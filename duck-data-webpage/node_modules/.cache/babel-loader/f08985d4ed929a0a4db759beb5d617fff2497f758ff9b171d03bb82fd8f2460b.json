{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { CompositeLayer, _flatten as flatten } from '@deck.gl/core';\nimport { GeoJsonLayer } from '@deck.gl/layers';\nimport { Tileset2D, STRATEGY_DEFAULT } from \"../tileset-2d/index.js\";\nimport { urlType, getURLFromTemplate } from \"../tileset-2d/index.js\";\nconst defaultProps = {\n  TilesetClass: Tileset2D,\n  data: {\n    type: 'data',\n    value: []\n  },\n  dataComparator: urlType.equal,\n  renderSubLayers: {\n    type: 'function',\n    value: props => new GeoJsonLayer(props)\n  },\n  getTileData: {\n    type: 'function',\n    optional: true,\n    value: null\n  },\n  // TODO - change to onViewportLoad to align with Tile3DLayer\n  onViewportLoad: {\n    type: 'function',\n    optional: true,\n    value: null\n  },\n  onTileLoad: {\n    type: 'function',\n    value: tile => {}\n  },\n  onTileUnload: {\n    type: 'function',\n    value: tile => {}\n  },\n  // eslint-disable-next-line\n  onTileError: {\n    type: 'function',\n    value: err => console.error(err)\n  },\n  extent: {\n    type: 'array',\n    optional: true,\n    value: null,\n    compare: true\n  },\n  tileSize: 512,\n  maxZoom: null,\n  minZoom: 0,\n  maxCacheSize: null,\n  maxCacheByteSize: null,\n  refinementStrategy: STRATEGY_DEFAULT,\n  zRange: null,\n  maxRequests: 6,\n  debounceTime: 0,\n  zoomOffset: 0\n};\n/**\n * The TileLayer is a composite layer that makes it possible to visualize very large datasets.\n *\n * Instead of fetching the entire dataset, it only loads and renders what's visible in the current viewport.\n */\nclass TileLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      tileset: null,\n      isLoaded: false\n    };\n  }\n  finalizeState() {\n    this.state?.tileset?.finalize();\n  }\n  get isLoaded() {\n    return Boolean(this.state?.tileset?.selectedTiles?.every(tile => tile.isLoaded && tile.layers && tile.layers.every(layer => layer.isLoaded)));\n  }\n  shouldUpdateState({\n    changeFlags\n  }) {\n    return changeFlags.somethingChanged;\n  }\n  updateState({\n    changeFlags\n  }) {\n    let {\n      tileset\n    } = this.state;\n    const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;\n    const dataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);\n    if (!tileset) {\n      tileset = new this.props.TilesetClass(this._getTilesetOptions());\n      this.setState({\n        tileset\n      });\n    } else if (propsChanged) {\n      tileset.setOptions(this._getTilesetOptions());\n      if (dataChanged) {\n        // reload all tiles\n        // use cached layers until new content is loaded\n        tileset.reloadAll();\n      } else {\n        // some render options changed, regenerate sub layers now\n        tileset.tiles.forEach(tile => {\n          tile.layers = null;\n        });\n      }\n    }\n    this._updateTileset();\n  }\n  _getTilesetOptions() {\n    const {\n      tileSize,\n      maxCacheSize,\n      maxCacheByteSize,\n      refinementStrategy,\n      extent,\n      maxZoom,\n      minZoom,\n      maxRequests,\n      debounceTime,\n      zoomOffset\n    } = this.props;\n    return {\n      maxCacheSize,\n      maxCacheByteSize,\n      maxZoom,\n      minZoom,\n      tileSize,\n      refinementStrategy,\n      extent,\n      maxRequests,\n      debounceTime,\n      zoomOffset,\n      getTileData: this.getTileData.bind(this),\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileError: this._onTileError.bind(this),\n      onTileUnload: this._onTileUnload.bind(this)\n    };\n  }\n  _updateTileset() {\n    const tileset = this.state.tileset;\n    const {\n      zRange,\n      modelMatrix\n    } = this.props;\n    const frameNumber = tileset.update(this.context.viewport, {\n      zRange,\n      modelMatrix\n    });\n    const {\n      isLoaded\n    } = tileset;\n    const loadingStateChanged = this.state.isLoaded !== isLoaded;\n    const tilesetChanged = this.state.frameNumber !== frameNumber;\n    if (isLoaded && (loadingStateChanged || tilesetChanged)) {\n      this._onViewportLoad();\n    }\n    if (tilesetChanged) {\n      // Save the tileset frame number - trigger a rerender\n      this.setState({\n        frameNumber\n      });\n    }\n    // Save the loaded state - should not trigger a rerender\n    this.state.isLoaded = isLoaded;\n  }\n  _onViewportLoad() {\n    const {\n      tileset\n    } = this.state;\n    const {\n      onViewportLoad\n    } = this.props;\n    if (onViewportLoad) {\n      // This method can only be called when tileset is defined and updated\n      onViewportLoad(tileset.selectedTiles);\n    }\n  }\n  _onTileLoad(tile) {\n    this.props.onTileLoad(tile);\n    tile.layers = null;\n    this.setNeedsUpdate();\n  }\n  _onTileError(error, tile) {\n    this.props.onTileError(error);\n    tile.layers = null;\n    this.setNeedsUpdate();\n  }\n  _onTileUnload(tile) {\n    this.props.onTileUnload(tile);\n  }\n  // Methods for subclass to override\n  getTileData(tile) {\n    const {\n      data,\n      getTileData,\n      fetch\n    } = this.props;\n    const {\n      signal\n    } = tile;\n    tile.url = typeof data === 'string' || Array.isArray(data) ? getURLFromTemplate(data, tile) : null;\n    if (getTileData) {\n      return getTileData(tile);\n    }\n    if (fetch && tile.url) {\n      return fetch(tile.url, {\n        propName: 'data',\n        layer: this,\n        signal\n      });\n    }\n    return null;\n  }\n  renderSubLayers(props) {\n    return this.props.renderSubLayers(props);\n  }\n  getSubLayerPropsByTile(tile) {\n    return null;\n  }\n  getPickingInfo(params) {\n    // TileLayer does not directly render anything, sourceLayer cannot be null\n    const sourceLayer = params.sourceLayer;\n    const sourceTile = sourceLayer.props.tile;\n    const info = params.info;\n    if (info.picked) {\n      info.tile = sourceTile;\n    }\n    info.sourceTile = sourceTile;\n    info.sourceTileSubLayer = sourceLayer;\n    return info;\n  }\n  _updateAutoHighlight(info) {\n    info.sourceTileSubLayer.updateAutoHighlight(info);\n  }\n  renderLayers() {\n    return this.state.tileset.tiles.map(tile => {\n      const subLayerProps = this.getSubLayerPropsByTile(tile);\n      // cache the rendered layer in the tile\n      if (!tile.isLoaded && !tile.content) {\n        // nothing to show\n      } else if (!tile.layers) {\n        const layers = this.renderSubLayers({\n          ...this.props,\n          ...this.getSubLayerProps({\n            id: tile.id,\n            updateTriggers: this.props.updateTriggers\n          }),\n          data: tile.content,\n          _offset: 0,\n          tile\n        });\n        tile.layers = flatten(layers, Boolean).map(layer => layer.clone({\n          tile,\n          ...subLayerProps\n        }));\n      } else if (subLayerProps && tile.layers[0] && Object.keys(subLayerProps).some(propName => tile.layers[0].props[propName] !== subLayerProps[propName])) {\n        tile.layers = tile.layers.map(layer => layer.clone(subLayerProps));\n      }\n      return tile.layers;\n    });\n  }\n  filterSubLayer({\n    layer,\n    cullRect\n  }) {\n    const {\n      tile\n    } = layer.props;\n    return this.state.tileset.isTileVisible(tile, cullRect);\n  }\n}\nTileLayer.defaultProps = defaultProps;\nTileLayer.layerName = 'TileLayer';\nexport default TileLayer;","map":{"version":3,"names":["CompositeLayer","_flatten","flatten","GeoJsonLayer","Tileset2D","STRATEGY_DEFAULT","urlType","getURLFromTemplate","defaultProps","TilesetClass","data","type","value","dataComparator","equal","renderSubLayers","props","getTileData","optional","onViewportLoad","onTileLoad","tile","onTileUnload","onTileError","err","console","error","extent","compare","tileSize","maxZoom","minZoom","maxCacheSize","maxCacheByteSize","refinementStrategy","zRange","maxRequests","debounceTime","zoomOffset","TileLayer","initializeState","state","tileset","isLoaded","finalizeState","finalize","Boolean","selectedTiles","every","layers","layer","shouldUpdateState","changeFlags","somethingChanged","updateState","propsChanged","propsOrDataChanged","updateTriggersChanged","dataChanged","all","_getTilesetOptions","setState","setOptions","reloadAll","tiles","forEach","_updateTileset","bind","_onTileLoad","_onTileError","_onTileUnload","modelMatrix","frameNumber","update","context","viewport","loadingStateChanged","tilesetChanged","_onViewportLoad","setNeedsUpdate","fetch","signal","url","Array","isArray","propName","getSubLayerPropsByTile","getPickingInfo","params","sourceLayer","sourceTile","info","picked","sourceTileSubLayer","_updateAutoHighlight","updateAutoHighlight","renderLayers","map","subLayerProps","content","getSubLayerProps","id","updateTriggers","_offset","clone","Object","keys","some","filterSubLayer","cullRect","isTileVisible","layerName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\geo-layers\\src\\tile-layer\\tile-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  CompositeLayer,\n  CompositeLayerProps,\n  Layer,\n  LayerProps,\n  UpdateParameters,\n  PickingInfo,\n  GetPickingInfoParams,\n  DefaultProps,\n  FilterContext,\n  _flatten as flatten\n} from '@deck.gl/core';\nimport {GeoJsonLayer} from '@deck.gl/layers';\nimport {LayersList} from '@deck.gl/core';\n\nimport type {TileLoadProps, ZRange} from '../tileset-2d/index';\nimport {\n  Tileset2D,\n  Tile2DHeader,\n  RefinementStrategy,\n  STRATEGY_DEFAULT,\n  Tileset2DProps\n} from '../tileset-2d/index';\nimport {urlType, URLTemplate, getURLFromTemplate} from '../tileset-2d/index';\n\nconst defaultProps: DefaultProps<TileLayerProps> = {\n  TilesetClass: Tileset2D,\n  data: {type: 'data', value: []},\n  dataComparator: urlType.equal,\n  renderSubLayers: {type: 'function', value: (props: any) => new GeoJsonLayer(props)},\n  getTileData: {type: 'function', optional: true, value: null},\n  // TODO - change to onViewportLoad to align with Tile3DLayer\n  onViewportLoad: {type: 'function', optional: true, value: null},\n  onTileLoad: {type: 'function', value: tile => {}},\n  onTileUnload: {type: 'function', value: tile => {}},\n  // eslint-disable-next-line\n  onTileError: {type: 'function', value: err => console.error(err)},\n  extent: {type: 'array', optional: true, value: null, compare: true},\n  tileSize: 512,\n  maxZoom: null,\n  minZoom: 0,\n  maxCacheSize: null,\n  maxCacheByteSize: null,\n  refinementStrategy: STRATEGY_DEFAULT,\n  zRange: null,\n  maxRequests: 6,\n  debounceTime: 0,\n  zoomOffset: 0\n};\n\n/** All props supported by the TileLayer */\nexport type TileLayerProps<DataT = unknown> = CompositeLayerProps & _TileLayerProps<DataT>;\n\n/** Props added by the TileLayer */\ntype _TileLayerProps<DataT> = {\n  data: URLTemplate;\n  /**\n   * Optionally implement a custom indexing scheme.\n   */\n  TilesetClass?: typeof Tileset2D;\n  /**\n   * Renders one or an array of Layer instances.\n   */\n  renderSubLayers?: (\n    props: TileLayerProps<DataT> & {\n      id: string;\n      data: DataT;\n      _offset: number;\n      tile: Tile2DHeader<DataT>;\n    }\n  ) => Layer | null | LayersList;\n  /**\n   * If supplied, `getTileData` is called to retrieve the data of each tile.\n   */\n  getTileData?: ((props: TileLoadProps) => Promise<DataT> | DataT) | null;\n\n  /** Called when all tiles in the current viewport are loaded. */\n  onViewportLoad?: ((tiles: Tile2DHeader<DataT>[]) => void) | null;\n\n  /** Called when a tile successfully loads. */\n  onTileLoad?: (tile: Tile2DHeader<DataT>) => void;\n\n  /** Called when a tile is cleared from cache. */\n  onTileUnload?: (tile: Tile2DHeader<DataT>) => void;\n\n  /** Called when a tile failed to load. */\n  onTileError?: (err: any, tile?) => void;\n\n  /** The bounding box of the layer's data. */\n  extent?: number[] | null;\n\n  /** The pixel dimension of the tiles, usually a power of 2. */\n  tileSize?: number;\n\n  /** The max zoom level of the layer's data.\n   * @default null\n   */\n  maxZoom?: number | null;\n\n  /** The min zoom level of the layer's data.\n   * @default 0\n   */\n  minZoom?: number | null;\n\n  /** The maximum number of tiles that can be cached. */\n  maxCacheSize?: number | null;\n\n  /**\n   * The maximum memory used for caching tiles.\n   *\n   * @default null\n   */\n  maxCacheByteSize?: number | null;\n\n  /**\n   * How the tile layer refines the visibility of tiles.\n   *\n   * @default 'best-available'\n   */\n  refinementStrategy?: RefinementStrategy;\n\n  /** Range of minimum and maximum heights in the tile. */\n  zRange?: ZRange | null;\n\n  /**\n   * The maximum number of concurrent getTileData calls.\n   *\n   * @default 6\n   */\n  maxRequests?: number;\n\n  /**\n   * Queue tile requests until no new tiles have been requested for at least `debounceTime` milliseconds.\n   *\n   * @default 0\n   */\n  debounceTime?: number;\n\n  /**\n   * This offset changes the zoom level at which the tiles are fetched.\n   *\n   * Needs to be an integer.\n   *\n   * @default 0\n   */\n  zoomOffset?: number;\n};\n\nexport type TileLayerPickingInfo<\n  DataT = any,\n  SubLayerPickingInfo = PickingInfo\n> = SubLayerPickingInfo & {\n  /** The picked tile */\n  tile?: Tile2DHeader<DataT>;\n  /** the tile that emitted the picking event */\n  sourceTile: Tile2DHeader<DataT>;\n  /** a layer created by props.renderSubLayer() that emitted the picking event */\n  sourceTileSubLayer: Layer;\n};\n\n/**\n * The TileLayer is a composite layer that makes it possible to visualize very large datasets.\n *\n * Instead of fetching the entire dataset, it only loads and renders what's visible in the current viewport.\n */\nexport default class TileLayer<DataT = any, ExtraPropsT extends {} = {}> extends CompositeLayer<\n  ExtraPropsT & Required<_TileLayerProps<DataT>>\n> {\n  static defaultProps: DefaultProps = defaultProps;\n  static layerName = 'TileLayer';\n\n  state!: {\n    tileset: Tileset2D | null;\n    isLoaded: boolean;\n    frameNumber?: number;\n  };\n\n  initializeState() {\n    this.state = {\n      tileset: null,\n      isLoaded: false\n    };\n  }\n\n  finalizeState() {\n    this.state?.tileset?.finalize();\n  }\n\n  get isLoaded(): boolean {\n    return Boolean(\n      this.state?.tileset?.selectedTiles?.every(\n        tile => tile.isLoaded && tile.layers && tile.layers.every(layer => layer.isLoaded)\n      )\n    );\n  }\n\n  shouldUpdateState({changeFlags}): boolean {\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({changeFlags}: UpdateParameters<this>) {\n    let {tileset} = this.state;\n    const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;\n    const dataChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData));\n\n    if (!tileset) {\n      tileset = new this.props.TilesetClass(this._getTilesetOptions());\n      this.setState({tileset});\n    } else if (propsChanged) {\n      tileset.setOptions(this._getTilesetOptions());\n\n      if (dataChanged) {\n        // reload all tiles\n        // use cached layers until new content is loaded\n        tileset.reloadAll();\n      } else {\n        // some render options changed, regenerate sub layers now\n        tileset.tiles.forEach(tile => {\n          tile.layers = null;\n        });\n      }\n    }\n\n    this._updateTileset();\n  }\n\n  _getTilesetOptions(): Tileset2DProps {\n    const {\n      tileSize,\n      maxCacheSize,\n      maxCacheByteSize,\n      refinementStrategy,\n      extent,\n      maxZoom,\n      minZoom,\n      maxRequests,\n      debounceTime,\n      zoomOffset\n    } = this.props;\n\n    return {\n      maxCacheSize,\n      maxCacheByteSize,\n      maxZoom,\n      minZoom,\n      tileSize,\n      refinementStrategy,\n      extent,\n      maxRequests,\n      debounceTime,\n      zoomOffset,\n\n      getTileData: this.getTileData.bind(this),\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileError: this._onTileError.bind(this),\n      onTileUnload: this._onTileUnload.bind(this)\n    };\n  }\n\n  private _updateTileset(): void {\n    const tileset = this.state.tileset!;\n    const {zRange, modelMatrix} = this.props;\n    const frameNumber = tileset.update(this.context.viewport, {zRange, modelMatrix});\n    const {isLoaded} = tileset;\n\n    const loadingStateChanged = this.state.isLoaded !== isLoaded;\n    const tilesetChanged = this.state.frameNumber !== frameNumber;\n\n    if (isLoaded && (loadingStateChanged || tilesetChanged)) {\n      this._onViewportLoad();\n    }\n\n    if (tilesetChanged) {\n      // Save the tileset frame number - trigger a rerender\n      this.setState({frameNumber});\n    }\n    // Save the loaded state - should not trigger a rerender\n    this.state.isLoaded = isLoaded;\n  }\n\n  _onViewportLoad(): void {\n    const {tileset} = this.state;\n    const {onViewportLoad} = this.props;\n\n    if (onViewportLoad) {\n      // This method can only be called when tileset is defined and updated\n      onViewportLoad(tileset!.selectedTiles!);\n    }\n  }\n\n  _onTileLoad(tile: Tile2DHeader<DataT>): void {\n    this.props.onTileLoad(tile);\n    tile.layers = null;\n\n    this.setNeedsUpdate();\n  }\n\n  _onTileError(error: any, tile: Tile2DHeader<DataT>) {\n    this.props.onTileError(error);\n    tile.layers = null;\n\n    this.setNeedsUpdate();\n  }\n\n  _onTileUnload(tile: Tile2DHeader<DataT>) {\n    this.props.onTileUnload(tile);\n  }\n\n  // Methods for subclass to override\n\n  getTileData(tile: TileLoadProps): Promise<DataT> | DataT | null {\n    const {data, getTileData, fetch} = this.props;\n    const {signal} = tile;\n\n    tile.url =\n      typeof data === 'string' || Array.isArray(data) ? getURLFromTemplate(data, tile) : null;\n\n    if (getTileData) {\n      return getTileData(tile);\n    }\n    if (fetch && tile.url) {\n      return fetch(tile.url, {propName: 'data', layer: this, signal});\n    }\n    return null;\n  }\n\n  renderSubLayers(\n    props: TileLayer['props'] & {\n      id: string;\n      data: DataT;\n      _offset: number;\n      tile: Tile2DHeader<DataT>;\n    }\n  ): Layer | null | LayersList {\n    return this.props.renderSubLayers(props);\n  }\n\n  getSubLayerPropsByTile(tile: Tile2DHeader): Partial<LayerProps> | null {\n    return null;\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): TileLayerPickingInfo<DataT> {\n    // TileLayer does not directly render anything, sourceLayer cannot be null\n    const sourceLayer = params.sourceLayer!;\n    const sourceTile: Tile2DHeader<DataT> = (sourceLayer.props as any).tile;\n    const info = params.info as TileLayerPickingInfo<DataT>;\n    if (info.picked) {\n      info.tile = sourceTile;\n    }\n    info.sourceTile = sourceTile;\n    info.sourceTileSubLayer = sourceLayer;\n    return info;\n  }\n\n  protected _updateAutoHighlight(info: TileLayerPickingInfo<DataT>): void {\n    info.sourceTileSubLayer.updateAutoHighlight(info);\n  }\n\n  renderLayers(): Layer | null | LayersList {\n    return this.state.tileset!.tiles.map((tile: Tile2DHeader) => {\n      const subLayerProps = this.getSubLayerPropsByTile(tile);\n      // cache the rendered layer in the tile\n      if (!tile.isLoaded && !tile.content) {\n        // nothing to show\n      } else if (!tile.layers) {\n        const layers = this.renderSubLayers({\n          ...this.props,\n          ...this.getSubLayerProps({\n            id: tile.id,\n            updateTriggers: this.props.updateTriggers\n          }),\n          data: tile.content,\n          _offset: 0,\n          tile\n        });\n        tile.layers = (flatten(layers, Boolean) as Layer<{tile?: Tile2DHeader}>[]).map(layer =>\n          layer.clone({\n            tile,\n            ...subLayerProps\n          })\n        );\n      } else if (\n        subLayerProps &&\n        tile.layers[0] &&\n        Object.keys(subLayerProps).some(\n          propName => tile.layers![0].props[propName] !== subLayerProps[propName]\n        )\n      ) {\n        tile.layers = tile.layers.map(layer => layer.clone(subLayerProps));\n      }\n      return tile.layers;\n    });\n  }\n\n  filterSubLayer({layer, cullRect}: FilterContext) {\n    const {tile} = (layer as Layer<{tile: Tile2DHeader}>).props;\n    return this.state.tileset!.isTileVisible(tile, cullRect);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}