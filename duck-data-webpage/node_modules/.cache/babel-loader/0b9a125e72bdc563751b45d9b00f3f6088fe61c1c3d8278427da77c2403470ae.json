{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { padArray } from \"../utils/array-utils.js\";\nimport Attribute from \"../lib/attribute/attribute.js\";\nimport { GL } from '@luma.gl/constants';\n/** Create a new empty attribute with the same settings: type, shader layout etc. */\nexport function cloneAttribute(attribute) {\n  // `attribute.settings` is the original options passed when constructing the attribute.\n  // This ensures that we set the proper `doublePrecision` flag and shader attributes.\n  const {\n    device,\n    settings,\n    value\n  } = attribute;\n  const newAttribute = new Attribute(device, settings);\n  // Placeholder value - necessary for generating the correct buffer layout\n  newAttribute.setData({\n    value: value instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),\n    normalized: settings.normalized\n  });\n  return newAttribute;\n}\n/** Returns the GLSL attribute type for the given number of float32 components. */\nexport function getAttributeTypeFromSize(size) {\n  switch (size) {\n    case 1:\n      return 'float';\n    case 2:\n      return 'vec2';\n    case 3:\n      return 'vec3';\n    case 4:\n      return 'vec4';\n    default:\n      throw new Error(`No defined attribute type for size \"${size}\"`);\n  }\n}\n/** Returns the {@link VertexFormat} for the given number of float32 components. */\nexport function getFloat32VertexFormat(size) {\n  switch (size) {\n    case 1:\n      return 'float32';\n    case 2:\n      return 'float32x2';\n    case 3:\n      return 'float32x3';\n    case 4:\n      return 'float32x4';\n    default:\n      throw new Error('invalid type size');\n  }\n}\nexport function cycleBuffers(buffers) {\n  buffers.push(buffers.shift());\n}\nexport function getAttributeBufferLength(attribute, numInstances) {\n  const {\n    doublePrecision,\n    settings,\n    value,\n    size\n  } = attribute;\n  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;\n  let maxVertexOffset = 0;\n  const {\n    shaderAttributes\n  } = attribute.settings;\n  if (shaderAttributes) {\n    for (const shaderAttribute of Object.values(shaderAttributes)) {\n      maxVertexOffset = Math.max(maxVertexOffset, shaderAttribute.vertexOffset ?? 0);\n    }\n  }\n  return (settings.noAlloc ? value.length : (numInstances + maxVertexOffset) * size) * multiplier;\n}\nexport function matchBuffer({\n  device,\n  source,\n  target\n}) {\n  if (!target || target.byteLength < source.byteLength) {\n    target?.destroy();\n    target = device.createBuffer({\n      byteLength: source.byteLength,\n      usage: source.usage\n    });\n  }\n  return target;\n}\n/* eslint-disable complexity */\n// This helper is used when transitioning attributes from a set of values in one buffer layout\n// to a set of values in a different buffer layout. (Buffer layouts are used when attribute values\n// within a buffer should be grouped for drawElements, like the Polygon layer.) For example, a\n// buffer layout of [3, 4] might have data [A1, A2, A3, B1, B2, B3, B4]. If it needs to transition\n// to a buffer layout of [4, 2], it should produce a buffer, using the transition setting's `enter`\n// function, that looks like this: [A1, A2, A3, A4 (user `enter` fn), B1, B2, 0]. Note: the final\n// 0 in this buffer is because we never shrink buffers, only grow them, for performance reasons.\n//\n// padBuffer may return either the original buffer, or a new buffer if the size of the original\n// was insufficient. Callers are responsible for disposing of the original buffer if needed.\nexport function padBuffer({\n  device,\n  buffer,\n  attribute,\n  fromLength,\n  toLength,\n  fromStartIndices,\n  getData = x => x\n}) {\n  // TODO: move the precisionMultiplier logic to the attribute when retrieving\n  // its `size` and `elementOffset`?\n  const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;\n  const size = attribute.size * precisionMultiplier;\n  const byteOffset = attribute.byteOffset;\n  // Transform feedback can only write to float varyings\n  // Attributes of format unorm8/uint8 (1 byte per element) etc will be padded to float32 (4 bytes per element)\n  const targetByteOffset = attribute.settings.bytesPerElement < 4 ? byteOffset / attribute.settings.bytesPerElement * 4 : byteOffset;\n  const toStartIndices = attribute.startIndices;\n  const hasStartIndices = fromStartIndices && toStartIndices;\n  const isConstant = attribute.isConstant;\n  // check if buffer needs to be padded\n  if (!hasStartIndices && buffer && fromLength >= toLength) {\n    return buffer;\n  }\n  const ArrayType = attribute.value instanceof Float64Array ? Float32Array : attribute.value.constructor;\n  const toData = isConstant ? attribute.value :\n  // TODO(v9.1): Avoid non-portable synchronous reads.\n  new ArrayType(attribute.getBuffer().readSyncWebGL(byteOffset, toLength * ArrayType.BYTES_PER_ELEMENT).buffer);\n  if (attribute.settings.normalized && !isConstant) {\n    const getter = getData;\n    getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));\n  }\n  const getMissingData = isConstant ? (i, chunk) => getData(toData, chunk) : (i, chunk) => getData(toData.subarray(i + byteOffset, i + byteOffset + size), chunk);\n  // TODO(v9.1): Avoid non-portable synchronous reads.\n  const source = buffer ? new Float32Array(buffer.readSyncWebGL(targetByteOffset, fromLength * 4).buffer) : new Float32Array(0);\n  const target = new Float32Array(toLength);\n  padArray({\n    source,\n    target,\n    sourceStartIndices: fromStartIndices,\n    targetStartIndices: toStartIndices,\n    size,\n    getData: getMissingData\n  });\n  if (!buffer || buffer.byteLength < target.byteLength + targetByteOffset) {\n    buffer?.destroy();\n    buffer = device.createBuffer({\n      byteLength: target.byteLength + targetByteOffset,\n      usage: 35050\n    });\n  }\n  buffer.write(target, targetByteOffset);\n  return buffer;\n}","map":{"version":3,"names":["padArray","Attribute","GL","cloneAttribute","attribute","device","settings","value","newAttribute","setData","Float64Array","Float32Array","normalized","getAttributeTypeFromSize","size","Error","getFloat32VertexFormat","cycleBuffers","buffers","push","shift","getAttributeBufferLength","numInstances","doublePrecision","multiplier","maxVertexOffset","shaderAttributes","shaderAttribute","Object","values","Math","max","vertexOffset","noAlloc","length","matchBuffer","source","target","byteLength","destroy","createBuffer","usage","padBuffer","buffer","fromLength","toLength","fromStartIndices","getData","x","precisionMultiplier","byteOffset","targetByteOffset","bytesPerElement","toStartIndices","startIndices","hasStartIndices","isConstant","ArrayType","constructor","toData","getBuffer","readSyncWebGL","BYTES_PER_ELEMENT","getter","chunk","normalizeConstant","getMissingData","i","subarray","sourceStartIndices","targetStartIndices","write"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\transitions\\gpu-transition-utils.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device, Buffer, VertexFormat} from '@luma.gl/core';\nimport {padArray} from '../utils/array-utils';\nimport {NumericArray, TypedArray, TypedArrayConstructor} from '../types/types';\nimport Attribute from '../lib/attribute/attribute';\nimport {GL} from '@luma.gl/constants';\n\n/** Create a new empty attribute with the same settings: type, shader layout etc. */\nexport function cloneAttribute(attribute: Attribute): Attribute {\n  // `attribute.settings` is the original options passed when constructing the attribute.\n  // This ensures that we set the proper `doublePrecision` flag and shader attributes.\n  const {device, settings, value} = attribute;\n  const newAttribute = new Attribute(device, settings);\n  // Placeholder value - necessary for generating the correct buffer layout\n  newAttribute.setData({\n    value: value instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),\n    normalized: settings.normalized\n  });\n  return newAttribute;\n}\n\n/** Returns the GLSL attribute type for the given number of float32 components. */\nexport function getAttributeTypeFromSize(size: number): string {\n  switch (size) {\n    case 1:\n      return 'float';\n    case 2:\n      return 'vec2';\n    case 3:\n      return 'vec3';\n    case 4:\n      return 'vec4';\n    default:\n      throw new Error(`No defined attribute type for size \"${size}\"`);\n  }\n}\n\n/** Returns the {@link VertexFormat} for the given number of float32 components. */\nexport function getFloat32VertexFormat(size: number): VertexFormat {\n  switch (size) {\n    case 1:\n      return 'float32';\n    case 2:\n      return 'float32x2';\n    case 3:\n      return 'float32x3';\n    case 4:\n      return 'float32x4';\n    default:\n      throw new Error('invalid type size');\n  }\n}\n\nexport function cycleBuffers(buffers: Buffer[]): void {\n  buffers.push(buffers.shift() as Buffer);\n}\n\nexport function getAttributeBufferLength(attribute: Attribute, numInstances: number): number {\n  const {doublePrecision, settings, value, size} = attribute;\n  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;\n  let maxVertexOffset = 0;\n  const {shaderAttributes} = attribute.settings;\n  if (shaderAttributes) {\n    for (const shaderAttribute of Object.values(shaderAttributes)) {\n      maxVertexOffset = Math.max(maxVertexOffset, shaderAttribute.vertexOffset ?? 0);\n    }\n  }\n  return (\n    (settings.noAlloc ? (value as NumericArray).length : (numInstances + maxVertexOffset) * size) *\n    multiplier\n  );\n}\n\nexport function matchBuffer({\n  device,\n  source,\n  target\n}: {\n  device: Device;\n  source: Buffer;\n  target?: Buffer;\n}): Buffer {\n  if (!target || target.byteLength < source.byteLength) {\n    target?.destroy();\n    target = device.createBuffer({\n      byteLength: source.byteLength,\n      usage: source.usage\n    });\n  }\n  return target;\n}\n\n/* eslint-disable complexity */\n// This helper is used when transitioning attributes from a set of values in one buffer layout\n// to a set of values in a different buffer layout. (Buffer layouts are used when attribute values\n// within a buffer should be grouped for drawElements, like the Polygon layer.) For example, a\n// buffer layout of [3, 4] might have data [A1, A2, A3, B1, B2, B3, B4]. If it needs to transition\n// to a buffer layout of [4, 2], it should produce a buffer, using the transition setting's `enter`\n// function, that looks like this: [A1, A2, A3, A4 (user `enter` fn), B1, B2, 0]. Note: the final\n// 0 in this buffer is because we never shrink buffers, only grow them, for performance reasons.\n//\n// padBuffer may return either the original buffer, or a new buffer if the size of the original\n// was insufficient. Callers are responsible for disposing of the original buffer if needed.\nexport function padBuffer({\n  device,\n  buffer,\n  attribute,\n  fromLength,\n  toLength,\n  fromStartIndices,\n  getData = x => x\n}: {\n  device: Device;\n  buffer?: Buffer;\n  attribute: Attribute;\n  fromLength: number;\n  toLength: number;\n  fromStartIndices?: NumericArray | null;\n  getData?: (toValue: NumericArray, chunk?: NumericArray) => NumericArray;\n}): Buffer {\n  // TODO: move the precisionMultiplier logic to the attribute when retrieving\n  // its `size` and `elementOffset`?\n  const precisionMultiplier =\n    attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;\n  const size = attribute.size * precisionMultiplier;\n  const byteOffset = attribute.byteOffset;\n  // Transform feedback can only write to float varyings\n  // Attributes of format unorm8/uint8 (1 byte per element) etc will be padded to float32 (4 bytes per element)\n  const targetByteOffset =\n    attribute.settings.bytesPerElement < 4\n      ? (byteOffset / attribute.settings.bytesPerElement) * 4\n      : byteOffset;\n  const toStartIndices = attribute.startIndices;\n  const hasStartIndices = fromStartIndices && toStartIndices;\n  const isConstant = attribute.isConstant;\n\n  // check if buffer needs to be padded\n  if (!hasStartIndices && buffer && fromLength >= toLength) {\n    return buffer;\n  }\n\n  const ArrayType =\n    attribute.value instanceof Float64Array\n      ? Float32Array\n      : ((attribute.value as TypedArray).constructor as TypedArrayConstructor);\n  const toData = isConstant\n    ? (attribute.value as TypedArray)\n    : // TODO(v9.1): Avoid non-portable synchronous reads.\n      new ArrayType(\n        attribute\n          .getBuffer()!\n          .readSyncWebGL(byteOffset, toLength * ArrayType.BYTES_PER_ELEMENT).buffer\n      );\n  if (attribute.settings.normalized && !isConstant) {\n    const getter = getData;\n    getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));\n  }\n\n  const getMissingData = isConstant\n    ? (i: number, chunk: NumericArray) => getData(toData, chunk)\n    : (i: number, chunk: NumericArray) =>\n        getData(toData.subarray(i + byteOffset, i + byteOffset + size), chunk);\n\n  // TODO(v9.1): Avoid non-portable synchronous reads.\n  const source = buffer\n    ? new Float32Array(buffer.readSyncWebGL(targetByteOffset, fromLength * 4).buffer)\n    : new Float32Array(0);\n  const target = new Float32Array(toLength);\n  padArray({\n    source,\n    target,\n    sourceStartIndices: fromStartIndices,\n    targetStartIndices: toStartIndices,\n    size,\n    getData: getMissingData\n  });\n\n  if (!buffer || buffer.byteLength < target.byteLength + targetByteOffset) {\n    buffer?.destroy();\n    buffer = device.createBuffer({\n      byteLength: target.byteLength + targetByteOffset,\n      usage: GL.DYNAMIC_COPY\n    });\n  }\n  buffer.write(target, targetByteOffset);\n  return buffer;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}