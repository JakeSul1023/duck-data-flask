{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { GL } from '@luma.gl/constants';\nimport { decodeGLUniformType, decodeGLAttributeType, isSamplerUniform } from \"./decode-webgl-types.js\";\n/**\n * Extract metadata describing binding information for a program's shaders\n * Note: `linkProgram()` needs to have been called\n * (although linking does not need to have been successful).\n */\nexport function getShaderLayoutFromGLSL(gl, program) {\n  const shaderLayout = {\n    attributes: [],\n    bindings: []\n  };\n  shaderLayout.attributes = readAttributeDeclarations(gl, program);\n  // Uniform blocks\n  const uniformBlocks = readUniformBlocks(gl, program);\n  for (const uniformBlock of uniformBlocks) {\n    const uniforms = uniformBlock.uniforms.map(uniform => ({\n      name: uniform.name,\n      format: uniform.format,\n      byteOffset: uniform.byteOffset,\n      byteStride: uniform.byteStride,\n      arrayLength: uniform.arrayLength\n    }));\n    shaderLayout.bindings.push({\n      type: 'uniform',\n      name: uniformBlock.name,\n      group: 0,\n      location: uniformBlock.location,\n      visibility: (uniformBlock.vertex ? 0x1 : 0) & (uniformBlock.fragment ? 0x2 : 0),\n      minBindingSize: uniformBlock.byteLength,\n      uniforms\n    });\n  }\n  const uniforms = readUniformBindings(gl, program);\n  let textureUnit = 0;\n  for (const uniform of uniforms) {\n    if (isSamplerUniform(uniform.type)) {\n      const {\n        viewDimension,\n        sampleType\n      } = getSamplerInfo(uniform.type);\n      shaderLayout.bindings.push({\n        type: 'texture',\n        name: uniform.name,\n        group: 0,\n        location: textureUnit,\n        viewDimension,\n        sampleType\n      });\n      // @ts-expect-error\n      uniform.textureUnit = textureUnit;\n      textureUnit += 1;\n    }\n  }\n  if (uniforms.length) {\n    shaderLayout.uniforms = uniforms;\n  }\n  // Varyings\n  const varyings = readVaryings(gl, program);\n  // Note - samplers are always in unform bindings, even if uniform blocks are used\n  if (varyings?.length) {\n    shaderLayout.varyings = varyings;\n  }\n  return shaderLayout;\n}\n// HELPERS\n/**\n * Extract info about all transform feedback varyings\n *\n * linkProgram needs to have been called, although linking does not need to have been successful\n */\nfunction readAttributeDeclarations(gl, program) {\n  const attributes = [];\n  const count = gl.getProgramParameter(program, 35721);\n  for (let index = 0; index < count; index++) {\n    const activeInfo = gl.getActiveAttrib(program, index);\n    if (!activeInfo) {\n      throw new Error('activeInfo');\n    }\n    const {\n      name,\n      type: compositeType /* , size*/\n    } = activeInfo;\n    const location = gl.getAttribLocation(program, name);\n    // Add only user provided attributes, for built-in attributes like `gl_InstanceID` location will be < 0\n    if (location >= 0) {\n      const {\n        attributeType\n      } = decodeGLAttributeType(compositeType);\n      // Whether an attribute is instanced is essentially fixed by the structure of the shader code,\n      // so it is arguably a static property of the shader.\n      // There is no hint in the shader declarations\n      // Heuristic: Any attribute name containing the word \"instance\" will be assumed to be instanced\n      const stepMode = /instance/i.test(name) ? 'instance' : 'vertex';\n      attributes.push({\n        name,\n        location,\n        stepMode,\n        type: attributeType\n        // size - for arrays, size is the number of elements in the array\n      });\n    }\n  }\n  // Sort by declaration order\n  attributes.sort((a, b) => a.location - b.location);\n  return attributes;\n}\n/**\n * Extract info about all transform feedback varyings\n *\n * linkProgram needs to have been called, although linking does not need to have been successful\n */\nfunction readVaryings(gl, program) {\n  const varyings = [];\n  const count = gl.getProgramParameter(program, 35971);\n  for (let location = 0; location < count; location++) {\n    const activeInfo = gl.getTransformFeedbackVarying(program, location);\n    if (!activeInfo) {\n      throw new Error('activeInfo');\n    }\n    const {\n      name,\n      type: compositeType,\n      size\n    } = activeInfo;\n    const {\n      glType,\n      components\n    } = decodeGLUniformType(compositeType);\n    const varying = {\n      location,\n      name,\n      type: glType,\n      size: size * components\n    }; // Base values\n    varyings.push(varying);\n  }\n  varyings.sort((a, b) => a.location - b.location);\n  return varyings;\n}\n/**\n * Extract info about all uniforms\n *\n * Query uniform locations and build name to setter map.\n */\nfunction readUniformBindings(gl, program) {\n  const uniforms = [];\n  const uniformCount = gl.getProgramParameter(program, 35718);\n  for (let i = 0; i < uniformCount; i++) {\n    const activeInfo = gl.getActiveUniform(program, i);\n    if (!activeInfo) {\n      throw new Error('activeInfo');\n    }\n    const {\n      name: rawName,\n      size,\n      type\n    } = activeInfo;\n    const {\n      name,\n      isArray\n    } = parseUniformName(rawName);\n    let webglLocation = gl.getUniformLocation(program, name);\n    const uniformInfo = {\n      // WebGL locations are uniquely typed but just numbers\n      location: webglLocation,\n      name,\n      size,\n      type,\n      isArray\n    };\n    uniforms.push(uniformInfo);\n    // Array (e.g. matrix) uniforms can occupy several 4x4 byte banks\n    if (uniformInfo.size > 1) {\n      for (let j = 0; j < uniformInfo.size; j++) {\n        const elementName = `${name}[${j}]`;\n        webglLocation = gl.getUniformLocation(program, elementName);\n        const arrayElementUniformInfo = {\n          ...uniformInfo,\n          name: elementName,\n          location: webglLocation\n        };\n        uniforms.push(arrayElementUniformInfo);\n      }\n    }\n  }\n  return uniforms;\n}\n/**\n * Extract info about all \"active\" uniform blocks\n * @note In WebGL, \"active\" just means that unused (inactive) blocks may have been optimized away during linking)\n */\nfunction readUniformBlocks(gl, program) {\n  const getBlockParameter = (blockIndex, pname) => gl.getActiveUniformBlockParameter(program, blockIndex, pname);\n  const uniformBlocks = [];\n  const blockCount = gl.getProgramParameter(program, 35382);\n  for (let blockIndex = 0; blockIndex < blockCount; blockIndex++) {\n    const blockInfo = {\n      name: gl.getActiveUniformBlockName(program, blockIndex) || '',\n      location: getBlockParameter(blockIndex, 35391),\n      byteLength: getBlockParameter(blockIndex, 35392),\n      vertex: getBlockParameter(blockIndex, 35396),\n      fragment: getBlockParameter(blockIndex, 35398),\n      uniformCount: getBlockParameter(blockIndex, 35394),\n      uniforms: []\n    };\n    const uniformIndices = getBlockParameter(blockIndex, 35395) || [];\n    const uniformType = gl.getActiveUniforms(program, uniformIndices, 35383); // Array of GLenum indicating the types of the uniforms.\n    const uniformArrayLength = gl.getActiveUniforms(program, uniformIndices, 35384); // Array of GLuint indicating the sizes of the uniforms.\n    // const uniformBlockIndex = gl.getActiveUniforms(\n    //   program,\n    //   uniformIndices,\n    //   GL.UNIFORM_BLOCK_INDEX\n    // ); // Array of GLint indicating the block indices of the uniforms.\n    const uniformOffset = gl.getActiveUniforms(program, uniformIndices, 35387); // Array of GLint indicating the uniform buffer offsets.\n    const uniformStride = gl.getActiveUniforms(program, uniformIndices, 35388); // Array of GLint indicating the strides between the elements.\n    // const uniformMatrixStride = gl.getActiveUniforms(\n    //   program,\n    //   uniformIndices,\n    //   GL.UNIFORM_MATRIX_STRIDE\n    // ); // Array of GLint indicating the strides between columns of a column-major matrix or a row-major matrix.\n    // const uniformRowMajor = gl.getActiveUniforms(program, uniformIndices, GL.UNIFORM_IS_ROW_MAJOR);\n    for (let i = 0; i < blockInfo.uniformCount; ++i) {\n      const activeInfo = gl.getActiveUniform(program, uniformIndices[i]);\n      if (!activeInfo) {\n        throw new Error('activeInfo');\n      }\n      blockInfo.uniforms.push({\n        name: activeInfo.name,\n        format: decodeGLUniformType(uniformType[i]).format,\n        type: uniformType[i],\n        arrayLength: uniformArrayLength[i],\n        byteOffset: uniformOffset[i],\n        byteStride: uniformStride[i]\n        // matrixStride: uniformStride[i],\n        // rowMajor: uniformRowMajor[i]\n      });\n    }\n    uniformBlocks.push(blockInfo);\n  }\n  uniformBlocks.sort((a, b) => a.location - b.location);\n  return uniformBlocks;\n}\n/**\n * TOOD - compare with a above, confirm copy, then delete\n  const bindings: Binding[] = [];\n  const count = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);\n  for (let blockIndex = 0; blockIndex < count; blockIndex++) {\n    const vertex = gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),\n    const fragment = gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),\n    const visibility = (vertex) + (fragment);\n    const binding: BufferBinding = {\n      location: gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_BINDING),\n      // name: gl.getActiveUniformBlockName(program, blockIndex),\n      type: 'uniform',\n      visibility,\n      minBindingSize: gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_DATA_SIZE),\n      // uniformCount: gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_ACTIVE_UNIFORMS),\n      // uniformIndices: gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES),\n    }\n    bindings.push(binding);\n  }\n*/\nconst SAMPLER_UNIFORMS_GL_TO_GPU = {\n  [35678]: ['2d', 'float'],\n  [35680]: ['cube', 'float'],\n  [35679]: ['3d', 'float'],\n  [35682]: ['3d', 'depth'],\n  [36289]: ['2d-array', 'float'],\n  [36292]: ['2d-array', 'depth'],\n  [36293]: ['cube', 'float'],\n  [36298]: ['2d', 'sint'],\n  [36299]: ['3d', 'sint'],\n  [36300]: ['cube', 'sint'],\n  [36303]: ['2d-array', 'uint'],\n  [36306]: ['2d', 'uint'],\n  [36307]: ['3d', 'uint'],\n  [36308]: ['cube', 'uint'],\n  [36311]: ['2d-array', 'uint']\n};\nfunction getSamplerInfo(type) {\n  const sampler = SAMPLER_UNIFORMS_GL_TO_GPU[type];\n  if (!sampler) {\n    throw new Error('sampler');\n  }\n  const [viewDimension, sampleType] = sampler;\n  return {\n    viewDimension,\n    sampleType\n  };\n}\n// HELPERS\nfunction parseUniformName(name) {\n  // Shortcut to avoid redundant or bad matches\n  if (name[name.length - 1] !== ']') {\n    return {\n      name,\n      length: 1,\n      isArray: false\n    };\n  }\n  // if array name then clean the array brackets\n  const UNIFORM_NAME_REGEXP = /([^[]*)(\\[[0-9]+\\])?/;\n  const matches = UNIFORM_NAME_REGEXP.exec(name);\n  if (!matches || matches.length < 2) {\n    throw new Error(`Failed to parse GLSL uniform name ${name}`);\n  }\n  return {\n    name: matches[1],\n    length: matches[2] ? 1 : 0,\n    isArray: Boolean(matches[2])\n  };\n}\n//# sourceMappingURL=get-shader-layout.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}