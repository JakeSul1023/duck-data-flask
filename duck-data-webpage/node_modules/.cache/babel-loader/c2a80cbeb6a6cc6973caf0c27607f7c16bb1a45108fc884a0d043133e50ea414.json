{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n/* eslint-disable */\nimport { Vector3, _MathUtils } from '@math.gl/core';\nconst scratchVector = new Vector3();\nconst scaleToGeodeticSurfaceIntersection = new Vector3();\nconst scaleToGeodeticSurfaceGradient = new Vector3();\n// Scales the provided Cartesian position along the geodetic surface normal\n// so that it is on the surface of this ellipsoid.  If the position is\n// at the center of the ellipsoid, this function returns undefined.\nexport function scaleToGeodeticSurface(cartesian, ellipsoid) {\n  let result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const {\n    oneOverRadii,\n    oneOverRadiiSquared,\n    centerToleranceSquared\n  } = ellipsoid;\n  scratchVector.from(cartesian);\n  const positionX = scratchVector.x;\n  const positionY = scratchVector.y;\n  const positionZ = scratchVector.z;\n  const oneOverRadiiX = oneOverRadii.x;\n  const oneOverRadiiY = oneOverRadii.y;\n  const oneOverRadiiZ = oneOverRadii.z;\n  const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n  const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n  const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n  // Compute the squared ellipsoid norm.\n  const squaredNorm = x2 + y2 + z2;\n  const ratio = Math.sqrt(1.0 / squaredNorm);\n  // When very close to center or at center\n  if (!Number.isFinite(ratio)) {\n    return undefined;\n  }\n  // As an initial approximation, assume that the radial intersection is the projection point.\n  const intersection = scaleToGeodeticSurfaceIntersection;\n  intersection.copy(cartesian).scale(ratio);\n  // If the position is near the center, the iteration will not converge.\n  if (squaredNorm < centerToleranceSquared) {\n    return intersection.to(result);\n  }\n  const oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n  const oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n  const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n  // Use the gradient at the intersection point in place of the true unit normal.\n  // The difference in magnitude will be absorbed in the multiplier.\n  const gradient = scaleToGeodeticSurfaceGradient;\n  gradient.set(intersection.x * oneOverRadiiSquaredX * 2.0, intersection.y * oneOverRadiiSquaredY * 2.0, intersection.z * oneOverRadiiSquaredZ * 2.0);\n  // Compute the initial guess at the normal vector multiplier, lambda.\n  let lambda = (1.0 - ratio) * scratchVector.len() / (0.5 * gradient.len());\n  let correction = 0.0;\n  let xMultiplier;\n  let yMultiplier;\n  let zMultiplier;\n  let func;\n  do {\n    lambda -= correction;\n    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n    const xMultiplier2 = xMultiplier * xMultiplier;\n    const yMultiplier2 = yMultiplier * yMultiplier;\n    const zMultiplier2 = zMultiplier * zMultiplier;\n    const xMultiplier3 = xMultiplier2 * xMultiplier;\n    const yMultiplier3 = yMultiplier2 * yMultiplier;\n    const zMultiplier3 = zMultiplier2 * zMultiplier;\n    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n    // \"denominator\" here refers to the use of this expression in the velocity and acceleration\n    // computations in the sections to follow.\n    const denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n    const derivative = -2.0 * denominator;\n    correction = func / derivative;\n  } while (Math.abs(func) > _MathUtils.EPSILON12);\n  return scratchVector.scale([xMultiplier, yMultiplier, zMultiplier]).to(result);\n}\n//# sourceMappingURL=scale-to-geodetic-surface.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}