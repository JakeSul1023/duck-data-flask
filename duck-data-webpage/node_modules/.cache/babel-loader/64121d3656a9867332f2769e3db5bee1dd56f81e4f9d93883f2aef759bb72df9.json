{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBrowser } from '@loaders.gl/loader-utils';\nconst MIME_TYPES = ['image/png', 'image/jpeg', 'image/gif', 'image/webp', 'image/avif', 'image/tiff',\n// TODO - what is the correct type for SVG\n'image/svg', 'image/svg+xml', 'image/bmp', 'image/vnd.microsoft.icon'];\n/** Only one round of tests is performed */\nconst mimeTypeSupportedPromise = null;\n/** Run-time browser detection of file formats requires async tests for most precise results */\nexport async function getSupportedImageFormats() {\n  if (mimeTypeSupportedPromise) {\n    return await mimeTypeSupportedPromise;\n  }\n  const supportedMimeTypes = new Set();\n  for (const mimeType of MIME_TYPES) {\n    const supported = isBrowser ? await checkBrowserImageFormatSupportAsync(mimeType) : checkNodeImageFormatSupport(mimeType);\n    if (supported) {\n      supportedMimeTypes.add(mimeType);\n    }\n  }\n  return supportedMimeTypes;\n}\n/** Cache sync values for speed */\nconst mimeTypeSupportedSync = {};\n/**\n * Check if image MIME type is supported. Result is cached to avoid repeated tests.\n */\nexport function isImageFormatSupported(mimeType) {\n  if (mimeTypeSupportedSync[mimeType] === undefined) {\n    const supported = isBrowser ? checkBrowserImageFormatSupport(mimeType) : checkNodeImageFormatSupport(mimeType);\n    mimeTypeSupportedSync[mimeType] = supported;\n  }\n  return mimeTypeSupportedSync[mimeType];\n}\n/**\n * Checks that polyfills are installed and that mimeType is supported by polyfills\n * @todo Ideally polyfills should declare what formats they support, instead of storing that data here.\n */\nfunction checkNodeImageFormatSupport(mimeType) {\n  const NODE_FORMAT_SUPPORT = ['image/png', 'image/jpeg', 'image/gif'];\n  const imageFormatsNode = globalThis.loaders?.imageFormatsNode || NODE_FORMAT_SUPPORT;\n  const parseImageNode = globalThis.loaders?.parseImageNode;\n  return Boolean(parseImageNode) && imageFormatsNode.includes(mimeType);\n}\n/** Checks image format support synchronously.\n * @note Unreliable, fails on AVIF\n */\nfunction checkBrowserImageFormatSupport(mimeType) {\n  switch (mimeType) {\n    case 'image/avif': // Will fail\n    case 'image/webp':\n      return testBrowserImageFormatSupport(mimeType);\n    default:\n      return true;\n  }\n}\nconst TEST_IMAGE = {\n  'image/avif': 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=',\n  // Lossy test image. Support for lossy images doesn't guarantee support for all WebP images.\n  'image/webp': 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'\n};\n/** Checks WebP and AVIF support asynchronously */\nasync function checkBrowserImageFormatSupportAsync(mimeType) {\n  const dataURL = TEST_IMAGE[mimeType];\n  return dataURL ? await testBrowserImageFormatSupportAsync(dataURL) : true;\n}\n/**\n * Checks browser synchronously\n * Checks if toDataURL supports the mimeType.\n * @note Imperfect testOn Chrome this is true for WebP but not for AVIF\n */\nfunction testBrowserImageFormatSupport(mimeType) {\n  try {\n    const element = document.createElement('canvas');\n    const dataURL = element.toDataURL(mimeType);\n    return dataURL.indexOf(`data:${mimeType}`) === 0;\n  } catch {\n    // Probably Safari...\n    return false;\n  }\n}\n// Check WebPSupport asynchronously\nasync function testBrowserImageFormatSupportAsync(testImageDataURL) {\n  return new Promise(resolve => {\n    const image = new Image();\n    image.src = testImageDataURL;\n    image.onload = () => resolve(image.height > 0);\n    image.onerror = () => resolve(false);\n  });\n}","map":{"version":3,"names":["isBrowser","MIME_TYPES","mimeTypeSupportedPromise","getSupportedImageFormats","supportedMimeTypes","Set","mimeType","supported","checkBrowserImageFormatSupportAsync","checkNodeImageFormatSupport","add","mimeTypeSupportedSync","isImageFormatSupported","undefined","checkBrowserImageFormatSupport","NODE_FORMAT_SUPPORT","imageFormatsNode","globalThis","loaders","parseImageNode","Boolean","includes","testBrowserImageFormatSupport","TEST_IMAGE","dataURL","testBrowserImageFormatSupportAsync","element","document","createElement","toDataURL","indexOf","testImageDataURL","Promise","resolve","image","Image","src","onload","height","onerror"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/images/dist/lib/category-api/image-format.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBrowser } from '@loaders.gl/loader-utils';\nconst MIME_TYPES = [\n    'image/png',\n    'image/jpeg',\n    'image/gif',\n    'image/webp',\n    'image/avif',\n    'image/tiff',\n    // TODO - what is the correct type for SVG\n    'image/svg',\n    'image/svg+xml',\n    'image/bmp',\n    'image/vnd.microsoft.icon'\n];\n/** Only one round of tests is performed */\nconst mimeTypeSupportedPromise = null;\n/** Run-time browser detection of file formats requires async tests for most precise results */\nexport async function getSupportedImageFormats() {\n    if (mimeTypeSupportedPromise) {\n        return await mimeTypeSupportedPromise;\n    }\n    const supportedMimeTypes = new Set();\n    for (const mimeType of MIME_TYPES) {\n        const supported = isBrowser\n            ? await checkBrowserImageFormatSupportAsync(mimeType)\n            : checkNodeImageFormatSupport(mimeType);\n        if (supported) {\n            supportedMimeTypes.add(mimeType);\n        }\n    }\n    return supportedMimeTypes;\n}\n/** Cache sync values for speed */\nconst mimeTypeSupportedSync = {};\n/**\n * Check if image MIME type is supported. Result is cached to avoid repeated tests.\n */\nexport function isImageFormatSupported(mimeType) {\n    if (mimeTypeSupportedSync[mimeType] === undefined) {\n        const supported = isBrowser\n            ? checkBrowserImageFormatSupport(mimeType)\n            : checkNodeImageFormatSupport(mimeType);\n        mimeTypeSupportedSync[mimeType] = supported;\n    }\n    return mimeTypeSupportedSync[mimeType];\n}\n/**\n * Checks that polyfills are installed and that mimeType is supported by polyfills\n * @todo Ideally polyfills should declare what formats they support, instead of storing that data here.\n */\nfunction checkNodeImageFormatSupport(mimeType) {\n    const NODE_FORMAT_SUPPORT = ['image/png', 'image/jpeg', 'image/gif'];\n    const imageFormatsNode = globalThis.loaders?.imageFormatsNode || NODE_FORMAT_SUPPORT;\n    const parseImageNode = globalThis.loaders?.parseImageNode;\n    return Boolean(parseImageNode) && imageFormatsNode.includes(mimeType);\n}\n/** Checks image format support synchronously.\n * @note Unreliable, fails on AVIF\n */\nfunction checkBrowserImageFormatSupport(mimeType) {\n    switch (mimeType) {\n        case 'image/avif': // Will fail\n        case 'image/webp':\n            return testBrowserImageFormatSupport(mimeType);\n        default:\n            return true;\n    }\n}\nconst TEST_IMAGE = {\n    'image/avif': 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=',\n    // Lossy test image. Support for lossy images doesn't guarantee support for all WebP images.\n    'image/webp': 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'\n};\n/** Checks WebP and AVIF support asynchronously */\nasync function checkBrowserImageFormatSupportAsync(mimeType) {\n    const dataURL = TEST_IMAGE[mimeType];\n    return dataURL ? await testBrowserImageFormatSupportAsync(dataURL) : true;\n}\n/**\n * Checks browser synchronously\n * Checks if toDataURL supports the mimeType.\n * @note Imperfect testOn Chrome this is true for WebP but not for AVIF\n */\nfunction testBrowserImageFormatSupport(mimeType) {\n    try {\n        const element = document.createElement('canvas');\n        const dataURL = element.toDataURL(mimeType);\n        return dataURL.indexOf(`data:${mimeType}`) === 0;\n    }\n    catch {\n        // Probably Safari...\n        return false;\n    }\n}\n// Check WebPSupport asynchronously\nasync function testBrowserImageFormatSupportAsync(testImageDataURL) {\n    return new Promise((resolve) => {\n        const image = new Image();\n        image.src = testImageDataURL;\n        image.onload = () => resolve(image.height > 0);\n        image.onerror = () => resolve(false);\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}