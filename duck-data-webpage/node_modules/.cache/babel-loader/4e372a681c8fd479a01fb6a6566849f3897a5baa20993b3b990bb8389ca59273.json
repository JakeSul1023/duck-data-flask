{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@deck.gl/core';\nimport { terrainModule } from \"./shader-module.js\";\nimport { TerrainCover } from \"./terrain-cover.js\";\nimport { TerrainPass } from \"./terrain-pass.js\";\nimport { TerrainPickingPass } from \"./terrain-picking-pass.js\";\nimport { HeightMapBuilder } from \"./height-map-builder.js\";\n/** Class to manage terrain effect */\nexport class TerrainEffect {\n  constructor() {\n    this.id = 'terrain-effect';\n    this.props = null;\n    this.useInPicking = true;\n    /** true if picking in the current pass */\n    this.isPicking = false;\n    /** true if should use in the current pass */\n    this.isDrapingEnabled = false;\n    /** One texture for each primitive terrain layer, into which the draped layers render */\n    this.terrainCovers = new Map();\n  }\n  setup(_ref) {\n    let {\n      device,\n      deck\n    } = _ref;\n    this.dummyHeightMap = device.createTexture({\n      width: 1,\n      height: 1,\n      data: new Uint8Array([0, 0, 0, 0])\n    });\n    this.terrainPass = new TerrainPass(device, {\n      id: 'terrain'\n    });\n    this.terrainPickingPass = new TerrainPickingPass(device, {\n      id: 'terrain-picking'\n    });\n    if (HeightMapBuilder.isSupported(device)) {\n      this.heightMap = new HeightMapBuilder(device);\n    } else {\n      log.warn('Terrain offset mode is not supported by this browser')();\n    }\n    deck._addDefaultShaderModule(terrainModule);\n  }\n  preRender(opts) {\n    // @ts-expect-error pickZ only defined in picking pass\n    if (opts.pickZ) {\n      // Do not update if picking attributes\n      this.isDrapingEnabled = false;\n      return;\n    }\n    const {\n      viewports\n    } = opts;\n    const isPicking = opts.pass.startsWith('picking');\n    this.isPicking = isPicking;\n    this.isDrapingEnabled = true;\n    // TODO - support multiple views?\n    const viewport = viewports[0];\n    const layers = (isPicking ? this.terrainPickingPass : this.terrainPass).getRenderableLayers(viewport, opts);\n    const terrainLayers = layers.filter(l => l.props.operation.includes('terrain'));\n    if (terrainLayers.length === 0) {\n      return;\n    }\n    if (!isPicking) {\n      const offsetLayers = layers.filter(l => l.state.terrainDrawMode === 'offset');\n      if (offsetLayers.length > 0) {\n        this._updateHeightMap(terrainLayers, viewport, opts);\n      }\n    }\n    const drapeLayers = layers.filter(l => l.state.terrainDrawMode === 'drape');\n    this._updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts);\n  }\n  getShaderModuleProps(layer, otherShaderModuleProps) {\n    const {\n      terrainDrawMode\n    } = layer.state;\n    return {\n      terrain: {\n        project: otherShaderModuleProps.project,\n        isPicking: this.isPicking,\n        heightMap: this.heightMap?.getRenderFramebuffer()?.colorAttachments[0].texture || null,\n        heightMapBounds: this.heightMap?.bounds,\n        dummyHeightMap: this.dummyHeightMap,\n        terrainCover: this.isDrapingEnabled ? this.terrainCovers.get(layer.id) : null,\n        useTerrainHeightMap: terrainDrawMode === 'offset',\n        terrainSkipRender: terrainDrawMode === 'drape' || !layer.props.operation.includes('draw')\n      }\n    };\n  }\n  cleanup(_ref2) {\n    let {\n      deck\n    } = _ref2;\n    if (this.dummyHeightMap) {\n      this.dummyHeightMap.delete();\n      this.dummyHeightMap = undefined;\n    }\n    if (this.heightMap) {\n      this.heightMap.delete();\n      this.heightMap = undefined;\n    }\n    for (const terrainCover of this.terrainCovers.values()) {\n      terrainCover.delete();\n    }\n    this.terrainCovers.clear();\n    deck._removeDefaultShaderModule(terrainModule);\n  }\n  _updateHeightMap(terrainLayers, viewport, opts) {\n    if (!this.heightMap) {\n      // Not supported\n      return;\n    }\n    const shouldUpdate = this.heightMap.shouldUpdate({\n      layers: terrainLayers,\n      viewport\n    });\n    if (!shouldUpdate) {\n      return;\n    }\n    this.terrainPass.renderHeightMap(this.heightMap, {\n      ...opts,\n      layers: terrainLayers,\n      shaderModuleProps: {\n        terrain: {\n          heightMapBounds: this.heightMap.bounds,\n          dummyHeightMap: this.dummyHeightMap,\n          drawToTerrainHeightMap: true\n        },\n        project: {\n          devicePixelRatio: 1\n        }\n      }\n    });\n  }\n  _updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts) {\n    // Mark a terrain cover as dirty if one of the drape layers needs redraw\n    const layerNeedsRedraw = {};\n    for (const layer of drapeLayers) {\n      if (layer.state.terrainCoverNeedsRedraw) {\n        layerNeedsRedraw[layer.id] = true;\n        layer.state.terrainCoverNeedsRedraw = false;\n      }\n    }\n    for (const terrainCover of this.terrainCovers.values()) {\n      terrainCover.isDirty = terrainCover.isDirty || terrainCover.shouldUpdate({\n        layerNeedsRedraw\n      });\n    }\n    for (const layer of terrainLayers) {\n      this._updateTerrainCover(layer, drapeLayers, viewport, opts);\n    }\n    if (!this.isPicking) {\n      this._pruneTerrainCovers();\n    }\n  }\n  _updateTerrainCover(terrainLayer, drapeLayers, viewport, opts) {\n    const renderPass = this.isPicking ? this.terrainPickingPass : this.terrainPass;\n    let terrainCover = this.terrainCovers.get(terrainLayer.id);\n    if (!terrainCover) {\n      terrainCover = new TerrainCover(terrainLayer);\n      this.terrainCovers.set(terrainLayer.id, terrainCover);\n    }\n    try {\n      const isDirty = terrainCover.shouldUpdate({\n        targetLayer: terrainLayer,\n        viewport,\n        layers: drapeLayers\n      });\n      if (this.isPicking || terrainCover.isDirty || isDirty) {\n        renderPass.renderTerrainCover(terrainCover, {\n          ...opts,\n          layers: drapeLayers,\n          shaderModuleProps: {\n            terrain: {\n              dummyHeightMap: this.dummyHeightMap,\n              terrainSkipRender: false\n            },\n            project: {\n              devicePixelRatio: 1\n            }\n          }\n        });\n        if (!this.isPicking) {\n          // IsDirty refers to the normal fbo, not the picking fbo.\n          // Only mark it as not dirty if the normal fbo was updated.\n          terrainCover.isDirty = false;\n        }\n      }\n    } catch (err) {\n      terrainLayer.raiseError(err, `Error rendering terrain cover ${terrainCover.id}`);\n    }\n  }\n  _pruneTerrainCovers() {\n    /** Prune the cache, remove textures for layers that have been removed */\n    const idsToRemove = [];\n    for (const [id, terrainCover] of this.terrainCovers) {\n      if (!terrainCover.isActive) {\n        idsToRemove.push(id);\n      }\n    }\n    for (const id of idsToRemove) {\n      this.terrainCovers.delete(id);\n    }\n  }\n}\n//# sourceMappingURL=terrain-effect.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}