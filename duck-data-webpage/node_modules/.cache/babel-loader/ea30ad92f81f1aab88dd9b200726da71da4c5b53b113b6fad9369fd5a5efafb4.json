{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Vector3, Matrix3 } from '@math.gl/core';\nimport { computeEigenDecomposition } from \"./compute-eigen-decomposition.js\";\nimport { OrientedBoundingBox } from \"../bounding-volumes/oriented-bounding-box.js\";\nimport { AxisAlignedBoundingBox } from \"../bounding-volumes/axis-aligned-bounding-box.js\";\nconst scratchVector2 = new Vector3();\nconst scratchVector3 = new Vector3();\nconst scratchVector4 = new Vector3();\nconst scratchVector5 = new Vector3();\nconst scratchVector6 = new Vector3();\nconst scratchCovarianceResult = new Matrix3();\nconst scratchEigenResult = {\n  diagonal: new Matrix3(),\n  unitary: new Matrix3()\n};\n/**\n * Computes an instance of an OrientedBoundingBox of the given positions.\n *\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\n */\n/* eslint-disable max-statements */\nexport function makeOrientedBoundingBoxFromPoints(positions, result = new OrientedBoundingBox()) {\n  if (!positions || positions.length === 0) {\n    result.halfAxes = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    result.center = new Vector3();\n    return result;\n  }\n  const length = positions.length;\n  const meanPoint = new Vector3(0, 0, 0);\n  for (const position of positions) {\n    meanPoint.add(position);\n  }\n  const invLength = 1.0 / length;\n  meanPoint.multiplyByScalar(invLength);\n  let exx = 0.0;\n  let exy = 0.0;\n  let exz = 0.0;\n  let eyy = 0.0;\n  let eyz = 0.0;\n  let ezz = 0.0;\n  for (const position of positions) {\n    const p = scratchVector2.copy(position).subtract(meanPoint);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n  const covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n  const {\n    unitary\n  } = computeEigenDecomposition(covarianceMatrix, scratchEigenResult);\n  const rotation = result.halfAxes.copy(unitary);\n  let v1 = rotation.getColumn(0, scratchVector4);\n  let v2 = rotation.getColumn(1, scratchVector5);\n  let v3 = rotation.getColumn(2, scratchVector6);\n  let u1 = -Number.MAX_VALUE;\n  let u2 = -Number.MAX_VALUE;\n  let u3 = -Number.MAX_VALUE;\n  let l1 = Number.MAX_VALUE;\n  let l2 = Number.MAX_VALUE;\n  let l3 = Number.MAX_VALUE;\n  for (const position of positions) {\n    scratchVector2.copy(position);\n    u1 = Math.max(scratchVector2.dot(v1), u1);\n    u2 = Math.max(scratchVector2.dot(v2), u2);\n    u3 = Math.max(scratchVector2.dot(v3), u3);\n    l1 = Math.min(scratchVector2.dot(v1), l1);\n    l2 = Math.min(scratchVector2.dot(v2), l2);\n    l3 = Math.min(scratchVector2.dot(v3), l3);\n  }\n  v1 = v1.multiplyByScalar(0.5 * (l1 + u1));\n  v2 = v2.multiplyByScalar(0.5 * (l2 + u2));\n  v3 = v3.multiplyByScalar(0.5 * (l3 + u3));\n  result.center.copy(v1).add(v2).add(v3);\n  const scale = scratchVector3.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);\n  const scaleMatrix = new Matrix3([scale[0], 0, 0, 0, scale[1], 0, 0, 0, scale[2]]);\n  result.halfAxes.multiplyRight(scaleMatrix);\n  return result;\n}\n/**\n * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\n * finding the points spaced the farthest apart on the x, y, and z axes.\n */\nexport function makeAxisAlignedBoundingBoxFromPoints(positions, result = new AxisAlignedBoundingBox()) {\n  if (!positions || positions.length === 0) {\n    result.minimum.set(0, 0, 0);\n    result.maximum.set(0, 0, 0);\n    result.center.set(0, 0, 0);\n    result.halfDiagonal.set(0, 0, 0);\n    return result;\n  }\n  let minimumX = positions[0][0];\n  let minimumY = positions[0][1];\n  let minimumZ = positions[0][2];\n  let maximumX = positions[0][0];\n  let maximumY = positions[0][1];\n  let maximumZ = positions[0][2];\n  for (const p of positions) {\n    const x = p[0];\n    const y = p[1];\n    const z = p[2];\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n    minimumZ = Math.min(z, minimumZ);\n    maximumZ = Math.max(z, maximumZ);\n  }\n  result.minimum.set(minimumX, minimumY, minimumZ);\n  result.maximum.set(maximumX, maximumY, maximumZ);\n  result.center.copy(result.minimum).add(result.maximum).scale(0.5);\n  result.halfDiagonal.copy(result.maximum).subtract(result.center);\n  return result;\n}","map":{"version":3,"names":["Vector3","Matrix3","computeEigenDecomposition","OrientedBoundingBox","AxisAlignedBoundingBox","scratchVector2","scratchVector3","scratchVector4","scratchVector5","scratchVector6","scratchCovarianceResult","scratchEigenResult","diagonal","unitary","makeOrientedBoundingBoxFromPoints","positions","result","length","halfAxes","center","meanPoint","position","add","invLength","multiplyByScalar","exx","exy","exz","eyy","eyz","ezz","p","copy","subtract","x","y","z","covarianceMatrix","rotation","v1","getColumn","v2","v3","u1","Number","MAX_VALUE","u2","u3","l1","l2","l3","Math","max","dot","min","scale","set","scaleMatrix","multiplyRight","makeAxisAlignedBoundingBoxFromPoints","minimum","maximum","halfDiagonal","minimumX","minimumY","minimumZ","maximumX","maximumY","maximumZ"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\culling\\src\\lib\\algorithms\\bounding-box-from-points.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, Matrix3} from '@math.gl/core';\nimport {computeEigenDecomposition} from './compute-eigen-decomposition';\nimport {OrientedBoundingBox} from '../bounding-volumes/oriented-bounding-box';\nimport {AxisAlignedBoundingBox} from '../bounding-volumes/axis-aligned-bounding-box';\n\nconst scratchVector2 = new Vector3();\n\nconst scratchVector3 = new Vector3();\n\nconst scratchVector4 = new Vector3();\n\nconst scratchVector5 = new Vector3();\n\nconst scratchVector6 = new Vector3();\n\nconst scratchCovarianceResult = new Matrix3();\n\nconst scratchEigenResult = {\n  diagonal: new Matrix3(),\n  unitary: new Matrix3()\n};\n\n/**\n * Computes an instance of an OrientedBoundingBox of the given positions.\n *\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\n */\n/* eslint-disable max-statements */\nexport function makeOrientedBoundingBoxFromPoints(\n  positions: number[][],\n  result: OrientedBoundingBox = new OrientedBoundingBox()\n): OrientedBoundingBox {\n  if (!positions || positions.length === 0) {\n    result.halfAxes = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    result.center = new Vector3();\n    return result;\n  }\n\n  const length = positions.length;\n  const meanPoint = new Vector3(0, 0, 0);\n  for (const position of positions) {\n    meanPoint.add(position);\n  }\n  const invLength = 1.0 / length;\n  meanPoint.multiplyByScalar(invLength);\n\n  let exx = 0.0;\n  let exy = 0.0;\n  let exz = 0.0;\n  let eyy = 0.0;\n  let eyz = 0.0;\n  let ezz = 0.0;\n\n  for (const position of positions) {\n    const p = scratchVector2.copy(position).subtract(meanPoint);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n\n  const covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n\n  const {unitary} = computeEigenDecomposition(covarianceMatrix, scratchEigenResult);\n  const rotation = result.halfAxes.copy(unitary);\n\n  let v1 = rotation.getColumn(0, scratchVector4);\n  let v2 = rotation.getColumn(1, scratchVector5);\n  let v3 = rotation.getColumn(2, scratchVector6);\n\n  let u1 = -Number.MAX_VALUE;\n  let u2 = -Number.MAX_VALUE;\n  let u3 = -Number.MAX_VALUE;\n  let l1 = Number.MAX_VALUE;\n  let l2 = Number.MAX_VALUE;\n  let l3 = Number.MAX_VALUE;\n\n  for (const position of positions) {\n    scratchVector2.copy(position);\n\n    u1 = Math.max(scratchVector2.dot(v1), u1);\n    u2 = Math.max(scratchVector2.dot(v2), u2);\n    u3 = Math.max(scratchVector2.dot(v3), u3);\n\n    l1 = Math.min(scratchVector2.dot(v1), l1);\n    l2 = Math.min(scratchVector2.dot(v2), l2);\n    l3 = Math.min(scratchVector2.dot(v3), l3);\n  }\n\n  v1 = v1.multiplyByScalar(0.5 * (l1 + u1));\n  v2 = v2.multiplyByScalar(0.5 * (l2 + u2));\n  v3 = v3.multiplyByScalar(0.5 * (l3 + u3));\n\n  result.center.copy(v1).add(v2).add(v3);\n\n  const scale = scratchVector3.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);\n  const scaleMatrix = new Matrix3([scale[0], 0, 0, 0, scale[1], 0, 0, 0, scale[2]]);\n  result.halfAxes.multiplyRight(scaleMatrix);\n\n  return result;\n}\n\n/**\n * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\n * finding the points spaced the farthest apart on the x, y, and z axes.\n */\nexport function makeAxisAlignedBoundingBoxFromPoints(\n  positions: readonly number[][],\n  result: AxisAlignedBoundingBox = new AxisAlignedBoundingBox()\n): AxisAlignedBoundingBox {\n  if (!positions || positions.length === 0) {\n    result.minimum.set(0, 0, 0);\n    result.maximum.set(0, 0, 0);\n    result.center.set(0, 0, 0);\n    result.halfDiagonal.set(0, 0, 0);\n    return result;\n  }\n\n  let minimumX = positions[0][0];\n  let minimumY = positions[0][1];\n  let minimumZ = positions[0][2];\n\n  let maximumX = positions[0][0];\n  let maximumY = positions[0][1];\n  let maximumZ = positions[0][2];\n\n  for (const p of positions) {\n    const x = p[0];\n    const y = p[1];\n    const z = p[2];\n\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n    minimumZ = Math.min(z, minimumZ);\n    maximumZ = Math.max(z, maximumZ);\n  }\n\n  result.minimum.set(minimumX, minimumY, minimumZ);\n  result.maximum.set(maximumX, maximumY, maximumZ);\n  result.center.copy(result.minimum).add(result.maximum).scale(0.5);\n  result.halfDiagonal.copy(result.maximum).subtract(result.center);\n\n  return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}