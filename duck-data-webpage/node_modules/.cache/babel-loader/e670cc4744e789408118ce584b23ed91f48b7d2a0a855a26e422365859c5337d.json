{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { uid } from \"../utils/uid.js\";\nexport class Geometry {\n  id;\n  /** Determines how vertices are read from the 'vertex' attributes */\n  topology;\n  vertexCount;\n  indices;\n  attributes;\n  userData = {};\n  constructor(props) {\n    const {\n      attributes = {},\n      indices = null,\n      vertexCount = null\n    } = props;\n    this.id = props.id || uid('geometry');\n    this.topology = props.topology;\n    if (indices) {\n      this.indices = ArrayBuffer.isView(indices) ? {\n        value: indices,\n        size: 1\n      } : indices;\n    }\n    // @ts-expect-error\n    this.attributes = {};\n    for (const [attributeName, attributeValue] of Object.entries(attributes)) {\n      // Wrap \"unwrapped\" arrays and try to autodetect their type\n      const attribute = ArrayBuffer.isView(attributeValue) ? {\n        value: attributeValue\n      } : attributeValue;\n      if (!ArrayBuffer.isView(attribute.value)) {\n        throw new Error(`${this._print(attributeName)}: must be typed array or object with value as typed array`);\n      }\n      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {\n        attribute.size = 3;\n      }\n      // Move indices to separate field\n      if (attributeName === 'indices') {\n        if (this.indices) {\n          throw new Error('Multiple indices detected');\n        }\n        this.indices = attribute;\n      } else {\n        this.attributes[attributeName] = attribute;\n      }\n    }\n    if (this.indices && this.indices.isIndexed !== undefined) {\n      this.indices = Object.assign({}, this.indices);\n      delete this.indices.isIndexed;\n    }\n    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);\n  }\n  getVertexCount() {\n    return this.vertexCount;\n  }\n  /**\n   * Return an object with all attributes plus indices added as a field.\n   * TODO Geometry types are a mess\n   */\n  getAttributes() {\n    return this.indices ? {\n      indices: this.indices,\n      ...this.attributes\n    } : this.attributes;\n  }\n  // PRIVATE\n  _print(attributeName) {\n    return `Geometry ${this.id} attribute ${attributeName}`;\n  }\n  /**\n   * GeometryAttribute\n   * value: typed array\n   * type: indices, vertices, uvs\n   * size: elements per vertex\n   * target: WebGL buffer type (string or constant)\n   *\n   * @param attributes\n   * @param indices\n   * @returns\n   */\n  _setAttributes(attributes, indices) {\n    return this;\n  }\n  _calculateVertexCount(attributes, indices) {\n    if (indices) {\n      return indices.value.length;\n    }\n    let vertexCount = Infinity;\n    for (const attribute of Object.values(attributes)) {\n      const {\n        value,\n        size,\n        constant\n      } = attribute;\n      if (!constant && value && size !== undefined && size >= 1) {\n        vertexCount = Math.min(vertexCount, value.length / size);\n      }\n    }\n    // assert(Number.isFinite(vertexCount));\n    return vertexCount;\n  }\n}","map":{"version":3,"names":["uid","Geometry","id","topology","vertexCount","indices","attributes","userData","constructor","props","ArrayBuffer","isView","value","size","attributeName","attributeValue","Object","entries","attribute","Error","_print","isIndexed","undefined","assign","_calculateVertexCount","getVertexCount","getAttributes","_setAttributes","length","Infinity","values","constant","Math","min"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\engine\\src\\geometry\\geometry.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {TypedArray} from '@math.gl/core';\nimport type {PrimitiveTopology} from '@luma.gl/core';\nimport {uid} from '../utils/uid';\n\nexport type GeometryProps = {\n  id?: string;\n  /** Determines how vertices are read from the 'vertex' attributes */\n  topology: 'point-list' | 'line-list' | 'line-strip' | 'triangle-list' | 'triangle-strip';\n  /** Auto calculated from attributes if not provided */\n  vertexCount?: number;\n  attributes: Record<string, GeometryAttribute | TypedArray>;\n  indices?: GeometryAttribute | TypedArray;\n};\n\nexport type GeometryAttributes = {\n  POSITION: GeometryAttribute;\n  NORMAL: GeometryAttribute;\n  TEXCOORD_0: GeometryAttribute;\n  COLOR_0?: GeometryAttribute;\n  indices?: GeometryAttribute & {size: 1; value: Uint32Array | Uint16Array};\n};\n\nexport type GeometryAttribute = {\n  size?: number;\n  value: TypedArray;\n  [key: string]: any;\n};\n\nexport class Geometry {\n  readonly id: string;\n  /** Determines how vertices are read from the 'vertex' attributes */\n  readonly topology?: PrimitiveTopology;\n  readonly vertexCount: number;\n  readonly indices?: GeometryAttribute;\n  readonly attributes: {\n    POSITION: GeometryAttribute;\n    NORMAL: GeometryAttribute;\n    TEXCOORD_0: GeometryAttribute;\n    COLOR_0?: GeometryAttribute;\n    [key: string]: GeometryAttribute | undefined;\n  };\n\n  userData: Record<string, unknown> = {};\n\n  constructor(props: GeometryProps) {\n    const {attributes = {}, indices = null, vertexCount = null} = props;\n\n    this.id = props.id || uid('geometry');\n    this.topology = props.topology;\n\n    if (indices) {\n      this.indices = ArrayBuffer.isView(indices) ? {value: indices, size: 1} : indices;\n    }\n\n    // @ts-expect-error\n    this.attributes = {};\n\n    for (const [attributeName, attributeValue] of Object.entries(attributes)) {\n      // Wrap \"unwrapped\" arrays and try to autodetect their type\n      const attribute: GeometryAttribute = ArrayBuffer.isView(attributeValue)\n        ? {value: attributeValue}\n        : attributeValue;\n\n      if (!ArrayBuffer.isView(attribute.value)) {\n        throw new Error(\n          `${this._print(attributeName)}: must be typed array or object with value as typed array`\n        );\n      }\n\n      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {\n        attribute.size = 3;\n      }\n\n      // Move indices to separate field\n      if (attributeName === 'indices') {\n        if (this.indices) {\n          throw new Error('Multiple indices detected');\n        }\n        this.indices = attribute;\n      } else {\n        this.attributes[attributeName] = attribute;\n      }\n    }\n\n    if (this.indices && this.indices.isIndexed !== undefined) {\n      this.indices = Object.assign({}, this.indices);\n      delete this.indices.isIndexed;\n    }\n\n    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);\n  }\n\n  getVertexCount(): number {\n    return this.vertexCount;\n  }\n\n  /**\n   * Return an object with all attributes plus indices added as a field.\n   * TODO Geometry types are a mess\n   */\n  getAttributes(): GeometryAttributes {\n    return this.indices ? {indices: this.indices, ...this.attributes} : this.attributes;\n  }\n\n  // PRIVATE\n\n  _print(attributeName: string): string {\n    return `Geometry ${this.id} attribute ${attributeName}`;\n  }\n\n  /**\n   * GeometryAttribute\n   * value: typed array\n   * type: indices, vertices, uvs\n   * size: elements per vertex\n   * target: WebGL buffer type (string or constant)\n   *\n   * @param attributes\n   * @param indices\n   * @returns\n   */\n  _setAttributes(attributes: Record<string, GeometryAttribute>, indices: any): this {\n    return this;\n  }\n\n  _calculateVertexCount(attributes: GeometryAttributes, indices?: GeometryAttribute): number {\n    if (indices) {\n      return indices.value.length;\n    }\n    let vertexCount = Infinity;\n    for (const attribute of Object.values(attributes)) {\n      const {value, size, constant} = attribute;\n      if (!constant && value && size !== undefined && size >= 1) {\n        vertexCount = Math.min(vertexCount, value.length / size);\n      }\n    }\n\n    // assert(Number.isFinite(vertexCount));\n    return vertexCount;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}