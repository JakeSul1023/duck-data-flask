{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { load } from '@loaders.gl/core';\nimport { createIterable } from '@deck.gl/core';\nconst DEFAULT_CANVAS_WIDTH = 1024;\nconst DEFAULT_BUFFER = 4;\nconst noop = () => {};\nconst DEFAULT_SAMPLER_PARAMETERS = {\n  minFilter: 'linear',\n  mipmapFilter: 'linear',\n  // LINEAR is the default value but explicitly set it here\n  magFilter: 'linear',\n  // minimize texture boundary artifacts\n  addressModeU: 'clamp-to-edge',\n  addressModeV: 'clamp-to-edge'\n};\nconst MISSING_ICON = {\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0\n};\nfunction nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n// update comment to create a new texture and copy original data.\nfunction resizeImage(ctx, imageData, maxWidth, maxHeight) {\n  const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);\n  const width = Math.floor(imageData.width * resizeRatio);\n  const height = Math.floor(imageData.height * resizeRatio);\n  if (resizeRatio === 1) {\n    // No resizing required\n    return {\n      image: imageData,\n      width,\n      height\n    };\n  }\n  ctx.canvas.height = height;\n  ctx.canvas.width = width;\n  ctx.clearRect(0, 0, width, height);\n  // image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight\n  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);\n  return {\n    image: ctx.canvas,\n    width,\n    height\n  };\n}\nfunction getIconId(icon) {\n  return icon && (icon.id || icon.url);\n}\n// resize texture without losing original data\nfunction resizeTexture(texture, width, height, sampler) {\n  const {\n    width: oldWidth,\n    height: oldHeight,\n    device\n  } = texture;\n  const newTexture = device.createTexture({\n    format: 'rgba8unorm',\n    width,\n    height,\n    sampler,\n    mipmaps: true\n  });\n  const commandEncoder = device.createCommandEncoder();\n  commandEncoder.copyTextureToTexture({\n    sourceTexture: texture,\n    destinationTexture: newTexture,\n    width: oldWidth,\n    height: oldHeight\n  });\n  commandEncoder.finish();\n  texture.destroy();\n  return newTexture;\n}\n// traverse icons in a row of icon atlas\n// extend each icon with left-top coordinates\nfunction buildRowMapping(mapping, columns, yOffset) {\n  for (let i = 0; i < columns.length; i++) {\n    const {\n      icon,\n      xOffset\n    } = columns[i];\n    const id = getIconId(icon);\n    mapping[id] = {\n      ...icon,\n      x: xOffset,\n      y: yOffset\n    };\n  }\n}\n/**\n * Generate coordinate mapping to retrieve icon left-top position from an icon atlas\n */\nexport function buildMapping(_ref) {\n  let {\n    icons,\n    buffer,\n    mapping = {},\n    xOffset = 0,\n    yOffset = 0,\n    rowHeight = 0,\n    canvasWidth\n  } = _ref;\n  let columns = [];\n  // Strategy to layout all the icons into a texture:\n  // traverse the icons sequentially, layout the icons from left to right, top to bottom\n  // when the sum of the icons width is equal or larger than canvasWidth,\n  // move to next row starting from total height so far plus max height of the icons in previous row\n  // row width is equal to canvasWidth\n  // row height is decided by the max height of the icons in that row\n  // mapping coordinates of each icon is its left-top position in the texture\n  for (let i = 0; i < icons.length; i++) {\n    const icon = icons[i];\n    const id = getIconId(icon);\n    if (!mapping[id]) {\n      const {\n        height,\n        width\n      } = icon;\n      // fill one row\n      if (xOffset + width + buffer > canvasWidth) {\n        buildRowMapping(mapping, columns, yOffset);\n        xOffset = 0;\n        yOffset = rowHeight + yOffset + buffer;\n        rowHeight = 0;\n        columns = [];\n      }\n      columns.push({\n        icon,\n        xOffset\n      });\n      xOffset = xOffset + width + buffer;\n      rowHeight = Math.max(rowHeight, height);\n    }\n  }\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset);\n  }\n  return {\n    mapping,\n    rowHeight,\n    xOffset,\n    yOffset,\n    canvasWidth,\n    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)\n  };\n}\n// extract icons from data\n// return icons should be unique, and not cached or cached but url changed\nexport function getDiffIcons(data, getIcon, cachedIcons) {\n  if (!data || !getIcon) {\n    return null;\n  }\n  cachedIcons = cachedIcons || {};\n  const icons = {};\n  const {\n    iterable,\n    objectInfo\n  } = createIterable(data);\n  for (const object of iterable) {\n    objectInfo.index++;\n    const icon = getIcon(object, objectInfo);\n    const id = getIconId(icon);\n    if (!icon) {\n      throw new Error('Icon is missing.');\n    }\n    if (!icon.url) {\n      throw new Error('Icon url is missing.');\n    }\n    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {\n      icons[id] = {\n        ...icon,\n        source: object,\n        sourceIndex: objectInfo.index\n      };\n    }\n  }\n  return icons;\n}\nexport default class IconManager {\n  constructor(device, _ref2) {\n    let {\n      onUpdate = noop,\n      onError = noop\n    } = _ref2;\n    this._loadOptions = null;\n    this._texture = null;\n    this._externalTexture = null;\n    this._mapping = {};\n    this._samplerParameters = null;\n    /** count of pending requests to fetch icons */\n    this._pendingCount = 0;\n    this._autoPacking = false;\n    // / internal state used for autoPacking\n    this._xOffset = 0;\n    this._yOffset = 0;\n    this._rowHeight = 0;\n    this._buffer = DEFAULT_BUFFER;\n    this._canvasWidth = DEFAULT_CANVAS_WIDTH;\n    this._canvasHeight = 0;\n    this._canvas = null;\n    this.device = device;\n    this.onUpdate = onUpdate;\n    this.onError = onError;\n  }\n  finalize() {\n    this._texture?.delete();\n  }\n  getTexture() {\n    return this._texture || this._externalTexture;\n  }\n  getIconMapping(icon) {\n    const id = this._autoPacking ? getIconId(icon) : icon;\n    return this._mapping[id] || MISSING_ICON;\n  }\n  setProps(_ref3) {\n    let {\n      loadOptions,\n      autoPacking,\n      iconAtlas,\n      iconMapping,\n      textureParameters\n    } = _ref3;\n    if (loadOptions) {\n      this._loadOptions = loadOptions;\n    }\n    if (autoPacking !== undefined) {\n      this._autoPacking = autoPacking;\n    }\n    if (iconMapping) {\n      this._mapping = iconMapping;\n    }\n    if (iconAtlas) {\n      this._texture?.delete();\n      this._texture = null;\n      this._externalTexture = iconAtlas;\n    }\n    if (textureParameters) {\n      this._samplerParameters = textureParameters;\n    }\n  }\n  get isLoaded() {\n    return this._pendingCount === 0;\n  }\n  packIcons(data, getIcon) {\n    if (!this._autoPacking || typeof document === 'undefined') {\n      return;\n    }\n    const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});\n    if (icons.length > 0) {\n      // generate icon mapping\n      const {\n        mapping,\n        xOffset,\n        yOffset,\n        rowHeight,\n        canvasHeight\n      } = buildMapping({\n        icons,\n        buffer: this._buffer,\n        canvasWidth: this._canvasWidth,\n        mapping: this._mapping,\n        rowHeight: this._rowHeight,\n        xOffset: this._xOffset,\n        yOffset: this._yOffset\n      });\n      this._rowHeight = rowHeight;\n      this._mapping = mapping;\n      this._xOffset = xOffset;\n      this._yOffset = yOffset;\n      this._canvasHeight = canvasHeight;\n      // create new texture\n      if (!this._texture) {\n        this._texture = this.device.createTexture({\n          format: 'rgba8unorm',\n          width: this._canvasWidth,\n          height: this._canvasHeight,\n          sampler: this._samplerParameters || DEFAULT_SAMPLER_PARAMETERS,\n          mipmaps: true\n        });\n      }\n      if (this._texture.height !== this._canvasHeight) {\n        this._texture = resizeTexture(this._texture, this._canvasWidth, this._canvasHeight, this._samplerParameters || DEFAULT_SAMPLER_PARAMETERS);\n      }\n      this.onUpdate();\n      // load images\n      this._canvas = this._canvas || document.createElement('canvas');\n      this._loadIcons(icons);\n    }\n  }\n  _loadIcons(icons) {\n    // This method is only called in the auto packing case, where _canvas is defined\n    const ctx = this._canvas.getContext('2d', {\n      willReadFrequently: true\n    });\n    for (const icon of icons) {\n      this._pendingCount++;\n      load(icon.url, this._loadOptions).then(imageData => {\n        const id = getIconId(icon);\n        const iconDef = this._mapping[id];\n        const {\n          x,\n          y,\n          width: maxWidth,\n          height: maxHeight\n        } = iconDef;\n        const {\n          image,\n          width,\n          height\n        } = resizeImage(ctx, imageData, maxWidth, maxHeight);\n        this._texture?.copyExternalImage({\n          image,\n          x: x + (maxWidth - width) / 2,\n          y: y + (maxHeight - height) / 2,\n          width,\n          height\n        });\n        iconDef.width = width;\n        iconDef.height = height;\n        // Call to regenerate mipmaps after modifying texture(s)\n        // @ts-expect-error TODO v9 API not yet clear\n        this._texture.generateMipmap();\n        this.onUpdate();\n      }).catch(error => {\n        this.onError({\n          url: icon.url,\n          source: icon.source,\n          sourceIndex: icon.sourceIndex,\n          loadOptions: this._loadOptions,\n          error\n        });\n      }).finally(() => {\n        this._pendingCount--;\n      });\n    }\n  }\n}\n//# sourceMappingURL=icon-manager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}