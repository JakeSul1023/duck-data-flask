{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Model } from \"../model/model.js\";\nimport { getPassthroughFS } from '@luma.gl/shadertools';\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n/**\n * Creates a pipeline for texture→texture transforms.\n * @deprecated\n */\nexport class TextureTransform {\n  device;\n  model;\n  sampler;\n  currentIndex = 0;\n  samplerTextureMap = null;\n  bindings = []; // each element is an object : {sourceTextures, targetTexture, framebuffer}\n  resources = {}; // resources to be deleted\n  constructor(device, props) {\n    this.device = device;\n    // For precise picking of element IDs.\n    this.sampler = device.createSampler({\n      addressModeU: 'clamp-to-edge',\n      addressModeV: 'clamp-to-edge',\n      minFilter: 'nearest',\n      magFilter: 'nearest',\n      mipmapFilter: 'nearest'\n    });\n    this.model = new Model(this.device, {\n      id: props.id || 'texture-transform-model',\n      fs: props.fs || getPassthroughFS({\n        input: props.targetTextureVarying,\n        inputChannels: props.targetTextureChannels,\n        output: FS_OUTPUT_VARIABLE\n      }),\n      vertexCount: props.vertexCount,\n      // TODO(donmccurdy): Naming?\n      ...props\n    });\n    this._initialize(props);\n    Object.seal(this);\n  }\n  // Delete owned resources.\n  destroy() {\n    this.model.destroy();\n    for (const binding of this.bindings) {\n      binding.framebuffer?.destroy();\n    }\n  }\n  /** @deprecated Use {@link destroy}. */\n  delete() {\n    this.destroy();\n  }\n  run(options) {\n    const {\n      framebuffer\n    } = this.bindings[this.currentIndex];\n    const renderPass = this.device.beginRenderPass({\n      framebuffer,\n      ...options\n    });\n    this.model.draw(renderPass);\n    renderPass.end();\n  }\n  getTargetTexture() {\n    const {\n      targetTexture\n    } = this.bindings[this.currentIndex];\n    return targetTexture;\n  }\n  getFramebuffer() {\n    const currentResources = this.bindings[this.currentIndex];\n    return currentResources.framebuffer;\n  }\n  // Private\n  _initialize(props) {\n    this._updateBindings(props);\n  }\n  _updateBindings(props) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], props);\n  }\n  _updateBinding(binding, {\n    sourceBuffers,\n    sourceTextures,\n    targetTexture\n  }) {\n    if (!binding) {\n      binding = {\n        sourceBuffers: {},\n        sourceTextures: {},\n        // @ts-expect-error\n        targetTexture: null\n      };\n    }\n    Object.assign(binding.sourceTextures, sourceTextures);\n    Object.assign(binding.sourceBuffers, sourceBuffers);\n    if (targetTexture) {\n      binding.targetTexture = targetTexture;\n      const {\n        width,\n        height\n      } = targetTexture;\n      // TODO(donmccurdy): When is this called, and is this expected?\n      if (binding.framebuffer) {\n        binding.framebuffer.destroy();\n      }\n      binding.framebuffer = this.device.createFramebuffer({\n        id: 'transform-framebuffer',\n        width,\n        height,\n        colorAttachments: [targetTexture]\n      });\n      binding.framebuffer.resize({\n        width,\n        height\n      });\n    }\n    return binding;\n  }\n  // set texture filtering parameters on source textures.\n  _setSourceTextureParameters() {\n    const index = this.currentIndex;\n    const {\n      sourceTextures\n    } = this.bindings[index];\n    for (const name in sourceTextures) {\n      sourceTextures[name].sampler = this.sampler;\n    }\n  }\n}","map":{"version":3,"names":["Model","getPassthroughFS","FS_OUTPUT_VARIABLE","TextureTransform","device","model","sampler","currentIndex","samplerTextureMap","bindings","resources","constructor","props","createSampler","addressModeU","addressModeV","minFilter","magFilter","mipmapFilter","id","fs","input","targetTextureVarying","inputChannels","targetTextureChannels","output","vertexCount","_initialize","Object","seal","destroy","binding","framebuffer","delete","run","options","renderPass","beginRenderPass","draw","end","getTargetTexture","targetTexture","getFramebuffer","currentResources","_updateBindings","_updateBinding","sourceBuffers","sourceTextures","assign","width","height","createFramebuffer","colorAttachments","resize","_setSourceTextureParameters","index","name"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\engine\\src\\compute\\texture-transform.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Buffer, Device, Framebuffer, RenderPassProps, Sampler, Texture} from '@luma.gl/core';\nimport {Model, ModelProps} from '../model/model';\nimport {getPassthroughFS} from '@luma.gl/shadertools';\n\n/**\n * Properties for creating a {@link TextureTransform}\n */\nexport type TextureTransformProps = Omit<ModelProps, 'fs'> & {\n  fs?: ModelProps['fs']; // override as optional\n  /** @deprecated TODO(donmccurdy): Needed? */\n  inject?: Record<string, string>;\n  /** @deprecated TODO(donmccurdy): Needed? */\n  framebuffer?: Framebuffer;\n  /** @deprecated TODO(donmccurdy): Model already handles this? */\n  sourceBuffers?: Record<string, Buffer>;\n  /** @deprecated TODO(donmccurdy): Model already handles this? */\n  sourceTextures?: Record<string, Texture>;\n  targetTexture: Texture;\n  targetTextureChannels: 1 | 2 | 3 | 4;\n  targetTextureVarying: string;\n};\n\ntype TextureBinding = {\n  sourceBuffers: Record<string, Buffer>;\n  sourceTextures: Record<string, Texture>;\n  targetTexture: Texture;\n  framebuffer?: Framebuffer;\n};\n\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n\n/**\n * Creates a pipeline for texture→texture transforms.\n * @deprecated\n */\nexport class TextureTransform {\n  readonly device: Device;\n  readonly model: Model;\n  readonly sampler: Sampler;\n\n  currentIndex = 0;\n  samplerTextureMap: Record<string, any> | null = null;\n  bindings: TextureBinding[] = []; // each element is an object : {sourceTextures, targetTexture, framebuffer}\n  resources: Record<string, any> = {}; // resources to be deleted\n\n  constructor(device: Device, props: TextureTransformProps) {\n    this.device = device;\n\n    // For precise picking of element IDs.\n    this.sampler = device.createSampler({\n      addressModeU: 'clamp-to-edge',\n      addressModeV: 'clamp-to-edge',\n      minFilter: 'nearest',\n      magFilter: 'nearest',\n      mipmapFilter: 'nearest'\n    });\n\n    this.model = new Model(this.device, {\n      id: props.id || 'texture-transform-model',\n      fs:\n        props.fs ||\n        getPassthroughFS({\n          input: props.targetTextureVarying,\n          inputChannels: props.targetTextureChannels,\n          output: FS_OUTPUT_VARIABLE\n        }),\n      vertexCount: props.vertexCount, // TODO(donmccurdy): Naming?\n      ...props\n    });\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  // Delete owned resources.\n  destroy(): void {\n    this.model.destroy();\n    for (const binding of this.bindings) {\n      binding.framebuffer?.destroy();\n    }\n  }\n\n  /** @deprecated Use {@link destroy}. */\n  delete(): void {\n    this.destroy();\n  }\n\n  run(options?: RenderPassProps): void {\n    const {framebuffer} = this.bindings[this.currentIndex];\n    const renderPass = this.device.beginRenderPass({framebuffer, ...options});\n    this.model.draw(renderPass);\n    renderPass.end();\n  }\n\n  getTargetTexture(): Texture {\n    const {targetTexture} = this.bindings[this.currentIndex];\n    return targetTexture;\n  }\n\n  getFramebuffer(): Framebuffer | undefined {\n    const currentResources = this.bindings[this.currentIndex];\n    return currentResources.framebuffer;\n  }\n\n  // Private\n\n  _initialize(props: TextureTransformProps): void {\n    this._updateBindings(props);\n  }\n\n  _updateBindings(props: TextureTransformProps) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], props);\n  }\n\n  _updateBinding(\n    binding: TextureBinding,\n    {sourceBuffers, sourceTextures, targetTexture}: TextureTransformProps\n  ): TextureBinding {\n    if (!binding) {\n      binding = {\n        sourceBuffers: {},\n        sourceTextures: {},\n        // @ts-expect-error\n        targetTexture: null\n      };\n    }\n    Object.assign(binding.sourceTextures, sourceTextures);\n    Object.assign(binding.sourceBuffers, sourceBuffers);\n    if (targetTexture) {\n      binding.targetTexture = targetTexture;\n      const {width, height} = targetTexture;\n      // TODO(donmccurdy): When is this called, and is this expected?\n      if (binding.framebuffer) {\n        binding.framebuffer.destroy();\n      }\n      binding.framebuffer = this.device.createFramebuffer({\n        id: 'transform-framebuffer',\n        width,\n        height,\n        colorAttachments: [targetTexture]\n      });\n      binding.framebuffer.resize({width, height});\n    }\n    return binding;\n  }\n\n  // set texture filtering parameters on source textures.\n  _setSourceTextureParameters(): void {\n    const index = this.currentIndex;\n    const {sourceTextures} = this.bindings[index];\n    for (const name in sourceTextures) {\n      sourceTextures[name].sampler = this.sampler;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}