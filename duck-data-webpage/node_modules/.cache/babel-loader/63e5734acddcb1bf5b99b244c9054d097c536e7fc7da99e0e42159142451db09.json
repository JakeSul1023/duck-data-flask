{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { joinLayerBounds, getRenderBounds, makeViewport } from \"../utils/projection-utils.js\";\nimport { createRenderTarget } from \"./utils.js\";\nconst MAP_MAX_SIZE = 2048;\n/**\n * Manages the lifecycle of the height map (a framebuffer that encodes elevation).\n * One instance of height map is is shared across all layers. It is updated when the viewport changes\n * or when some terrain source layer's data changes.\n * During the draw call of any terrainDrawMode:offset layers,\n * the vertex shader reads from this framebuffer to retrieve its z offset.\n */\nexport class HeightMapBuilder {\n  static isSupported(device) {\n    return device.isTextureFormatRenderable('rgba32float');\n  }\n  constructor(device) {\n    /** Viewport used to draw into the texture */\n    this.renderViewport = null;\n    /** Bounds of the height map texture, in cartesian space */\n    this.bounds = null;\n    /** Last rendered layers */\n    this.layers = [];\n    /** Last layer.getBounds() */\n    this.layersBounds = [];\n    /** The union of layersBounds in cartesian space */\n    this.layersBoundsCommon = null;\n    this.lastViewport = null;\n    this.device = device;\n  }\n  /** Returns the height map framebuffer for read/write access.\n   * Returns null when the texture is invalid.\n   */\n  getRenderFramebuffer() {\n    if (!this.renderViewport) {\n      return null;\n    }\n    if (!this.fbo) {\n      this.fbo = createRenderTarget(this.device, {\n        id: 'height-map',\n        float: true\n      });\n    }\n    return this.fbo;\n  }\n  /** Called every render cycle to check if the framebuffer needs update */\n  shouldUpdate({\n    layers,\n    viewport\n  }) {\n    const layersChanged = layers.length !== this.layers.length || layers.some((layer, i) =>\n    // Layer instance is updated\n    // Layer props might have changed\n    // Undetermined props could have an effect on the output geometry of a terrain source,\n    // for example getElevation+updateTriggers, elevationScale, modelMatrix\n    layer !== this.layers[i] ||\n    // Some prop is in transition\n    layer.props.transitions ||\n    // Layer's geometry bounds have changed\n    layer.getBounds() !== this.layersBounds[i]);\n    if (layersChanged) {\n      // Recalculate cached bounds\n      this.layers = layers;\n      this.layersBounds = layers.map(layer => layer.getBounds());\n      this.layersBoundsCommon = joinLayerBounds(layers, viewport);\n    }\n    const viewportChanged = !this.lastViewport || !viewport.equals(this.lastViewport);\n    if (!this.layersBoundsCommon) {\n      this.renderViewport = null;\n    } else if (layersChanged || viewportChanged) {\n      const bounds = getRenderBounds(this.layersBoundsCommon, viewport);\n      if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {\n        this.renderViewport = null;\n        return false;\n      }\n      this.bounds = bounds;\n      this.lastViewport = viewport;\n      const scale = viewport.scale;\n      const pixelWidth = (bounds[2] - bounds[0]) * scale;\n      const pixelHeight = (bounds[3] - bounds[1]) * scale;\n      this.renderViewport = pixelWidth > 0 || pixelHeight > 0 ? makeViewport({\n        // It's not important whether the geometry is visible in this viewport, because\n        // vertices will not use the standard project_to_clipspace in the DRAW_TO_HEIGHT_MAP shader\n        // However the viewport must have the same center and zoom as the screen viewport\n        // So that projection uniforms used for calculating z are the same\n        bounds: [viewport.center[0] - 1, viewport.center[1] - 1, viewport.center[0] + 1, viewport.center[1] + 1],\n        zoom: viewport.zoom,\n        width: Math.min(pixelWidth, MAP_MAX_SIZE),\n        height: Math.min(pixelHeight, MAP_MAX_SIZE),\n        viewport\n      }) : null;\n      return true;\n    }\n    return false;\n  }\n  delete() {\n    if (this.fbo) {\n      this.fbo.colorAttachments[0].delete();\n      this.fbo.delete();\n    }\n  }\n}","map":{"version":3,"names":["joinLayerBounds","getRenderBounds","makeViewport","createRenderTarget","MAP_MAX_SIZE","HeightMapBuilder","isSupported","device","isTextureFormatRenderable","constructor","renderViewport","bounds","layers","layersBounds","layersBoundsCommon","lastViewport","getRenderFramebuffer","fbo","id","float","shouldUpdate","viewport","layersChanged","length","some","layer","i","props","transitions","getBounds","map","viewportChanged","equals","scale","pixelWidth","pixelHeight","center","zoom","width","Math","min","height","delete","colorAttachments"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\extensions\\src\\terrain\\height-map-builder.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, Framebuffer} from '@luma.gl/core';\nimport {joinLayerBounds, getRenderBounds, makeViewport, Bounds} from '../utils/projection-utils';\nimport {createRenderTarget} from './utils';\n\nimport type {Viewport, Layer} from '@deck.gl/core';\n\nconst MAP_MAX_SIZE = 2048;\n\n/**\n * Manages the lifecycle of the height map (a framebuffer that encodes elevation).\n * One instance of height map is is shared across all layers. It is updated when the viewport changes\n * or when some terrain source layer's data changes.\n * During the draw call of any terrainDrawMode:offset layers,\n * the vertex shader reads from this framebuffer to retrieve its z offset.\n */\nexport class HeightMapBuilder {\n  /** Viewport used to draw into the texture */\n  renderViewport: Viewport | null = null;\n  /** Bounds of the height map texture, in cartesian space */\n  bounds: Bounds | null = null;\n\n  protected fbo?: Framebuffer;\n  protected device: Device;\n  /** Last rendered layers */\n  private layers: Layer[] = [];\n  /** Last layer.getBounds() */\n  private layersBounds: ([number[], number[]] | null)[] = [];\n  /** The union of layersBounds in cartesian space */\n  private layersBoundsCommon: Bounds | null = null;\n  private lastViewport: Viewport | null = null;\n\n  static isSupported(device: Device): boolean {\n    return device.isTextureFormatRenderable('rgba32float');\n  }\n\n  constructor(device: Device) {\n    this.device = device;\n  }\n\n  /** Returns the height map framebuffer for read/write access.\n   * Returns null when the texture is invalid.\n   */\n  getRenderFramebuffer(): Framebuffer | null {\n    if (!this.renderViewport) {\n      return null;\n    }\n    if (!this.fbo) {\n      this.fbo = createRenderTarget(this.device, {id: 'height-map', float: true});\n    }\n    return this.fbo;\n  }\n\n  /** Called every render cycle to check if the framebuffer needs update */\n  shouldUpdate({layers, viewport}: {layers: Layer[]; viewport: Viewport}): boolean {\n    const layersChanged =\n      layers.length !== this.layers.length ||\n      layers.some(\n        (layer, i) =>\n          // Layer instance is updated\n          // Layer props might have changed\n          // Undetermined props could have an effect on the output geometry of a terrain source,\n          // for example getElevation+updateTriggers, elevationScale, modelMatrix\n          layer !== this.layers[i] ||\n          // Some prop is in transition\n          layer.props.transitions ||\n          // Layer's geometry bounds have changed\n          layer.getBounds() !== this.layersBounds[i]\n      );\n\n    if (layersChanged) {\n      // Recalculate cached bounds\n      this.layers = layers;\n      this.layersBounds = layers.map(layer => layer.getBounds());\n      this.layersBoundsCommon = joinLayerBounds(layers, viewport);\n    }\n\n    const viewportChanged = !this.lastViewport || !viewport.equals(this.lastViewport);\n\n    if (!this.layersBoundsCommon) {\n      this.renderViewport = null;\n    } else if (layersChanged || viewportChanged) {\n      const bounds = getRenderBounds(this.layersBoundsCommon, viewport);\n      if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {\n        this.renderViewport = null;\n        return false;\n      }\n\n      this.bounds = bounds;\n      this.lastViewport = viewport;\n\n      const scale = viewport.scale;\n      const pixelWidth = (bounds[2] - bounds[0]) * scale;\n      const pixelHeight = (bounds[3] - bounds[1]) * scale;\n\n      this.renderViewport =\n        pixelWidth > 0 || pixelHeight > 0\n          ? makeViewport({\n              // It's not important whether the geometry is visible in this viewport, because\n              // vertices will not use the standard project_to_clipspace in the DRAW_TO_HEIGHT_MAP shader\n              // However the viewport must have the same center and zoom as the screen viewport\n              // So that projection uniforms used for calculating z are the same\n              bounds: [\n                viewport.center[0] - 1,\n                viewport.center[1] - 1,\n                viewport.center[0] + 1,\n                viewport.center[1] + 1\n              ],\n              zoom: viewport.zoom,\n              width: Math.min(pixelWidth, MAP_MAX_SIZE),\n              height: Math.min(pixelHeight, MAP_MAX_SIZE),\n              viewport\n            })\n          : null;\n      return true;\n    }\n    return false;\n  }\n\n  delete() {\n    if (this.fbo) {\n      this.fbo.colorAttachments[0].delete();\n      this.fbo.delete();\n    }\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAGA,SAAQA,eAAe,EAAEC,eAAe,EAAEC,YAAY,QAAS;AAC/D,SAAQC,kBAAkB,QAAC;AAI3B,MAAMC,YAAY,GAAG,IAAI;AAEzB;;;;;;;AAOA,OAAM,MAAOC,gBAAgB;EAgB3B,OAAOC,WAAWA,CAACC,MAAc;IAC/B,OAAOA,MAAM,CAACC,yBAAyB,CAAC,aAAa,CAAC;EACxD;EAEAC,YAAYF,MAAc;IAnB1B;IACA,KAAAG,cAAc,GAAoB,IAAI;IACtC;IACA,KAAAC,MAAM,GAAkB,IAAI;IAI5B;IACQ,KAAAC,MAAM,GAAY,EAAE;IAC5B;IACQ,KAAAC,YAAY,GAAoC,EAAE;IAC1D;IACQ,KAAAC,kBAAkB,GAAkB,IAAI;IACxC,KAAAC,YAAY,GAAoB,IAAI;IAO1C,IAAI,CAACR,MAAM,GAAGA,MAAM;EACtB;EAEA;;;EAGAS,oBAAoBA,CAAA;IAClB,IAAI,CAAC,IAAI,CAACN,cAAc,EAAE;MACxB,OAAO,IAAI;IACb;IACA,IAAI,CAAC,IAAI,CAACO,GAAG,EAAE;MACb,IAAI,CAACA,GAAG,GAAGd,kBAAkB,CAAC,IAAI,CAACI,MAAM,EAAE;QAACW,EAAE,EAAE,YAAY;QAAEC,KAAK,EAAE;MAAI,CAAC,CAAC;IAC7E;IACA,OAAO,IAAI,CAACF,GAAG;EACjB;EAEA;EACAG,YAAYA,CAAC;IAACR,MAAM;IAAES;EAAQ,CAAwC;IACpE,MAAMC,aAAa,GACjBV,MAAM,CAACW,MAAM,KAAK,IAAI,CAACX,MAAM,CAACW,MAAM,IACpCX,MAAM,CAACY,IAAI,CACT,CAACC,KAAK,EAAEC,CAAC;IACP;IACA;IACA;IACA;IACAD,KAAK,KAAK,IAAI,CAACb,MAAM,CAACc,CAAC,CAAC;IACxB;IACAD,KAAK,CAACE,KAAK,CAACC,WAAW;IACvB;IACAH,KAAK,CAACI,SAAS,EAAE,KAAK,IAAI,CAAChB,YAAY,CAACa,CAAC,CAAC,CAC7C;IAEH,IAAIJ,aAAa,EAAE;MACjB;MACA,IAAI,CAACV,MAAM,GAAGA,MAAM;MACpB,IAAI,CAACC,YAAY,GAAGD,MAAM,CAACkB,GAAG,CAACL,KAAK,IAAIA,KAAK,CAACI,SAAS,EAAE,CAAC;MAC1D,IAAI,CAACf,kBAAkB,GAAGd,eAAe,CAACY,MAAM,EAAES,QAAQ,CAAC;IAC7D;IAEA,MAAMU,eAAe,GAAG,CAAC,IAAI,CAAChB,YAAY,IAAI,CAACM,QAAQ,CAACW,MAAM,CAAC,IAAI,CAACjB,YAAY,CAAC;IAEjF,IAAI,CAAC,IAAI,CAACD,kBAAkB,EAAE;MAC5B,IAAI,CAACJ,cAAc,GAAG,IAAI;IAC5B,CAAC,MAAM,IAAIY,aAAa,IAAIS,eAAe,EAAE;MAC3C,MAAMpB,MAAM,GAAGV,eAAe,CAAC,IAAI,CAACa,kBAAkB,EAAEO,QAAQ,CAAC;MACjE,IAAIV,MAAM,CAAC,CAAC,CAAC,IAAIA,MAAM,CAAC,CAAC,CAAC,IAAIA,MAAM,CAAC,CAAC,CAAC,IAAIA,MAAM,CAAC,CAAC,CAAC,EAAE;QACpD,IAAI,CAACD,cAAc,GAAG,IAAI;QAC1B,OAAO,KAAK;MACd;MAEA,IAAI,CAACC,MAAM,GAAGA,MAAM;MACpB,IAAI,CAACI,YAAY,GAAGM,QAAQ;MAE5B,MAAMY,KAAK,GAAGZ,QAAQ,CAACY,KAAK;MAC5B,MAAMC,UAAU,GAAG,CAACvB,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,IAAIsB,KAAK;MAClD,MAAME,WAAW,GAAG,CAACxB,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,IAAIsB,KAAK;MAEnD,IAAI,CAACvB,cAAc,GACjBwB,UAAU,GAAG,CAAC,IAAIC,WAAW,GAAG,CAAC,GAC7BjC,YAAY,CAAC;QACX;QACA;QACA;QACA;QACAS,MAAM,EAAE,CACNU,QAAQ,CAACe,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,EACtBf,QAAQ,CAACe,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,EACtBf,QAAQ,CAACe,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,EACtBf,QAAQ,CAACe,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CACvB;QACDC,IAAI,EAAEhB,QAAQ,CAACgB,IAAI;QACnBC,KAAK,EAAEC,IAAI,CAACC,GAAG,CAACN,UAAU,EAAE9B,YAAY,CAAC;QACzCqC,MAAM,EAAEF,IAAI,CAACC,GAAG,CAACL,WAAW,EAAE/B,YAAY,CAAC;QAC3CiB;OACD,CAAC,GACF,IAAI;MACV,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;EAEAqB,MAAMA,CAAA;IACJ,IAAI,IAAI,CAACzB,GAAG,EAAE;MACZ,IAAI,CAACA,GAAG,CAAC0B,gBAAgB,CAAC,CAAC,CAAC,CAACD,MAAM,EAAE;MACrC,IAAI,CAACzB,GAAG,CAACyB,MAAM,EAAE;IACnB;EACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}