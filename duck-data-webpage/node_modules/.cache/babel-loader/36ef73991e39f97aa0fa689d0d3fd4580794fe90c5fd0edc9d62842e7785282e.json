{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n/* eslint-disable */\nimport { Vector3, _MathUtils } from '@math.gl/core';\nconst scratchVector = new Vector3();\nconst scaleToGeodeticSurfaceIntersection = new Vector3();\nconst scaleToGeodeticSurfaceGradient = new Vector3();\n// Scales the provided Cartesian position along the geodetic surface normal\n// so that it is on the surface of this ellipsoid.  If the position is\n// at the center of the ellipsoid, this function returns undefined.\nexport function scaleToGeodeticSurface(cartesian, ellipsoid, result = []) {\n  const {\n    oneOverRadii,\n    oneOverRadiiSquared,\n    centerToleranceSquared\n  } = ellipsoid;\n  scratchVector.from(cartesian);\n  const positionX = scratchVector.x;\n  const positionY = scratchVector.y;\n  const positionZ = scratchVector.z;\n  const oneOverRadiiX = oneOverRadii.x;\n  const oneOverRadiiY = oneOverRadii.y;\n  const oneOverRadiiZ = oneOverRadii.z;\n  const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n  const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n  const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n  // Compute the squared ellipsoid norm.\n  const squaredNorm = x2 + y2 + z2;\n  const ratio = Math.sqrt(1.0 / squaredNorm);\n  // When very close to center or at center\n  if (!Number.isFinite(ratio)) {\n    return undefined;\n  }\n  // As an initial approximation, assume that the radial intersection is the projection point.\n  const intersection = scaleToGeodeticSurfaceIntersection;\n  intersection.copy(cartesian).scale(ratio);\n  // If the position is near the center, the iteration will not converge.\n  if (squaredNorm < centerToleranceSquared) {\n    return intersection.to(result);\n  }\n  const oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n  const oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n  const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n  // Use the gradient at the intersection point in place of the true unit normal.\n  // The difference in magnitude will be absorbed in the multiplier.\n  const gradient = scaleToGeodeticSurfaceGradient;\n  gradient.set(intersection.x * oneOverRadiiSquaredX * 2.0, intersection.y * oneOverRadiiSquaredY * 2.0, intersection.z * oneOverRadiiSquaredZ * 2.0);\n  // Compute the initial guess at the normal vector multiplier, lambda.\n  let lambda = (1.0 - ratio) * scratchVector.len() / (0.5 * gradient.len());\n  let correction = 0.0;\n  let xMultiplier;\n  let yMultiplier;\n  let zMultiplier;\n  let func;\n  do {\n    lambda -= correction;\n    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n    const xMultiplier2 = xMultiplier * xMultiplier;\n    const yMultiplier2 = yMultiplier * yMultiplier;\n    const zMultiplier2 = zMultiplier * zMultiplier;\n    const xMultiplier3 = xMultiplier2 * xMultiplier;\n    const yMultiplier3 = yMultiplier2 * yMultiplier;\n    const zMultiplier3 = zMultiplier2 * zMultiplier;\n    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n    // \"denominator\" here refers to the use of this expression in the velocity and acceleration\n    // computations in the sections to follow.\n    const denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n    const derivative = -2.0 * denominator;\n    correction = func / derivative;\n  } while (Math.abs(func) > _MathUtils.EPSILON12);\n  return scratchVector.scale([xMultiplier, yMultiplier, zMultiplier]).to(result);\n}","map":{"version":3,"names":["Vector3","_MathUtils","scratchVector","scaleToGeodeticSurfaceIntersection","scaleToGeodeticSurfaceGradient","scaleToGeodeticSurface","cartesian","ellipsoid","result","oneOverRadii","oneOverRadiiSquared","centerToleranceSquared","from","positionX","x","positionY","y","positionZ","z","oneOverRadiiX","oneOverRadiiY","oneOverRadiiZ","x2","y2","z2","squaredNorm","ratio","Math","sqrt","Number","isFinite","undefined","intersection","copy","scale","to","oneOverRadiiSquaredX","oneOverRadiiSquaredY","oneOverRadiiSquaredZ","gradient","set","lambda","len","correction","xMultiplier","yMultiplier","zMultiplier","func","xMultiplier2","yMultiplier2","zMultiplier2","xMultiplier3","yMultiplier3","zMultiplier3","denominator","derivative","abs","EPSILON12"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\geospatial\\src\\ellipsoid\\helpers\\scale-to-geodetic-surface.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable */\nimport {Vector3, _MathUtils} from '@math.gl/core';\nimport type {Ellipsoid} from '../ellipsoid';\n\nconst scratchVector = new Vector3();\nconst scaleToGeodeticSurfaceIntersection = new Vector3();\nconst scaleToGeodeticSurfaceGradient = new Vector3();\n\n// Scales the provided Cartesian position along the geodetic surface normal\n// so that it is on the surface of this ellipsoid.  If the position is\n// at the center of the ellipsoid, this function returns undefined.\nexport function scaleToGeodeticSurface(\n  cartesian: number[],\n  ellipsoid: Ellipsoid,\n  result: number[] = []\n): number[] {\n  const {oneOverRadii, oneOverRadiiSquared, centerToleranceSquared} = ellipsoid;\n\n  scratchVector.from(cartesian);\n\n  const positionX = scratchVector.x;\n  const positionY = scratchVector.y;\n  const positionZ = scratchVector.z;\n\n  const oneOverRadiiX = oneOverRadii.x;\n  const oneOverRadiiY = oneOverRadii.y;\n  const oneOverRadiiZ = oneOverRadii.z;\n\n  const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n  const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n  const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n\n  // Compute the squared ellipsoid norm.\n  const squaredNorm = x2 + y2 + z2;\n  const ratio = Math.sqrt(1.0 / squaredNorm);\n\n  // When very close to center or at center\n  if (!Number.isFinite(ratio)) {\n    return undefined;\n  }\n\n  // As an initial approximation, assume that the radial intersection is the projection point.\n  const intersection = scaleToGeodeticSurfaceIntersection;\n  intersection.copy(cartesian).scale(ratio);\n\n  // If the position is near the center, the iteration will not converge.\n  if (squaredNorm < centerToleranceSquared) {\n    return intersection.to(result);\n  }\n\n  const oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n  const oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n  const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n\n  // Use the gradient at the intersection point in place of the true unit normal.\n  // The difference in magnitude will be absorbed in the multiplier.\n  const gradient = scaleToGeodeticSurfaceGradient;\n  gradient.set(\n    intersection.x * oneOverRadiiSquaredX * 2.0,\n    intersection.y * oneOverRadiiSquaredY * 2.0,\n    intersection.z * oneOverRadiiSquaredZ * 2.0\n  );\n\n  // Compute the initial guess at the normal vector multiplier, lambda.\n  let lambda = ((1.0 - ratio) * scratchVector.len()) / (0.5 * gradient.len());\n  let correction = 0.0;\n\n  let xMultiplier;\n  let yMultiplier;\n  let zMultiplier;\n  let func;\n\n  do {\n    lambda -= correction;\n\n    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n\n    const xMultiplier2 = xMultiplier * xMultiplier;\n    const yMultiplier2 = yMultiplier * yMultiplier;\n    const zMultiplier2 = zMultiplier * zMultiplier;\n\n    const xMultiplier3 = xMultiplier2 * xMultiplier;\n    const yMultiplier3 = yMultiplier2 * yMultiplier;\n    const zMultiplier3 = zMultiplier2 * zMultiplier;\n\n    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n\n    // \"denominator\" here refers to the use of this expression in the velocity and acceleration\n    // computations in the sections to follow.\n    const denominator =\n      x2 * xMultiplier3 * oneOverRadiiSquaredX +\n      y2 * yMultiplier3 * oneOverRadiiSquaredY +\n      z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n\n    const derivative = -2.0 * denominator;\n\n    correction = func / derivative;\n  } while (Math.abs(func) > _MathUtils.EPSILON12);\n\n  return scratchVector.scale([xMultiplier, yMultiplier, zMultiplier]).to(result);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}