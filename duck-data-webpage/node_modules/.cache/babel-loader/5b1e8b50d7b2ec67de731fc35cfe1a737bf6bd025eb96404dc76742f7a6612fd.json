{"ast":null,"code":"export default class Martini {\n  constructor() {\n    let gridSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 257;\n    this.gridSize = gridSize;\n    const tileSize = gridSize - 1;\n    if (tileSize & tileSize - 1) throw new Error(`Expected grid size to be 2^n+1, got ${gridSize}.`);\n    this.numTriangles = tileSize * tileSize * 2 - 2;\n    this.numParentTriangles = this.numTriangles - tileSize * tileSize;\n    this.indices = new Uint32Array(this.gridSize * this.gridSize);\n\n    // coordinates for all possible triangles in an RTIN tile\n    this.coords = new Uint16Array(this.numTriangles * 4);\n\n    // get triangle coordinates from its index in an implicit binary tree\n    for (let i = 0; i < this.numTriangles; i++) {\n      let id = i + 2;\n      let ax = 0,\n        ay = 0,\n        bx = 0,\n        by = 0,\n        cx = 0,\n        cy = 0;\n      if (id & 1) {\n        bx = by = cx = tileSize; // bottom-left triangle\n      } else {\n        ax = ay = cy = tileSize; // top-right triangle\n      }\n      while ((id >>= 1) > 1) {\n        const mx = ax + bx >> 1;\n        const my = ay + by >> 1;\n        if (id & 1) {\n          // left half\n          bx = ax;\n          by = ay;\n          ax = cx;\n          ay = cy;\n        } else {\n          // right half\n          ax = bx;\n          ay = by;\n          bx = cx;\n          by = cy;\n        }\n        cx = mx;\n        cy = my;\n      }\n      const k = i * 4;\n      this.coords[k + 0] = ax;\n      this.coords[k + 1] = ay;\n      this.coords[k + 2] = bx;\n      this.coords[k + 3] = by;\n    }\n  }\n  createTile(terrain) {\n    return new Tile(terrain, this);\n  }\n}\nclass Tile {\n  constructor(terrain, martini) {\n    const size = martini.gridSize;\n    if (terrain.length !== size * size) throw new Error(`Expected terrain data of length ${size * size} (${size} x ${size}), got ${terrain.length}.`);\n    this.terrain = terrain;\n    this.martini = martini;\n    this.errors = new Float32Array(terrain.length);\n    this.update();\n  }\n  update() {\n    const {\n      numTriangles,\n      numParentTriangles,\n      coords,\n      gridSize: size\n    } = this.martini;\n    const {\n      terrain,\n      errors\n    } = this;\n\n    // iterate over all possible triangles, starting from the smallest level\n    for (let i = numTriangles - 1; i >= 0; i--) {\n      const k = i * 4;\n      const ax = coords[k + 0];\n      const ay = coords[k + 1];\n      const bx = coords[k + 2];\n      const by = coords[k + 3];\n      const mx = ax + bx >> 1;\n      const my = ay + by >> 1;\n      const cx = mx + my - ay;\n      const cy = my + ax - mx;\n\n      // calculate error in the middle of the long edge of the triangle\n      const interpolatedHeight = (terrain[ay * size + ax] + terrain[by * size + bx]) / 2;\n      const middleIndex = my * size + mx;\n      const middleError = Math.abs(interpolatedHeight - terrain[middleIndex]);\n      errors[middleIndex] = Math.max(errors[middleIndex], middleError);\n      if (i < numParentTriangles) {\n        // bigger triangles; accumulate error with children\n        const leftChildIndex = (ay + cy >> 1) * size + (ax + cx >> 1);\n        const rightChildIndex = (by + cy >> 1) * size + (bx + cx >> 1);\n        errors[middleIndex] = Math.max(errors[middleIndex], errors[leftChildIndex], errors[rightChildIndex]);\n      }\n    }\n  }\n  getMesh() {\n    let maxError = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const {\n      gridSize: size,\n      indices\n    } = this.martini;\n    const {\n      errors\n    } = this;\n    let numVertices = 0;\n    let numTriangles = 0;\n    const max = size - 1;\n\n    // use an index grid to keep track of vertices that were already used to avoid duplication\n    indices.fill(0);\n\n    // retrieve mesh in two stages that both traverse the error map:\n    // - countElements: find used vertices (and assign each an index), and count triangles (for minimum allocation)\n    // - processTriangle: fill the allocated vertices & triangles typed arrays\n\n    function countElements(ax, ay, bx, by, cx, cy) {\n      const mx = ax + bx >> 1;\n      const my = ay + by >> 1;\n      if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {\n        countElements(cx, cy, ax, ay, mx, my);\n        countElements(bx, by, cx, cy, mx, my);\n      } else {\n        indices[ay * size + ax] = indices[ay * size + ax] || ++numVertices;\n        indices[by * size + bx] = indices[by * size + bx] || ++numVertices;\n        indices[cy * size + cx] = indices[cy * size + cx] || ++numVertices;\n        numTriangles++;\n      }\n    }\n    countElements(0, 0, max, max, max, 0);\n    countElements(max, max, 0, 0, 0, max);\n    const vertices = new Uint16Array(numVertices * 2);\n    const triangles = new Uint32Array(numTriangles * 3);\n    let triIndex = 0;\n    function processTriangle(ax, ay, bx, by, cx, cy) {\n      const mx = ax + bx >> 1;\n      const my = ay + by >> 1;\n      if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {\n        // triangle doesn't approximate the surface well enough; drill down further\n        processTriangle(cx, cy, ax, ay, mx, my);\n        processTriangle(bx, by, cx, cy, mx, my);\n      } else {\n        // add a triangle\n        const a = indices[ay * size + ax] - 1;\n        const b = indices[by * size + bx] - 1;\n        const c = indices[cy * size + cx] - 1;\n        vertices[2 * a] = ax;\n        vertices[2 * a + 1] = ay;\n        vertices[2 * b] = bx;\n        vertices[2 * b + 1] = by;\n        vertices[2 * c] = cx;\n        vertices[2 * c + 1] = cy;\n        triangles[triIndex++] = a;\n        triangles[triIndex++] = b;\n        triangles[triIndex++] = c;\n      }\n    }\n    processTriangle(0, 0, max, max, max, 0);\n    processTriangle(max, max, 0, 0, 0, max);\n    return {\n      vertices,\n      triangles\n    };\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}