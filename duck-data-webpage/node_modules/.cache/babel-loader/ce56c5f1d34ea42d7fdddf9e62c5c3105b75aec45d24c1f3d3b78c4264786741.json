{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { XMLLoader } from '@loaders.gl/xml';\nimport { deepStrictEqual } from \"./deep-strict-equal.js\";\nimport rewind from '@turf/rewind';\nfunction noTransform() {\n  for (var _len = arguments.length, coords = new Array(_len), _key = 0; _key < _len; _key++) {\n    coords[_key] = arguments[_key];\n  }\n  return coords;\n}\n/**\n * Parses a typed data structure from raw XML for GML features\n * @note Error handlings is fairly weak\n */\nexport function parseGML(text, options) {\n  // GeoJSON | null {\n  const parsedXML = XMLLoader.parseTextSync?.(text, options);\n  options = {\n    transformCoords: noTransform,\n    stride: 2,\n    ...options\n  };\n  const context = createChildContext(parsedXML, options, {});\n  return parseGMLToGeometry(parsedXML, options, context);\n}\n/** Parse a GeoJSON geometry from GML XML */\nexport function parseGMLToGeometry(inputXML, options, context) {\n  const childContext = createChildContext(inputXML, options, context);\n  let geometry = null;\n  const [name, xml] = getFirstKeyValue(inputXML);\n  switch (name) {\n    // case 'gml:MultiPoint':\n    //   geometry = {\n    //     type: 'MultiPoint',\n    //     coordinates: parseMultiPoint(xml, options, childContext)\n    //   };\n    //   break;\n    case 'gml:LineString':\n      geometry = {\n        type: 'LineString',\n        coordinates: parseLinearRingOrLineString(xml, options, childContext)\n      };\n      break;\n    // case 'gml:MultiLineString':\n    //   geometry = {\n    //     type: 'MultiLineString',\n    //     coordinates: parseMultiLineString(xml, options, childContext)\n    //   };\n    //   break;\n    case 'gml:Polygon':\n    case 'gml:Rectangle':\n      geometry = {\n        type: 'Polygon',\n        coordinates: parsePolygonOrRectangle(xml, options, childContext)\n      };\n      break;\n    case 'gml:Surface':\n      geometry = {\n        type: 'MultiPolygon',\n        coordinates: parseSurface(xml, options, childContext)\n      };\n      break;\n    case 'gml:MultiSurface':\n      geometry = {\n        type: 'MultiPolygon',\n        coordinates: parseMultiSurface(xml, options, childContext)\n      };\n      break;\n    default:\n      return null;\n  }\n  // todo\n  return rewind(geometry, {\n    mutate: true\n  });\n}\n/** Parse a list of coordinates from a string */\nfunction parseCoords(s, options, context) {\n  const stride = context.srsDimension || options.stride || 2;\n  // Handle white space\n  const coords = s.replace(/\\s+/g, ' ').trim().split(' ');\n  if (coords.length === 0 || coords.length % stride !== 0) {\n    throw new Error(`invalid coordinates list (stride ${stride})`);\n  }\n  const points = [];\n  for (let i = 0; i < coords.length - 1; i += stride) {\n    const point = coords.slice(i, i + stride).map(parseFloat);\n    points.push(options.transformCoords?.(...point) || point);\n  }\n  return points;\n}\nexport function parsePosList(xml, options, context) {\n  const childContext = createChildContext(xml, options, context);\n  const coords = textOf(xml);\n  if (!coords) {\n    throw new Error('invalid gml:posList element');\n  }\n  return parseCoords(coords, options, childContext);\n}\nexport function parsePos(xml, options, context) {\n  const childContext = createChildContext(xml, options, context);\n  const coords = textOf(xml);\n  if (!coords) {\n    throw new Error('invalid gml:pos element');\n  }\n  const points = parseCoords(coords, options, childContext);\n  if (points.length !== 1) {\n    throw new Error('gml:pos must have 1 point');\n  }\n  return points[0];\n}\nexport function parsePoint(xml, options, context) {\n  const childContext = createChildContext(xml, options, context);\n  // TODO AV: Parse other gml:Point options\n  const pos = findIn(xml, 'gml:pos');\n  if (!pos) {\n    throw new Error('invalid gml:Point element, expected a gml:pos subelement');\n  }\n  return parsePos(pos, options, childContext);\n}\nexport function parseLinearRingOrLineString(xml, options, context) {\n  // or a LineStringSegment\n  const childContext = createChildContext(xml, options, context);\n  let points = [];\n  const posList = findIn(xml, 'gml:posList');\n  if (posList) {\n    points = parsePosList(posList, options, childContext);\n  } else {\n    for (const [childName, childXML] of Object.entries(xml)) {\n      switch (childName) {\n        case 'gml:Point':\n          points.push(parsePoint(childXML, options, childContext));\n          break;\n        case 'gml:pos':\n          points.push(parsePos(childXML, options, childContext));\n          break;\n        default:\n          continue;\n      }\n    }\n  }\n  if (points.length === 0) {\n    throw new Error(`${xml.name} must have > 0 points`);\n  }\n  return points;\n}\nexport function parseCurveSegments(xml, options, context) {\n  const points = [];\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:LineStringSegment':\n        const points2 = parseLinearRingOrLineString(childXML, options, context);\n        // remove overlapping\n        const end = points[points.length - 1];\n        const start = points2[0];\n        if (end && start && deepStrictEqual(end, start)) {\n          points2.shift();\n        }\n        points.push(...points2);\n        break;\n      default:\n        continue;\n    }\n  }\n  if (points.length === 0) {\n    throw new Error('gml:Curve > gml:segments must have > 0 points');\n  }\n  return points;\n}\nexport function parseRing(xml, options, context) {\n  const childContext = createChildContext(xml, options, context);\n  const points = [];\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:curveMember':\n        let points2;\n        const lineString = findIn(childXML, 'gml:LineString');\n        if (lineString) {\n          points2 = parseLinearRingOrLineString(lineString, options, childContext);\n        } else {\n          const segments = findIn(childXML, 'gml:Curve', 'gml:segments');\n          if (!segments) {\n            throw new Error(`invalid ${childName} element`);\n          }\n          points2 = parseCurveSegments(segments, options, childContext);\n        }\n        // remove overlapping\n        const end = points[points.length - 1];\n        const start = points2[0];\n        if (end && start && deepStrictEqual(end, start)) {\n          points2.shift();\n        }\n        points.push(...points2);\n        break;\n    }\n  }\n  if (points.length < 4) {\n    throw new Error(`${xml.name} must have >= 4 points`);\n  }\n  return points;\n}\nexport function parseExteriorOrInterior(xml, options, context) {\n  const linearRing = findIn(xml, 'gml:LinearRing');\n  if (linearRing) {\n    return parseLinearRingOrLineString(linearRing, options, context);\n  }\n  const ring = findIn(xml, 'gml:Ring');\n  if (!ring) {\n    throw new Error(`invalid ${xml.name} element`);\n  }\n  return parseRing(ring, options, context);\n}\nexport function parsePolygonOrRectangle(xml, options, context) {\n  // or PolygonPatch\n  const childContext = createChildContext(xml, options, context);\n  const exterior = findIn(xml, 'gml:exterior');\n  if (!exterior) {\n    throw new Error(`invalid ${xml.name} element`);\n  }\n  const pointLists = [parseExteriorOrInterior(exterior, options, childContext)];\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:interior':\n        pointLists.push(parseExteriorOrInterior(childXML, options, childContext));\n        break;\n    }\n  }\n  return pointLists;\n}\nexport function parseSurface(xml, options, context) {\n  const childContext = createChildContext(xml, options, context);\n  const patches = findIn(xml, 'gml:patches');\n  if (!patches) {\n    throw new Error(`invalid ${xml.name} element`);\n  }\n  const polygons = [];\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:PolygonPatch':\n      case 'gml:Rectangle':\n        polygons.push(parsePolygonOrRectangle(childXML, options, childContext));\n        break;\n      default:\n        continue;\n    }\n  }\n  if (polygons.length === 0) {\n    throw new Error(`${xml.name} must have > 0 polygons`);\n  }\n  return polygons;\n}\nexport function parseCompositeSurface(xml, options, context) {\n  const childContext = createChildContext(xml, options, context);\n  const polygons = [];\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:surfaceMember':\n      case 'gml:surfaceMembers':\n        const [c2Name, c2Xml] = getFirstKeyValue(childXML);\n        switch (c2Name) {\n          case 'gml:Surface':\n            polygons.push(...parseSurface(c2Xml, options, childContext));\n            break;\n          case 'gml:Polygon':\n            polygons.push(parsePolygonOrRectangle(c2Xml, options, childContext));\n            break;\n        }\n        break;\n    }\n  }\n  if (polygons.length === 0) {\n    throw new Error(`${xml.name} must have > 0 polygons`);\n  }\n  return polygons;\n}\nexport function parseMultiSurface(xml, options, context) {\n  let el = xml;\n  const surfaceMembers = findIn(xml, 'gml:LinearRing');\n  if (surfaceMembers) {\n    el = surfaceMembers;\n  }\n  const polygons = [];\n  for (const [childName, childXML] of Object.entries(el)) {\n    switch (childName) {\n      case 'gml:Surface':\n        const polygons2 = parseSurface(childXML, options, context);\n        polygons.push(...polygons2);\n        break;\n      case 'gml:surfaceMember':\n        const polygons3 = parseSurfaceMember(childXML, options, context);\n        polygons.push(...polygons3);\n        break;\n      case 'gml:surfaceMembers':\n        const polygonXML = findIn(childXML, 'gml:Polygon');\n        for (const surfaceMemberXML of polygonXML) {\n          const polygons3 = parseSurfaceMember(surfaceMemberXML, options, context);\n          polygons.push(...polygons3);\n        }\n        break;\n    }\n  }\n  if (polygons.length === 0) {\n    throw new Error(`${xml.name} must have > 0 polygons`);\n  }\n  return polygons;\n}\nfunction parseSurfaceMember(xml, options, context) {\n  const [childName, childXml] = getFirstKeyValue(xml);\n  switch (childName) {\n    case 'gml:CompositeSurface':\n      return parseCompositeSurface(childXml, options, context);\n    case 'gml:Surface':\n      return parseSurface(childXml, options, context);\n    case 'gml:Polygon':\n      return [parsePolygonOrRectangle(childXml, options, context)];\n  }\n  throw new Error(`${childName} must have polygons`);\n}\n// Helpers\nfunction textOf(el) {\n  if (typeof el !== 'string') {\n    throw new Error('expected string');\n  }\n  return el;\n}\nfunction findIn(root) {\n  let el = root;\n  for (var _len2 = arguments.length, tags = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    tags[_key2 - 1] = arguments[_key2];\n  }\n  for (const tag of tags) {\n    const child = el[tag];\n    if (!child) {\n      return null;\n    }\n    el = child;\n  }\n  return el;\n}\n/** @returns the first [key, value] pair in an object, or ['', null] if empty object */\nfunction getFirstKeyValue(object) {\n  if (object && typeof object === 'object') {\n    for (const [key, value] of Object.entries(object)) {\n      return [key, value];\n    }\n  }\n  return ['', null];\n}\n/** A bit heavyweight for just tracking dimension? */\nfunction createChildContext(xml, options, context) {\n  const srsDimensionAttribute = xml.attributes && xml.attributes.srsDimension;\n  if (srsDimensionAttribute) {\n    const srsDimension = parseInt(srsDimensionAttribute);\n    if (Number.isNaN(srsDimension) || srsDimension <= 0) {\n      throw new Error(`invalid srsDimension attribute value \"${srsDimensionAttribute}\", expected a positive integer`);\n    }\n    const childContext = Object.create(context);\n    childContext.srsDimension = srsDimension;\n    return childContext;\n  }\n  return context;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}