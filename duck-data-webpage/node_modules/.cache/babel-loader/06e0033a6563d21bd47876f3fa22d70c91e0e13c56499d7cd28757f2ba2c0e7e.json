{"ast":null,"code":"/* eslint-disable indent */\nimport { earcut } from '@math.gl/polygon';\n/**\n * Convert binary features to flat binary arrays. Similar to\n * `geojsonToBinary` helper function, except that it expects\n * a binary representation of the feature data, which enables\n * 2X-3X speed increase in parse speed, compared to using\n * geoJSON. See `binary-vector-tile/VectorTileFeature` for\n * data format detais\n *\n * @param features\n * @param geometryInfo\n * @param options\n * @returns filled arrays\n */\nexport function flatGeojsonToBinary(features, geometryInfo, options) {\n  const propArrayTypes = extractNumericPropTypes(features);\n  const numericPropKeys = Object.keys(propArrayTypes).filter(k => propArrayTypes[k] !== Array);\n  return fillArrays(features, {\n    propArrayTypes,\n    ...geometryInfo\n  }, {\n    numericPropKeys: options && options.numericPropKeys || numericPropKeys,\n    PositionDataType: options ? options.PositionDataType : Float32Array,\n    triangulate: options ? options.triangulate : true\n  });\n}\nexport const TEST_EXPORTS = {\n  extractNumericPropTypes\n};\n/**\n * Extracts properties that are always numeric\n *\n * @param features\n * @returns object with numeric types\n */\nfunction extractNumericPropTypes(features) {\n  const propArrayTypes = {};\n  for (const feature of features) {\n    if (feature.properties) {\n      for (const key in feature.properties) {\n        // If property has not been seen before, or if property has been numeric\n        // in all previous features, check if numeric in this feature\n        // If not numeric, Array is stored to prevent rechecking in the future\n        // Additionally, detects if 64 bit precision is required\n        const val = feature.properties[key];\n        propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);\n      }\n    }\n  }\n  return propArrayTypes;\n}\n/**\n * Fills coordinates into pre-allocated typed arrays\n *\n * @param features\n * @param geometryInfo\n * @param options\n * @returns an accessor object with value and size keys\n */\n// eslint-disable-next-line complexity, max-statements\nfunction fillArrays(features, geometryInfo, options) {\n  const {\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    polygonFeaturesCount,\n    propArrayTypes,\n    coordLength\n  } = geometryInfo;\n  const {\n    numericPropKeys = [],\n    PositionDataType = Float32Array,\n    triangulate = true\n  } = options;\n  const hasGlobalId = features[0] && 'id' in features[0];\n  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n  const points = {\n    type: 'Point',\n    positions: new PositionDataType(pointPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n    featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const lines = {\n    type: 'LineString',\n    pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),\n    positions: new PositionDataType(linePositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n    featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const polygons = {\n    type: 'Polygon',\n    polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),\n    primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),\n    positions: new PositionDataType(polygonPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n    featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  if (triangulate) {\n    polygons.triangles = [];\n  }\n  // Instantiate numeric properties arrays; one value per vertex\n  for (const object of [points, lines, polygons]) {\n    for (const propName of numericPropKeys) {\n      // If property has been numeric in all previous features in which the property existed, check\n      // if numeric in this feature\n      const T = propArrayTypes[propName];\n      object.numericProps[propName] = new T(object.positions.length / coordLength);\n    }\n  }\n  // Set last element of path/polygon indices as positions length\n  lines.pathIndices[linePathsCount] = linePositionsCount;\n  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n  const indexMap = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    const properties = feature.properties || {};\n    switch (geometry.type) {\n      case 'Point':\n        handlePoint(geometry, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          points.fields.push({\n            id: feature.id\n          });\n        }\n        indexMap.pointFeature++;\n        break;\n      case 'LineString':\n        handleLineString(geometry, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          lines.fields.push({\n            id: feature.id\n          });\n        }\n        indexMap.lineFeature++;\n        break;\n      case 'Polygon':\n        handlePolygon(geometry, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          polygons.fields.push({\n            id: feature.id\n          });\n        }\n        indexMap.polygonFeature++;\n        break;\n      default:\n        throw new Error('Invalid geometry type');\n    }\n    indexMap.feature++;\n  }\n  // Wrap each array in an accessor object with value and size keys\n  return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n/**\n * Fills (Multi)Point coordinates into points object of arrays\n *\n * @param geometry\n * @param points\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handlePoint(geometry, points, indexMap, coordLength, properties) {\n  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);\n  points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n  points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n  indexMap.pointPosition += nPositions;\n}\n/**\n * Fills (Multi)LineString coordinates into lines object of arrays\n *\n * @param geometry\n * @param lines\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handleLineString(geometry, lines, indexMap, coordLength, properties) {\n  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n  lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);\n  lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);\n  for (let i = 0, il = geometry.indices.length; i < il; ++i) {\n    // Extract range of data we are working with, defined by start\n    // and end indices (these index into the geometry.data array)\n    const start = geometry.indices[i];\n    const end = i === il - 1 ? geometry.data.length // last line, so read to end of data\n    : geometry.indices[i + 1]; // start index for next line\n    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;\n    indexMap.linePosition += (end - start) / coordLength;\n  }\n}\n/**\n * Fills (Multi)Polygon coordinates into polygons object of arrays\n *\n * @param geometry\n * @param polygons\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handlePolygon(geometry, polygons, indexMap, coordLength, properties) {\n  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n  polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n  polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n  // Unlike Point & LineString geometry.indices is a 2D array\n  for (let l = 0, ll = geometry.indices.length; l < ll; ++l) {\n    const startPosition = indexMap.polygonPosition;\n    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;\n    const areas = geometry.areas[l];\n    const indices = geometry.indices[l];\n    const nextIndices = geometry.indices[l + 1];\n    for (let i = 0, il = indices.length; i < il; ++i) {\n      const start = indices[i];\n      const end = i === il - 1 ?\n      // last line, so either read to:\n      nextIndices === undefined ? geometry.data.length // end of data (no next indices)\n      : nextIndices[0] // start of first line in nextIndices\n      : indices[i + 1]; // start index for next line\n      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;\n      indexMap.polygonPosition += (end - start) / coordLength;\n    }\n    const endPosition = indexMap.polygonPosition;\n    triangulatePolygon(polygons, areas, indices, {\n      startPosition,\n      endPosition,\n      coordLength\n    });\n  }\n}\n/**\n * Triangulate polygon using earcut\n *\n * @param polygons\n * @param areas\n * @param indices\n * @param param3\n */\nfunction triangulatePolygon(polygons, areas, indices, {\n  startPosition,\n  endPosition,\n  coordLength\n}) {\n  if (!polygons.triangles) {\n    return;\n  }\n  const start = startPosition * coordLength;\n  const end = endPosition * coordLength;\n  // Extract positions and holes for just this polygon\n  const polygonPositions = polygons.positions.subarray(start, end);\n  // Holes are referenced relative to outer polygon\n  const offset = indices[0];\n  const holes = indices.slice(1).map(n => (n - offset) / coordLength);\n  // Compute triangulation\n  const triangles = earcut(polygonPositions, holes, coordLength, areas);\n  // Indices returned by triangulation are relative to start\n  // of polygon, so we need to offset\n  for (let t = 0, tl = triangles.length; t < tl; ++t) {\n    polygons.triangles.push(startPosition + triangles[t]);\n  }\n}\n/**\n * Wraps an object containing array into accessors\n *\n * @param obj\n * @param size\n */\nfunction wrapProps(obj, size) {\n  const returnObj = {};\n  for (const key in obj) {\n    returnObj[key] = {\n      value: obj[key],\n      size\n    };\n  }\n  return returnObj;\n}\n/**\n * Wrap each array in an accessor object with value and size keys\n *\n * @param points\n * @param lines\n * @param polygons\n * @param coordLength\n * @returns object\n */\nfunction makeAccessorObjects(points, lines, polygons, coordLength) {\n  const binaryFeatures = {\n    shape: 'binary-feature-collection',\n    points: {\n      ...points,\n      positions: {\n        value: points.positions,\n        size: coordLength\n      },\n      globalFeatureIds: {\n        value: points.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: points.featureIds,\n        size: 1\n      },\n      numericProps: wrapProps(points.numericProps, 1)\n    },\n    lines: {\n      ...lines,\n      positions: {\n        value: lines.positions,\n        size: coordLength\n      },\n      pathIndices: {\n        value: lines.pathIndices,\n        size: 1\n      },\n      globalFeatureIds: {\n        value: lines.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: lines.featureIds,\n        size: 1\n      },\n      numericProps: wrapProps(lines.numericProps, 1)\n    },\n    polygons: {\n      ...polygons,\n      positions: {\n        value: polygons.positions,\n        size: coordLength\n      },\n      polygonIndices: {\n        value: polygons.polygonIndices,\n        size: 1\n      },\n      primitivePolygonIndices: {\n        value: polygons.primitivePolygonIndices,\n        size: 1\n      },\n      globalFeatureIds: {\n        value: polygons.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: polygons.featureIds,\n        size: 1\n      },\n      numericProps: wrapProps(polygons.numericProps, 1)\n    } // triangles not expected\n  };\n  if (binaryFeatures.polygons && polygons.triangles) {\n    binaryFeatures.polygons.triangles = {\n      value: new Uint32Array(polygons.triangles),\n      size: 1\n    };\n  }\n  return binaryFeatures;\n}\n/**\n * Add numeric properties to object\n *\n * @param object\n * @param properties\n * @param index\n * @param length\n */\nfunction fillNumericProperties(object, properties, index, length) {\n  for (const numericPropName in object.numericProps) {\n    if (numericPropName in properties) {\n      const value = properties[numericPropName];\n      object.numericProps[numericPropName].fill(value, index, index + length);\n    }\n  }\n}\n/**\n * Keep string properties in object\n *\n * @param properties\n * @param numericKeys\n * @returns object\n */\nfunction keepStringProperties(properties, numericKeys) {\n  const props = {};\n  for (const key in properties) {\n    if (!numericKeys.includes(key)) {\n      props[key] = properties[key];\n    }\n  }\n  return props;\n}\n/**\n *\n * Deduce correct array constructor to use for a given value\n *\n * @param x value to test\n * @param constructor previous constructor deduced\n * @returns PropArrayConstructor\n */\nfunction deduceArrayType(x, constructor) {\n  if (constructor === Array || !Number.isFinite(x)) {\n    return Array;\n  }\n  // If this or previous value required 64bits use Float64Array\n  return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;\n}","map":{"version":3,"names":["earcut","flatGeojsonToBinary","features","geometryInfo","options","propArrayTypes","extractNumericPropTypes","numericPropKeys","Object","keys","filter","k","Array","fillArrays","PositionDataType","Float32Array","triangulate","TEST_EXPORTS","feature","properties","key","val","deduceArrayType","pointPositionsCount","pointFeaturesCount","linePositionsCount","linePathsCount","lineFeaturesCount","polygonPositionsCount","polygonObjectsCount","polygonRingsCount","polygonFeaturesCount","coordLength","hasGlobalId","GlobalFeatureIdsDataType","length","Uint32Array","Uint16Array","points","type","positions","globalFeatureIds","featureIds","numericProps","fields","lines","pathIndices","polygons","polygonIndices","primitivePolygonIndices","triangles","object","propName","T","indexMap","pointPosition","pointFeature","linePosition","linePath","lineFeature","polygonPosition","polygonObject","polygonRing","polygonFeature","geometry","handlePoint","push","keepStringProperties","id","handleLineString","handlePolygon","Error","makeAccessorObjects","set","data","nPositions","fillNumericProperties","fill","i","il","indices","start","end","l","ll","startPosition","areas","nextIndices","undefined","endPosition","triangulatePolygon","polygonPositions","subarray","offset","holes","slice","map","n","t","tl","wrapProps","obj","size","returnObj","value","binaryFeatures","shape","index","numericPropName","numericKeys","props","includes","x","constructor","Number","isFinite","Float64Array","Math","fround"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/gis/dist/lib/binary-features/flat-geojson-to-binary.js"],"sourcesContent":["/* eslint-disable indent */\nimport { earcut } from '@math.gl/polygon';\n/**\n * Convert binary features to flat binary arrays. Similar to\n * `geojsonToBinary` helper function, except that it expects\n * a binary representation of the feature data, which enables\n * 2X-3X speed increase in parse speed, compared to using\n * geoJSON. See `binary-vector-tile/VectorTileFeature` for\n * data format detais\n *\n * @param features\n * @param geometryInfo\n * @param options\n * @returns filled arrays\n */\nexport function flatGeojsonToBinary(features, geometryInfo, options) {\n    const propArrayTypes = extractNumericPropTypes(features);\n    const numericPropKeys = Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array);\n    return fillArrays(features, {\n        propArrayTypes,\n        ...geometryInfo\n    }, {\n        numericPropKeys: (options && options.numericPropKeys) || numericPropKeys,\n        PositionDataType: options ? options.PositionDataType : Float32Array,\n        triangulate: options ? options.triangulate : true\n    });\n}\nexport const TEST_EXPORTS = {\n    extractNumericPropTypes\n};\n/**\n * Extracts properties that are always numeric\n *\n * @param features\n * @returns object with numeric types\n */\nfunction extractNumericPropTypes(features) {\n    const propArrayTypes = {};\n    for (const feature of features) {\n        if (feature.properties) {\n            for (const key in feature.properties) {\n                // If property has not been seen before, or if property has been numeric\n                // in all previous features, check if numeric in this feature\n                // If not numeric, Array is stored to prevent rechecking in the future\n                // Additionally, detects if 64 bit precision is required\n                const val = feature.properties[key];\n                propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);\n            }\n        }\n    }\n    return propArrayTypes;\n}\n/**\n * Fills coordinates into pre-allocated typed arrays\n *\n * @param features\n * @param geometryInfo\n * @param options\n * @returns an accessor object with value and size keys\n */\n// eslint-disable-next-line complexity, max-statements\nfunction fillArrays(features, geometryInfo, options) {\n    const { pointPositionsCount, pointFeaturesCount, linePositionsCount, linePathsCount, lineFeaturesCount, polygonPositionsCount, polygonObjectsCount, polygonRingsCount, polygonFeaturesCount, propArrayTypes, coordLength } = geometryInfo;\n    const { numericPropKeys = [], PositionDataType = Float32Array, triangulate = true } = options;\n    const hasGlobalId = features[0] && 'id' in features[0];\n    const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n    const points = {\n        type: 'Point',\n        positions: new PositionDataType(pointPositionsCount * coordLength),\n        globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n        featureIds: pointFeaturesCount > 65535\n            ? new Uint32Array(pointPositionsCount)\n            : new Uint16Array(pointPositionsCount),\n        numericProps: {},\n        properties: [],\n        fields: []\n    };\n    const lines = {\n        type: 'LineString',\n        pathIndices: linePositionsCount > 65535\n            ? new Uint32Array(linePathsCount + 1)\n            : new Uint16Array(linePathsCount + 1),\n        positions: new PositionDataType(linePositionsCount * coordLength),\n        globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n        featureIds: lineFeaturesCount > 65535\n            ? new Uint32Array(linePositionsCount)\n            : new Uint16Array(linePositionsCount),\n        numericProps: {},\n        properties: [],\n        fields: []\n    };\n    const polygons = {\n        type: 'Polygon',\n        polygonIndices: polygonPositionsCount > 65535\n            ? new Uint32Array(polygonObjectsCount + 1)\n            : new Uint16Array(polygonObjectsCount + 1),\n        primitivePolygonIndices: polygonPositionsCount > 65535\n            ? new Uint32Array(polygonRingsCount + 1)\n            : new Uint16Array(polygonRingsCount + 1),\n        positions: new PositionDataType(polygonPositionsCount * coordLength),\n        globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n        featureIds: polygonFeaturesCount > 65535\n            ? new Uint32Array(polygonPositionsCount)\n            : new Uint16Array(polygonPositionsCount),\n        numericProps: {},\n        properties: [],\n        fields: []\n    };\n    if (triangulate) {\n        polygons.triangles = [];\n    }\n    // Instantiate numeric properties arrays; one value per vertex\n    for (const object of [points, lines, polygons]) {\n        for (const propName of numericPropKeys) {\n            // If property has been numeric in all previous features in which the property existed, check\n            // if numeric in this feature\n            const T = propArrayTypes[propName];\n            object.numericProps[propName] = new T(object.positions.length / coordLength);\n        }\n    }\n    // Set last element of path/polygon indices as positions length\n    lines.pathIndices[linePathsCount] = linePositionsCount;\n    polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n    polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n    const indexMap = {\n        pointPosition: 0,\n        pointFeature: 0,\n        linePosition: 0,\n        linePath: 0,\n        lineFeature: 0,\n        polygonPosition: 0,\n        polygonObject: 0,\n        polygonRing: 0,\n        polygonFeature: 0,\n        feature: 0\n    };\n    for (const feature of features) {\n        const geometry = feature.geometry;\n        const properties = feature.properties || {};\n        switch (geometry.type) {\n            case 'Point':\n                handlePoint(geometry, points, indexMap, coordLength, properties);\n                points.properties.push(keepStringProperties(properties, numericPropKeys));\n                if (hasGlobalId) {\n                    points.fields.push({ id: feature.id });\n                }\n                indexMap.pointFeature++;\n                break;\n            case 'LineString':\n                handleLineString(geometry, lines, indexMap, coordLength, properties);\n                lines.properties.push(keepStringProperties(properties, numericPropKeys));\n                if (hasGlobalId) {\n                    lines.fields.push({ id: feature.id });\n                }\n                indexMap.lineFeature++;\n                break;\n            case 'Polygon':\n                handlePolygon(geometry, polygons, indexMap, coordLength, properties);\n                polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n                if (hasGlobalId) {\n                    polygons.fields.push({ id: feature.id });\n                }\n                indexMap.polygonFeature++;\n                break;\n            default:\n                throw new Error('Invalid geometry type');\n        }\n        indexMap.feature++;\n    }\n    // Wrap each array in an accessor object with value and size keys\n    return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n/**\n * Fills (Multi)Point coordinates into points object of arrays\n *\n * @param geometry\n * @param points\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handlePoint(geometry, points, indexMap, coordLength, properties) {\n    points.positions.set(geometry.data, indexMap.pointPosition * coordLength);\n    const nPositions = geometry.data.length / coordLength;\n    fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);\n    points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n    points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n    indexMap.pointPosition += nPositions;\n}\n/**\n * Fills (Multi)LineString coordinates into lines object of arrays\n *\n * @param geometry\n * @param lines\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handleLineString(geometry, lines, indexMap, coordLength, properties) {\n    lines.positions.set(geometry.data, indexMap.linePosition * coordLength);\n    const nPositions = geometry.data.length / coordLength;\n    fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n    lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);\n    lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);\n    for (let i = 0, il = geometry.indices.length; i < il; ++i) {\n        // Extract range of data we are working with, defined by start\n        // and end indices (these index into the geometry.data array)\n        const start = geometry.indices[i];\n        const end = i === il - 1\n            ? geometry.data.length // last line, so read to end of data\n            : geometry.indices[i + 1]; // start index for next line\n        lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;\n        indexMap.linePosition += (end - start) / coordLength;\n    }\n}\n/**\n * Fills (Multi)Polygon coordinates into polygons object of arrays\n *\n * @param geometry\n * @param polygons\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handlePolygon(geometry, polygons, indexMap, coordLength, properties) {\n    polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);\n    const nPositions = geometry.data.length / coordLength;\n    fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n    polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n    polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n    // Unlike Point & LineString geometry.indices is a 2D array\n    for (let l = 0, ll = geometry.indices.length; l < ll; ++l) {\n        const startPosition = indexMap.polygonPosition;\n        polygons.polygonIndices[indexMap.polygonObject++] = startPosition;\n        const areas = geometry.areas[l];\n        const indices = geometry.indices[l];\n        const nextIndices = geometry.indices[l + 1];\n        for (let i = 0, il = indices.length; i < il; ++i) {\n            const start = indices[i];\n            const end = i === il - 1\n                ? // last line, so either read to:\n                    nextIndices === undefined\n                        ? geometry.data.length // end of data (no next indices)\n                        : nextIndices[0] // start of first line in nextIndices\n                : indices[i + 1]; // start index for next line\n            polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;\n            indexMap.polygonPosition += (end - start) / coordLength;\n        }\n        const endPosition = indexMap.polygonPosition;\n        triangulatePolygon(polygons, areas, indices, { startPosition, endPosition, coordLength });\n    }\n}\n/**\n * Triangulate polygon using earcut\n *\n * @param polygons\n * @param areas\n * @param indices\n * @param param3\n */\nfunction triangulatePolygon(polygons, areas, indices, { startPosition, endPosition, coordLength }) {\n    if (!polygons.triangles) {\n        return;\n    }\n    const start = startPosition * coordLength;\n    const end = endPosition * coordLength;\n    // Extract positions and holes for just this polygon\n    const polygonPositions = polygons.positions.subarray(start, end);\n    // Holes are referenced relative to outer polygon\n    const offset = indices[0];\n    const holes = indices.slice(1).map((n) => (n - offset) / coordLength);\n    // Compute triangulation\n    const triangles = earcut(polygonPositions, holes, coordLength, areas);\n    // Indices returned by triangulation are relative to start\n    // of polygon, so we need to offset\n    for (let t = 0, tl = triangles.length; t < tl; ++t) {\n        polygons.triangles.push(startPosition + triangles[t]);\n    }\n}\n/**\n * Wraps an object containing array into accessors\n *\n * @param obj\n * @param size\n */\nfunction wrapProps(obj, size) {\n    const returnObj = {};\n    for (const key in obj) {\n        returnObj[key] = { value: obj[key], size };\n    }\n    return returnObj;\n}\n/**\n * Wrap each array in an accessor object with value and size keys\n *\n * @param points\n * @param lines\n * @param polygons\n * @param coordLength\n * @returns object\n */\nfunction makeAccessorObjects(points, lines, polygons, coordLength) {\n    const binaryFeatures = {\n        shape: 'binary-feature-collection',\n        points: {\n            ...points,\n            positions: { value: points.positions, size: coordLength },\n            globalFeatureIds: { value: points.globalFeatureIds, size: 1 },\n            featureIds: { value: points.featureIds, size: 1 },\n            numericProps: wrapProps(points.numericProps, 1)\n        },\n        lines: {\n            ...lines,\n            positions: { value: lines.positions, size: coordLength },\n            pathIndices: { value: lines.pathIndices, size: 1 },\n            globalFeatureIds: { value: lines.globalFeatureIds, size: 1 },\n            featureIds: { value: lines.featureIds, size: 1 },\n            numericProps: wrapProps(lines.numericProps, 1)\n        },\n        polygons: {\n            ...polygons,\n            positions: { value: polygons.positions, size: coordLength },\n            polygonIndices: { value: polygons.polygonIndices, size: 1 },\n            primitivePolygonIndices: { value: polygons.primitivePolygonIndices, size: 1 },\n            globalFeatureIds: { value: polygons.globalFeatureIds, size: 1 },\n            featureIds: { value: polygons.featureIds, size: 1 },\n            numericProps: wrapProps(polygons.numericProps, 1)\n        } // triangles not expected\n    };\n    if (binaryFeatures.polygons && polygons.triangles) {\n        binaryFeatures.polygons.triangles = { value: new Uint32Array(polygons.triangles), size: 1 };\n    }\n    return binaryFeatures;\n}\n/**\n * Add numeric properties to object\n *\n * @param object\n * @param properties\n * @param index\n * @param length\n */\nfunction fillNumericProperties(object, properties, index, length) {\n    for (const numericPropName in object.numericProps) {\n        if (numericPropName in properties) {\n            const value = properties[numericPropName];\n            object.numericProps[numericPropName].fill(value, index, index + length);\n        }\n    }\n}\n/**\n * Keep string properties in object\n *\n * @param properties\n * @param numericKeys\n * @returns object\n */\nfunction keepStringProperties(properties, numericKeys) {\n    const props = {};\n    for (const key in properties) {\n        if (!numericKeys.includes(key)) {\n            props[key] = properties[key];\n        }\n    }\n    return props;\n}\n/**\n *\n * Deduce correct array constructor to use for a given value\n *\n * @param x value to test\n * @param constructor previous constructor deduced\n * @returns PropArrayConstructor\n */\nfunction deduceArrayType(x, constructor) {\n    if (constructor === Array || !Number.isFinite(x)) {\n        return Array;\n    }\n    // If this or previous value required 64bits use Float64Array\n    return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}