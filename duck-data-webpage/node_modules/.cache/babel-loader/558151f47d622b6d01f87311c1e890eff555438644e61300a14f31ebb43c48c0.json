{"ast":null,"code":"// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\n/* eslint-disable camelcase */\nimport { sliceArrayBuffer, parseFromContext } from '@loaders.gl/loader-utils';\nimport { DracoLoader } from '@loaders.gl/draco';\nimport { GLTFScenegraph } from \"../api/gltf-scenegraph.js\";\nimport { getGLTFAccessors, getGLTFAccessor } from \"../gltf-utils/gltf-attribute-utils.js\";\nconst KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\n/** Extension name */\nexport const name = KHR_DRACO_MESH_COMPRESSION;\nexport function preprocess(gltfData, options, context) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      // TODO - Remove fallback accessors to make sure we don't load unnecessary buffers\n    }\n  }\n}\nexport async function decode(gltfData, options, context) {\n  if (!options?.gltf?.decompressMeshes) {\n    return;\n  }\n  const scenegraph = new GLTFScenegraph(gltfData);\n  const promises = [];\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      promises.push(decompressPrimitive(scenegraph, primitive, options, context));\n    }\n  }\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n  // We have now decompressed all primitives, so remove the top-level extension\n  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\nexport function encode(gltfData, options = {}) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  for (const mesh of scenegraph.json.meshes || []) {\n    // eslint-disable-next-line camelcase\n    // @ts-ignore\n    compressMesh(mesh, options);\n    // NOTE: Only add the extension if something was actually compressed\n    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n}\n// DECODE\n// Unpacks one mesh primitive and removes the extension from the primitive\n// DracoDecoder needs to be imported and registered by app\n// Returns: Promise that resolves when all pending draco decoder jobs for this mesh complete\n// TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\nasync function decompressPrimitive(scenegraph, primitive, options, context) {\n  const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n  if (!dracoExtension) {\n    return;\n  }\n  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);\n  // TODO - parse does not yet deal well with byte offsets embedded in typed arrays. Copy buffer\n  // TODO - remove when `parse` is fixed to handle `byteOffset`s\n  const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset); // , buffer.byteLength);\n  const dracoOptions = {\n    ...options\n  };\n  // TODO - remove hack: The entire tileset might be included, too expensive to serialize\n  delete dracoOptions['3d-tiles'];\n  const decodedData = await parseFromContext(bufferCopy, DracoLoader, dracoOptions, context);\n  const decodedAttributes = getGLTFAccessors(decodedData.attributes);\n  // Restore min/max values\n  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {\n    if (attributeName in primitive.attributes) {\n      const accessorIndex = primitive.attributes[attributeName];\n      const accessor = scenegraph.getAccessor(accessorIndex);\n      if (accessor?.min && accessor?.max) {\n        decodedAttribute.min = accessor.min;\n        decodedAttribute.max = accessor.max;\n      }\n    }\n  }\n  // @ts-ignore\n  primitive.attributes = decodedAttributes;\n  if (decodedData.indices) {\n    // @ts-ignore\n    primitive.indices = getGLTFAccessor(decodedData.indices);\n  }\n  // Extension has been processed, delete it\n  scenegraph.removeObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n  checkPrimitive(primitive);\n}\n// ENCODE\n// eslint-disable-next-line max-len\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\nfunction compressMesh(attributes, indices, mode = 4, options, context) {\n  if (!options.DracoWriter) {\n    throw new Error('options.gltf.DracoWriter not provided');\n  }\n  // TODO - use DracoWriter using encode w/ registered DracoWriter...\n  const compressedData = options.DracoWriter.encodeSync({\n    attributes\n  });\n  // Draco compression may change the order and number of vertices in a mesh.\n  // To satisfy the requirement that accessors properties be correct for both\n  // compressed and uncompressed data, generators should create uncompressed\n  // attributes and indices using data that has been decompressed from the Draco buffer,\n  // rather than the original source data.\n  // @ts-ignore TODO this needs to be fixed\n  const decodedData = context?.parseSync?.({\n    attributes\n  });\n  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n  const bufferViewIndex = options.addBufferView(compressedData);\n  const glTFMesh = {\n    primitives: [{\n      attributes: fauxAccessors,\n      // TODO - verify with spec\n      mode,\n      // GL.POINTS\n      extensions: {\n        [KHR_DRACO_MESH_COMPRESSION]: {\n          bufferView: bufferViewIndex,\n          attributes: fauxAccessors // TODO - verify with spec\n        }\n      }\n    }]\n  };\n  return glTFMesh;\n}\n// UTILS\nfunction checkPrimitive(primitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('glTF: Empty primitive detected: Draco decompression failure?');\n  }\n}\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n  for (const mesh of scenegraph.json.meshes || []) {\n    for (const primitive of mesh.primitives) {\n      yield primitive;\n    }\n  }\n}","map":{"version":3,"names":["sliceArrayBuffer","parseFromContext","DracoLoader","GLTFScenegraph","getGLTFAccessors","getGLTFAccessor","KHR_DRACO_MESH_COMPRESSION","name","preprocess","gltfData","options","context","scenegraph","primitive","makeMeshPrimitiveIterator","getObjectExtension","decode","gltf","decompressMeshes","promises","push","decompressPrimitive","Promise","all","removeExtension","encode","mesh","json","meshes","compressMesh","addRequiredExtension","dracoExtension","buffer","getTypedArrayForBufferView","bufferView","bufferCopy","byteOffset","dracoOptions","decodedData","decodedAttributes","attributes","attributeName","decodedAttribute","Object","entries","accessorIndex","accessor","getAccessor","min","max","indices","removeObjectExtension","checkPrimitive","mode","DracoWriter","Error","compressedData","encodeSync","parseSync","fauxAccessors","_addFauxAttributes","bufferViewIndex","addBufferView","glTFMesh","primitives","extensions","keys","length"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_draco_mesh_compression.js"],"sourcesContent":["// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\n/* eslint-disable camelcase */\nimport { sliceArrayBuffer, parseFromContext } from '@loaders.gl/loader-utils';\nimport { DracoLoader } from '@loaders.gl/draco';\nimport { GLTFScenegraph } from \"../api/gltf-scenegraph.js\";\nimport { getGLTFAccessors, getGLTFAccessor } from \"../gltf-utils/gltf-attribute-utils.js\";\nconst KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\n/** Extension name */\nexport const name = KHR_DRACO_MESH_COMPRESSION;\nexport function preprocess(gltfData, options, context) {\n    const scenegraph = new GLTFScenegraph(gltfData);\n    for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n        if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n            // TODO - Remove fallback accessors to make sure we don't load unnecessary buffers\n        }\n    }\n}\nexport async function decode(gltfData, options, context) {\n    if (!options?.gltf?.decompressMeshes) {\n        return;\n    }\n    const scenegraph = new GLTFScenegraph(gltfData);\n    const promises = [];\n    for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n        if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n            promises.push(decompressPrimitive(scenegraph, primitive, options, context));\n        }\n    }\n    // Decompress meshes in parallel\n    await Promise.all(promises);\n    // We have now decompressed all primitives, so remove the top-level extension\n    scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\nexport function encode(gltfData, options = {}) {\n    const scenegraph = new GLTFScenegraph(gltfData);\n    for (const mesh of scenegraph.json.meshes || []) {\n        // eslint-disable-next-line camelcase\n        // @ts-ignore\n        compressMesh(mesh, options);\n        // NOTE: Only add the extension if something was actually compressed\n        scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n    }\n}\n// DECODE\n// Unpacks one mesh primitive and removes the extension from the primitive\n// DracoDecoder needs to be imported and registered by app\n// Returns: Promise that resolves when all pending draco decoder jobs for this mesh complete\n// TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\nasync function decompressPrimitive(scenegraph, primitive, options, context) {\n    const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n    if (!dracoExtension) {\n        return;\n    }\n    const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);\n    // TODO - parse does not yet deal well with byte offsets embedded in typed arrays. Copy buffer\n    // TODO - remove when `parse` is fixed to handle `byteOffset`s\n    const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset); // , buffer.byteLength);\n    const dracoOptions = { ...options };\n    // TODO - remove hack: The entire tileset might be included, too expensive to serialize\n    delete dracoOptions['3d-tiles'];\n    const decodedData = await parseFromContext(bufferCopy, DracoLoader, dracoOptions, context);\n    const decodedAttributes = getGLTFAccessors(decodedData.attributes);\n    // Restore min/max values\n    for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {\n        if (attributeName in primitive.attributes) {\n            const accessorIndex = primitive.attributes[attributeName];\n            const accessor = scenegraph.getAccessor(accessorIndex);\n            if (accessor?.min && accessor?.max) {\n                decodedAttribute.min = accessor.min;\n                decodedAttribute.max = accessor.max;\n            }\n        }\n    }\n    // @ts-ignore\n    primitive.attributes = decodedAttributes;\n    if (decodedData.indices) {\n        // @ts-ignore\n        primitive.indices = getGLTFAccessor(decodedData.indices);\n    }\n    // Extension has been processed, delete it\n    scenegraph.removeObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n    checkPrimitive(primitive);\n}\n// ENCODE\n// eslint-disable-next-line max-len\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\nfunction compressMesh(attributes, indices, mode = 4, options, context) {\n    if (!options.DracoWriter) {\n        throw new Error('options.gltf.DracoWriter not provided');\n    }\n    // TODO - use DracoWriter using encode w/ registered DracoWriter...\n    const compressedData = options.DracoWriter.encodeSync({ attributes });\n    // Draco compression may change the order and number of vertices in a mesh.\n    // To satisfy the requirement that accessors properties be correct for both\n    // compressed and uncompressed data, generators should create uncompressed\n    // attributes and indices using data that has been decompressed from the Draco buffer,\n    // rather than the original source data.\n    // @ts-ignore TODO this needs to be fixed\n    const decodedData = context?.parseSync?.({ attributes });\n    const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n    const bufferViewIndex = options.addBufferView(compressedData);\n    const glTFMesh = {\n        primitives: [\n            {\n                attributes: fauxAccessors, // TODO - verify with spec\n                mode, // GL.POINTS\n                extensions: {\n                    [KHR_DRACO_MESH_COMPRESSION]: {\n                        bufferView: bufferViewIndex,\n                        attributes: fauxAccessors // TODO - verify with spec\n                    }\n                }\n            }\n        ]\n    };\n    return glTFMesh;\n}\n// UTILS\nfunction checkPrimitive(primitive) {\n    if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n        throw new Error('glTF: Empty primitive detected: Draco decompression failure?');\n    }\n}\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n    for (const mesh of scenegraph.json.meshes || []) {\n        for (const primitive of mesh.primitives) {\n            yield primitive;\n        }\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,gBAAgB,EAAEC,gBAAgB,QAAQ,0BAA0B;AAC7E,SAASC,WAAW,QAAQ,mBAAmB;AAC/C,SAASC,cAAc,QAAQ,2BAA2B;AAC1D,SAASC,gBAAgB,EAAEC,eAAe,QAAQ,uCAAuC;AACzF,MAAMC,0BAA0B,GAAG,4BAA4B;AAC/D;AACA,OAAO,MAAMC,IAAI,GAAGD,0BAA0B;AAC9C,OAAO,SAASE,UAAUA,CAACC,QAAQ,EAAEC,OAAO,EAAEC,OAAO,EAAE;EACnD,MAAMC,UAAU,GAAG,IAAIT,cAAc,CAACM,QAAQ,CAAC;EAC/C,KAAK,MAAMI,SAAS,IAAIC,yBAAyB,CAACF,UAAU,CAAC,EAAE;IAC3D,IAAIA,UAAU,CAACG,kBAAkB,CAACF,SAAS,EAAEP,0BAA0B,CAAC,EAAE;MACtE;IAAA;EAER;AACJ;AACA,OAAO,eAAeU,MAAMA,CAACP,QAAQ,EAAEC,OAAO,EAAEC,OAAO,EAAE;EACrD,IAAI,CAACD,OAAO,EAAEO,IAAI,EAAEC,gBAAgB,EAAE;IAClC;EACJ;EACA,MAAMN,UAAU,GAAG,IAAIT,cAAc,CAACM,QAAQ,CAAC;EAC/C,MAAMU,QAAQ,GAAG,EAAE;EACnB,KAAK,MAAMN,SAAS,IAAIC,yBAAyB,CAACF,UAAU,CAAC,EAAE;IAC3D,IAAIA,UAAU,CAACG,kBAAkB,CAACF,SAAS,EAAEP,0BAA0B,CAAC,EAAE;MACtEa,QAAQ,CAACC,IAAI,CAACC,mBAAmB,CAACT,UAAU,EAAEC,SAAS,EAAEH,OAAO,EAAEC,OAAO,CAAC,CAAC;IAC/E;EACJ;EACA;EACA,MAAMW,OAAO,CAACC,GAAG,CAACJ,QAAQ,CAAC;EAC3B;EACAP,UAAU,CAACY,eAAe,CAAClB,0BAA0B,CAAC;AAC1D;AACA,OAAO,SAASmB,MAAMA,CAAChB,QAAQ,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EAC3C,MAAME,UAAU,GAAG,IAAIT,cAAc,CAACM,QAAQ,CAAC;EAC/C,KAAK,MAAMiB,IAAI,IAAId,UAAU,CAACe,IAAI,CAACC,MAAM,IAAI,EAAE,EAAE;IAC7C;IACA;IACAC,YAAY,CAACH,IAAI,EAAEhB,OAAO,CAAC;IAC3B;IACAE,UAAU,CAACkB,oBAAoB,CAACxB,0BAA0B,CAAC;EAC/D;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,eAAee,mBAAmBA,CAACT,UAAU,EAAEC,SAAS,EAAEH,OAAO,EAAEC,OAAO,EAAE;EACxE,MAAMoB,cAAc,GAAGnB,UAAU,CAACG,kBAAkB,CAACF,SAAS,EAAEP,0BAA0B,CAAC;EAC3F,IAAI,CAACyB,cAAc,EAAE;IACjB;EACJ;EACA,MAAMC,MAAM,GAAGpB,UAAU,CAACqB,0BAA0B,CAACF,cAAc,CAACG,UAAU,CAAC;EAC/E;EACA;EACA,MAAMC,UAAU,GAAGnC,gBAAgB,CAACgC,MAAM,CAACA,MAAM,EAAEA,MAAM,CAACI,UAAU,CAAC,CAAC,CAAC;EACvE,MAAMC,YAAY,GAAG;IAAE,GAAG3B;EAAQ,CAAC;EACnC;EACA,OAAO2B,YAAY,CAAC,UAAU,CAAC;EAC/B,MAAMC,WAAW,GAAG,MAAMrC,gBAAgB,CAACkC,UAAU,EAAEjC,WAAW,EAAEmC,YAAY,EAAE1B,OAAO,CAAC;EAC1F,MAAM4B,iBAAiB,GAAGnC,gBAAgB,CAACkC,WAAW,CAACE,UAAU,CAAC;EAClE;EACA,KAAK,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACL,iBAAiB,CAAC,EAAE;IAC/E,IAAIE,aAAa,IAAI5B,SAAS,CAAC2B,UAAU,EAAE;MACvC,MAAMK,aAAa,GAAGhC,SAAS,CAAC2B,UAAU,CAACC,aAAa,CAAC;MACzD,MAAMK,QAAQ,GAAGlC,UAAU,CAACmC,WAAW,CAACF,aAAa,CAAC;MACtD,IAAIC,QAAQ,EAAEE,GAAG,IAAIF,QAAQ,EAAEG,GAAG,EAAE;QAChCP,gBAAgB,CAACM,GAAG,GAAGF,QAAQ,CAACE,GAAG;QACnCN,gBAAgB,CAACO,GAAG,GAAGH,QAAQ,CAACG,GAAG;MACvC;IACJ;EACJ;EACA;EACApC,SAAS,CAAC2B,UAAU,GAAGD,iBAAiB;EACxC,IAAID,WAAW,CAACY,OAAO,EAAE;IACrB;IACArC,SAAS,CAACqC,OAAO,GAAG7C,eAAe,CAACiC,WAAW,CAACY,OAAO,CAAC;EAC5D;EACA;EACAtC,UAAU,CAACuC,qBAAqB,CAACtC,SAAS,EAAEP,0BAA0B,CAAC;EACvE8C,cAAc,CAACvC,SAAS,CAAC;AAC7B;AACA;AACA;AACA;AACA,SAASgB,YAAYA,CAACW,UAAU,EAAEU,OAAO,EAAEG,IAAI,GAAG,CAAC,EAAE3C,OAAO,EAAEC,OAAO,EAAE;EACnE,IAAI,CAACD,OAAO,CAAC4C,WAAW,EAAE;IACtB,MAAM,IAAIC,KAAK,CAAC,uCAAuC,CAAC;EAC5D;EACA;EACA,MAAMC,cAAc,GAAG9C,OAAO,CAAC4C,WAAW,CAACG,UAAU,CAAC;IAAEjB;EAAW,CAAC,CAAC;EACrE;EACA;EACA;EACA;EACA;EACA;EACA,MAAMF,WAAW,GAAG3B,OAAO,EAAE+C,SAAS,GAAG;IAAElB;EAAW,CAAC,CAAC;EACxD,MAAMmB,aAAa,GAAGjD,OAAO,CAACkD,kBAAkB,CAACtB,WAAW,CAACE,UAAU,CAAC;EACxE,MAAMqB,eAAe,GAAGnD,OAAO,CAACoD,aAAa,CAACN,cAAc,CAAC;EAC7D,MAAMO,QAAQ,GAAG;IACbC,UAAU,EAAE,CACR;MACIxB,UAAU,EAAEmB,aAAa;MAAE;MAC3BN,IAAI;MAAE;MACNY,UAAU,EAAE;QACR,CAAC3D,0BAA0B,GAAG;UAC1B4B,UAAU,EAAE2B,eAAe;UAC3BrB,UAAU,EAAEmB,aAAa,CAAC;QAC9B;MACJ;IACJ,CAAC;EAET,CAAC;EACD,OAAOI,QAAQ;AACnB;AACA;AACA,SAASX,cAAcA,CAACvC,SAAS,EAAE;EAC/B,IAAI,CAACA,SAAS,CAAC2B,UAAU,IAAIG,MAAM,CAACuB,IAAI,CAACrD,SAAS,CAAC2B,UAAU,CAAC,CAAC2B,MAAM,GAAG,CAAC,EAAE;IACvE,MAAM,IAAIZ,KAAK,CAAC,8DAA8D,CAAC;EACnF;AACJ;AACA,UAAUzC,yBAAyBA,CAACF,UAAU,EAAE;EAC5C,KAAK,MAAMc,IAAI,IAAId,UAAU,CAACe,IAAI,CAACC,MAAM,IAAI,EAAE,EAAE;IAC7C,KAAK,MAAMf,SAAS,IAAIa,IAAI,CAACsC,UAAU,EAAE;MACrC,MAAMnD,SAAS;IACnB;EACJ;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}