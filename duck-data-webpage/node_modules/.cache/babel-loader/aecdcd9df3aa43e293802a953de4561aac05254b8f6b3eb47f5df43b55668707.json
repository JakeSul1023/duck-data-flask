{"ast":null,"code":"// luma.gl, MIT license\n// Copyright (c) vis.gl contributors\nimport { loadImageBitmap } from \"../application-utils/load-file.js\";\nimport { uid } from \"../utils/uid.js\";\n/**\n * It is very convenient to be able to initialize textures with promises\n * This can add considerable complexity to the Texture class, and doesn't\n * fit with the immutable nature of WebGPU resources.\n * Instead, luma.gl offers async textures as a separate class.\n */\nexport class AsyncTexture {\n  device;\n  id;\n  // TODO - should we type these as possibly `null`? It will make usage harder?\n  // @ts-expect-error\n  texture;\n  // @ts-expect-error\n  sampler;\n  // @ts-expect-error\n  view;\n  ready;\n  isReady = false;\n  destroyed = false;\n  resolveReady = () => {};\n  rejectReady = () => {};\n  get [Symbol.toStringTag]() {\n    return 'AsyncTexture';\n  }\n  toString() {\n    return `AsyncTexture:\"${this.id}\"(${this.isReady ? 'ready' : 'loading'})`;\n  }\n  constructor(device, props) {\n    this.device = device;\n    this.id = props.id || uid('async-texture');\n    // this.id = typeof props?.data === 'string' ? props.data.slice(-20) : uid('async-texture');\n    // Signature: new AsyncTexture(device, {data: url})\n    if (typeof props?.data === 'string' && props.dimension === '2d') {\n      props = {\n        ...props,\n        data: loadImageBitmap(props.data)\n      };\n    }\n    this.ready = new Promise((resolve, reject) => {\n      this.resolveReady = () => {\n        this.isReady = true;\n        resolve();\n      };\n      this.rejectReady = reject;\n    });\n    this.initAsync(props);\n  }\n  async initAsync(props) {\n    let resolveReady;\n    let rejectReady;\n    const asyncData = props.data;\n    const data = await awaitAllPromises(asyncData).then(resolveReady, rejectReady);\n    // Check that we haven't been destroyed while waiting for texture data to load\n    if (this.destroyed) {\n      return;\n    }\n    // Now we can actually create the texture\n    // @ts-expect-error Discriminated union\n    const syncProps = {\n      ...props,\n      data\n    };\n    this.texture = this.device.createTexture(syncProps);\n    this.sampler = this.texture.sampler;\n    this.view = this.texture.view;\n    this.isReady = true;\n  }\n  destroy() {\n    if (this.texture) {\n      this.texture.destroy();\n      // @ts-expect-error\n      this.texture = null;\n    }\n    this.destroyed = true;\n  }\n  /**\n   * Textures are immutable and cannot be resized after creation,\n   * but we can create a similar texture with the same parameters but a new size.\n   * @note Does not copy contents of the texture\n   * @todo Abort pending promise and create a texture with the new size?\n   */\n  resize(size) {\n    if (!this.isReady) {\n      throw new Error('Cannot resize texture before it is ready');\n    }\n    if (size.width === this.texture.width && size.height === this.texture.height) {\n      return false;\n    }\n    if (this.texture) {\n      const texture = this.texture;\n      this.texture = texture.clone(size);\n      texture.destroy();\n    }\n    return true;\n  }\n}\n// HELPERS\n/** Resolve all promises in a nested data structure */\nasync function awaitAllPromises(x) {\n  x = await x;\n  if (Array.isArray(x)) {\n    return await Promise.all(x.map(awaitAllPromises));\n  }\n  if (x && typeof x === 'object' && x.constructor === Object) {\n    const object = x;\n    const values = await Promise.all(Object.values(object));\n    const keys = Object.keys(object);\n    const resolvedObject = {};\n    for (let i = 0; i < keys.length; i++) {\n      resolvedObject[keys[i]] = values[i];\n    }\n    return resolvedObject;\n  }\n  return x;\n}","map":{"version":3,"names":["loadImageBitmap","uid","AsyncTexture","device","id","texture","sampler","view","ready","isReady","destroyed","resolveReady","rejectReady","Symbol","toStringTag","toString","constructor","props","data","dimension","Promise","resolve","reject","initAsync","asyncData","awaitAllPromises","then","syncProps","createTexture","destroy","resize","size","Error","width","height","clone","x","Array","isArray","all","map","Object","object","values","keys","resolvedObject","i","length"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\engine\\src\\async-texture\\async-texture.ts"],"sourcesContent":["// luma.gl, MIT license\n// Copyright (c) vis.gl contributors\n\nimport type {\n  Texture,\n  TextureProps,\n  Sampler,\n  TextureView,\n  Device,\n  Texture1DData,\n  Texture2DData,\n  Texture3DData,\n  TextureArrayData,\n  TextureCubeData,\n  TextureCubeArrayData\n} from '@luma.gl/core';\n\nimport {loadImageBitmap} from '../application-utils/load-file';\nimport {uid} from '../utils/uid';\n\nexport type AsyncTextureProps = Omit<TextureProps, 'data'> & AsyncTextureDataProps;\n\ntype AsyncTextureDataProps =\n  | AsyncTexture1DProps\n  | AsyncTexture2DProps\n  | AsyncTexture3DProps\n  | AsyncTextureArrayProps\n  | AsyncTextureCubeProps\n  | AsyncTextureCubeArrayProps;\n\ntype AsyncTexture1DProps = {dimension: '1d'; data: Promise<Texture1DData> | Texture1DData | null};\ntype AsyncTexture2DProps = {dimension?: '2d'; data: Promise<Texture2DData> | Texture2DData | null};\ntype AsyncTexture3DProps = {dimension: '3d'; data: Promise<Texture3DData> | Texture3DData | null};\ntype AsyncTextureArrayProps = {\n  dimension: '2d-array';\n  data: Promise<TextureArrayData> | TextureArrayData | null;\n};\ntype AsyncTextureCubeProps = {\n  dimension: 'cube';\n  data: Promise<TextureCubeData> | TextureCubeData | null;\n};\ntype AsyncTextureCubeArrayProps = {\n  dimension: 'cube-array';\n  data: Promise<TextureCubeArrayData> | TextureCubeArrayData | null;\n};\n\ntype TextureData = TextureProps['data'];\ntype AsyncTextureData = AsyncTextureProps['data'];\n\n/**\n * It is very convenient to be able to initialize textures with promises\n * This can add considerable complexity to the Texture class, and doesn't\n * fit with the immutable nature of WebGPU resources.\n * Instead, luma.gl offers async textures as a separate class.\n */\nexport class AsyncTexture {\n  readonly device: Device;\n  readonly id: string;\n\n  // TODO - should we type these as possibly `null`? It will make usage harder?\n  // @ts-expect-error\n  texture: Texture;\n  // @ts-expect-error\n  sampler: Sampler;\n  // @ts-expect-error\n  view: TextureView;\n\n  readonly ready: Promise<void>;\n  isReady: boolean = false;\n  destroyed: boolean = false;\n\n  protected resolveReady: () => void = () => {};\n  protected rejectReady: (error: Error) => void = () => {};\n\n  get [Symbol.toStringTag]() {\n    return 'AsyncTexture';\n  }\n\n  toString(): string {\n    return `AsyncTexture:\"${this.id}\"(${this.isReady ? 'ready' : 'loading'})`;\n  }\n\n  constructor(device: Device, props: AsyncTextureProps) {\n    this.device = device;\n    this.id = props.id || uid('async-texture');\n    // this.id = typeof props?.data === 'string' ? props.data.slice(-20) : uid('async-texture');\n\n    // Signature: new AsyncTexture(device, {data: url})\n    if (typeof props?.data === 'string' && props.dimension === '2d') {\n      props = {...props, data: loadImageBitmap(props.data)};\n    }\n\n    this.ready = new Promise<void>((resolve, reject) => {\n      this.resolveReady = () => {\n        this.isReady = true;\n        resolve();\n      };\n      this.rejectReady = reject;\n    });\n\n    this.initAsync(props);\n  }\n\n  async initAsync(props: AsyncTextureProps): Promise<void> {\n    let resolveReady;\n    let rejectReady;\n\n    const asyncData: AsyncTextureData = props.data;\n    const data: TextureData = await awaitAllPromises(asyncData).then(resolveReady, rejectReady);\n\n    // Check that we haven't been destroyed while waiting for texture data to load\n    if (this.destroyed) {\n      return;\n    }\n\n    // Now we can actually create the texture\n    // @ts-expect-error Discriminated union\n    const syncProps: TextureProps = {...props, data};\n\n    this.texture = this.device.createTexture(syncProps);\n    this.sampler = this.texture.sampler;\n    this.view = this.texture.view;\n    this.isReady = true;\n  }\n\n  destroy(): void {\n    if (this.texture) {\n      this.texture.destroy();\n      // @ts-expect-error\n      this.texture = null;\n    }\n    this.destroyed = true;\n  }\n\n  /**\n   * Textures are immutable and cannot be resized after creation,\n   * but we can create a similar texture with the same parameters but a new size.\n   * @note Does not copy contents of the texture\n   * @todo Abort pending promise and create a texture with the new size?\n   */\n  resize(size: {width: number; height: number}): boolean {\n    if (!this.isReady) {\n      throw new Error('Cannot resize texture before it is ready');\n    }\n\n    if (size.width === this.texture.width && size.height === this.texture.height) {\n      return false;\n    }\n\n    if (this.texture) {\n      const texture = this.texture;\n      this.texture = texture.clone(size);\n      texture.destroy();\n    }\n    return true;\n  }\n}\n\n// HELPERS\n\n/** Resolve all promises in a nested data structure */\nasync function awaitAllPromises(x: any): Promise<any> {\n  x = await x;\n  if (Array.isArray(x)) {\n    return await Promise.all(x.map(awaitAllPromises));\n  }\n  if (x && typeof x === 'object' && x.constructor === Object) {\n    const object: Record<string, any> = x;\n    const values = await Promise.all(Object.values(object));\n    const keys = Object.keys(object);\n    const resolvedObject: Record<string, any> = {};\n    for (let i = 0; i < keys.length; i++) {\n      resolvedObject[keys[i]] = values[i];\n    }\n    return resolvedObject;\n  }\n  return x;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}