{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Buffer, getVertexFormatFromAttribute } from '@luma.gl/core';\nimport { uid } from \"../utils/uid.js\";\nexport class GPUGeometry {\n  id;\n  userData = {};\n  /** Determines how vertices are read from the 'vertex' attributes */\n  topology;\n  bufferLayout = [];\n  vertexCount;\n  indices;\n  attributes;\n  constructor(props) {\n    this.id = props.id || uid('geometry');\n    this.topology = props.topology;\n    this.indices = props.indices || null;\n    this.attributes = props.attributes;\n    this.vertexCount = props.vertexCount;\n    this.bufferLayout = props.bufferLayout || [];\n    if (this.indices) {\n      if (!(this.indices.usage & Buffer.INDEX)) {\n        throw new Error('Index buffer must have INDEX usage');\n      }\n    }\n  }\n  destroy() {\n    this.indices?.destroy();\n    for (const attribute of Object.values(this.attributes)) {\n      attribute.destroy();\n    }\n  }\n  getVertexCount() {\n    return this.vertexCount;\n  }\n  getAttributes() {\n    return this.attributes;\n  }\n  getIndexes() {\n    return this.indices || null;\n  }\n  _calculateVertexCount(positions) {\n    // Assume that positions is a fully packed float32x3 buffer\n    const vertexCount = positions.byteLength / 12;\n    return vertexCount;\n  }\n}\nexport function makeGPUGeometry(device, geometry) {\n  if (geometry instanceof GPUGeometry) {\n    return geometry;\n  }\n  const indices = getIndexBufferFromGeometry(device, geometry);\n  const {\n    attributes,\n    bufferLayout\n  } = getAttributeBuffersFromGeometry(device, geometry);\n  return new GPUGeometry({\n    topology: geometry.topology || 'triangle-list',\n    bufferLayout,\n    vertexCount: geometry.vertexCount,\n    indices,\n    attributes\n  });\n}\nexport function getIndexBufferFromGeometry(device, geometry) {\n  if (!geometry.indices) {\n    return undefined;\n  }\n  const data = geometry.indices.value;\n  return device.createBuffer({\n    usage: Buffer.INDEX,\n    data\n  });\n}\nexport function getAttributeBuffersFromGeometry(device, geometry) {\n  const bufferLayout = [];\n  const attributes = {};\n  for (const [attributeName, attribute] of Object.entries(geometry.attributes)) {\n    let name = attributeName;\n    // TODO Map some GLTF attribute names (is this still needed?)\n    switch (attributeName) {\n      case 'POSITION':\n        name = 'positions';\n        break;\n      case 'NORMAL':\n        name = 'normals';\n        break;\n      case 'TEXCOORD_0':\n        name = 'texCoords';\n        break;\n      case 'COLOR_0':\n        name = 'colors';\n        break;\n    }\n    if (attribute) {\n      attributes[name] = device.createBuffer({\n        data: attribute.value,\n        id: `${attributeName}-buffer`\n      });\n      const {\n        value,\n        size,\n        normalized\n      } = attribute;\n      // @ts-expect-error\n      bufferLayout.push({\n        name,\n        format: getVertexFormatFromAttribute(value, size, normalized)\n      });\n    }\n  }\n  const vertexCount = geometry._calculateVertexCount(geometry.attributes, geometry.indices);\n  return {\n    attributes,\n    bufferLayout,\n    vertexCount\n  };\n}\n//# sourceMappingURL=gpu-geometry.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}