{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Projection utils\n * TODO: move to Viewport class?\n */\nimport { COORDINATE_SYSTEM } from \"../../lib/constants.js\";\nimport { getOffsetOrigin } from \"./viewport-uniforms.js\";\nimport WebMercatorViewport from \"../../viewports/web-mercator-viewport.js\";\nimport { vec3, vec4 } from '@math.gl/core';\nimport { addMetersToLngLat } from '@math.gl/web-mercator';\nconst DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];\n// In project.glsl, offset modes calculate z differently from LNG_LAT mode.\n// offset modes apply the y adjustment (unitsPerMeter2) when projecting z\n// LNG_LAT mode only use the linear scale.\nfunction lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {\n  const p = viewport.projectPosition(lngLatZ);\n  // TODO - avoid using instanceof\n  if (offsetMode && viewport instanceof WebMercatorViewport) {\n    const [longitude, latitude, z = 0] = lngLatZ;\n    const distanceScales = viewport.getDistanceScales([longitude, latitude]);\n    p[2] = z * distanceScales.unitsPerMeter[2];\n  }\n  return p;\n}\nfunction normalizeParameters(opts) {\n  const {\n    viewport,\n    modelMatrix,\n    coordinateOrigin\n  } = opts;\n  let {\n    coordinateSystem,\n    fromCoordinateSystem,\n    fromCoordinateOrigin\n  } = opts;\n  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;\n  }\n  if (fromCoordinateSystem === undefined) {\n    fromCoordinateSystem = coordinateSystem;\n  }\n  if (fromCoordinateOrigin === undefined) {\n    fromCoordinateOrigin = coordinateOrigin;\n  }\n  return {\n    viewport,\n    coordinateSystem,\n    coordinateOrigin,\n    modelMatrix,\n    fromCoordinateSystem,\n    fromCoordinateOrigin\n  };\n}\n/** Get the common space position from world coordinates in the given coordinate system */\nexport function getWorldPosition(position, {\n  viewport,\n  modelMatrix,\n  coordinateSystem,\n  coordinateOrigin,\n  offsetMode\n}) {\n  let [x, y, z = 0] = position;\n  if (modelMatrix) {\n    [x, y, z] = vec4.transformMat4([], [x, y, z, 1.0], modelMatrix);\n  }\n  switch (coordinateSystem) {\n    case COORDINATE_SYSTEM.LNGLAT:\n      return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);\n    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n      return lngLatZToWorldPosition([x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport, offsetMode);\n    case COORDINATE_SYSTEM.METER_OFFSETS:\n      return lngLatZToWorldPosition(addMetersToLngLat(coordinateOrigin, [x, y, z]), viewport, offsetMode);\n    case COORDINATE_SYSTEM.CARTESIAN:\n    default:\n      return viewport.isGeospatial ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]] : viewport.projectPosition([x, y, z]);\n  }\n}\n/**\n * Equivalent to project_position in project.glsl\n * projects a user supplied position to world position directly with or without\n * a reference coordinate system\n */\nexport function projectPosition(position, params) {\n  const {\n    viewport,\n    coordinateSystem,\n    coordinateOrigin,\n    modelMatrix,\n    fromCoordinateSystem,\n    fromCoordinateOrigin\n  } = normalizeParameters(params);\n  const {\n    autoOffset = true\n  } = params;\n  const {\n    geospatialOrigin = DEFAULT_COORDINATE_ORIGIN,\n    shaderCoordinateOrigin = DEFAULT_COORDINATE_ORIGIN,\n    offsetMode = false\n  } = autoOffset ? getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin) : {};\n  const worldPosition = getWorldPosition(position, {\n    viewport,\n    modelMatrix,\n    coordinateSystem: fromCoordinateSystem,\n    coordinateOrigin: fromCoordinateOrigin,\n    offsetMode\n  });\n  if (offsetMode) {\n    const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);\n    vec3.sub(worldPosition, worldPosition, positionCommonSpace);\n  }\n  return worldPosition;\n}","map":{"version":3,"names":["COORDINATE_SYSTEM","getOffsetOrigin","WebMercatorViewport","vec3","vec4","addMetersToLngLat","DEFAULT_COORDINATE_ORIGIN","lngLatZToWorldPosition","lngLatZ","viewport","offsetMode","p","projectPosition","longitude","latitude","z","distanceScales","getDistanceScales","unitsPerMeter","normalizeParameters","opts","modelMatrix","coordinateOrigin","coordinateSystem","fromCoordinateSystem","fromCoordinateOrigin","DEFAULT","isGeospatial","LNGLAT","CARTESIAN","undefined","getWorldPosition","position","x","y","transformMat4","LNGLAT_OFFSETS","METER_OFFSETS","params","autoOffset","geospatialOrigin","shaderCoordinateOrigin","worldPosition","positionCommonSpace","sub"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\shaderlib\\project\\project-functions.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/**\n * Projection utils\n * TODO: move to Viewport class?\n */\nimport {COORDINATE_SYSTEM} from '../../lib/constants';\nimport {getOffsetOrigin} from './viewport-uniforms';\nimport WebMercatorViewport from '../../viewports/web-mercator-viewport';\n\nimport {vec3, vec4} from '@math.gl/core';\nimport {addMetersToLngLat} from '@math.gl/web-mercator';\n\nimport type {CoordinateSystem} from '../../lib/constants';\nimport type Viewport from '../../viewports/viewport';\nimport type {NumericArray} from '../../types/types';\n\nconst DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];\n\n// In project.glsl, offset modes calculate z differently from LNG_LAT mode.\n// offset modes apply the y adjustment (unitsPerMeter2) when projecting z\n// LNG_LAT mode only use the linear scale.\nfunction lngLatZToWorldPosition(\n  lngLatZ: [number, number, number],\n  viewport: Viewport,\n  offsetMode: boolean = false\n): [number, number, number] {\n  const p = viewport.projectPosition(lngLatZ);\n\n  // TODO - avoid using instanceof\n  if (offsetMode && viewport instanceof WebMercatorViewport) {\n    const [longitude, latitude, z = 0] = lngLatZ;\n    const distanceScales = viewport.getDistanceScales([longitude, latitude]);\n    p[2] = z * distanceScales.unitsPerMeter[2];\n  }\n  return p;\n}\n\nfunction normalizeParameters(opts: {\n  viewport: Viewport;\n  coordinateSystem: CoordinateSystem;\n  coordinateOrigin: [number, number, number];\n  modelMatrix?: NumericArray | null;\n  fromCoordinateSystem?: CoordinateSystem;\n  fromCoordinateOrigin?: [number, number, number];\n}): {\n  viewport: Viewport;\n  coordinateSystem: CoordinateSystem;\n  coordinateOrigin: [number, number, number];\n  modelMatrix?: NumericArray | null;\n  fromCoordinateSystem: CoordinateSystem;\n  fromCoordinateOrigin: [number, number, number];\n} {\n  const {viewport, modelMatrix, coordinateOrigin} = opts;\n  let {coordinateSystem, fromCoordinateSystem, fromCoordinateOrigin} = opts;\n\n  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n    coordinateSystem = viewport.isGeospatial\n      ? COORDINATE_SYSTEM.LNGLAT\n      : COORDINATE_SYSTEM.CARTESIAN;\n  }\n\n  if (fromCoordinateSystem === undefined) {\n    fromCoordinateSystem = coordinateSystem;\n  }\n  if (fromCoordinateOrigin === undefined) {\n    fromCoordinateOrigin = coordinateOrigin;\n  }\n\n  return {\n    viewport,\n    coordinateSystem,\n    coordinateOrigin,\n    modelMatrix,\n    fromCoordinateSystem,\n    fromCoordinateOrigin\n  };\n}\n\n/** Get the common space position from world coordinates in the given coordinate system */\nexport function getWorldPosition(\n  position: number[],\n  {\n    viewport,\n    modelMatrix,\n    coordinateSystem,\n    coordinateOrigin,\n    offsetMode\n  }: {\n    viewport: Viewport;\n    modelMatrix?: NumericArray | null;\n    coordinateSystem: CoordinateSystem;\n    coordinateOrigin: [number, number, number];\n    offsetMode?: boolean;\n  }\n): [number, number, number] {\n  let [x, y, z = 0] = position;\n\n  if (modelMatrix) {\n    [x, y, z] = vec4.transformMat4([], [x, y, z, 1.0], modelMatrix);\n  }\n\n  switch (coordinateSystem) {\n    case COORDINATE_SYSTEM.LNGLAT:\n      return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);\n\n    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n      return lngLatZToWorldPosition(\n        [x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)],\n        viewport,\n        offsetMode\n      );\n\n    case COORDINATE_SYSTEM.METER_OFFSETS:\n      return lngLatZToWorldPosition(\n        addMetersToLngLat(coordinateOrigin, [x, y, z]) as [number, number, number],\n        viewport,\n        offsetMode\n      );\n\n    case COORDINATE_SYSTEM.CARTESIAN:\n    default:\n      return viewport.isGeospatial\n        ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]]\n        : viewport.projectPosition([x, y, z]);\n  }\n}\n\n/**\n * Equivalent to project_position in project.glsl\n * projects a user supplied position to world position directly with or without\n * a reference coordinate system\n */\nexport function projectPosition(\n  position: number[],\n  params: {\n    /** The current viewport */\n    viewport: Viewport;\n    /** The reference coordinate system used to align world position */\n    coordinateSystem: CoordinateSystem;\n    /** The reference coordinate origin used to align world position */\n    coordinateOrigin: [number, number, number];\n    /** The model matrix of the supplied position */\n    modelMatrix?: NumericArray | null;\n    /** The coordinate system that the supplied position is in. Default to the same as `coordinateSystem`. */\n    fromCoordinateSystem?: CoordinateSystem;\n    /** The coordinate origin that the supplied position is in. Default to the same as `coordinateOrigin`. */\n    fromCoordinateOrigin?: [number, number, number];\n    /** Whether to apply offset mode automatically as does the project shader module.\n     * Offset mode places the origin of the common space at the given viewport's center. It is used in some use cases\n     * to improve precision in the vertex shader due to the fp32 float limitation.\n     * Use `autoOffset:false` if the returned position should not be dependent on the current viewport.\n     * Default `true` */\n    autoOffset?: boolean;\n  }\n): [number, number, number] {\n  const {\n    viewport,\n    coordinateSystem,\n    coordinateOrigin,\n    modelMatrix,\n    fromCoordinateSystem,\n    fromCoordinateOrigin\n  } = normalizeParameters(params);\n  const {autoOffset = true} = params;\n\n  const {\n    geospatialOrigin = DEFAULT_COORDINATE_ORIGIN,\n    shaderCoordinateOrigin = DEFAULT_COORDINATE_ORIGIN,\n    offsetMode = false\n  } = autoOffset ? getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin) : {};\n\n  const worldPosition = getWorldPosition(position, {\n    viewport,\n    modelMatrix,\n    coordinateSystem: fromCoordinateSystem,\n    coordinateOrigin: fromCoordinateOrigin,\n    offsetMode\n  });\n\n  if (offsetMode) {\n    const positionCommonSpace = viewport.projectPosition(\n      geospatialOrigin || shaderCoordinateOrigin\n    );\n    vec3.sub(worldPosition, worldPosition, positionCommonSpace);\n  }\n\n  return worldPosition;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}