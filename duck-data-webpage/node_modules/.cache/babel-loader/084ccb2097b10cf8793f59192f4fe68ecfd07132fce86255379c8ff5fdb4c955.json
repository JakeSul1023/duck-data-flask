{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This file is derived from the tar-js code base under MIT license\n// See https://github.com/beatgammit/tar-js/blob/master/LICENSE\n/*\n * tar-js\n * MIT (c) 2011 T. Jameson Little\n */\nimport { clean, pad, stringToUint8 } from \"./utils.js\";\nimport { format } from \"./header.js\";\nlet blockSize;\nlet headerLength;\nlet inputLength;\nconst recordSize = 512;\nclass Tar {\n  written;\n  out;\n  blocks = [];\n  length;\n  /**\n   * @param [recordsPerBlock]\n   */\n  constructor(recordsPerBlock) {\n    this.written = 0;\n    blockSize = (recordsPerBlock || 20) * recordSize;\n    this.out = clean(blockSize);\n    this.blocks = [];\n    this.length = 0;\n    this.save = this.save.bind(this);\n    this.clear = this.clear.bind(this);\n    this.append = this.append.bind(this);\n  }\n  /**\n   * Append a file to the tar archive\n   * @param filepath\n   * @param input\n   * @param [opts]\n   */\n  // eslint-disable-next-line complexity\n  append(filepath, input, opts) {\n    let checksum;\n    if (typeof input === 'string') {\n      input = stringToUint8(input);\n    } else if (input.constructor && input.constructor !== Uint8Array.prototype.constructor) {\n      // @ts-ignore\n      const errorInputMatch = /function\\s*([$A-Za-z_][0-9A-Za-z_]*)\\s*\\(/.exec(input.constructor.toString());\n      const errorInput = errorInputMatch && errorInputMatch[1];\n      const errorMessage = `Invalid input type. You gave me: ${errorInput}`;\n      throw errorMessage;\n    }\n    opts = opts || {};\n    const mode = opts.mode || parseInt('777', 8) & 0xfff;\n    const mtime = opts.mtime || Math.floor(Number(new Date()) / 1000);\n    const uid = opts.uid || 0;\n    const gid = opts.gid || 0;\n    const data = {\n      fileName: filepath,\n      fileMode: pad(mode, 7),\n      uid: pad(uid, 7),\n      gid: pad(gid, 7),\n      fileSize: pad(input.length, 11),\n      mtime: pad(mtime, 11),\n      checksum: '        ',\n      // 0 = just a file\n      type: '0',\n      ustar: 'ustar  ',\n      owner: opts.owner || '',\n      group: opts.group || ''\n    };\n    // calculate the checksum\n    checksum = 0;\n    Object.keys(data).forEach(key => {\n      let i;\n      const value = data[key];\n      let length;\n      for (i = 0, length = value.length; i < length; i += 1) {\n        checksum += value.charCodeAt(i);\n      }\n    });\n    data.checksum = `${pad(checksum, 6)}\\u0000 `;\n    const headerArr = format(data);\n    headerLength = Math.ceil(headerArr.length / recordSize) * recordSize;\n    inputLength = Math.ceil(input.length / recordSize) * recordSize;\n    this.blocks.push({\n      header: headerArr,\n      input,\n      headerLength,\n      inputLength\n    });\n  }\n  /**\n   * Compiling data to a Blob object\n   * @returns {Blob}\n   */\n  save() {\n    const buffers = [];\n    const chunks = new Array();\n    let length = 0;\n    const max = Math.pow(2, 20);\n    let chunk = new Array();\n    this.blocks.forEach(function () {\n      let b = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      if (length + b.headerLength + b.inputLength > max) {\n        chunks.push({\n          blocks: chunk,\n          length\n        });\n        chunk = [];\n        length = 0;\n      }\n      chunk.push(b);\n      length += b.headerLength + b.inputLength;\n    });\n    chunks.push({\n      blocks: chunk,\n      length\n    });\n    chunks.forEach(function () {\n      let c = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      const buffer = new Uint8Array(c.length);\n      let written = 0;\n      c.blocks.forEach(function () {\n        let b = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        buffer.set(b.header, written);\n        written += b.headerLength;\n        buffer.set(b.input, written);\n        written += b.inputLength;\n      });\n      buffers.push(buffer);\n    });\n    buffers.push(new Uint8Array(2 * recordSize));\n    return new Blob(buffers, {\n      type: 'octet/stream'\n    });\n  }\n  /**\n   * Clear the data by its blocksize\n   */\n  clear() {\n    this.written = 0;\n    this.out = clean(blockSize);\n  }\n}\nexport default Tar;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}