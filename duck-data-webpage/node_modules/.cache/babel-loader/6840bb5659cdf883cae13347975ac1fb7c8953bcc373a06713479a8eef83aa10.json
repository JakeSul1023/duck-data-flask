{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isResponse } from \"../../javascript-utils/is-type.js\";\nimport { FetchError } from \"../fetch/fetch-error.js\";\nimport { getResourceContentLength, getResourceUrl, getResourceMIMEType } from \"./resource-utils.js\";\nimport { shortenUrlForDisplay } from \"./url-utils.js\";\n/**\n * Returns a Response object\n * Adds content-length header when possible\n *\n * @param resource\n */\nexport async function makeResponse(resource) {\n  if (isResponse(resource)) {\n    return resource;\n  }\n  // Add content-length header if possible\n  const headers = {};\n  const contentLength = getResourceContentLength(resource);\n  if (contentLength >= 0) {\n    headers['content-length'] = String(contentLength);\n  }\n  // `new Response(File)` does not preserve content-type and URL\n  // so we add them here\n  const url = getResourceUrl(resource);\n  const type = getResourceMIMEType(resource);\n  if (type) {\n    headers['content-type'] = type;\n  }\n  // Add a custom header with initial bytes if available\n  const initialDataUrl = await getInitialDataUrl(resource);\n  if (initialDataUrl) {\n    headers['x-first-bytes'] = initialDataUrl;\n  }\n  // TODO - is this the best way of handling strings?\n  // Maybe package as data URL instead?\n  if (typeof resource === 'string') {\n    // Convert to ArrayBuffer to avoid Response treating it as a URL\n    resource = new TextEncoder().encode(resource);\n  }\n  // Attempt to create a Response from the resource, adding headers and setting url\n  const response = new Response(resource, {\n    headers\n  });\n  // We can't control `Response.url` via constructor, use a property override to record URL.\n  Object.defineProperty(response, 'url', {\n    value: url\n  });\n  return response;\n}\n/**\n * Checks response status (async) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport async function checkResponse(response) {\n  if (!response.ok) {\n    const error = await getResponseError(response);\n    throw error;\n  }\n}\n/**\n * Checks response status (sync) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport function checkResponseSync(response) {\n  if (!response.ok) {\n    let message = `${response.status} ${response.statusText}`;\n    message = message.length > 60 ? `${message.slice(0, 60)}...` : message;\n    throw new Error(message);\n  }\n}\n// HELPERS\nasync function getResponseError(response) {\n  const shortUrl = shortenUrlForDisplay(response.url);\n  let message = `Failed to fetch resource (${response.status}) ${response.statusText}: ${shortUrl}`;\n  message = message.length > 100 ? `${message.slice(0, 100)}...` : message;\n  const info = {\n    reason: response.statusText,\n    url: response.url,\n    response\n  };\n  // See if we got an error message in the body\n  try {\n    const contentType = response.headers.get('Content-Type');\n    info.reason = !response.bodyUsed && contentType?.includes('application/json') ? await response.json() : await response.text();\n  } catch (error) {\n    // eslint forbids return in a finally statement, so we just catch here\n  }\n  return new FetchError(message, info);\n}\nasync function getInitialDataUrl(resource) {\n  const INITIAL_DATA_LENGTH = 5;\n  if (typeof resource === 'string') {\n    return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;\n  }\n  if (resource instanceof Blob) {\n    const blobSlice = resource.slice(0, 5);\n    return await new Promise(resolve => {\n      const reader = new FileReader();\n      reader.onload = event => resolve(event?.target?.result);\n      reader.readAsDataURL(blobSlice);\n    });\n  }\n  if (resource instanceof ArrayBuffer) {\n    const slice = resource.slice(0, INITIAL_DATA_LENGTH);\n    const base64 = arrayBufferToBase64(slice);\n    return `data:base64,${base64}`;\n  }\n  return null;\n}\n// https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string\nfunction arrayBufferToBase64(buffer) {\n  let binary = '';\n  const bytes = new Uint8Array(buffer);\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}","map":{"version":3,"names":["isResponse","FetchError","getResourceContentLength","getResourceUrl","getResourceMIMEType","shortenUrlForDisplay","makeResponse","resource","headers","contentLength","String","url","type","initialDataUrl","getInitialDataUrl","TextEncoder","encode","response","Response","Object","defineProperty","value","checkResponse","ok","error","getResponseError","checkResponseSync","message","status","statusText","length","slice","Error","shortUrl","info","reason","contentType","get","bodyUsed","includes","json","text","INITIAL_DATA_LENGTH","Blob","blobSlice","Promise","resolve","reader","FileReader","onload","event","target","result","readAsDataURL","ArrayBuffer","base64","arrayBufferToBase64","buffer","binary","bytes","Uint8Array","i","byteLength","fromCharCode","btoa"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isResponse } from \"../../javascript-utils/is-type.js\";\nimport { FetchError } from \"../fetch/fetch-error.js\";\nimport { getResourceContentLength, getResourceUrl, getResourceMIMEType } from \"./resource-utils.js\";\nimport { shortenUrlForDisplay } from \"./url-utils.js\";\n/**\n * Returns a Response object\n * Adds content-length header when possible\n *\n * @param resource\n */\nexport async function makeResponse(resource) {\n    if (isResponse(resource)) {\n        return resource;\n    }\n    // Add content-length header if possible\n    const headers = {};\n    const contentLength = getResourceContentLength(resource);\n    if (contentLength >= 0) {\n        headers['content-length'] = String(contentLength);\n    }\n    // `new Response(File)` does not preserve content-type and URL\n    // so we add them here\n    const url = getResourceUrl(resource);\n    const type = getResourceMIMEType(resource);\n    if (type) {\n        headers['content-type'] = type;\n    }\n    // Add a custom header with initial bytes if available\n    const initialDataUrl = await getInitialDataUrl(resource);\n    if (initialDataUrl) {\n        headers['x-first-bytes'] = initialDataUrl;\n    }\n    // TODO - is this the best way of handling strings?\n    // Maybe package as data URL instead?\n    if (typeof resource === 'string') {\n        // Convert to ArrayBuffer to avoid Response treating it as a URL\n        resource = new TextEncoder().encode(resource);\n    }\n    // Attempt to create a Response from the resource, adding headers and setting url\n    const response = new Response(resource, { headers });\n    // We can't control `Response.url` via constructor, use a property override to record URL.\n    Object.defineProperty(response, 'url', { value: url });\n    return response;\n}\n/**\n * Checks response status (async) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport async function checkResponse(response) {\n    if (!response.ok) {\n        const error = await getResponseError(response);\n        throw error;\n    }\n}\n/**\n * Checks response status (sync) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport function checkResponseSync(response) {\n    if (!response.ok) {\n        let message = `${response.status} ${response.statusText}`;\n        message = message.length > 60 ? `${message.slice(0, 60)}...` : message;\n        throw new Error(message);\n    }\n}\n// HELPERS\nasync function getResponseError(response) {\n    const shortUrl = shortenUrlForDisplay(response.url);\n    let message = `Failed to fetch resource (${response.status}) ${response.statusText}: ${shortUrl}`;\n    message = message.length > 100 ? `${message.slice(0, 100)}...` : message;\n    const info = {\n        reason: response.statusText,\n        url: response.url,\n        response\n    };\n    // See if we got an error message in the body\n    try {\n        const contentType = response.headers.get('Content-Type');\n        info.reason =\n            !response.bodyUsed && contentType?.includes('application/json')\n                ? await response.json()\n                : await response.text();\n    }\n    catch (error) {\n        // eslint forbids return in a finally statement, so we just catch here\n    }\n    return new FetchError(message, info);\n}\nasync function getInitialDataUrl(resource) {\n    const INITIAL_DATA_LENGTH = 5;\n    if (typeof resource === 'string') {\n        return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;\n    }\n    if (resource instanceof Blob) {\n        const blobSlice = resource.slice(0, 5);\n        return await new Promise((resolve) => {\n            const reader = new FileReader();\n            reader.onload = (event) => resolve(event?.target?.result);\n            reader.readAsDataURL(blobSlice);\n        });\n    }\n    if (resource instanceof ArrayBuffer) {\n        const slice = resource.slice(0, INITIAL_DATA_LENGTH);\n        const base64 = arrayBufferToBase64(slice);\n        return `data:base64,${base64}`;\n    }\n    return null;\n}\n// https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string\nfunction arrayBufferToBase64(buffer) {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}