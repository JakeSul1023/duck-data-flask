{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { lightingShader } from \"./lights-glsl.js\";\nconst INITIAL_MODULE_OPTIONS = {\n  lightSources: {}\n};\n// Take color 0-255 and intensity as input and output 0.0-1.0 range\nfunction convertColor(colorDef = {}) {\n  const {\n    color = [0, 0, 0],\n    intensity = 1.0\n  } = colorDef;\n  return color.map(component => component * intensity / 255.0);\n}\nfunction getLightSourceUniforms({\n  ambientLight,\n  pointLights = [],\n  directionalLights = []\n}) {\n  const lightSourceUniforms = {};\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[`lighting_uPointLight[${index}].color`] = convertColor(pointLight);\n    lightSourceUniforms[`lighting_uPointLight[${index}].position`] = pointLight.position;\n    lightSourceUniforms[`lighting_uPointLight[${index}].attenuation`] = pointLight.attenuation || [1, 0, 0];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].color`] = convertColor(directionalLight);\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].direction`] = directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n  return lightSourceUniforms;\n}\n// eslint-disable-next-line complexity\nfunction getUniforms(opts = INITIAL_MODULE_OPTIONS) {\n  // Specify lights separately\n  if ('lightSources' in opts) {\n    const {\n      ambientLight,\n      pointLights,\n      directionalLights\n    } = opts.lightSources || {};\n    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;\n    if (!hasLights) {\n      return {\n        lighting_uEnabled: false\n      };\n    }\n    return Object.assign({}, getLightSourceUniforms({\n      ambientLight,\n      pointLights,\n      directionalLights\n    }), {\n      lighting_uEnabled: true\n    });\n  }\n  // Support for array of lights. Type of light is detected by type field\n  if ('lights' in opts) {\n    const lightSources = {\n      pointLights: [],\n      directionalLights: []\n    };\n    // @ts-expect-error\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          // Note: Only uses last ambient light\n          // TODO - add ambient light sources on CPU?\n          lightSources.ambientLight = light;\n          break;\n        case 'directional':\n          lightSources.directionalLights?.push(light);\n          break;\n        case 'point':\n          lightSources.pointLights?.push(light);\n          break;\n        default:\n        // eslint-disable-next-line\n        // console.warn(light.type);\n      }\n    }\n    // Call the `opts.lightSources`` version\n    return getUniforms({\n      lightSources\n    });\n  }\n  return {};\n}\n/**\n * An implementation of PBR (Physically-Based Rendering).\n * Physically Based Shading of a microfacet surface defined by a glTF material.\n */\nexport const lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};","map":{"version":3,"names":["lightingShader","INITIAL_MODULE_OPTIONS","lightSources","convertColor","colorDef","color","intensity","map","component","getLightSourceUniforms","ambientLight","pointLights","directionalLights","lightSourceUniforms","forEach","pointLight","index","position","attenuation","lighting_uPointLightCount","length","directionalLight","direction","lighting_uDirectionalLightCount","getUniforms","opts","hasLights","lighting_uEnabled","Object","assign","light","lights","type","push","name","vs","fs","defines","MAX_LIGHTS"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\shadertools\\src\\modules-webgl1\\lighting\\lights\\lights.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {NumberArray} from '../../../types';\nimport {lightingShader} from './lights-glsl';\n\n/* eslint-disable camelcase */\n\ntype LightSources = {\n  ambientLight?: {\n    color: Readonly<NumberArray>;\n    intensity: number;\n  };\n  pointLights?: {\n    color: Readonly<NumberArray>;\n    intensity: number;\n    position: NumberArray;\n    attenuation: number;\n  }[];\n  directionalLights?: {\n    color: Readonly<NumberArray>;\n    intensity: number;\n    position: NumberArray;\n    direction: NumberArray;\n  }[];\n};\n\nexport type LightsOptions = {\n  lightSources?: LightSources;\n};\n\nconst INITIAL_MODULE_OPTIONS: Required<LightsOptions> = {\n  lightSources: {}\n};\n\n// Take color 0-255 and intensity as input and output 0.0-1.0 range\nfunction convertColor(\n  colorDef: {color?: Readonly<NumberArray>; intensity?: number} = {}\n): NumberArray {\n  const {color = [0, 0, 0], intensity = 1.0} = colorDef;\n  return color.map(component => (component * intensity) / 255.0);\n}\n\nfunction getLightSourceUniforms({\n  ambientLight,\n  pointLights = [],\n  directionalLights = []\n}: LightSources): Record<string, any> {\n  const lightSourceUniforms: Record<string, any> = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[`lighting_uPointLight[${index}].color`] = convertColor(pointLight);\n    lightSourceUniforms[`lighting_uPointLight[${index}].position`] = pointLight.position;\n    lightSourceUniforms[`lighting_uPointLight[${index}].attenuation`] = pointLight.attenuation || [\n      1, 0, 0\n    ];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].color`] =\n      convertColor(directionalLight);\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].direction`] =\n      directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n\n  return lightSourceUniforms;\n}\n\n// eslint-disable-next-line complexity\nfunction getUniforms(opts: LightsOptions = INITIAL_MODULE_OPTIONS): Record<string, any> {\n  // Specify lights separately\n  if ('lightSources' in opts) {\n    const {ambientLight, pointLights, directionalLights} = opts.lightSources || {};\n    const hasLights =\n      ambientLight ||\n      (pointLights && pointLights.length > 0) ||\n      (directionalLights && directionalLights.length > 0);\n\n    if (!hasLights) {\n      return {lighting_uEnabled: false};\n    }\n\n    return Object.assign(\n      {},\n      getLightSourceUniforms({ambientLight, pointLights, directionalLights}),\n      {\n        lighting_uEnabled: true\n      }\n    );\n  }\n\n  // Support for array of lights. Type of light is detected by type field\n  if ('lights' in opts) {\n    const lightSources: LightSources = {pointLights: [], directionalLights: []};\n    // @ts-expect-error\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          // Note: Only uses last ambient light\n          // TODO - add ambient light sources on CPU?\n          lightSources.ambientLight = light;\n          break;\n        case 'directional':\n          lightSources.directionalLights?.push(light);\n          break;\n        case 'point':\n          lightSources.pointLights?.push(light);\n          break;\n        default:\n        // eslint-disable-next-line\n        // console.warn(light.type);\n      }\n    }\n\n    // Call the `opts.lightSources`` version\n    return getUniforms({lightSources});\n  }\n\n  return {};\n}\n\n/**\n * An implementation of PBR (Physically-Based Rendering).\n * Physically Based Shading of a microfacet surface defined by a glTF material.\n */\nexport const lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}