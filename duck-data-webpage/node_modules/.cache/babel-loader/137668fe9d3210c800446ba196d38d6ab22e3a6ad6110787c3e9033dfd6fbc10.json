{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log, createIterable, project32, Viewport } from '@deck.gl/core';\nimport { WebGLAggregator, CPUAggregator } from \"../common/aggregator/index.js\";\nimport AggregationLayer from \"../common/aggregation-layer.js\";\nimport { defaultColorRange } from \"../common/utils/color-utils.js\";\nimport { AttributeWithScale } from \"../common/utils/scale-utils.js\";\nimport { getBinIdRange } from \"../common/utils/bounds-utils.js\";\nimport HexagonCellLayer from \"./hexagon-cell-layer.js\";\nimport { pointToHexbin, HexbinVertices, getHexbinCentroid, pointToHexbinGLSL } from \"./hexbin.js\";\nimport { binOptionsUniforms } from \"./bin-options-uniforms.js\";\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\nconst defaultProps = {\n  gpuAggregation: true,\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorValue: {\n    type: 'accessor',\n    value: null\n  },\n  // default value is calculated from `getColorWeight` and `colorAggregation`\n  getColorWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  colorAggregation: 'SUM',\n  lowerPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 0\n  },\n  upperPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 100\n  },\n  colorScaleType: 'quantize',\n  onSetColorDomain: noop,\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationValue: {\n    type: 'accessor',\n    value: null\n  },\n  // default value is calculated from `getElevationWeight` and `elevationAggregation`\n  getElevationWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  elevationAggregation: 'SUM',\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  elevationLowerPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 0\n  },\n  elevationUpperPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 100\n  },\n  elevationScaleType: 'linear',\n  onSetElevationDomain: noop,\n  // hexbin\n  radius: {\n    type: 'number',\n    min: 1,\n    value: 1000\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  hexagonAggregator: {\n    type: 'function',\n    optional: true,\n    value: null\n  },\n  extruded: false,\n  // Optional material for 'lighting' shader module\n  material: true\n};\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\nclass HexagonLayer extends AggregationLayer {\n  getAggregatorType() {\n    const {\n      gpuAggregation,\n      hexagonAggregator,\n      getColorValue,\n      getElevationValue\n    } = this.props;\n    if (gpuAggregation && (hexagonAggregator || getColorValue || getElevationValue)) {\n      // If these features are desired by the app, the user should explicitly use CPU aggregation\n      log.warn('Features not supported by GPU aggregation, falling back to CPU')();\n      return 'cpu';\n    }\n    if (\n    // GPU aggregation is requested\n    gpuAggregation &&\n    // GPU aggregation is supported by the device\n    WebGLAggregator.isSupported(this.context.device)) {\n      return 'gpu';\n    }\n    return 'cpu';\n  }\n  createAggregator(type) {\n    if (type === 'cpu') {\n      const {\n        hexagonAggregator,\n        radius\n      } = this.props;\n      return new CPUAggregator({\n        dimensions: 2,\n        getBin: {\n          sources: ['positions'],\n          getValue: (_ref, index, opts) => {\n            let {\n              positions\n            } = _ref;\n            if (hexagonAggregator) {\n              return hexagonAggregator(positions, radius);\n            }\n            const viewport = this.state.aggregatorViewport;\n            // project to common space\n            const p = viewport.projectPosition(positions);\n            const {\n              radiusCommon,\n              hexOriginCommon\n            } = opts;\n            return pointToHexbin([p[0] - hexOriginCommon[0], p[1] - hexOriginCommon[1]], radiusCommon);\n          }\n        },\n        getValue: [{\n          sources: ['colorWeights'],\n          getValue: _ref2 => {\n            let {\n              colorWeights\n            } = _ref2;\n            return colorWeights;\n          }\n        }, {\n          sources: ['elevationWeights'],\n          getValue: _ref3 => {\n            let {\n              elevationWeights\n            } = _ref3;\n            return elevationWeights;\n          }\n        }]\n      });\n    }\n    return new WebGLAggregator(this.context.device, {\n      dimensions: 2,\n      channelCount: 2,\n      bufferLayout: this.getAttributeManager().getBufferLayouts({\n        isInstanced: false\n      }),\n      ...super.getShaders({\n        modules: [project32, binOptionsUniforms],\n        vs: /* glsl */`\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float colorWeights;\n  in float elevationWeights;\n  \n  ${pointToHexbinGLSL}\n\n  void getBin(out ivec2 binId) {\n    vec3 positionCommon = project_position(positions, positions64Low);\n    binId = pointToHexbin(positionCommon.xy, binOptions.radiusCommon);\n  }\n  void getValue(out vec2 value) {\n    value = vec2(colorWeights, elevationWeights);\n  }\n  `\n      })\n    });\n  }\n  initializeState() {\n    super.initializeState();\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 'float64',\n        fp64: this.use64bitPositions()\n      },\n      colorWeights: {\n        size: 1,\n        accessor: 'getColorWeight'\n      },\n      elevationWeights: {\n        size: 1,\n        accessor: 'getElevationWeight'\n      }\n    });\n  }\n  updateState(params) {\n    const aggregatorChanged = super.updateState(params);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const {\n      aggregator\n    } = this.state;\n    if ((changeFlags.dataChanged || !this.state.dataAsArray) && (props.getColorValue || props.getElevationValue)) {\n      // Convert data to array\n      this.state.dataAsArray = Array.from(createIterable(props.data).iterable);\n    }\n    if (aggregatorChanged || changeFlags.dataChanged || props.radius !== oldProps.radius || props.getColorValue !== oldProps.getColorValue || props.getElevationValue !== oldProps.getElevationValue || props.colorAggregation !== oldProps.colorAggregation || props.elevationAggregation !== oldProps.elevationAggregation) {\n      this._updateBinOptions();\n      const {\n        radiusCommon,\n        hexOriginCommon,\n        binIdRange,\n        dataAsArray\n      } = this.state;\n      aggregator.setProps({\n        // @ts-expect-error only used by GPUAggregator\n        binIdRange,\n        pointCount: this.getNumInstances(),\n        operations: [props.colorAggregation, props.elevationAggregation],\n        binOptions: {\n          radiusCommon,\n          hexOriginCommon\n        },\n        onUpdate: this._onAggregationUpdate.bind(this)\n      });\n      if (dataAsArray) {\n        const {\n          getColorValue,\n          getElevationValue\n        } = this.props;\n        aggregator.setProps({\n          // @ts-expect-error only used by CPUAggregator\n          customOperations: [getColorValue && (indices => getColorValue(indices.map(i => dataAsArray[i]), {\n            indices,\n            data: props.data\n          })), getElevationValue && (indices => getElevationValue(indices.map(i => dataAsArray[i]), {\n            indices,\n            data: props.data\n          }))]\n        });\n      }\n    }\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getColorValue) {\n      aggregator.setNeedsUpdate(0);\n    }\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getElevationValue) {\n      aggregator.setNeedsUpdate(1);\n    }\n    return aggregatorChanged;\n  }\n  _updateBinOptions() {\n    const bounds = this.getBounds();\n    let radiusCommon = 1;\n    let hexOriginCommon = [0, 0];\n    let binIdRange = [[0, 1], [0, 1]];\n    let viewport = this.context.viewport;\n    if (bounds && Number.isFinite(bounds[0][0])) {\n      let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];\n      const {\n        radius\n      } = this.props;\n      const {\n        unitsPerMeter\n      } = viewport.getDistanceScales(centroid);\n      radiusCommon = unitsPerMeter[0] * radius;\n      // Use the centroid of the hex at the center of the data\n      // This offsets the common space without changing the bins\n      const centerHex = pointToHexbin(viewport.projectFlat(centroid), radiusCommon);\n      centroid = viewport.unprojectFlat(getHexbinCentroid(centerHex, radiusCommon));\n      const ViewportType = viewport.constructor;\n      // We construct a viewport for the GPU aggregator's project module\n      // This viewport is determined by data\n      // removes arbitrary precision variance that depends on initial view state\n      viewport = viewport.isGeospatial ? new ViewportType({\n        longitude: centroid[0],\n        latitude: centroid[1],\n        zoom: 12\n      }) : new Viewport({\n        position: [centroid[0], centroid[1], 0],\n        zoom: 12\n      });\n      hexOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];\n      binIdRange = getBinIdRange({\n        dataBounds: bounds,\n        getBinId: p => {\n          const positionCommon = viewport.projectFlat(p);\n          positionCommon[0] -= hexOriginCommon[0];\n          positionCommon[1] -= hexOriginCommon[1];\n          return pointToHexbin(positionCommon, radiusCommon);\n        },\n        padding: 1\n      });\n    }\n    this.setState({\n      radiusCommon,\n      hexOriginCommon,\n      binIdRange,\n      aggregatorViewport: viewport\n    });\n  }\n  draw(opts) {\n    // Replaces render time viewport with our own\n    if (opts.shaderModuleProps.project) {\n      opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;\n    }\n    super.draw(opts);\n  }\n  _onAggregationUpdate(_ref4) {\n    let {\n      channel\n    } = _ref4;\n    const props = this.getCurrentLayer().props;\n    const {\n      aggregator\n    } = this.state;\n    if (channel === 0) {\n      const result = aggregator.getResult(0);\n      this.setState({\n        colors: new AttributeWithScale(result, aggregator.binCount)\n      });\n      props.onSetColorDomain(aggregator.getResultDomain(0));\n    } else if (channel === 1) {\n      const result = aggregator.getResult(1);\n      this.setState({\n        elevations: new AttributeWithScale(result, aggregator.binCount)\n      });\n      props.onSetElevationDomain(aggregator.getResultDomain(1));\n    }\n  }\n  onAttributeChange(id) {\n    const {\n      aggregator\n    } = this.state;\n    switch (id) {\n      case 'positions':\n        aggregator.setNeedsUpdate();\n        this._updateBinOptions();\n        const {\n          radiusCommon,\n          hexOriginCommon,\n          binIdRange\n        } = this.state;\n        aggregator.setProps({\n          // @ts-expect-error only used by GPUAggregator\n          binIdRange,\n          binOptions: {\n            radiusCommon,\n            hexOriginCommon\n          }\n        });\n        break;\n      case 'colorWeights':\n        aggregator.setNeedsUpdate(0);\n        break;\n      case 'elevationWeights':\n        aggregator.setNeedsUpdate(1);\n        break;\n      default:\n      // This should not happen\n    }\n  }\n  renderLayers() {\n    const {\n      aggregator,\n      radiusCommon,\n      hexOriginCommon\n    } = this.state;\n    const {\n      elevationScale,\n      colorRange,\n      elevationRange,\n      extruded,\n      coverage,\n      material,\n      transitions,\n      colorScaleType,\n      lowerPercentile,\n      upperPercentile,\n      colorDomain,\n      elevationScaleType,\n      elevationLowerPercentile,\n      elevationUpperPercentile,\n      elevationDomain\n    } = this.props;\n    const CellLayerClass = this.getSubLayerClass('cells', HexagonCellLayer);\n    const binAttribute = aggregator.getBins();\n    const colors = this.state.colors?.update({\n      scaleType: colorScaleType,\n      lowerPercentile,\n      upperPercentile\n    });\n    const elevations = this.state.elevations?.update({\n      scaleType: elevationScaleType,\n      lowerPercentile: elevationLowerPercentile,\n      upperPercentile: elevationUpperPercentile\n    });\n    if (!colors || !elevations) {\n      return null;\n    }\n    return new CellLayerClass(this.getSubLayerProps({\n      id: 'cells'\n    }), {\n      data: {\n        length: aggregator.binCount,\n        attributes: {\n          getBin: binAttribute,\n          getColorValue: colors.attribute,\n          getElevationValue: elevations.attribute\n        }\n      },\n      // Data has changed shallowly, but we likely don't need to update the attributes\n      dataComparator: (data, oldData) => data.length === oldData.length,\n      updateTriggers: {\n        getBin: [binAttribute],\n        getColorValue: [colors.attribute],\n        getElevationValue: [elevations.attribute]\n      },\n      diskResolution: 6,\n      vertices: HexbinVertices,\n      radius: radiusCommon,\n      hexOriginCommon,\n      elevationScale,\n      colorRange,\n      colorScaleType,\n      elevationRange,\n      extruded,\n      coverage,\n      material,\n      colorDomain: colors.domain || colorDomain || aggregator.getResultDomain(0),\n      elevationDomain: elevations.domain || elevationDomain || aggregator.getResultDomain(1),\n      colorCutoff: colors.cutoff,\n      elevationCutoff: elevations.cutoff,\n      transitions: transitions && {\n        getFillColor: transitions.getColorValue || transitions.getColorWeight,\n        getElevation: transitions.getElevationValue || transitions.getElevationWeight\n      },\n      // Extensions are already handled by the GPUAggregator, do not pass it down\n      extensions: []\n    });\n  }\n  getPickingInfo(params) {\n    const info = params.info;\n    const {\n      index\n    } = info;\n    if (index >= 0) {\n      const bin = this.state.aggregator.getBin(index);\n      let object;\n      if (bin) {\n        const centroidCommon = getHexbinCentroid(bin.id, this.state.radiusCommon);\n        const centroid = this.context.viewport.unprojectFlat(centroidCommon);\n        object = {\n          col: bin.id[0],\n          row: bin.id[1],\n          position: centroid,\n          colorValue: bin.value[0],\n          elevationValue: bin.value[1],\n          count: bin.count\n        };\n        if (bin.pointIndices) {\n          object.pointIndices = bin.pointIndices;\n          object.points = Array.isArray(this.props.data) ? bin.pointIndices.map(i => this.props.data[i]) : [];\n        }\n      }\n      info.object = object;\n    }\n    return info;\n  }\n}\nHexagonLayer.layerName = 'HexagonLayer';\nHexagonLayer.defaultProps = defaultProps;\nexport default HexagonLayer;\n//# sourceMappingURL=hexagon-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}