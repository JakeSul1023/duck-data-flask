{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { DataSource, resolvePath } from '@loaders.gl/loader-utils';\nimport { ImageLoader, getBinaryImageMetadata } from '@loaders.gl/images';\nimport { MVTLoader, TileJSONLoader } from '@loaders.gl/mvt';\n/** Creates an MVTTileSource */\nexport const MVTSource = {\n  name: 'MVT',\n  id: 'mvt',\n  module: 'mvt',\n  version: '0.0.0',\n  extensions: ['mvt'],\n  mimeTypes: ['application/octet-stream'],\n  options: {\n    mvt: {\n      // TODO - add options here\n    }\n  },\n  type: 'mvt',\n  fromUrl: true,\n  fromBlob: false,\n  testURL: url => true,\n  createDataSource(url, props) {\n    return new MVTTileSource(url, props);\n  }\n};\n/**\n * MVT data source for Mapbox Vector Tiles v1.\n */\n/**\n * A PMTiles data source\n * @note Can be either a raster or vector tile source depending on the contents of the PMTiles file.\n */\nexport class MVTTileSource extends DataSource {\n  props;\n  url;\n  metadataUrl = null;\n  data;\n  schema = 'tms';\n  metadata;\n  extension;\n  mimeType = null;\n  constructor(url, props) {\n    super(props);\n    this.props = props;\n    this.url = resolvePath(url);\n    this.metadataUrl = props.mvt?.metadataUrl || `${this.url}/tilejson.json`;\n    this.extension = props.mvt?.extension || '.png';\n    this.data = this.url;\n    this.getTileData = this.getTileData.bind(this);\n    this.metadata = this.getMetadata();\n    if (isURLTemplate(this.url)) {\n      this.schema = 'template';\n    }\n  }\n  // @ts-ignore - Metadata type misalignment\n  async getMetadata() {\n    if (!this.metadataUrl) {\n      return null;\n    }\n    let response;\n    try {\n      // Annoyingly, on CORS errors, fetch doesn't use the response status/ok mechanism but instead throws\n      // CORS errors are common when requesting an unavailable sub resource such as a metadata file or an unavailable tile)\n      response = await this.fetch(this.metadataUrl);\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      console.error(error.message);\n      return null;\n    }\n    if (!response.ok) {\n      // eslint-disable-next-line no-console\n      console.error(response.statusText);\n      return null;\n    }\n    const tileJSON = await response.text();\n    const metadata = TileJSONLoader.parseTextSync?.(tileJSON) || null;\n    // TODO add metadata attributions\n    // metadata.attributions = [...this.props.attributions, ...(metadata.attributions || [])];\n    // if (metadata?.mimeType) {\n    //   this.mimeType = metadata?.tileMIMEType;\n    // }\n    return metadata;\n  }\n  getTileMIMEType() {\n    return this.mimeType;\n  }\n  async getTile(parameters) {\n    const {\n      x,\n      y,\n      z\n    } = parameters;\n    const tileUrl = this.getTileURL(x, y, z);\n    const response = await this.fetch(tileUrl);\n    if (!response.ok) {\n      return null;\n    }\n    const arrayBuffer = await response.arrayBuffer();\n    return arrayBuffer;\n  }\n  // Tile Source interface implementation: deck.gl compatible API\n  // TODO - currently only handles image tiles, not vector tiles\n  async getTileData(parameters) {\n    const {\n      x,\n      y,\n      z\n    } = parameters.index;\n    // const metadata = await this.metadata;\n    // mimeType = metadata?.tileMIMEType || 'application/vnd.mapbox-vector-tile';\n    const arrayBuffer = await this.getTile({\n      x,\n      y,\n      z,\n      layers: []\n    });\n    if (arrayBuffer === null) {\n      return null;\n    }\n    const imageMetadata = getBinaryImageMetadata(arrayBuffer);\n    this.mimeType = this.mimeType || imageMetadata?.mimeType || 'application/vnd.mapbox-vector-tile';\n    switch (this.mimeType) {\n      case 'application/vnd.mapbox-vector-tile':\n        return await this._parseVectorTile(arrayBuffer, {\n          x,\n          y,\n          z,\n          layers: []\n        });\n      default:\n        return await this._parseImageTile(arrayBuffer);\n    }\n  }\n  // ImageTileSource interface implementation\n  async getImageTile(tileParams) {\n    const arrayBuffer = await this.getTile(tileParams);\n    return arrayBuffer ? this._parseImageTile(arrayBuffer) : null;\n  }\n  async _parseImageTile(arrayBuffer) {\n    return await ImageLoader.parse(arrayBuffer, this.loadOptions);\n  }\n  // VectorTileSource interface implementation\n  async getVectorTile(tileParams) {\n    const arrayBuffer = await this.getTile(tileParams);\n    return arrayBuffer ? this._parseVectorTile(arrayBuffer, tileParams) : null;\n  }\n  async _parseVectorTile(arrayBuffer, tileParams) {\n    const loadOptions = {\n      shape: 'geojson-table',\n      mvt: {\n        coordinates: 'wgs84',\n        tileIndex: {\n          x: tileParams.x,\n          y: tileParams.y,\n          z: tileParams.z\n        },\n        ...this.loadOptions?.mvt\n      },\n      ...this.loadOptions\n    };\n    return await MVTLoader.parse(arrayBuffer, loadOptions);\n  }\n  getMetadataUrl() {\n    return this.metadataUrl;\n  }\n  getTileURL(x, y, z) {\n    switch (this.schema) {\n      case 'xyz':\n        return `${this.url}/${x}/${y}/${z}${this.extension}`;\n      case 'tms':\n        return `${this.url}/${z}/${x}/${y}${this.extension}`;\n      case 'template':\n        return getURLFromTemplate(this.url, x, y, z, '0');\n      default:\n        throw new Error(this.schema);\n    }\n  }\n}\nexport function isURLTemplate(s) {\n  return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))|(?=.*{x})(?=.*({y}|{-y})(?=.*{z}))/.test(s);\n}\nconst xRegex = new RegExp('{x}', 'g');\nconst yRegex = new RegExp('{y}', 'g');\nconst zRegex = new RegExp('{z}', 'g');\n/**\n * Get a URL from a URL template\n * @note copied from deck.gl/modules/geo-layers/src/tileset-2d/utils.ts\n * @param template - URL template\n * @param x - tile x coordinate\n * @param y - tile y coordinate\n * @param z - tile z coordinate\n * @param id - tile id\n * @returns URL\n */\nexport function getURLFromTemplate(template, x, y, z) {\n  let id = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '0';\n  if (Array.isArray(template)) {\n    const i = stringHash(id) % template.length;\n    template = template[i];\n  }\n  let url = template;\n  url = url.replace(xRegex, String(x));\n  url = url.replace(yRegex, String(y));\n  url = url.replace(zRegex, String(z));\n  // Back-compatible support for {-y}\n  if (Number.isInteger(y) && Number.isInteger(z)) {\n    url = url.replace(/\\{-y\\}/g, String(Math.pow(2, z) - y - 1));\n  }\n  return url;\n}\nfunction stringHash(s) {\n  return Math.abs(s.split('').reduce((a, b) => (a << 5) - a + b.charCodeAt(0) | 0, 0));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}