{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* eslint-disable complexity, camelcase */\nimport { mat4, vec4 } from '@math.gl/core';\nimport { COORDINATE_SYSTEM, PROJECTION_MODE } from \"../../lib/constants.js\";\nimport memoize from \"../../utils/memoize.js\";\n// To quickly set a vector to zero\nconst ZERO_VECTOR = [0, 0, 0, 0];\n// 4x4 matrix that drops 4th component of vector\nconst VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\nconst IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nconst DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];\nconst DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];\nconst getMemoizedViewportUniforms = memoize(calculateViewportUniforms);\nexport function getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN) {\n  if (coordinateOrigin.length < 3) {\n    coordinateOrigin = [coordinateOrigin[0], coordinateOrigin[1], 0];\n  }\n  let shaderCoordinateOrigin = coordinateOrigin;\n  let geospatialOrigin;\n  let offsetMode = true;\n  if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {\n    geospatialOrigin = coordinateOrigin;\n  } else {\n    geospatialOrigin = viewport.isGeospatial ?\n    // @ts-expect-error longitude and latitude are not defined on the base Viewport, but is expected on geospatial viewports\n    [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0] : null;\n  }\n  switch (viewport.projectionMode) {\n    case PROJECTION_MODE.WEB_MERCATOR:\n      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {\n        geospatialOrigin = [0, 0, 0];\n        offsetMode = false;\n      }\n      break;\n    case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:\n      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n        // viewport center in world space\n        // @ts-expect-error when using LNGLAT coordinates, we expect the viewport to be geospatial, in which case geospatialOrigin is defined\n        shaderCoordinateOrigin = geospatialOrigin;\n      } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {\n        // viewport center in common space\n        shaderCoordinateOrigin = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1]), 0];\n        // Geospatial origin (wgs84) must match shaderCoordinateOrigin (common)\n        geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);\n        shaderCoordinateOrigin[0] -= coordinateOrigin[0];\n        shaderCoordinateOrigin[1] -= coordinateOrigin[1];\n        shaderCoordinateOrigin[2] -= coordinateOrigin[2];\n      }\n      break;\n    case PROJECTION_MODE.IDENTITY:\n      shaderCoordinateOrigin = viewport.position.map(Math.fround);\n      shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;\n      break;\n    case PROJECTION_MODE.GLOBE:\n      offsetMode = false;\n      geospatialOrigin = null;\n      break;\n    default:\n      // Unknown projection mode\n      offsetMode = false;\n  }\n  return {\n    geospatialOrigin,\n    shaderCoordinateOrigin,\n    offsetMode\n  };\n}\n// The code that utilizes Matrix4 does the same calculation as their mat4 counterparts,\n// has lower performance but provides error checking.\nfunction calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {\n  const {\n    viewMatrixUncentered,\n    projectionMatrix\n  } = viewport;\n  let {\n    viewMatrix,\n    viewProjectionMatrix\n  } = viewport;\n  let projectionCenter = ZERO_VECTOR;\n  let originCommon = ZERO_VECTOR;\n  let cameraPosCommon = viewport.cameraPosition;\n  const {\n    geospatialOrigin,\n    shaderCoordinateOrigin,\n    offsetMode\n  } = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin);\n  if (offsetMode) {\n    // Calculate transformed projectionCenter (using 64 bit precision JS)\n    // This is the key to offset mode precision\n    // (avoids doing this addition in 32 bit precision in GLSL)\n    // @ts-expect-error the 4th component is assigned below\n    originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);\n    cameraPosCommon = [cameraPosCommon[0] - originCommon[0], cameraPosCommon[1] - originCommon[1], cameraPosCommon[2] - originCommon[2]];\n    originCommon[3] = 1;\n    // projectionCenter = new Matrix4(viewProjectionMatrix)\n    //   .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);\n    projectionCenter = vec4.transformMat4([], originCommon, viewProjectionMatrix);\n    // Always apply uncentered projection matrix if available (shader adds center)\n    viewMatrix = viewMatrixUncentered || viewMatrix;\n    // Zero out 4th coordinate (\"after\" model matrix) - avoids further translations\n    // viewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)\n    //   .multiplyRight(VECTOR_TO_POINT_MATRIX);\n    viewProjectionMatrix = mat4.multiply([], projectionMatrix, viewMatrix);\n    viewProjectionMatrix = mat4.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);\n  }\n  return {\n    viewMatrix: viewMatrix,\n    viewProjectionMatrix: viewProjectionMatrix,\n    projectionCenter,\n    originCommon,\n    cameraPosCommon,\n    shaderCoordinateOrigin,\n    geospatialOrigin\n  };\n}\n/**\n * Returns uniforms for shaders based on current projection\n * includes: projection matrix suitable for shaders\n *\n * TODO - Ensure this works with any viewport, not just WebMercatorViewports\n *\n * @param {WebMercatorViewport} viewport -\n * @return {Float32Array} - 4x4 projection matrix that can be used in shaders\n */\nexport function getUniformsFromViewport({\n  viewport,\n  devicePixelRatio = 1,\n  modelMatrix = null,\n  // Match Layer.defaultProps\n  coordinateSystem = COORDINATE_SYSTEM.DEFAULT,\n  coordinateOrigin = DEFAULT_COORDINATE_ORIGIN,\n  autoWrapLongitude = false\n}) {\n  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;\n  }\n  const uniforms = getMemoizedViewportUniforms({\n    viewport,\n    devicePixelRatio,\n    coordinateSystem,\n    coordinateOrigin\n  });\n  uniforms.wrapLongitude = autoWrapLongitude;\n  uniforms.modelMatrix = modelMatrix || IDENTITY_MATRIX;\n  return uniforms;\n}\nfunction calculateViewportUniforms({\n  viewport,\n  devicePixelRatio,\n  coordinateSystem,\n  coordinateOrigin\n}) {\n  const {\n    projectionCenter,\n    viewProjectionMatrix,\n    originCommon,\n    cameraPosCommon,\n    shaderCoordinateOrigin,\n    geospatialOrigin\n  } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);\n  // Calculate projection pixels per unit\n  const distanceScales = viewport.getDistanceScales();\n  const viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];\n  // Distance at which screen pixels are projected.\n  // Used to scale sizes in clipspace to match screen pixels.\n  // When using Viewport class's default projection matrix, this yields 1 for orthographic\n  // and `viewport.focalDistance` for perspective views\n  const focalDistance = vec4.transformMat4([], [0, 0, -viewport.focalDistance, 1], viewport.projectionMatrix)[3] || 1;\n  const uniforms = {\n    // Projection mode values\n    coordinateSystem,\n    projectionMode: viewport.projectionMode,\n    coordinateOrigin: shaderCoordinateOrigin,\n    commonOrigin: originCommon.slice(0, 3),\n    center: projectionCenter,\n    // Backward compatibility\n    // TODO: remove in v9\n    // @ts-expect-error _pseudoMeters is only defined on WebMercator viewport\n    pseudoMeters: Boolean(viewport._pseudoMeters),\n    // Screen size\n    viewportSize,\n    devicePixelRatio,\n    focalDistance,\n    commonUnitsPerMeter: distanceScales.unitsPerMeter,\n    commonUnitsPerWorldUnit: distanceScales.unitsPerMeter,\n    commonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,\n    scale: viewport.scale,\n    // This is the mercator scale (2 ** zoom)\n    wrapLongitude: false,\n    viewProjectionMatrix,\n    modelMatrix: IDENTITY_MATRIX,\n    // This is for lighting calculations\n    cameraPosition: cameraPosCommon\n  };\n  if (geospatialOrigin) {\n    // Get high-precision DistanceScales from geospatial viewport\n    // TODO: stricter types in Viewport classes\n    const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);\n    switch (coordinateSystem) {\n      case COORDINATE_SYSTEM.METER_OFFSETS:\n        uniforms.commonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;\n        uniforms.commonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;\n        break;\n      case COORDINATE_SYSTEM.LNGLAT:\n      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n        // @ts-expect-error _pseudoMeters only exists on WebMercatorView\n        if (!viewport._pseudoMeters) {\n          uniforms.commonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;\n        }\n        uniforms.commonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;\n        uniforms.commonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;\n        break;\n      // a.k.a \"preprojected\" positions\n      case COORDINATE_SYSTEM.CARTESIAN:\n        uniforms.commonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];\n        uniforms.commonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];\n        break;\n      default:\n        break;\n    }\n  }\n  return uniforms;\n}\n//# sourceMappingURL=viewport-uniforms.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}