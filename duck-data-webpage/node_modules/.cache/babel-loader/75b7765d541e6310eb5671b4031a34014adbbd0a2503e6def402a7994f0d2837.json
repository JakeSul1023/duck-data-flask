{"ast":null,"code":"import { getBlobOrSVGDataUrl } from \"./svg-utils.js\";\n// Parses html image from array buffer\nexport async function parseToImage(arrayBuffer, options, url) {\n  // Note: image parsing requires conversion to Blob (for createObjectURL).\n  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n  // But presumably not worth adding 'blob' flag to loader objects?\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\nexport async function loadToImage(url, options) {\n  const image = new Image();\n  image.src = url;\n  // The `image.onload()` callback does not guarantee that the image has been decoded\n  // so a main thread \"freeze\" can be incurred when using the image for the first time.\n  // `Image.decode()` returns a promise that completes when image is decoded.\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n  // Create a promise that tracks onload/onerror callbacks\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = error => {\n        const message = error instanceof Error ? error.message : 'error';\n        reject(new Error(message));\n      };\n    } catch (error) {\n      reject(error);\n    }\n  });\n}","map":{"version":3,"names":["getBlobOrSVGDataUrl","parseToImage","arrayBuffer","options","url","blobOrDataUrl","URL","self","webkitURL","objectUrl","createObjectURL","loadToImage","revokeObjectURL","image","Image","src","decode","Promise","resolve","reject","onload","onerror","error","message","Error"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image.js"],"sourcesContent":["import { getBlobOrSVGDataUrl } from \"./svg-utils.js\";\n// Parses html image from array buffer\nexport async function parseToImage(arrayBuffer, options, url) {\n    // Note: image parsing requires conversion to Blob (for createObjectURL).\n    // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n    // But presumably not worth adding 'blob' flag to loader objects?\n    const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n    const URL = self.URL || self.webkitURL;\n    const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n    try {\n        return await loadToImage(objectUrl || blobOrDataUrl, options);\n    }\n    finally {\n        if (objectUrl) {\n            URL.revokeObjectURL(objectUrl);\n        }\n    }\n}\nexport async function loadToImage(url, options) {\n    const image = new Image();\n    image.src = url;\n    // The `image.onload()` callback does not guarantee that the image has been decoded\n    // so a main thread \"freeze\" can be incurred when using the image for the first time.\n    // `Image.decode()` returns a promise that completes when image is decoded.\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n    // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n    // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n    if (options.image && options.image.decode && image.decode) {\n        await image.decode();\n        return image;\n    }\n    // Create a promise that tracks onload/onerror callbacks\n    return await new Promise((resolve, reject) => {\n        try {\n            image.onload = () => resolve(image);\n            image.onerror = (error) => {\n                const message = error instanceof Error ? error.message : 'error';\n                reject(new Error(message));\n            };\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n"],"mappings":"AAAA,SAASA,mBAAmB,QAAQ,gBAAgB;AACpD;AACA,OAAO,eAAeC,YAAYA,CAACC,WAAW,EAAEC,OAAO,EAAEC,GAAG,EAAE;EAC1D;EACA;EACA;EACA,MAAMC,aAAa,GAAGL,mBAAmB,CAACE,WAAW,EAAEE,GAAG,CAAC;EAC3D,MAAME,GAAG,GAAGC,IAAI,CAACD,GAAG,IAAIC,IAAI,CAACC,SAAS;EACtC,MAAMC,SAAS,GAAG,OAAOJ,aAAa,KAAK,QAAQ,IAAIC,GAAG,CAACI,eAAe,CAACL,aAAa,CAAC;EACzF,IAAI;IACA,OAAO,MAAMM,WAAW,CAACF,SAAS,IAAIJ,aAAa,EAAEF,OAAO,CAAC;EACjE,CAAC,SACO;IACJ,IAAIM,SAAS,EAAE;MACXH,GAAG,CAACM,eAAe,CAACH,SAAS,CAAC;IAClC;EACJ;AACJ;AACA,OAAO,eAAeE,WAAWA,CAACP,GAAG,EAAED,OAAO,EAAE;EAC5C,MAAMU,KAAK,GAAG,IAAIC,KAAK,CAAC,CAAC;EACzBD,KAAK,CAACE,GAAG,GAAGX,GAAG;EACf;EACA;EACA;EACA;EACA;EACA;EACA,IAAID,OAAO,CAACU,KAAK,IAAIV,OAAO,CAACU,KAAK,CAACG,MAAM,IAAIH,KAAK,CAACG,MAAM,EAAE;IACvD,MAAMH,KAAK,CAACG,MAAM,CAAC,CAAC;IACpB,OAAOH,KAAK;EAChB;EACA;EACA,OAAO,MAAM,IAAII,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IAC1C,IAAI;MACAN,KAAK,CAACO,MAAM,GAAG,MAAMF,OAAO,CAACL,KAAK,CAAC;MACnCA,KAAK,CAACQ,OAAO,GAAIC,KAAK,IAAK;QACvB,MAAMC,OAAO,GAAGD,KAAK,YAAYE,KAAK,GAAGF,KAAK,CAACC,OAAO,GAAG,OAAO;QAChEJ,MAAM,CAAC,IAAIK,KAAK,CAACD,OAAO,CAAC,CAAC;MAC9B,CAAC;IACL,CAAC,CACD,OAAOD,KAAK,EAAE;MACVH,MAAM,CAACG,KAAK,CAAC;IACjB;EACJ,CAAC,CAAC;AACN","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}