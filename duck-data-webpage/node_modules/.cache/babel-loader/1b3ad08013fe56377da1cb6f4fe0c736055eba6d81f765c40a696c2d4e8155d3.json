{"ast":null,"code":"import { RecognizerState } from \"./recognizer-state.js\";\nimport { uniqueId } from \"../utils/unique-id.js\";\nimport { stateStr } from \"./state-str.js\";\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n */\nexport class Recognizer {\n  constructor(options) {\n    this.options = options;\n    this.id = uniqueId();\n    this.state = RecognizerState.Possible;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  /**\n   * set options\n   */\n  set(options) {\n    Object.assign(this.options, options);\n    // also update the touchAction, in case something changed about the directions/enabled state\n    this.manager.touchAction.update();\n    return this;\n  }\n  /**\n   * recognize simultaneous with an other recognizer.\n   */\n  recognizeWith(recognizerOrName) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.recognizeWith(item);\n      }\n      return this;\n    }\n    let otherRecognizer;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n      if (!otherRecognizer) {\n        throw new Error(`Cannot find recognizer ${recognizerOrName}`);\n      }\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    const {\n      simultaneous\n    } = this;\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n    return this;\n  }\n  /**\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   */\n  dropRecognizeWith(recognizerOrName) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.dropRecognizeWith(item);\n      }\n      return this;\n    }\n    let otherRecognizer;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    if (otherRecognizer) {\n      delete this.simultaneous[otherRecognizer.id];\n    }\n    return this;\n  }\n  /**\n   * recognizer can only run when an other is failing\n   */\n  requireFailure(recognizerOrName) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.requireFailure(item);\n      }\n      return this;\n    }\n    let otherRecognizer;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n      if (!otherRecognizer) {\n        throw new Error(`Cannot find recognizer ${recognizerOrName}`);\n      }\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    const {\n      requireFail\n    } = this;\n    if (requireFail.indexOf(otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n    return this;\n  }\n  /**\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   */\n  dropRequireFailure(recognizerOrName) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.dropRequireFailure(item);\n      }\n      return this;\n    }\n    let otherRecognizer;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    if (otherRecognizer) {\n      const index = this.requireFail.indexOf(otherRecognizer);\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n    }\n    return this;\n  }\n  /**\n   * has require failures boolean\n   */\n  hasRequireFailures() {\n    return Boolean(this.requireFail.find(recognier => recognier.options.enable));\n  }\n  /**\n   * if the recognizer can recognize simultaneous with an other recognizer\n   */\n  canRecognizeWith(otherRecognizer) {\n    return Boolean(this.simultaneous[otherRecognizer.id]);\n  }\n  /**\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   */\n  emit(input) {\n    // Some recognizers override emit() with their own logic\n    if (!input) return;\n    const {\n      state\n    } = this;\n    // 'panstart' and 'panmove'\n    if (state < RecognizerState.Ended) {\n      this.manager.emit(this.options.event + stateStr(state), input);\n    }\n    // simple 'eventName' events\n    this.manager.emit(this.options.event, input);\n    // additional event(panleft, panright, pinchin, pinchout...)\n    if (input.additionalEvent) {\n      this.manager.emit(input.additionalEvent, input);\n    }\n    // panend and pancancel\n    if (state >= RecognizerState.Ended) {\n      this.manager.emit(this.options.event + stateStr(state), input);\n    }\n  }\n  /**\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   */\n  tryEmit(input) {\n    if (this.canEmit()) {\n      this.emit(input);\n    } else {\n      // it's failing anyway\n      this.state = RecognizerState.Failed;\n    }\n  }\n  /**\n   * can we emit?\n   */\n  canEmit() {\n    let i = 0;\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (RecognizerState.Failed | RecognizerState.Possible))) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  }\n  /**\n   * update the recognizer\n   */\n  recognize(inputData) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    const inputDataClone = {\n      ...inputData\n    };\n    // is is enabled and allow recognizing?\n    if (!this.options.enable) {\n      this.reset();\n      this.state = RecognizerState.Failed;\n      return;\n    }\n    // reset when we've reached the end\n    if (this.state & (RecognizerState.Recognized | RecognizerState.Cancelled | RecognizerState.Failed)) {\n      this.state = RecognizerState.Possible;\n    }\n    this.state = this.process(inputDataClone);\n    // the recognizer has recognized a gesture\n    // so trigger an event\n    if (this.state & (RecognizerState.Began | RecognizerState.Changed | RecognizerState.Ended | RecognizerState.Cancelled)) {\n      this.tryEmit(inputDataClone);\n    }\n  }\n  /**\n   * return the event names that are emitted by this recognizer\n   */\n  getEventNames() {\n    return [this.options.event];\n  }\n  /**\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   */\n  reset() {}\n}","map":{"version":3,"names":["RecognizerState","uniqueId","stateStr","Recognizer","constructor","options","id","state","Possible","simultaneous","requireFail","set","Object","assign","manager","touchAction","update","recognizeWith","recognizerOrName","Array","isArray","item","otherRecognizer","get","Error","dropRecognizeWith","requireFailure","indexOf","push","dropRequireFailure","index","splice","hasRequireFailures","Boolean","find","recognier","enable","canRecognizeWith","emit","input","Ended","event","additionalEvent","tryEmit","canEmit","Failed","i","length","recognize","inputData","inputDataClone","reset","Recognized","Cancelled","process","Began","Changed","getEventNames"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\mjolnir.js\\src\\hammerjs\\recognizer\\recognizer.ts"],"sourcesContent":["import {RecognizerState} from './recognizer-state';\nimport {uniqueId} from '../utils/unique-id';\nimport {stateStr} from './state-str';\n\nimport type {Manager} from '../manager';\nimport type {HammerInput} from '../input/types';\n\nexport type RecognizerOptions = {\n  /** Name of the event */\n  event: string;\n  /** Enable this recognizer */\n  enable: boolean;\n};\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n */\nexport abstract class Recognizer<OptionsT extends RecognizerOptions = any> {\n  id: number;\n  state: RecognizerState;\n  manager!: Manager;\n\n  readonly options: OptionsT;\n\n  protected simultaneous: {[id: string]: Recognizer};\n  protected requireFail: Recognizer[];\n\n  constructor(options: OptionsT) {\n    this.options = options;\n\n    this.id = uniqueId();\n\n    this.state = RecognizerState.Possible;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n\n  /**\n   * set options\n   */\n  set(options: Partial<OptionsT>) {\n    Object.assign(this.options, options);\n\n    // also update the touchAction, in case something changed about the directions/enabled state\n    this.manager.touchAction.update();\n    return this;\n  }\n\n  /**\n   * recognize simultaneous with an other recognizer.\n   */\n  recognizeWith(recognizerOrName: Recognizer | string | (Recognizer | string)[]) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.recognizeWith(item);\n      }\n      return this;\n    }\n\n    let otherRecognizer: Recognizer | null;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n      if (!otherRecognizer) {\n        throw new Error(`Cannot find recognizer ${recognizerOrName}`);\n      }\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    const {simultaneous} = this;\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n    return this;\n  }\n\n  /**\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   */\n  dropRecognizeWith(recognizerOrName: Recognizer | string | (Recognizer | string)[]) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.dropRecognizeWith(item);\n      }\n      return this;\n    }\n\n    let otherRecognizer: Recognizer | null;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    if (otherRecognizer) {\n      delete this.simultaneous[otherRecognizer.id];\n    }\n    return this;\n  }\n\n  /**\n   * recognizer can only run when an other is failing\n   */\n  requireFailure(recognizerOrName: Recognizer | string | (Recognizer | string)[]) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.requireFailure(item);\n      }\n      return this;\n    }\n\n    let otherRecognizer: Recognizer | null;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n      if (!otherRecognizer) {\n        throw new Error(`Cannot find recognizer ${recognizerOrName}`);\n      }\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    const {requireFail} = this;\n    if (requireFail.indexOf(otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n    return this;\n  }\n\n  /**\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   */\n  dropRequireFailure(recognizerOrName: Recognizer | string | (Recognizer | string)[]) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.dropRequireFailure(item);\n      }\n      return this;\n    }\n\n    let otherRecognizer: Recognizer | null;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    if (otherRecognizer) {\n      const index = this.requireFail.indexOf(otherRecognizer);\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * has require failures boolean\n   */\n  hasRequireFailures(): boolean {\n    return Boolean(this.requireFail.find((recognier) => recognier.options.enable));\n  }\n\n  /**\n   * if the recognizer can recognize simultaneous with an other recognizer\n   */\n  canRecognizeWith(otherRecognizer: Recognizer): boolean {\n    return Boolean(this.simultaneous[otherRecognizer.id]);\n  }\n\n  /**\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   */\n  protected emit(input?: HammerInput) {\n    // Some recognizers override emit() with their own logic\n    if (!input) return;\n\n    const {state} = this;\n\n    // 'panstart' and 'panmove'\n    if (state < RecognizerState.Ended) {\n      this.manager.emit(this.options.event + stateStr(state), input);\n    }\n\n    // simple 'eventName' events\n    this.manager.emit(this.options.event, input);\n\n    // additional event(panleft, panright, pinchin, pinchout...)\n    if (input.additionalEvent) {\n      this.manager.emit(input.additionalEvent, input);\n    }\n\n    // panend and pancancel\n    if (state >= RecognizerState.Ended) {\n      this.manager.emit(this.options.event + stateStr(state), input);\n    }\n  }\n\n  /**\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   */\n  protected tryEmit(input?: HammerInput) {\n    if (this.canEmit()) {\n      this.emit(input);\n    } else {\n      // it's failing anyway\n      this.state = RecognizerState.Failed;\n    }\n  }\n\n  /**\n   * can we emit?\n   */\n  protected canEmit(): boolean {\n    let i = 0;\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (RecognizerState.Failed | RecognizerState.Possible))) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  }\n\n  /**\n   * update the recognizer\n   */\n  recognize(inputData: HammerInput) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    const inputDataClone = {...inputData};\n\n    // is is enabled and allow recognizing?\n    if (!this.options.enable) {\n      this.reset();\n      this.state = RecognizerState.Failed;\n      return;\n    }\n\n    // reset when we've reached the end\n    if (\n      this.state &\n      (RecognizerState.Recognized | RecognizerState.Cancelled | RecognizerState.Failed)\n    ) {\n      this.state = RecognizerState.Possible;\n    }\n\n    this.state = this.process(inputDataClone);\n\n    // the recognizer has recognized a gesture\n    // so trigger an event\n    if (\n      this.state &\n      (RecognizerState.Began |\n        RecognizerState.Changed |\n        RecognizerState.Ended |\n        RecognizerState.Cancelled)\n    ) {\n      this.tryEmit(inputDataClone);\n    }\n  }\n\n  /**\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   */\n\n  abstract process(inputData: HammerInput): RecognizerState;\n\n  /**\n   * return the preferred touch-action\n   */\n  abstract getTouchAction(): string[];\n\n  /**\n   * return the event names that are emitted by this recognizer\n   */\n  getEventNames(): string[] {\n    return [this.options.event];\n  }\n\n  /**\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   */\n  reset(): void {}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}