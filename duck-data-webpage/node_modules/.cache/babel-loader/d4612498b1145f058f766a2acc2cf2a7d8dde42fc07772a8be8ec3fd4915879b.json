{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getTableLength } from \"./table-accessors.js\";\n/**\n * Returns an iterator that yields a single table as a sequence of batches.\n * @note Currently only a single batch is yielded.\n * @note All batches will have the same shape and schema as the original table.\n * @returns\n */\nexport function* makeBatchesFromTable(table) {\n  yield makeBatchFromTable(table);\n}\n/**\n * Returns a table packaged as a single table batch\n * @note The batch will have the same shape and schema as the original table.\n * @returns `null` if no batches are yielded by the async iterator\n */\nexport function makeBatchFromTable(table) {\n  return {\n    ...table,\n    length: getTableLength(table),\n    batchType: 'data'\n  };\n}\n/**\n * Assembles all batches from an async iterator into a single table.\n * @note All batches must have the same shape and schema\n * @param batchIterator\n * @returns `null` if no batches are yielded by the async iterator\n */\n// eslint-disable-next-line complexity\nexport async function makeTableFromBatches(batchIterator) {\n  let arrayRows;\n  let objectRows;\n  let features;\n  let shape = null;\n  let schema;\n  for await (const batch of batchIterator) {\n    shape = shape || batch.shape;\n    schema = schema || batch.schema;\n    switch (batch.shape) {\n      case 'array-row-table':\n        arrayRows = arrayRows || [];\n        for (let rowIndex = 0; rowIndex < getTableLength(batch); rowIndex++) {\n          const row = batch.data[rowIndex];\n          arrayRows.push(row);\n        }\n        break;\n      case 'object-row-table':\n        objectRows = objectRows || [];\n        for (let rowIndex = 0; rowIndex < getTableLength(batch); rowIndex++) {\n          const row = batch.data[rowIndex];\n          objectRows.push(row);\n        }\n        break;\n      case 'geojson-table':\n        features = features || [];\n        for (let rowIndex = 0; rowIndex < getTableLength(batch); rowIndex++) {\n          const row = batch.features[rowIndex];\n          features.push(row);\n        }\n        break;\n      case 'columnar-table':\n      case 'arrow-table':\n      default:\n        throw new Error('shape');\n    }\n  }\n  if (!shape) {\n    return null;\n  }\n  switch (shape) {\n    case 'array-row-table':\n      return {\n        shape: 'array-row-table',\n        data: arrayRows,\n        schema\n      };\n    case 'object-row-table':\n      return {\n        shape: 'object-row-table',\n        data: objectRows,\n        schema\n      };\n    case 'geojson-table':\n      return {\n        shape: 'geojson-table',\n        type: 'FeatureCollection',\n        features: features,\n        schema\n      };\n    default:\n      return null;\n  }\n}","map":{"version":3,"names":["getTableLength","makeBatchesFromTable","table","makeBatchFromTable","length","batchType","makeTableFromBatches","batchIterator","arrayRows","objectRows","features","shape","schema","batch","rowIndex","row","data","push","Error","type"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/schema/dist/lib/table/simple-table/make-table-from-batches.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getTableLength } from \"./table-accessors.js\";\n/**\n * Returns an iterator that yields a single table as a sequence of batches.\n * @note Currently only a single batch is yielded.\n * @note All batches will have the same shape and schema as the original table.\n * @returns\n */\nexport function* makeBatchesFromTable(table) {\n    yield makeBatchFromTable(table);\n}\n/**\n * Returns a table packaged as a single table batch\n * @note The batch will have the same shape and schema as the original table.\n * @returns `null` if no batches are yielded by the async iterator\n */\nexport function makeBatchFromTable(table) {\n    return { ...table, length: getTableLength(table), batchType: 'data' };\n}\n/**\n * Assembles all batches from an async iterator into a single table.\n * @note All batches must have the same shape and schema\n * @param batchIterator\n * @returns `null` if no batches are yielded by the async iterator\n */\n// eslint-disable-next-line complexity\nexport async function makeTableFromBatches(batchIterator) {\n    let arrayRows;\n    let objectRows;\n    let features;\n    let shape = null;\n    let schema;\n    for await (const batch of batchIterator) {\n        shape = shape || batch.shape;\n        schema = schema || batch.schema;\n        switch (batch.shape) {\n            case 'array-row-table':\n                arrayRows = arrayRows || [];\n                for (let rowIndex = 0; rowIndex < getTableLength(batch); rowIndex++) {\n                    const row = batch.data[rowIndex];\n                    arrayRows.push(row);\n                }\n                break;\n            case 'object-row-table':\n                objectRows = objectRows || [];\n                for (let rowIndex = 0; rowIndex < getTableLength(batch); rowIndex++) {\n                    const row = batch.data[rowIndex];\n                    objectRows.push(row);\n                }\n                break;\n            case 'geojson-table':\n                features = features || [];\n                for (let rowIndex = 0; rowIndex < getTableLength(batch); rowIndex++) {\n                    const row = batch.features[rowIndex];\n                    features.push(row);\n                }\n                break;\n            case 'columnar-table':\n            case 'arrow-table':\n            default:\n                throw new Error('shape');\n        }\n    }\n    if (!shape) {\n        return null;\n    }\n    switch (shape) {\n        case 'array-row-table':\n            return { shape: 'array-row-table', data: arrayRows, schema };\n        case 'object-row-table':\n            return { shape: 'object-row-table', data: objectRows, schema };\n        case 'geojson-table':\n            return { shape: 'geojson-table', type: 'FeatureCollection', features: features, schema };\n        default:\n            return null;\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,cAAc,QAAQ,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,UAAUC,oBAAoBA,CAACC,KAAK,EAAE;EACzC,MAAMC,kBAAkB,CAACD,KAAK,CAAC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,kBAAkBA,CAACD,KAAK,EAAE;EACtC,OAAO;IAAE,GAAGA,KAAK;IAAEE,MAAM,EAAEJ,cAAc,CAACE,KAAK,CAAC;IAAEG,SAAS,EAAE;EAAO,CAAC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAeC,oBAAoBA,CAACC,aAAa,EAAE;EACtD,IAAIC,SAAS;EACb,IAAIC,UAAU;EACd,IAAIC,QAAQ;EACZ,IAAIC,KAAK,GAAG,IAAI;EAChB,IAAIC,MAAM;EACV,WAAW,MAAMC,KAAK,IAAIN,aAAa,EAAE;IACrCI,KAAK,GAAGA,KAAK,IAAIE,KAAK,CAACF,KAAK;IAC5BC,MAAM,GAAGA,MAAM,IAAIC,KAAK,CAACD,MAAM;IAC/B,QAAQC,KAAK,CAACF,KAAK;MACf,KAAK,iBAAiB;QAClBH,SAAS,GAAGA,SAAS,IAAI,EAAE;QAC3B,KAAK,IAAIM,QAAQ,GAAG,CAAC,EAAEA,QAAQ,GAAGd,cAAc,CAACa,KAAK,CAAC,EAAEC,QAAQ,EAAE,EAAE;UACjE,MAAMC,GAAG,GAAGF,KAAK,CAACG,IAAI,CAACF,QAAQ,CAAC;UAChCN,SAAS,CAACS,IAAI,CAACF,GAAG,CAAC;QACvB;QACA;MACJ,KAAK,kBAAkB;QACnBN,UAAU,GAAGA,UAAU,IAAI,EAAE;QAC7B,KAAK,IAAIK,QAAQ,GAAG,CAAC,EAAEA,QAAQ,GAAGd,cAAc,CAACa,KAAK,CAAC,EAAEC,QAAQ,EAAE,EAAE;UACjE,MAAMC,GAAG,GAAGF,KAAK,CAACG,IAAI,CAACF,QAAQ,CAAC;UAChCL,UAAU,CAACQ,IAAI,CAACF,GAAG,CAAC;QACxB;QACA;MACJ,KAAK,eAAe;QAChBL,QAAQ,GAAGA,QAAQ,IAAI,EAAE;QACzB,KAAK,IAAII,QAAQ,GAAG,CAAC,EAAEA,QAAQ,GAAGd,cAAc,CAACa,KAAK,CAAC,EAAEC,QAAQ,EAAE,EAAE;UACjE,MAAMC,GAAG,GAAGF,KAAK,CAACH,QAAQ,CAACI,QAAQ,CAAC;UACpCJ,QAAQ,CAACO,IAAI,CAACF,GAAG,CAAC;QACtB;QACA;MACJ,KAAK,gBAAgB;MACrB,KAAK,aAAa;MAClB;QACI,MAAM,IAAIG,KAAK,CAAC,OAAO,CAAC;IAChC;EACJ;EACA,IAAI,CAACP,KAAK,EAAE;IACR,OAAO,IAAI;EACf;EACA,QAAQA,KAAK;IACT,KAAK,iBAAiB;MAClB,OAAO;QAAEA,KAAK,EAAE,iBAAiB;QAAEK,IAAI,EAAER,SAAS;QAAEI;MAAO,CAAC;IAChE,KAAK,kBAAkB;MACnB,OAAO;QAAED,KAAK,EAAE,kBAAkB;QAAEK,IAAI,EAAEP,UAAU;QAAEG;MAAO,CAAC;IAClE,KAAK,eAAe;MAChB,OAAO;QAAED,KAAK,EAAE,eAAe;QAAEQ,IAAI,EAAE,mBAAmB;QAAET,QAAQ,EAAEA,QAAQ;QAAEE;MAAO,CAAC;IAC5F;MACI,OAAO,IAAI;EACnB;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}