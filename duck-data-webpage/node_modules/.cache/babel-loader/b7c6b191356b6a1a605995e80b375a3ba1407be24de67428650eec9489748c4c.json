{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport { log } from '@luma.gl/core';\nimport { ScenegraphNode } from \"./scenegraph-node.js\";\nexport class GroupNode extends ScenegraphNode {\n  children;\n  constructor(props = {}) {\n    props = Array.isArray(props) ? {\n      children: props\n    } : props;\n    const {\n      children = []\n    } = props;\n    log.assert(children.every(child => child instanceof ScenegraphNode), 'every child must an instance of ScenegraphNode');\n    super(props);\n    this.children = children;\n  }\n  getBounds() {\n    const result = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n    this.traverse((node, {\n      worldMatrix\n    }) => {\n      const bounds = node.getBounds();\n      if (!bounds) {\n        return;\n      }\n      const [min, max] = bounds;\n      const center = new Vector3(min).add(max).divide([2, 2, 2]);\n      worldMatrix.transformAsPoint(center, center);\n      const halfSize = new Vector3(max).subtract(min).divide([2, 2, 2]);\n      worldMatrix.transformAsVector(halfSize, halfSize);\n      for (let v = 0; v < 8; v++) {\n        // Test all 8 corners of the box\n        const position = new Vector3(v & 0b001 ? -1 : 1, v & 0b010 ? -1 : 1, v & 0b100 ? -1 : 1).multiply(halfSize).add(center);\n        for (let i = 0; i < 3; i++) {\n          result[0][i] = Math.min(result[0][i], position[i]);\n          result[1][i] = Math.max(result[1][i], position[i]);\n        }\n      }\n    });\n    if (!Number.isFinite(result[0][0])) {\n      return null;\n    }\n    return result;\n  }\n  destroy() {\n    this.children.forEach(child => child.destroy());\n    this.removeAll();\n    super.destroy();\n  }\n  // Unpacks arrays and nested arrays of children\n  add(...children) {\n    for (const child of children) {\n      if (Array.isArray(child)) {\n        this.add(...child);\n      } else {\n        this.children.push(child);\n      }\n    }\n    return this;\n  }\n  remove(child) {\n    const children = this.children;\n    const indexOf = children.indexOf(child);\n    if (indexOf > -1) {\n      children.splice(indexOf, 1);\n    }\n    return this;\n  }\n  removeAll() {\n    this.children = [];\n    return this;\n  }\n  traverse(visitor, {\n    worldMatrix = new Matrix4()\n  } = {}) {\n    const modelMatrix = new Matrix4(worldMatrix).multiplyRight(this.matrix);\n    for (const child of this.children) {\n      if (child instanceof GroupNode) {\n        child.traverse(visitor, {\n          worldMatrix: modelMatrix\n        });\n      } else {\n        visitor(child, {\n          worldMatrix: modelMatrix\n        });\n      }\n    }\n  }\n}","map":{"version":3,"names":["Matrix4","Vector3","log","ScenegraphNode","GroupNode","children","constructor","props","Array","isArray","assert","every","child","getBounds","result","Infinity","traverse","node","worldMatrix","bounds","min","max","center","add","divide","transformAsPoint","halfSize","subtract","transformAsVector","v","position","multiply","i","Math","Number","isFinite","destroy","forEach","removeAll","push","remove","indexOf","splice","visitor","modelMatrix","multiplyRight","matrix"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\engine\\src\\scenegraph\\group-node.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Matrix4, Vector3} from '@math.gl/core';\nimport {log} from '@luma.gl/core';\nimport {ScenegraphNode, ScenegraphNodeProps} from './scenegraph-node';\n\nexport type GroupNodeProps = ScenegraphNodeProps & {\n  children?: ScenegraphNode[];\n};\n\nexport class GroupNode extends ScenegraphNode {\n  children: ScenegraphNode[];\n\n  constructor(children: ScenegraphNode[]);\n  constructor(props?: GroupNodeProps);\n\n  constructor(props: ScenegraphNode[] | GroupNodeProps = {}) {\n    props = Array.isArray(props) ? {children: props} : props;\n    const {children = []} = props;\n    log.assert(\n      children.every(child => child instanceof ScenegraphNode),\n      'every child must an instance of ScenegraphNode'\n    );\n    super(props);\n    this.children = children;\n  }\n\n  override getBounds(): [number[], number[]] | null {\n    const result: [number[], number[]] = [\n      [Infinity, Infinity, Infinity],\n      [-Infinity, -Infinity, -Infinity]\n    ];\n\n    this.traverse((node, {worldMatrix}) => {\n      const bounds = node.getBounds();\n      if (!bounds) {\n        return;\n      }\n      const [min, max] = bounds;\n      const center = new Vector3(min).add(max).divide([2, 2, 2]);\n      worldMatrix.transformAsPoint(center, center);\n      const halfSize = new Vector3(max).subtract(min).divide([2, 2, 2]);\n      worldMatrix.transformAsVector(halfSize, halfSize);\n\n      for (let v = 0; v < 8; v++) {\n        // Test all 8 corners of the box\n        const position = new Vector3(v & 0b001 ? -1 : 1, v & 0b010 ? -1 : 1, v & 0b100 ? -1 : 1)\n          .multiply(halfSize)\n          .add(center);\n\n        for (let i = 0; i < 3; i++) {\n          result[0][i] = Math.min(result[0][i], position[i]);\n          result[1][i] = Math.max(result[1][i], position[i]);\n        }\n      }\n    });\n    if (!Number.isFinite(result[0][0])) {\n      return null;\n    }\n    return result;\n  }\n\n  override destroy(): void {\n    this.children.forEach(child => child.destroy());\n    this.removeAll();\n    super.destroy();\n  }\n\n  // Unpacks arrays and nested arrays of children\n  add(...children: (ScenegraphNode | ScenegraphNode[])[]): this {\n    for (const child of children) {\n      if (Array.isArray(child)) {\n        this.add(...child);\n      } else {\n        this.children.push(child);\n      }\n    }\n    return this;\n  }\n\n  remove(child: ScenegraphNode): this {\n    const children = this.children;\n    const indexOf = children.indexOf(child);\n    if (indexOf > -1) {\n      children.splice(indexOf, 1);\n    }\n    return this;\n  }\n\n  removeAll(): this {\n    this.children = [];\n    return this;\n  }\n\n  traverse(\n    visitor: (node: ScenegraphNode, context: {worldMatrix: Matrix4}) => void,\n    {worldMatrix = new Matrix4()} = {}\n  ) {\n    const modelMatrix = new Matrix4(worldMatrix).multiplyRight(this.matrix);\n\n    for (const child of this.children) {\n      if (child instanceof GroupNode) {\n        child.traverse(visitor, {worldMatrix: modelMatrix});\n      } else {\n        visitor(child, {worldMatrix: modelMatrix});\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}