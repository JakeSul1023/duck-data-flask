{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBrowser, isFileProvider, FileHandleFile } from '@loaders.gl/loader-utils';\nimport { makeZipCDHeaderIterator } from \"../parse-zip/cd-file-header.js\";\nimport { parseZipLocalFileHeader } from \"../parse-zip/local-file-header.js\";\nimport { DeflateCompression } from '@loaders.gl/compression';\nimport { IndexedArchive } from \"./IndexedArchive.js\";\n/** Handling different compression types in zip */\nexport const ZIP_COMPRESSION_HANDLERS = {\n  /** No compression */\n  0: async compressedFile => compressedFile,\n  /** Deflation */\n  8: async compressedFile => {\n    const compression = new DeflateCompression({\n      raw: true\n    });\n    const decompressedData = await compression.decompress(compressedFile);\n    return decompressedData;\n  }\n};\n/**\n * FileSystem adapter for a ZIP file\n * Holds FileProvider object that provides random access to archived files\n */\nexport class ZipFileSystem {\n  /** FileProvider instance promise */\n  fileProvider = null;\n  fileName;\n  archive = null;\n  /**\n   * Constructor\n   * @param file - instance of FileProvider or file path string\n   */\n  constructor(file) {\n    // Try to open file in NodeJS\n    if (typeof file === 'string') {\n      this.fileName = file;\n      if (!isBrowser) {\n        this.fileProvider = new FileHandleFile(file);\n      } else {\n        throw new Error('Cannot open file for random access in a WEB browser');\n      }\n    } else if (file instanceof IndexedArchive) {\n      this.fileProvider = file.fileProvider;\n      this.archive = file;\n      this.fileName = file.fileName;\n    } else if (isFileProvider(file)) {\n      this.fileProvider = file;\n    }\n  }\n  /** Clean up resources */\n  async destroy() {\n    if (this.fileProvider) {\n      await this.fileProvider.destroy();\n    }\n  }\n  /**\n   * Get file names list from zip archive\n   * @returns array of file names\n   */\n  async readdir() {\n    if (!this.fileProvider) {\n      throw new Error('No data detected in the zip archive');\n    }\n    const fileNames = [];\n    const zipCDIterator = makeZipCDHeaderIterator(this.fileProvider);\n    for await (const cdHeader of zipCDIterator) {\n      fileNames.push(cdHeader.fileName);\n    }\n    return fileNames;\n  }\n  /**\n   * Get file metadata\n   * @param filename - name of a file\n   * @returns central directory data\n   */\n  async stat(filename) {\n    const cdFileHeader = await this.getCDFileHeader(filename);\n    return {\n      ...cdFileHeader,\n      size: Number(cdFileHeader.uncompressedSize)\n    };\n  }\n  /**\n   * Implementation of fetch against this file system\n   * @param filename - name of a file\n   * @returns - Response with file data\n   */\n  async fetch(filename) {\n    if (this.fileName && filename.indexOf(this.fileName) === 0) {\n      filename = filename.substring(this.fileName.length + 1);\n    }\n    let uncompressedFile;\n    if (this.archive) {\n      uncompressedFile = await this.archive.getFile(filename, 'http');\n    } else {\n      if (!this.fileProvider) {\n        throw new Error('No data detected in the zip archive');\n      }\n      const cdFileHeader = await this.getCDFileHeader(filename);\n      const localFileHeader = await parseZipLocalFileHeader(cdFileHeader.localHeaderOffset, this.fileProvider);\n      if (!localFileHeader) {\n        throw new Error('Local file header has not been found in the zip archive`');\n      }\n      const compressionHandler = ZIP_COMPRESSION_HANDLERS[localFileHeader.compressionMethod.toString()];\n      if (!compressionHandler) {\n        throw Error('Only Deflation compression is supported');\n      }\n      const compressedFile = await this.fileProvider.slice(localFileHeader.fileDataOffset, localFileHeader.fileDataOffset + localFileHeader.compressedSize);\n      uncompressedFile = await compressionHandler(compressedFile);\n    }\n    const response = new Response(uncompressedFile);\n    Object.defineProperty(response, 'url', {\n      value: filename ? `${this.fileName || ''}/${filename}` : this.fileName || ''\n    });\n    return response;\n  }\n  /**\n   * Get central directory file header\n   * @param filename - name of a file\n   * @returns central directory file header\n   */\n  async getCDFileHeader(filename) {\n    if (!this.fileProvider) {\n      throw new Error('No data detected in the zip archive');\n    }\n    const zipCDIterator = makeZipCDHeaderIterator(this.fileProvider);\n    let result = null;\n    for await (const cdHeader of zipCDIterator) {\n      if (cdHeader.fileName === filename) {\n        result = cdHeader;\n        break;\n      }\n    }\n    if (!result) {\n      throw new Error('File has not been found in the zip archive');\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["isBrowser","isFileProvider","FileHandleFile","makeZipCDHeaderIterator","parseZipLocalFileHeader","DeflateCompression","IndexedArchive","ZIP_COMPRESSION_HANDLERS","compressedFile","compression","raw","decompressedData","decompress","ZipFileSystem","fileProvider","fileName","archive","constructor","file","Error","destroy","readdir","fileNames","zipCDIterator","cdHeader","push","stat","filename","cdFileHeader","getCDFileHeader","size","Number","uncompressedSize","fetch","indexOf","substring","length","uncompressedFile","getFile","localFileHeader","localHeaderOffset","compressionHandler","compressionMethod","toString","slice","fileDataOffset","compressedSize","response","Response","Object","defineProperty","value","result"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/zip/dist/filesystems/zip-filesystem.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBrowser, isFileProvider, FileHandleFile } from '@loaders.gl/loader-utils';\nimport { makeZipCDHeaderIterator } from \"../parse-zip/cd-file-header.js\";\nimport { parseZipLocalFileHeader } from \"../parse-zip/local-file-header.js\";\nimport { DeflateCompression } from '@loaders.gl/compression';\nimport { IndexedArchive } from \"./IndexedArchive.js\";\n/** Handling different compression types in zip */\nexport const ZIP_COMPRESSION_HANDLERS = {\n    /** No compression */\n    0: async (compressedFile) => compressedFile,\n    /** Deflation */\n    8: async (compressedFile) => {\n        const compression = new DeflateCompression({ raw: true });\n        const decompressedData = await compression.decompress(compressedFile);\n        return decompressedData;\n    }\n};\n/**\n * FileSystem adapter for a ZIP file\n * Holds FileProvider object that provides random access to archived files\n */\nexport class ZipFileSystem {\n    /** FileProvider instance promise */\n    fileProvider = null;\n    fileName;\n    archive = null;\n    /**\n     * Constructor\n     * @param file - instance of FileProvider or file path string\n     */\n    constructor(file) {\n        // Try to open file in NodeJS\n        if (typeof file === 'string') {\n            this.fileName = file;\n            if (!isBrowser) {\n                this.fileProvider = new FileHandleFile(file);\n            }\n            else {\n                throw new Error('Cannot open file for random access in a WEB browser');\n            }\n        }\n        else if (file instanceof IndexedArchive) {\n            this.fileProvider = file.fileProvider;\n            this.archive = file;\n            this.fileName = file.fileName;\n        }\n        else if (isFileProvider(file)) {\n            this.fileProvider = file;\n        }\n    }\n    /** Clean up resources */\n    async destroy() {\n        if (this.fileProvider) {\n            await this.fileProvider.destroy();\n        }\n    }\n    /**\n     * Get file names list from zip archive\n     * @returns array of file names\n     */\n    async readdir() {\n        if (!this.fileProvider) {\n            throw new Error('No data detected in the zip archive');\n        }\n        const fileNames = [];\n        const zipCDIterator = makeZipCDHeaderIterator(this.fileProvider);\n        for await (const cdHeader of zipCDIterator) {\n            fileNames.push(cdHeader.fileName);\n        }\n        return fileNames;\n    }\n    /**\n     * Get file metadata\n     * @param filename - name of a file\n     * @returns central directory data\n     */\n    async stat(filename) {\n        const cdFileHeader = await this.getCDFileHeader(filename);\n        return { ...cdFileHeader, size: Number(cdFileHeader.uncompressedSize) };\n    }\n    /**\n     * Implementation of fetch against this file system\n     * @param filename - name of a file\n     * @returns - Response with file data\n     */\n    async fetch(filename) {\n        if (this.fileName && filename.indexOf(this.fileName) === 0) {\n            filename = filename.substring(this.fileName.length + 1);\n        }\n        let uncompressedFile;\n        if (this.archive) {\n            uncompressedFile = await this.archive.getFile(filename, 'http');\n        }\n        else {\n            if (!this.fileProvider) {\n                throw new Error('No data detected in the zip archive');\n            }\n            const cdFileHeader = await this.getCDFileHeader(filename);\n            const localFileHeader = await parseZipLocalFileHeader(cdFileHeader.localHeaderOffset, this.fileProvider);\n            if (!localFileHeader) {\n                throw new Error('Local file header has not been found in the zip archive`');\n            }\n            const compressionHandler = ZIP_COMPRESSION_HANDLERS[localFileHeader.compressionMethod.toString()];\n            if (!compressionHandler) {\n                throw Error('Only Deflation compression is supported');\n            }\n            const compressedFile = await this.fileProvider.slice(localFileHeader.fileDataOffset, localFileHeader.fileDataOffset + localFileHeader.compressedSize);\n            uncompressedFile = await compressionHandler(compressedFile);\n        }\n        const response = new Response(uncompressedFile);\n        Object.defineProperty(response, 'url', {\n            value: filename ? `${this.fileName || ''}/${filename}` : this.fileName || ''\n        });\n        return response;\n    }\n    /**\n     * Get central directory file header\n     * @param filename - name of a file\n     * @returns central directory file header\n     */\n    async getCDFileHeader(filename) {\n        if (!this.fileProvider) {\n            throw new Error('No data detected in the zip archive');\n        }\n        const zipCDIterator = makeZipCDHeaderIterator(this.fileProvider);\n        let result = null;\n        for await (const cdHeader of zipCDIterator) {\n            if (cdHeader.fileName === filename) {\n                result = cdHeader;\n                break;\n            }\n        }\n        if (!result) {\n            throw new Error('File has not been found in the zip archive');\n        }\n        return result;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}