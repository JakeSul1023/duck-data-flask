{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { assert } from \"../utils/assert.js\";\nimport { getAccessorArrayTypeAndLength } from \"../gltf-utils/gltf-utils.js\";\n// This is a post processor for loaded glTF files\n// The goal is to make the loaded data easier to use in WebGL applications\n//\n// Functions:\n// * Resolve indexed arrays structure of glTF into a linked tree.\n// * Translate stringified enum keys and values into WebGL constants.\n// * Load images (optional)\n// ENUM LOOKUP\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst BYTES = {\n  5120: 1,\n  // BYTE\n  5121: 1,\n  // UNSIGNED_BYTE\n  5122: 2,\n  // SHORT\n  5123: 2,\n  // UNSIGNED_SHORT\n  5125: 4,\n  // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\nconst GL_SAMPLER = {\n  // Sampler parameters\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n  // Sampler default values\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\nconst SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\n// When undefined, a sampler with repeat wrapping and auto filtering should be used.\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\nconst DEFAULT_SAMPLER_PARAMETERS = {\n  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,\n  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,\n  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,\n  [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT\n};\nfunction makeDefaultSampler() {\n  return {\n    id: 'default-sampler',\n    parameters: DEFAULT_SAMPLER_PARAMETERS\n  };\n}\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\nclass GLTFPostProcessor {\n  baseUri = '';\n  // @ts-expect-error\n  jsonUnprocessed;\n  // @ts-expect-error\n  json;\n  buffers = [];\n  images = [];\n  postProcess(gltf, options = {}) {\n    const {\n      json,\n      buffers = [],\n      images = []\n    } = gltf;\n    // @ts-expect-error\n    const {\n      baseUri = ''\n    } = gltf;\n    assert(json);\n    this.baseUri = baseUri;\n    this.buffers = buffers;\n    this.images = images;\n    this.jsonUnprocessed = json;\n    this.json = this._resolveTree(gltf.json, options);\n    return this.json;\n  }\n  // Convert indexed glTF structure into tree structure\n  // cross-link index resolution, enum lookup, convenience calculations\n  // eslint-disable-next-line complexity, max-statements\n  _resolveTree(gltf, options = {}) {\n    // @ts-expect-error\n    const json = {\n      ...gltf\n    };\n    this.json = json;\n    if (gltf.bufferViews) {\n      json.bufferViews = gltf.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));\n    }\n    if (gltf.images) {\n      json.images = gltf.images.map((image, i) => this._resolveImage(image, i));\n    }\n    if (gltf.samplers) {\n      json.samplers = gltf.samplers.map((sampler, i) => this._resolveSampler(sampler, i));\n    }\n    if (gltf.textures) {\n      json.textures = gltf.textures.map((texture, i) => this._resolveTexture(texture, i));\n    }\n    if (gltf.accessors) {\n      json.accessors = gltf.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));\n    }\n    if (gltf.materials) {\n      json.materials = gltf.materials.map((material, i) => this._resolveMaterial(material, i));\n    }\n    if (gltf.meshes) {\n      json.meshes = gltf.meshes.map((mesh, i) => this._resolveMesh(mesh, i));\n    }\n    if (gltf.nodes) {\n      json.nodes = gltf.nodes.map((node, i) => this._resolveNode(node, i));\n      json.nodes = json.nodes.map((node, i) => this._resolveNodeChildren(node));\n    }\n    if (gltf.skins) {\n      json.skins = gltf.skins.map((skin, i) => this._resolveSkin(skin, i));\n    }\n    if (gltf.scenes) {\n      json.scenes = gltf.scenes.map((scene, i) => this._resolveScene(scene, i));\n    }\n    if (typeof this.json.scene === 'number' && json.scenes) {\n      json.scene = json.scenes[this.json.scene];\n    }\n    return json;\n  }\n  getScene(index) {\n    return this._get(this.json.scenes, index);\n  }\n  getNode(index) {\n    return this._get(this.json.nodes, index);\n  }\n  getSkin(index) {\n    return this._get(this.json.skins, index);\n  }\n  getMesh(index) {\n    return this._get(this.json.meshes, index);\n  }\n  getMaterial(index) {\n    return this._get(this.json.materials, index);\n  }\n  getAccessor(index) {\n    return this._get(this.json.accessors, index);\n  }\n  getCamera(index) {\n    return this._get(this.json.cameras, index);\n  }\n  getTexture(index) {\n    return this._get(this.json.textures, index);\n  }\n  getSampler(index) {\n    return this._get(this.json.samplers, index);\n  }\n  getImage(index) {\n    return this._get(this.json.images, index);\n  }\n  getBufferView(index) {\n    return this._get(this.json.bufferViews, index);\n  }\n  getBuffer(index) {\n    return this._get(this.json.buffers, index);\n  }\n  _get(array, index) {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = array && array[index];\n    if (!object) {\n      console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n  // PARSING HELPERS\n  _resolveScene(scene, index) {\n    return {\n      ...scene,\n      // @ts-ignore\n      id: scene.id || `scene-${index}`,\n      nodes: (scene.nodes || []).map(node => this.getNode(node))\n    };\n  }\n  _resolveNode(gltfNode, index) {\n    // @ts-expect-error\n    const node = {\n      ...gltfNode,\n      // @ts-expect-error id could already be present, glTF standard does not prevent it\n      id: gltfNode?.id || `node-${index}`\n    };\n    if (gltfNode.mesh !== undefined) {\n      node.mesh = this.getMesh(gltfNode.mesh);\n    }\n    if (gltfNode.camera !== undefined) {\n      node.camera = this.getCamera(gltfNode.camera);\n    }\n    if (gltfNode.skin !== undefined) {\n      node.skin = this.getSkin(gltfNode.skin);\n    }\n    // TODO deprecated - Delete in v4.0?\n    // @ts-expect-error node.meshes does not seem to be part of the GLTF standard\n    if (gltfNode.meshes !== undefined && gltfNode.meshes.length) {\n      // @ts-expect-error\n      node.mesh = gltfNode.meshes.reduce((accum, meshIndex) => {\n        const mesh = this.getMesh(meshIndex);\n        accum.id = mesh.id;\n        accum.primitives = accum.primitives.concat(mesh.primitives);\n        return accum;\n      }, {\n        primitives: []\n      });\n    }\n    return node;\n  }\n  _resolveNodeChildren(node) {\n    if (node.children) {\n      // @ts-expect-error node.children are numbers at this stage\n      node.children = node.children.map(child => this.getNode(child));\n    }\n    return node;\n  }\n  _resolveSkin(gltfSkin, index) {\n    const inverseBindMatrices = typeof gltfSkin.inverseBindMatrices === 'number' ? this.getAccessor(gltfSkin.inverseBindMatrices) : undefined;\n    return {\n      ...gltfSkin,\n      id: gltfSkin.id || `skin-${index}`,\n      inverseBindMatrices\n    };\n  }\n  _resolveMesh(gltfMesh, index) {\n    const mesh = {\n      ...gltfMesh,\n      id: gltfMesh.id || `mesh-${index}`,\n      primitives: []\n    };\n    if (gltfMesh.primitives) {\n      mesh.primitives = gltfMesh.primitives.map(gltfPrimitive => {\n        const primitive = {\n          ...gltfPrimitive,\n          attributes: {},\n          indices: undefined,\n          material: undefined\n        };\n        const attributes = gltfPrimitive.attributes;\n        for (const attribute in attributes) {\n          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);\n        }\n        if (gltfPrimitive.indices !== undefined) {\n          primitive.indices = this.getAccessor(gltfPrimitive.indices);\n        }\n        if (gltfPrimitive.material !== undefined) {\n          primitive.material = this.getMaterial(gltfPrimitive.material);\n        }\n        return primitive;\n      });\n    }\n    return mesh;\n  }\n  _resolveMaterial(gltfMaterial, index) {\n    // @ts-expect-error\n    const material = {\n      ...gltfMaterial,\n      // @ts-expect-error\n      id: gltfMaterial.id || `material-${index}`\n    };\n    if (material.normalTexture) {\n      material.normalTexture = {\n        ...material.normalTexture\n      };\n      material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n    }\n    if (material.occlusionTexture) {\n      material.occlusionTexture = {\n        ...material.occlusionTexture\n      };\n      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n    }\n    if (material.emissiveTexture) {\n      material.emissiveTexture = {\n        ...material.emissiveTexture\n      };\n      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n    }\n    if (!material.emissiveFactor) {\n      material.emissiveFactor = material.emissiveTexture ? [1, 1, 1] : [0, 0, 0];\n    }\n    if (material.pbrMetallicRoughness) {\n      material.pbrMetallicRoughness = {\n        ...material.pbrMetallicRoughness\n      };\n      const mr = material.pbrMetallicRoughness;\n      if (mr.baseColorTexture) {\n        mr.baseColorTexture = {\n          ...mr.baseColorTexture\n        };\n        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n      }\n      if (mr.metallicRoughnessTexture) {\n        mr.metallicRoughnessTexture = {\n          ...mr.metallicRoughnessTexture\n        };\n        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n      }\n    }\n    return material;\n  }\n  _resolveAccessor(gltfAccessor, index) {\n    // Look up enums\n    const bytesPerComponent = getBytesFromComponentType(gltfAccessor.componentType);\n    const components = getSizeFromAccessorType(gltfAccessor.type);\n    const bytesPerElement = bytesPerComponent * components;\n    const accessor = {\n      ...gltfAccessor,\n      // @ts-expect-error\n      id: gltfAccessor.id || `accessor-${index}`,\n      bytesPerComponent,\n      components,\n      bytesPerElement,\n      value: undefined,\n      bufferView: undefined,\n      sparse: undefined\n    };\n    if (gltfAccessor.bufferView !== undefined) {\n      // Draco encoded meshes don't have bufferView\n      accessor.bufferView = this.getBufferView(gltfAccessor.bufferView);\n    }\n    // Create TypedArray for the accessor\n    // Note: The canonical way to instantiate is to ignore this array and create\n    // WebGLBuffer's using the bufferViews.\n    if (accessor.bufferView) {\n      const buffer = accessor.bufferView.buffer;\n      const {\n        ArrayType,\n        byteLength\n      } = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);\n      const byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n      let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n      if (accessor.bufferView.byteStride) {\n        cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);\n      }\n      accessor.value = new ArrayType(cutBuffer);\n    }\n    return accessor;\n  }\n  /**\n   * Take values of particular accessor from interleaved buffer\n   * various parts of the buffer\n   * @param buffer\n   * @param byteOffset\n   * @param byteStride\n   * @param bytesPerElement\n   * @param count\n   * @returns\n   */\n  _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {\n    const result = new Uint8Array(count * bytesPerElement);\n    for (let i = 0; i < count; i++) {\n      const elementOffset = byteOffset + i * byteStride;\n      result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i * bytesPerElement);\n    }\n    return result.buffer;\n  }\n  _resolveTexture(gltfTexture, index) {\n    return {\n      ...gltfTexture,\n      // @ts-expect-error id could already be present, glTF standard does not prevent it\n      id: gltfTexture.id || `texture-${index}`,\n      sampler: typeof gltfTexture.sampler === 'number' ? this.getSampler(gltfTexture.sampler) : makeDefaultSampler(),\n      source: typeof gltfTexture.source === 'number' ? this.getImage(gltfTexture.source) : undefined\n    };\n  }\n  _resolveSampler(gltfSampler, index) {\n    const sampler = {\n      // @ts-expect-error id could already be present, glTF standard does not prevent it\n      id: gltfSampler.id || `sampler-${index}`,\n      ...gltfSampler,\n      parameters: {}\n    };\n    // Map textual parameters to GL parameter values\n    for (const key in sampler) {\n      const glEnum = this._enumSamplerParameter(key);\n      if (glEnum !== undefined) {\n        sampler.parameters[glEnum] = sampler[key];\n      }\n    }\n    return sampler;\n  }\n  _enumSamplerParameter(key) {\n    return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n  }\n  _resolveImage(gltfImage, index) {\n    const image = {\n      ...gltfImage,\n      // @ts-expect-error id could already be present, glTF standard does not prevent it\n      id: gltfImage.id || `image-${index}`,\n      image: null,\n      bufferView: gltfImage.bufferView !== undefined ? this.getBufferView(gltfImage.bufferView) : undefined\n    };\n    // Check if image has been preloaded by the GLTFLoader\n    // If so, link it into the JSON and drop the URI\n    const preloadedImage = this.images[index];\n    if (preloadedImage) {\n      image.image = preloadedImage;\n    }\n    return image;\n  }\n  _resolveBufferView(gltfBufferView, index) {\n    const bufferIndex = gltfBufferView.buffer;\n    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n    // Add offset of buffer, then offset of buffer view\n    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n    if (gltfBufferView.byteOffset) {\n      byteOffset += gltfBufferView.byteOffset;\n    }\n    const bufferView = {\n      // // @ts-expect-error id could already be present, glTF standard does not prevent it\n      id: `bufferView-${index}`,\n      ...gltfBufferView,\n      // ...this.buffers[bufferIndex],\n      buffer: this.buffers[bufferIndex],\n      data: new Uint8Array(arrayBuffer, byteOffset, gltfBufferView.byteLength)\n    };\n    return bufferView;\n  }\n  _resolveCamera(gltfCamera, index) {\n    const camera = {\n      ...gltfCamera,\n      // @ts-expect-error id could already be present, glTF standard does not prevent it\n      id: gltfCamera.id || `camera-${index}`\n    };\n    // TODO - create 4x4 matrices\n    if (camera.perspective) {\n      // camera.matrix = createPerspectiveMatrix(camera.perspective);\n    }\n    if (camera.orthographic) {\n      // camera.matrix = createOrthographicMatrix(camera.orthographic);\n    }\n    return camera;\n  }\n}\nexport function postProcessGLTF(gltf, options) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}