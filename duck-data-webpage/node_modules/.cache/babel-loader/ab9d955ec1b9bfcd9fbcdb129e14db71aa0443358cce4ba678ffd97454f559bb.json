{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { createRenderTarget } from \"./utils.js\";\nimport { joinLayerBounds, makeViewport, getRenderBounds } from \"../utils/projection-utils.js\";\n/**\n * Manages the lifecycle of the terrain cover (draped textures over a terrain mesh).\n * One terrain cover is created for each unique terrain layer (primitive layer with operation:terrain).\n * It is updated when the terrain source layer's mesh changes or when any of the terrainDrawMode:drape\n * layers requires redraw.\n * During the draw call of a terrain layer, the drape texture is overlaid on top of the layer's own color.\n */\nexport class TerrainCover {\n  constructor(targetLayer) {\n    this.isDirty = true;\n    /** Viewport used to draw into the texture */\n    this.renderViewport = null;\n    /** Bounds of the terrain cover texture, in cartesian space */\n    this.bounds = null;\n    this.layers = [];\n    /** Cached version of targetLayer.getBounds() */\n    this.targetBounds = null;\n    /** targetBounds in cartesian space */\n    this.targetBoundsCommon = null;\n    this.targetLayer = targetLayer;\n    this.tile = getTile(targetLayer);\n  }\n  get id() {\n    return this.targetLayer.id;\n  }\n  /** returns true if the target layer is still in use (i.e. not finalized) */\n  get isActive() {\n    return Boolean(this.targetLayer.getCurrentLayer());\n  }\n  shouldUpdate({\n    targetLayer,\n    viewport,\n    layers,\n    layerNeedsRedraw\n  }) {\n    if (targetLayer) {\n      this.targetLayer = targetLayer;\n    }\n    const sizeChanged = viewport ? this._updateViewport(viewport) : false;\n    let layersChanged = layers ? this._updateLayers(layers) : false;\n    if (layerNeedsRedraw) {\n      for (const id of this.layers) {\n        if (layerNeedsRedraw[id]) {\n          layersChanged = true;\n          // console.log('layer needs redraw', id);\n          break;\n        }\n      }\n    }\n    return layersChanged || sizeChanged;\n  }\n  /** Compare layers with the last version. Only rerender if necessary. */\n  _updateLayers(layers) {\n    let needsRedraw = false;\n    layers = this.tile ? getIntersectingLayers(this.tile, layers) : layers;\n    if (layers.length !== this.layers.length) {\n      needsRedraw = true;\n      // console.log('layers count changed', this.layers.length, '>>', layers.length);\n    } else {\n      for (let i = 0; i < layers.length; i++) {\n        const id = layers[i].id;\n        if (id !== this.layers[i]) {\n          needsRedraw = true;\n          // console.log('layer added/removed', id);\n          break;\n        }\n      }\n    }\n    if (needsRedraw) {\n      this.layers = layers.map(layer => layer.id);\n    }\n    return needsRedraw;\n  }\n  /** Compare viewport and terrain bounds with the last version. Only rerender if necesary. */\n  _updateViewport(viewport) {\n    const targetLayer = this.targetLayer;\n    let shouldRedraw = false;\n    if (this.tile && 'boundingBox' in this.tile) {\n      if (!this.targetBounds) {\n        shouldRedraw = true;\n        this.targetBounds = this.tile.boundingBox;\n        const bottomLeftCommon = viewport.projectPosition(this.targetBounds[0]);\n        const topRightCommon = viewport.projectPosition(this.targetBounds[1]);\n        this.targetBoundsCommon = [bottomLeftCommon[0], bottomLeftCommon[1], topRightCommon[0], topRightCommon[1]];\n      }\n    } else if (this.targetBounds !== targetLayer.getBounds()) {\n      // console.log('bounds changed', this.bounds, '>>', newBounds);\n      shouldRedraw = true;\n      this.targetBounds = targetLayer.getBounds();\n      this.targetBoundsCommon = joinLayerBounds([targetLayer], viewport);\n    }\n    if (!this.targetBoundsCommon) {\n      return false;\n    }\n    const newZoom = Math.ceil(viewport.zoom + 0.5);\n    // If the terrain layer is bound to a tile, always render a texture that cover the whole tile.\n    // Otherwise, use the smaller of layer bounds and the viewport bounds.\n    if (this.tile) {\n      this.bounds = this.targetBoundsCommon;\n    } else {\n      const oldZoom = this.renderViewport?.zoom;\n      shouldRedraw = shouldRedraw || newZoom !== oldZoom;\n      const newBounds = getRenderBounds(this.targetBoundsCommon, viewport);\n      const oldBounds = this.bounds;\n      shouldRedraw = shouldRedraw || !oldBounds || newBounds.some((x, i) => x !== oldBounds[i]);\n      this.bounds = newBounds;\n    }\n    if (shouldRedraw) {\n      this.renderViewport = makeViewport({\n        bounds: this.bounds,\n        zoom: newZoom,\n        viewport\n      });\n    }\n    return shouldRedraw;\n  }\n  getRenderFramebuffer() {\n    if (!this.renderViewport || this.layers.length === 0) {\n      return null;\n    }\n    if (!this.fbo) {\n      this.fbo = createRenderTarget(this.targetLayer.context.device, {\n        id: this.id\n      });\n    }\n    return this.fbo;\n  }\n  getPickingFramebuffer() {\n    if (!this.renderViewport || this.layers.length === 0 && !this.targetLayer.props.pickable) {\n      return null;\n    }\n    if (!this.pickingFbo) {\n      this.pickingFbo = createRenderTarget(this.targetLayer.context.device, {\n        id: `${this.id}-picking`,\n        interpolate: false\n      });\n    }\n    return this.pickingFbo;\n  }\n  filterLayers(layers) {\n    return layers.filter(({\n      id\n    }) => this.layers.includes(id));\n  }\n  delete() {\n    const {\n      fbo,\n      pickingFbo\n    } = this;\n    if (fbo) {\n      fbo.colorAttachments[0].destroy();\n      fbo.destroy();\n    }\n    if (pickingFbo) {\n      pickingFbo.colorAttachments[0].destroy();\n      pickingFbo.destroy();\n    }\n  }\n}\n/**\n * Remove layers that do not overlap with the current terrain cover.\n * This implementation only has effect when a TileLayer is overlaid on top of a TileLayer\n */\nfunction getIntersectingLayers(sourceTile, layers) {\n  return layers.filter(layer => {\n    const tile = getTile(layer);\n    if (tile) {\n      return intersect(sourceTile.boundingBox, tile.boundingBox);\n    }\n    return true;\n  });\n}\n/** If layer is the descendent of a TileLayer, return the corresponding tile. */\nfunction getTile(layer) {\n  while (layer) {\n    // @ts-expect-error tile may not exist\n    const {\n      tile\n    } = layer.props;\n    if (tile) {\n      return tile;\n    }\n    layer = layer.parent;\n  }\n  return null;\n}\nfunction intersect(b1, b2) {\n  if (b1 && b2) {\n    return b1[0][0] < b2[1][0] && b2[0][0] < b1[1][0] && b1[0][1] < b2[1][1] && b2[0][1] < b1[1][1];\n  }\n  return false;\n}\n//# sourceMappingURL=terrain-cover.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}