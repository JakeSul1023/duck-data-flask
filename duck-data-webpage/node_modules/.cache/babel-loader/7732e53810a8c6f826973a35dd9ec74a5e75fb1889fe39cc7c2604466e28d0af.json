{"ast":null,"code":"import { Vector3 } from '@math.gl/core';\nimport { CullingVolume, Plane } from '@math.gl/culling';\nimport { Ellipsoid } from '@math.gl/geospatial';\nconst scratchVector = new Vector3();\nconst scratchPosition = new Vector3();\nconst cullingVolume = new CullingVolume([new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()]);\n// Extracts a frame state appropriate for tile culling from a deck.gl viewport\n// TODO - this could likely be generalized and merged back into deck.gl for other culling scenarios\nexport function getFrameState(viewport, frameNumber) {\n  // Traverse and and request. Update _selectedTiles so that we know what to render.\n  // Traverse and and request. Update _selectedTiles so that we know what to render.\n  const {\n    cameraDirection,\n    cameraUp,\n    height\n  } = viewport;\n  const {\n    metersPerUnit\n  } = viewport.distanceScales;\n  // TODO - Ellipsoid.eastNorthUpToFixedFrame() breaks on raw array, create a Vector.\n  // TODO - Ellipsoid.eastNorthUpToFixedFrame() takes a cartesian, is that intuitive?\n  const viewportCenterCartesian = worldToCartesian(viewport, viewport.center);\n  const enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector3());\n  // These should still be normalized as the transform has scale 1 (goes from meters to meters)\n  const cameraDirectionCartesian = new Vector3(\n  // @ts-ignore\n  enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))).normalize();\n  const cameraUpCartesian = new Vector3(\n  // @ts-ignore\n  enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))).normalize();\n  commonSpacePlanesToWGS84(viewport);\n  const ViewportClass = viewport.constructor;\n  const {\n    longitude,\n    latitude,\n    width,\n    bearing,\n    zoom\n  } = viewport;\n  // @ts-ignore\n  const topDownViewport = new ViewportClass({\n    longitude,\n    latitude,\n    height,\n    width,\n    bearing,\n    zoom,\n    pitch: 0\n  });\n  // TODO: make a file/class for frameState and document what needs to be attached to this so that traversal can function\n  return {\n    camera: {\n      position: cameraPositionCartesian,\n      direction: cameraDirectionCartesian,\n      up: cameraUpCartesian\n    },\n    viewport,\n    topDownViewport,\n    height,\n    cullingVolume,\n    frameNumber,\n    // TODO: This can be the same between updates, what number is unique for between updates?\n    sseDenominator: 1.15 // Assumes fovy = 60 degrees\n  };\n}\n/**\n * Limit `tiles` array length with `maximumTilesSelected` number.\n * The criteria for this filtering is distance of a tile center\n * to the `frameState.viewport`'s longitude and latitude\n * @param tiles - tiles array to filter\n * @param frameState - frameState to calculate distances\n * @param maximumTilesSelected - maximal amount of tiles in the output array\n * @returns new tiles array\n */\nexport function limitSelectedTiles(tiles, frameState, maximumTilesSelected) {\n  if (maximumTilesSelected === 0 || tiles.length <= maximumTilesSelected) {\n    return [tiles, []];\n  }\n  // Accumulate distances in couples array: [tileIndex: number, distanceToViewport: number]\n  const tuples = [];\n  const {\n    longitude: viewportLongitude,\n    latitude: viewportLatitude\n  } = frameState.viewport;\n  for (const [index, tile] of tiles.entries()) {\n    const [longitude, latitude] = tile.header.mbs;\n    const deltaLon = Math.abs(viewportLongitude - longitude);\n    const deltaLat = Math.abs(viewportLatitude - latitude);\n    const distance = Math.sqrt(deltaLat * deltaLat + deltaLon * deltaLon);\n    tuples.push([index, distance]);\n  }\n  const tuplesSorted = tuples.sort((a, b) => a[1] - b[1]);\n  const selectedTiles = [];\n  for (let i = 0; i < maximumTilesSelected; i++) {\n    selectedTiles.push(tiles[tuplesSorted[i][0]]);\n  }\n  const unselectedTiles = [];\n  for (let i = maximumTilesSelected; i < tuplesSorted.length; i++) {\n    unselectedTiles.push(tiles[tuplesSorted[i][0]]);\n  }\n  return [selectedTiles, unselectedTiles];\n}\nfunction commonSpacePlanesToWGS84(viewport) {\n  // Extract frustum planes based on current view.\n  const frustumPlanes = viewport.getFrustumPlanes();\n  // Get the near/far plane centers\n  const nearCenterCommon = closestPointOnPlane(frustumPlanes.near, viewport.cameraPosition);\n  const nearCenterCartesian = worldToCartesian(viewport, nearCenterCommon);\n  const cameraCartesian = worldToCartesian(viewport, viewport.cameraPosition, scratchPosition);\n  let i = 0;\n  cullingVolume.planes[i++].fromPointNormal(nearCenterCartesian, scratchVector.copy(nearCenterCartesian).subtract(cameraCartesian));\n  for (const dir in frustumPlanes) {\n    if (dir === 'near') {\n      continue; // eslint-disable-line no-continue\n    }\n    const plane = frustumPlanes[dir];\n    const posCommon = closestPointOnPlane(plane, nearCenterCommon, scratchPosition);\n    const cartesianPos = worldToCartesian(viewport, posCommon, scratchPosition);\n    cullingVolume.planes[i++].fromPointNormal(cartesianPos,\n    // Want the normal to point into the frustum since that's what culling expects\n    scratchVector.copy(nearCenterCartesian).subtract(cartesianPos));\n  }\n}\nfunction closestPointOnPlane(plane, refPoint, out = new Vector3()) {\n  const distanceToRef = plane.normal.dot(refPoint);\n  out.copy(plane.normal).scale(plane.distance - distanceToRef).add(refPoint);\n  return out;\n}\nfunction worldToCartesian(viewport, point, out = new Vector3()) {\n  const cartographicPos = viewport.unprojectPosition(point);\n  return Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, out);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}