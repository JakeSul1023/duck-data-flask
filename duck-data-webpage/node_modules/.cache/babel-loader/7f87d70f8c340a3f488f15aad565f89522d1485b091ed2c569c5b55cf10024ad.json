{"ast":null,"code":"// The MIT License (MIT)\n//\n// Copyright (c) 2016 Zhipeng Jia\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n'use strict';\n\nvar BLOCK_LOG = 16;\nvar BLOCK_SIZE = 1 << BLOCK_LOG;\nvar MAX_HASH_TABLE_BITS = 14;\nvar globalHashTables = new Array(MAX_HASH_TABLE_BITS + 1);\nfunction hashFunc(key, hashFuncShift) {\n  return key * 0x1e35a7bd >>> hashFuncShift;\n}\nfunction load32(array, pos) {\n  return array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);\n}\nfunction equals32(array, pos1, pos2) {\n  return array[pos1] === array[pos2] && array[pos1 + 1] === array[pos2 + 1] && array[pos1 + 2] === array[pos2 + 2] && array[pos1 + 3] === array[pos2 + 3];\n}\nfunction copyBytes(fromArray, fromPos, toArray, toPos, length) {\n  var i;\n  for (i = 0; i < length; i++) {\n    toArray[toPos + i] = fromArray[fromPos + i];\n  }\n}\nfunction emitLiteral(input, ip, len, output, op) {\n  if (len <= 60) {\n    output[op] = len - 1 << 2;\n    op += 1;\n  } else if (len < 256) {\n    output[op] = 60 << 2;\n    output[op + 1] = len - 1;\n    op += 2;\n  } else {\n    output[op] = 61 << 2;\n    output[op + 1] = len - 1 & 0xff;\n    output[op + 2] = len - 1 >>> 8;\n    op += 3;\n  }\n  copyBytes(input, ip, output, op, len);\n  return op + len;\n}\nfunction emitCopyLessThan64(output, op, offset, len) {\n  if (len < 12 && offset < 2048) {\n    output[op] = 1 + (len - 4 << 2) + (offset >>> 8 << 5);\n    output[op + 1] = offset & 0xff;\n    return op + 2;\n  } else {\n    output[op] = 2 + (len - 1 << 2);\n    output[op + 1] = offset & 0xff;\n    output[op + 2] = offset >>> 8;\n    return op + 3;\n  }\n}\nfunction emitCopy(output, op, offset, len) {\n  while (len >= 68) {\n    op = emitCopyLessThan64(output, op, offset, 64);\n    len -= 64;\n  }\n  if (len > 64) {\n    op = emitCopyLessThan64(output, op, offset, 60);\n    len -= 60;\n  }\n  return emitCopyLessThan64(output, op, offset, len);\n}\nfunction compressFragment(input, ip, inputSize, output, op) {\n  var hashTableBits = 1;\n  while (1 << hashTableBits <= inputSize && hashTableBits <= MAX_HASH_TABLE_BITS) {\n    hashTableBits += 1;\n  }\n  hashTableBits -= 1;\n  var hashFuncShift = 32 - hashTableBits;\n  if (typeof globalHashTables[hashTableBits] === 'undefined') {\n    globalHashTables[hashTableBits] = new Uint16Array(1 << hashTableBits);\n  }\n  var hashTable = globalHashTables[hashTableBits];\n  var i;\n  for (i = 0; i < hashTable.length; i++) {\n    hashTable[i] = 0;\n  }\n  var ipEnd = ip + inputSize;\n  var ipLimit;\n  var baseIp = ip;\n  var nextEmit = ip;\n  var hash, nextHash;\n  var nextIp, candidate, skip;\n  var bytesBetweenHashLookups;\n  var base, matched, offset;\n  var prevHash, curHash;\n  var flag = true;\n  var INPUT_MARGIN = 15;\n  if (inputSize >= INPUT_MARGIN) {\n    ipLimit = ipEnd - INPUT_MARGIN;\n    ip += 1;\n    nextHash = hashFunc(load32(input, ip), hashFuncShift);\n    while (flag) {\n      skip = 32;\n      nextIp = ip;\n      do {\n        ip = nextIp;\n        hash = nextHash;\n        bytesBetweenHashLookups = skip >>> 5;\n        skip += 1;\n        nextIp = ip + bytesBetweenHashLookups;\n        if (ip > ipLimit) {\n          flag = false;\n          break;\n        }\n        nextHash = hashFunc(load32(input, nextIp), hashFuncShift);\n        candidate = baseIp + hashTable[hash];\n        hashTable[hash] = ip - baseIp;\n      } while (!equals32(input, ip, candidate));\n      if (!flag) {\n        break;\n      }\n      op = emitLiteral(input, nextEmit, ip - nextEmit, output, op);\n      do {\n        base = ip;\n        matched = 4;\n        while (ip + matched < ipEnd && input[ip + matched] === input[candidate + matched]) {\n          matched += 1;\n        }\n        ip += matched;\n        offset = base - candidate;\n        op = emitCopy(output, op, offset, matched);\n        nextEmit = ip;\n        if (ip >= ipLimit) {\n          flag = false;\n          break;\n        }\n        prevHash = hashFunc(load32(input, ip - 1), hashFuncShift);\n        hashTable[prevHash] = ip - 1 - baseIp;\n        curHash = hashFunc(load32(input, ip), hashFuncShift);\n        candidate = baseIp + hashTable[curHash];\n        hashTable[curHash] = ip - baseIp;\n      } while (equals32(input, ip, candidate));\n      if (!flag) {\n        break;\n      }\n      ip += 1;\n      nextHash = hashFunc(load32(input, ip), hashFuncShift);\n    }\n  }\n  if (nextEmit < ipEnd) {\n    op = emitLiteral(input, nextEmit, ipEnd - nextEmit, output, op);\n  }\n  return op;\n}\nfunction putVarint(value, output, op) {\n  do {\n    output[op] = value & 0x7f;\n    value = value >>> 7;\n    if (value > 0) {\n      output[op] += 0x80;\n    }\n    op += 1;\n  } while (value > 0);\n  return op;\n}\nfunction SnappyCompressor(uncompressed) {\n  this.array = uncompressed;\n}\nSnappyCompressor.prototype.maxCompressedLength = function () {\n  var sourceLen = this.array.length;\n  return 32 + sourceLen + Math.floor(sourceLen / 6);\n};\nSnappyCompressor.prototype.compressToBuffer = function (outBuffer) {\n  var array = this.array;\n  var length = array.length;\n  var pos = 0;\n  var outPos = 0;\n  var fragmentSize;\n  outPos = putVarint(length, outBuffer, outPos);\n  while (pos < length) {\n    fragmentSize = Math.min(length - pos, BLOCK_SIZE);\n    outPos = compressFragment(array, pos, fragmentSize, outBuffer, outPos);\n    pos += fragmentSize;\n  }\n  return outPos;\n};\nexports.SnappyCompressor = SnappyCompressor;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}