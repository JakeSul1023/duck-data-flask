{"ast":null,"code":"import { concatenateArrayBuffers } from '@loaders.gl/loader-utils';\nexport const signature = new Uint8Array([0x01, 0x00]);\n/**\n * creates zip64 extra field\n * @param options info that can be placed into zip64 field\n * @returns buffer with field\n */\nexport function createZip64Info(options) {\n  const optionsToUse = {\n    ...options,\n    zip64Length: (options.offset ? 1 : 0) * 8 + (options.size ? 1 : 0) * 16\n  };\n  const arraysToConcat = [];\n  for (const field of ZIP64_FIELDS) {\n    if (!optionsToUse[field.name ?? ''] && !field.default) {\n      continue; // eslint-disable-line no-continue\n    }\n    const newValue = new DataView(new ArrayBuffer(field.size));\n    NUMBER_SETTERS[field.size](newValue, 0, optionsToUse[field.name ?? ''] ?? field.default);\n    arraysToConcat.push(newValue.buffer);\n  }\n  return concatenateArrayBuffers(...arraysToConcat);\n}\n/**\n * Writes values into buffer according to the bytes amount\n * @param header header where to write the data\n * @param fieldSize size of the field in bytes\n * @param fieldOffset offset of the field\n * @param value value to be written\n */\nexport function setFieldToNumber(header, fieldSize, fieldOffset, value) {\n  NUMBER_SETTERS[fieldSize](header, Number(fieldOffset), value);\n}\n/** functions to write values into buffer according to the bytes amount */\nconst NUMBER_SETTERS = {\n  2: (header, offset, value) => {\n    header.setUint16(offset, Number(value > 0xffff ? 0xffff : value), true);\n  },\n  4: (header, offset, value) => {\n    header.setUint32(offset, Number(value > 0xffffffff ? 0xffffffff : value), true);\n  },\n  8: (header, offset, value) => {\n    header.setBigUint64(offset, BigInt(value), true);\n  }\n};\n/** zip64 info fields description, we need it as a pattern to build a zip64 info */\nconst ZIP64_FIELDS = [\n// Header ID 0x0001\n{\n  size: 2,\n  default: new DataView(signature.buffer).getUint16(0, true)\n},\n// Size of the extra field chunk (8, 16, 24 or 28)\n{\n  size: 2,\n  name: 'zip64Length'\n},\n// Original uncompressed file size\n{\n  size: 8,\n  name: 'size'\n},\n// Size of compressed data\n{\n  size: 8,\n  name: 'size'\n},\n// Offset of local header record\n{\n  size: 8,\n  name: 'offset'\n}];","map":{"version":3,"names":["concatenateArrayBuffers","signature","Uint8Array","createZip64Info","options","optionsToUse","zip64Length","offset","size","arraysToConcat","field","ZIP64_FIELDS","name","default","newValue","DataView","ArrayBuffer","NUMBER_SETTERS","push","buffer","setFieldToNumber","header","fieldSize","fieldOffset","value","Number","setUint16","setUint32","setBigUint64","BigInt","getUint16"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/zip/dist/parse-zip/zip64-info-generation.js"],"sourcesContent":["import { concatenateArrayBuffers } from '@loaders.gl/loader-utils';\nexport const signature = new Uint8Array([0x01, 0x00]);\n/**\n * creates zip64 extra field\n * @param options info that can be placed into zip64 field\n * @returns buffer with field\n */\nexport function createZip64Info(options) {\n    const optionsToUse = {\n        ...options,\n        zip64Length: (options.offset ? 1 : 0) * 8 + (options.size ? 1 : 0) * 16\n    };\n    const arraysToConcat = [];\n    for (const field of ZIP64_FIELDS) {\n        if (!optionsToUse[field.name ?? ''] && !field.default) {\n            continue; // eslint-disable-line no-continue\n        }\n        const newValue = new DataView(new ArrayBuffer(field.size));\n        NUMBER_SETTERS[field.size](newValue, 0, optionsToUse[field.name ?? ''] ?? field.default);\n        arraysToConcat.push(newValue.buffer);\n    }\n    return concatenateArrayBuffers(...arraysToConcat);\n}\n/**\n * Writes values into buffer according to the bytes amount\n * @param header header where to write the data\n * @param fieldSize size of the field in bytes\n * @param fieldOffset offset of the field\n * @param value value to be written\n */\nexport function setFieldToNumber(header, fieldSize, fieldOffset, value) {\n    NUMBER_SETTERS[fieldSize](header, Number(fieldOffset), value);\n}\n/** functions to write values into buffer according to the bytes amount */\nconst NUMBER_SETTERS = {\n    2: (header, offset, value) => {\n        header.setUint16(offset, Number(value > 0xffff ? 0xffff : value), true);\n    },\n    4: (header, offset, value) => {\n        header.setUint32(offset, Number(value > 0xffffffff ? 0xffffffff : value), true);\n    },\n    8: (header, offset, value) => {\n        header.setBigUint64(offset, BigInt(value), true);\n    }\n};\n/** zip64 info fields description, we need it as a pattern to build a zip64 info */\nconst ZIP64_FIELDS = [\n    // Header ID 0x0001\n    {\n        size: 2,\n        default: new DataView(signature.buffer).getUint16(0, true)\n    },\n    // Size of the extra field chunk (8, 16, 24 or 28)\n    {\n        size: 2,\n        name: 'zip64Length'\n    },\n    // Original uncompressed file size\n    {\n        size: 8,\n        name: 'size'\n    },\n    // Size of compressed data\n    {\n        size: 8,\n        name: 'size'\n    },\n    // Offset of local header record\n    {\n        size: 8,\n        name: 'offset'\n    }\n];\n"],"mappings":"AAAA,SAASA,uBAAuB,QAAQ,0BAA0B;AAClE,OAAO,MAAMC,SAAS,GAAG,IAAIC,UAAU,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AACrD;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAACC,OAAO,EAAE;EACrC,MAAMC,YAAY,GAAG;IACjB,GAAGD,OAAO;IACVE,WAAW,EAAE,CAACF,OAAO,CAACG,MAAM,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAACH,OAAO,CAACI,IAAI,GAAG,CAAC,GAAG,CAAC,IAAI;EACzE,CAAC;EACD,MAAMC,cAAc,GAAG,EAAE;EACzB,KAAK,MAAMC,KAAK,IAAIC,YAAY,EAAE;IAC9B,IAAI,CAACN,YAAY,CAACK,KAAK,CAACE,IAAI,IAAI,EAAE,CAAC,IAAI,CAACF,KAAK,CAACG,OAAO,EAAE;MACnD,SAAS,CAAC;IACd;IACA,MAAMC,QAAQ,GAAG,IAAIC,QAAQ,CAAC,IAAIC,WAAW,CAACN,KAAK,CAACF,IAAI,CAAC,CAAC;IAC1DS,cAAc,CAACP,KAAK,CAACF,IAAI,CAAC,CAACM,QAAQ,EAAE,CAAC,EAAET,YAAY,CAACK,KAAK,CAACE,IAAI,IAAI,EAAE,CAAC,IAAIF,KAAK,CAACG,OAAO,CAAC;IACxFJ,cAAc,CAACS,IAAI,CAACJ,QAAQ,CAACK,MAAM,CAAC;EACxC;EACA,OAAOnB,uBAAuB,CAAC,GAAGS,cAAc,CAAC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASW,gBAAgBA,CAACC,MAAM,EAAEC,SAAS,EAAEC,WAAW,EAAEC,KAAK,EAAE;EACpEP,cAAc,CAACK,SAAS,CAAC,CAACD,MAAM,EAAEI,MAAM,CAACF,WAAW,CAAC,EAAEC,KAAK,CAAC;AACjE;AACA;AACA,MAAMP,cAAc,GAAG;EACnB,CAAC,EAAE,CAACI,MAAM,EAAEd,MAAM,EAAEiB,KAAK,KAAK;IAC1BH,MAAM,CAACK,SAAS,CAACnB,MAAM,EAAEkB,MAAM,CAACD,KAAK,GAAG,MAAM,GAAG,MAAM,GAAGA,KAAK,CAAC,EAAE,IAAI,CAAC;EAC3E,CAAC;EACD,CAAC,EAAE,CAACH,MAAM,EAAEd,MAAM,EAAEiB,KAAK,KAAK;IAC1BH,MAAM,CAACM,SAAS,CAACpB,MAAM,EAAEkB,MAAM,CAACD,KAAK,GAAG,UAAU,GAAG,UAAU,GAAGA,KAAK,CAAC,EAAE,IAAI,CAAC;EACnF,CAAC;EACD,CAAC,EAAE,CAACH,MAAM,EAAEd,MAAM,EAAEiB,KAAK,KAAK;IAC1BH,MAAM,CAACO,YAAY,CAACrB,MAAM,EAAEsB,MAAM,CAACL,KAAK,CAAC,EAAE,IAAI,CAAC;EACpD;AACJ,CAAC;AACD;AACA,MAAMb,YAAY,GAAG;AACjB;AACA;EACIH,IAAI,EAAE,CAAC;EACPK,OAAO,EAAE,IAAIE,QAAQ,CAACd,SAAS,CAACkB,MAAM,CAAC,CAACW,SAAS,CAAC,CAAC,EAAE,IAAI;AAC7D,CAAC;AACD;AACA;EACItB,IAAI,EAAE,CAAC;EACPI,IAAI,EAAE;AACV,CAAC;AACD;AACA;EACIJ,IAAI,EAAE,CAAC;EACPI,IAAI,EAAE;AACV,CAAC;AACD;AACA;EACIJ,IAAI,EAAE,CAAC;EACPI,IAAI,EAAE;AACV,CAAC;AACD;AACA;EACIJ,IAAI,EAAE,CAAC;EACPI,IAAI,EAAE;AACV,CAAC,CACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}