{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { RenderPipeline, log } from '@luma.gl/core';\n// import {getAttributeInfosFromLayouts} from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\nimport { getShaderLayoutFromGLSL } from \"../helpers/get-shader-layout.js\";\nimport { withDeviceAndGLParameters } from \"../converters/device-parameters.js\";\nimport { setUniform } from \"../helpers/set-uniform.js\";\nimport { splitUniformsAndBindings } from \"../../utils/split-uniforms-and-bindings.js\";\nimport { WEBGLBuffer } from \"./webgl-buffer.js\";\nimport { WEBGLFramebuffer } from \"./webgl-framebuffer.js\";\nimport { WEBGLTexture } from \"./webgl-texture.js\";\nimport { WEBGLTextureView } from \"./webgl-texture-view.js\";\nimport { getGLDrawMode } from \"../helpers/webgl-topology-utils.js\";\nconst LOG_PROGRAM_PERF_PRIORITY = 4;\n/** Creates a new render pipeline */\nexport class WEBGLRenderPipeline extends RenderPipeline {\n  /** The WebGL device that created this render pipeline */\n  device;\n  /** Handle to underlying WebGL program */\n  handle;\n  /** vertex shader */\n  vs;\n  /** fragment shader */\n  fs;\n  /** The layout extracted from shader by WebGL introspection APIs */\n  introspectedLayout;\n  /** Uniforms set on this model */\n  uniforms = {};\n  /** Bindings set on this model */\n  bindings = {};\n  /** WebGL varyings */\n  varyings = null;\n  _uniformCount = 0;\n  _uniformSetters = {}; // TODO are these used?\n  constructor(device, props) {\n    super(device, props);\n    this.device = device;\n    this.handle = this.props.handle || this.device.gl.createProgram();\n    this.device.setSpectorMetadata(this.handle, {\n      id: this.props.id\n    });\n    // Create shaders if needed\n    this.vs = props.vs;\n    this.fs = props.fs;\n    // assert(this.vs.stage === 'vertex');\n    // assert(this.fs.stage === 'fragment');\n    // Setup varyings if supplied\n    // @ts-expect-error WebGL only\n    const {\n      varyings,\n      bufferMode = 35981\n    } = props;\n    if (varyings && varyings.length > 0) {\n      this.varyings = varyings;\n      this.device.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);\n    }\n    this._linkShaders();\n    log.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)();\n    this.introspectedLayout = getShaderLayoutFromGLSL(this.device.gl, this.handle);\n    log.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)();\n    // Merge provided layout with introspected layout\n    this.shaderLayout = mergeShaderLayout(this.introspectedLayout, props.shaderLayout);\n  }\n  destroy() {\n    if (this.handle) {\n      this.device.gl.deleteProgram(this.handle);\n      // this.handle = null;\n      this.destroyed = true;\n    }\n  }\n  /**\n   * Bindings include: textures, samplers and uniform buffers\n   * @todo needed for portable model\n   */\n  setBindings(bindings, options) {\n    // if (log.priority >= 2) {\n    //   checkUniformValues(uniforms, this.id, this._uniformSetters);\n    // }\n    for (const [name, value] of Object.entries(bindings)) {\n      // Accept both `xyz` and `xyzUniforms` as valid names for `xyzUniforms` uniform block\n      // This convention allows shaders to name uniform blocks as `uniform appUniforms {} app;`\n      // and reference them as `app` from both GLSL and JS.\n      // TODO - this is rather hacky - we could also remap the name directly in the shader layout.\n      const binding = this.shaderLayout.bindings.find(binding_ => binding_.name === name) || this.shaderLayout.bindings.find(binding_ => binding_.name === `${name}Uniforms`);\n      if (!binding) {\n        const validBindings = this.shaderLayout.bindings.map(binding_ => `\"${binding_.name}\"`).join(', ');\n        if (!options?.disableWarnings) {\n          log.warn(`No binding \"${name}\" in render pipeline \"${this.id}\", expected one of ${validBindings}`, value)();\n        }\n        continue; // eslint-disable-line no-continue\n      }\n      if (!value) {\n        log.warn(`Unsetting binding \"${name}\" in render pipeline \"${this.id}\"`)();\n      }\n      switch (binding.type) {\n        case 'uniform':\n          // @ts-expect-error\n          if (!(value instanceof WEBGLBuffer) && !(value.buffer instanceof WEBGLBuffer)) {\n            throw new Error('buffer value');\n          }\n          break;\n        case 'texture':\n          if (!(value instanceof WEBGLTextureView || value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {\n            throw new Error('texture value');\n          }\n          break;\n        case 'sampler':\n          log.warn(`Ignoring sampler ${name}`)();\n          break;\n        default:\n          throw new Error(binding.type);\n      }\n      this.bindings[name] = value;\n    }\n  }\n  /** @todo needed for portable model\n   * @note The WebGL API is offers many ways to draw things\n   * This function unifies those ways into a single call using common parameters with sane defaults\n   */\n  draw(options) {\n    const {\n      renderPass,\n      parameters = this.props.parameters,\n      topology = this.props.topology,\n      vertexArray,\n      vertexCount,\n      // indexCount,\n      instanceCount,\n      isInstanced = false,\n      firstVertex = 0,\n      // firstIndex,\n      // firstInstance,\n      // baseVertex,\n      transformFeedback\n    } = options;\n    const glDrawMode = getGLDrawMode(topology);\n    const isIndexed = Boolean(vertexArray.indexBuffer);\n    const glIndexType = vertexArray.indexBuffer?.glIndexType;\n    // Note that we sometimes get called with 0 instances\n    // If we are using async linking, we need to wait until linking completes\n    if (this.linkStatus !== 'success') {\n      log.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)();\n      return false;\n    }\n    // Avoid WebGL draw call when not rendering any data or values are incomplete\n    // Note: async textures set as uniforms might still be loading.\n    // Now that all uniforms have been updated, check if any texture\n    // in the uniforms is not yet initialized, then we don't draw\n    if (!this._areTexturesRenderable()) {\n      log.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)();\n      //  Note: false means that the app needs to redraw the pipeline again.\n      return false;\n    }\n    // (isInstanced && instanceCount === 0)\n    // if (vertexCount === 0) {\n    //   log.info(2, `RenderPipeline:${this.id}.draw() aborted - no vertices to draw`)();\n    //   Note: false means that the app needs to redraw the pipeline again.\n    //   return true;\n    // }\n    this.device.gl.useProgram(this.handle);\n    // Note: Rebinds constant attributes before each draw call\n    vertexArray.bindBeforeRender(renderPass);\n    if (transformFeedback) {\n      transformFeedback.begin(this.props.topology);\n    }\n    // We have to apply bindings before every draw call since other draw calls will overwrite\n    this._applyBindings();\n    this._applyUniforms();\n    const webglRenderPass = renderPass;\n    withDeviceAndGLParameters(this.device, parameters, webglRenderPass.glParameters, () => {\n      if (isIndexed && isInstanced) {\n        this.device.gl.drawElementsInstanced(glDrawMode, vertexCount || 0,\n        // indexCount?\n        glIndexType, firstVertex, instanceCount || 0);\n        // } else if (isIndexed && this.device.isWebGL2 && !isNaN(start) && !isNaN(end)) {\n        //   this.device.gldrawRangeElements(glDrawMode, start, end, vertexCount, glIndexType, offset);\n      } else if (isIndexed) {\n        this.device.gl.drawElements(glDrawMode, vertexCount || 0, glIndexType, firstVertex); // indexCount?\n      } else if (isInstanced) {\n        this.device.gl.drawArraysInstanced(glDrawMode, firstVertex, vertexCount || 0, instanceCount || 0);\n      } else {\n        this.device.gl.drawArrays(glDrawMode, firstVertex, vertexCount || 0);\n      }\n      if (transformFeedback) {\n        transformFeedback.end();\n      }\n    });\n    vertexArray.unbindAfterRender(renderPass);\n    return true;\n  }\n  // DEPRECATED METHODS\n  setUniformsWebGL(uniforms) {\n    const {\n      bindings\n    } = splitUniformsAndBindings(uniforms);\n    Object.keys(bindings).forEach(name => {\n      log.warn(`Unsupported value \"${JSON.stringify(bindings[name])}\" used in setUniforms() for key ${name}. Use setBindings() instead?`)();\n    });\n    // TODO - check against layout\n    Object.assign(this.uniforms, uniforms);\n  }\n  // PRIVATE METHODS\n  // setAttributes(attributes: Record<string, Buffer>): void {}\n  // setBindings(bindings: Record<string, Binding>): void {}\n  async _linkShaders() {\n    const {\n      gl\n    } = this.device;\n    gl.attachShader(this.handle, this.vs.handle);\n    gl.attachShader(this.handle, this.fs.handle);\n    log.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();\n    gl.linkProgram(this.handle);\n    log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();\n    // TODO Avoid checking program linking error in production\n    if (log.level === 0) {\n      // return;\n    }\n    if (!this.device.features.has('compilation-status-async-webgl')) {\n      const status = this._getLinkStatus();\n      this._reportLinkStatus(status);\n      return;\n    }\n    // async case\n    log.once(1, 'RenderPipeline linking is asynchronous')();\n    await this._waitForLinkComplete();\n    log.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();\n    const status = this._getLinkStatus();\n    this._reportLinkStatus(status);\n  }\n  /** Report link status. First, check for shader compilation failures if linking fails */\n  async _reportLinkStatus(status) {\n    switch (status) {\n      case 'success':\n        return;\n      default:\n        // First check for shader compilation failures if linking fails\n        switch (this.vs.compilationStatus) {\n          case 'error':\n            this.vs.debugShader();\n            throw new Error(`Error during compilation of shader ${this.vs.id}`);\n          case 'pending':\n            this.vs.asyncCompilationStatus.then(() => this.vs.debugShader());\n            break;\n          case 'success':\n            break;\n        }\n        switch (this.fs?.compilationStatus) {\n          case 'error':\n            this.fs.debugShader();\n            throw new Error(`Error during compilation of shader ${this.fs.id}`);\n          case 'pending':\n            this.fs.asyncCompilationStatus.then(() => this.fs.debugShader());\n            break;\n          case 'success':\n            break;\n        }\n        const linkErrorLog = this.device.gl.getProgramInfoLog(this.handle);\n        throw new Error(`Error during ${status}: ${linkErrorLog}`);\n    }\n  }\n  /**\n   * Get the shader compilation status\n   * TODO - Load log even when no error reported, to catch warnings?\n   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings\n   */\n  _getLinkStatus() {\n    const {\n      gl\n    } = this.device;\n    const linked = gl.getProgramParameter(this.handle, 35714);\n    if (!linked) {\n      this.linkStatus = 'error';\n      return 'linking';\n    }\n    gl.validateProgram(this.handle);\n    const validated = gl.getProgramParameter(this.handle, 35715);\n    if (!validated) {\n      this.linkStatus = 'error';\n      return 'validation';\n    }\n    this.linkStatus = 'success';\n    return 'success';\n  }\n  /** Use KHR_parallel_shader_compile extension if available */\n  async _waitForLinkComplete() {\n    const waitMs = async ms => await new Promise(resolve => setTimeout(resolve, ms));\n    const DELAY_MS = 10; // Shader compilation is typically quite fast (with some exceptions)\n    // If status polling is not available, we can't wait for completion. Just wait a little to minimize blocking\n    if (!this.device.features.has('compilation-status-async-webgl')) {\n      await waitMs(DELAY_MS);\n      return;\n    }\n    const {\n      gl\n    } = this.device;\n    for (;;) {\n      const complete = gl.getProgramParameter(this.handle, 37297);\n      if (complete) {\n        return;\n      }\n      await waitMs(DELAY_MS);\n    }\n  }\n  /**\n   * Checks if all texture-values uniforms are renderable (i.e. loaded)\n   * Update a texture if needed (e.g. from video)\n   * Note: This is currently done before every draw call\n   */\n  _areTexturesRenderable() {\n    let texturesRenderable = true;\n    for (const bindingInfo of this.shaderLayout.bindings) {\n      if (!this.bindings[bindingInfo.name] && !this.bindings[bindingInfo.name.replace(/Uniforms$/, '')]) {\n        log.warn(`Binding ${bindingInfo.name} not found in ${this.id}`)();\n        texturesRenderable = false;\n      }\n    }\n    // TODO - remove this should be handled by ExternalTexture\n    // for (const [, texture] of Object.entries(this.bindings)) {\n    //   if (texture instanceof WEBGLTexture) {\n    //     texture.update();\n    //   }\n    // }\n    return texturesRenderable;\n  }\n  /** Apply any bindings (before each draw call) */\n  _applyBindings() {\n    // If we are using async linking, we need to wait until linking completes\n    if (this.linkStatus !== 'success') {\n      return;\n    }\n    const {\n      gl\n    } = this.device;\n    gl.useProgram(this.handle);\n    let textureUnit = 0;\n    let uniformBufferIndex = 0;\n    for (const binding of this.shaderLayout.bindings) {\n      // Accept both `xyz` and `xyzUniforms` as valid names for `xyzUniforms` uniform block\n      const value = this.bindings[binding.name] || this.bindings[binding.name.replace(/Uniforms$/, '')];\n      if (!value) {\n        throw new Error(`No value for binding ${binding.name} in ${this.id}`);\n      }\n      switch (binding.type) {\n        case 'uniform':\n          // Set buffer\n          const {\n            name\n          } = binding;\n          const location = gl.getUniformBlockIndex(this.handle, name);\n          if (location === 4294967295) {\n            throw new Error(`Invalid uniform block name ${name}`);\n          }\n          gl.uniformBlockBinding(this.handle, uniformBufferIndex, location);\n          // console.debug(binding, location);\n          if (value instanceof WEBGLBuffer) {\n            gl.bindBufferBase(35345, uniformBufferIndex, value.handle);\n          } else {\n            gl.bindBufferRange(35345, uniformBufferIndex,\n            // @ts-expect-error\n            value.buffer.handle,\n            // @ts-expect-error\n            value.offset || 0,\n            // @ts-expect-error\n            value.size || value.buffer.byteLength - value.offset);\n          }\n          uniformBufferIndex += 1;\n          break;\n        case 'texture':\n          if (!(value instanceof WEBGLTextureView || value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {\n            throw new Error('texture');\n          }\n          let texture;\n          if (value instanceof WEBGLTextureView) {\n            texture = value.texture;\n          } else if (value instanceof WEBGLTexture) {\n            texture = value;\n          } else if (value instanceof WEBGLFramebuffer && value.colorAttachments[0] instanceof WEBGLTextureView) {\n            log.warn('Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead')();\n            texture = value.colorAttachments[0].texture;\n          } else {\n            throw new Error('No texture');\n          }\n          gl.activeTexture(33984 + textureUnit);\n          gl.bindTexture(texture.glTarget, texture.handle);\n          // gl.bindSampler(textureUnit, sampler.handle);\n          textureUnit += 1;\n          break;\n        case 'sampler':\n          // ignore\n          break;\n        case 'storage':\n        case 'read-only-storage':\n          throw new Error(`binding type '${binding.type}' not supported in WebGL`);\n      }\n    }\n  }\n  /**\n   * Due to program sharing, uniforms need to be reset before every draw call\n   * (though caching will avoid redundant WebGL calls)\n   */\n  _applyUniforms() {\n    for (const uniformLayout of this.shaderLayout.uniforms || []) {\n      const {\n        name,\n        location,\n        type,\n        textureUnit\n      } = uniformLayout;\n      const value = this.uniforms[name] ?? textureUnit;\n      if (value !== undefined) {\n        setUniform(this.device.gl, location, type, value);\n      }\n    }\n  }\n}\n/**\n * Merges an provided shader layout into a base shader layout\n * In WebGL, this allows the auto generated shader layout to be overridden by the application\n * Typically to change the format of the vertex attributes (from float32x4 to uint8x4 etc).\n * @todo Drop this? Aren't all use cases covered by mergeBufferLayout()?\n */\nfunction mergeShaderLayout(baseLayout, overrideLayout) {\n  // Deep clone the base layout\n  const mergedLayout = {\n    ...baseLayout,\n    attributes: baseLayout.attributes.map(attribute => ({\n      ...attribute\n    }))\n  };\n  // Merge the attributes\n  for (const attribute of overrideLayout?.attributes || []) {\n    const baseAttribute = mergedLayout.attributes.find(attr => attr.name === attribute.name);\n    if (!baseAttribute) {\n      log.warn(`shader layout attribute ${attribute.name} not present in shader`);\n    } else {\n      baseAttribute.type = attribute.type || baseAttribute.type;\n      baseAttribute.stepMode = attribute.stepMode || baseAttribute.stepMode;\n    }\n  }\n  return mergedLayout;\n}","map":{"version":3,"names":["RenderPipeline","log","GL","getShaderLayoutFromGLSL","withDeviceAndGLParameters","setUniform","splitUniformsAndBindings","WEBGLBuffer","WEBGLFramebuffer","WEBGLTexture","WEBGLTextureView","getGLDrawMode","LOG_PROGRAM_PERF_PRIORITY","WEBGLRenderPipeline","device","handle","vs","fs","introspectedLayout","uniforms","bindings","varyings","_uniformCount","_uniformSetters","constructor","props","gl","createProgram","setSpectorMetadata","id","bufferMode","length","transformFeedbackVaryings","_linkShaders","time","timeEnd","shaderLayout","mergeShaderLayout","destroy","deleteProgram","destroyed","setBindings","options","name","value","Object","entries","binding","find","binding_","validBindings","map","join","disableWarnings","warn","type","buffer","Error","draw","renderPass","parameters","topology","vertexArray","vertexCount","instanceCount","isInstanced","firstVertex","transformFeedback","glDrawMode","isIndexed","Boolean","indexBuffer","glIndexType","linkStatus","info","_areTexturesRenderable","useProgram","bindBeforeRender","begin","_applyBindings","_applyUniforms","webglRenderPass","glParameters","drawElementsInstanced","drawElements","drawArraysInstanced","drawArrays","end","unbindAfterRender","setUniformsWebGL","keys","forEach","JSON","stringify","assign","attachShader","linkProgram","level","features","has","status","_getLinkStatus","_reportLinkStatus","once","_waitForLinkComplete","compilationStatus","debugShader","asyncCompilationStatus","then","linkErrorLog","getProgramInfoLog","linked","getProgramParameter","validateProgram","validated","waitMs","ms","Promise","resolve","setTimeout","DELAY_MS","complete","texturesRenderable","bindingInfo","replace","textureUnit","uniformBufferIndex","location","getUniformBlockIndex","uniformBlockBinding","bindBufferBase","bindBufferRange","offset","size","byteLength","texture","colorAttachments","activeTexture","bindTexture","glTarget","uniformLayout","undefined","baseLayout","overrideLayout","mergedLayout","attributes","attribute","baseAttribute","attr","stepMode"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\webgl\\src\\adapter\\resources\\webgl-render-pipeline.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {\n  RenderPipelineProps,\n  RenderPipelineParameters,\n  PrimitiveTopology,\n  ShaderLayout,\n  UniformValue,\n  Binding,\n  RenderPass,\n  VertexArray\n} from '@luma.gl/core';\nimport {RenderPipeline, log} from '@luma.gl/core';\n// import {getAttributeInfosFromLayouts} from '@luma.gl/core';\nimport {GL} from '@luma.gl/constants';\n\nimport {getShaderLayoutFromGLSL} from '../helpers/get-shader-layout';\nimport {withDeviceAndGLParameters} from '../converters/device-parameters';\nimport {setUniform} from '../helpers/set-uniform';\nimport {splitUniformsAndBindings} from '../../utils/split-uniforms-and-bindings';\n// import {copyUniform, checkUniformValues} from '../../classes/uniforms';\n\nimport {WebGLDevice} from '../webgl-device';\nimport {WEBGLBuffer} from './webgl-buffer';\nimport {WEBGLShader} from './webgl-shader';\nimport {WEBGLFramebuffer} from './webgl-framebuffer';\nimport {WEBGLTexture} from './webgl-texture';\nimport {WEBGLTextureView} from './webgl-texture-view';\nimport {WEBGLRenderPass} from './webgl-render-pass';\nimport {WEBGLTransformFeedback} from './webgl-transform-feedback';\nimport {getGLDrawMode} from '../helpers/webgl-topology-utils';\n\nconst LOG_PROGRAM_PERF_PRIORITY = 4;\n\n/** Creates a new render pipeline */\nexport class WEBGLRenderPipeline extends RenderPipeline {\n  /** The WebGL device that created this render pipeline */\n  device: WebGLDevice;\n  /** Handle to underlying WebGL program */\n  handle: WebGLProgram;\n  /** vertex shader */\n  vs: WEBGLShader;\n  /** fragment shader */\n  fs: WEBGLShader;\n  /** The layout extracted from shader by WebGL introspection APIs */\n  introspectedLayout: ShaderLayout;\n\n  /** Uniforms set on this model */\n  uniforms: Record<string, UniformValue> = {};\n  /** Bindings set on this model */\n  bindings: Record<string, Binding> = {};\n  /** WebGL varyings */\n  varyings: string[] | null = null;\n\n  _uniformCount: number = 0;\n  _uniformSetters: Record<string, Function> = {}; // TODO are these used?\n\n  constructor(device: WebGLDevice, props: RenderPipelineProps) {\n    super(device, props);\n    this.device = device;\n    this.handle = this.props.handle || this.device.gl.createProgram();\n    this.device.setSpectorMetadata(this.handle, {id: this.props.id});\n\n    // Create shaders if needed\n    this.vs = props.vs as WEBGLShader;\n    this.fs = props.fs as WEBGLShader;\n    // assert(this.vs.stage === 'vertex');\n    // assert(this.fs.stage === 'fragment');\n\n    // Setup varyings if supplied\n    // @ts-expect-error WebGL only\n    const {varyings, bufferMode = GL.SEPARATE_ATTRIBS} = props;\n    if (varyings && varyings.length > 0) {\n      this.varyings = varyings;\n      this.device.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);\n    }\n\n    this._linkShaders();\n\n    log.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)();\n    this.introspectedLayout = getShaderLayoutFromGLSL(this.device.gl, this.handle);\n    log.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)();\n\n    // Merge provided layout with introspected layout\n    this.shaderLayout = mergeShaderLayout(this.introspectedLayout, props.shaderLayout);\n  }\n\n  override destroy(): void {\n    if (this.handle) {\n      this.device.gl.deleteProgram(this.handle);\n      // this.handle = null;\n      this.destroyed = true;\n    }\n  }\n\n  /**\n   * Bindings include: textures, samplers and uniform buffers\n   * @todo needed for portable model\n   */\n  setBindings(bindings: Record<string, Binding>, options?: {disableWarnings?: boolean}): void {\n    // if (log.priority >= 2) {\n    //   checkUniformValues(uniforms, this.id, this._uniformSetters);\n    // }\n\n    for (const [name, value] of Object.entries(bindings)) {\n      // Accept both `xyz` and `xyzUniforms` as valid names for `xyzUniforms` uniform block\n      // This convention allows shaders to name uniform blocks as `uniform appUniforms {} app;`\n      // and reference them as `app` from both GLSL and JS.\n      // TODO - this is rather hacky - we could also remap the name directly in the shader layout.\n      const binding =\n        this.shaderLayout.bindings.find(binding_ => binding_.name === name) ||\n        this.shaderLayout.bindings.find(binding_ => binding_.name === `${name}Uniforms`);\n\n      if (!binding) {\n        const validBindings = this.shaderLayout.bindings\n          .map(binding_ => `\"${binding_.name}\"`)\n          .join(', ');\n        if (!options?.disableWarnings) {\n          log.warn(\n            `No binding \"${name}\" in render pipeline \"${this.id}\", expected one of ${validBindings}`,\n            value\n          )();\n        }\n        continue; // eslint-disable-line no-continue\n      }\n      if (!value) {\n        log.warn(`Unsetting binding \"${name}\" in render pipeline \"${this.id}\"`)();\n      }\n      switch (binding.type) {\n        case 'uniform':\n          // @ts-expect-error\n          if (!(value instanceof WEBGLBuffer) && !(value.buffer instanceof WEBGLBuffer)) {\n            throw new Error('buffer value');\n          }\n          break;\n        case 'texture':\n          if (\n            !(\n              value instanceof WEBGLTextureView ||\n              value instanceof WEBGLTexture ||\n              value instanceof WEBGLFramebuffer\n            )\n          ) {\n            throw new Error('texture value');\n          }\n          break;\n        case 'sampler':\n          log.warn(`Ignoring sampler ${name}`)();\n          break;\n        default:\n          throw new Error(binding.type);\n      }\n\n      this.bindings[name] = value;\n    }\n  }\n\n  /** @todo needed for portable model\n   * @note The WebGL API is offers many ways to draw things\n   * This function unifies those ways into a single call using common parameters with sane defaults\n   */\n  draw(options: {\n    renderPass: RenderPass;\n    parameters?: RenderPipelineParameters;\n    topology?: PrimitiveTopology;\n    vertexArray: VertexArray;\n    isInstanced?: boolean;\n    vertexCount?: number;\n    indexCount?: number;\n    instanceCount?: number;\n    firstVertex?: number;\n    firstIndex?: number;\n    firstInstance?: number;\n    baseVertex?: number;\n    transformFeedback?: WEBGLTransformFeedback;\n  }): boolean {\n    const {\n      renderPass,\n      parameters = this.props.parameters,\n      topology = this.props.topology,\n      vertexArray,\n      vertexCount,\n      // indexCount,\n      instanceCount,\n      isInstanced = false,\n      firstVertex = 0,\n      // firstIndex,\n      // firstInstance,\n      // baseVertex,\n      transformFeedback\n    } = options;\n\n    const glDrawMode = getGLDrawMode(topology);\n    const isIndexed: boolean = Boolean(vertexArray.indexBuffer);\n    const glIndexType = (vertexArray.indexBuffer as WEBGLBuffer)?.glIndexType;\n    // Note that we sometimes get called with 0 instances\n\n    // If we are using async linking, we need to wait until linking completes\n    if (this.linkStatus !== 'success') {\n      log.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)();\n      return false;\n    }\n\n    // Avoid WebGL draw call when not rendering any data or values are incomplete\n    // Note: async textures set as uniforms might still be loading.\n    // Now that all uniforms have been updated, check if any texture\n    // in the uniforms is not yet initialized, then we don't draw\n    if (!this._areTexturesRenderable()) {\n      log.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)();\n      //  Note: false means that the app needs to redraw the pipeline again.\n      return false;\n    }\n\n    // (isInstanced && instanceCount === 0)\n    // if (vertexCount === 0) {\n    //   log.info(2, `RenderPipeline:${this.id}.draw() aborted - no vertices to draw`)();\n    //   Note: false means that the app needs to redraw the pipeline again.\n    //   return true;\n    // }\n\n    this.device.gl.useProgram(this.handle);\n\n    // Note: Rebinds constant attributes before each draw call\n    vertexArray.bindBeforeRender(renderPass);\n\n    if (transformFeedback) {\n      transformFeedback.begin(this.props.topology);\n    }\n\n    // We have to apply bindings before every draw call since other draw calls will overwrite\n    this._applyBindings();\n    this._applyUniforms();\n\n    const webglRenderPass = renderPass as WEBGLRenderPass;\n\n    withDeviceAndGLParameters(this.device, parameters, webglRenderPass.glParameters, () => {\n      if (isIndexed && isInstanced) {\n        this.device.gl.drawElementsInstanced(\n          glDrawMode,\n          vertexCount || 0, // indexCount?\n          glIndexType,\n          firstVertex,\n          instanceCount || 0\n        );\n        // } else if (isIndexed && this.device.isWebGL2 && !isNaN(start) && !isNaN(end)) {\n        //   this.device.gldrawRangeElements(glDrawMode, start, end, vertexCount, glIndexType, offset);\n      } else if (isIndexed) {\n        this.device.gl.drawElements(glDrawMode, vertexCount || 0, glIndexType, firstVertex); // indexCount?\n      } else if (isInstanced) {\n        this.device.gl.drawArraysInstanced(\n          glDrawMode,\n          firstVertex,\n          vertexCount || 0,\n          instanceCount || 0\n        );\n      } else {\n        this.device.gl.drawArrays(glDrawMode, firstVertex, vertexCount || 0);\n      }\n\n      if (transformFeedback) {\n        transformFeedback.end();\n      }\n    });\n\n    vertexArray.unbindAfterRender(renderPass);\n\n    return true;\n  }\n\n  // DEPRECATED METHODS\n\n  override setUniformsWebGL(uniforms: Record<string, UniformValue>) {\n    const {bindings} = splitUniformsAndBindings(uniforms);\n    Object.keys(bindings).forEach(name => {\n      log.warn(\n        `Unsupported value \"${JSON.stringify(\n          bindings[name]\n        )}\" used in setUniforms() for key ${name}. Use setBindings() instead?`\n      )();\n    });\n    // TODO - check against layout\n    Object.assign(this.uniforms, uniforms);\n  }\n\n  // PRIVATE METHODS\n\n  // setAttributes(attributes: Record<string, Buffer>): void {}\n  // setBindings(bindings: Record<string, Binding>): void {}\n\n  protected async _linkShaders() {\n    const {gl} = this.device;\n    gl.attachShader(this.handle, this.vs.handle);\n    gl.attachShader(this.handle, this.fs.handle);\n    log.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();\n    gl.linkProgram(this.handle);\n    log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();\n\n    // TODO Avoid checking program linking error in production\n    if (log.level === 0) {\n      // return;\n    }\n\n    if (!this.device.features.has('compilation-status-async-webgl')) {\n      const status = this._getLinkStatus();\n      this._reportLinkStatus(status);\n      return;\n    }\n\n    // async case\n    log.once(1, 'RenderPipeline linking is asynchronous')();\n    await this._waitForLinkComplete();\n    log.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();\n    const status = this._getLinkStatus();\n    this._reportLinkStatus(status);\n  }\n\n  /** Report link status. First, check for shader compilation failures if linking fails */\n  async _reportLinkStatus(status: 'success' | 'linking' | 'validation'): Promise<void> {\n    switch (status) {\n      case 'success':\n        return;\n\n      default:\n        // First check for shader compilation failures if linking fails\n        switch (this.vs.compilationStatus) {\n          case 'error':\n            this.vs.debugShader();\n            throw new Error(`Error during compilation of shader ${this.vs.id}`);\n          case 'pending':\n            this.vs.asyncCompilationStatus.then(() => this.vs.debugShader());\n            break;\n          case 'success':\n            break;\n        }\n\n        switch (this.fs?.compilationStatus) {\n          case 'error':\n            this.fs.debugShader();\n            throw new Error(`Error during compilation of shader ${this.fs.id}`);\n          case 'pending':\n            this.fs.asyncCompilationStatus.then(() => this.fs.debugShader());\n            break;\n          case 'success':\n            break;\n        }\n\n        const linkErrorLog = this.device.gl.getProgramInfoLog(this.handle);\n        throw new Error(`Error during ${status}: ${linkErrorLog}`);\n    }\n  }\n\n  /**\n   * Get the shader compilation status\n   * TODO - Load log even when no error reported, to catch warnings?\n   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings\n   */\n  _getLinkStatus(): 'success' | 'linking' | 'validation' {\n    const {gl} = this.device;\n    const linked = gl.getProgramParameter(this.handle, gl.LINK_STATUS);\n    if (!linked) {\n      this.linkStatus = 'error';\n      return 'linking';\n    }\n\n    gl.validateProgram(this.handle);\n    const validated = gl.getProgramParameter(this.handle, gl.VALIDATE_STATUS);\n    if (!validated) {\n      this.linkStatus = 'error';\n      return 'validation';\n    }\n\n    this.linkStatus = 'success';\n    return 'success';\n  }\n\n  /** Use KHR_parallel_shader_compile extension if available */\n  async _waitForLinkComplete(): Promise<void> {\n    const waitMs = async (ms: number) => await new Promise(resolve => setTimeout(resolve, ms));\n    const DELAY_MS = 10; // Shader compilation is typically quite fast (with some exceptions)\n\n    // If status polling is not available, we can't wait for completion. Just wait a little to minimize blocking\n    if (!this.device.features.has('compilation-status-async-webgl')) {\n      await waitMs(DELAY_MS);\n      return;\n    }\n\n    const {gl} = this.device;\n    for (;;) {\n      const complete = gl.getProgramParameter(this.handle, GL.COMPLETION_STATUS_KHR);\n      if (complete) {\n        return;\n      }\n      await waitMs(DELAY_MS);\n    }\n  }\n\n  /**\n   * Checks if all texture-values uniforms are renderable (i.e. loaded)\n   * Update a texture if needed (e.g. from video)\n   * Note: This is currently done before every draw call\n   */\n  _areTexturesRenderable() {\n    let texturesRenderable = true;\n\n    for (const bindingInfo of this.shaderLayout.bindings) {\n      if (\n        !this.bindings[bindingInfo.name] &&\n        !this.bindings[bindingInfo.name.replace(/Uniforms$/, '')]\n      ) {\n        log.warn(`Binding ${bindingInfo.name} not found in ${this.id}`)();\n        texturesRenderable = false;\n      }\n    }\n\n    // TODO - remove this should be handled by ExternalTexture\n    // for (const [, texture] of Object.entries(this.bindings)) {\n    //   if (texture instanceof WEBGLTexture) {\n    //     texture.update();\n    //   }\n    // }\n\n    return texturesRenderable;\n  }\n\n  /** Apply any bindings (before each draw call) */\n  _applyBindings() {\n    // If we are using async linking, we need to wait until linking completes\n    if (this.linkStatus !== 'success') {\n      return;\n    }\n\n    const {gl} = this.device;\n    gl.useProgram(this.handle);\n\n    let textureUnit = 0;\n    let uniformBufferIndex = 0;\n    for (const binding of this.shaderLayout.bindings) {\n      // Accept both `xyz` and `xyzUniforms` as valid names for `xyzUniforms` uniform block\n      const value =\n        this.bindings[binding.name] || this.bindings[binding.name.replace(/Uniforms$/, '')];\n      if (!value) {\n        throw new Error(`No value for binding ${binding.name} in ${this.id}`);\n      }\n      switch (binding.type) {\n        case 'uniform':\n          // Set buffer\n          const {name} = binding;\n          const location = gl.getUniformBlockIndex(this.handle, name);\n          if ((location as GL) === GL.INVALID_INDEX) {\n            throw new Error(`Invalid uniform block name ${name}`);\n          }\n          gl.uniformBlockBinding(this.handle, uniformBufferIndex, location);\n          // console.debug(binding, location);\n          if (value instanceof WEBGLBuffer) {\n            gl.bindBufferBase(GL.UNIFORM_BUFFER, uniformBufferIndex, value.handle);\n          } else {\n            gl.bindBufferRange(\n              GL.UNIFORM_BUFFER,\n              uniformBufferIndex,\n              // @ts-expect-error\n              value.buffer.handle,\n              // @ts-expect-error\n              value.offset || 0,\n              // @ts-expect-error\n              value.size || value.buffer.byteLength - value.offset\n            );\n          }\n          uniformBufferIndex += 1;\n          break;\n\n        case 'texture':\n          if (\n            !(\n              value instanceof WEBGLTextureView ||\n              value instanceof WEBGLTexture ||\n              value instanceof WEBGLFramebuffer\n            )\n          ) {\n            throw new Error('texture');\n          }\n          let texture: WEBGLTexture;\n          if (value instanceof WEBGLTextureView) {\n            texture = value.texture;\n          } else if (value instanceof WEBGLTexture) {\n            texture = value;\n          } else if (\n            value instanceof WEBGLFramebuffer &&\n            value.colorAttachments[0] instanceof WEBGLTextureView\n          ) {\n            log.warn(\n              'Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead'\n            )();\n            texture = value.colorAttachments[0].texture;\n          } else {\n            throw new Error('No texture');\n          }\n\n          gl.activeTexture(GL.TEXTURE0 + textureUnit);\n          gl.bindTexture(texture.glTarget, texture.handle);\n          // gl.bindSampler(textureUnit, sampler.handle);\n          textureUnit += 1;\n          break;\n\n        case 'sampler':\n          // ignore\n          break;\n\n        case 'storage':\n        case 'read-only-storage':\n          throw new Error(`binding type '${binding.type}' not supported in WebGL`);\n      }\n    }\n  }\n\n  /**\n   * Due to program sharing, uniforms need to be reset before every draw call\n   * (though caching will avoid redundant WebGL calls)\n   */\n  _applyUniforms() {\n    for (const uniformLayout of this.shaderLayout.uniforms || []) {\n      const {name, location, type, textureUnit} = uniformLayout;\n      const value = this.uniforms[name] ?? textureUnit;\n      if (value !== undefined) {\n        setUniform(this.device.gl, location, type, value);\n      }\n    }\n  }\n}\n\n/**\n * Merges an provided shader layout into a base shader layout\n * In WebGL, this allows the auto generated shader layout to be overridden by the application\n * Typically to change the format of the vertex attributes (from float32x4 to uint8x4 etc).\n * @todo Drop this? Aren't all use cases covered by mergeBufferLayout()?\n */\nfunction mergeShaderLayout(baseLayout: ShaderLayout, overrideLayout: ShaderLayout): ShaderLayout {\n  // Deep clone the base layout\n  const mergedLayout: ShaderLayout = {\n    ...baseLayout,\n    attributes: baseLayout.attributes.map(attribute => ({...attribute}))\n  };\n  // Merge the attributes\n  for (const attribute of overrideLayout?.attributes || []) {\n    const baseAttribute = mergedLayout.attributes.find(attr => attr.name === attribute.name);\n    if (!baseAttribute) {\n      log.warn(`shader layout attribute ${attribute.name} not present in shader`);\n    } else {\n      baseAttribute.type = attribute.type || baseAttribute.type;\n      baseAttribute.stepMode = attribute.stepMode || baseAttribute.stepMode;\n    }\n  }\n  return mergedLayout;\n}\n"],"mappings":"AAAA;AACA;AACA;AAYA,SAAQA,cAAc,EAAEC,GAAG,QAAO,eAAe;AACjD;AACA,SAAQC,EAAE,QAAO,oBAAoB;AAErC,SAAQC,uBAAuB,QAAC;AAChC,SAAQC,yBAAyB,QAAC;AAClC,SAAQC,UAAU,QAAC;AACnB,SAAQC,wBAAwB,QAAC;AAIjC,SAAQC,WAAW,QAAC;AAEpB,SAAQC,gBAAgB,QAAC;AACzB,SAAQC,YAAY,QAAC;AACrB,SAAQC,gBAAgB,QAAC;AAGzB,SAAQC,aAAa,QAAC;AAEtB,MAAMC,yBAAyB,GAAG,CAAC;AAEnC;AACA,OAAM,MAAOC,mBAAoB,SAAQb,cAAc;EACrD;EACAc,MAAM;EACN;EACAC,MAAM;EACN;EACAC,EAAE;EACF;EACAC,EAAE;EACF;EACAC,kBAAkB;EAElB;EACAC,QAAQ,GAAiC,EAAE;EAC3C;EACAC,QAAQ,GAA4B,EAAE;EACtC;EACAC,QAAQ,GAAoB,IAAI;EAEhCC,aAAa,GAAW,CAAC;EACzBC,eAAe,GAA6B,EAAE,CAAC,CAAC;EAEhDC,YAAYV,MAAmB,EAAEW,KAA0B;IACzD,KAAK,CAACX,MAAM,EAAEW,KAAK,CAAC;IACpB,IAAI,CAACX,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,MAAM,GAAG,IAAI,CAACU,KAAK,CAACV,MAAM,IAAI,IAAI,CAACD,MAAM,CAACY,EAAE,CAACC,aAAa,EAAE;IACjE,IAAI,CAACb,MAAM,CAACc,kBAAkB,CAAC,IAAI,CAACb,MAAM,EAAE;MAACc,EAAE,EAAE,IAAI,CAACJ,KAAK,CAACI;IAAE,CAAC,CAAC;IAEhE;IACA,IAAI,CAACb,EAAE,GAAGS,KAAK,CAACT,EAAiB;IACjC,IAAI,CAACC,EAAE,GAAGQ,KAAK,CAACR,EAAiB;IACjC;IACA;IAEA;IACA;IACA,MAAM;MAACI,QAAQ;MAAES,UAAU;IAAsB,CAAC,GAAGL,KAAK;IAC1D,IAAIJ,QAAQ,IAAIA,QAAQ,CAACU,MAAM,GAAG,CAAC,EAAE;MACnC,IAAI,CAACV,QAAQ,GAAGA,QAAQ;MACxB,IAAI,CAACP,MAAM,CAACY,EAAE,CAACM,yBAAyB,CAAC,IAAI,CAACjB,MAAM,EAAEM,QAAQ,EAAES,UAAU,CAAC;IAC7E;IAEA,IAAI,CAACG,YAAY,EAAE;IAEnBhC,GAAG,CAACiC,IAAI,CAAC,CAAC,EAAE,kBAAkB,IAAI,CAACL,EAAE,+BAA+B,CAAC,EAAE;IACvE,IAAI,CAACX,kBAAkB,GAAGf,uBAAuB,CAAC,IAAI,CAACW,MAAM,CAACY,EAAE,EAAE,IAAI,CAACX,MAAM,CAAC;IAC9Ed,GAAG,CAACkC,OAAO,CAAC,CAAC,EAAE,kBAAkB,IAAI,CAACN,EAAE,+BAA+B,CAAC,EAAE;IAE1E;IACA,IAAI,CAACO,YAAY,GAAGC,iBAAiB,CAAC,IAAI,CAACnB,kBAAkB,EAAEO,KAAK,CAACW,YAAY,CAAC;EACpF;EAESE,OAAOA,CAAA;IACd,IAAI,IAAI,CAACvB,MAAM,EAAE;MACf,IAAI,CAACD,MAAM,CAACY,EAAE,CAACa,aAAa,CAAC,IAAI,CAACxB,MAAM,CAAC;MACzC;MACA,IAAI,CAACyB,SAAS,GAAG,IAAI;IACvB;EACF;EAEA;;;;EAIAC,WAAWA,CAACrB,QAAiC,EAAEsB,OAAqC;IAClF;IACA;IACA;IAEA,KAAK,MAAM,CAACC,IAAI,EAAEC,KAAK,CAAC,IAAIC,MAAM,CAACC,OAAO,CAAC1B,QAAQ,CAAC,EAAE;MACpD;MACA;MACA;MACA;MACA,MAAM2B,OAAO,GACX,IAAI,CAACX,YAAY,CAAChB,QAAQ,CAAC4B,IAAI,CAACC,QAAQ,IAAIA,QAAQ,CAACN,IAAI,KAAKA,IAAI,CAAC,IACnE,IAAI,CAACP,YAAY,CAAChB,QAAQ,CAAC4B,IAAI,CAACC,QAAQ,IAAIA,QAAQ,CAACN,IAAI,KAAK,GAAGA,IAAI,UAAU,CAAC;MAElF,IAAI,CAACI,OAAO,EAAE;QACZ,MAAMG,aAAa,GAAG,IAAI,CAACd,YAAY,CAAChB,QAAQ,CAC7C+B,GAAG,CAACF,QAAQ,IAAI,IAAIA,QAAQ,CAACN,IAAI,GAAG,CAAC,CACrCS,IAAI,CAAC,IAAI,CAAC;QACb,IAAI,CAACV,OAAO,EAAEW,eAAe,EAAE;UAC7BpD,GAAG,CAACqD,IAAI,CACN,eAAeX,IAAI,yBAAyB,IAAI,CAACd,EAAE,sBAAsBqB,aAAa,EAAE,EACxFN,KAAK,CACN,EAAE;QACL;QACA,SAAS,CAAC;MACZ;MACA,IAAI,CAACA,KAAK,EAAE;QACV3C,GAAG,CAACqD,IAAI,CAAC,sBAAsBX,IAAI,yBAAyB,IAAI,CAACd,EAAE,GAAG,CAAC,EAAE;MAC3E;MACA,QAAQkB,OAAO,CAACQ,IAAI;QAClB,KAAK,SAAS;UACZ;UACA,IAAI,EAAEX,KAAK,YAAYrC,WAAW,CAAC,IAAI,EAAEqC,KAAK,CAACY,MAAM,YAAYjD,WAAW,CAAC,EAAE;YAC7E,MAAM,IAAIkD,KAAK,CAAC,cAAc,CAAC;UACjC;UACA;QACF,KAAK,SAAS;UACZ,IACE,EACEb,KAAK,YAAYlC,gBAAgB,IACjCkC,KAAK,YAAYnC,YAAY,IAC7BmC,KAAK,YAAYpC,gBAAgB,CAClC,EACD;YACA,MAAM,IAAIiD,KAAK,CAAC,eAAe,CAAC;UAClC;UACA;QACF,KAAK,SAAS;UACZxD,GAAG,CAACqD,IAAI,CAAC,oBAAoBX,IAAI,EAAE,CAAC,EAAE;UACtC;QACF;UACE,MAAM,IAAIc,KAAK,CAACV,OAAO,CAACQ,IAAI,CAAC;MACjC;MAEA,IAAI,CAACnC,QAAQ,CAACuB,IAAI,CAAC,GAAGC,KAAK;IAC7B;EACF;EAEA;;;;EAIAc,IAAIA,CAAChB,OAcJ;IACC,MAAM;MACJiB,UAAU;MACVC,UAAU,GAAG,IAAI,CAACnC,KAAK,CAACmC,UAAU;MAClCC,QAAQ,GAAG,IAAI,CAACpC,KAAK,CAACoC,QAAQ;MAC9BC,WAAW;MACXC,WAAW;MACX;MACAC,aAAa;MACbC,WAAW,GAAG,KAAK;MACnBC,WAAW,GAAG,CAAC;MACf;MACA;MACA;MACAC;IAAiB,CAClB,GAAGzB,OAAO;IAEX,MAAM0B,UAAU,GAAGzD,aAAa,CAACkD,QAAQ,CAAC;IAC1C,MAAMQ,SAAS,GAAYC,OAAO,CAACR,WAAW,CAACS,WAAW,CAAC;IAC3D,MAAMC,WAAW,GAAIV,WAAW,CAACS,WAA2B,EAAEC,WAAW;IACzE;IAEA;IACA,IAAI,IAAI,CAACC,UAAU,KAAK,SAAS,EAAE;MACjCxE,GAAG,CAACyE,IAAI,CAAC,CAAC,EAAE,kBAAkB,IAAI,CAAC7C,EAAE,8CAA8C,CAAC,EAAE;MACtF,OAAO,KAAK;IACd;IAEA;IACA;IACA;IACA;IACA,IAAI,CAAC,IAAI,CAAC8C,sBAAsB,EAAE,EAAE;MAClC1E,GAAG,CAACyE,IAAI,CAAC,CAAC,EAAE,kBAAkB,IAAI,CAAC7C,EAAE,2CAA2C,CAAC,EAAE;MACnF;MACA,OAAO,KAAK;IACd;IAEA;IACA;IACA;IACA;IACA;IACA;IAEA,IAAI,CAACf,MAAM,CAACY,EAAE,CAACkD,UAAU,CAAC,IAAI,CAAC7D,MAAM,CAAC;IAEtC;IACA+C,WAAW,CAACe,gBAAgB,CAAClB,UAAU,CAAC;IAExC,IAAIQ,iBAAiB,EAAE;MACrBA,iBAAiB,CAACW,KAAK,CAAC,IAAI,CAACrD,KAAK,CAACoC,QAAQ,CAAC;IAC9C;IAEA;IACA,IAAI,CAACkB,cAAc,EAAE;IACrB,IAAI,CAACC,cAAc,EAAE;IAErB,MAAMC,eAAe,GAAGtB,UAA6B;IAErDvD,yBAAyB,CAAC,IAAI,CAACU,MAAM,EAAE8C,UAAU,EAAEqB,eAAe,CAACC,YAAY,EAAE,MAAK;MACpF,IAAIb,SAAS,IAAIJ,WAAW,EAAE;QAC5B,IAAI,CAACnD,MAAM,CAACY,EAAE,CAACyD,qBAAqB,CAClCf,UAAU,EACVL,WAAW,IAAI,CAAC;QAAE;QAClBS,WAAW,EACXN,WAAW,EACXF,aAAa,IAAI,CAAC,CACnB;QACD;QACA;MACF,CAAC,MAAM,IAAIK,SAAS,EAAE;QACpB,IAAI,CAACvD,MAAM,CAACY,EAAE,CAAC0D,YAAY,CAAChB,UAAU,EAAEL,WAAW,IAAI,CAAC,EAAES,WAAW,EAAEN,WAAW,CAAC,CAAC,CAAC;MACvF,CAAC,MAAM,IAAID,WAAW,EAAE;QACtB,IAAI,CAACnD,MAAM,CAACY,EAAE,CAAC2D,mBAAmB,CAChCjB,UAAU,EACVF,WAAW,EACXH,WAAW,IAAI,CAAC,EAChBC,aAAa,IAAI,CAAC,CACnB;MACH,CAAC,MAAM;QACL,IAAI,CAAClD,MAAM,CAACY,EAAE,CAAC4D,UAAU,CAAClB,UAAU,EAAEF,WAAW,EAAEH,WAAW,IAAI,CAAC,CAAC;MACtE;MAEA,IAAII,iBAAiB,EAAE;QACrBA,iBAAiB,CAACoB,GAAG,EAAE;MACzB;IACF,CAAC,CAAC;IAEFzB,WAAW,CAAC0B,iBAAiB,CAAC7B,UAAU,CAAC;IAEzC,OAAO,IAAI;EACb;EAEA;EAES8B,gBAAgBA,CAACtE,QAAsC;IAC9D,MAAM;MAACC;IAAQ,CAAC,GAAGd,wBAAwB,CAACa,QAAQ,CAAC;IACrD0B,MAAM,CAAC6C,IAAI,CAACtE,QAAQ,CAAC,CAACuE,OAAO,CAAChD,IAAI,IAAG;MACnC1C,GAAG,CAACqD,IAAI,CACN,sBAAsBsC,IAAI,CAACC,SAAS,CAClCzE,QAAQ,CAACuB,IAAI,CAAC,CACf,mCAAmCA,IAAI,8BAA8B,CACvE,EAAE;IACL,CAAC,CAAC;IACF;IACAE,MAAM,CAACiD,MAAM,CAAC,IAAI,CAAC3E,QAAQ,EAAEA,QAAQ,CAAC;EACxC;EAEA;EAEA;EACA;EAEU,MAAMc,YAAYA,CAAA;IAC1B,MAAM;MAACP;IAAE,CAAC,GAAG,IAAI,CAACZ,MAAM;IACxBY,EAAE,CAACqE,YAAY,CAAC,IAAI,CAAChF,MAAM,EAAE,IAAI,CAACC,EAAE,CAACD,MAAM,CAAC;IAC5CW,EAAE,CAACqE,YAAY,CAAC,IAAI,CAAChF,MAAM,EAAE,IAAI,CAACE,EAAE,CAACF,MAAM,CAAC;IAC5Cd,GAAG,CAACiC,IAAI,CAACtB,yBAAyB,EAAE,mBAAmB,IAAI,CAACiB,EAAE,EAAE,CAAC,EAAE;IACnEH,EAAE,CAACsE,WAAW,CAAC,IAAI,CAACjF,MAAM,CAAC;IAC3Bd,GAAG,CAACkC,OAAO,CAACvB,yBAAyB,EAAE,mBAAmB,IAAI,CAACiB,EAAE,EAAE,CAAC,EAAE;IAEtE;IACA,IAAI5B,GAAG,CAACgG,KAAK,KAAK,CAAC,EAAE;MACnB;IAAA;IAGF,IAAI,CAAC,IAAI,CAACnF,MAAM,CAACoF,QAAQ,CAACC,GAAG,CAAC,gCAAgC,CAAC,EAAE;MAC/D,MAAMC,MAAM,GAAG,IAAI,CAACC,cAAc,EAAE;MACpC,IAAI,CAACC,iBAAiB,CAACF,MAAM,CAAC;MAC9B;IACF;IAEA;IACAnG,GAAG,CAACsG,IAAI,CAAC,CAAC,EAAE,wCAAwC,CAAC,EAAE;IACvD,MAAM,IAAI,CAACC,oBAAoB,EAAE;IACjCvG,GAAG,CAACyE,IAAI,CAAC,CAAC,EAAE,kBAAkB,IAAI,CAAC7C,EAAE,8BAA8B,IAAI,CAAC4C,UAAU,EAAE,CAAC,EAAE;IACvF,MAAM2B,MAAM,GAAG,IAAI,CAACC,cAAc,EAAE;IACpC,IAAI,CAACC,iBAAiB,CAACF,MAAM,CAAC;EAChC;EAEA;EACA,MAAME,iBAAiBA,CAACF,MAA4C;IAClE,QAAQA,MAAM;MACZ,KAAK,SAAS;QACZ;MAEF;QACE;QACA,QAAQ,IAAI,CAACpF,EAAE,CAACyF,iBAAiB;UAC/B,KAAK,OAAO;YACV,IAAI,CAACzF,EAAE,CAAC0F,WAAW,EAAE;YACrB,MAAM,IAAIjD,KAAK,CAAC,sCAAsC,IAAI,CAACzC,EAAE,CAACa,EAAE,EAAE,CAAC;UACrE,KAAK,SAAS;YACZ,IAAI,CAACb,EAAE,CAAC2F,sBAAsB,CAACC,IAAI,CAAC,MAAM,IAAI,CAAC5F,EAAE,CAAC0F,WAAW,EAAE,CAAC;YAChE;UACF,KAAK,SAAS;YACZ;QACJ;QAEA,QAAQ,IAAI,CAACzF,EAAE,EAAEwF,iBAAiB;UAChC,KAAK,OAAO;YACV,IAAI,CAACxF,EAAE,CAACyF,WAAW,EAAE;YACrB,MAAM,IAAIjD,KAAK,CAAC,sCAAsC,IAAI,CAACxC,EAAE,CAACY,EAAE,EAAE,CAAC;UACrE,KAAK,SAAS;YACZ,IAAI,CAACZ,EAAE,CAAC0F,sBAAsB,CAACC,IAAI,CAAC,MAAM,IAAI,CAAC3F,EAAE,CAACyF,WAAW,EAAE,CAAC;YAChE;UACF,KAAK,SAAS;YACZ;QACJ;QAEA,MAAMG,YAAY,GAAG,IAAI,CAAC/F,MAAM,CAACY,EAAE,CAACoF,iBAAiB,CAAC,IAAI,CAAC/F,MAAM,CAAC;QAClE,MAAM,IAAI0C,KAAK,CAAC,gBAAgB2C,MAAM,KAAKS,YAAY,EAAE,CAAC;IAC9D;EACF;EAEA;;;;;EAKAR,cAAcA,CAAA;IACZ,MAAM;MAAC3E;IAAE,CAAC,GAAG,IAAI,CAACZ,MAAM;IACxB,MAAMiG,MAAM,GAAGrF,EAAE,CAACsF,mBAAmB,CAAC,IAAI,CAACjG,MAAM,QAAiB;IAClE,IAAI,CAACgG,MAAM,EAAE;MACX,IAAI,CAACtC,UAAU,GAAG,OAAO;MACzB,OAAO,SAAS;IAClB;IAEA/C,EAAE,CAACuF,eAAe,CAAC,IAAI,CAAClG,MAAM,CAAC;IAC/B,MAAMmG,SAAS,GAAGxF,EAAE,CAACsF,mBAAmB,CAAC,IAAI,CAACjG,MAAM,QAAqB;IACzE,IAAI,CAACmG,SAAS,EAAE;MACd,IAAI,CAACzC,UAAU,GAAG,OAAO;MACzB,OAAO,YAAY;IACrB;IAEA,IAAI,CAACA,UAAU,GAAG,SAAS;IAC3B,OAAO,SAAS;EAClB;EAEA;EACA,MAAM+B,oBAAoBA,CAAA;IACxB,MAAMW,MAAM,GAAG,MAAOC,EAAU,IAAK,MAAM,IAAIC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEF,EAAE,CAAC,CAAC;IAC1F,MAAMI,QAAQ,GAAG,EAAE,CAAC,CAAC;IAErB;IACA,IAAI,CAAC,IAAI,CAAC1G,MAAM,CAACoF,QAAQ,CAACC,GAAG,CAAC,gCAAgC,CAAC,EAAE;MAC/D,MAAMgB,MAAM,CAACK,QAAQ,CAAC;MACtB;IACF;IAEA,MAAM;MAAC9F;IAAE,CAAC,GAAG,IAAI,CAACZ,MAAM;IACxB,SAAS;MACP,MAAM2G,QAAQ,GAAG/F,EAAE,CAACsF,mBAAmB,CAAC,IAAI,CAACjG,MAAM,QAA2B;MAC9E,IAAI0G,QAAQ,EAAE;QACZ;MACF;MACA,MAAMN,MAAM,CAACK,QAAQ,CAAC;IACxB;EACF;EAEA;;;;;EAKA7C,sBAAsBA,CAAA;IACpB,IAAI+C,kBAAkB,GAAG,IAAI;IAE7B,KAAK,MAAMC,WAAW,IAAI,IAAI,CAACvF,YAAY,CAAChB,QAAQ,EAAE;MACpD,IACE,CAAC,IAAI,CAACA,QAAQ,CAACuG,WAAW,CAAChF,IAAI,CAAC,IAChC,CAAC,IAAI,CAACvB,QAAQ,CAACuG,WAAW,CAAChF,IAAI,CAACiF,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC,EACzD;QACA3H,GAAG,CAACqD,IAAI,CAAC,WAAWqE,WAAW,CAAChF,IAAI,iBAAiB,IAAI,CAACd,EAAE,EAAE,CAAC,EAAE;QACjE6F,kBAAkB,GAAG,KAAK;MAC5B;IACF;IAEA;IACA;IACA;IACA;IACA;IACA;IAEA,OAAOA,kBAAkB;EAC3B;EAEA;EACA3C,cAAcA,CAAA;IACZ;IACA,IAAI,IAAI,CAACN,UAAU,KAAK,SAAS,EAAE;MACjC;IACF;IAEA,MAAM;MAAC/C;IAAE,CAAC,GAAG,IAAI,CAACZ,MAAM;IACxBY,EAAE,CAACkD,UAAU,CAAC,IAAI,CAAC7D,MAAM,CAAC;IAE1B,IAAI8G,WAAW,GAAG,CAAC;IACnB,IAAIC,kBAAkB,GAAG,CAAC;IAC1B,KAAK,MAAM/E,OAAO,IAAI,IAAI,CAACX,YAAY,CAAChB,QAAQ,EAAE;MAChD;MACA,MAAMwB,KAAK,GACT,IAAI,CAACxB,QAAQ,CAAC2B,OAAO,CAACJ,IAAI,CAAC,IAAI,IAAI,CAACvB,QAAQ,CAAC2B,OAAO,CAACJ,IAAI,CAACiF,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;MACrF,IAAI,CAAChF,KAAK,EAAE;QACV,MAAM,IAAIa,KAAK,CAAC,wBAAwBV,OAAO,CAACJ,IAAI,OAAO,IAAI,CAACd,EAAE,EAAE,CAAC;MACvE;MACA,QAAQkB,OAAO,CAACQ,IAAI;QAClB,KAAK,SAAS;UACZ;UACA,MAAM;YAACZ;UAAI,CAAC,GAAGI,OAAO;UACtB,MAAMgF,QAAQ,GAAGrG,EAAE,CAACsG,oBAAoB,CAAC,IAAI,CAACjH,MAAM,EAAE4B,IAAI,CAAC;UAC3D,IAAKoF,QAAe,eAAqB,EAAE;YACzC,MAAM,IAAItE,KAAK,CAAC,8BAA8Bd,IAAI,EAAE,CAAC;UACvD;UACAjB,EAAE,CAACuG,mBAAmB,CAAC,IAAI,CAAClH,MAAM,EAAE+G,kBAAkB,EAAEC,QAAQ,CAAC;UACjE;UACA,IAAInF,KAAK,YAAYrC,WAAW,EAAE;YAChCmB,EAAE,CAACwG,cAAc,QAAoBJ,kBAAkB,EAAElF,KAAK,CAAC7B,MAAM,CAAC;UACxE,CAAC,MAAM;YACLW,EAAE,CAACyG,eAAe,QAEhBL,kBAAkB;YAClB;YACAlF,KAAK,CAACY,MAAM,CAACzC,MAAM;YACnB;YACA6B,KAAK,CAACwF,MAAM,IAAI,CAAC;YACjB;YACAxF,KAAK,CAACyF,IAAI,IAAIzF,KAAK,CAACY,MAAM,CAAC8E,UAAU,GAAG1F,KAAK,CAACwF,MAAM,CACrD;UACH;UACAN,kBAAkB,IAAI,CAAC;UACvB;QAEF,KAAK,SAAS;UACZ,IACE,EACElF,KAAK,YAAYlC,gBAAgB,IACjCkC,KAAK,YAAYnC,YAAY,IAC7BmC,KAAK,YAAYpC,gBAAgB,CAClC,EACD;YACA,MAAM,IAAIiD,KAAK,CAAC,SAAS,CAAC;UAC5B;UACA,IAAI8E,OAAqB;UACzB,IAAI3F,KAAK,YAAYlC,gBAAgB,EAAE;YACrC6H,OAAO,GAAG3F,KAAK,CAAC2F,OAAO;UACzB,CAAC,MAAM,IAAI3F,KAAK,YAAYnC,YAAY,EAAE;YACxC8H,OAAO,GAAG3F,KAAK;UACjB,CAAC,MAAM,IACLA,KAAK,YAAYpC,gBAAgB,IACjCoC,KAAK,CAAC4F,gBAAgB,CAAC,CAAC,CAAC,YAAY9H,gBAAgB,EACrD;YACAT,GAAG,CAACqD,IAAI,CACN,+FAA+F,CAChG,EAAE;YACHiF,OAAO,GAAG3F,KAAK,CAAC4F,gBAAgB,CAAC,CAAC,CAAC,CAACD,OAAO;UAC7C,CAAC,MAAM;YACL,MAAM,IAAI9E,KAAK,CAAC,YAAY,CAAC;UAC/B;UAEA/B,EAAE,CAAC+G,aAAa,CAAC,QAAcZ,WAAW,CAAC;UAC3CnG,EAAE,CAACgH,WAAW,CAACH,OAAO,CAACI,QAAQ,EAAEJ,OAAO,CAACxH,MAAM,CAAC;UAChD;UACA8G,WAAW,IAAI,CAAC;UAChB;QAEF,KAAK,SAAS;UACZ;UACA;QAEF,KAAK,SAAS;QACd,KAAK,mBAAmB;UACtB,MAAM,IAAIpE,KAAK,CAAC,iBAAiBV,OAAO,CAACQ,IAAI,0BAA0B,CAAC;MAC5E;IACF;EACF;EAEA;;;;EAIAyB,cAAcA,CAAA;IACZ,KAAK,MAAM4D,aAAa,IAAI,IAAI,CAACxG,YAAY,CAACjB,QAAQ,IAAI,EAAE,EAAE;MAC5D,MAAM;QAACwB,IAAI;QAAEoF,QAAQ;QAAExE,IAAI;QAAEsE;MAAW,CAAC,GAAGe,aAAa;MACzD,MAAMhG,KAAK,GAAG,IAAI,CAACzB,QAAQ,CAACwB,IAAI,CAAC,IAAIkF,WAAW;MAChD,IAAIjF,KAAK,KAAKiG,SAAS,EAAE;QACvBxI,UAAU,CAAC,IAAI,CAACS,MAAM,CAACY,EAAE,EAAEqG,QAAQ,EAAExE,IAAI,EAAEX,KAAK,CAAC;MACnD;IACF;EACF;;AAGF;;;;;;AAMA,SAASP,iBAAiBA,CAACyG,UAAwB,EAAEC,cAA4B;EAC/E;EACA,MAAMC,YAAY,GAAiB;IACjC,GAAGF,UAAU;IACbG,UAAU,EAAEH,UAAU,CAACG,UAAU,CAAC9F,GAAG,CAAC+F,SAAS,KAAK;MAAC,GAAGA;IAAS,CAAC,CAAC;GACpE;EACD;EACA,KAAK,MAAMA,SAAS,IAAIH,cAAc,EAAEE,UAAU,IAAI,EAAE,EAAE;IACxD,MAAME,aAAa,GAAGH,YAAY,CAACC,UAAU,CAACjG,IAAI,CAACoG,IAAI,IAAIA,IAAI,CAACzG,IAAI,KAAKuG,SAAS,CAACvG,IAAI,CAAC;IACxF,IAAI,CAACwG,aAAa,EAAE;MAClBlJ,GAAG,CAACqD,IAAI,CAAC,2BAA2B4F,SAAS,CAACvG,IAAI,wBAAwB,CAAC;IAC7E,CAAC,MAAM;MACLwG,aAAa,CAAC5F,IAAI,GAAG2F,SAAS,CAAC3F,IAAI,IAAI4F,aAAa,CAAC5F,IAAI;MACzD4F,aAAa,CAACE,QAAQ,GAAGH,SAAS,CAACG,QAAQ,IAAIF,aAAa,CAACE,QAAQ;IACvE;EACF;EACA,OAAOL,YAAY;AACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}