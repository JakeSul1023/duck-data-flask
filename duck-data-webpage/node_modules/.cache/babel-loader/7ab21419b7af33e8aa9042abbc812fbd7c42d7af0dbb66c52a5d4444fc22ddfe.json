{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@deck.gl/core';\nimport { equals } from '@math.gl/core';\nimport MaskPass from \"./mask-pass.js\";\nimport { joinLayerBounds, getRenderBounds, makeViewport } from \"../utils/projection-utils.js\";\n// Class to manage mask effect\nexport default class MaskEffect {\n  constructor() {\n    this.id = 'mask-effect';\n    this.props = null;\n    this.useInPicking = true;\n    this.order = 0;\n    this.channels = [];\n    this.masks = null;\n  }\n  setup({\n    device\n  }) {\n    this.dummyMaskMap = device.createTexture({\n      width: 1,\n      height: 1\n    });\n    this.maskPass = new MaskPass(device, {\n      id: 'default-mask'\n    });\n    this.maskMap = this.maskPass.maskMap;\n  }\n  preRender({\n    layers,\n    layerFilter,\n    viewports,\n    onViewportActive,\n    views,\n    isPicking\n  }) {\n    let didRender = false;\n    if (isPicking) {\n      // Do not update on picking pass\n      return {\n        didRender\n      };\n    }\n    const maskLayers = layers.filter(l => l.props.visible && l.props.operation.includes('mask'));\n    if (maskLayers.length === 0) {\n      this.masks = null;\n      this.channels.length = 0;\n      return {\n        didRender\n      };\n    }\n    this.masks = {};\n    // Map layers to channels\n    const channelMap = this._sortMaskChannels(maskLayers);\n    // TODO - support multiple views\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n    if (viewport.resolution !== undefined) {\n      log.warn('MaskExtension is not supported in GlobeView')();\n      return {\n        didRender\n      };\n    }\n    for (const maskId in channelMap) {\n      const result = this._renderChannel(channelMap[maskId], {\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n      didRender || (didRender = result);\n    }\n    // debugFBO(this.maskMap, {opaque: true});\n    return {\n      didRender\n    };\n  }\n  /* eslint-disable-next-line complexity */\n  _renderChannel(channelInfo, {\n    layerFilter,\n    onViewportActive,\n    views,\n    viewport,\n    viewportChanged\n  }) {\n    let didRender = false;\n    const oldChannelInfo = this.channels[channelInfo.index];\n    if (!oldChannelInfo) {\n      return didRender;\n    }\n    const maskChanged =\n    // If a channel is new\n    channelInfo === oldChannelInfo ||\n    // If sublayers have changed\n    channelInfo.layers.length !== oldChannelInfo.layers.length || channelInfo.layers.some((layer, i) =>\n    // Layer instance is updated\n    // Layer props might have changed\n    // Undetermined props could have an effect on the output geometry of a mask layer,\n    // for example getRadius+updateTriggers, radiusScale, modelMatrix\n    layer !== oldChannelInfo.layers[i] ||\n    // Some prop is in transition\n    layer.props.transitions) ||\n    // If a sublayer's positions have been updated, the cached bounds will change shallowly\n    channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);\n    channelInfo.bounds = oldChannelInfo.bounds;\n    channelInfo.maskBounds = oldChannelInfo.maskBounds;\n    this.channels[channelInfo.index] = channelInfo;\n    if (maskChanged || viewportChanged) {\n      // Recalculate mask bounds\n      this.lastViewport = viewport;\n      const layerBounds = joinLayerBounds(channelInfo.layers, viewport);\n      channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);\n      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n        // Rerender mask FBO\n        const {\n          maskPass,\n          maskMap\n        } = this;\n        const maskViewport = layerBounds && makeViewport({\n          bounds: channelInfo.bounds,\n          viewport,\n          width: maskMap.width,\n          height: maskMap.height,\n          border: 1\n        });\n        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n        // @ts-ignore (2532) This method is only called from preRender where maskPass is defined\n        maskPass.render({\n          pass: 'mask',\n          channel: channelInfo.index,\n          layers: channelInfo.layers,\n          layerFilter,\n          viewports: maskViewport ? [maskViewport] : [],\n          onViewportActive,\n          views,\n          shaderModuleProps: {\n            project: {\n              devicePixelRatio: 1\n            }\n          }\n        });\n        didRender = true;\n      }\n    }\n    // @ts-ignore (2532) This method is only called from preRender where masks is defined\n    this.masks[channelInfo.id] = {\n      index: channelInfo.index,\n      bounds: channelInfo.maskBounds,\n      coordinateOrigin: channelInfo.coordinateOrigin,\n      coordinateSystem: channelInfo.coordinateSystem\n    };\n    return didRender;\n  }\n  /**\n   * Find a channel to render each mask into\n   * If a maskId already exists, diff and update the existing channel\n   * Otherwise replace a removed mask\n   * Otherwise create a new channel\n   * Returns a map from mask layer id to channel info\n   */\n  _sortMaskChannels(maskLayers) {\n    const channelMap = {};\n    let channelCount = 0;\n    for (const layer of maskLayers) {\n      const {\n        id\n      } = layer.root;\n      let channelInfo = channelMap[id];\n      if (!channelInfo) {\n        if (++channelCount > 4) {\n          log.warn('Too many mask layers. The max supported is 4')();\n          continue; // eslint-disable-line no-continue\n        }\n        channelInfo = {\n          id,\n          index: this.channels.findIndex(c => c?.id === id),\n          layers: [],\n          layerBounds: [],\n          coordinateOrigin: layer.root.props.coordinateOrigin,\n          coordinateSystem: layer.root.props.coordinateSystem\n        };\n        channelMap[id] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n    }\n    for (let i = 0; i < 4; i++) {\n      const channelInfo = this.channels[i];\n      if (!channelInfo || !(channelInfo.id in channelMap)) {\n        // The mask id at this channel no longer exists\n        this.channels[i] = null;\n      }\n    }\n    for (const maskId in channelMap) {\n      const channelInfo = channelMap[maskId];\n      if (channelInfo.index < 0) {\n        channelInfo.index = this.channels.findIndex(c => !c);\n        this.channels[channelInfo.index] = channelInfo;\n      }\n    }\n    return channelMap;\n  }\n  getShaderModuleProps() {\n    return {\n      mask: {\n        maskMap: this.masks ? this.maskMap : this.dummyMaskMap,\n        maskChannels: this.masks\n      }\n    };\n  }\n  cleanup() {\n    if (this.dummyMaskMap) {\n      this.dummyMaskMap.delete();\n      this.dummyMaskMap = undefined;\n    }\n    if (this.maskPass) {\n      this.maskPass.delete();\n      this.maskPass = undefined;\n      this.maskMap = undefined;\n    }\n    this.lastViewport = undefined;\n    this.masks = null;\n    this.channels.length = 0;\n  }\n}\n//# sourceMappingURL=mask-effect.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}