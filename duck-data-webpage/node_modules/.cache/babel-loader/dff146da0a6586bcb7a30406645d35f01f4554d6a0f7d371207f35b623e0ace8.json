{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport PickLayersPass from \"../passes/pick-layers-pass.js\";\nimport { getClosestObject, getUniqueObjects } from \"./picking/query-object.js\";\nimport { processPickInfo, getLayerPickingInfo, getEmptyPickingInfo } from \"./picking/pick-info.js\";\n/** Manages picking in a Deck context */\nexport default class DeckPicker {\n  constructor(device) {\n    this._pickable = true;\n    this.device = device;\n    this.pickLayersPass = new PickLayersPass(device);\n    this.lastPickedInfo = {\n      index: -1,\n      layerId: null,\n      info: null\n    };\n  }\n  setProps(props) {\n    if ('layerFilter' in props) {\n      this.layerFilter = props.layerFilter;\n    }\n    if ('_pickable' in props) {\n      this._pickable = props._pickable;\n    }\n  }\n  finalize() {\n    if (this.pickingFBO) {\n      this.pickingFBO.destroy();\n    }\n    if (this.depthFBO) {\n      this.depthFBO.destroy();\n    }\n  }\n  /** Pick the closest info at given coordinate */\n  pickObject(opts) {\n    return this._pickClosestObject(opts);\n  }\n  /** Get all unique infos within a bounding box */\n  pickObjects(opts) {\n    return this._pickVisibleObjects(opts);\n  }\n  // Returns a new picking info object by assuming the last picked object is still picked\n  getLastPickedObject({\n    x,\n    y,\n    layers,\n    viewports\n  }, lastPickedInfo = this.lastPickedInfo.info) {\n    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n    const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;\n    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;\n    const viewport = lastPickedViewportId && viewports.find(v => v.id === lastPickedViewportId) || viewports[0];\n    const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);\n    const info = {\n      x,\n      y,\n      viewport,\n      coordinate,\n      layer\n    };\n    return {\n      ...lastPickedInfo,\n      ...info\n    };\n  }\n  // Private\n  /** Ensures that picking framebuffer exists and matches the canvas size */\n  _resizeBuffer() {\n    // Create a frame buffer if not already available\n    if (!this.pickingFBO) {\n      this.pickingFBO = this.device.createFramebuffer({\n        colorAttachments: ['rgba8unorm'],\n        depthStencilAttachment: 'depth16unorm'\n      });\n      if (this.device.isTextureFormatRenderable('rgba32float')) {\n        const depthFBO = this.device.createFramebuffer({\n          colorAttachments: ['rgba32float'],\n          depthStencilAttachment: 'depth16unorm'\n        });\n        this.depthFBO = depthFBO;\n      }\n    }\n    // Resize it to current canvas size (this is a noop if size hasn't changed)\n    const {\n      canvas\n    } = this.device.getDefaultCanvasContext();\n    this.pickingFBO?.resize({\n      width: canvas.width,\n      height: canvas.height\n    });\n    this.depthFBO?.resize({\n      width: canvas.width,\n      height: canvas.height\n    });\n  }\n  /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */\n  _getPickable(layers) {\n    if (this._pickable === false) {\n      return null;\n    }\n    const pickableLayers = layers.filter(layer => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite);\n    return pickableLayers.length ? pickableLayers : null;\n  }\n  /** Pick the closest object at the given coordinate */\n  // eslint-disable-next-line max-statements,complexity\n  _pickClosestObject({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    radius = 0,\n    depth = 1,\n    mode = 'query',\n    unproject3D,\n    onViewportActive,\n    effects\n  }) {\n    // @ts-expect-error TODO - assuming WebGL context\n    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();\n    const pickableLayers = this._getPickable(layers);\n    if (!pickableLayers || viewports.length === 0) {\n      return {\n        result: [],\n        emptyInfo: getEmptyPickingInfo({\n          viewports,\n          x,\n          y,\n          pixelRatio\n        })\n      };\n    }\n    this._resizeBuffer();\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // Top-left coordinates [x, y] to bottom-left coordinates [deviceX, deviceY]\n    // And compensate for pixelRatio\n    // @ts-expect-error TODO - assuming WebGL context\n    const devicePixelRange = this.device.canvasContext.cssToDevicePixels([x, y], true);\n    const devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];\n    const deviceRadius = Math.round(radius * pixelRatio);\n    const {\n      width,\n      height\n    } = this.pickingFBO;\n    const deviceRect = this._getPickingRect({\n      deviceX: devicePixel[0],\n      deviceY: devicePixel[1],\n      deviceRadius,\n      deviceWidth: width,\n      deviceHeight: height\n    });\n    const cullRect = {\n      x: x - radius,\n      y: y - radius,\n      width: radius * 2 + 1,\n      height: radius * 2 + 1\n    };\n    let infos;\n    const result = [];\n    const affectedLayers = new Set();\n    for (let i = 0; i < depth; i++) {\n      let pickInfo;\n      if (deviceRect) {\n        const pickedResult = this._drawAndSample({\n          layers: pickableLayers,\n          views,\n          viewports,\n          onViewportActive,\n          deviceRect,\n          cullRect,\n          effects,\n          pass: `picking:${mode}`\n        });\n        pickInfo = getClosestObject({\n          ...pickedResult,\n          deviceX: devicePixel[0],\n          deviceY: devicePixel[1],\n          deviceRadius,\n          deviceRect\n        });\n      } else {\n        pickInfo = {\n          pickedColor: null,\n          pickedObjectIndex: -1\n        };\n      }\n      let z;\n      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n        const {\n          pickedColors: pickedColors2\n        } = this._drawAndSample({\n          layers: [pickInfo.pickedLayer],\n          views,\n          viewports,\n          onViewportActive,\n          deviceRect: {\n            x: pickInfo.pickedX,\n            y: pickInfo.pickedY,\n            width: 1,\n            height: 1\n          },\n          cullRect,\n          effects,\n          pass: `picking:${mode}:z`\n        }, true);\n        // picked value is in common space (pixels) from the camera target (viewport.position)\n        // convert it to meters from the ground\n        if (pickedColors2[3]) {\n          z = pickedColors2[0];\n        }\n      }\n      // Only exclude if we need to run picking again.\n      // We need to run picking again if an object is detected AND\n      // we have not exhausted the requested depth.\n      if (pickInfo.pickedLayer && i + 1 < depth) {\n        affectedLayers.add(pickInfo.pickedLayer);\n        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);\n      }\n      // This logic needs to run even if no object is picked.\n      infos = processPickInfo({\n        pickInfo,\n        lastPickedInfo: this.lastPickedInfo,\n        mode,\n        layers: pickableLayers,\n        viewports,\n        x,\n        y,\n        z,\n        pixelRatio\n      });\n      for (const info of infos.values()) {\n        if (info.layer) {\n          result.push(info);\n        }\n      }\n      // If no object is picked stop.\n      if (!pickInfo.pickedColor) {\n        break;\n      }\n    }\n    // reset only affected buffers\n    for (const layer of affectedLayers) {\n      layer.restorePickingColors();\n    }\n    return {\n      result,\n      emptyInfo: infos.get(null)\n    };\n  }\n  /** Pick all objects within the given bounding box */\n  _pickVisibleObjects({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    width = 1,\n    height = 1,\n    mode = 'query',\n    maxObjects = null,\n    onViewportActive,\n    effects\n  }) {\n    const pickableLayers = this._getPickable(layers);\n    if (!pickableLayers || viewports.length === 0) {\n      return [];\n    }\n    this._resizeBuffer();\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // And compensate for pixelRatio\n    // @ts-expect-error TODO - assuming WebGL context\n    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();\n    // @ts-expect-error TODO - assuming WebGL context\n    const leftTop = this.device.canvasContext.cssToDevicePixels([x, y], true);\n    // take left and top (y inverted in device pixels) from start location\n    const deviceLeft = leftTop.x;\n    const deviceTop = leftTop.y + leftTop.height;\n    // take right and bottom (y inverted in device pixels) from end location\n    // @ts-expect-error TODO - assuming WebGL context\n    const rightBottom = this.device.canvasContext.cssToDevicePixels([x + width, y + height], true);\n    const deviceRight = rightBottom.x + rightBottom.width;\n    const deviceBottom = rightBottom.y;\n    const deviceRect = {\n      x: deviceLeft,\n      y: deviceBottom,\n      // deviceTop and deviceRight represent the first pixel outside the desired rect\n      width: deviceRight - deviceLeft,\n      height: deviceTop - deviceBottom\n    };\n    const pickedResult = this._drawAndSample({\n      layers: pickableLayers,\n      views,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      cullRect: {\n        x,\n        y,\n        width,\n        height\n      },\n      effects,\n      pass: `picking:${mode}`\n    });\n    const pickInfos = getUniqueObjects(pickedResult);\n    // `getUniqueObjects` dedup by picked color\n    // However different picked color may be linked to the same picked object, e.g. stroke and fill of the same polygon\n    // picked from different sub layers of a GeoJsonLayer\n    // Here after resolving the picked index with `layer.getPickingInfo`, we need to dedup again by unique picked objects\n    const uniquePickedObjects = new Map();\n    const uniqueInfos = [];\n    const limitMaxObjects = Number.isFinite(maxObjects);\n    for (let i = 0; i < pickInfos.length; i++) {\n      if (limitMaxObjects && uniqueInfos.length >= maxObjects) {\n        break;\n      }\n      const pickInfo = pickInfos[i];\n      let info = {\n        color: pickInfo.pickedColor,\n        layer: null,\n        index: pickInfo.pickedObjectIndex,\n        picked: true,\n        x,\n        y,\n        pixelRatio\n      };\n      info = getLayerPickingInfo({\n        layer: pickInfo.pickedLayer,\n        info,\n        mode\n      });\n      // info.layer is always populated because it's a picked pixel\n      const pickedLayerId = info.layer.id;\n      if (!uniquePickedObjects.has(pickedLayerId)) {\n        uniquePickedObjects.set(pickedLayerId, new Set());\n      }\n      const uniqueObjectsInLayer = uniquePickedObjects.get(pickedLayerId);\n      // info.object may be null if the layer is using non-iterable data.\n      // Fall back to using index as identifier.\n      const pickedObjectKey = info.object ?? info.index;\n      if (!uniqueObjectsInLayer.has(pickedObjectKey)) {\n        uniqueObjectsInLayer.add(pickedObjectKey);\n        uniqueInfos.push(info);\n      }\n    }\n    return uniqueInfos;\n  }\n  _drawAndSample({\n    layers,\n    views,\n    viewports,\n    onViewportActive,\n    deviceRect,\n    cullRect,\n    effects,\n    pass\n  }, pickZ = false) {\n    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n    const opts = {\n      layers,\n      layerFilter: this.layerFilter,\n      views,\n      viewports,\n      onViewportActive,\n      pickingFBO,\n      deviceRect,\n      cullRect,\n      effects,\n      pass,\n      pickZ,\n      preRenderStats: {},\n      isPicking: true\n    };\n    for (const effect of effects) {\n      if (effect.useInPicking) {\n        opts.preRenderStats[effect.id] = effect.preRender(opts);\n      }\n    }\n    const {\n      decodePickingColor\n    } = this.pickLayersPass.render(opts);\n    // Read from an already rendered picking buffer\n    // Returns an Uint8ClampedArray of picked pixels\n    const {\n      x,\n      y,\n      width,\n      height\n    } = deviceRect;\n    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n    this.device.readPixelsToArrayWebGL(pickingFBO, {\n      sourceX: x,\n      sourceY: y,\n      sourceWidth: width,\n      sourceHeight: height,\n      target: pickedColors\n    });\n    return {\n      pickedColors,\n      decodePickingColor\n    };\n  }\n  // Calculate a picking rect centered on deviceX and deviceY and clipped to device\n  // Returns null if pixel is outside of device\n  _getPickingRect({\n    deviceX,\n    deviceY,\n    deviceRadius,\n    deviceWidth,\n    deviceHeight\n  }) {\n    // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]\n    const x = Math.max(0, deviceX - deviceRadius);\n    const y = Math.max(0, deviceY - deviceRadius);\n    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n    // x, y out of bounds.\n    if (width <= 0 || height <= 0) {\n      return null;\n    }\n    return {\n      x,\n      y,\n      width,\n      height\n    };\n  }\n}\n//# sourceMappingURL=deck-picker.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}