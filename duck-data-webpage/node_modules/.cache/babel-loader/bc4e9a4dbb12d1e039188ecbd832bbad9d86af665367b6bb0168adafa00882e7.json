{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Create a WebGL context for a canvas\n * Note calling this multiple time on the same canvas does return the same context\n * @param canvas A canvas element or offscreen canvas\n */\nexport function createBrowserContext(canvas, props, webglContextAttributes) {\n  // Try to extract any extra information about why context creation failed\n  let errorMessage = '';\n  // const onCreateError = error => (errorMessage = error.statusMessage || errorMessage);\n  // Avoid multiple listeners?\n  // canvas.removeEventListener('webglcontextcreationerror', onCreateError, false);\n  // canvas.addEventListener('webglcontextcreationerror', onCreateError, false);\n  const webglProps = {\n    preserveDrawingBuffer: true,\n    // failIfMajorPerformanceCaveat: true,\n    ...webglContextAttributes\n  };\n  // Create the desired context\n  let gl = null;\n  // Create a webgl2 context\n  gl ||= canvas.getContext('webgl2', webglProps);\n  if (webglProps.failIfMajorPerformanceCaveat) {\n    errorMessage ||= 'Only software GPU is available. Set `failIfMajorPerformanceCaveat: false` to allow.';\n  }\n  // Creation failed with failIfMajorPerformanceCaveat - Try a Software GPU\n  if (!gl && !webglContextAttributes.failIfMajorPerformanceCaveat) {\n    webglProps.failIfMajorPerformanceCaveat = false;\n    gl = canvas.getContext('webgl2', webglProps);\n    // @ts-expect-error\n    gl.luma ||= {};\n    // @ts-expect-error\n    gl.luma.softwareRenderer = true;\n  }\n  if (!gl) {\n    gl = canvas.getContext('webgl', {});\n    if (gl) {\n      gl = null;\n      errorMessage ||= 'Your browser only supports WebGL1';\n    }\n  }\n  if (!gl) {\n    errorMessage ||= 'Your browser does not support WebGL';\n    throw new Error(`Failed to create WebGL context: ${errorMessage}`);\n  }\n  // Carefully extract and wrap callbacks to prevent addEventListener from rebinding them.\n  const {\n    onContextLost,\n    onContextRestored\n  } = props;\n  canvas.addEventListener('webglcontextlost', event => onContextLost(event), false);\n  canvas.addEventListener('webglcontextrestored', event => onContextRestored(event), false);\n  // @ts-expect-error\n  gl.luma ||= {};\n  return gl;\n}\n/* TODO - can we call this asynchronously to catch the error events?\nexport async function createBrowserContextAsync(canvas: HTMLCanvasElement | OffscreenCanvas, props: ContextProps): Promise<WebGL2RenderingContext> {\n  props = {...DEFAULT_CONTEXT_PROPS, ...props};\n\n // Try to extract any extra information about why context creation failed\n let errorMessage = null;\n const onCreateError = (error) => (errorMessage = error.statusMessage || errorMessage);\n canvas.addEventListener('webglcontextcreationerror', onCreateError, false);\n\n const gl = createBrowserContext(canvas, props);\n\n // Give the listener a chance to fire\n await new Promise(resolve => setTimeout(resolve, 0));\n\n canvas.removeEventListener('webglcontextcreationerror', onCreateError, false);\n\n return gl;\n}\n*/\n//# sourceMappingURL=create-browser-context.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}