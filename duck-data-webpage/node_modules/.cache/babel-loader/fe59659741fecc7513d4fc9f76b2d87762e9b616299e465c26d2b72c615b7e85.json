{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { initializeShaderModule } from '@luma.gl/shadertools';\nimport { ShaderInputs } from \"../shader-inputs.js\";\nimport { ClipSpace } from \"../models/clip-space.js\";\nimport { SwapFramebuffers } from \"../compute/swap.js\";\nimport { BackgroundTextureModel } from \"../models/billboard-texture-model.js\";\nimport { getFragmentShaderForRenderPass } from \"./get-fragment-shader.js\";\n/** A pass that renders a given texture into screen space */\nexport class ShaderPassRenderer {\n  device;\n  shaderInputs;\n  passRenderers;\n  swapFramebuffers;\n  /** For rendering to the screen */\n  clipSpace;\n  textureModel;\n  constructor(device, props) {\n    this.device = device;\n    props.shaderPasses.map(shaderPass => initializeShaderModule(shaderPass));\n    const modules = props.shaderPasses.reduce((object, shaderPass) => ({\n      ...object,\n      [shaderPass.name]: shaderPass\n    }), {});\n    this.shaderInputs = props.shaderInputs || new ShaderInputs(modules);\n    const size = device.getCanvasContext().getPixelSize();\n    this.swapFramebuffers = new SwapFramebuffers(device, {\n      colorAttachments: ['rgba8unorm'],\n      width: size[0],\n      height: size[1]\n    });\n    this.textureModel = new BackgroundTextureModel(device, {\n      backgroundTexture: this.swapFramebuffers.current.colorAttachments[0].texture\n    });\n    this.clipSpace = new ClipSpace(device, {\n      source: /* wgsl */`\\\n  @group(0) @binding(0) var sourceTexture: texture_2d<f32>;\n  @group(0) @binding(1) var sourceTextureSampler: sampler;\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n\tlet texCoord: vec2<f32> = inputs.coordinate;\n\treturn textureSample(sourceTexture, sourceTextureSampler, texCoord);\n}\n`,\n      fs: /* glsl */`\\\n#version 300 es\n\nuniform sampler2D sourceTexture;\nin vec2 uv;\nin vec2 coordinate;\nout vec4 fragColor;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n  fragColor = texture(sourceTexture, coordinate);\n}\n`\n    });\n    this.passRenderers = props.shaderPasses.map(shaderPass => new PassRenderer(device, shaderPass));\n  }\n  /** Destroys resources created by this ShaderPassRenderer */\n  destroy() {\n    for (const subPassRenderer of this.passRenderers) {\n      subPassRenderer.destroy();\n    }\n    this.swapFramebuffers.destroy();\n    this.clipSpace.destroy();\n  }\n  resize(width, height) {\n    this.swapFramebuffers.resize({\n      width,\n      height\n    });\n    // this.props.passes.forEach(pass => pass.resize(width, height));\n  }\n  renderToScreen(options) {\n    // Run the shader passes and generate an output texture\n    const outputTexture = this.renderToTexture(options);\n    if (!outputTexture) {\n      // source texture not yet loaded\n      return false;\n    }\n    const renderPass = this.device.beginRenderPass({\n      clearColor: [0, 0, 0, 1],\n      clearDepth: 1\n    });\n    this.clipSpace.setBindings({\n      sourceTexture: outputTexture\n    });\n    this.clipSpace.draw(renderPass);\n    renderPass.end();\n    return true;\n  }\n  /** Runs the shaderPasses in sequence on the sourceTexture and returns a texture with the results.\n   * @returns null if the the sourceTexture has not yet been loaded\n   */\n  renderToTexture(options) {\n    const {\n      sourceTexture\n    } = options;\n    if (!sourceTexture.isReady) {\n      return null;\n    }\n    this.textureModel.destroy();\n    this.textureModel = new BackgroundTextureModel(this.device, {\n      backgroundTexture: sourceTexture\n    });\n    // Clear the current texture before we begin\n    const clearTexturePass = this.device.beginRenderPass({\n      framebuffer: this.swapFramebuffers.current,\n      clearColor: [0, 0, 0, 1]\n    });\n    this.textureModel.draw(clearTexturePass);\n    clearTexturePass.end();\n    // const commandEncoder = this.device.createCommandEncoder();\n    // commandEncoder.copyTextureToTexture({\n    //   sourceTexture: sourceTexture.texture,\n    //   destinationTexture: this.swapFramebuffers.current.colorAttachments[0].texture\n    // });\n    // commandEncoder.finish();\n    let first = true;\n    for (const passRenderer of this.passRenderers) {\n      for (const subPassRenderer of passRenderer.subPassRenderers) {\n        if (!first) {\n          this.swapFramebuffers.swap();\n        }\n        first = false;\n        const swapBufferTexture = this.swapFramebuffers.current.colorAttachments[0].texture;\n        const bindings = {\n          sourceTexture: swapBufferTexture\n          // texSize: [sourceTextures.width, sourceTextures.height]\n        };\n        const renderPass = this.device.beginRenderPass({\n          framebuffer: this.swapFramebuffers.next,\n          clearColor: [0, 0, 0, 1],\n          clearDepth: 1\n        });\n        subPassRenderer.render({\n          renderPass,\n          bindings\n        });\n        renderPass.end();\n      }\n    }\n    this.swapFramebuffers.swap();\n    const outputTexture = this.swapFramebuffers.current.colorAttachments[0].texture;\n    return outputTexture;\n  }\n}\n/** renders one ShaderPass */\nclass PassRenderer {\n  shaderPass;\n  subPassRenderers;\n  constructor(device, shaderPass) {\n    let props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.shaderPass = shaderPass;\n    // const id = `${shaderPass.name}-pass`;\n    const subPasses = shaderPass.passes || [];\n    // normalizePasses(gl, module, id, props);\n    this.subPassRenderers = subPasses.map(subPass => {\n      // const idn = `${id}-${subPasses.length + 1}`;\n      return new SubPassRenderer(device, shaderPass, subPass);\n    });\n  }\n  destroy() {\n    for (const subPassRenderer of this.subPassRenderers) {\n      subPassRenderer.destroy();\n    }\n  }\n}\n/** Renders one subpass of a ShaderPass */\nclass SubPassRenderer {\n  model;\n  shaderPass;\n  subPass;\n  constructor(device, shaderPass, subPass) {\n    this.shaderPass = shaderPass;\n    this.subPass = subPass;\n    const action = subPass.action || subPass.filter && 'filter' || subPass.sampler && 'sample' || 'filter';\n    const fs = getFragmentShaderForRenderPass({\n      shaderPass,\n      action,\n      shadingLanguage: device.info.shadingLanguage\n    });\n    this.model = new ClipSpace(device, {\n      id: `${shaderPass.name}-subpass`,\n      source: fs,\n      fs,\n      modules: [shaderPass],\n      parameters: {\n        depthWriteEnabled: false,\n        depthCompare: 'always'\n      }\n    });\n  }\n  destroy() {\n    this.model.destroy();\n  }\n  render(options) {\n    const {\n      renderPass,\n      bindings\n    } = options;\n    this.model.shaderInputs.setProps({\n      [this.shaderPass.name]: this.shaderPass.uniforms || {}\n    });\n    this.model.shaderInputs.setProps({\n      [this.shaderPass.name]: this.subPass.uniforms || {}\n    });\n    // this.model.setBindings(this.subPass.bindings || {});\n    this.model.setBindings(bindings || {});\n    this.model.draw(renderPass);\n  }\n}\n//# sourceMappingURL=shader-pass-renderer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}