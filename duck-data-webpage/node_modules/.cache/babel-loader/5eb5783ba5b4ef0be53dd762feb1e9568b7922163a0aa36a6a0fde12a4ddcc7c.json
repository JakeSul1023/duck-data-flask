{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport * as React from 'react';\nimport { createElement, useRef, useState, useMemo, useEffect, useImperativeHandle } from 'react';\nimport { Deck } from '@deck.gl/core';\nimport useIsomorphicLayoutEffect from \"./utils/use-isomorphic-layout-effect.js\";\nimport extractJSXLayers from \"./utils/extract-jsx-layers.js\";\nimport positionChildrenUnderViews from \"./utils/position-children-under-views.js\";\nimport extractStyles from \"./utils/extract-styles.js\";\nfunction getRefHandles(thisRef) {\n  return {\n    get deck() {\n      return thisRef.deck;\n    },\n    // The following method can only be called after ref is available, by which point deck is defined in useEffect\n    pickObject: opts => thisRef.deck.pickObject(opts),\n    pickMultipleObjects: opts => thisRef.deck.pickMultipleObjects(opts),\n    pickObjects: opts => thisRef.deck.pickObjects(opts)\n  };\n}\nfunction redrawDeck(thisRef) {\n  if (thisRef.redrawReason) {\n    // Only redraw if we have received a dirty flag\n    // @ts-expect-error accessing protected method\n    thisRef.deck._drawLayers(thisRef.redrawReason);\n    thisRef.redrawReason = null;\n  }\n}\nfunction createDeckInstance(thisRef, DeckClass, props) {\n  const deck = new DeckClass({\n    ...props,\n    // The Deck's animation loop is independent from React's render cycle, causing potential\n    // synchronization issues. We provide this custom render function to make sure that React\n    // and Deck update on the same schedule.\n    // TODO(ibgreen) - Hack to enable WebGPU as it needs to render quickly to avoid CanvasContext texture from going stale\n    _customRender: props.deviceProps?.adapters?.[0]?.type === 'webgpu' ? undefined : redrawReason => {\n      // Save the dirty flag for later\n      thisRef.redrawReason = redrawReason;\n      // Viewport/view state is passed to child components as props.\n      // If they have changed, we need to trigger a React rerender to update children props.\n      const viewports = deck.getViewports();\n      if (thisRef.lastRenderedViewports !== viewports) {\n        // Viewports have changed, update children props first.\n        // This will delay the Deck canvas redraw till after React update (in useLayoutEffect)\n        // so that the canvas does not get rendered before the child components update.\n        thisRef.forceUpdate();\n      } else {\n        redrawDeck(thisRef);\n      }\n    }\n  });\n  return deck;\n}\nfunction DeckGLWithRef(props, ref) {\n  // A mechanism to force redraw\n  const [version, setVersion] = useState(0);\n  // A reference to persistent states\n  const _thisRef = useRef({\n    control: null,\n    version,\n    forceUpdate: () => setVersion(v => v + 1)\n  });\n  const thisRef = _thisRef.current;\n  // DOM refs\n  const containerRef = useRef(null);\n  const canvasRef = useRef(null);\n  // extract any deck.gl layers masquerading as react elements from props.children\n  const jsxProps = useMemo(() => extractJSXLayers(props), [props.layers, props.views, props.children]);\n  // Callbacks\n  let inRender = true;\n  const handleViewStateChange = params => {\n    if (inRender && props.viewState) {\n      // Callback may invoke a state update. Defer callback to after render() to avoid React error\n      // In React StrictMode, render is executed twice and useEffect/useLayoutEffect is executed once\n      // Store deferred parameters in ref so that we can access it in another render\n      thisRef.viewStateUpdateRequested = params;\n      return null;\n    }\n    thisRef.viewStateUpdateRequested = null;\n    return props.onViewStateChange?.(params);\n  };\n  const handleInteractionStateChange = params => {\n    if (inRender) {\n      // Callback may invoke a state update. Defer callback to after render() to avoid React error\n      // In React StrictMode, render is executed twice and useEffect/useLayoutEffect is executed once\n      // Store deferred parameters in ref so that we can access it in another render\n      thisRef.interactionStateUpdateRequested = params;\n    } else {\n      thisRef.interactionStateUpdateRequested = null;\n      props.onInteractionStateChange?.(params);\n    }\n  };\n  // Update Deck's props. If Deck needs redraw, this will trigger a call to `_customRender` in\n  // the next animation frame.\n  // Needs to be called both from initial mount, and when new props are received\n  const deckProps = useMemo(() => {\n    const forwardProps = {\n      widgets: [],\n      ...props,\n      // Override user styling props. We will set the canvas style in render()\n      style: null,\n      width: '100%',\n      height: '100%',\n      parent: containerRef.current,\n      canvas: canvasRef.current,\n      layers: jsxProps.layers,\n      views: jsxProps.views,\n      onViewStateChange: handleViewStateChange,\n      onInteractionStateChange: handleInteractionStateChange\n    };\n    // The defaultValue for _customRender is null, which would overwrite the definition\n    // of _customRender. Remove to avoid frequently redeclaring the method here.\n    delete forwardProps._customRender;\n    if (thisRef.deck) {\n      thisRef.deck.setProps(forwardProps);\n    }\n    return forwardProps;\n  }, [props]);\n  useEffect(() => {\n    const DeckClass = props.Deck || Deck;\n    thisRef.deck = createDeckInstance(thisRef, DeckClass, {\n      ...deckProps,\n      parent: containerRef.current,\n      canvas: canvasRef.current\n    });\n    return () => thisRef.deck?.finalize();\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    // render has just been called. The children are positioned based on the current view state.\n    // Redraw Deck canvas immediately, if necessary, using the current view state, so that it\n    // matches the child components.\n    redrawDeck(thisRef);\n    // Execute deferred callbacks\n    const {\n      viewStateUpdateRequested,\n      interactionStateUpdateRequested\n    } = thisRef;\n    if (viewStateUpdateRequested) {\n      handleViewStateChange(viewStateUpdateRequested);\n    }\n    if (interactionStateUpdateRequested) {\n      handleInteractionStateChange(interactionStateUpdateRequested);\n    }\n  });\n  useImperativeHandle(ref, () => getRefHandles(thisRef), []);\n  const currentViewports = thisRef.deck && thisRef.deck.isInitialized ? thisRef.deck.getViewports() : undefined;\n  const {\n    ContextProvider,\n    width = '100%',\n    height = '100%',\n    id,\n    style\n  } = props;\n  const {\n    containerStyle,\n    canvasStyle\n  } = useMemo(() => extractStyles({\n    width,\n    height,\n    style\n  }), [width, height, style]);\n  // Props changes may lead to 3 types of updates:\n  // 1. Only the WebGL canvas - updated in Deck's render cycle (next animation frame)\n  // 2. Only the DOM - updated in React's lifecycle (now)\n  // 3. Both the WebGL canvas and the DOM - defer React rerender to next animation frame just\n  //    before Deck redraw to ensure perfect synchronization & avoid excessive redraw\n  //    This is because multiple changes may happen to Deck between two frames e.g. transition\n  if (!thisRef.viewStateUpdateRequested && thisRef.lastRenderedViewports === currentViewports ||\n  // case 2\n  thisRef.version !== version // case 3 just before deck redraws\n  ) {\n    thisRef.lastRenderedViewports = currentViewports;\n    thisRef.version = version;\n    // Render the background elements (typically react-map-gl instances)\n    // using the view descriptors\n    const childrenUnderViews = positionChildrenUnderViews({\n      children: jsxProps.children,\n      deck: thisRef.deck,\n      ContextProvider\n    });\n    const canvas = createElement('canvas', {\n      key: 'canvas',\n      id: id || 'deckgl-overlay',\n      ref: canvasRef,\n      style: canvasStyle\n    });\n    // Render deck.gl as the last child\n    thisRef.control = createElement('div', {\n      id: `${id || 'deckgl'}-wrapper`,\n      ref: containerRef,\n      style: containerStyle\n    }, [canvas, childrenUnderViews]);\n  }\n  inRender = false;\n  return thisRef.control;\n}\nconst DeckGL = React.forwardRef(DeckGLWithRef);\nexport default DeckGL;\n//# sourceMappingURL=deckgl.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}