{"ast":null,"code":"import { InputEvent } from \"../input/input-consts.js\";\nimport { Input } from \"../input/input.js\";\nconst POINTER_INPUT_MAP = {\n  pointerdown: InputEvent.Start,\n  pointermove: InputEvent.Move,\n  pointerup: InputEvent.End,\n  pointercancel: InputEvent.Cancel,\n  pointerout: InputEvent.Cancel\n};\nconst POINTER_ELEMENT_EVENTS = 'pointerdown';\nconst POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n/**\n * Pointer events input\n */\nexport class PointerEventInput extends Input {\n  constructor(manager) {\n    super(manager);\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n    this.store = this.manager.session.pointerEvents = [];\n    this.init();\n  }\n  /**\n   * handle mouse events\n   */\n  handler(ev) {\n    const {\n      store\n    } = this;\n    let removePointer = false;\n    // @ts-ignore\n    const eventType = POINTER_INPUT_MAP[ev.type];\n    const pointerType = ev.pointerType;\n    const isTouch = pointerType === 'touch';\n    // get index of the event in the store\n    let storeIndex = store.findIndex(e => e.pointerId === ev.pointerId);\n    // start and mouse must be down\n    if (eventType & InputEvent.Start && (ev.buttons || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (InputEvent.End | InputEvent.Cancel)) {\n      removePointer = true;\n    }\n    // it not found, so the pointer hasn't been down (so it's probably a hover)\n    if (storeIndex < 0) {\n      return;\n    }\n    // update the event in the store\n    store[storeIndex] = ev;\n    this.callback(eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      eventType,\n      pointerType,\n      srcEvent: ev\n    });\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  }\n}","map":{"version":3,"names":["InputEvent","Input","POINTER_INPUT_MAP","pointerdown","Start","pointermove","Move","pointerup","End","pointercancel","Cancel","pointerout","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","PointerEventInput","constructor","manager","evEl","evWin","store","session","pointerEvents","init","handler","ev","removePointer","eventType","type","pointerType","isTouch","storeIndex","findIndex","e","pointerId","buttons","push","length","callback","pointers","changedPointers","srcEvent","splice"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\mjolnir.js\\src\\hammerjs\\inputs\\pointerevent.ts"],"sourcesContent":["import {InputEvent} from '../input/input-consts';\nimport {Input} from '../input/input';\nimport type {Manager} from '../manager';\n\nconst POINTER_INPUT_MAP = {\n  pointerdown: InputEvent.Start,\n  pointermove: InputEvent.Move,\n  pointerup: InputEvent.End,\n  pointercancel: InputEvent.Cancel,\n  pointerout: InputEvent.Cancel\n} as const;\n\nconst POINTER_ELEMENT_EVENTS = 'pointerdown';\nconst POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n/**\n * Pointer events input\n */\nexport class PointerEventInput extends Input {\n  store: PointerEvent[];\n\n  constructor(manager: Manager) {\n    super(manager);\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    this.store = this.manager.session.pointerEvents = [];\n    this.init();\n  }\n\n  /**\n   * handle mouse events\n   */\n  handler(ev: PointerEvent) {\n    const {store} = this;\n    let removePointer = false;\n\n    // @ts-ignore\n    const eventType = POINTER_INPUT_MAP[ev.type];\n    const pointerType = ev.pointerType;\n\n    const isTouch = pointerType === 'touch';\n\n    // get index of the event in the store\n    let storeIndex = store.findIndex((e) => e.pointerId === ev.pointerId);\n\n    // start and mouse must be down\n    if (eventType & InputEvent.Start && (ev.buttons || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (InputEvent.End | InputEvent.Cancel)) {\n      removePointer = true;\n    }\n\n    // it not found, so the pointer hasn't been down (so it's probably a hover)\n    if (storeIndex < 0) {\n      return;\n    }\n\n    // update the event in the store\n    store[storeIndex] = ev;\n\n    this.callback(eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      eventType,\n      pointerType,\n      srcEvent: ev\n    });\n\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  }\n}\n"],"mappings":"AAAA,SAAQA,UAAU,QAAC;AACnB,SAAQC,KAAK,QAAC;AAGd,MAAMC,iBAAiB,GAAG;EACxBC,WAAW,EAAEH,UAAU,CAACI,KAAK;EAC7BC,WAAW,EAAEL,UAAU,CAACM,IAAI;EAC5BC,SAAS,EAAEP,UAAU,CAACQ,GAAG;EACzBC,aAAa,EAAET,UAAU,CAACU,MAAM;EAChCC,UAAU,EAAEX,UAAU,CAACU;CACf;AAEV,MAAME,sBAAsB,GAAG,aAAa;AAC5C,MAAMC,qBAAqB,GAAG,qCAAqC;AAEnE;;;AAGA,OAAM,MAAOC,iBAAkB,SAAQb,KAAK;EAG1Cc,YAAYC,OAAgB;IAC1B,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAACC,IAAI,GAAGL,sBAAsB;IAClC,IAAI,CAACM,KAAK,GAAGL,qBAAqB;IAElC,IAAI,CAACM,KAAK,GAAG,IAAI,CAACH,OAAO,CAACI,OAAO,CAACC,aAAa,GAAG,EAAE;IACpD,IAAI,CAACC,IAAI,EAAE;EACb;EAEA;;;EAGAC,OAAOA,CAACC,EAAgB;IACtB,MAAM;MAACL;IAAK,CAAC,GAAG,IAAI;IACpB,IAAIM,aAAa,GAAG,KAAK;IAEzB;IACA,MAAMC,SAAS,GAAGxB,iBAAiB,CAACsB,EAAE,CAACG,IAAI,CAAC;IAC5C,MAAMC,WAAW,GAAGJ,EAAE,CAACI,WAAW;IAElC,MAAMC,OAAO,GAAGD,WAAW,KAAK,OAAO;IAEvC;IACA,IAAIE,UAAU,GAAGX,KAAK,CAACY,SAAS,CAAEC,CAAC,IAAKA,CAAC,CAACC,SAAS,KAAKT,EAAE,CAACS,SAAS,CAAC;IAErE;IACA,IAAIP,SAAS,GAAG1B,UAAU,CAACI,KAAK,KAAKoB,EAAE,CAACU,OAAO,IAAIL,OAAO,CAAC,EAAE;MAC3D,IAAIC,UAAU,GAAG,CAAC,EAAE;QAClBX,KAAK,CAACgB,IAAI,CAACX,EAAE,CAAC;QACdM,UAAU,GAAGX,KAAK,CAACiB,MAAM,GAAG,CAAC;MAC/B;IACF,CAAC,MAAM,IAAIV,SAAS,IAAI1B,UAAU,CAACQ,GAAG,GAAGR,UAAU,CAACU,MAAM,CAAC,EAAE;MAC3De,aAAa,GAAG,IAAI;IACtB;IAEA;IACA,IAAIK,UAAU,GAAG,CAAC,EAAE;MAClB;IACF;IAEA;IACAX,KAAK,CAACW,UAAU,CAAC,GAAGN,EAAE;IAEtB,IAAI,CAACa,QAAQ,CAACX,SAAS,EAAE;MACvBY,QAAQ,EAAEnB,KAAK;MACfoB,eAAe,EAAE,CAACf,EAAE,CAAC;MACrBE,SAAS;MACTE,WAAW;MACXY,QAAQ,EAAEhB;KACX,CAAC;IAEF,IAAIC,aAAa,EAAE;MACjB;MACAN,KAAK,CAACsB,MAAM,CAACX,UAAU,EAAE,CAAC,CAAC;IAC7B;EACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}