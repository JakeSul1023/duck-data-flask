{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Shader } from '@luma.gl/core';\n/** Manages a cached pool of Shaders for reuse. */\nexport class ShaderFactory {\n  static defaultProps = {\n    ...Shader.defaultProps\n  };\n  /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */\n  static getDefaultShaderFactory(device) {\n    device._lumaData.defaultShaderFactory ||= new ShaderFactory(device);\n    return device._lumaData.defaultShaderFactory;\n  }\n  device;\n  destroyPolicy;\n  _cache = {};\n  /** @internal */\n  constructor(device) {\n    this.device = device;\n    this.destroyPolicy = device.props._factoryDestroyPolicy;\n  }\n  /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */\n  createShader(props) {\n    const key = this._hashShader(props);\n    let cacheEntry = this._cache[key];\n    if (!cacheEntry) {\n      const shader = this.device.createShader({\n        ...props,\n        id: props.id ? `${props.id}-cached` : undefined\n      });\n      this._cache[key] = cacheEntry = {\n        shader,\n        useCount: 0\n      };\n    }\n    cacheEntry.useCount++;\n    return cacheEntry.shader;\n  }\n  /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */\n  release(shader) {\n    const key = this._hashShader(shader);\n    const cacheEntry = this._cache[key];\n    if (cacheEntry) {\n      cacheEntry.useCount--;\n      if (cacheEntry.useCount === 0) {\n        if (this.destroyPolicy === 'unused') {\n          delete this._cache[key];\n          cacheEntry.shader.destroy();\n        }\n      }\n    }\n  }\n  // PRIVATE\n  _hashShader(value) {\n    return `${value.stage}:${value.source}`;\n  }\n}\n//# sourceMappingURL=shader-factory.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}