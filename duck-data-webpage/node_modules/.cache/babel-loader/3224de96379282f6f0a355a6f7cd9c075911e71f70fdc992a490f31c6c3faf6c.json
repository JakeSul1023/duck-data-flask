{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBrowser, isFileProvider, FileHandleFile } from '@loaders.gl/loader-utils';\nimport { makeZipCDHeaderIterator } from \"../parse-zip/cd-file-header.js\";\nimport { parseZipLocalFileHeader } from \"../parse-zip/local-file-header.js\";\nimport { DeflateCompression } from '@loaders.gl/compression';\nimport { IndexedArchive } from \"./IndexedArchive.js\";\n/** Handling different compression types in zip */\nexport const ZIP_COMPRESSION_HANDLERS = {\n  /** No compression */\n  0: async compressedFile => compressedFile,\n  /** Deflation */\n  8: async compressedFile => {\n    const compression = new DeflateCompression({\n      raw: true\n    });\n    const decompressedData = await compression.decompress(compressedFile);\n    return decompressedData;\n  }\n};\n/**\n * FileSystem adapter for a ZIP file\n * Holds FileProvider object that provides random access to archived files\n */\nexport class ZipFileSystem {\n  /** FileProvider instance promise */\n  fileProvider = null;\n  fileName;\n  archive = null;\n  /**\n   * Constructor\n   * @param file - instance of FileProvider or file path string\n   */\n  constructor(file) {\n    // Try to open file in NodeJS\n    if (typeof file === 'string') {\n      this.fileName = file;\n      if (!isBrowser) {\n        this.fileProvider = new FileHandleFile(file);\n      } else {\n        throw new Error('Cannot open file for random access in a WEB browser');\n      }\n    } else if (file instanceof IndexedArchive) {\n      this.fileProvider = file.fileProvider;\n      this.archive = file;\n      this.fileName = file.fileName;\n    } else if (isFileProvider(file)) {\n      this.fileProvider = file;\n    }\n  }\n  /** Clean up resources */\n  async destroy() {\n    if (this.fileProvider) {\n      await this.fileProvider.destroy();\n    }\n  }\n  /**\n   * Get file names list from zip archive\n   * @returns array of file names\n   */\n  async readdir() {\n    if (!this.fileProvider) {\n      throw new Error('No data detected in the zip archive');\n    }\n    const fileNames = [];\n    const zipCDIterator = makeZipCDHeaderIterator(this.fileProvider);\n    for await (const cdHeader of zipCDIterator) {\n      fileNames.push(cdHeader.fileName);\n    }\n    return fileNames;\n  }\n  /**\n   * Get file metadata\n   * @param filename - name of a file\n   * @returns central directory data\n   */\n  async stat(filename) {\n    const cdFileHeader = await this.getCDFileHeader(filename);\n    return {\n      ...cdFileHeader,\n      size: Number(cdFileHeader.uncompressedSize)\n    };\n  }\n  /**\n   * Implementation of fetch against this file system\n   * @param filename - name of a file\n   * @returns - Response with file data\n   */\n  async fetch(filename) {\n    if (this.fileName && filename.indexOf(this.fileName) === 0) {\n      filename = filename.substring(this.fileName.length + 1);\n    }\n    let uncompressedFile;\n    if (this.archive) {\n      uncompressedFile = await this.archive.getFile(filename, 'http');\n    } else {\n      if (!this.fileProvider) {\n        throw new Error('No data detected in the zip archive');\n      }\n      const cdFileHeader = await this.getCDFileHeader(filename);\n      const localFileHeader = await parseZipLocalFileHeader(cdFileHeader.localHeaderOffset, this.fileProvider);\n      if (!localFileHeader) {\n        throw new Error('Local file header has not been found in the zip archive`');\n      }\n      const compressionHandler = ZIP_COMPRESSION_HANDLERS[localFileHeader.compressionMethod.toString()];\n      if (!compressionHandler) {\n        throw Error('Only Deflation compression is supported');\n      }\n      const compressedFile = await this.fileProvider.slice(localFileHeader.fileDataOffset, localFileHeader.fileDataOffset + localFileHeader.compressedSize);\n      uncompressedFile = await compressionHandler(compressedFile);\n    }\n    const response = new Response(uncompressedFile);\n    Object.defineProperty(response, 'url', {\n      value: filename ? `${this.fileName || ''}/${filename}` : this.fileName || ''\n    });\n    return response;\n  }\n  /**\n   * Get central directory file header\n   * @param filename - name of a file\n   * @returns central directory file header\n   */\n  async getCDFileHeader(filename) {\n    if (!this.fileProvider) {\n      throw new Error('No data detected in the zip archive');\n    }\n    const zipCDIterator = makeZipCDHeaderIterator(this.fileProvider);\n    let result = null;\n    for await (const cdHeader of zipCDIterator) {\n      if (cdHeader.fileName === filename) {\n        result = cdHeader;\n        break;\n      }\n    }\n    if (!result) {\n      throw new Error('File has not been found in the zip archive');\n    }\n    return result;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}