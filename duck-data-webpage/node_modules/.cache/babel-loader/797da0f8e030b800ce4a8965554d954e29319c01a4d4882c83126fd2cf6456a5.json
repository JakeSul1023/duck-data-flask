{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { parsePBRMaterial } from '@luma.gl/gltf';\nimport { pbrMaterial } from '@luma.gl/shadertools';\nimport { Model } from '@luma.gl/engine';\nimport { SimpleMeshLayer } from '@deck.gl/mesh-layers';\nimport { meshUniforms } from \"./mesh-layer-uniforms.js\";\nimport vs from \"./mesh-layer-vertex.glsl.js\";\nimport fs from \"./mesh-layer-fragment.glsl.js\";\nfunction validateGeometryAttributes(attributes) {\n  const positionAttribute = attributes.positions || attributes.POSITION;\n  const vertexCount = positionAttribute.value.length / positionAttribute.size;\n  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;\n  if (!hasColorAttribute) {\n    attributes.colors = {\n      size: 4,\n      value: new Uint8Array(vertexCount * 4).fill(255),\n      normalized: true\n    };\n  }\n}\nconst defaultProps = {\n  pbrMaterial: {\n    type: 'object',\n    value: null\n  },\n  featureIds: {\n    type: 'array',\n    value: null,\n    optional: true\n  }\n};\nclass MeshLayer extends SimpleMeshLayer {\n  getShaders() {\n    const shaders = super.getShaders();\n    const modules = shaders.modules;\n    modules.push(pbrMaterial, meshUniforms);\n    return {\n      ...shaders,\n      vs,\n      fs\n    };\n  }\n  initializeState() {\n    const {\n      featureIds\n    } = this.props;\n    super.initializeState();\n    const attributeManager = this.getAttributeManager();\n    if (featureIds) {\n      // attributeManager is always defined in a primitive layer\n      attributeManager.add({\n        featureIdsPickingColors: {\n          type: 'uint8',\n          size: 3,\n          noAlloc: true,\n          // eslint-disable-next-line @typescript-eslint/unbound-method\n          update: this.calculateFeatureIdsPickingColors\n        }\n      });\n    }\n  }\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps\n    } = params;\n    if (props.pbrMaterial !== oldProps.pbrMaterial) {\n      this.updatePbrMaterialUniforms(props.pbrMaterial);\n    }\n  }\n  draw(opts) {\n    const {\n      featureIds\n    } = this.props;\n    const {\n      model\n    } = this.state;\n    if (!model) {\n      return;\n    }\n    const meshProps = {\n      pickFeatureIds: Boolean(featureIds)\n    };\n    const pbrProjectionProps = {\n      // Needed for PBR (TODO: find better way to get it)\n      camera: model.uniforms.cameraPosition\n    };\n    model.shaderInputs.setProps({\n      pbrProjection: pbrProjectionProps,\n      mesh: meshProps\n    });\n    super.draw(opts);\n  }\n  getModel(mesh) {\n    const {\n      id\n    } = this.props;\n    const parsedPBRMaterial = this.parseMaterial(this.props.pbrMaterial, mesh);\n    // Keep material to explicitly remove textures\n    this.setState({\n      parsedPBRMaterial\n    });\n    const shaders = this.getShaders();\n    validateGeometryAttributes(mesh.attributes);\n    const model = new Model(this.context.device, {\n      ...this.getShaders(),\n      id,\n      geometry: mesh,\n      bufferLayout: this.getAttributeManager().getBufferLayouts(),\n      defines: {\n        ...shaders.defines,\n        ...parsedPBRMaterial?.defines,\n        HAS_UV_REGIONS: mesh.attributes.uvRegions ? 1 : 0\n      },\n      parameters: parsedPBRMaterial?.parameters,\n      isInstanced: true\n    });\n    return model;\n  }\n  updatePbrMaterialUniforms(material) {\n    const {\n      model\n    } = this.state;\n    if (model) {\n      const {\n        mesh\n      } = this.props;\n      const parsedPBRMaterial = this.parseMaterial(material, mesh);\n      // Keep material to explicitly remove textures\n      this.setState({\n        parsedPBRMaterial\n      });\n      const {\n        pbr_baseColorSampler\n      } = parsedPBRMaterial.bindings;\n      const {\n        emptyTexture\n      } = this.state;\n      const simpleMeshProps = {\n        sampler: pbr_baseColorSampler || emptyTexture,\n        hasTexture: Boolean(pbr_baseColorSampler)\n      };\n      const {\n        camera,\n        ...pbrMaterialProps\n      } = {\n        ...parsedPBRMaterial.bindings,\n        ...parsedPBRMaterial.uniforms\n      };\n      model.shaderInputs.setProps({\n        simpleMesh: simpleMeshProps,\n        pbrMaterial: pbrMaterialProps\n      });\n    }\n  }\n  parseMaterial(material, mesh) {\n    const unlit = Boolean(material.pbrMetallicRoughness && material.pbrMetallicRoughness.baseColorTexture);\n    return parsePBRMaterial(this.context.device, {\n      unlit,\n      ...material\n    }, {\n      NORMAL: mesh.attributes.normals,\n      TEXCOORD_0: mesh.attributes.texCoords\n    }, {\n      pbrDebug: false,\n      lights: true,\n      useTangents: false\n    });\n  }\n  calculateFeatureIdsPickingColors(attribute) {\n    // This updater is only called if featureIds is not null\n    const featureIds = this.props.featureIds;\n    const value = new Uint8ClampedArray(featureIds.length * attribute.size);\n    const pickingColor = [];\n    for (let index = 0; index < featureIds.length; index++) {\n      this.encodePickingColor(featureIds[index], pickingColor);\n      value[index * 3] = pickingColor[0];\n      value[index * 3 + 1] = pickingColor[1];\n      value[index * 3 + 2] = pickingColor[2];\n    }\n    attribute.value = value;\n  }\n  finalizeState(context) {\n    super.finalizeState(context);\n    this.state.parsedPBRMaterial?.generatedTextures.forEach(texture => texture.destroy());\n    this.setState({\n      parsedPBRMaterial: null\n    });\n  }\n}\nMeshLayer.layerName = 'MeshLayer';\nMeshLayer.defaultProps = defaultProps;\nexport default MeshLayer;\n//# sourceMappingURL=mesh-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}