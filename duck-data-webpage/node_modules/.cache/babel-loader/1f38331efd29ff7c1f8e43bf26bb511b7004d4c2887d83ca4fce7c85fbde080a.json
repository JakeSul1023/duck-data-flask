{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getShaderModuleDependencies } from \"../shader-module/shader-module-dependencies.js\";\nimport { getPlatformShaderDefines } from \"./platform-defines.js\";\nimport { injectShader, DECLARATION_INJECT_MARKER } from \"./shader-injections.js\";\nimport { transpileGLSLShader } from \"../shader-transpiler/transpile-glsl-shader.js\";\nimport { checkShaderModuleDeprecations } from \"../shader-module/shader-module.js\";\nimport { normalizeShaderHooks, getShaderHooks } from \"./shader-hooks.js\";\nimport { assert } from \"../utils/assert.js\";\nimport { getShaderInfo } from \"../glsl-utils/get-shader-info.js\";\nconst INJECT_SHADER_DECLARATIONS = `\\n\\n${DECLARATION_INJECT_MARKER}\\n`;\n/**\n * Precision prologue to inject before functions are injected in shader\n * TODO - extract any existing prologue in the fragment source and move it up...\n */\nconst FRAGMENT_SHADER_PROLOGUE = /* glsl */`\\\nprecision highp float;\n`;\n/**\n * Inject a list of shader modules into a single shader source for WGSL\n */\nexport function assembleWGSLShader(options) {\n  const modules = getShaderModuleDependencies(options.modules || []);\n  return {\n    source: assembleShaderWGSL(options.platformInfo, {\n      ...options,\n      source: options.source,\n      stage: 'vertex',\n      modules\n    }),\n    getUniforms: assembleGetUniforms(modules)\n  };\n}\n/**\n * Injects dependent shader module sources into pair of main vertex/fragment shader sources for GLSL\n */\nexport function assembleGLSLShaderPair(options) {\n  const {\n    vs,\n    fs\n  } = options;\n  const modules = getShaderModuleDependencies(options.modules || []);\n  return {\n    vs: assembleShaderGLSL(options.platformInfo, {\n      ...options,\n      source: vs,\n      stage: 'vertex',\n      modules\n    }),\n    fs: assembleShaderGLSL(options.platformInfo, {\n      ...options,\n      // @ts-expect-error\n      source: fs,\n      stage: 'fragment',\n      modules\n    }),\n    getUniforms: assembleGetUniforms(modules)\n  };\n}\n/**\n * Pulls together complete source code for either a vertex or a fragment shader\n * adding prologues, requested module chunks, and any final injections.\n * @param gl\n * @param options\n * @returns\n */\nexport function assembleShaderWGSL(platformInfo, options) {\n  const {\n    // id,\n    source,\n    stage,\n    modules,\n    // defines = {},\n    hookFunctions = [],\n    inject = {},\n    log\n  } = options;\n  assert(typeof source === 'string', 'shader source must be a string');\n  // const isVertex = type === 'vs';\n  // const sourceLines = source.split('\\n');\n  const coreSource = source;\n  // Combine Module and Application Defines\n  // const allDefines = {};\n  // modules.forEach(module => {\n  //   Object.assign(allDefines, module.getDefines());\n  // });\n  // Object.assign(allDefines, defines);\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = '';\n  //   prologue\n  //     ? `\\\n  // ${getShaderNameDefine({id, source, type})}\n  // ${getShaderType(type)}\n  // ${getPlatformShaderDefines(platformInfo)}\n  // ${getApplicationDefines(allDefines)}\n  // ${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n  // `\n  // `;\n  const hookFunctionMap = normalizeShaderHooks(hookFunctions);\n  // Add source of dependent modules in resolved order\n  const hookInjections = {};\n  const declInjections = {};\n  const mainInjections = {};\n  for (const key in inject) {\n    const injection = typeof inject[key] === 'string' ? {\n      injection: inject[key],\n      order: 0\n    } : inject[key];\n    const match = /^(v|f)s:(#)?([\\w-]+)$/.exec(key);\n    if (match) {\n      const hash = match[2];\n      const name = match[3];\n      if (hash) {\n        if (name === 'decl') {\n          declInjections[key] = [injection];\n        } else {\n          mainInjections[key] = [injection];\n        }\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection];\n    }\n  }\n  // TODO - hack until shadertool modules support WebGPU\n  const modulesToInject = modules;\n  for (const module of modulesToInject) {\n    if (log) {\n      checkShaderModuleDeprecations(module, coreSource, log);\n    }\n    const moduleSource = getShaderModuleSource(module, 'wgsl');\n    // Add the module source, and a #define that declares it presence\n    assembledSource += moduleSource;\n    const injections = module.injections?.[stage] || {};\n    for (const key in injections) {\n      const match = /^(v|f)s:#([\\w-]+)$/.exec(key);\n      if (match) {\n        const name = match[2];\n        const injectionType = name === 'decl' ? declInjections : mainInjections;\n        injectionType[key] = injectionType[key] || [];\n        injectionType[key].push(injections[key]);\n      } else {\n        hookInjections[key] = hookInjections[key] || [];\n        hookInjections[key].push(injections[key]);\n      }\n    }\n  }\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n  assembledSource = injectShader(assembledSource, stage, declInjections);\n  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, stage, mainInjections);\n  return assembledSource;\n}\n/**\n * Pulls together complete source code for either a vertex or a fragment shader\n * adding prologues, requested module chunks, and any final injections.\n * @param gl\n * @param options\n * @returns\n */\nfunction assembleShaderGLSL(platformInfo, options) {\n  const {\n    id,\n    source,\n    stage,\n    language = 'glsl',\n    modules,\n    defines = {},\n    hookFunctions = [],\n    inject = {},\n    prologue = true,\n    log\n  } = options;\n  assert(typeof source === 'string', 'shader source must be a string');\n  const sourceVersion = language === 'glsl' ? getShaderInfo(source).version : -1;\n  const targetVersion = platformInfo.shaderLanguageVersion;\n  const sourceVersionDirective = sourceVersion === 100 ? '#version 100' : '#version 300 es';\n  const sourceLines = source.split('\\n');\n  // TODO : keep all pre-processor statements at the beginning of the shader.\n  const coreSource = sourceLines.slice(1).join('\\n');\n  // Combine Module and Application Defines\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.defines);\n  });\n  Object.assign(allDefines, defines);\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = '';\n  switch (language) {\n    case 'wgsl':\n      break;\n    case 'glsl':\n      assembledSource = prologue ? `\\\n${sourceVersionDirective}\n\n// ----- PROLOGUE -------------------------\n${getShaderNameDefine({\n        id,\n        source,\n        stage\n      })}\n${`#define SHADER_TYPE_${stage.toUpperCase()}`}\n\n${getPlatformShaderDefines(platformInfo)}\n${stage === 'fragment' ? FRAGMENT_SHADER_PROLOGUE : ''}\n\n// ----- APPLICATION DEFINES -------------------------\n\n${getApplicationDefines(allDefines)}\n\n` : `${sourceVersionDirective}\n`;\n      break;\n  }\n  const hookFunctionMap = normalizeShaderHooks(hookFunctions);\n  // Add source of dependent modules in resolved order\n  const hookInjections = {};\n  const declInjections = {};\n  const mainInjections = {};\n  for (const key in inject) {\n    const injection = typeof inject[key] === 'string' ? {\n      injection: inject[key],\n      order: 0\n    } : inject[key];\n    const match = /^(v|f)s:(#)?([\\w-]+)$/.exec(key);\n    if (match) {\n      const hash = match[2];\n      const name = match[3];\n      if (hash) {\n        if (name === 'decl') {\n          declInjections[key] = [injection];\n        } else {\n          mainInjections[key] = [injection];\n        }\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection];\n    }\n  }\n  for (const module of modules) {\n    if (log) {\n      checkShaderModuleDeprecations(module, coreSource, log);\n    }\n    const moduleSource = getShaderModuleSource(module, stage);\n    // Add the module source, and a #define that declares it presence\n    assembledSource += moduleSource;\n    const injections = module.instance?.normalizedInjections[stage] || {};\n    for (const key in injections) {\n      const match = /^(v|f)s:#([\\w-]+)$/.exec(key);\n      if (match) {\n        const name = match[2];\n        const injectionType = name === 'decl' ? declInjections : mainInjections;\n        injectionType[key] = injectionType[key] || [];\n        injectionType[key].push(injections[key]);\n      } else {\n        hookInjections[key] = hookInjections[key] || [];\n        hookInjections[key].push(injections[key]);\n      }\n    }\n  }\n  assembledSource += '// ----- MAIN SHADER SOURCE -------------------------';\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n  assembledSource = injectShader(assembledSource, stage, declInjections);\n  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, stage, mainInjections);\n  if (language === 'glsl' && sourceVersion !== targetVersion) {\n    assembledSource = transpileGLSLShader(assembledSource, stage);\n  }\n  return assembledSource.trim();\n}\n/**\n * Returns a combined `getUniforms` covering the options for all the modules,\n * the created function will pass on options to the inidividual `getUniforms`\n * function of each shader module and combine the results into one object that\n * can be passed to setUniforms.\n * @param modules\n * @returns\n */\nexport function assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const module of modules) {\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = module.getUniforms?.(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n}\n/**\n * Generate \"glslify-compatible\" SHADER_NAME defines\n * These are understood by the GLSL error parsing function\n * If id is provided and no SHADER_NAME constant is present in source, create one\n */\nfunction getShaderNameDefine(options) {\n  const {\n    id,\n    source,\n    stage\n  } = options;\n  const injectShaderName = id && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName ? `\n#define SHADER_NAME ${id}_${stage}` : '';\n}\n/** Generates application defines from an object of key value pairs */\nfunction getApplicationDefines(defines = {}) {\n  let sourceText = '';\n  for (const define in defines) {\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n    }\n  }\n  return sourceText;\n}\n/** Extracts the source code chunk for the specified shader type from the named shader module */\nexport function getShaderModuleSource(module, stage) {\n  let moduleSource;\n  switch (stage) {\n    case 'vertex':\n      moduleSource = module.vs || '';\n      break;\n    case 'fragment':\n      moduleSource = module.fs || '';\n      break;\n    case 'wgsl':\n      moduleSource = module.source || '';\n      break;\n    default:\n      assert(false);\n  }\n  if (!module.name) {\n    throw new Error('Shader module must have a name');\n  }\n  const moduleName = module.name.toUpperCase().replace(/[^0-9a-z]/gi, '_');\n  let source = `\\\n// ----- MODULE ${module.name} ---------------\n\n`;\n  if (stage !== 'wgsl') {\n    source += `#define MODULE_${moduleName}\\n`;\n  }\n  source += `${moduleSource}\\n`;\n  return source;\n}\n/*\nfunction getHookFunctions(\n  hookFunctions: Record<string, HookFunction>,\n  hookInjections: Record<string, Injection[]>\n): string {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a: {order: number}, b: {order: number}): number => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\n\nfunction normalizeHookFunctions(hookFunctions: (string | HookFunction)[]): {\n  vs: Record<string, HookFunction>;\n  fs: Record<string, HookFunction>;\n} {\n  const result: {vs: Record<string, any>; fs: Record<string, any>} = {\n    vs: {},\n    fs: {}\n  };\n\n  hookFunctions.forEach((hookFunction: string | HookFunction) => {\n    let opts: HookFunction;\n    let hook: string;\n    if (typeof hookFunction !== 'string') {\n      opts = hookFunction;\n      hook = opts.hook;\n    } else {\n      opts = {} as HookFunction;\n      hook = hookFunction;\n    }\n    hook = hook.trim();\n    const [stage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    if (stage !== 'vs' && stage !== 'fs') {\n      throw new Error(stage);\n    }\n    result[stage][name] = Object.assign(opts, {signature});\n  });\n\n  return result;\n}\n*/\n//# sourceMappingURL=assemble-shaders.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}