{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { classifyRings, classifyRingsFlat, projectToLngLat, projectToLngLatFlat, convertToLocalCoordinates, convertToLocalCoordinatesFlat } from \"../utils/geometry-utils.js\";\nexport class VectorTileFeature {\n  properties;\n  extent;\n  type;\n  id;\n  _pbf;\n  _geometry;\n  _keys;\n  _values;\n  _geometryInfo;\n  static types = ['Unknown', 'Point', 'LineString', 'Polygon'];\n  // eslint-disable-next-line max-params\n  constructor(pbf, end, extent, keys, values, geometryInfo) {\n    // Public\n    this.properties = {};\n    this.extent = extent;\n    this.type = 0;\n    this.id = null;\n    // Private\n    this._pbf = pbf;\n    this._geometry = -1;\n    this._keys = keys;\n    this._values = values;\n    // Only used by binary tiles\n    this._geometryInfo = geometryInfo;\n    pbf.readFields(readFeature, this, end);\n  }\n  toGeoJSONFeature(coordinates, tileIndex) {\n    const coords = this.loadGeometry();\n    switch (coordinates) {\n      case 'wgs84':\n        return _toGeoJSONFeature(this, coords, line => projectToLngLat(line, tileIndex, this.extent));\n      default:\n        return _toGeoJSONFeature(this, coords, convertToLocalCoordinates);\n    }\n  }\n  /**\n   *\n   * @param options\n   * @returns\n   */\n  toBinaryFeature(coordinates, tileIndex) {\n    const geom = this.loadFlatGeometry();\n    switch (coordinates) {\n      case 'wgs84':\n        return this._toBinaryCoordinates(geom, coords => projectToLngLatFlat(coords, tileIndex, this.extent));\n      default:\n        return this._toBinaryCoordinates(geom, convertToLocalCoordinatesFlat);\n    }\n  }\n  /** Read a bounding box from the feature */\n  // eslint-disable-next-line max-statements\n  bbox() {\n    const pbf = this._pbf;\n    pbf.pos = this._geometry;\n    const end = pbf.readVarint() + pbf.pos;\n    let cmd = 1;\n    let length = 0;\n    let x = 0;\n    let y = 0;\n    let x1 = Infinity;\n    let x2 = -Infinity;\n    let y1 = Infinity;\n    let y2 = -Infinity;\n    while (pbf.pos < end) {\n      if (length <= 0) {\n        const cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n      length--;\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n        if (x < x1) x1 = x;\n        if (x > x2) x2 = x;\n        if (y < y1) y1 = y;\n        if (y > y2) y2 = y;\n      } else if (cmd !== 7) {\n        throw new Error(`unknown command ${cmd}`);\n      }\n    }\n    return [x1, y1, x2, y2];\n  }\n  // BINARY HELPERS\n  /**\n   *\n   * @param transform\n   * @returns result\n   */\n  _toBinaryCoordinates(geom, transform) {\n    let geometry;\n    // Apply the supplied transformation to data\n    transform(geom.data, this.extent);\n    const coordLength = 2;\n    // eslint-disable-next-line default-case\n    switch (this.type) {\n      case 1:\n        // Point\n        this._geometryInfo.pointFeaturesCount++;\n        this._geometryInfo.pointPositionsCount += geom.indices.length;\n        geometry = {\n          type: 'Point',\n          ...geom\n        };\n        break;\n      case 2:\n        // LineString\n        this._geometryInfo.lineFeaturesCount++;\n        this._geometryInfo.linePathsCount += geom.indices.length;\n        this._geometryInfo.linePositionsCount += geom.data.length / coordLength;\n        geometry = {\n          type: 'LineString',\n          ...geom\n        };\n        break;\n      case 3:\n        // Polygon\n        geometry = classifyRingsFlat(geom);\n        // Unlike Point & LineString geom.indices is a 2D array, thanks\n        // to the classifyRings method\n        this._geometryInfo.polygonFeaturesCount++;\n        this._geometryInfo.polygonObjectsCount += geometry.indices.length;\n        for (const indices of geometry.indices) {\n          this._geometryInfo.polygonRingsCount += indices.length;\n        }\n        this._geometryInfo.polygonPositionsCount += geometry.data.length / coordLength;\n        break;\n      default:\n        throw new Error(`Invalid geometry type: ${this.type}`);\n    }\n    const result = {\n      type: 'Feature',\n      geometry,\n      properties: this.properties\n    };\n    if (this.id !== null) {\n      result.id = this.id;\n    }\n    return result;\n  }\n  // GEOJSON HELPER\n  // eslint-disable-next-line complexity, max-statements\n  loadGeometry() {\n    const pbf = this._pbf;\n    pbf.pos = this._geometry;\n    const end = pbf.readVarint() + pbf.pos;\n    let cmd = 1;\n    let length = 0;\n    let x = 0;\n    let y = 0;\n    const lines = [];\n    let line;\n    while (pbf.pos < end) {\n      if (length <= 0) {\n        const cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n      length--;\n      switch (cmd) {\n        case 1:\n        case 2:\n          x += pbf.readSVarint();\n          y += pbf.readSVarint();\n          if (cmd === 1) {\n            // moveTo\n            if (line) lines.push(line);\n            line = [];\n          }\n          if (line) line.push([x, y]);\n          break;\n        case 7:\n          // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n          if (line) {\n            line.push(line[0].slice()); // closePolygon\n          }\n          break;\n        default:\n          throw new Error(`unknown command ${cmd}`);\n      }\n    }\n    if (line) lines.push(line);\n    return lines;\n  }\n  /**\n   * Expands the protobuf data to an intermediate Flat GeoJSON\n   * data format, which maps closely to the binary data buffers.\n   * It is similar to GeoJSON, but rather than storing the coordinates\n   * in multidimensional arrays, we have a 1D `data` with all the\n   * coordinates, and then index into this using the `indices`\n   * parameter, e.g.\n   *\n   * geometry: {\n   *   type: 'Point', data: [1,2], indices: [0]\n   * }\n   * geometry: {\n   *   type: 'LineString', data: [1,2,3,4,...], indices: [0]\n   * }\n   * geometry: {\n   *   type: 'Polygon', data: [1,2,3,4,...], indices: [[0, 2]]\n   * }\n   * Thus the indices member lets us look up the relevant range\n   * from the data array.\n   * The Multi* versions of the above types share the same data\n   * structure, just with multiple elements in the indices array\n   */\n  // eslint-disable-next-line complexity, max-statements\n  loadFlatGeometry() {\n    const pbf = this._pbf;\n    pbf.pos = this._geometry;\n    const endPos = pbf.readVarint() + pbf.pos;\n    let cmd = 1;\n    let cmdLen;\n    let length = 0;\n    let x = 0;\n    let y = 0;\n    let i = 0;\n    // Note: I attempted to replace the `data` array with a\n    // Float32Array, but performance was worse, both using\n    // `set()` and direct index access. Also, we cannot\n    // know how large the buffer should be, so it would\n    // increase memory usage\n    const indices = []; // Indices where geometries start\n    const data = []; // Flat array of coordinate data\n    while (pbf.pos < endPos) {\n      if (length <= 0) {\n        cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n      length--;\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n        if (cmd === 1) {\n          // New line\n          indices.push(i);\n        }\n        data.push(x, y);\n        i += 2;\n      } else if (cmd === 7) {\n        // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n        if (i > 0) {\n          const start = indices[indices.length - 1]; // start index of polygon\n          data.push(data[start], data[start + 1]); // closePolygon\n          i += 2;\n        }\n      } else {\n        throw new Error(`unknown command ${cmd}`);\n      }\n    }\n    return {\n      data,\n      indices\n    };\n  }\n}\nfunction _toGeoJSONFeature(vtFeature, coords, transform) {\n  let type = VectorTileFeature.types[vtFeature.type];\n  let i;\n  let j;\n  let coordinates;\n  switch (vtFeature.type) {\n    case 1:\n      const points = [];\n      for (i = 0; i < coords.length; i++) {\n        points[i] = coords[i][0];\n      }\n      coordinates = points;\n      transform(coordinates, vtFeature.extent);\n      break;\n    case 2:\n      coordinates = coords;\n      for (i = 0; i < coordinates.length; i++) {\n        transform(coordinates[i], vtFeature.extent);\n      }\n      break;\n    case 3:\n      coordinates = classifyRings(coords);\n      for (i = 0; i < coordinates.length; i++) {\n        for (j = 0; j < coordinates[i].length; j++) {\n          transform(coordinates[i][j], vtFeature.extent);\n        }\n      }\n      break;\n    default:\n      throw new Error('illegal vector tile type');\n  }\n  if (coordinates.length === 1) {\n    // @ts-expect-error\n    coordinates = coordinates[0];\n  } else {\n    type = `Multi${type}`;\n  }\n  const result = {\n    type: 'Feature',\n    geometry: {\n      type: type,\n      coordinates: coordinates\n    },\n    properties: vtFeature.properties\n  };\n  if (vtFeature.id !== null) {\n    result.properties ||= {};\n    result.properties.id = vtFeature.id;\n  }\n  return result;\n}\n// PBF READER UTILS\n/**\n *\n * @param tag\n * @param feature\n * @param pbf\n */\nfunction readFeature(tag, feature, pbf) {\n  if (feature && pbf) {\n    if (tag === 1) feature.id = pbf.readVarint();else if (tag === 2) readTag(pbf, feature);else if (tag === 3) feature.type = pbf.readVarint();else if (tag === 4) feature._geometry = pbf.pos;\n  }\n}\n/**\n *\n * @param pbf\n * @param feature\n */\nfunction readTag(pbf, feature) {\n  const end = pbf.readVarint() + pbf.pos;\n  while (pbf.pos < end) {\n    const key = feature._keys[pbf.readVarint()];\n    const value = feature._values[pbf.readVarint()];\n    feature.properties[key] = value;\n  }\n}","map":{"version":3,"names":["classifyRings","classifyRingsFlat","projectToLngLat","projectToLngLatFlat","convertToLocalCoordinates","convertToLocalCoordinatesFlat","VectorTileFeature","properties","extent","type","id","_pbf","_geometry","_keys","_values","_geometryInfo","types","constructor","pbf","end","keys","values","geometryInfo","readFields","readFeature","toGeoJSONFeature","coordinates","tileIndex","coords","loadGeometry","_toGeoJSONFeature","line","toBinaryFeature","geom","loadFlatGeometry","_toBinaryCoordinates","bbox","pos","readVarint","cmd","length","x","y","x1","Infinity","x2","y1","y2","cmdLen","readSVarint","Error","transform","geometry","data","coordLength","pointFeaturesCount","pointPositionsCount","indices","lineFeaturesCount","linePathsCount","linePositionsCount","polygonFeaturesCount","polygonObjectsCount","polygonRingsCount","polygonPositionsCount","result","lines","push","slice","endPos","i","start","vtFeature","j","points","tag","feature","readTag","key","value"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/mvt/dist/lib/vector-tile/vector-tile-feature.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { classifyRings, classifyRingsFlat, projectToLngLat, projectToLngLatFlat, convertToLocalCoordinates, convertToLocalCoordinatesFlat } from \"../utils/geometry-utils.js\";\nexport class VectorTileFeature {\n    properties;\n    extent;\n    type;\n    id;\n    _pbf;\n    _geometry;\n    _keys;\n    _values;\n    _geometryInfo;\n    static types = ['Unknown', 'Point', 'LineString', 'Polygon'];\n    // eslint-disable-next-line max-params\n    constructor(pbf, end, extent, keys, values, geometryInfo) {\n        // Public\n        this.properties = {};\n        this.extent = extent;\n        this.type = 0;\n        this.id = null;\n        // Private\n        this._pbf = pbf;\n        this._geometry = -1;\n        this._keys = keys;\n        this._values = values;\n        // Only used by binary tiles\n        this._geometryInfo = geometryInfo;\n        pbf.readFields(readFeature, this, end);\n    }\n    toGeoJSONFeature(coordinates, tileIndex) {\n        const coords = this.loadGeometry();\n        switch (coordinates) {\n            case 'wgs84':\n                return _toGeoJSONFeature(this, coords, (line) => projectToLngLat(line, tileIndex, this.extent));\n            default:\n                return _toGeoJSONFeature(this, coords, convertToLocalCoordinates);\n        }\n    }\n    /**\n     *\n     * @param options\n     * @returns\n     */\n    toBinaryFeature(coordinates, tileIndex) {\n        const geom = this.loadFlatGeometry();\n        switch (coordinates) {\n            case 'wgs84':\n                return this._toBinaryCoordinates(geom, (coords) => projectToLngLatFlat(coords, tileIndex, this.extent));\n            default:\n                return this._toBinaryCoordinates(geom, convertToLocalCoordinatesFlat);\n        }\n    }\n    /** Read a bounding box from the feature */\n    // eslint-disable-next-line max-statements\n    bbox() {\n        const pbf = this._pbf;\n        pbf.pos = this._geometry;\n        const end = pbf.readVarint() + pbf.pos;\n        let cmd = 1;\n        let length = 0;\n        let x = 0;\n        let y = 0;\n        let x1 = Infinity;\n        let x2 = -Infinity;\n        let y1 = Infinity;\n        let y2 = -Infinity;\n        while (pbf.pos < end) {\n            if (length <= 0) {\n                const cmdLen = pbf.readVarint();\n                cmd = cmdLen & 0x7;\n                length = cmdLen >> 3;\n            }\n            length--;\n            if (cmd === 1 || cmd === 2) {\n                x += pbf.readSVarint();\n                y += pbf.readSVarint();\n                if (x < x1)\n                    x1 = x;\n                if (x > x2)\n                    x2 = x;\n                if (y < y1)\n                    y1 = y;\n                if (y > y2)\n                    y2 = y;\n            }\n            else if (cmd !== 7) {\n                throw new Error(`unknown command ${cmd}`);\n            }\n        }\n        return [x1, y1, x2, y2];\n    }\n    // BINARY HELPERS\n    /**\n     *\n     * @param transform\n     * @returns result\n     */\n    _toBinaryCoordinates(geom, transform) {\n        let geometry;\n        // Apply the supplied transformation to data\n        transform(geom.data, this.extent);\n        const coordLength = 2;\n        // eslint-disable-next-line default-case\n        switch (this.type) {\n            case 1: // Point\n                this._geometryInfo.pointFeaturesCount++;\n                this._geometryInfo.pointPositionsCount += geom.indices.length;\n                geometry = { type: 'Point', ...geom };\n                break;\n            case 2: // LineString\n                this._geometryInfo.lineFeaturesCount++;\n                this._geometryInfo.linePathsCount += geom.indices.length;\n                this._geometryInfo.linePositionsCount += geom.data.length / coordLength;\n                geometry = { type: 'LineString', ...geom };\n                break;\n            case 3: // Polygon\n                geometry = classifyRingsFlat(geom);\n                // Unlike Point & LineString geom.indices is a 2D array, thanks\n                // to the classifyRings method\n                this._geometryInfo.polygonFeaturesCount++;\n                this._geometryInfo.polygonObjectsCount += geometry.indices.length;\n                for (const indices of geometry.indices) {\n                    this._geometryInfo.polygonRingsCount += indices.length;\n                }\n                this._geometryInfo.polygonPositionsCount += geometry.data.length / coordLength;\n                break;\n            default:\n                throw new Error(`Invalid geometry type: ${this.type}`);\n        }\n        const result = { type: 'Feature', geometry, properties: this.properties };\n        if (this.id !== null) {\n            result.id = this.id;\n        }\n        return result;\n    }\n    // GEOJSON HELPER\n    // eslint-disable-next-line complexity, max-statements\n    loadGeometry() {\n        const pbf = this._pbf;\n        pbf.pos = this._geometry;\n        const end = pbf.readVarint() + pbf.pos;\n        let cmd = 1;\n        let length = 0;\n        let x = 0;\n        let y = 0;\n        const lines = [];\n        let line;\n        while (pbf.pos < end) {\n            if (length <= 0) {\n                const cmdLen = pbf.readVarint();\n                cmd = cmdLen & 0x7;\n                length = cmdLen >> 3;\n            }\n            length--;\n            switch (cmd) {\n                case 1:\n                case 2:\n                    x += pbf.readSVarint();\n                    y += pbf.readSVarint();\n                    if (cmd === 1) {\n                        // moveTo\n                        if (line)\n                            lines.push(line);\n                        line = [];\n                    }\n                    if (line)\n                        line.push([x, y]);\n                    break;\n                case 7:\n                    // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n                    if (line) {\n                        line.push(line[0].slice()); // closePolygon\n                    }\n                    break;\n                default:\n                    throw new Error(`unknown command ${cmd}`);\n            }\n        }\n        if (line)\n            lines.push(line);\n        return lines;\n    }\n    /**\n     * Expands the protobuf data to an intermediate Flat GeoJSON\n     * data format, which maps closely to the binary data buffers.\n     * It is similar to GeoJSON, but rather than storing the coordinates\n     * in multidimensional arrays, we have a 1D `data` with all the\n     * coordinates, and then index into this using the `indices`\n     * parameter, e.g.\n     *\n     * geometry: {\n     *   type: 'Point', data: [1,2], indices: [0]\n     * }\n     * geometry: {\n     *   type: 'LineString', data: [1,2,3,4,...], indices: [0]\n     * }\n     * geometry: {\n     *   type: 'Polygon', data: [1,2,3,4,...], indices: [[0, 2]]\n     * }\n     * Thus the indices member lets us look up the relevant range\n     * from the data array.\n     * The Multi* versions of the above types share the same data\n     * structure, just with multiple elements in the indices array\n     */\n    // eslint-disable-next-line complexity, max-statements\n    loadFlatGeometry() {\n        const pbf = this._pbf;\n        pbf.pos = this._geometry;\n        const endPos = pbf.readVarint() + pbf.pos;\n        let cmd = 1;\n        let cmdLen;\n        let length = 0;\n        let x = 0;\n        let y = 0;\n        let i = 0;\n        // Note: I attempted to replace the `data` array with a\n        // Float32Array, but performance was worse, both using\n        // `set()` and direct index access. Also, we cannot\n        // know how large the buffer should be, so it would\n        // increase memory usage\n        const indices = []; // Indices where geometries start\n        const data = []; // Flat array of coordinate data\n        while (pbf.pos < endPos) {\n            if (length <= 0) {\n                cmdLen = pbf.readVarint();\n                cmd = cmdLen & 0x7;\n                length = cmdLen >> 3;\n            }\n            length--;\n            if (cmd === 1 || cmd === 2) {\n                x += pbf.readSVarint();\n                y += pbf.readSVarint();\n                if (cmd === 1) {\n                    // New line\n                    indices.push(i);\n                }\n                data.push(x, y);\n                i += 2;\n            }\n            else if (cmd === 7) {\n                // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n                if (i > 0) {\n                    const start = indices[indices.length - 1]; // start index of polygon\n                    data.push(data[start], data[start + 1]); // closePolygon\n                    i += 2;\n                }\n            }\n            else {\n                throw new Error(`unknown command ${cmd}`);\n            }\n        }\n        return { data, indices };\n    }\n}\nfunction _toGeoJSONFeature(vtFeature, coords, transform) {\n    let type = VectorTileFeature.types[vtFeature.type];\n    let i;\n    let j;\n    let coordinates;\n    switch (vtFeature.type) {\n        case 1:\n            const points = [];\n            for (i = 0; i < coords.length; i++) {\n                points[i] = coords[i][0];\n            }\n            coordinates = points;\n            transform(coordinates, vtFeature.extent);\n            break;\n        case 2:\n            coordinates = coords;\n            for (i = 0; i < coordinates.length; i++) {\n                transform(coordinates[i], vtFeature.extent);\n            }\n            break;\n        case 3:\n            coordinates = classifyRings(coords);\n            for (i = 0; i < coordinates.length; i++) {\n                for (j = 0; j < coordinates[i].length; j++) {\n                    transform(coordinates[i][j], vtFeature.extent);\n                }\n            }\n            break;\n        default:\n            throw new Error('illegal vector tile type');\n    }\n    if (coordinates.length === 1) {\n        // @ts-expect-error\n        coordinates = coordinates[0];\n    }\n    else {\n        type = `Multi${type}`;\n    }\n    const result = {\n        type: 'Feature',\n        geometry: {\n            type: type,\n            coordinates: coordinates\n        },\n        properties: vtFeature.properties\n    };\n    if (vtFeature.id !== null) {\n        result.properties ||= {};\n        result.properties.id = vtFeature.id;\n    }\n    return result;\n}\n// PBF READER UTILS\n/**\n *\n * @param tag\n * @param feature\n * @param pbf\n */\nfunction readFeature(tag, feature, pbf) {\n    if (feature && pbf) {\n        if (tag === 1)\n            feature.id = pbf.readVarint();\n        else if (tag === 2)\n            readTag(pbf, feature);\n        else if (tag === 3)\n            feature.type = pbf.readVarint();\n        else if (tag === 4)\n            feature._geometry = pbf.pos;\n    }\n}\n/**\n *\n * @param pbf\n * @param feature\n */\nfunction readTag(pbf, feature) {\n    const end = pbf.readVarint() + pbf.pos;\n    while (pbf.pos < end) {\n        const key = feature._keys[pbf.readVarint()];\n        const value = feature._values[pbf.readVarint()];\n        feature.properties[key] = value;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}