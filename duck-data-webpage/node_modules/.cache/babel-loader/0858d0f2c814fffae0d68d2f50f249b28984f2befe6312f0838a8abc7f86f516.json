{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Buffer } from '@luma.gl/core';\nimport { getPassthroughFS } from '@luma.gl/shadertools';\nimport { Model } from \"../model/model.js\";\n/**\n * Manages a WebGL program (pipeline) for bufferâ†’buffer transforms.\n * @note Only works under WebGL2.\n */\nexport class BufferTransform {\n  device;\n  model;\n  transformFeedback;\n  static defaultProps = (() => ({\n    ...Model.defaultProps,\n    outputs: undefined,\n    feedbackBuffers: undefined\n  }))();\n  static isSupported(device) {\n    return device?.info?.type === 'webgl';\n  }\n  constructor(device) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BufferTransform.defaultProps;\n    if (!BufferTransform.isSupported(device)) {\n      throw new Error('BufferTransform not yet implemented on WebGPU');\n    }\n    this.device = device;\n    this.model = new Model(this.device, {\n      id: props.id || 'buffer-transform-model',\n      fs: props.fs || getPassthroughFS(),\n      topology: props.topology || 'point-list',\n      varyings: props.outputs || props.varyings,\n      ...props\n    });\n    this.transformFeedback = this.device.createTransformFeedback({\n      layout: this.model.pipeline.shaderLayout,\n      // @ts-expect-error TODO\n      buffers: props.feedbackBuffers\n    });\n    this.model.setTransformFeedback(this.transformFeedback);\n    Object.seal(this);\n  }\n  /** Destroy owned resources. */\n  destroy() {\n    if (this.model) {\n      this.model.destroy();\n    }\n  }\n  /** @deprecated Use {@link destroy}. */\n  delete() {\n    this.destroy();\n  }\n  /** Run one transform loop. */\n  run(options) {\n    if (options?.inputBuffers) {\n      this.model.setAttributes(options.inputBuffers);\n    }\n    if (options?.outputBuffers) {\n      this.transformFeedback.setBuffers(options.outputBuffers);\n    }\n    const renderPass = this.device.beginRenderPass(options);\n    this.model.draw(renderPass);\n    renderPass.end();\n  }\n  // DEPRECATED METHODS\n  /** @deprecated App knows what buffers it is passing in - Returns the {@link Buffer} or {@link BufferRange} for given varying name. */\n  getBuffer(varyingName) {\n    return this.transformFeedback.getBuffer(varyingName);\n  }\n  /** @deprecated App knows what buffers it is passing in - Reads the {@link Buffer} or {@link BufferRange} for given varying name. */\n  readAsync(varyingName) {\n    const result = this.getBuffer(varyingName);\n    if (!result) {\n      throw new Error('BufferTransform#getBuffer');\n    }\n    if (result instanceof Buffer) {\n      return result.readAsync();\n    }\n    const {\n      buffer,\n      byteOffset = 0,\n      byteLength = buffer.byteLength\n    } = result;\n    return buffer.readAsync(byteOffset, byteLength);\n  }\n}\n//# sourceMappingURL=buffer-transform.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}