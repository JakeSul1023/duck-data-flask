{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** Evaluate a VertexAccessor with a set of attributes */\nexport function evaluateVertexAccessor(accessor, attributes, options) {\n  const vertexReaders = {};\n  for (const id of accessor.sources || []) {\n    const attribute = attributes[id];\n    if (attribute) {\n      vertexReaders[id] = getVertexReader(attribute);\n    } else {\n      throw new Error(`Cannot find attribute ${id}`);\n    }\n  }\n  const data = {};\n  return vertexIndex => {\n    for (const id in vertexReaders) {\n      data[id] = vertexReaders[id](vertexIndex);\n    }\n    return accessor.getValue(data, vertexIndex, options);\n  };\n}\n/** Read value out of a deck.gl Attribute by vertex */\nfunction getVertexReader(attribute) {\n  const value = attribute.value;\n  const {\n    offset = 0,\n    stride,\n    size\n  } = attribute.getAccessor();\n  const bytesPerElement = value.BYTES_PER_ELEMENT;\n  const elementOffset = offset / bytesPerElement;\n  const elementStride = stride ? stride / bytesPerElement : size;\n  if (size === 1) {\n    // Size 1, returns (i: number) => number\n    if (attribute.isConstant) {\n      return () => value[0];\n    }\n    return vertexIndex => {\n      const i = elementOffset + elementStride * vertexIndex;\n      return value[i];\n    };\n  }\n  // Size >1, returns (i: number) => number[]\n  let result;\n  if (attribute.isConstant) {\n    result = Array.from(value);\n    return () => result;\n  }\n  result = new Array(size);\n  return vertexIndex => {\n    const i = elementOffset + elementStride * vertexIndex;\n    for (let j = 0; j < size; j++) {\n      result[j] = value[i + j];\n    }\n    return result;\n  };\n}","map":{"version":3,"names":["evaluateVertexAccessor","accessor","attributes","options","vertexReaders","id","sources","attribute","getVertexReader","Error","data","vertexIndex","getValue","value","offset","stride","size","getAccessor","bytesPerElement","BYTES_PER_ELEMENT","elementOffset","elementStride","isConstant","i","result","Array","from","j"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\aggregation-layers\\src\\common\\aggregator\\cpu-aggregator\\vertex-accessor.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Attribute} from '@deck.gl/core';\nimport type {TypedArray} from '@luma.gl/core';\n\n/** This is designed to mirror a vertex shader function\n * For each vertex, calculates a value from attribtes, vertex index and options (uniforms)\n */\nexport type VertexAccessor<ValueT, OptionsT = undefined> = {\n  /** Attribute ids that provide input to getValue, used to index into the attributes map.\n   * For example `['position', 'size']`\n   */\n  sources?: string[];\n  /** Called for each data point to retrieve a value during update. */\n  getValue: (\n    /** Attributes at the vertex index */\n    data: any,\n    /** Vertex index */\n    index: number,\n    /** Shared options across all vertices */\n    options: OptionsT\n  ) => ValueT;\n};\n\n/** Evaluate a VertexAccessor with a set of attributes */\nexport function evaluateVertexAccessor<ValueT, OptionsT>(\n  accessor: VertexAccessor<ValueT, OptionsT>,\n  attributes: Record<string, Attribute>,\n  options: OptionsT\n): (vertexIndex: number) => ValueT {\n  const vertexReaders: {[id: string]: (i: number) => number | number[]} = {};\n  for (const id of accessor.sources || []) {\n    const attribute = attributes[id];\n    if (attribute) {\n      vertexReaders[id] = getVertexReader(attribute);\n    } else {\n      throw new Error(`Cannot find attribute ${id}`);\n    }\n  }\n  const data: {[id: string]: number | number[]} = {};\n\n  return (vertexIndex: number) => {\n    for (const id in vertexReaders) {\n      data[id] = vertexReaders[id](vertexIndex);\n    }\n    return accessor.getValue(data, vertexIndex, options);\n  };\n}\n\n/** Read value out of a deck.gl Attribute by vertex */\nfunction getVertexReader(attribute: Attribute): (vertexIndex: number) => number | number[] {\n  const value = attribute.value as TypedArray;\n  const {offset = 0, stride, size} = attribute.getAccessor();\n  const bytesPerElement = value.BYTES_PER_ELEMENT;\n  const elementOffset = offset / bytesPerElement;\n  const elementStride = stride ? stride / bytesPerElement : size;\n\n  if (size === 1) {\n    // Size 1, returns (i: number) => number\n    if (attribute.isConstant) {\n      return () => value[0];\n    }\n    return (vertexIndex: number) => {\n      const i = elementOffset + elementStride * vertexIndex;\n      return value[i];\n    };\n  }\n\n  // Size >1, returns (i: number) => number[]\n  let result: number[];\n  if (attribute.isConstant) {\n    result = Array.from(value);\n    return () => result;\n  }\n\n  result = new Array(size);\n  return (vertexIndex: number) => {\n    const i = elementOffset + elementStride * vertexIndex;\n    for (let j = 0; j < size; j++) {\n      result[j] = value[i + j];\n    }\n    return result;\n  };\n}\n"],"mappings":"AAAA;AACA;AACA;AAwBA;AACA,OAAM,SAAUA,sBAAsBA,CACpCC,QAA0C,EAC1CC,UAAqC,EACrCC,OAAiB;EAEjB,MAAMC,aAAa,GAAqD,EAAE;EAC1E,KAAK,MAAMC,EAAE,IAAIJ,QAAQ,CAACK,OAAO,IAAI,EAAE,EAAE;IACvC,MAAMC,SAAS,GAAGL,UAAU,CAACG,EAAE,CAAC;IAChC,IAAIE,SAAS,EAAE;MACbH,aAAa,CAACC,EAAE,CAAC,GAAGG,eAAe,CAACD,SAAS,CAAC;IAChD,CAAC,MAAM;MACL,MAAM,IAAIE,KAAK,CAAC,yBAAyBJ,EAAE,EAAE,CAAC;IAChD;EACF;EACA,MAAMK,IAAI,GAAsC,EAAE;EAElD,OAAQC,WAAmB,IAAI;IAC7B,KAAK,MAAMN,EAAE,IAAID,aAAa,EAAE;MAC9BM,IAAI,CAACL,EAAE,CAAC,GAAGD,aAAa,CAACC,EAAE,CAAC,CAACM,WAAW,CAAC;IAC3C;IACA,OAAOV,QAAQ,CAACW,QAAQ,CAACF,IAAI,EAAEC,WAAW,EAAER,OAAO,CAAC;EACtD,CAAC;AACH;AAEA;AACA,SAASK,eAAeA,CAACD,SAAoB;EAC3C,MAAMM,KAAK,GAAGN,SAAS,CAACM,KAAmB;EAC3C,MAAM;IAACC,MAAM,GAAG,CAAC;IAAEC,MAAM;IAAEC;EAAI,CAAC,GAAGT,SAAS,CAACU,WAAW,EAAE;EAC1D,MAAMC,eAAe,GAAGL,KAAK,CAACM,iBAAiB;EAC/C,MAAMC,aAAa,GAAGN,MAAM,GAAGI,eAAe;EAC9C,MAAMG,aAAa,GAAGN,MAAM,GAAGA,MAAM,GAAGG,eAAe,GAAGF,IAAI;EAE9D,IAAIA,IAAI,KAAK,CAAC,EAAE;IACd;IACA,IAAIT,SAAS,CAACe,UAAU,EAAE;MACxB,OAAO,MAAMT,KAAK,CAAC,CAAC,CAAC;IACvB;IACA,OAAQF,WAAmB,IAAI;MAC7B,MAAMY,CAAC,GAAGH,aAAa,GAAGC,aAAa,GAAGV,WAAW;MACrD,OAAOE,KAAK,CAACU,CAAC,CAAC;IACjB,CAAC;EACH;EAEA;EACA,IAAIC,MAAgB;EACpB,IAAIjB,SAAS,CAACe,UAAU,EAAE;IACxBE,MAAM,GAAGC,KAAK,CAACC,IAAI,CAACb,KAAK,CAAC;IAC1B,OAAO,MAAMW,MAAM;EACrB;EAEAA,MAAM,GAAG,IAAIC,KAAK,CAACT,IAAI,CAAC;EACxB,OAAQL,WAAmB,IAAI;IAC7B,MAAMY,CAAC,GAAGH,aAAa,GAAGC,aAAa,GAAGV,WAAW;IACrD,KAAK,IAAIgB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,IAAI,EAAEW,CAAC,EAAE,EAAE;MAC7BH,MAAM,CAACG,CAAC,CAAC,GAAGd,KAAK,CAACU,CAAC,GAAGI,CAAC,CAAC;IAC1B;IACA,OAAOH,MAAM;EACf,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}