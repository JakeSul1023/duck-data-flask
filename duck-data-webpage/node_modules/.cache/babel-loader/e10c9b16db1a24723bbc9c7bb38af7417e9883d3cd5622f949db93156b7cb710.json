{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { padToNBytes, copyBinaryToDataView, copyPaddedStringToDataView } from '@loaders.gl/loader-utils';\nimport { MAGIC_ARRAY } from \"../constants.js\";\nimport { encode3DTileHeader, encode3DTileByteLength } from \"./helpers/encode-3d-tile-header.js\";\n// Procedurally encode the tile array dataView for testing purposes\nexport function encodeBatchedModel3DTile(tile, dataView, byteOffset, options) {\n  const {\n    featuresLength = 0,\n    batchTable\n  } = tile;\n  const featureTableJson = {\n    BATCH_LENGTH: featuresLength\n  };\n  const featureTableJsonString = JSON.stringify(featureTableJson);\n  const batchTableJsonString = batchTable ? JSON.stringify(batchTable) : '';\n  const featureTableJsonByteLength = padToNBytes(featureTableJsonString.length, 8);\n  const batchTableJsonByteLength = batchTableJsonString ? padToNBytes(batchTableJsonString.length, 8) : 0;\n  // Add default magic for this tile type\n  tile = {\n    magic: MAGIC_ARRAY.BATCHED_MODEL,\n    ...tile\n  };\n  const byteOffsetStart = byteOffset;\n  byteOffset = encode3DTileHeader(tile, dataView, byteOffset);\n  if (dataView) {\n    dataView.setUint32(12, featureTableJsonByteLength, true); // featureTableJsonByteLength\n    dataView.setUint32(16, 0, true); // featureTableBinaryByteLength\n    dataView.setUint32(20, batchTableJsonByteLength, true); // batchTableJsonByteLength\n    dataView.setUint32(24, 0, true); // batchTableBinaryByteLength\n  }\n  byteOffset += 16;\n  // TODO feature table binary\n  byteOffset = copyPaddedStringToDataView(dataView, byteOffset, featureTableJsonString, 8);\n  if (batchTable) {\n    byteOffset = copyPaddedStringToDataView(dataView, byteOffset, batchTableJsonString, 8);\n  }\n  // Add encoded GLTF to the end of data\n  const gltfEncoded = tile.gltfEncoded;\n  if (gltfEncoded) {\n    byteOffset = copyBinaryToDataView(dataView, byteOffset, gltfEncoded, gltfEncoded.byteLength);\n  }\n  // Go \"back\" and rewrite the tile's `byteLength` now that we know the value\n  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n  return byteOffset;\n}","map":{"version":3,"names":["padToNBytes","copyBinaryToDataView","copyPaddedStringToDataView","MAGIC_ARRAY","encode3DTileHeader","encode3DTileByteLength","encodeBatchedModel3DTile","tile","dataView","byteOffset","options","featuresLength","batchTable","featureTableJson","BATCH_LENGTH","featureTableJsonString","JSON","stringify","batchTableJsonString","featureTableJsonByteLength","length","batchTableJsonByteLength","magic","BATCHED_MODEL","byteOffsetStart","setUint32","gltfEncoded","byteLength"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/3d-tiles/dist/lib/encoders/encode-3d-tile-batched-model.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { padToNBytes, copyBinaryToDataView, copyPaddedStringToDataView } from '@loaders.gl/loader-utils';\nimport { MAGIC_ARRAY } from \"../constants.js\";\nimport { encode3DTileHeader, encode3DTileByteLength } from \"./helpers/encode-3d-tile-header.js\";\n// Procedurally encode the tile array dataView for testing purposes\nexport function encodeBatchedModel3DTile(tile, dataView, byteOffset, options) {\n    const { featuresLength = 0, batchTable } = tile;\n    const featureTableJson = {\n        BATCH_LENGTH: featuresLength\n    };\n    const featureTableJsonString = JSON.stringify(featureTableJson);\n    const batchTableJsonString = batchTable ? JSON.stringify(batchTable) : '';\n    const featureTableJsonByteLength = padToNBytes(featureTableJsonString.length, 8);\n    const batchTableJsonByteLength = batchTableJsonString\n        ? padToNBytes(batchTableJsonString.length, 8)\n        : 0;\n    // Add default magic for this tile type\n    tile = { magic: MAGIC_ARRAY.BATCHED_MODEL, ...tile };\n    const byteOffsetStart = byteOffset;\n    byteOffset = encode3DTileHeader(tile, dataView, byteOffset);\n    if (dataView) {\n        dataView.setUint32(12, featureTableJsonByteLength, true); // featureTableJsonByteLength\n        dataView.setUint32(16, 0, true); // featureTableBinaryByteLength\n        dataView.setUint32(20, batchTableJsonByteLength, true); // batchTableJsonByteLength\n        dataView.setUint32(24, 0, true); // batchTableBinaryByteLength\n    }\n    byteOffset += 16;\n    // TODO feature table binary\n    byteOffset = copyPaddedStringToDataView(dataView, byteOffset, featureTableJsonString, 8);\n    if (batchTable) {\n        byteOffset = copyPaddedStringToDataView(dataView, byteOffset, batchTableJsonString, 8);\n    }\n    // Add encoded GLTF to the end of data\n    const gltfEncoded = tile.gltfEncoded;\n    if (gltfEncoded) {\n        byteOffset = copyBinaryToDataView(dataView, byteOffset, gltfEncoded, gltfEncoded.byteLength);\n    }\n    // Go \"back\" and rewrite the tile's `byteLength` now that we know the value\n    encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n    return byteOffset;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,SAASA,WAAW,EAAEC,oBAAoB,EAAEC,0BAA0B,QAAQ,0BAA0B;AACxG,SAASC,WAAW,QAAQ,iBAAiB;AAC7C,SAASC,kBAAkB,EAAEC,sBAAsB,QAAQ,oCAAoC;AAC/F;AACA,OAAO,SAASC,wBAAwBA,CAACC,IAAI,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,OAAO,EAAE;EAC1E,MAAM;IAAEC,cAAc,GAAG,CAAC;IAAEC;EAAW,CAAC,GAAGL,IAAI;EAC/C,MAAMM,gBAAgB,GAAG;IACrBC,YAAY,EAAEH;EAClB,CAAC;EACD,MAAMI,sBAAsB,GAAGC,IAAI,CAACC,SAAS,CAACJ,gBAAgB,CAAC;EAC/D,MAAMK,oBAAoB,GAAGN,UAAU,GAAGI,IAAI,CAACC,SAAS,CAACL,UAAU,CAAC,GAAG,EAAE;EACzE,MAAMO,0BAA0B,GAAGnB,WAAW,CAACe,sBAAsB,CAACK,MAAM,EAAE,CAAC,CAAC;EAChF,MAAMC,wBAAwB,GAAGH,oBAAoB,GAC/ClB,WAAW,CAACkB,oBAAoB,CAACE,MAAM,EAAE,CAAC,CAAC,GAC3C,CAAC;EACP;EACAb,IAAI,GAAG;IAAEe,KAAK,EAAEnB,WAAW,CAACoB,aAAa;IAAE,GAAGhB;EAAK,CAAC;EACpD,MAAMiB,eAAe,GAAGf,UAAU;EAClCA,UAAU,GAAGL,kBAAkB,CAACG,IAAI,EAAEC,QAAQ,EAAEC,UAAU,CAAC;EAC3D,IAAID,QAAQ,EAAE;IACVA,QAAQ,CAACiB,SAAS,CAAC,EAAE,EAAEN,0BAA0B,EAAE,IAAI,CAAC,CAAC,CAAC;IAC1DX,QAAQ,CAACiB,SAAS,CAAC,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;IACjCjB,QAAQ,CAACiB,SAAS,CAAC,EAAE,EAAEJ,wBAAwB,EAAE,IAAI,CAAC,CAAC,CAAC;IACxDb,QAAQ,CAACiB,SAAS,CAAC,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;EACrC;EACAhB,UAAU,IAAI,EAAE;EAChB;EACAA,UAAU,GAAGP,0BAA0B,CAACM,QAAQ,EAAEC,UAAU,EAAEM,sBAAsB,EAAE,CAAC,CAAC;EACxF,IAAIH,UAAU,EAAE;IACZH,UAAU,GAAGP,0BAA0B,CAACM,QAAQ,EAAEC,UAAU,EAAES,oBAAoB,EAAE,CAAC,CAAC;EAC1F;EACA;EACA,MAAMQ,WAAW,GAAGnB,IAAI,CAACmB,WAAW;EACpC,IAAIA,WAAW,EAAE;IACbjB,UAAU,GAAGR,oBAAoB,CAACO,QAAQ,EAAEC,UAAU,EAAEiB,WAAW,EAAEA,WAAW,CAACC,UAAU,CAAC;EAChG;EACA;EACAtB,sBAAsB,CAACG,QAAQ,EAAEgB,eAAe,EAAEf,UAAU,GAAGe,eAAe,CAAC;EAC/E,OAAOf,UAAU;AACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}