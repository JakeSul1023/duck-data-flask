{"ast":null,"code":"import { log, TransformFeedback } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\nimport { WEBGLBuffer } from \"../../index.js\";\nimport { getGLPrimitive } from \"../helpers/webgl-topology-utils.js\";\nexport class WEBGLTransformFeedback extends TransformFeedback {\n  device;\n  gl;\n  handle;\n  /**\n   * NOTE: The Model already has this information while drawing, but\n   * TransformFeedback currently needs it internally, to look up\n   * varying information outside of a draw() call.\n   */\n  layout;\n  buffers = {};\n  unusedBuffers = {};\n  /**\n   * Allows us to avoid a Chrome bug where a buffer that is already bound to a\n   * different target cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n   * This a major workaround, see: https://github.com/KhronosGroup/WebGL/issues/2346\n   */\n  bindOnUse = true;\n  _bound = false;\n  constructor(device, props) {\n    super(device, props);\n    this.device = device;\n    this.gl = device.gl;\n    this.handle = this.props.handle || this.gl.createTransformFeedback();\n    this.layout = this.props.layout;\n    if (props.buffers) {\n      this.setBuffers(props.buffers);\n    }\n    Object.seal(this);\n  }\n  destroy() {\n    this.gl.deleteTransformFeedback(this.handle);\n    super.destroy();\n  }\n  begin() {\n    let topology = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'point-list';\n    this.gl.bindTransformFeedback(36386, this.handle);\n    if (this.bindOnUse) {\n      this._bindBuffers();\n    }\n    this.gl.beginTransformFeedback(getGLPrimitive(topology));\n  }\n  end() {\n    this.gl.endTransformFeedback();\n    if (this.bindOnUse) {\n      this._unbindBuffers();\n    }\n    this.gl.bindTransformFeedback(36386, null);\n  }\n  // SUBCLASS\n  setBuffers(buffers) {\n    this.buffers = {};\n    this.unusedBuffers = {};\n    this.bind(() => {\n      for (const bufferName in buffers) {\n        this.setBuffer(bufferName, buffers[bufferName]);\n      }\n    });\n  }\n  setBuffer(locationOrName, bufferOrRange) {\n    const location = this._getVaryingIndex(locationOrName);\n    const {\n      buffer,\n      byteLength,\n      byteOffset\n    } = this._getBufferRange(bufferOrRange);\n    if (location < 0) {\n      this.unusedBuffers[locationOrName] = buffer;\n      log.warn(`${this.id} unusedBuffers varying buffer ${locationOrName}`)();\n      return;\n    }\n    this.buffers[location] = {\n      buffer,\n      byteLength,\n      byteOffset\n    };\n    // Need to avoid chrome bug where buffer that is already bound to a different target\n    // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n    if (!this.bindOnUse) {\n      this._bindBuffer(location, buffer, byteOffset, byteLength);\n    }\n  }\n  getBuffer(locationOrName) {\n    if (isIndex(locationOrName)) {\n      return this.buffers[locationOrName] || null;\n    }\n    const location = this._getVaryingIndex(locationOrName);\n    return location >= 0 ? this.buffers[location] : null;\n  }\n  bind() {\n    let funcOrHandle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.handle;\n    if (typeof funcOrHandle !== 'function') {\n      this.gl.bindTransformFeedback(36386, funcOrHandle);\n      return this;\n    }\n    let value;\n    if (!this._bound) {\n      this.gl.bindTransformFeedback(36386, this.handle);\n      this._bound = true;\n      value = funcOrHandle();\n      this._bound = false;\n      this.gl.bindTransformFeedback(36386, null);\n    } else {\n      value = funcOrHandle();\n    }\n    return value;\n  }\n  unbind() {\n    this.bind(null);\n  }\n  // PRIVATE METHODS\n  /** Extract offsets for bindBufferRange */\n  _getBufferRange(bufferOrRange) {\n    if (bufferOrRange instanceof WEBGLBuffer) {\n      return {\n        buffer: bufferOrRange,\n        byteOffset: 0,\n        byteLength: bufferOrRange.byteLength\n      };\n    }\n    // To use bindBufferRange either offset or size must be specified.\n    // @ts-expect-error Must be a BufferRange.\n    const {\n      buffer,\n      byteOffset = 0,\n      byteLength = bufferOrRange.buffer.byteLength\n    } = bufferOrRange;\n    return {\n      buffer,\n      byteOffset,\n      byteLength\n    };\n  }\n  _getVaryingIndex(locationOrName) {\n    if (isIndex(locationOrName)) {\n      return Number(locationOrName);\n    }\n    for (const varying of this.layout.varyings) {\n      if (locationOrName === varying.name) {\n        return varying.location;\n      }\n    }\n    return -1;\n  }\n  /**\n   * Need to avoid chrome bug where buffer that is already bound to a different target\n   * cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n   */\n  _bindBuffers() {\n    for (const bufferIndex in this.buffers) {\n      const {\n        buffer,\n        byteLength,\n        byteOffset\n      } = this._getBufferRange(this.buffers[bufferIndex]);\n      this._bindBuffer(Number(bufferIndex), buffer, byteOffset, byteLength);\n    }\n  }\n  _unbindBuffers() {\n    for (const bufferIndex in this.buffers) {\n      this.gl.bindBufferBase(35982, Number(bufferIndex), null);\n    }\n  }\n  _bindBuffer(index, buffer) {\n    let byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let byteLength = arguments.length > 3 ? arguments[3] : undefined;\n    const handle = buffer && buffer.handle;\n    if (!handle || byteLength === undefined) {\n      this.gl.bindBufferBase(35982, index, handle);\n    } else {\n      this.gl.bindBufferRange(35982, index, handle, byteOffset, byteLength);\n    }\n  }\n}\n/**\n * Returns true if the given value is an integer, or a string that\n * trivially converts to an integer (only numeric characters).\n */\nfunction isIndex(value) {\n  if (typeof value === 'number') {\n    return Number.isInteger(value);\n  }\n  return /^\\d+$/.test(value);\n}\n//# sourceMappingURL=webgl-transform-feedback.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}