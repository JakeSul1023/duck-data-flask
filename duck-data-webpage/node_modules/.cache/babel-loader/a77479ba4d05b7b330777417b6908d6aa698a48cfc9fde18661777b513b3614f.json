{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getSchemaFromTileJSONLayer } from \"./get-schemas-from-tilejson.js\";\nconst isObject = x => x !== null && typeof x === 'object';\n/**\n * Parse TileJSON from metadata\n * @param jsonMetadata - metadata object\n * @param options - options\n * @returns - parsed TileJSON\n */\n// eslint-disable-next-line complexity\nexport function parseTileJSON(jsonMetadata, options) {\n  if (!jsonMetadata || !isObject(jsonMetadata)) {\n    return null;\n  }\n  let tileJSON = {\n    name: jsonMetadata.name || '',\n    description: jsonMetadata.description || ''\n  };\n  // tippecanoe\n  if (typeof jsonMetadata.generator === 'string') {\n    tileJSON.generator = jsonMetadata.generator;\n  }\n  if (typeof jsonMetadata.generator_options === 'string') {\n    tileJSON.generatorOptions = jsonMetadata.generator_options;\n  }\n  // Tippecanoe emits `antimeridian_adjusted_bounds` instead of `bounds`\n  tileJSON.boundingBox = parseBounds(jsonMetadata.bounds) || parseBounds(jsonMetadata.antimeridian_adjusted_bounds);\n  // TODO - can be undefined - we could set to center of bounds...\n  tileJSON.center = parseCenter(jsonMetadata.center);\n  // TODO - can be undefined, we could extract from layers...\n  tileJSON.maxZoom = safeParseFloat(jsonMetadata.maxzoom);\n  // TODO - can be undefined, we could extract from layers...\n  tileJSON.minZoom = safeParseFloat(jsonMetadata.minzoom);\n  // Look for nested metadata embedded in .json field\n  // TODO - document what source this applies to, when is this needed?\n  if (typeof jsonMetadata?.json === 'string') {\n    // try to parse json\n    try {\n      tileJSON.metaJson = JSON.parse(jsonMetadata.json);\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      console.warn('Failed to parse tilejson.json field', error);\n      // do nothing\n    }\n  }\n  // Look for fields in tilestats\n  const tilestats = jsonMetadata.tilestats || tileJSON.metaJson?.tilestats;\n  const tileStatsLayers = parseTilestatsLayers(tilestats, options);\n  const tileJSONlayers = parseTileJSONLayers(jsonMetadata.vector_layers); // eslint-disable-line camelcase\n  // TODO - merge in description from tilejson\n  const layers = mergeLayers(tileJSONlayers, tileStatsLayers);\n  tileJSON = {\n    ...tileJSON,\n    layers\n  };\n  if (tileJSON.maxZoom === null && layers.length > 0) {\n    tileJSON.maxZoom = layers[0].maxZoom || null;\n  }\n  if (tileJSON.minZoom === null && layers.length > 0) {\n    tileJSON.minZoom = layers[0].minZoom || null;\n  }\n  return tileJSON;\n}\nfunction parseTileJSONLayers(layers) {\n  // Look for fields in vector_layers\n  if (!Array.isArray(layers)) {\n    return [];\n  }\n  return layers.map(layer => parseTileJSONLayer(layer));\n}\nfunction parseTileJSONLayer(layer) {\n  const fields = Object.entries(layer.fields || []).map(([key, datatype]) => ({\n    name: key,\n    ...attributeTypeToFieldType(String(datatype))\n  }));\n  const layer2 = {\n    ...layer\n  };\n  delete layer2.fields;\n  return {\n    name: layer.id || '',\n    ...layer2,\n    fields\n  };\n}\n/** parse Layers array from tilestats */\nfunction parseTilestatsLayers(tilestats, options) {\n  if (isObject(tilestats) && Array.isArray(tilestats.layers)) {\n    // we are in luck!\n    return tilestats.layers.map(layer => parseTilestatsForLayer(layer, options));\n  }\n  return [];\n}\nfunction parseTilestatsForLayer(layer, options) {\n  const fields = [];\n  const indexedAttributes = {};\n  const attributes = layer.attributes || [];\n  for (const attribute of attributes) {\n    const name = attribute.attribute;\n    if (typeof name === 'string') {\n      // TODO - code copied from kepler.gl, need sample tilestats files to test\n      if (name.split('|').length > 1) {\n        // indexed field\n        const fname = name.split('|')[0];\n        indexedAttributes[fname] = indexedAttributes[fname] || [];\n        indexedAttributes[fname].push(attribute);\n        // eslint-disable-next-line no-console\n        console.warn('ignoring tilestats indexed field', fname);\n      } else if (!fields[name]) {\n        fields.push(attributeToField(attribute, options));\n      } else {\n        // return (fields[name], attribute);\n      }\n    }\n  }\n  return {\n    name: layer.layer || '',\n    dominantGeometry: layer.geometry,\n    fields\n  };\n}\nfunction mergeLayers(layers, tilestatsLayers) {\n  return layers.map(layer => {\n    const tilestatsLayer = tilestatsLayers.find(tsLayer => tsLayer.name === layer.name);\n    const fields = tilestatsLayer?.fields || layer.fields || [];\n    const mergedLayer = {\n      ...layer,\n      ...tilestatsLayer,\n      fields\n    };\n    mergedLayer.schema = getSchemaFromTileJSONLayer(mergedLayer);\n    return mergedLayer;\n  });\n}\n/**\n * bounds should be [minLng, minLat, maxLng, maxLat]\n *`[[w, s], [e, n]]`, indicates the limits of the bounding box using the axis units and order of the specified CRS.\n */\nfunction parseBounds(bounds) {\n  // supported formats\n  // string: \"-96.657715,40.126127,-90.140061,43.516689\",\n  // array: [ -180, -85.05112877980659, 180, 85.0511287798066 ]\n  const result = fromArrayOrString(bounds);\n  // validate bounds\n  if (Array.isArray(result) && result.length === 4 && [result[0], result[2]].every(isLng) && [result[1], result[3]].every(isLat)) {\n    return [[result[0], result[1]], [result[2], result[3]]];\n  }\n  return undefined;\n}\nfunction parseCenter(center) {\n  // supported formats\n  // string: \"-96.657715,40.126127,-90.140061,43.516689\",\n  // array: [-91.505127,41.615442,14]\n  const result = fromArrayOrString(center);\n  if (Array.isArray(result) && result.length === 3 && isLng(result[0]) && isLat(result[1]) && isZoom(result[2])) {\n    return result;\n  }\n  return null;\n}\nfunction safeParseFloat(input) {\n  const result = typeof input === 'string' ? parseFloat(input) : typeof input === 'number' ? input : null;\n  return result === null || isNaN(result) ? null : result;\n}\n// https://github.com/mapbox/tilejson-spec/tree/master/2.2.0\nfunction isLat(num) {\n  return Number.isFinite(num) && num <= 90 && num >= -90;\n}\nfunction isLng(num) {\n  return Number.isFinite(num) && num <= 180 && num >= -180;\n}\nfunction isZoom(num) {\n  return Number.isFinite(num) && num >= 0 && num <= 22;\n}\nfunction fromArrayOrString(data) {\n  if (typeof data === 'string') {\n    return data.split(',').map(parseFloat);\n  } else if (Array.isArray(data)) {\n    return data;\n  }\n  return null;\n}\n// possible types https://github.com/mapbox/tippecanoe#modifying-feature-attributes\nconst attrTypeMap = {\n  number: {\n    type: 'float32'\n  },\n  numeric: {\n    type: 'float32'\n  },\n  string: {\n    type: 'utf8'\n  },\n  vachar: {\n    type: 'utf8'\n  },\n  float: {\n    type: 'float32'\n  },\n  int: {\n    type: 'int32'\n  },\n  int4: {\n    type: 'int32'\n  },\n  boolean: {\n    type: 'boolean'\n  },\n  bool: {\n    type: 'boolean'\n  }\n};\nfunction attributeToField(attribute = {}, options) {\n  const fieldTypes = attributeTypeToFieldType(attribute.type);\n  const field = {\n    name: attribute.attribute,\n    // what happens if attribute type is string...\n    // filterProps: getFilterProps(fieldTypes.type, attribute),\n    ...fieldTypes\n  };\n  // attribute: \"_season_peaks_color\"\n  // count: 1000\n  // max: 0.95\n  // min: 0.24375\n  // type: \"number\"\n  if (typeof attribute.min === 'number') {\n    field.min = attribute.min;\n  }\n  if (typeof attribute.max === 'number') {\n    field.max = attribute.max;\n  }\n  if (typeof attribute.count === 'number') {\n    field.uniqueValueCount = attribute.count;\n  }\n  if (attribute.values) {\n    // Too much data? Add option?\n    field.values = attribute.values;\n  }\n  if (field.values && typeof options.maxValues === 'number') {\n    // Too much data? Add option?\n    field.values = field.values?.slice(0, options.maxValues);\n  }\n  return field;\n}\nfunction attributeTypeToFieldType(aType) {\n  const type = aType.toLowerCase();\n  if (!type || !attrTypeMap[type]) {\n    // console.warn(\n    //   `cannot convert attribute type ${type} to loaders.gl data type, use string by default`\n    // );\n  }\n  return attrTypeMap[type] || {\n    type: 'string'\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}