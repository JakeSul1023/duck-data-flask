{"ast":null,"code":"// loaders./gl, MIT license\nimport { padToNBytes } from \"./memory-copy-utils.js\";\n/**\n * Helper function that pads a string with spaces to fit a certain byte alignment\n * @param string\n * @param byteAlignment\n * @returns\n *\n * @todo PERFORMANCE IDEA: No need to copy string twice...\n */\nexport function padStringToByteAlignment(string, byteAlignment) {\n  const length = string.length;\n  const paddedLength = Math.ceil(length / byteAlignment) * byteAlignment; // Round up to the required alignment\n  const padding = paddedLength - length;\n  let whitespace = '';\n  for (let i = 0; i < padding; ++i) {\n    whitespace += ' ';\n  }\n  return string + whitespace;\n}\n/**\n *\n * @param dataView\n * @param byteOffset\n * @param string\n * @param byteLength\n * @returns\n */\nexport function copyStringToDataView(dataView, byteOffset, string, byteLength) {\n  if (dataView) {\n    for (let i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, string.charCodeAt(i));\n    }\n  }\n  return byteOffset + byteLength;\n}\nexport function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {\n  if (dataView) {\n    for (let i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, binary[i]);\n    }\n  }\n  return byteOffset + byteLength;\n}\n/**\n * Copy sourceBuffer to dataView with some padding\n *\n * @param dataView - destination data container. If null - only new offset is calculated\n * @param byteOffset - destination byte offset to copy to\n * @param sourceBuffer - source data buffer\n * @param padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer, padding) {\n  const paddedLength = padToNBytes(sourceBuffer.byteLength, padding);\n  const padLength = paddedLength - sourceBuffer.byteLength;\n  if (dataView) {\n    // Copy array\n    const targetArray = new Uint8Array(dataView.buffer, dataView.byteOffset + byteOffset, sourceBuffer.byteLength);\n    const sourceArray = new Uint8Array(sourceBuffer);\n    targetArray.set(sourceArray);\n    // Add PADDING\n    for (let i = 0; i < padLength; ++i) {\n      // json chunk is padded with spaces (ASCII 0x20)\n      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);\n    }\n  }\n  byteOffset += paddedLength;\n  return byteOffset;\n}\n/**\n * Copy string to dataView with some padding\n *\n * @param {DataView | null} dataView - destination data container. If null - only new offset is calculated\n * @param {number} byteOffset - destination byte offset to copy to\n * @param {string} string - source string\n * @param {number} padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedStringToDataView(dataView, byteOffset, string, padding) {\n  const textEncoder = new TextEncoder();\n  // PERFORMANCE IDEA: We encode twice, once to get size and once to store\n  // PERFORMANCE IDEA: Use TextEncoder.encodeInto() to avoid temporary copy\n  const stringBuffer = textEncoder.encode(string);\n  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);\n  return byteOffset;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}