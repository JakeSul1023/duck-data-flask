{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = /* glsl */`\\\nuniform dataFilterUniforms {\n  bool useSoftMargin;\n  bool enabled;\n  bool transformSize;\n  bool transformColor;\n#ifdef DATAFILTER_TYPE\n  DATAFILTER_TYPE min;\n  DATAFILTER_TYPE softMin;\n  DATAFILTER_TYPE softMax;\n  DATAFILTER_TYPE max;\n#ifdef DATAFILTER_DOUBLE\n  DATAFILTER_TYPE min64High;\n  DATAFILTER_TYPE max64High;\n#endif\n#endif\n#ifdef DATACATEGORY_TYPE\n  highp uvec4 categoryBitMask;\n#endif\n} dataFilter;\n`;\nconst vertex = /* glsl */`\n#ifdef DATAFILTER_TYPE\n  in DATAFILTER_TYPE filterValues;\n#ifdef DATAFILTER_DOUBLE\n  in DATAFILTER_TYPE filterValues64Low;\n#endif\n#endif\n\n#ifdef DATACATEGORY_TYPE\n  in DATACATEGORY_TYPE filterCategoryValues;\n#endif\n\nout float dataFilter_value;\n\nfloat dataFilter_reduceValue(float value) {\n  return value;\n}\nfloat dataFilter_reduceValue(vec2 value) {\n  return min(value.x, value.y);\n}\nfloat dataFilter_reduceValue(vec3 value) {\n  return min(min(value.x, value.y), value.z);\n}\nfloat dataFilter_reduceValue(vec4 value) {\n  return min(min(value.x, value.y), min(value.z, value.w));\n}\n\n#ifdef DATAFILTER_TYPE\n  void dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax) {\n    if (dataFilter.useSoftMargin) {\n      // smoothstep results are undefined if edge0 â‰¥ edge1\n      // Fallback to ignore filterSoftRange if it is truncated by filterRange\n      DATAFILTER_TYPE leftInRange = mix(\n        smoothstep(dataFilter.min, dataFilter.softMin, valueFromMin),\n        step(dataFilter.min, valueFromMin),\n        step(dataFilter.softMin, dataFilter.min)\n      );\n      DATAFILTER_TYPE rightInRange = mix(\n        1.0 - smoothstep(dataFilter.softMax, dataFilter.max, valueFromMax),\n        step(valueFromMax, dataFilter.max),\n        step(dataFilter.max, dataFilter.softMax)\n      );\n      dataFilter_value = dataFilter_reduceValue(leftInRange * rightInRange);\n    } else {\n      dataFilter_value = dataFilter_reduceValue(\n        step(dataFilter.min, valueFromMin) * step(valueFromMax, dataFilter.max)\n      );\n    }\n  }\n#endif\n\n#ifdef DATACATEGORY_TYPE\n  void dataFilter_setCategoryValue(DATACATEGORY_TYPE category) {\n    #if DATACATEGORY_CHANNELS == 1 // One 128-bit mask\n    uint dataFilter_masks = dataFilter.categoryBitMask[category / 32u];\n    #elif DATACATEGORY_CHANNELS == 2 // Two 64-bit masks\n    uvec2 dataFilter_masks = uvec2(\n      dataFilter.categoryBitMask[category.x / 32u],\n      dataFilter.categoryBitMask[category.y / 32u + 2u]\n    );\n    #elif DATACATEGORY_CHANNELS == 3 // Three 32-bit masks\n    uvec3 dataFilter_masks = dataFilter.categoryBitMask.xyz;\n    #else // Four 32-bit masks\n    uvec4 dataFilter_masks = dataFilter.categoryBitMask;\n    #endif\n\n    // Shift mask and extract relevant bits\n    DATACATEGORY_TYPE dataFilter_bits = DATACATEGORY_TYPE(dataFilter_masks) >> (category & 31u);\n    dataFilter_bits &= 1u;\n\n    #if DATACATEGORY_CHANNELS == 1\n    if(dataFilter_bits == 0u) dataFilter_value = 0.0;\n    #else\n    if(any(equal(dataFilter_bits, DATACATEGORY_TYPE(0u)))) dataFilter_value = 0.0;\n    #endif\n  }\n#endif\n`;\nconst vs = `\n${uniformBlock}\n${vertex}\n`;\nconst fragment = /* glsl */`\nin float dataFilter_value;\n`;\nconst fs = `\n${uniformBlock}\n${fragment}\n`;\n/* eslint-disable camelcase */\nfunction getUniforms(opts) {\n  if (!opts || !('extensions' in opts)) {\n    return {};\n  }\n  const {\n    filterRange = [-1, 1],\n    filterEnabled = true,\n    filterTransformSize = true,\n    filterTransformColor = true,\n    categoryBitMask\n  } = opts;\n  const filterSoftRange = opts.filterSoftRange || filterRange;\n  return {\n    ...(Number.isFinite(filterRange[0]) ? {\n      min: filterRange[0],\n      softMin: filterSoftRange[0],\n      softMax: filterSoftRange[1],\n      max: filterRange[1]\n    } : {\n      min: filterRange.map(r => r[0]),\n      softMin: filterSoftRange.map(r => r[0]),\n      softMax: filterSoftRange.map(r => r[1]),\n      max: filterRange.map(r => r[1])\n    }),\n    enabled: filterEnabled,\n    useSoftMargin: Boolean(opts.filterSoftRange),\n    transformSize: filterEnabled && filterTransformSize,\n    transformColor: filterEnabled && filterTransformColor,\n    ...(categoryBitMask && {\n      categoryBitMask\n    })\n  };\n}\nfunction getUniforms64(opts) {\n  if (!opts || !('extensions' in opts)) {\n    return {};\n  }\n  const uniforms = getUniforms(opts);\n  if (Number.isFinite(uniforms.min)) {\n    const min64High = Math.fround(uniforms.min);\n    uniforms.min -= min64High;\n    uniforms.softMin -= min64High;\n    uniforms.min64High = min64High;\n    const max64High = Math.fround(uniforms.max);\n    uniforms.max -= max64High;\n    uniforms.softMax -= max64High;\n    uniforms.max64High = max64High;\n  } else {\n    const min64High = uniforms.min.map(Math.fround);\n    uniforms.min = uniforms.min.map((x, i) => x - min64High[i]);\n    uniforms.softMin = uniforms.softMin.map((x, i) => x - min64High[i]);\n    uniforms.min64High = min64High;\n    const max64High = uniforms.max.map(Math.fround);\n    uniforms.max = uniforms.max.map((x, i) => x - max64High[i]);\n    uniforms.softMax = uniforms.softMax.map((x, i) => x - max64High[i]);\n    uniforms.max64High = max64High;\n  }\n  return uniforms;\n}\nconst inject = {\n  'vs:#main-start': /* glsl */`\n    dataFilter_value = 1.0;\n    if (dataFilter.enabled) {\n      #ifdef DATAFILTER_TYPE\n        #ifdef DATAFILTER_DOUBLE\n          dataFilter_setValue(\n            filterValues - dataFilter.min64High + filterValues64Low,\n            filterValues - dataFilter.max64High + filterValues64Low\n          );\n        #else\n          dataFilter_setValue(filterValues, filterValues);\n        #endif\n      #endif\n\n      #ifdef DATACATEGORY_TYPE\n        dataFilter_setCategoryValue(filterCategoryValues);\n      #endif\n    }\n  `,\n  'vs:#main-end': /* glsl */`\n    if (dataFilter_value == 0.0) {\n      gl_Position = vec4(0.);\n    }\n  `,\n  'vs:DECKGL_FILTER_SIZE': /* glsl */`\n    if (dataFilter.transformSize) {\n      size = size * dataFilter_value;\n    }\n  `,\n  'fs:DECKGL_FILTER_COLOR': /* glsl */`\n    if (dataFilter_value == 0.0) discard;\n    if (dataFilter.transformColor) {\n      color.a *= dataFilter_value;\n    }\n  `\n};\nfunction uniformTypesFromOptions(opts) {\n  const {\n    categorySize,\n    filterSize,\n    fp64\n  } = opts;\n  const uniformTypes = {\n    useSoftMargin: 'i32',\n    enabled: 'i32',\n    transformSize: 'i32',\n    transformColor: 'i32'\n  };\n  if (filterSize) {\n    const uniformFormat = filterSize === 1 ? 'f32' : `vec${filterSize}<f32>`;\n    uniformTypes.min = uniformFormat;\n    uniformTypes.softMin = uniformFormat;\n    uniformTypes.softMax = uniformFormat;\n    uniformTypes.max = uniformFormat;\n    if (fp64) {\n      uniformTypes.min64High = uniformFormat;\n      uniformTypes.max64High = uniformFormat;\n    }\n  }\n  if (categorySize) {\n    uniformTypes.categoryBitMask = 'vec4<i32>';\n  }\n  return uniformTypes;\n}\nexport const dataFilter = {\n  name: 'dataFilter',\n  vs,\n  fs,\n  inject,\n  getUniforms,\n  uniformTypesFromOptions\n};\nexport const dataFilter64 = {\n  name: 'dataFilter',\n  vs,\n  fs,\n  inject,\n  getUniforms: getUniforms64,\n  uniformTypesFromOptions\n};","map":{"version":3,"names":["uniformBlock","vertex","vs","fragment","fs","getUniforms","opts","filterRange","filterEnabled","filterTransformSize","filterTransformColor","categoryBitMask","filterSoftRange","Number","isFinite","min","softMin","softMax","max","map","r","enabled","useSoftMargin","Boolean","transformSize","transformColor","getUniforms64","uniforms","min64High","Math","fround","max64High","x","i","inject","uniformTypesFromOptions","categorySize","filterSize","fp64","uniformTypes","uniformFormat","dataFilter","name","dataFilter64"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\extensions\\src\\data-filter\\shader-module.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\nimport type {DataFilterExtensionOptions, DataFilterExtensionProps} from './data-filter-extension';\nimport {UniformFormat} from '@luma.gl/shadertools/dist/types';\n\n/*\n * data filter shader module\n */\nexport type Defines = {\n  // Defines passed externally\n  /**\n   * Primitive type of parameter used for category filtering. If undefined, category filtering disabled.\n   */\n  DATACATEGORY_TYPE?: 'uint' | 'uvec2' | 'uvec3' | 'uvec4';\n  /**\n   * Number of category filtering channels. Must match dimension of `DATACATEGORY_TYPE`\n   */\n  DATACATEGORY_CHANNELS?: 1 | 2 | 3 | 4;\n\n  /**\n   * Primitive type of parameter used for numeric filtering. If undefined, numeric filtering disabled.\n   */\n  DATAFILTER_TYPE?: 'float' | 'vec2' | 'vec3' | 'vec4';\n\n  /**\n   * Enable 64-bit precision in numeric filter.\n   */\n  DATAFILTER_DOUBLE?: boolean;\n};\n\nconst uniformBlock = /* glsl */ `\\\nuniform dataFilterUniforms {\n  bool useSoftMargin;\n  bool enabled;\n  bool transformSize;\n  bool transformColor;\n#ifdef DATAFILTER_TYPE\n  DATAFILTER_TYPE min;\n  DATAFILTER_TYPE softMin;\n  DATAFILTER_TYPE softMax;\n  DATAFILTER_TYPE max;\n#ifdef DATAFILTER_DOUBLE\n  DATAFILTER_TYPE min64High;\n  DATAFILTER_TYPE max64High;\n#endif\n#endif\n#ifdef DATACATEGORY_TYPE\n  highp uvec4 categoryBitMask;\n#endif\n} dataFilter;\n`;\n\nconst vertex = /* glsl */ `\n#ifdef DATAFILTER_TYPE\n  in DATAFILTER_TYPE filterValues;\n#ifdef DATAFILTER_DOUBLE\n  in DATAFILTER_TYPE filterValues64Low;\n#endif\n#endif\n\n#ifdef DATACATEGORY_TYPE\n  in DATACATEGORY_TYPE filterCategoryValues;\n#endif\n\nout float dataFilter_value;\n\nfloat dataFilter_reduceValue(float value) {\n  return value;\n}\nfloat dataFilter_reduceValue(vec2 value) {\n  return min(value.x, value.y);\n}\nfloat dataFilter_reduceValue(vec3 value) {\n  return min(min(value.x, value.y), value.z);\n}\nfloat dataFilter_reduceValue(vec4 value) {\n  return min(min(value.x, value.y), min(value.z, value.w));\n}\n\n#ifdef DATAFILTER_TYPE\n  void dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax) {\n    if (dataFilter.useSoftMargin) {\n      // smoothstep results are undefined if edge0 â‰¥ edge1\n      // Fallback to ignore filterSoftRange if it is truncated by filterRange\n      DATAFILTER_TYPE leftInRange = mix(\n        smoothstep(dataFilter.min, dataFilter.softMin, valueFromMin),\n        step(dataFilter.min, valueFromMin),\n        step(dataFilter.softMin, dataFilter.min)\n      );\n      DATAFILTER_TYPE rightInRange = mix(\n        1.0 - smoothstep(dataFilter.softMax, dataFilter.max, valueFromMax),\n        step(valueFromMax, dataFilter.max),\n        step(dataFilter.max, dataFilter.softMax)\n      );\n      dataFilter_value = dataFilter_reduceValue(leftInRange * rightInRange);\n    } else {\n      dataFilter_value = dataFilter_reduceValue(\n        step(dataFilter.min, valueFromMin) * step(valueFromMax, dataFilter.max)\n      );\n    }\n  }\n#endif\n\n#ifdef DATACATEGORY_TYPE\n  void dataFilter_setCategoryValue(DATACATEGORY_TYPE category) {\n    #if DATACATEGORY_CHANNELS == 1 // One 128-bit mask\n    uint dataFilter_masks = dataFilter.categoryBitMask[category / 32u];\n    #elif DATACATEGORY_CHANNELS == 2 // Two 64-bit masks\n    uvec2 dataFilter_masks = uvec2(\n      dataFilter.categoryBitMask[category.x / 32u],\n      dataFilter.categoryBitMask[category.y / 32u + 2u]\n    );\n    #elif DATACATEGORY_CHANNELS == 3 // Three 32-bit masks\n    uvec3 dataFilter_masks = dataFilter.categoryBitMask.xyz;\n    #else // Four 32-bit masks\n    uvec4 dataFilter_masks = dataFilter.categoryBitMask;\n    #endif\n\n    // Shift mask and extract relevant bits\n    DATACATEGORY_TYPE dataFilter_bits = DATACATEGORY_TYPE(dataFilter_masks) >> (category & 31u);\n    dataFilter_bits &= 1u;\n\n    #if DATACATEGORY_CHANNELS == 1\n    if(dataFilter_bits == 0u) dataFilter_value = 0.0;\n    #else\n    if(any(equal(dataFilter_bits, DATACATEGORY_TYPE(0u)))) dataFilter_value = 0.0;\n    #endif\n  }\n#endif\n`;\n\nconst vs = `\n${uniformBlock}\n${vertex}\n`;\n\nconst fragment = /* glsl */ `\nin float dataFilter_value;\n`;\n\nconst fs = `\n${uniformBlock}\n${fragment}\n`;\n\nexport type CategoryBitMask = Uint32Array;\nexport type DataFilterModuleProps = {\n  extensions: any[]; // used to detect if layer props are present\n  categoryBitMask?: CategoryBitMask;\n} & DataFilterExtensionProps;\n\n/* eslint-disable camelcase */\nfunction getUniforms(opts?: DataFilterModuleProps | {}): Record<string, any> {\n  if (!opts || !('extensions' in opts)) {\n    return {};\n  }\n  const {\n    filterRange = [-1, 1],\n    filterEnabled = true,\n    filterTransformSize = true,\n    filterTransformColor = true,\n    categoryBitMask\n  } = opts;\n  const filterSoftRange = opts.filterSoftRange || filterRange;\n\n  return {\n    ...(Number.isFinite(filterRange[0])\n      ? {\n          min: filterRange[0],\n          softMin: filterSoftRange[0],\n          softMax: filterSoftRange[1],\n          max: filterRange[1]\n        }\n      : {\n          min: filterRange.map(r => r[0]),\n          softMin: filterSoftRange.map(r => r[0]),\n          softMax: filterSoftRange.map(r => r[1]),\n          max: filterRange.map(r => r[1])\n        }),\n    enabled: filterEnabled,\n    useSoftMargin: Boolean(opts.filterSoftRange),\n    transformSize: filterEnabled && filterTransformSize,\n    transformColor: filterEnabled && filterTransformColor,\n    ...(categoryBitMask && {categoryBitMask})\n  };\n}\n\nfunction getUniforms64(opts?: DataFilterModuleProps | {}): Record<string, any> {\n  if (!opts || !('extensions' in opts)) {\n    return {};\n  }\n  const uniforms = getUniforms(opts);\n  if (Number.isFinite(uniforms.min)) {\n    const min64High = Math.fround(uniforms.min);\n    uniforms.min -= min64High;\n    uniforms.softMin -= min64High;\n    uniforms.min64High = min64High;\n\n    const max64High = Math.fround(uniforms.max);\n    uniforms.max -= max64High;\n    uniforms.softMax -= max64High;\n    uniforms.max64High = max64High;\n  } else {\n    const min64High = uniforms.min.map(Math.fround);\n    uniforms.min = uniforms.min.map((x, i) => x - min64High[i]);\n    uniforms.softMin = uniforms.softMin.map((x, i) => x - min64High[i]);\n    uniforms.min64High = min64High;\n\n    const max64High = uniforms.max.map(Math.fround);\n    uniforms.max = uniforms.max.map((x, i) => x - max64High[i]);\n    uniforms.softMax = uniforms.softMax.map((x, i) => x - max64High[i]);\n    uniforms.max64High = max64High;\n  }\n  return uniforms;\n}\n\nconst inject = {\n  'vs:#main-start': /* glsl */ `\n    dataFilter_value = 1.0;\n    if (dataFilter.enabled) {\n      #ifdef DATAFILTER_TYPE\n        #ifdef DATAFILTER_DOUBLE\n          dataFilter_setValue(\n            filterValues - dataFilter.min64High + filterValues64Low,\n            filterValues - dataFilter.max64High + filterValues64Low\n          );\n        #else\n          dataFilter_setValue(filterValues, filterValues);\n        #endif\n      #endif\n\n      #ifdef DATACATEGORY_TYPE\n        dataFilter_setCategoryValue(filterCategoryValues);\n      #endif\n    }\n  `,\n\n  'vs:#main-end': /* glsl */ `\n    if (dataFilter_value == 0.0) {\n      gl_Position = vec4(0.);\n    }\n  `,\n\n  'vs:DECKGL_FILTER_SIZE': /* glsl */ `\n    if (dataFilter.transformSize) {\n      size = size * dataFilter_value;\n    }\n  `,\n\n  'fs:DECKGL_FILTER_COLOR': /* glsl */ `\n    if (dataFilter_value == 0.0) discard;\n    if (dataFilter.transformColor) {\n      color.a *= dataFilter_value;\n    }\n  `\n};\n\ntype UniformTypesFunc = (opts: DataFilterExtensionOptions) => any;\nfunction uniformTypesFromOptions(opts: DataFilterExtensionOptions): any {\n  const {categorySize, filterSize, fp64} = opts;\n  const uniformTypes: Record<string, UniformFormat> = {\n    useSoftMargin: 'i32',\n    enabled: 'i32',\n    transformSize: 'i32',\n    transformColor: 'i32'\n  };\n\n  if (filterSize) {\n    const uniformFormat: UniformFormat = filterSize === 1 ? 'f32' : `vec${filterSize}<f32>`;\n    uniformTypes.min = uniformFormat;\n    uniformTypes.softMin = uniformFormat;\n    uniformTypes.softMax = uniformFormat;\n    uniformTypes.max = uniformFormat;\n    if (fp64) {\n      uniformTypes.min64High = uniformFormat;\n      uniformTypes.max64High = uniformFormat;\n    }\n  }\n\n  if (categorySize) {\n    uniformTypes.categoryBitMask = 'vec4<i32>';\n  }\n\n  return uniformTypes;\n}\n\nexport const dataFilter: ShaderModule<DataFilterModuleProps> & {\n  uniformTypesFromOptions: UniformTypesFunc;\n} = {\n  name: 'dataFilter',\n  vs,\n  fs,\n  inject,\n  getUniforms,\n  uniformTypesFromOptions\n};\n\nexport const dataFilter64: ShaderModule<DataFilterModuleProps> & {\n  uniformTypesFromOptions: UniformTypesFunc;\n} = {\n  name: 'dataFilter',\n  vs,\n  fs,\n  inject,\n  getUniforms: getUniforms64,\n  uniformTypesFromOptions\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}