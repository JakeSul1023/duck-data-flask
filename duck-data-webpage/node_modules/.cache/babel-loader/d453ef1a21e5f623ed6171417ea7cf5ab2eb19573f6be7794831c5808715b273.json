{"ast":null,"code":"import { load } from '@loaders.gl/core';\nimport { TilesetTraverser } from \"../tileset-traverser.js\";\nimport { getLodStatus } from \"../helpers/i3s-lod.js\";\nimport { Tile3D } from \"../tile-3d.js\";\nimport { I3STileManager } from \"./i3s-tile-manager.js\";\nexport class I3STilesetTraverser extends TilesetTraverser {\n  _tileManager;\n  constructor(options) {\n    super(options);\n    this._tileManager = new I3STileManager();\n  }\n  /**\n   * Check if there are no penging tile header requests,\n   * that means the traversal is finished and we can call\n   * following-up callbacks.\n   */\n  traversalFinished(frameState) {\n    return !this._tileManager.hasPendingTiles(frameState.viewport.id, this._frameNumber || 0);\n  }\n  shouldRefine(tile, frameState) {\n    tile._lodJudge = getLodStatus(tile, frameState);\n    return tile._lodJudge === 'DIG';\n  }\n  updateChildTiles(tile, frameState) {\n    const children = tile.header.children || [];\n    // children which are already fetched and constructed as Tile3D instances\n    const childTiles = tile.children;\n    const tileset = tile.tileset;\n    for (const child of children) {\n      const extendedId = `${child.id}-${frameState.viewport.id}`;\n      // if child tile is not fetched\n      const childTile = childTiles && childTiles.find(t => t.id === extendedId);\n      if (!childTile) {\n        let request = () => this._loadTile(child.id, tileset);\n        const cachedRequest = this._tileManager.find(extendedId);\n        if (!cachedRequest) {\n          // eslint-disable-next-line max-depth\n          if (tileset.tileset.nodePages) {\n            request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);\n          }\n          this._tileManager.add(request, extendedId, header => this._onTileLoad(header, tile, extendedId), frameState);\n        } else {\n          // update frameNumber since it is still needed in current frame\n          this._tileManager.update(extendedId, frameState);\n        }\n      } else if (childTile) {\n        // if child tile is fetched and available\n        this.updateTile(childTile, frameState);\n      }\n    }\n    return false;\n  }\n  async _loadTile(nodeId, tileset) {\n    const {\n      loader\n    } = tileset;\n    const nodeUrl = tileset.getTileUrl(`${tileset.url}/nodes/${nodeId}`);\n    // load metadata\n    const options = {\n      ...tileset.loadOptions,\n      i3s: {\n        ...tileset.loadOptions.i3s,\n        isTileHeader: true\n      }\n    };\n    return await load(nodeUrl, loader, options);\n  }\n  /**\n   * The callback to init Tile3D instance after loading the tile JSON\n   * @param {Object} header - the tile JSON from a dataset\n   * @param {Tile3D} tile - the parent Tile3D instance\n   * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.\n   *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;\n   * @return {void}\n   */\n  _onTileLoad(header, tile, extendedId) {\n    // after child tile is fetched\n    const childTile = new Tile3D(tile.tileset, header, tile, extendedId);\n    tile.children.push(childTile);\n    const frameState = this._tileManager.find(childTile.id).frameState;\n    this.updateTile(childTile, frameState);\n    // after tile fetched, resume traversal if still in current update/traversal frame\n    if (this._frameNumber === frameState.frameNumber && (this.traversalFinished(frameState) || new Date().getTime() - this.lastUpdate > this.updateDebounceTime)) {\n      this.executeTraversal(childTile, frameState);\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}