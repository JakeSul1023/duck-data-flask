{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Model } from '@luma.gl/engine';\nimport { createRenderTarget } from \"./utils.js\";\nimport { binSorterUniforms } from \"./bin-sorter-uniforms.js\";\nconst COLOR_CHANNELS = [0x1, 0x2, 0x4, 0x8]; // GPU color mask RED, GREEN, BLUE, ALPHA\nconst MAX_FLOAT32 = 3e38;\nconst EMPTY_MASKS = {\n  SUM: 0,\n  MEAN: 0,\n  MIN: 0,\n  MAX: 0,\n  COUNT: 0\n};\nexport const TEXTURE_WIDTH = 1024;\n/**\n * This class manages the resources for performing the first step of aggregation\n * Sort a list of data points into a number of bins\n */\nexport class WebGLBinSorter {\n  constructor(device, props) {\n    /**\n     * A packed texture in which each pixel represents a bin.\n     * The index of the pixel in the memory layout is the bin index.\n     * Alpha value is the count of data points that fall into this bin\n     * R,G,B values are the aggregated values of each channel:\n     *   - Sum of all data points if operation is 'SUM', or 'MEAN'\n     *   - Min of all data points if operation is 'MIN'\n     *   - Max of all data points if operation is 'MAX'\n     */\n    this.binsFBO = null;\n    this.device = device;\n    this.model = createModel(device, props);\n  }\n  get texture() {\n    return this.binsFBO ? this.binsFBO.colorAttachments[0].texture : null;\n  }\n  destroy() {\n    this.model.destroy();\n    this.binsFBO?.colorAttachments[0].texture.destroy();\n    this.binsFBO?.destroy();\n  }\n  getBinValues(index) {\n    if (!this.binsFBO) {\n      return null;\n    }\n    const x = index % TEXTURE_WIDTH;\n    const y = Math.floor(index / TEXTURE_WIDTH);\n    const buffer = this.device.readPixelsToArrayWebGL(this.binsFBO, {\n      sourceX: x,\n      sourceY: y,\n      sourceWidth: 1,\n      sourceHeight: 1\n    }).buffer;\n    return new Float32Array(buffer);\n  }\n  setDimensions(binCount, binIdRange) {\n    const width = TEXTURE_WIDTH;\n    const height = Math.ceil(binCount / width);\n    // Only destroy existing texture if it is not large enough\n    if (!this.binsFBO) {\n      this.binsFBO = createRenderTarget(this.device, width, height);\n    } else if (this.binsFBO.height < height) {\n      this.binsFBO.resize({\n        width,\n        height\n      });\n    }\n    const binSorterProps = {\n      binIdRange: [binIdRange[0][0], binIdRange[0][1], binIdRange[1]?.[0] || 0, binIdRange[1]?.[1] || 0],\n      targetSize: [this.binsFBO.width, this.binsFBO.height]\n    };\n    this.model.shaderInputs.setProps({\n      binSorter: binSorterProps\n    });\n  }\n  setModelProps(props) {\n    const model = this.model;\n    if (props.attributes) {\n      model.setAttributes(props.attributes);\n    }\n    if (props.constantAttributes) {\n      model.setConstantAttributes(props.constantAttributes);\n    }\n    if (props.vertexCount !== undefined) {\n      model.setVertexCount(props.vertexCount);\n    }\n    if (props.shaderModuleProps) {\n      model.shaderInputs.setProps(props.shaderModuleProps);\n    }\n  }\n  /** Update aggregation */\n  update(/** The aggregation operation for each channel. Use null to skip update. */\n  operations) {\n    if (!this.binsFBO) {\n      return;\n    }\n    const masks = getMaskByOperation(operations);\n    this._updateBins('SUM', masks.SUM + masks.MEAN);\n    this._updateBins('MIN', masks.MIN);\n    this._updateBins('MAX', masks.MAX);\n  }\n  /** Recalculate aggregation on the given channels using the given operation */\n  _updateBins(operation, /** GPU bit mask of one or more channels that should be updated */\n  colorMask) {\n    if (colorMask === 0) {\n      return;\n    }\n    colorMask |= COLOR_CHANNELS[3]; // Also renders to the alpha channel (point count)\n    const model = this.model;\n    const target = this.binsFBO;\n    const initialValue = operation === 'MAX' ? -MAX_FLOAT32 : operation === 'MIN' ? MAX_FLOAT32 : 0;\n    const renderPass = this.device.beginRenderPass({\n      id: `gpu-aggregation-${operation}`,\n      framebuffer: target,\n      parameters: {\n        viewport: [0, 0, target.width, target.height],\n        colorMask\n      },\n      clearColor: [initialValue, initialValue, initialValue, 0],\n      clearDepth: false,\n      clearStencil: false\n    });\n    model.setParameters({\n      blend: true,\n      blendColorSrcFactor: 'one',\n      blendColorDstFactor: 'one',\n      blendAlphaSrcFactor: 'one',\n      blendAlphaDstFactor: 'one',\n      blendColorOperation: operation === 'MAX' ? 'max' : operation === 'MIN' ? 'min' : 'add',\n      blendAlphaOperation: 'add'\n    });\n    model.draw(renderPass);\n    renderPass.end();\n  }\n}\n/** Convert a [channel -> operation] map to a [operation -> GPU color mask] map */\nfunction getMaskByOperation(operations) {\n  const result = {\n    ...EMPTY_MASKS\n  };\n  for (let channel = 0; channel < operations.length; channel++) {\n    const op = operations[channel];\n    if (op) {\n      result[op] += COLOR_CHANNELS[channel];\n    }\n  }\n  return result;\n}\nfunction createModel(device, props) {\n  let userVs = props.vs;\n  if (props.dimensions === 2) {\n    // If user provides 2d bin IDs, convert them to 1d indices for data packing\n    userVs += /* glsl */`\nvoid getBin(out int binId) {\n  ivec2 binId2;\n  getBin(binId2);\n  if (binId2.x < binSorter.binIdRange.x || binId2.x >= binSorter.binIdRange.y) {\n    binId = -1;\n  } else {\n    binId = (binId2.y - binSorter.binIdRange.z) * (binSorter.binIdRange.y - binSorter.binIdRange.x) + binId2.x;\n  }\n}\n`;\n  }\n  const vs = `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-sort-bins-vertex\n\n${userVs}\n\nout vec3 v_Value;\n\nvoid main() {\n  int binIndex;\n  getBin(binIndex);\n  binIndex = binIndex - binSorter.binIdRange.x;\n  if (binIndex < 0) {\n    gl_Position = vec4(0.);\n    return;\n  }\n  int row = binIndex / binSorter.targetSize.x;\n  int col = binIndex - row * binSorter.targetSize.x;\n  vec2 position = (vec2(col, row) + 0.5) / vec2(binSorter.targetSize) * 2.0 - 1.0;\n  gl_Position = vec4(position, 0.0, 1.0);\n  gl_PointSize = 1.0;\n\n#if NUM_CHANNELS == 3\n  getValue(v_Value);\n#elif NUM_CHANNELS == 2\n  getValue(v_Value.xy);\n#else\n  getValue(v_Value.x);\n#endif\n}\n`;\n  const fs = /* glsl */`\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-sort-bins-fragment\n\nprecision highp float;\n\nin vec3 v_Value;\nout vec4 fragColor;\n\nvoid main() {\n  fragColor.xyz = v_Value;\n\n  #ifdef MODULE_GEOMETRY\n  geometry.uv = vec2(0.);\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n  #endif\n\n  fragColor.w = 1.0;\n}\n`;\n  const model = new Model(device, {\n    bufferLayout: props.bufferLayout,\n    modules: [...(props.modules || []), binSorterUniforms],\n    defines: {\n      ...props.defines,\n      NON_INSTANCED_MODEL: 1,\n      NUM_CHANNELS: props.channelCount\n    },\n    isInstanced: false,\n    vs,\n    fs,\n    topology: 'point-list',\n    disableWarnings: true\n  });\n  return model;\n}\n//# sourceMappingURL=webgl-bin-sorter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}