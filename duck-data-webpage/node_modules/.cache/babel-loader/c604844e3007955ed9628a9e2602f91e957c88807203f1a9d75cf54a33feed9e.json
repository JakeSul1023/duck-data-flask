{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst RADIANS_TO_DEGREES = 1 / Math.PI * 180;\nconst DEGREES_TO_RADIANS = 1 / 180 * Math.PI;\nconst DEFAULT_CONFIG = {\n  EPSILON: 1e-12,\n  debug: false,\n  precision: 4,\n  printTypes: false,\n  printDegrees: false,\n  printRowMajor: true,\n  _cartographicRadians: false\n};\n// Configuration is truly global as of v3.6 to ensure single config even if multiple copies of math.gl\n// Multiple copies of config can be quite tricky to debug...\nglobalThis.mathgl = globalThis.mathgl || {\n  config: {\n    ...DEFAULT_CONFIG\n  }\n};\nexport const config = globalThis.mathgl.config;\nexport function configure(options) {\n  // Only copy existing keys\n  Object.assign(config, options);\n  return config;\n}\n/**\n * Formats a value into a string\n * @param value\n * @param param1\n * @returns\n */\nexport function formatValue(value, {\n  precision = config.precision\n} = {}) {\n  value = round(value);\n  // get rid of trailing zeros\n  return `${parseFloat(value.toPrecision(precision))}`;\n}\n/**\n * Check if value is an \"array\"\n * Returns `true` if value is either an array or a typed array\n * Note: returns `false` for `ArrayBuffer` and `DataView` instances\n * @note isTypedArray and isNumericArray are often more useful in TypeScript\n */\nexport function isArray(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);\n}\nexport function clone(array) {\n  return 'clone' in array ? array.clone() : array.slice();\n}\nexport function toRadians(degrees) {\n  return radians(degrees);\n}\nexport function toDegrees(radians) {\n  return degrees(radians);\n}\nexport function radians(degrees, result) {\n  return map(degrees, degrees => degrees * DEGREES_TO_RADIANS, result);\n}\nexport function degrees(radians, result) {\n  return map(radians, radians => radians * RADIANS_TO_DEGREES, result);\n}\n/**\n * \"GLSL equivalent\" of `Math.sin`: Works on single values and vectors\n * @deprecated\n */\nexport function sin(radians, result) {\n  return map(radians, angle => Math.sin(angle), result);\n}\n/**\n * \"GLSL equivalent\" of `Math.cos`: Works on single values and vectors\n * @deprecated\n */\nexport function cos(radians, result) {\n  return map(radians, angle => Math.cos(angle), result);\n}\n/**\n * \"GLSL equivalent\" of `Math.tan`: Works on single values and vectors\n * @deprecated\n */\nexport function tan(radians, result) {\n  return map(radians, angle => Math.tan(angle), result);\n}\n/**\n * \"GLSL equivalent\" of `Math.asin`: Works on single values and vectors\n * @deprecated\n */\nexport function asin(radians, result) {\n  return map(radians, angle => Math.asin(angle), result);\n}\n/**\n * \"GLSL equivalent\" of `Math.acos`: Works on single values and vectors\n * @deprecated\n */\nexport function acos(radians, result) {\n  return map(radians, angle => Math.acos(angle), result);\n}\n/**\n * \"GLSL equivalent\" of `Math.atan`: Works on single values and vectors\n * @deprecated\n */\nexport function atan(radians, result) {\n  return map(radians, angle => Math.atan(angle), result);\n}\nexport function clamp(value, min, max) {\n  return map(value, value => Math.max(min, Math.min(max, value)));\n}\nexport function lerp(a, b, t) {\n  if (isArray(a)) {\n    return a.map((ai, i) => lerp(ai, b[i], t));\n  }\n  return t * b + (1 - t) * a;\n}\n/* eslint-disable */\n/**\n * Compares any two math objects, using `equals` method if available.\n * @param a\n * @param b\n * @param epsilon\n * @returns\n */\nexport function equals(a, b, epsilon) {\n  const oldEpsilon = config.EPSILON;\n  if (epsilon) {\n    config.EPSILON = epsilon;\n  }\n  try {\n    if (a === b) {\n      return true;\n    }\n    if (isArray(a) && isArray(b)) {\n      if (a.length !== b.length) {\n        return false;\n      }\n      for (let i = 0; i < a.length; ++i) {\n        // eslint-disable-next-line max-depth\n        if (!equals(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    if (a && a.equals) {\n      return a.equals(b);\n    }\n    if (b && b.equals) {\n      return b.equals(a);\n    }\n    if (typeof a === 'number' && typeof b === 'number') {\n      return Math.abs(a - b) <= config.EPSILON * Math.max(1, Math.abs(a), Math.abs(b));\n    }\n    return false;\n  } finally {\n    config.EPSILON = oldEpsilon;\n  }\n}\nexport function exactEquals(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (a && typeof a === 'object' && b && typeof b === 'object') {\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n    if (a.exactEquals) {\n      return a.exactEquals(b);\n    }\n  }\n  if (isArray(a) && isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length; ++i) {\n      if (!exactEquals(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n/* eslint-enable */\nexport function withEpsilon(epsilon, func) {\n  const oldPrecision = config.EPSILON;\n  config.EPSILON = epsilon;\n  let value;\n  try {\n    value = func();\n  } finally {\n    config.EPSILON = oldPrecision;\n  }\n  return value;\n}\n// HELPERS\nfunction round(value) {\n  return Math.round(value / config.EPSILON) * config.EPSILON;\n}\n// If the array has a clone function, calls it, otherwise returns a copy\nfunction duplicateArray(array) {\n  // @ts-expect-error We check for math.gl class methods\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n  return array.clone ? array.clone() : new Array(array.length);\n}\n// If the argument value is an array, applies the func element wise,\n// otherwise applies func to the argument value\nfunction map(value, func, result) {\n  if (isArray(value)) {\n    const array = value;\n    result = result || duplicateArray(array);\n    for (let i = 0; i < result.length && i < array.length; ++i) {\n      const val = typeof value === 'number' ? value : value[i];\n      result[i] = func(val, i, result);\n    }\n    return result;\n  }\n  return func(value);\n}","map":{"version":3,"names":["RADIANS_TO_DEGREES","Math","PI","DEGREES_TO_RADIANS","DEFAULT_CONFIG","EPSILON","debug","precision","printTypes","printDegrees","printRowMajor","_cartographicRadians","globalThis","mathgl","config","configure","options","Object","assign","formatValue","value","round","parseFloat","toPrecision","isArray","Array","ArrayBuffer","isView","DataView","clone","array","slice","toRadians","degrees","radians","toDegrees","result","map","sin","angle","cos","tan","asin","acos","atan","clamp","min","max","lerp","a","b","t","ai","i","equals","epsilon","oldEpsilon","length","abs","exactEquals","constructor","withEpsilon","func","oldPrecision","duplicateArray","val"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\core\\src\\lib\\common.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable no-shadow */ // radians and degrees are common variable names\n\nimport type {NumericArray} from '@math.gl/types';\n\nimport type {MathArray} from '../classes/base/math-array';\n\nconst RADIANS_TO_DEGREES = (1 / Math.PI) * 180;\nconst DEGREES_TO_RADIANS = (1 / 180) * Math.PI;\n\nexport type ConfigurationOptions = {\n  EPSILON: number;\n  debug?: boolean;\n  precision: number;\n  printTypes?: boolean;\n  printDegrees?: boolean;\n  printRowMajor?: boolean;\n  _cartographicRadians?: boolean;\n};\n\nconst DEFAULT_CONFIG: Required<ConfigurationOptions> = {\n  EPSILON: 1e-12,\n  debug: false,\n  precision: 4,\n  printTypes: false,\n  printDegrees: false,\n  printRowMajor: true,\n  _cartographicRadians: false\n};\n\n// We use a global field to store the config\ndeclare global {\n  // eslint-disable-next-line no-var\n  var mathgl: {\n    config: Required<ConfigurationOptions>;\n  };\n}\n\n// Configuration is truly global as of v3.6 to ensure single config even if multiple copies of math.gl\n// Multiple copies of config can be quite tricky to debug...\nglobalThis.mathgl = globalThis.mathgl || {config: {...DEFAULT_CONFIG}};\n\nexport const config = globalThis.mathgl.config;\n\nexport function configure(options: Partial<ConfigurationOptions>): ConfigurationOptions {\n  // Only copy existing keys\n  Object.assign(config, options);\n  return config;\n}\n\n/**\n * Formats a value into a string\n * @param value\n * @param param1\n * @returns\n */\nexport function formatValue(\n  value: number,\n  {precision = config.precision}: {precision?: number} = {}\n): string {\n  value = round(value);\n  // get rid of trailing zeros\n  return `${parseFloat(value.toPrecision(precision))}`;\n}\n\n/**\n * Check if value is an \"array\"\n * Returns `true` if value is either an array or a typed array\n * Note: returns `false` for `ArrayBuffer` and `DataView` instances\n * @note isTypedArray and isNumericArray are often more useful in TypeScript\n */\nexport function isArray(value: unknown): boolean {\n  return Array.isArray(value) || (ArrayBuffer.isView(value) && !(value instanceof DataView));\n}\n\nexport function clone(array: NumericArray | MathArray): NumericArray {\n  return 'clone' in array ? array.clone() : array.slice();\n}\n\nexport function toRadians(degrees: number): number;\nexport function toRadians(degrees: NumericArray): NumericArray;\n\nexport function toRadians(degrees: number | NumericArray): number | NumericArray {\n  return radians(degrees as NumericArray);\n}\n\nexport function toDegrees(degrees: number): number;\nexport function toDegrees(degrees: NumericArray): NumericArray;\n\nexport function toDegrees(radians: number | NumericArray): number | NumericArray {\n  return degrees(radians as NumericArray);\n}\n\n// GLSL math function equivalents - Works on both single values and vectors\n\n/**\n * \"GLSL equivalent\" radians: Works on single values and vectors\n */\nexport function radians(degrees: number): number;\nexport function radians(degrees: NumericArray, result?: NumericArray): NumericArray;\n\nexport function radians(\n  degrees: number | NumericArray,\n  result?: NumericArray\n): number | NumericArray {\n  return map(degrees, (degrees) => degrees * DEGREES_TO_RADIANS, result);\n}\n\n/**\n * \"GLSL equivalent\" degrees: Works on single values and vectors\n */\nexport function degrees(radians: number): number;\nexport function degrees(radians: NumericArray, result?: NumericArray): NumericArray;\n\nexport function degrees(\n  radians: number | NumericArray,\n  result?: NumericArray\n): number | NumericArray {\n  return map(radians, (radians) => radians * RADIANS_TO_DEGREES, result);\n}\n\n/**\n * \"GLSL equivalent\" of `Math.sin`: Works on single values and vectors\n * @deprecated\n */\nexport function sin(radians: number | NumericArray, result?: NumericArray): number | NumericArray {\n  return map(radians, (angle) => Math.sin(angle), result);\n}\n\n/**\n * \"GLSL equivalent\" of `Math.cos`: Works on single values and vectors\n * @deprecated\n */\nexport function cos(radians: number | NumericArray, result?: NumericArray): number | NumericArray {\n  return map(radians, (angle) => Math.cos(angle), result);\n}\n\n/**\n * \"GLSL equivalent\" of `Math.tan`: Works on single values and vectors\n * @deprecated\n */\nexport function tan(radians: number | NumericArray, result?: NumericArray): number | NumericArray {\n  return map(radians, (angle) => Math.tan(angle), result);\n}\n\n/**\n * \"GLSL equivalent\" of `Math.asin`: Works on single values and vectors\n * @deprecated\n */\nexport function asin(radians: number | NumericArray, result?: NumericArray): number | NumericArray {\n  return map(radians, (angle) => Math.asin(angle), result);\n}\n\n/**\n * \"GLSL equivalent\" of `Math.acos`: Works on single values and vectors\n * @deprecated\n */\nexport function acos(radians: number | NumericArray, result?: NumericArray): number | NumericArray {\n  return map(radians, (angle) => Math.acos(angle), result);\n}\n\n/**\n * \"GLSL equivalent\" of `Math.atan`: Works on single values and vectors\n * @deprecated\n */\nexport function atan(radians: number | NumericArray, result?: NumericArray): number | NumericArray {\n  return map(radians, (angle) => Math.atan(angle), result);\n}\n\n/**\n * GLSL style value clamping: Works on single values and vectors\n */\nexport function clamp(value: number, min: number, max: number): number;\nexport function clamp(value: NumericArray, min: number, max: number): NumericArray;\n\nexport function clamp(\n  value: number | NumericArray,\n  min: number,\n  max: number\n): number | NumericArray {\n  return map(value, (value) => Math.max(min, Math.min(max, value)));\n}\n\n/**\n * Interpolate between two numbers or two arrays\n */\nexport function lerp(a: number, b: number, t: number): number;\nexport function lerp(a: NumericArray, b: NumericArray, t: number): NumericArray;\n\nexport function lerp(\n  a: number | NumericArray,\n  b: number | NumericArray,\n  t: number\n): number | NumericArray {\n  if (isArray(a)) {\n    return (a as NumericArray).map((ai: number, i: number) => lerp(ai, (b as NumericArray)[i], t));\n  }\n  return t * (b as number) + (1 - t) * (a as number);\n}\n\n/* eslint-disable */\n\n/**\n * Compares any two math objects, using `equals` method if available.\n * @param a\n * @param b\n * @param epsilon\n * @returns\n */\nexport function equals(a: any, b: any, epsilon?: number): boolean {\n  const oldEpsilon = config.EPSILON;\n  if (epsilon) {\n    config.EPSILON = epsilon;\n  }\n  try {\n    if (a === b) {\n      return true;\n    }\n    if (isArray(a) && isArray(b)) {\n      if (a.length !== b.length) {\n        return false;\n      }\n      for (let i = 0; i < a.length; ++i) {\n        // eslint-disable-next-line max-depth\n        if (!equals(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    if (a && a.equals) {\n      return a.equals(b);\n    }\n    if (b && b.equals) {\n      return b.equals(a);\n    }\n    if (typeof a === 'number' && typeof b === 'number') {\n      return Math.abs(a - b) <= config.EPSILON * Math.max(1, Math.abs(a), Math.abs(b));\n    }\n    return false;\n  } finally {\n    config.EPSILON = oldEpsilon;\n  }\n}\n\nexport function exactEquals(a: any, b: any): boolean {\n  if (a === b) {\n    return true;\n  }\n  if (a && typeof a === 'object' && b && typeof b === 'object') {\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n    if (a.exactEquals) {\n      return a.exactEquals(b);\n    }\n  }\n  if (isArray(a) && isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length; ++i) {\n      if (!exactEquals(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\n/* eslint-enable */\n\nexport function withEpsilon<T>(epsilon: number, func: () => T): T {\n  const oldPrecision = config.EPSILON;\n  config.EPSILON = epsilon;\n  let value: T;\n  try {\n    value = func();\n  } finally {\n    config.EPSILON = oldPrecision;\n  }\n  return value;\n}\n\n// HELPERS\n\nfunction round(value: number): number {\n  return Math.round(value / config.EPSILON) * config.EPSILON;\n}\n\n// If the array has a clone function, calls it, otherwise returns a copy\nfunction duplicateArray(array: NumericArray): NumericArray {\n  // @ts-expect-error We check for math.gl class methods\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n  return array.clone ? (array.clone() as NumericArray) : (new Array(array.length) as number[]);\n}\n\n// If the argument value is an array, applies the func element wise,\n// otherwise applies func to the argument value\nfunction map(\n  value: number | NumericArray,\n  func: (x: number, index?: number, resultArray?: NumericArray) => number,\n  result?: NumericArray\n): number | NumericArray {\n  if (isArray(value)) {\n    const array = value as NumericArray;\n    result = result || duplicateArray(array);\n    for (let i = 0; i < result.length && i < array.length; ++i) {\n      const val = typeof value === 'number' ? value : value[i];\n      result[i] = func(val, i, result);\n    }\n    return result;\n  }\n  return func(value as number);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}