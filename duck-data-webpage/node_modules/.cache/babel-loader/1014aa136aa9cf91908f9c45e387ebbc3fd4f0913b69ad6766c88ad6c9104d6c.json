{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ManagedArray } from \"../utils/managed-array.js\";\nimport { TILE_REFINEMENT } from \"../constants.js\";\nexport const DEFAULT_PROPS = {\n  loadSiblings: false,\n  skipLevelOfDetail: false,\n  updateTransforms: true,\n  onTraversalEnd: () => {},\n  viewportTraversersMap: {},\n  basePath: ''\n};\nexport class TilesetTraverser {\n  options;\n  // fulfill in traverse call\n  root = null;\n  // tiles should be rendered\n  selectedTiles = {};\n  // tiles should be loaded from server\n  requestedTiles = {};\n  // tiles does not have render content\n  emptyTiles = {};\n  lastUpdate = new Date().getTime();\n  updateDebounceTime = 1000;\n  /** temporary storage to hold the traversed tiles during a traversal */\n  _traversalStack = new ManagedArray();\n  _emptyTraversalStack = new ManagedArray();\n  /** set in every traverse cycle */\n  _frameNumber = null;\n  // RESULT\n  traversalFinished(frameState) {\n    return true;\n  }\n  // TODO nested props\n  constructor(options) {\n    this.options = {\n      ...DEFAULT_PROPS,\n      ...options\n    };\n  }\n  // tiles should be visible\n  traverse(root, frameState, options) {\n    this.root = root; // for root screen space error\n    this.options = {\n      ...this.options,\n      ...options\n    };\n    // reset result\n    this.reset();\n    // update tile (visibility and expiration)\n    this.updateTile(root, frameState);\n    this._frameNumber = frameState.frameNumber;\n    this.executeTraversal(root, frameState);\n  }\n  reset() {\n    this.requestedTiles = {};\n    this.selectedTiles = {};\n    this.emptyTiles = {};\n    this._traversalStack.reset();\n    this._emptyTraversalStack.reset();\n  }\n  /**\n   * Execute traverse\n   * Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n   * If skipLevelOfDetail is off then a tile does not refine until all children are loaded.\n   * This is the traditional replacement refinement approach and is called the base traversal.\n   * Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n   * all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n   * and rendering children and parent tiles simultaneously.\n   */\n  /* eslint-disable-next-line complexity, max-statements */\n  executeTraversal(root, frameState) {\n    // stack to store traversed tiles, only visible tiles should be added to stack\n    // visible: visible in the current view frustum\n    const stack = this._traversalStack;\n    root._selectionDepth = 1;\n    stack.push(root);\n    while (stack.length > 0) {\n      // 1. pop tile\n      const tile = stack.pop();\n      // 2. check if tile needs to be refine, needs refine if a tile's LoD is not sufficient and tile has available children (available content)\n      let shouldRefine = false;\n      if (this.canTraverse(tile, frameState)) {\n        this.updateChildTiles(tile, frameState);\n        shouldRefine = this.updateAndPushChildren(tile, frameState, stack, tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth);\n      }\n      // 3. decide if should render (select) this tile\n      //   - tile does not have render content\n      //   - tile has render content and tile is `add` type (pointcloud)\n      //   - tile has render content and tile is `replace` type (photogrammetry) and can't refine any further\n      const parent = tile.parent;\n      const parentRefines = Boolean(!parent || parent._shouldRefine);\n      const stoppedRefining = !shouldRefine;\n      if (!tile.hasRenderContent) {\n        this.emptyTiles[tile.id] = tile;\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n        // additive tiles\n      } else if (tile.refine === TILE_REFINEMENT.ADD) {\n        // Additive tiles are always loaded and selected\n        this.loadTile(tile, frameState);\n        this.selectTile(tile, frameState);\n        // replace tiles\n      } else if (tile.refine === TILE_REFINEMENT.REPLACE) {\n        // Always load tiles in the base traversal\n        // Select tiles that can't refine further\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n      }\n      // 3. update cache, most recent touched tiles have higher priority to be fetched from server\n      this.touchTile(tile, frameState);\n      // 4. update tile refine prop and parent refinement status to trickle down to the descendants\n      tile._shouldRefine = shouldRefine && parentRefines;\n    }\n    const newTime = new Date().getTime();\n    if (this.traversalFinished(frameState) || newTime - this.lastUpdate > this.updateDebounceTime) {\n      this.lastUpdate = newTime;\n      this.options.onTraversalEnd(frameState);\n    }\n  }\n  updateChildTiles(tile, frameState) {\n    const children = tile.children;\n    for (const child of children) {\n      this.updateTile(child, frameState);\n    }\n  }\n  /* eslint-disable complexity, max-statements */\n  updateAndPushChildren(tile, frameState, stack, depth) {\n    const {\n      loadSiblings,\n      skipLevelOfDetail\n    } = this.options;\n    const children = tile.children;\n    // sort children tiles\n    children.sort(this.compareDistanceToCamera.bind(this));\n    // For traditional replacement refinement only refine if all children are loaded.\n    // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.\n    const checkRefines = tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;\n    let hasVisibleChild = false;\n    let refines = true;\n    for (const child of children) {\n      child._selectionDepth = depth;\n      if (child.isVisibleAndInRequestVolume) {\n        if (stack.find(child)) {\n          stack.delete(child);\n        }\n        stack.push(child);\n        hasVisibleChild = true;\n      } else if (checkRefines || loadSiblings) {\n        // Keep non-visible children loaded since they are still needed before the parent can refine.\n        // Or loadSiblings is true so always load tiles regardless of visibility.\n        this.loadTile(child, frameState);\n        this.touchTile(child, frameState);\n      }\n      if (checkRefines) {\n        let childRefines;\n        if (!child._inRequestVolume) {\n          childRefines = false;\n        } else if (!child.hasRenderContent) {\n          childRefines = this.executeEmptyTraversal(child, frameState);\n        } else {\n          childRefines = child.contentAvailable;\n        }\n        refines = refines && childRefines;\n        if (!refines) {\n          return false;\n        }\n      }\n    }\n    if (!hasVisibleChild) {\n      refines = false;\n    }\n    return refines;\n  }\n  /* eslint-enable complexity, max-statements */\n  updateTile(tile, frameState) {\n    this.updateTileVisibility(tile, frameState);\n  }\n  // tile to render in the browser\n  selectTile(tile, frameState) {\n    if (this.shouldSelectTile(tile)) {\n      // The tile can be selected right away and does not require traverseAndSelect\n      tile._selectedFrame = frameState.frameNumber;\n      this.selectedTiles[tile.id] = tile;\n    }\n  }\n  // tile to load from server\n  loadTile(tile, frameState) {\n    if (this.shouldLoadTile(tile)) {\n      tile._requestedFrame = frameState.frameNumber;\n      tile._priority = tile._getPriority();\n      this.requestedTiles[tile.id] = tile;\n    }\n  }\n  // cache tile\n  touchTile(tile, frameState) {\n    tile.tileset._cache.touch(tile);\n    tile._touchedFrame = frameState.frameNumber;\n  }\n  // tile should be visible\n  // tile should have children\n  // tile LoD (level of detail) is not sufficient under current viewport\n  canTraverse(tile, frameState) {\n    if (!tile.hasChildren) {\n      return false;\n    }\n    // cesium specific\n    if (tile.hasTilesetContent) {\n      // Traverse external this to visit its root tile\n      // Don't traverse if the subtree is expired because it will be destroyed\n      return !tile.contentExpired;\n    }\n    return this.shouldRefine(tile, frameState);\n  }\n  shouldLoadTile(tile) {\n    // if request tile is in current frame\n    // and has unexpired render content\n    return tile.hasUnloadedContent || tile.contentExpired;\n  }\n  shouldSelectTile(tile) {\n    // if select tile is in current frame\n    // and content available\n    return tile.contentAvailable && !this.options.skipLevelOfDetail;\n  }\n  /** Decide if tile LoD (level of detail) is not sufficient under current viewport */\n  shouldRefine(tile, frameState, useParentMetric = false) {\n    let screenSpaceError = tile._screenSpaceError;\n    if (useParentMetric) {\n      screenSpaceError = tile.getScreenSpaceError(frameState, true);\n    }\n    return screenSpaceError > tile.tileset.memoryAdjustedScreenSpaceError;\n  }\n  updateTileVisibility(tile, frameState) {\n    const viewportIds = [];\n    if (this.options.viewportTraversersMap) {\n      for (const key in this.options.viewportTraversersMap) {\n        const value = this.options.viewportTraversersMap[key];\n        if (value === frameState.viewport.id) {\n          viewportIds.push(key);\n        }\n      }\n    } else {\n      viewportIds.push(frameState.viewport.id);\n    }\n    tile.updateVisibility(frameState, viewportIds);\n  }\n  // UTILITIES\n  compareDistanceToCamera(b, a) {\n    return b._distanceToCamera - a._distanceToCamera;\n  }\n  anyChildrenVisible(tile, frameState) {\n    let anyVisible = false;\n    for (const child of tile.children) {\n      // @ts-expect-error\n      child.updateVisibility(frameState);\n      // @ts-expect-error\n      anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n    }\n    return anyVisible;\n  }\n  // Depth-first traversal that checks if all nearest descendants with content are loaded.\n  // Ignores visibility.\n  executeEmptyTraversal(root, frameState) {\n    let allDescendantsLoaded = true;\n    const stack = this._emptyTraversalStack;\n    stack.push(root);\n    while (stack.length > 0) {\n      const tile = stack.pop();\n      const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState);\n      const emptyLeaf = !tile.hasRenderContent && tile.children.length === 0;\n      // Traversal stops but the tile does not have content yet\n      // There will be holes if the parent tries to refine to its children, so don't refine\n      // One exception: a parent may refine even if one of its descendants is an empty leaf\n      if (!traverse && !tile.contentAvailable && !emptyLeaf) {\n        allDescendantsLoaded = false;\n      }\n      this.updateTile(tile, frameState);\n      if (!tile.isVisibleAndInRequestVolume) {\n        this.loadTile(tile, frameState);\n        this.touchTile(tile, frameState);\n      }\n      if (traverse) {\n        const children = tile.children;\n        for (const child of children) {\n          stack.push(child);\n        }\n      }\n    }\n    return allDescendantsLoaded;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}