{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Get the first characters from a binary file (interpret the first bytes as an ASCII string)\n * @param data\n * @param length\n * @returns\n */\nexport function getFirstCharacters(data, length = 5) {\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    // Typed Arrays can have offsets into underlying buffer\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n  return '';\n}\n/**\n * Gets a magic string from a \"file\"\n * Typically used to check or detect file format\n * @param arrayBuffer\n * @param byteOffset\n * @param length\n * @returns\n */\nexport function getMagicString(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength <= byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}","map":{"version":3,"names":["getFirstCharacters","data","length","slice","ArrayBuffer","isView","getMagicString","buffer","byteOffset","arrayBuffer","byteLength","dataView","DataView","magic","i","String","fromCharCode","getUint8"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/get-first-characters.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Get the first characters from a binary file (interpret the first bytes as an ASCII string)\n * @param data\n * @param length\n * @returns\n */\nexport function getFirstCharacters(data, length = 5) {\n    if (typeof data === 'string') {\n        return data.slice(0, length);\n    }\n    else if (ArrayBuffer.isView(data)) {\n        // Typed Arrays can have offsets into underlying buffer\n        return getMagicString(data.buffer, data.byteOffset, length);\n    }\n    else if (data instanceof ArrayBuffer) {\n        const byteOffset = 0;\n        return getMagicString(data, byteOffset, length);\n    }\n    return '';\n}\n/**\n * Gets a magic string from a \"file\"\n * Typically used to check or detect file format\n * @param arrayBuffer\n * @param byteOffset\n * @param length\n * @returns\n */\nexport function getMagicString(arrayBuffer, byteOffset, length) {\n    if (arrayBuffer.byteLength <= byteOffset + length) {\n        return '';\n    }\n    const dataView = new DataView(arrayBuffer);\n    let magic = '';\n    for (let i = 0; i < length; i++) {\n        magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n    }\n    return magic;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,kBAAkBA,CAACC,IAAI,EAAEC,MAAM,GAAG,CAAC,EAAE;EACjD,IAAI,OAAOD,IAAI,KAAK,QAAQ,EAAE;IAC1B,OAAOA,IAAI,CAACE,KAAK,CAAC,CAAC,EAAED,MAAM,CAAC;EAChC,CAAC,MACI,IAAIE,WAAW,CAACC,MAAM,CAACJ,IAAI,CAAC,EAAE;IAC/B;IACA,OAAOK,cAAc,CAACL,IAAI,CAACM,MAAM,EAAEN,IAAI,CAACO,UAAU,EAAEN,MAAM,CAAC;EAC/D,CAAC,MACI,IAAID,IAAI,YAAYG,WAAW,EAAE;IAClC,MAAMI,UAAU,GAAG,CAAC;IACpB,OAAOF,cAAc,CAACL,IAAI,EAAEO,UAAU,EAAEN,MAAM,CAAC;EACnD;EACA,OAAO,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,cAAcA,CAACG,WAAW,EAAED,UAAU,EAAEN,MAAM,EAAE;EAC5D,IAAIO,WAAW,CAACC,UAAU,IAAIF,UAAU,GAAGN,MAAM,EAAE;IAC/C,OAAO,EAAE;EACb;EACA,MAAMS,QAAQ,GAAG,IAAIC,QAAQ,CAACH,WAAW,CAAC;EAC1C,IAAII,KAAK,GAAG,EAAE;EACd,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,MAAM,EAAEY,CAAC,EAAE,EAAE;IAC7BD,KAAK,IAAIE,MAAM,CAACC,YAAY,CAACL,QAAQ,CAACM,QAAQ,CAACT,UAAU,GAAGM,CAAC,CAAC,CAAC;EACnE;EACA,OAAOD,KAAK;AAChB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}