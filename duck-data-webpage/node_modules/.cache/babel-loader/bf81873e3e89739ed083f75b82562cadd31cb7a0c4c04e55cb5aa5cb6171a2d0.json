{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport debug from \"../debug/index.js\";\nimport DrawLayersPass from \"../passes/draw-layers-pass.js\";\nimport PickLayersPass from \"../passes/pick-layers-pass.js\";\nconst TRACE_RENDER_LAYERS = 'deckRenderer.renderLayers';\nexport default class DeckRenderer {\n  constructor(device) {\n    this.device = device;\n    this.layerFilter = null;\n    this.drawPickingColors = false;\n    this.drawLayersPass = new DrawLayersPass(device);\n    this.pickLayersPass = new PickLayersPass(device);\n    this.renderCount = 0;\n    this._needsRedraw = 'Initial render';\n    this.renderBuffers = [];\n    this.lastPostProcessEffect = null;\n  }\n  setProps(props) {\n    if (this.layerFilter !== props.layerFilter) {\n      this.layerFilter = props.layerFilter;\n      this._needsRedraw = 'layerFilter changed';\n    }\n    if (this.drawPickingColors !== props.drawPickingColors) {\n      this.drawPickingColors = props.drawPickingColors;\n      this._needsRedraw = 'drawPickingColors changed';\n    }\n  }\n  renderLayers(opts) {\n    if (!opts.viewports.length) {\n      return;\n    }\n    const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;\n    const renderOpts = {\n      layerFilter: this.layerFilter,\n      isPicking: this.drawPickingColors,\n      ...opts\n    };\n    if (renderOpts.effects) {\n      this._preRender(renderOpts.effects, renderOpts);\n    }\n    const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : renderOpts.target;\n    if (this.lastPostProcessEffect) {\n      renderOpts.clearColor = [0, 0, 0, 0];\n      renderOpts.clearCanvas = true;\n    }\n    const renderStats = layerPass.render({\n      ...renderOpts,\n      target: outputBuffer\n    });\n    if (renderOpts.effects) {\n      this._postRender(renderOpts.effects, renderOpts);\n    }\n    this.renderCount++;\n    debug(TRACE_RENDER_LAYERS, this, renderStats, opts);\n  }\n  needsRedraw(opts = {\n    clearRedrawFlags: false\n  }) {\n    const redraw = this._needsRedraw;\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n    return redraw;\n  }\n  finalize() {\n    const {\n      renderBuffers\n    } = this;\n    for (const buffer of renderBuffers) {\n      buffer.delete();\n    }\n    renderBuffers.length = 0;\n  }\n  _preRender(effects, opts) {\n    this.lastPostProcessEffect = null;\n    opts.preRenderStats = opts.preRenderStats || {};\n    for (const effect of effects) {\n      opts.preRenderStats[effect.id] = effect.preRender(opts);\n      if (effect.postRender) {\n        this.lastPostProcessEffect = effect.id;\n      }\n    }\n    if (this.lastPostProcessEffect) {\n      this._resizeRenderBuffers();\n    }\n  }\n  _resizeRenderBuffers() {\n    const {\n      renderBuffers\n    } = this;\n    const size = this.device.canvasContext.getDrawingBufferSize();\n    if (renderBuffers.length === 0) {\n      [0, 1].map(i => {\n        const texture = this.device.createTexture({\n          sampler: {\n            minFilter: 'linear',\n            magFilter: 'linear'\n          }\n        });\n        renderBuffers.push(this.device.createFramebuffer({\n          id: `deck-renderbuffer-${i}`,\n          colorAttachments: [texture]\n        }));\n      });\n    }\n    for (const buffer of renderBuffers) {\n      buffer.resize(size);\n    }\n  }\n  _postRender(effects, opts) {\n    const {\n      renderBuffers\n    } = this;\n    const params = {\n      ...opts,\n      inputBuffer: renderBuffers[0],\n      swapBuffer: renderBuffers[1]\n    };\n    for (const effect of effects) {\n      if (effect.postRender) {\n        // If not the last post processing effect, unset the target so that\n        // it only renders between the swap buffers\n        params.target = effect.id === this.lastPostProcessEffect ? opts.target : undefined;\n        const buffer = effect.postRender(params);\n        // Buffer cannot be null if target is unset\n        params.inputBuffer = buffer;\n        params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];\n      }\n    }\n  }\n}","map":{"version":3,"names":["debug","DrawLayersPass","PickLayersPass","TRACE_RENDER_LAYERS","DeckRenderer","constructor","device","layerFilter","drawPickingColors","drawLayersPass","pickLayersPass","renderCount","_needsRedraw","renderBuffers","lastPostProcessEffect","setProps","props","renderLayers","opts","viewports","length","layerPass","renderOpts","isPicking","effects","_preRender","outputBuffer","target","clearColor","clearCanvas","renderStats","render","_postRender","needsRedraw","clearRedrawFlags","redraw","finalize","buffer","delete","preRenderStats","effect","id","preRender","postRender","_resizeRenderBuffers","size","canvasContext","getDrawingBufferSize","map","i","texture","createTexture","sampler","minFilter","magFilter","push","createFramebuffer","colorAttachments","resize","params","inputBuffer","swapBuffer","undefined"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\lib\\deck-renderer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '@luma.gl/core';\nimport {Framebuffer} from '@luma.gl/core';\nimport debug from '../debug/index';\nimport DrawLayersPass from '../passes/draw-layers-pass';\nimport PickLayersPass from '../passes/pick-layers-pass';\n\nimport type Layer from './layer';\nimport type Viewport from '../viewports/viewport';\nimport type View from '../views/view';\nimport type {Effect, PostRenderOptions} from './effect';\nimport type {LayersPassRenderOptions, FilterContext} from '../passes/layers-pass';\n\nconst TRACE_RENDER_LAYERS = 'deckRenderer.renderLayers';\n\ntype LayerFilter = ((context: FilterContext) => boolean) | null;\n\nexport default class DeckRenderer {\n  device: Device;\n  layerFilter: LayerFilter;\n  drawPickingColors: boolean;\n  drawLayersPass: DrawLayersPass;\n  pickLayersPass: PickLayersPass;\n\n  private renderCount: number;\n  private _needsRedraw: string | false;\n  private renderBuffers: Framebuffer[];\n  private lastPostProcessEffect: string | null;\n\n  constructor(device: Device) {\n    this.device = device;\n    this.layerFilter = null;\n    this.drawPickingColors = false;\n    this.drawLayersPass = new DrawLayersPass(device);\n    this.pickLayersPass = new PickLayersPass(device);\n    this.renderCount = 0;\n    this._needsRedraw = 'Initial render';\n    this.renderBuffers = [];\n    this.lastPostProcessEffect = null;\n  }\n\n  setProps(props: {layerFilter: LayerFilter; drawPickingColors: boolean}) {\n    if (this.layerFilter !== props.layerFilter) {\n      this.layerFilter = props.layerFilter;\n      this._needsRedraw = 'layerFilter changed';\n    }\n\n    if (this.drawPickingColors !== props.drawPickingColors) {\n      this.drawPickingColors = props.drawPickingColors;\n      this._needsRedraw = 'drawPickingColors changed';\n    }\n  }\n\n  renderLayers(opts: {\n    pass: string;\n    layers: Layer[];\n    viewports: Viewport[];\n    views: {[viewId: string]: View};\n    onViewportActive: (viewport: Viewport) => void;\n    effects: Effect[];\n    target?: Framebuffer | null;\n    layerFilter?: LayerFilter;\n    clearStack?: boolean;\n    clearCanvas?: boolean;\n  }) {\n    if (!opts.viewports.length) {\n      return;\n    }\n\n    const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;\n\n    const renderOpts: LayersPassRenderOptions = {\n      layerFilter: this.layerFilter,\n      isPicking: this.drawPickingColors,\n      ...opts\n    };\n\n    if (renderOpts.effects) {\n      this._preRender(renderOpts.effects, renderOpts);\n    }\n\n    const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : renderOpts.target;\n    if (this.lastPostProcessEffect) {\n      renderOpts.clearColor = [0, 0, 0, 0];\n      renderOpts.clearCanvas = true;\n    }\n    const renderStats = layerPass.render({...renderOpts, target: outputBuffer});\n\n    if (renderOpts.effects) {\n      this._postRender(renderOpts.effects, renderOpts);\n    }\n\n    this.renderCount++;\n\n    debug(TRACE_RENDER_LAYERS, this, renderStats, opts);\n  }\n\n  needsRedraw(opts: {clearRedrawFlags: boolean} = {clearRedrawFlags: false}): string | false {\n    const redraw = this._needsRedraw;\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n    return redraw;\n  }\n\n  finalize() {\n    const {renderBuffers} = this;\n    for (const buffer of renderBuffers) {\n      buffer.delete();\n    }\n    renderBuffers.length = 0;\n  }\n\n  private _preRender(effects: Effect[], opts: LayersPassRenderOptions) {\n    this.lastPostProcessEffect = null;\n    opts.preRenderStats = opts.preRenderStats || {};\n\n    for (const effect of effects) {\n      opts.preRenderStats[effect.id] = effect.preRender(opts);\n      if (effect.postRender) {\n        this.lastPostProcessEffect = effect.id;\n      }\n    }\n\n    if (this.lastPostProcessEffect) {\n      this._resizeRenderBuffers();\n    }\n  }\n\n  private _resizeRenderBuffers() {\n    const {renderBuffers} = this;\n    const size = this.device.canvasContext!.getDrawingBufferSize();\n    if (renderBuffers.length === 0) {\n      [0, 1].map(i => {\n        const texture = this.device.createTexture({\n          sampler: {minFilter: 'linear', magFilter: 'linear'}\n        });\n        renderBuffers.push(\n          this.device.createFramebuffer({\n            id: `deck-renderbuffer-${i}`,\n            colorAttachments: [texture]\n          })\n        );\n      });\n    }\n    for (const buffer of renderBuffers) {\n      buffer.resize(size);\n    }\n  }\n\n  private _postRender(effects: Effect[], opts: LayersPassRenderOptions) {\n    const {renderBuffers} = this;\n    const params: PostRenderOptions = {\n      ...opts,\n      inputBuffer: renderBuffers[0],\n      swapBuffer: renderBuffers[1]\n    };\n    for (const effect of effects) {\n      if (effect.postRender) {\n        // If not the last post processing effect, unset the target so that\n        // it only renders between the swap buffers\n        params.target = effect.id === this.lastPostProcessEffect ? opts.target : undefined;\n        const buffer = effect.postRender(params);\n        // Buffer cannot be null if target is unset\n        params.inputBuffer = buffer!;\n        params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}