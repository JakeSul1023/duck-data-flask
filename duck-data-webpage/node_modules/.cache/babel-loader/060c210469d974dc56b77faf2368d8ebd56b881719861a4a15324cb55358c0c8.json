{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport function getBounds(points) {\n  // Now build bounding box in world space (aligned to world coordiante system)\n  const x = points.map(p => p[0]);\n  const y = points.map(p => p[1]);\n  const xMin = Math.min.apply(null, x);\n  const xMax = Math.max.apply(null, x);\n  const yMin = Math.min.apply(null, y);\n  const yMax = Math.max.apply(null, y);\n  return [xMin, yMin, xMax, yMax];\n}\n// true if currentBounds contains targetBounds, false otherwise\nexport function boundsContain(currentBounds, targetBounds) {\n  if (targetBounds[0] >= currentBounds[0] && targetBounds[2] <= currentBounds[2] && targetBounds[1] >= currentBounds[1] && targetBounds[3] <= currentBounds[3]) {\n    return true;\n  }\n  return false;\n}\nconst scratchArray = new Float32Array(12);\n// For given rectangle bounds generates two triangles vertices that coverit completely\nexport function packVertices(points, dimensions = 2) {\n  let index = 0;\n  for (const point of points) {\n    for (let i = 0; i < dimensions; i++) {\n      scratchArray[index++] = point[i] || 0;\n    }\n  }\n  return scratchArray;\n}\n// Expands boundingBox:[xMin, yMin, xMax, yMax] to match aspect ratio of given width and height\nexport function scaleToAspectRatio(boundingBox, width, height) {\n  const [xMin, yMin, xMax, yMax] = boundingBox;\n  const currentWidth = xMax - xMin;\n  const currentHeight = yMax - yMin;\n  let newWidth = currentWidth;\n  let newHeight = currentHeight;\n  if (currentWidth / currentHeight < width / height) {\n    // expand bounding box width\n    newWidth = width / height * currentHeight;\n  } else {\n    newHeight = height / width * currentWidth;\n  }\n  if (newWidth < width) {\n    newWidth = width;\n    newHeight = height;\n  }\n  const xCenter = (xMax + xMin) / 2;\n  const yCenter = (yMax + yMin) / 2;\n  return [xCenter - newWidth / 2, yCenter - newHeight / 2, xCenter + newWidth / 2, yCenter + newHeight / 2];\n}\n// Get texture coordiante of point inside a bounding box\nexport function getTextureCoordinates(point, bounds) {\n  const [xMin, yMin, xMax, yMax] = bounds;\n  return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];\n}","map":{"version":3,"names":["getBounds","points","x","map","p","y","xMin","Math","min","apply","xMax","max","yMin","yMax","boundsContain","currentBounds","targetBounds","scratchArray","Float32Array","packVertices","dimensions","index","point","i","scaleToAspectRatio","boundingBox","width","height","currentWidth","currentHeight","newWidth","newHeight","xCenter","yCenter","getTextureCoordinates","bounds"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\aggregation-layers\\src\\heatmap-layer\\heatmap-layer-utils.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport function getBounds(points: number[][]): number[] {\n  // Now build bounding box in world space (aligned to world coordiante system)\n  const x = points.map(p => p[0]);\n  const y = points.map(p => p[1]);\n\n  const xMin = Math.min.apply(null, x);\n  const xMax = Math.max.apply(null, x);\n  const yMin = Math.min.apply(null, y);\n  const yMax = Math.max.apply(null, y);\n\n  return [xMin, yMin, xMax, yMax];\n}\n\n// true if currentBounds contains targetBounds, false otherwise\nexport function boundsContain(currentBounds: number[], targetBounds: number[]): boolean {\n  if (\n    targetBounds[0] >= currentBounds[0] &&\n    targetBounds[2] <= currentBounds[2] &&\n    targetBounds[1] >= currentBounds[1] &&\n    targetBounds[3] <= currentBounds[3]\n  ) {\n    return true;\n  }\n  return false;\n}\n\nconst scratchArray = new Float32Array(12);\n\n// For given rectangle bounds generates two triangles vertices that coverit completely\nexport function packVertices(points: number[][], dimensions: number = 2): Float32Array {\n  let index = 0;\n  for (const point of points) {\n    for (let i = 0; i < dimensions; i++) {\n      scratchArray[index++] = point[i] || 0;\n    }\n  }\n  return scratchArray;\n}\n\n// Expands boundingBox:[xMin, yMin, xMax, yMax] to match aspect ratio of given width and height\nexport function scaleToAspectRatio(\n  boundingBox: [number, number, number, number],\n  width: number,\n  height: number\n): [number, number, number, number] {\n  const [xMin, yMin, xMax, yMax] = boundingBox;\n\n  const currentWidth = xMax - xMin;\n  const currentHeight = yMax - yMin;\n\n  let newWidth = currentWidth;\n  let newHeight = currentHeight;\n  if (currentWidth / currentHeight < width / height) {\n    // expand bounding box width\n    newWidth = (width / height) * currentHeight;\n  } else {\n    newHeight = (height / width) * currentWidth;\n  }\n\n  if (newWidth < width) {\n    newWidth = width;\n    newHeight = height;\n  }\n\n  const xCenter = (xMax + xMin) / 2;\n  const yCenter = (yMax + yMin) / 2;\n\n  return [\n    xCenter - newWidth / 2,\n    yCenter - newHeight / 2,\n    xCenter + newWidth / 2,\n    yCenter + newHeight / 2\n  ];\n}\n\n// Get texture coordiante of point inside a bounding box\nexport function getTextureCoordinates(point: number[], bounds: number[]) {\n  const [xMin, yMin, xMax, yMax] = bounds;\n  return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}