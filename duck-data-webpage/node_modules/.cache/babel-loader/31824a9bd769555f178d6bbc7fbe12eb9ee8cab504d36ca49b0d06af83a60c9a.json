{"ast":null,"code":"class e {\n  constructor(e, t) {\n    this.name = e, this.attributes = t, this.size = 0;\n  }\n  get isArray() {\n    return !1;\n  }\n  get isStruct() {\n    return !1;\n  }\n  get isTemplate() {\n    return !1;\n  }\n  getTypeName() {\n    return this.name;\n  }\n}\nclass t {\n  constructor(e, t, n) {\n    this.name = e, this.type = t, this.attributes = n, this.offset = 0, this.size = 0;\n  }\n  get isArray() {\n    return this.type.isArray;\n  }\n  get isStruct() {\n    return this.type.isStruct;\n  }\n  get isTemplate() {\n    return this.type.isTemplate;\n  }\n  get align() {\n    return this.type.isStruct ? this.type.align : 0;\n  }\n  get members() {\n    return this.type.isStruct ? this.type.members : null;\n  }\n  get format() {\n    return this.type.isArray || this.type.isTemplate ? this.type.format : null;\n  }\n  get count() {\n    return this.type.isArray ? this.type.count : 0;\n  }\n  get stride() {\n    return this.type.isArray ? this.type.stride : this.size;\n  }\n}\nclass n extends e {\n  constructor(e, t) {\n    super(e, t), this.members = [], this.align = 0, this.startLine = -1, this.endLine = -1, this.inUse = !1;\n  }\n  get isStruct() {\n    return !0;\n  }\n}\nclass s extends e {\n  constructor(e, t) {\n    super(e, t), this.count = 0, this.stride = 0;\n  }\n  get isArray() {\n    return !0;\n  }\n}\nclass r extends e {\n  constructor(e, t, n, s) {\n    super(e, n), this.format = t, this.access = s;\n  }\n  get isTemplate() {\n    return !0;\n  }\n  getTypeName() {\n    let e = this.name;\n    if (null !== this.format) {\n      if ('vec2' === e || 'vec3' === e || 'vec4' === e || 'mat2x2' === e || 'mat2x3' === e || 'mat2x4' === e || 'mat3x2' === e || 'mat3x3' === e || 'mat3x4' === e || 'mat4x2' === e || 'mat4x3' === e || 'mat4x4' === e) {\n        if ('f32' === this.format.name) return e += 'f', e;\n        if ('i32' === this.format.name) return e += 'i', e;\n        if ('u32' === this.format.name) return e += 'u', e;\n        if ('bool' === this.format.name) return e += 'b', e;\n        if ('f16' === this.format.name) return e += 'h', e;\n      }\n      e += `<${this.format.name}>`;\n    } else if ('vec2' === e || 'vec3' === e || 'vec4' === e) return e;\n    return e;\n  }\n}\nvar a;\n(e => {\n  e[e.Uniform = 0] = 'Uniform', e[e.Storage = 1] = 'Storage', e[e.Texture = 2] = 'Texture', e[e.Sampler = 3] = 'Sampler', e[e.StorageTexture = 4] = 'StorageTexture';\n})(a || (a = {}));\nclass i {\n  constructor(e, t, n, s, r, a, i) {\n    this.name = e, this.type = t, this.group = n, this.binding = s, this.attributes = r, this.resourceType = a, this.access = i;\n  }\n  get isArray() {\n    return this.type.isArray;\n  }\n  get isStruct() {\n    return this.type.isStruct;\n  }\n  get isTemplate() {\n    return this.type.isTemplate;\n  }\n  get size() {\n    return this.type.size;\n  }\n  get align() {\n    return this.type.isStruct ? this.type.align : 0;\n  }\n  get members() {\n    return this.type.isStruct ? this.type.members : null;\n  }\n  get format() {\n    return this.type.isArray || this.type.isTemplate ? this.type.format : null;\n  }\n  get count() {\n    return this.type.isArray ? this.type.count : 0;\n  }\n  get stride() {\n    return this.type.isArray ? this.type.stride : this.size;\n  }\n}\nclass o {\n  constructor(e, t) {\n    this.name = e, this.type = t;\n  }\n}\nclass l {\n  constructor(e, t, n, s) {\n    this.name = e, this.type = t, this.locationType = n, this.location = s, this.interpolation = null;\n  }\n}\nclass c {\n  constructor(e, t, n, s) {\n    this.name = e, this.type = t, this.locationType = n, this.location = s;\n  }\n}\nclass u {\n  constructor(e, t, n, s) {\n    this.name = e, this.type = t, this.attributes = n, this.id = s;\n  }\n}\nclass h {\n  constructor(e, t, n) {\n    this.name = e, this.type = t, this.attributes = n;\n  }\n}\nclass f {\n  constructor(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let n = arguments.length > 2 ? arguments[2] : undefined;\n    this.stage = null, this.inputs = [], this.outputs = [], this.arguments = [], this.returnType = null, this.resources = [], this.overrides = [], this.startLine = -1, this.endLine = -1, this.inUse = !1, this.calls = new Set(), this.name = e, this.stage = t, this.attributes = n;\n  }\n}\nclass p {\n  constructor() {\n    this.vertex = [], this.fragment = [], this.compute = [];\n  }\n}\nconst d = new Float32Array(1),\n  m = new Int32Array(d.buffer),\n  _ = new Uint16Array(1);\nfunction g(e) {\n  d[0] = e;\n  const t = m[0],\n    n = t >> 31 & 1;\n  let s = t >> 23 & 255,\n    r = 8388607 & t;\n  if (255 === s) return _[0] = n << 15 | 31744 | (0 !== r ? 512 : 0), _[0];\n  if (0 === s) {\n    if (0 === r) return _[0] = n << 15, _[0];\n    r |= 8388608;\n    let e = 113;\n    for (; !(8388608 & r);) r <<= 1, e--;\n    return s = 127 - e, r &= 8388607, s > 0 ? (r = (r >> 126 - s) + (r >> 127 - s & 1), _[0] = n << 15 | s << 10 | r >> 13, _[0]) : (_[0] = n << 15, _[0]);\n  }\n  return s = s - 127 + 15, s >= 31 ? (_[0] = n << 15 | 31744, _[0]) : s <= 0 ? s < -10 ? (_[0] = n << 15, _[0]) : (r = (8388608 | r) >> 1 - s, _[0] = n << 15 | r >> 13, _[0]) : (r >>= 13, _[0] = n << 15 | s << 10 | r, _[0]);\n}\nconst x = new Uint32Array(1),\n  y = new Float32Array(x.buffer, 0, 1);\nfunction b(e) {\n  const t = 112 + (e >> 6 & 31) << 23 | (63 & e) << 17;\n  return x[0] = t, y[0];\n}\nfunction v(e, t, n, s, r, a, i, o, l) {\n  const c = s * (i >>= r) * (a >>= r) + n * i + t * o;\n  switch (l) {\n    case 'r8unorm':\n      return [w(e, c, '8unorm', 1)[0]];\n    case 'r8snorm':\n      return [w(e, c, '8snorm', 1)[0]];\n    case 'r8uint':\n      return [w(e, c, '8uint', 1)[0]];\n    case 'r8sint':\n      return [w(e, c, '8sint', 1)[0]];\n    case 'rg8unorm':\n      {\n        const t = w(e, c, '8unorm', 2);\n        return [t[0], t[1]];\n      }\n    case 'rg8snorm':\n      {\n        const t = w(e, c, '8snorm', 2);\n        return [t[0], t[1]];\n      }\n    case 'rg8uint':\n      {\n        const t = w(e, c, '8uint', 2);\n        return [t[0], t[1]];\n      }\n    case 'rg8sint':\n      {\n        const t = w(e, c, '8sint', 2);\n        return [t[0], t[1]];\n      }\n    case 'rgba8unorm-srgb':\n    case 'rgba8unorm':\n      {\n        const t = w(e, c, '8unorm', 4);\n        return [t[0], t[1], t[2], t[3]];\n      }\n    case 'rgba8snorm':\n      {\n        const t = w(e, c, '8snorm', 4);\n        return [t[0], t[1], t[2], t[3]];\n      }\n    case 'rgba8uint':\n      {\n        const t = w(e, c, '8uint', 4);\n        return [t[0], t[1], t[2], t[3]];\n      }\n    case 'rgba8sint':\n      {\n        const t = w(e, c, '8sint', 4);\n        return [t[0], t[1], t[2], t[3]];\n      }\n    case 'bgra8unorm-srgb':\n    case 'bgra8unorm':\n      {\n        const t = w(e, c, '8unorm', 4);\n        return [t[2], t[1], t[0], t[3]];\n      }\n    case 'r16uint':\n      return [w(e, c, '16uint', 1)[0]];\n    case 'r16sint':\n      return [w(e, c, '16sint', 1)[0]];\n    case 'r16float':\n      return [w(e, c, '16float', 1)[0]];\n    case 'rg16uint':\n      {\n        const t = w(e, c, '16uint', 2);\n        return [t[0], t[1]];\n      }\n    case 'rg16sint':\n      {\n        const t = w(e, c, '16sint', 2);\n        return [t[0], t[1]];\n      }\n    case 'rg16float':\n      {\n        const t = w(e, c, '16float', 2);\n        return [t[0], t[1]];\n      }\n    case 'rgba16uint':\n      {\n        const t = w(e, c, '16uint', 4);\n        return [t[0], t[1], t[2], t[3]];\n      }\n    case 'rgba16sint':\n      {\n        const t = w(e, c, '16sint', 4);\n        return [t[0], t[1], t[2], t[3]];\n      }\n    case 'rgba16float':\n      {\n        const t = w(e, c, '16float', 4);\n        return [t[0], t[1], t[2], t[3]];\n      }\n    case 'r32uint':\n      return [w(e, c, '32uint', 1)[0]];\n    case 'r32sint':\n      return [w(e, c, '32sint', 1)[0]];\n    case 'depth16unorm':\n    case 'depth24plus':\n    case 'depth24plus-stencil8':\n    case 'depth32float':\n    case 'depth32float-stencil8':\n    case 'r32float':\n      return [w(e, c, '32float', 1)[0]];\n    case 'rg32uint':\n      {\n        const t = w(e, c, '32uint', 2);\n        return [t[0], t[1]];\n      }\n    case 'rg32sint':\n      {\n        const t = w(e, c, '32sint', 2);\n        return [t[0], t[1]];\n      }\n    case 'rg32float':\n      {\n        const t = w(e, c, '32float', 2);\n        return [t[0], t[1]];\n      }\n    case 'rgba32uint':\n      {\n        const t = w(e, c, '32uint', 4);\n        return [t[0], t[1], t[2], t[3]];\n      }\n    case 'rgba32sint':\n      {\n        const t = w(e, c, '32sint', 4);\n        return [t[0], t[1], t[2], t[3]];\n      }\n    case 'rgba32float':\n      {\n        const t = w(e, c, '32float', 4);\n        return [t[0], t[1], t[2], t[3]];\n      }\n    case 'rg11b10ufloat':\n      {\n        const t = new Uint32Array(e.buffer, c, 1)[0],\n          n = (4192256 & t) >> 11,\n          s = (4290772992 & t) >> 22;\n        return [b(2047 & t), b(n), function (e) {\n          const t = 112 + (e >> 5 & 31) << 23 | (31 & e) << 18;\n          return x[0] = t, y[0];\n        }(s), 1];\n      }\n  }\n  return null;\n}\nfunction w(e, t, n, s) {\n  const r = [0, 0, 0, 0];\n  for (let c = 0; c < s; ++c) switch (n) {\n    case '8unorm':\n      r[c] = e[t] / 255, t++;\n      break;\n    case '8snorm':\n      r[c] = e[t] / 255 * 2 - 1, t++;\n      break;\n    case '8uint':\n      r[c] = e[t], t++;\n      break;\n    case '8sint':\n      r[c] = e[t] - 127, t++;\n      break;\n    case '16uint':\n      r[c] = e[t] | e[t + 1] << 8, t += 2;\n      break;\n    case '16sint':\n      r[c] = (e[t] | e[t + 1] << 8) - 32768, t += 2;\n      break;\n    case '16float':\n      r[c] = (a = e[t] | e[t + 1] << 8, i = void 0, o = void 0, l = void 0, i = (32768 & a) >> 15, l = 1023 & a, 0 == (o = (31744 & a) >> 10) ? (i ? -1 : 1) * Math.pow(2, -14) * (l / Math.pow(2, 10)) : 31 == o ? l ? NaN : 1 / 0 * (i ? -1 : 1) : (i ? -1 : 1) * Math.pow(2, o - 15) * (1 + l / Math.pow(2, 10))), t += 2;\n      break;\n    case '32uint':\n    case '32sint':\n      r[c] = e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24, t += 4;\n      break;\n    case '32float':\n      r[c] = new Float32Array(e.buffer, t, 1)[0], t += 4;\n  }\n  var a, i, o, l;\n  return r;\n}\nfunction k(e, t, n, s, r) {\n  for (let a = 0; a < s; ++a) switch (n) {\n    case '8unorm':\n      e[t] = 255 * r[a], t++;\n      break;\n    case '8snorm':\n      e[t] = .5 * (r[a] + 1) * 255, t++;\n      break;\n    case '8uint':\n      e[t] = r[a], t++;\n      break;\n    case '8sint':\n      e[t] = r[a] + 127, t++;\n      break;\n    case '16uint':\n      new Uint16Array(e.buffer, t, 1)[0] = r[a], t += 2;\n      break;\n    case '16sint':\n      new Int16Array(e.buffer, t, 1)[0] = r[a], t += 2;\n      break;\n    case '16float':\n      {\n        const n = g(r[a]);\n        new Uint16Array(e.buffer, t, 1)[0] = n, t += 2;\n        break;\n      }\n    case '32uint':\n      new Uint32Array(e.buffer, t, 1)[0] = r[a], t += 4;\n      break;\n    case '32sint':\n      new Int32Array(e.buffer, t, 1)[0] = r[a], t += 4;\n      break;\n    case '32float':\n      new Float32Array(e.buffer, t, 1)[0] = r[a], t += 4;\n  }\n  return r;\n}\nconst I = {\n  r8unorm: {\n    bytesPerBlock: 1,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 1\n  },\n  r8snorm: {\n    bytesPerBlock: 1,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 1\n  },\n  r8uint: {\n    bytesPerBlock: 1,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 1\n  },\n  r8sint: {\n    bytesPerBlock: 1,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 1\n  },\n  rg8unorm: {\n    bytesPerBlock: 2,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 2\n  },\n  rg8snorm: {\n    bytesPerBlock: 2,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 2\n  },\n  rg8uint: {\n    bytesPerBlock: 2,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 2\n  },\n  rg8sint: {\n    bytesPerBlock: 2,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 2\n  },\n  rgba8unorm: {\n    bytesPerBlock: 4,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 4\n  },\n  'rgba8unorm-srgb': {\n    bytesPerBlock: 4,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 4\n  },\n  rgba8snorm: {\n    bytesPerBlock: 4,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 4\n  },\n  rgba8uint: {\n    bytesPerBlock: 4,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 4\n  },\n  rgba8sint: {\n    bytesPerBlock: 4,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 4\n  },\n  bgra8unorm: {\n    bytesPerBlock: 4,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 4\n  },\n  'bgra8unorm-srgb': {\n    bytesPerBlock: 4,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 4\n  },\n  r16uint: {\n    bytesPerBlock: 2,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 1\n  },\n  r16sint: {\n    bytesPerBlock: 2,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 1\n  },\n  r16float: {\n    bytesPerBlock: 2,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 1\n  },\n  rg16uint: {\n    bytesPerBlock: 4,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 2\n  },\n  rg16sint: {\n    bytesPerBlock: 4,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 2\n  },\n  rg16float: {\n    bytesPerBlock: 4,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 2\n  },\n  rgba16uint: {\n    bytesPerBlock: 8,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 4\n  },\n  rgba16sint: {\n    bytesPerBlock: 8,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 4\n  },\n  rgba16float: {\n    bytesPerBlock: 8,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 4\n  },\n  r32uint: {\n    bytesPerBlock: 4,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 1\n  },\n  r32sint: {\n    bytesPerBlock: 4,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 1\n  },\n  r32float: {\n    bytesPerBlock: 4,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 1\n  },\n  rg32uint: {\n    bytesPerBlock: 8,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 2\n  },\n  rg32sint: {\n    bytesPerBlock: 8,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 2\n  },\n  rg32float: {\n    bytesPerBlock: 8,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 2\n  },\n  rgba32uint: {\n    bytesPerBlock: 16,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 4\n  },\n  rgba32sint: {\n    bytesPerBlock: 16,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 4\n  },\n  rgba32float: {\n    bytesPerBlock: 16,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 4\n  },\n  rgb10a2uint: {\n    bytesPerBlock: 4,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 4\n  },\n  rgb10a2unorm: {\n    bytesPerBlock: 4,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 4\n  },\n  rg11b10ufloat: {\n    bytesPerBlock: 4,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 4\n  },\n  stencil8: {\n    bytesPerBlock: 1,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    isDepthStencil: !0,\n    hasDepth: !1,\n    hasStencil: !0,\n    channels: 1\n  },\n  depth16unorm: {\n    bytesPerBlock: 2,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    isDepthStencil: !0,\n    hasDepth: !0,\n    hasStencil: !1,\n    channels: 1\n  },\n  depth24plus: {\n    bytesPerBlock: 4,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    isDepthStencil: !0,\n    hasDepth: !0,\n    hasStencil: !1,\n    depthOnlyFormat: 'depth32float',\n    channels: 1\n  },\n  'depth24plus-stencil8': {\n    bytesPerBlock: 8,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    isDepthStencil: !0,\n    hasDepth: !0,\n    hasStencil: !0,\n    depthOnlyFormat: 'depth32float',\n    channels: 1\n  },\n  depth32float: {\n    bytesPerBlock: 4,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    isDepthStencil: !0,\n    hasDepth: !0,\n    hasStencil: !1,\n    channels: 1\n  },\n  'depth32float-stencil8': {\n    bytesPerBlock: 8,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    isDepthStencil: !0,\n    hasDepth: !0,\n    hasStencil: !0,\n    stencilOnlyFormat: 'depth32float',\n    channels: 1\n  },\n  rgb9e5ufloat: {\n    bytesPerBlock: 4,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !1,\n    channels: 4\n  },\n  'bc1-rgba-unorm': {\n    bytesPerBlock: 8,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'bc1-rgba-unorm-srgb': {\n    bytesPerBlock: 8,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'bc2-rgba-unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'bc2-rgba-unorm-srgb': {\n    bytesPerBlock: 16,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'bc3-rgba-unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'bc3-rgba-unorm-srgb': {\n    bytesPerBlock: 16,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'bc4-r-unorm': {\n    bytesPerBlock: 8,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 1\n  },\n  'bc4-r-snorm': {\n    bytesPerBlock: 8,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 1\n  },\n  'bc5-rg-unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 2\n  },\n  'bc5-rg-snorm': {\n    bytesPerBlock: 16,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 2\n  },\n  'bc6h-rgb-ufloat': {\n    bytesPerBlock: 16,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'bc6h-rgb-float': {\n    bytesPerBlock: 16,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'bc7-rgba-unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'bc7-rgba-unorm-srgb': {\n    bytesPerBlock: 16,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'etc2-rgb8unorm': {\n    bytesPerBlock: 8,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'etc2-rgb8unorm-srgb': {\n    bytesPerBlock: 8,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'etc2-rgb8a1unorm': {\n    bytesPerBlock: 8,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'etc2-rgb8a1unorm-srgb': {\n    bytesPerBlock: 8,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'etc2-rgba8unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'etc2-rgba8unorm-srgb': {\n    bytesPerBlock: 16,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'eac-r11unorm': {\n    bytesPerBlock: 8,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !0,\n    channels: 1\n  },\n  'eac-r11snorm': {\n    bytesPerBlock: 8,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !0,\n    channels: 1\n  },\n  'eac-rg11unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !0,\n    channels: 2\n  },\n  'eac-rg11snorm': {\n    bytesPerBlock: 16,\n    blockWidth: 1,\n    blockHeight: 1,\n    isCompressed: !0,\n    channels: 2\n  },\n  'astc-4x4-unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-4x4-unorm-srgb': {\n    bytesPerBlock: 16,\n    blockWidth: 4,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-5x4-unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 5,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-5x4-unorm-srgb': {\n    bytesPerBlock: 16,\n    blockWidth: 5,\n    blockHeight: 4,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-5x5-unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 5,\n    blockHeight: 5,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-5x5-unorm-srgb': {\n    bytesPerBlock: 16,\n    blockWidth: 5,\n    blockHeight: 5,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-6x5-unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 6,\n    blockHeight: 5,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-6x5-unorm-srgb': {\n    bytesPerBlock: 16,\n    blockWidth: 6,\n    blockHeight: 5,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-6x6-unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 6,\n    blockHeight: 6,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-6x6-unorm-srgb': {\n    bytesPerBlock: 16,\n    blockWidth: 6,\n    blockHeight: 6,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-8x5-unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 8,\n    blockHeight: 5,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-8x5-unorm-srgb': {\n    bytesPerBlock: 16,\n    blockWidth: 8,\n    blockHeight: 5,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-8x6-unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 8,\n    blockHeight: 6,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-8x6-unorm-srgb': {\n    bytesPerBlock: 16,\n    blockWidth: 8,\n    blockHeight: 6,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-8x8-unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 8,\n    blockHeight: 8,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-8x8-unorm-srgb': {\n    bytesPerBlock: 16,\n    blockWidth: 8,\n    blockHeight: 8,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-10x5-unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 10,\n    blockHeight: 5,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-10x5-unorm-srgb': {\n    bytesPerBlock: 16,\n    blockWidth: 10,\n    blockHeight: 5,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-10x6-unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 10,\n    blockHeight: 6,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-10x6-unorm-srgb': {\n    bytesPerBlock: 16,\n    blockWidth: 10,\n    blockHeight: 6,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-10x8-unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 10,\n    blockHeight: 8,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-10x8-unorm-srgb': {\n    bytesPerBlock: 16,\n    blockWidth: 10,\n    blockHeight: 8,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-10x10-unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 10,\n    blockHeight: 10,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-10x10-unorm-srgb': {\n    bytesPerBlock: 16,\n    blockWidth: 10,\n    blockHeight: 10,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-12x10-unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 12,\n    blockHeight: 10,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-12x10-unorm-srgb': {\n    bytesPerBlock: 16,\n    blockWidth: 12,\n    blockHeight: 10,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-12x12-unorm': {\n    bytesPerBlock: 16,\n    blockWidth: 12,\n    blockHeight: 12,\n    isCompressed: !0,\n    channels: 4\n  },\n  'astc-12x12-unorm-srgb': {\n    bytesPerBlock: 16,\n    blockWidth: 12,\n    blockHeight: 12,\n    isCompressed: !0,\n    channels: 4\n  }\n};\nclass T {\n  constructor() {\n    this.id = T._id++, this.line = 0;\n  }\n  get isAstNode() {\n    return !0;\n  }\n  get astNodeType() {\n    return '';\n  }\n  search(e) {\n    e(this);\n  }\n  searchBlock(e, t) {\n    if (e) {\n      t(S.instance);\n      for (const n of e) n instanceof Array ? this.searchBlock(n, t) : n.search(t);\n      t(A.instance);\n    }\n  }\n  constEvaluate(e, t) {\n    throw new Error('Cannot evaluate node');\n  }\n  constEvaluateString(e) {\n    return this.constEvaluate(e).toString();\n  }\n}\nT._id = 0;\nclass S extends T {}\nS.instance = new S();\nclass A extends T {}\nA.instance = new A();\nconst E = new Set(['all', 'all', 'any', 'select', 'arrayLength', 'abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'atan2', 'ceil', 'clamp', 'cos', 'cosh', 'countLeadingZeros', 'countOneBits', 'countTrailingZeros', 'cross', 'degrees', 'determinant', 'distance', 'dot', 'dot4U8Packed', 'dot4I8Packed', 'exp', 'exp2', 'extractBits', 'faceForward', 'firstLeadingBit', 'firstTrailingBit', 'floor', 'fma', 'fract', 'frexp', 'insertBits', 'inverseSqrt', 'ldexp', 'length', 'log', 'log2', 'max', 'min', 'mix', 'modf', 'normalize', 'pow', 'quantizeToF16', 'radians', 'reflect', 'refract', 'reverseBits', 'round', 'saturate', 'sign', 'sin', 'sinh', 'smoothStep', 'sqrt', 'step', 'tan', 'tanh', 'transpose', 'trunc', 'dpdx', 'dpdxCoarse', 'dpdxFine', 'dpdy', 'dpdyCoarse', 'dpdyFine', 'fwidth', 'fwidthCoarse', 'fwidthFine', 'textureDimensions', 'textureGather', 'textureGatherCompare', 'textureLoad', 'textureNumLayers', 'textureNumLevels', 'textureNumSamples', 'textureSample', 'textureSampleBias', 'textureSampleCompare', 'textureSampleCompareLevel', 'textureSampleGrad', 'textureSampleLevel', 'textureSampleBaseClampToEdge', 'textureStore', 'atomicLoad', 'atomicStore', 'atomicAdd', 'atomicSub', 'atomicMax', 'atomicMin', 'atomicAnd', 'atomicOr', 'atomicXor', 'atomicExchange', 'atomicCompareExchangeWeak', 'pack4x8snorm', 'pack4x8unorm', 'pack4xI8', 'pack4xU8', 'pack4x8Clamp', 'pack4xU8Clamp', 'pack2x16snorm', 'pack2x16unorm', 'pack2x16float', 'unpack4x8snorm', 'unpack4x8unorm', 'unpack4xI8', 'unpack4xU8', 'unpack2x16snorm', 'unpack2x16unorm', 'unpack2x16float', 'storageBarrier', 'textureBarrier', 'workgroupBarrier', 'workgroupUniformLoad', 'subgroupAdd', 'subgroupExclusiveAdd', 'subgroupInclusiveAdd', 'subgroupAll', 'subgroupAnd', 'subgroupAny', 'subgroupBallot', 'subgroupBroadcast', 'subgroupBroadcastFirst', 'subgroupElect', 'subgroupMax', 'subgroupMin', 'subgroupMul', 'subgroupExclusiveMul', 'subgroupInclusiveMul', 'subgroupOr', 'subgroupShuffle', 'subgroupShuffleDown', 'subgroupShuffleUp', 'subgroupShuffleXor', 'subgroupXor', 'quadBroadcast', 'quadSwapDiagonal', 'quadSwapX', 'quadSwapY']);\nclass $ extends T {\n  constructor() {\n    super();\n  }\n}\nclass L extends $ {\n  constructor(e, t, n, s, r, a) {\n    super(), this.calls = new Set(), this.name = e, this.args = t, this.returnType = n, this.body = s, this.startLine = r, this.endLine = a;\n  }\n  get astNodeType() {\n    return 'function';\n  }\n  search(e) {\n    if (this.attributes) for (const t of this.attributes) e(t);\n    e(this);\n    for (const t of this.args) e(t);\n    this.searchBlock(this.body, e);\n  }\n}\nclass C extends $ {\n  constructor(e) {\n    super(), this.expression = e;\n  }\n  get astNodeType() {\n    return 'staticAssert';\n  }\n  search(e) {\n    this.expression.search(e);\n  }\n}\nclass D extends $ {\n  constructor(e, t) {\n    super(), this.condition = e, this.body = t;\n  }\n  get astNodeType() {\n    return 'while';\n  }\n  search(e) {\n    this.condition.search(e), this.searchBlock(this.body, e);\n  }\n}\nclass N extends $ {\n  constructor(e, t) {\n    super(), this.body = e, this.loopId = t;\n  }\n  get astNodeType() {\n    return 'continuing';\n  }\n  search(e) {\n    this.searchBlock(this.body, e);\n  }\n}\nclass V extends $ {\n  constructor(e, t, n, s) {\n    super(), this.init = e, this.condition = t, this.increment = n, this.body = s;\n  }\n  get astNodeType() {\n    return 'for';\n  }\n  search(e) {\n    var t, n, s;\n    null === (t = this.init) || void 0 === t || t.search(e), null === (n = this.condition) || void 0 === n || n.search(e), null === (s = this.increment) || void 0 === s || s.search(e), this.searchBlock(this.body, e);\n  }\n}\nclass O extends $ {\n  constructor(e, t, n, s, r) {\n    super(), this.attributes = null, this.name = e, this.type = t, this.storage = n, this.access = s, this.value = r;\n  }\n  get astNodeType() {\n    return 'var';\n  }\n  search(e) {\n    var t;\n    e(this), null === (t = this.value) || void 0 === t || t.search(e);\n  }\n}\nclass B extends $ {\n  constructor(e, t, n) {\n    super(), this.attributes = null, this.name = e, this.type = t, this.value = n;\n  }\n  get astNodeType() {\n    return 'override';\n  }\n  search(e) {\n    var t;\n    null === (t = this.value) || void 0 === t || t.search(e);\n  }\n}\nclass F extends $ {\n  constructor(e, t, n, s, r) {\n    super(), this.attributes = null, this.name = e, this.type = t, this.storage = n, this.access = s, this.value = r;\n  }\n  get astNodeType() {\n    return 'let';\n  }\n  search(e) {\n    var t;\n    e(this), null === (t = this.value) || void 0 === t || t.search(e);\n  }\n}\nclass M extends $ {\n  constructor(e, t, n, s, r) {\n    super(), this.attributes = null, this.name = e, this.type = t, this.storage = n, this.access = s, this.value = r;\n  }\n  get astNodeType() {\n    return 'const';\n  }\n  constEvaluate(e, t) {\n    return this.value.constEvaluate(e, t);\n  }\n  search(e) {\n    var t;\n    e(this), null === (t = this.value) || void 0 === t || t.search(e);\n  }\n}\nvar U, P, W, q;\n(e => {\n  e.increment = '++', e.decrement = '--';\n})(U || (U = {})), (e => {\n  e.parse = function (t) {\n    const n = t;\n    if ('parse' == n) throw new Error('Invalid value for IncrementOperator');\n    return e[n];\n  };\n})(U || (U = {}));\nclass H extends $ {\n  constructor(e, t) {\n    super(), this.operator = e, this.variable = t;\n  }\n  get astNodeType() {\n    return 'increment';\n  }\n  search(e) {\n    this.variable.search(e);\n  }\n}\n(e => {\n  e.assign = '=', e.addAssign = '+=', e.subtractAssin = '-=', e.multiplyAssign = '*=', e.divideAssign = '/=', e.moduloAssign = '%=', e.andAssign = '&=', e.orAssign = '|=', e.xorAssign = '^=', e.shiftLeftAssign = '<<=', e.shiftRightAssign = '>>=';\n})(P || (P = {})), (e => {\n  e.parse = function (e) {\n    const t = e;\n    if ('parse' == t) throw new Error('Invalid value for AssignOperator');\n    return t;\n  };\n})(P || (P = {}));\nclass z extends $ {\n  constructor(e, t, n) {\n    super(), this.operator = e, this.variable = t, this.value = n;\n  }\n  get astNodeType() {\n    return 'assign';\n  }\n  search(e) {\n    this.variable.search(e), this.value.search(e);\n  }\n}\nclass R extends $ {\n  constructor(e, t) {\n    super(), this.name = e, this.args = t;\n  }\n  get astNodeType() {\n    return 'call';\n  }\n  isBuiltin() {\n    return E.has(this.name);\n  }\n  search(e) {\n    for (const t of this.args) t.search(e);\n    e(this);\n  }\n}\nclass G extends $ {\n  constructor(e, t) {\n    super(), this.body = e, this.continuing = t;\n  }\n  get astNodeType() {\n    return 'loop';\n  }\n}\nclass X extends $ {\n  constructor(e, t) {\n    super(), this.condition = e, this.cases = t;\n  }\n  get astNodeType() {\n    return 'switch';\n  }\n}\nclass j extends $ {\n  constructor(e, t, n, s) {\n    super(), this.condition = e, this.body = t, this.elseif = n, this.else = s;\n  }\n  get astNodeType() {\n    return 'if';\n  }\n  search(e) {\n    this.condition.search(e), this.searchBlock(this.body, e), this.searchBlock(this.elseif, e), this.searchBlock(this.else, e);\n  }\n}\nclass Z extends $ {\n  constructor(e) {\n    super(), this.value = e;\n  }\n  get astNodeType() {\n    return 'return';\n  }\n  search(e) {\n    var t;\n    null === (t = this.value) || void 0 === t || t.search(e);\n  }\n}\nclass Q extends $ {\n  constructor(e) {\n    super(), this.name = e;\n  }\n  get astNodeType() {\n    return 'enable';\n  }\n}\nclass Y extends $ {\n  constructor(e) {\n    super(), this.extensions = e;\n  }\n  get astNodeType() {\n    return 'requires';\n  }\n}\nclass K extends $ {\n  constructor(e, t) {\n    super(), this.severity = e, this.rule = t;\n  }\n  get astNodeType() {\n    return 'diagnostic';\n  }\n}\nclass J extends $ {\n  constructor(e, t) {\n    super(), this.name = e, this.type = t;\n  }\n  get astNodeType() {\n    return 'alias';\n  }\n}\nclass ee extends $ {\n  constructor() {\n    super();\n  }\n  get astNodeType() {\n    return 'discard';\n  }\n}\nclass te extends $ {\n  constructor() {\n    super(), this.condition = null, this.loopId = -1;\n  }\n  get astNodeType() {\n    return 'break';\n  }\n}\nclass ne extends $ {\n  constructor() {\n    super(), this.loopId = -1;\n  }\n  get astNodeType() {\n    return 'continue';\n  }\n}\nclass se extends $ {\n  constructor(e) {\n    super(), this.attributes = null, this.name = e;\n  }\n  get astNodeType() {\n    return 'type';\n  }\n  get isStruct() {\n    return !1;\n  }\n  get isArray() {\n    return !1;\n  }\n  static maxFormatType(e) {\n    let t = e[0];\n    if ('f32' === t.name) return t;\n    for (let n = 1; n < e.length; ++n) {\n      const s = se._priority.get(t.name);\n      se._priority.get(e[n].name) < s && (t = e[n]);\n    }\n    return 'x32' === t.name ? se.i32 : t;\n  }\n  getTypeName() {\n    return this.name;\n  }\n}\nse.x32 = new se('x32'), se.f32 = new se('f32'), se.i32 = new se('i32'), se.u32 = new se('u32'), se.f16 = new se('f16'), se.bool = new se('bool'), se.void = new se('void'), se._priority = new Map([['f32', 0], ['f16', 1], ['u32', 2], ['i32', 3], ['x32', 3]]);\nclass re extends se {\n  constructor(e) {\n    super(e);\n  }\n}\nclass ae extends se {\n  constructor(e, t, n, s) {\n    super(e), this.members = t, this.startLine = n, this.endLine = s;\n  }\n  get astNodeType() {\n    return 'struct';\n  }\n  get isStruct() {\n    return !0;\n  }\n  getMemberIndex(e) {\n    for (let t = 0; t < this.members.length; t++) if (this.members[t].name == e) return t;\n    return -1;\n  }\n  search(e) {\n    for (const t of this.members) e(t);\n  }\n}\nclass ie extends se {\n  constructor(e, t, n) {\n    super(e), this.format = t, this.access = n;\n  }\n  get astNodeType() {\n    return 'template';\n  }\n  getTypeName() {\n    let e = this.name;\n    if (null !== this.format) {\n      if ('vec2' === e || 'vec3' === e || 'vec4' === e || 'mat2x2' === e || 'mat2x3' === e || 'mat2x4' === e || 'mat3x2' === e || 'mat3x3' === e || 'mat3x4' === e || 'mat4x2' === e || 'mat4x3' === e || 'mat4x4' === e) {\n        if ('f32' === this.format.name) return e += 'f', e;\n        if ('i32' === this.format.name) return e += 'i', e;\n        if ('u32' === this.format.name) return e += 'u', e;\n        if ('bool' === this.format.name) return e += 'b', e;\n        if ('f16' === this.format.name) return e += 'h', e;\n      }\n      e += `<${this.format.name}>`;\n    } else if ('vec2' === e || 'vec3' === e || 'vec4' === e) return e;\n    return e;\n  }\n}\nie.vec2f = new ie('vec2', se.f32, null), ie.vec3f = new ie('vec3', se.f32, null), ie.vec4f = new ie('vec4', se.f32, null), ie.vec2i = new ie('vec2', se.i32, null), ie.vec3i = new ie('vec3', se.i32, null), ie.vec4i = new ie('vec4', se.i32, null), ie.vec2u = new ie('vec2', se.u32, null), ie.vec3u = new ie('vec3', se.u32, null), ie.vec4u = new ie('vec4', se.u32, null), ie.vec2h = new ie('vec2', se.f16, null), ie.vec3h = new ie('vec3', se.f16, null), ie.vec4h = new ie('vec4', se.f16, null), ie.vec2b = new ie('vec2', se.bool, null), ie.vec3b = new ie('vec3', se.bool, null), ie.vec4b = new ie('vec4', se.bool, null), ie.mat2x2f = new ie('mat2x2', se.f32, null), ie.mat2x3f = new ie('mat2x3', se.f32, null), ie.mat2x4f = new ie('mat2x4', se.f32, null), ie.mat3x2f = new ie('mat3x2', se.f32, null), ie.mat3x3f = new ie('mat3x3', se.f32, null), ie.mat3x4f = new ie('mat3x4', se.f32, null), ie.mat4x2f = new ie('mat4x2', se.f32, null), ie.mat4x3f = new ie('mat4x3', se.f32, null), ie.mat4x4f = new ie('mat4x4', se.f32, null), ie.mat2x2h = new ie('mat2x2', se.f16, null), ie.mat2x3h = new ie('mat2x3', se.f16, null), ie.mat2x4h = new ie('mat2x4', se.f16, null), ie.mat3x2h = new ie('mat3x2', se.f16, null), ie.mat3x3h = new ie('mat3x3', se.f16, null), ie.mat3x4h = new ie('mat3x4', se.f16, null), ie.mat4x2h = new ie('mat4x2', se.f16, null), ie.mat4x3h = new ie('mat4x3', se.f16, null), ie.mat4x4h = new ie('mat4x4', se.f16, null), ie.mat2x2i = new ie('mat2x2', se.i32, null), ie.mat2x3i = new ie('mat2x3', se.i32, null), ie.mat2x4i = new ie('mat2x4', se.i32, null), ie.mat3x2i = new ie('mat3x2', se.i32, null), ie.mat3x3i = new ie('mat3x3', se.i32, null), ie.mat3x4i = new ie('mat3x4', se.i32, null), ie.mat4x2i = new ie('mat4x2', se.i32, null), ie.mat4x3i = new ie('mat4x3', se.i32, null), ie.mat4x4i = new ie('mat4x4', se.i32, null), ie.mat2x2u = new ie('mat2x2', se.u32, null), ie.mat2x3u = new ie('mat2x3', se.u32, null), ie.mat2x4u = new ie('mat2x4', se.u32, null), ie.mat3x2u = new ie('mat3x2', se.u32, null), ie.mat3x3u = new ie('mat3x3', se.u32, null), ie.mat3x4u = new ie('mat3x4', se.u32, null), ie.mat4x2u = new ie('mat4x2', se.u32, null), ie.mat4x3u = new ie('mat4x3', se.u32, null), ie.mat4x4u = new ie('mat4x4', se.u32, null);\nclass oe extends se {\n  constructor(e, t, n, s) {\n    super(e), this.storage = t, this.type = n, this.access = s;\n  }\n  get astNodeType() {\n    return 'pointer';\n  }\n}\nclass le extends se {\n  constructor(e, t, n, s) {\n    super(e), this.attributes = t, this.format = n, this.count = s;\n  }\n  get astNodeType() {\n    return 'array';\n  }\n  get isArray() {\n    return !0;\n  }\n}\nclass ce extends se {\n  constructor(e, t, n) {\n    super(e), this.format = t, this.access = n;\n  }\n  get astNodeType() {\n    return 'sampler';\n  }\n}\nclass ue extends T {\n  constructor() {\n    super(), this.postfix = null;\n  }\n}\nclass he extends ue {\n  constructor(e) {\n    super(), this.value = e;\n  }\n  get astNodeType() {\n    return 'stringExpr';\n  }\n  toString() {\n    return this.value;\n  }\n  constEvaluateString() {\n    return this.value;\n  }\n}\nclass fe extends ue {\n  constructor(e, t) {\n    super(), this.type = e, this.args = t;\n  }\n  get astNodeType() {\n    return 'createExpr';\n  }\n  search(e) {\n    if (e(this), this.args) for (const t of this.args) t.search(e);\n  }\n  constEvaluate(e, t) {\n    return t && (t[0] = this.type), e.evalExpression(this, e.context);\n  }\n}\nclass pe extends ue {\n  constructor(e, t) {\n    super(), this.cachedReturnValue = null, this.name = e, this.args = t;\n  }\n  get astNodeType() {\n    return 'callExpr';\n  }\n  setCachedReturnValue(e) {\n    this.cachedReturnValue = e;\n  }\n  get isBuiltin() {\n    return E.has(this.name);\n  }\n  constEvaluate(e, t) {\n    return e.evalExpression(this, e.context);\n  }\n  search(e) {\n    for (const t of this.args) t.search(e);\n    e(this);\n  }\n}\nclass de extends ue {\n  constructor(e) {\n    super(), this.name = e;\n  }\n  get astNodeType() {\n    return 'varExpr';\n  }\n  search(e) {\n    e(this), this.postfix && this.postfix.search(e);\n  }\n  constEvaluate(e, t) {\n    return e.evalExpression(this, e.context);\n  }\n}\nclass me extends ue {\n  constructor(e, t) {\n    super(), this.name = e, this.initializer = t;\n  }\n  get astNodeType() {\n    return 'constExpr';\n  }\n  constEvaluate(e, t) {\n    if (this.initializer) {\n      const t = e.evalExpression(this.initializer, e.context);\n      return null !== t && this.postfix ? t.getSubData(e, this.postfix, e.context) : t;\n    }\n    return null;\n  }\n  search(e) {\n    this.initializer.search(e);\n  }\n}\nclass _e extends ue {\n  constructor(e, t) {\n    super(), this.value = e, this.type = t;\n  }\n  get astNodeType() {\n    return 'literalExpr';\n  }\n  constEvaluate(e, t) {\n    return void 0 !== t && (t[0] = this.type), this.value;\n  }\n  get isScalar() {\n    return this.value instanceof Ve;\n  }\n  get isVector() {\n    return this.value instanceof Be || this.value instanceof Fe;\n  }\n  get scalarValue() {\n    return this.value instanceof Ve ? this.value.value : (console.error('Value is not scalar.'), 0);\n  }\n  get vectorValue() {\n    return this.value instanceof Be || this.value instanceof Fe ? this.value.data : (console.error('Value is not a vector or matrix.'), new Float32Array(0));\n  }\n}\nclass ge extends ue {\n  constructor(e, t) {\n    super(), this.type = e, this.value = t;\n  }\n  get astNodeType() {\n    return 'bitcastExpr';\n  }\n  search(e) {\n    this.value.search(e);\n  }\n}\nclass xe extends ue {\n  constructor(e, t) {\n    super(), this.type = e, this.args = t;\n  }\n  get astNodeType() {\n    return 'typecastExpr';\n  }\n  constEvaluate(e, t) {\n    return e.evalExpression(this, e.context);\n  }\n  search(e) {\n    this.searchBlock(this.args, e);\n  }\n}\nclass ye extends ue {\n  constructor(e) {\n    super(), this.index = e;\n  }\n  search(e) {\n    this.index.search(e);\n  }\n}\nclass be extends ue {\n  constructor() {\n    super();\n  }\n}\nclass ve extends be {\n  constructor(e, t) {\n    super(), this.operator = e, this.right = t;\n  }\n  get astNodeType() {\n    return 'unaryOp';\n  }\n  constEvaluate(e, t) {\n    return e.evalExpression(this, e.context);\n  }\n  search(e) {\n    this.right.search(e);\n  }\n}\nclass we extends be {\n  constructor(e, t, n) {\n    super(), this.operator = e, this.left = t, this.right = n;\n  }\n  get astNodeType() {\n    return 'binaryOp';\n  }\n  _getPromotedType(e, t) {\n    return e.name === t.name ? e : 'f32' === e.name || 'f32' === t.name ? se.f32 : 'u32' === e.name || 'u32' === t.name ? se.u32 : se.i32;\n  }\n  constEvaluate(e, t) {\n    return e.evalExpression(this, e.context);\n  }\n  search(e) {\n    this.left.search(e), this.right.search(e);\n  }\n}\nclass ke extends T {\n  constructor(e) {\n    super(), this.body = e;\n  }\n}\nclass Ie extends ue {\n  constructor() {\n    super();\n  }\n  get astNodeType() {\n    return 'default';\n  }\n}\nclass Te extends ke {\n  constructor(e, t) {\n    super(t), this.selectors = e;\n  }\n  get astNodeType() {\n    return 'case';\n  }\n  search(e) {\n    this.searchBlock(this.body, e);\n  }\n}\nclass Se extends ke {\n  constructor(e) {\n    super(e);\n  }\n  get astNodeType() {\n    return 'default';\n  }\n  search(e) {\n    this.searchBlock(this.body, e);\n  }\n}\nclass Ae extends T {\n  constructor(e, t, n) {\n    super(), this.name = e, this.type = t, this.attributes = n;\n  }\n  get astNodeType() {\n    return 'argument';\n  }\n}\nclass Ee extends T {\n  constructor(e, t) {\n    super(), this.condition = e, this.body = t;\n  }\n  get astNodeType() {\n    return 'elseif';\n  }\n  search(e) {\n    this.condition.search(e), this.searchBlock(this.body, e);\n  }\n}\nclass $e extends T {\n  constructor(e, t, n) {\n    super(), this.name = e, this.type = t, this.attributes = n;\n  }\n  get astNodeType() {\n    return 'member';\n  }\n}\nclass Le extends T {\n  constructor(e, t) {\n    super(), this.name = e, this.value = t;\n  }\n  get astNodeType() {\n    return 'attribute';\n  }\n}\nclass Ce {\n  constructor(e, t) {\n    this.parent = null, this.typeInfo = e, this.parent = t, this.id = Ce._id++;\n  }\n  clone() {\n    throw `Clone: Not implemented for ${this.constructor.name}`;\n  }\n  setDataValue(e, t, n, s) {\n    console.error(`SetDataValue: Not implemented for ${this.constructor.name}`);\n  }\n  getSubData(e, t, n) {\n    return console.error(`GetDataValue: Not implemented for ${this.constructor.name}`), null;\n  }\n  toString() {\n    return `<${this.typeInfo.name}>`;\n  }\n}\nCe._id = 0;\nclass De extends Ce {\n  constructor() {\n    super(new e('void', null), null);\n  }\n  toString() {\n    return 'void';\n  }\n}\nDe.void = new De();\nclass Ne extends Ce {\n  constructor(t) {\n    super(new e('pointer', null), null), this.reference = t;\n  }\n  clone() {\n    return this;\n  }\n  setDataValue(e, t, n, s) {\n    this.reference.setDataValue(e, t, n, s);\n  }\n  getSubData(e, t, n) {\n    return t ? this.reference.getSubData(e, t, n) : this;\n  }\n}\nclass Ve extends Ce {\n  constructor(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    super(t, n), e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array ? this.data = e : 'x32' === this.typeInfo.name ? e - Math.floor(e) != 0 ? this.data = new Float32Array([e]) : this.data = e >= 0 ? new Uint32Array([e]) : new Int32Array([e]) : 'i32' === this.typeInfo.name || 'bool' === this.typeInfo.name ? this.data = new Int32Array([e]) : 'u32' === this.typeInfo.name ? this.data = new Uint32Array([e]) : 'f32' === this.typeInfo.name || 'f16' === this.typeInfo.name ? this.data = new Float32Array([e]) : console.error('ScalarData2: Invalid type', t);\n  }\n  clone() {\n    if (this.data instanceof Float32Array) return new Ve(new Float32Array(this.data), this.typeInfo, null);\n    if (this.data instanceof Int32Array) return new Ve(new Int32Array(this.data), this.typeInfo, null);\n    if (this.data instanceof Uint32Array) return new Ve(new Uint32Array(this.data), this.typeInfo, null);\n    throw 'ScalarData: Invalid data type';\n  }\n  get value() {\n    return this.data[0];\n  }\n  set value(e) {\n    this.data[0] = e;\n  }\n  setDataValue(e, t, n, s) {\n    if (n) return void console.error('SetDataValue: Scalar data does not support postfix', n);\n    if (!(t instanceof Ve)) return void console.error('SetDataValue: Invalid value', t);\n    let r = t.data[0];\n    'i32' === this.typeInfo.name || 'u32' === this.typeInfo.name ? r = Math.floor(r) : 'bool' === this.typeInfo.name && (r = r ? 1 : 0), this.data[0] = r;\n  }\n  getSubData(e, t, n) {\n    return t ? (console.error('getSubData: Scalar data does not support postfix', t), null) : this;\n  }\n  toString() {\n    return `${this.value}`;\n  }\n}\nfunction Oe(e, t, n) {\n  const s = t.length;\n  return 2 === s ? 'f32' === n ? new Be(new Float32Array(t), e.getTypeInfo('vec2f')) : 'i32' === n || 'bool' === n ? new Be(new Int32Array(t), e.getTypeInfo('vec2i')) : 'u32' === n ? new Be(new Uint32Array(t), e.getTypeInfo('vec2u')) : 'f16' === n ? new Be(new Float32Array(t), e.getTypeInfo('vec2h')) : (console.error(`getSubData: Unknown format ${n}`), null) : 3 === s ? 'f32' === n ? new Be(new Float32Array(t), e.getTypeInfo('vec3f')) : 'i32' === n || 'bool' === n ? new Be(new Int32Array(t), e.getTypeInfo('vec3i')) : 'u32' === n ? new Be(new Uint32Array(t), e.getTypeInfo('vec3u')) : 'f16' === n ? new Be(new Float32Array(t), e.getTypeInfo('vec3h')) : (console.error(`getSubData: Unknown format ${n}`), null) : 4 === s ? 'f32' === n ? new Be(new Float32Array(t), e.getTypeInfo('vec4f')) : 'i32' === n || 'bool' === n ? new Be(new Int32Array(t), e.getTypeInfo('vec4i')) : 'u32' === n ? new Be(new Uint32Array(t), e.getTypeInfo('vec4u')) : 'f16' === n ? new Be(new Float32Array(t), e.getTypeInfo('vec4h')) : (console.error(`getSubData: Unknown format ${n}`), null) : (console.error(`getSubData: Invalid vector size ${t.length}`), null);\n}\nclass Be extends Ce {\n  constructor(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (super(t, n), e instanceof Float32Array || e instanceof Uint32Array || e instanceof Int32Array) this.data = e;else {\n      const t = this.typeInfo.name;\n      'vec2f' === t || 'vec3f' === t || 'vec4f' === t ? this.data = new Float32Array(e) : 'vec2i' === t || 'vec3i' === t || 'vec4i' === t ? this.data = new Int32Array(e) : 'vec2u' === t || 'vec3u' === t || 'vec4u' === t ? this.data = new Uint32Array(e) : 'vec2h' === t || 'vec3h' === t || 'vec4h' === t ? this.data = new Float32Array(e) : 'vec2b' === t || 'vec3b' === t || 'vec4b' === t ? this.data = new Int32Array(e) : 'vec2' === t || 'vec3' === t || 'vec4' === t ? this.data = new Float32Array(e) : console.error(`VectorData: Invalid type ${t}`);\n    }\n  }\n  clone() {\n    if (this.data instanceof Float32Array) return new Be(new Float32Array(this.data), this.typeInfo, null);\n    if (this.data instanceof Int32Array) return new Be(new Int32Array(this.data), this.typeInfo, null);\n    if (this.data instanceof Uint32Array) return new Be(new Uint32Array(this.data), this.typeInfo, null);\n    throw 'VectorData: Invalid data type';\n  }\n  setDataValue(e, t, n, s) {\n    n instanceof he ? console.error('TODO: Set vector postfix') : t instanceof Be ? this.data = t.data : console.error('SetDataValue: Invalid value', t);\n  }\n  getSubData(e, t, n) {\n    if (null === t) return this;\n    let s = e.getTypeInfo('f32');\n    if (this.typeInfo instanceof r) s = this.typeInfo.format || s;else {\n      const t = this.typeInfo.name;\n      'vec2f' === t || 'vec3f' === t || 'vec4f' === t ? s = e.getTypeInfo('f32') : 'vec2i' === t || 'vec3i' === t || 'vec4i' === t ? s = e.getTypeInfo('i32') : 'vec2b' === t || 'vec3b' === t || 'vec4b' === t ? s = e.getTypeInfo('bool') : 'vec2u' === t || 'vec3u' === t || 'vec4u' === t ? s = e.getTypeInfo('u32') : 'vec2h' === t || 'vec3h' === t || 'vec4h' === t ? s = e.getTypeInfo('f16') : console.error(`GetSubData: Unknown type ${t}`);\n    }\n    let a = this;\n    for (; null !== t && null !== a;) {\n      if (t instanceof ye) {\n        const r = t.index;\n        let i = -1;\n        if (r instanceof _e) {\n          if (!(r.value instanceof Ve)) return console.error(`GetSubData: Invalid array index ${r.value}`), null;\n          i = r.value.value;\n        } else {\n          const t = e.evalExpression(r, n);\n          if (!(t instanceof Ve)) return console.error('GetSubData: Unknown index type', r), null;\n          i = t.value;\n        }\n        if (i < 0 || i >= a.data.length) return console.error('GetSubData: Index out of range', i), null;\n        if (a.data instanceof Float32Array) {\n          const e = new Float32Array(a.data.buffer, a.data.byteOffset + 4 * i, 1);\n          return new Ve(e, s);\n        }\n        if (a.data instanceof Int32Array) {\n          const e = new Int32Array(a.data.buffer, a.data.byteOffset + 4 * i, 1);\n          return new Ve(e, s);\n        }\n        if (a.data instanceof Uint32Array) {\n          const e = new Uint32Array(a.data.buffer, a.data.byteOffset + 4 * i, 1);\n          return new Ve(e, s);\n        }\n        throw 'GetSubData: Invalid data type';\n      }\n      if (!(t instanceof he)) return console.error('GetSubData: Unknown postfix', t), null;\n      {\n        const n = t.value.toLowerCase();\n        if (1 === n.length) {\n          let e = 0;\n          if ('x' === n || 'r' === n) e = 0;else if ('y' === n || 'g' === n) e = 1;else if ('z' === n || 'b' === n) e = 2;else {\n            if ('w' !== n && 'a' !== n) return console.error(`GetSubData: Unknown member ${n}`), null;\n            e = 3;\n          }\n          if (this.data instanceof Float32Array) {\n            let t = new Float32Array(this.data.buffer, this.data.byteOffset + 4 * e, 1);\n            return new Ve(t, s, this);\n          }\n          if (this.data instanceof Int32Array) {\n            let t = new Int32Array(this.data.buffer, this.data.byteOffset + 4 * e, 1);\n            return new Ve(t, s, this);\n          }\n          if (this.data instanceof Uint32Array) {\n            let t = new Uint32Array(this.data.buffer, this.data.byteOffset + 4 * e, 1);\n            return new Ve(t, s, this);\n          }\n        }\n        const r = [];\n        for (const e of n) 'x' === e || 'r' === e ? r.push(this.data[0]) : 'y' === e || 'g' === e ? r.push(this.data[1]) : 'z' === e || 'b' === e ? r.push(this.data[2]) : 'w' === e || 'a' === e ? r.push(this.data[3]) : console.error(`GetDataValue: Unknown member ${e}`);\n        a = Oe(e, r, s.name);\n      }\n      t = t.postfix;\n    }\n    return a;\n  }\n  toString() {\n    let e = `${this.data[0]}`;\n    for (let t = 1; t < this.data.length; ++t) e += `, ${this.data[t]}`;\n    return e;\n  }\n}\nclass Fe extends Ce {\n  constructor(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    super(t, n), e instanceof Float32Array ? this.data = e : this.data = new Float32Array(e);\n  }\n  clone() {\n    return new Fe(new Float32Array(this.data), this.typeInfo, null);\n  }\n  setDataValue(e, t, n, s) {\n    n instanceof he ? console.error('TODO: Set matrix postfix') : t instanceof Fe ? this.data = t.data : console.error('SetDataValue: Invalid value', t);\n  }\n  getSubData(e, t, n) {\n    if (null === t) return this;\n    const s = this.typeInfo.name;\n    if (e.getTypeInfo('f32'), this.typeInfo instanceof r) this.typeInfo.format;else if (s.endsWith('f')) e.getTypeInfo('f32');else if (s.endsWith('i')) e.getTypeInfo('i32');else if (s.endsWith('u')) e.getTypeInfo('u32');else {\n      if (!s.endsWith('h')) return console.error(`GetDataValue: Unknown type ${s}`), null;\n      e.getTypeInfo('f16');\n    }\n    if (t instanceof ye) {\n      const r = t.index;\n      let a = -1;\n      if (r instanceof _e) {\n        if (!(r.value instanceof Ve)) return console.error(`GetDataValue: Invalid array index ${r.value}`), null;\n        a = r.value.value;\n      } else {\n        const t = e.evalExpression(r, n);\n        if (!(t instanceof Ve)) return console.error('GetDataValue: Unknown index type', r), null;\n        a = t.value;\n      }\n      if (a < 0 || a >= this.data.length) return console.error('GetDataValue: Index out of range', a), null;\n      const i = s.endsWith('h') ? 'h' : 'f';\n      let o;\n      if ('mat2x2' === s || 'mat2x2f' === s || 'mat2x2h' === s || 'mat3x2' === s || 'mat3x2f' === s || 'mat3x2h' === s || 'mat4x2' === s || 'mat4x2f' === s || 'mat4x2h' === s) o = new Be(new Float32Array(this.data.buffer, this.data.byteOffset + 2 * a * 4, 2), e.getTypeInfo(`vec2${i}`));else if ('mat2x3' === s || 'mat2x3f' === s || 'mat2x3h' === s || 'mat3x3' === s || 'mat3x3f' === s || 'mat3x3h' === s || 'mat4x3' === s || 'mat4x3f' === s || 'mat4x3h' === s) o = new Be(new Float32Array(this.data.buffer, this.data.byteOffset + 3 * a * 4, 3), e.getTypeInfo(`vec3${i}`));else {\n        if ('mat2x4' !== s && 'mat2x4f' !== s && 'mat2x4h' !== s && 'mat3x4' !== s && 'mat3x4f' !== s && 'mat3x4h' !== s && 'mat4x4' !== s && 'mat4x4f' !== s && 'mat4x4h' !== s) return console.error(`GetDataValue: Unknown type ${s}`), null;\n        o = new Be(new Float32Array(this.data.buffer, this.data.byteOffset + 4 * a * 4, 4), e.getTypeInfo(`vec4${i}`));\n      }\n      return t.postfix ? o.getSubData(e, t.postfix, n) : o;\n    }\n    return console.error('GetDataValue: Invalid postfix', t), null;\n  }\n  toString() {\n    let e = `${this.data[0]}`;\n    for (let t = 1; t < this.data.length; ++t) e += `, ${this.data[t]}`;\n    return e;\n  }\n}\nclass Me extends Ce {\n  constructor(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    super(t, s), this.buffer = e instanceof ArrayBuffer ? e : e.buffer, this.offset = n;\n  }\n  clone() {\n    const e = new Uint8Array(new Uint8Array(this.buffer, this.offset, this.typeInfo.size));\n    return new Me(e.buffer, this.typeInfo, 0, null);\n  }\n  setDataValue(t, r, a, i) {\n    if (null === r) return void console.log('setDataValue: NULL data.');\n    let o = this.offset,\n      l = this.typeInfo;\n    for (; a;) {\n      if (a instanceof ye) {\n        if (l instanceof s) {\n          const e = a.index;\n          if (e instanceof _e) {\n            if (!(e.value instanceof Ve)) return void console.error(`SetDataValue: Invalid index type ${e.value}`);\n            o += e.value.value * l.stride;\n          } else {\n            const n = t.evalExpression(e, i);\n            if (!(n instanceof Ve)) return void console.error('SetDataValue: Unknown index type', e);\n            o += n.value * l.stride;\n          }\n          l = l.format;\n        } else console.error(`SetDataValue: Type ${l.getTypeName()} is not an array`);\n      } else {\n        if (!(a instanceof he)) return void console.error('SetDataValue: Unknown postfix type', a);\n        {\n          const t = a.value;\n          if (l instanceof n) {\n            let e = !1;\n            for (const n of l.members) if (n.name === t) {\n              o += n.offset, l = n.type, e = !0;\n              break;\n            }\n            if (!e) return void console.error(`SetDataValue: Member ${t} not found`);\n          } else if (l instanceof e) {\n            const e = l.getTypeName();\n            let n = 0;\n            if ('x' === t || 'r' === t) n = 0;else if ('y' === t || 'g' === t) n = 1;else if ('z' === t || 'b' === t) n = 2;else {\n              if ('w' !== t && 'a' !== t) return void console.error(`SetDataValue: Unknown member ${t}`);\n              n = 3;\n            }\n            if (!(r instanceof Ve)) return void console.error('SetDataValue: Invalid value', r);\n            const s = r.value;\n            return 'vec2f' === e ? void (new Float32Array(this.buffer, o, 2)[n] = s) : 'vec3f' === e ? void (new Float32Array(this.buffer, o, 3)[n] = s) : 'vec4f' === e ? void (new Float32Array(this.buffer, o, 4)[n] = s) : 'vec2i' === e ? void (new Int32Array(this.buffer, o, 2)[n] = s) : 'vec3i' === e ? void (new Int32Array(this.buffer, o, 3)[n] = s) : 'vec4i' === e ? void (new Int32Array(this.buffer, o, 4)[n] = s) : 'vec2u' === e ? void (new Uint32Array(this.buffer, o, 2)[n] = s) : 'vec3u' === e ? void (new Uint32Array(this.buffer, o, 3)[n] = s) : 'vec4u' === e ? void (new Uint32Array(this.buffer, o, 4)[n] = s) : void console.error(`SetDataValue: Type ${e} is not a struct`);\n          }\n        }\n      }\n      a = a.postfix;\n    }\n    this.setData(t, r, l, o, i);\n  }\n  setData(e, t, n, s, r) {\n    const a = n.getTypeName();\n    if ('f32' !== a && 'f16' !== a) {\n      if ('i32' !== a && 'atomic<i32>' !== a && 'x32' !== a) {\n        if ('u32' !== a && 'atomic<u32>' !== a) {\n          if ('bool' !== a) {\n            if ('vec2f' !== a && 'vec2h' !== a) {\n              if ('vec3f' !== a && 'vec3h' !== a) {\n                if ('vec4f' !== a && 'vec4h' !== a) {\n                  if ('vec2i' !== a) {\n                    if ('vec3i' !== a) {\n                      if ('vec4i' !== a) {\n                        if ('vec2u' !== a) {\n                          if ('vec3u' !== a) {\n                            if ('vec4u' !== a) {\n                              if ('vec2b' !== a) {\n                                if ('vec3b' !== a) {\n                                  if ('vec4b' !== a) {\n                                    if ('mat2x2f' !== a && 'mat2x2h' !== a) {\n                                      if ('mat2x3f' !== a && 'mat2x3h' !== a) {\n                                        if ('mat2x4f' !== a && 'mat2x4h' !== a) {\n                                          if ('mat3x2f' !== a && 'mat3x2h' !== a) {\n                                            if ('mat3x3f' !== a && 'mat3x3h' !== a) {\n                                              if ('mat3x4f' !== a && 'mat3x4h' !== a) {\n                                                if ('mat4x2f' !== a && 'mat4x2h' !== a) {\n                                                  if ('mat4x3f' !== a && 'mat4x3h' !== a) {\n                                                    if ('mat4x4f' !== a && 'mat4x4h' !== a) {\n                                                      if (t instanceof Me) {\n                                                        if (n === t.typeInfo) {\n                                                          return void new Uint8Array(this.buffer, s, t.buffer.byteLength).set(new Uint8Array(t.buffer));\n                                                        }\n                                                        console.error('SetDataValue: Type mismatch', a, t.typeInfo.getTypeName());\n                                                      } else console.error(`SetData: Unknown type ${a}`);\n                                                    } else {\n                                                      const e = new Float32Array(this.buffer, s, 16);\n                                                      t instanceof Fe ? (e[0] = t.data[0], e[1] = t.data[1], e[2] = t.data[2], e[3] = t.data[3], e[4] = t.data[4], e[5] = t.data[5], e[6] = t.data[6], e[7] = t.data[7], e[8] = t.data[8], e[9] = t.data[9], e[10] = t.data[10], e[11] = t.data[11], e[12] = t.data[12], e[13] = t.data[13], e[14] = t.data[14], e[15] = t.data[15]) : (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]);\n                                                    }\n                                                  } else {\n                                                    const e = new Float32Array(this.buffer, s, 12);\n                                                    t instanceof Fe ? (e[0] = t.data[0], e[1] = t.data[1], e[2] = t.data[2], e[3] = t.data[3], e[4] = t.data[4], e[5] = t.data[5], e[6] = t.data[6], e[7] = t.data[7], e[8] = t.data[8], e[9] = t.data[9], e[10] = t.data[10], e[11] = t.data[11]) : (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11]);\n                                                  }\n                                                } else {\n                                                  const e = new Float32Array(this.buffer, s, 8);\n                                                  t instanceof Fe ? (e[0] = t.data[0], e[1] = t.data[1], e[2] = t.data[2], e[3] = t.data[3], e[4] = t.data[4], e[5] = t.data[5], e[6] = t.data[6], e[7] = t.data[7]) : (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7]);\n                                                }\n                                              } else {\n                                                const e = new Float32Array(this.buffer, s, 12);\n                                                t instanceof Fe ? (e[0] = t.data[0], e[1] = t.data[1], e[2] = t.data[2], e[3] = t.data[3], e[4] = t.data[4], e[5] = t.data[5], e[6] = t.data[6], e[7] = t.data[7], e[8] = t.data[8], e[9] = t.data[9], e[10] = t.data[10], e[11] = t.data[11]) : (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11]);\n                                              }\n                                            } else {\n                                              const e = new Float32Array(this.buffer, s, 9);\n                                              t instanceof Fe ? (e[0] = t.data[0], e[1] = t.data[1], e[2] = t.data[2], e[3] = t.data[3], e[4] = t.data[4], e[5] = t.data[5], e[6] = t.data[6], e[7] = t.data[7], e[8] = t.data[8]) : (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8]);\n                                            }\n                                          } else {\n                                            const e = new Float32Array(this.buffer, s, 6);\n                                            t instanceof Fe ? (e[0] = t.data[0], e[1] = t.data[1], e[2] = t.data[2], e[3] = t.data[3], e[4] = t.data[4], e[5] = t.data[5]) : (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5]);\n                                          }\n                                        } else {\n                                          const e = new Float32Array(this.buffer, s, 8);\n                                          t instanceof Fe ? (e[0] = t.data[0], e[1] = t.data[1], e[2] = t.data[2], e[3] = t.data[3], e[4] = t.data[4], e[5] = t.data[5], e[6] = t.data[6], e[7] = t.data[7]) : (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7]);\n                                        }\n                                      } else {\n                                        const e = new Float32Array(this.buffer, s, 6);\n                                        t instanceof Fe ? (e[0] = t.data[0], e[1] = t.data[1], e[2] = t.data[2], e[3] = t.data[3], e[4] = t.data[4], e[5] = t.data[5]) : (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5]);\n                                      }\n                                    } else {\n                                      const e = new Float32Array(this.buffer, s, 4);\n                                      t instanceof Fe ? (e[0] = t.data[0], e[1] = t.data[1], e[2] = t.data[2], e[3] = t.data[3]) : (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3]);\n                                    }\n                                  } else {\n                                    const e = new Uint32Array(this.buffer, s, 4);\n                                    t instanceof Be ? (e[0] = t.data[0], e[1] = t.data[1], e[2] = t.data[2], e[3] = t.data[3]) : (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3]);\n                                  }\n                                } else {\n                                  const e = new Uint32Array(this.buffer, s, 3);\n                                  t instanceof Be ? (e[0] = t.data[0], e[1] = t.data[1], e[2] = t.data[2]) : (e[0] = t[0], e[1] = t[1], e[2] = t[2]);\n                                }\n                              } else {\n                                const e = new Uint32Array(this.buffer, s, 2);\n                                t instanceof Be ? (e[0] = t.data[0], e[1] = t.data[1]) : (e[0] = t[0], e[1] = t[1]);\n                              }\n                            } else {\n                              const e = new Uint32Array(this.buffer, s, 4);\n                              t instanceof Be ? (e[0] = t.data[0], e[1] = t.data[1], e[2] = t.data[2], e[3] = t.data[3]) : (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3]);\n                            }\n                          } else {\n                            const e = new Uint32Array(this.buffer, s, 3);\n                            t instanceof Be ? (e[0] = t.data[0], e[1] = t.data[1], e[2] = t.data[2]) : (e[0] = t[0], e[1] = t[1], e[2] = t[2]);\n                          }\n                        } else {\n                          const e = new Uint32Array(this.buffer, s, 2);\n                          t instanceof Be ? (e[0] = t.data[0], e[1] = t.data[1]) : (e[0] = t[0], e[1] = t[1]);\n                        }\n                      } else {\n                        const e = new Int32Array(this.buffer, s, 4);\n                        t instanceof Be ? (e[0] = t.data[0], e[1] = t.data[1], e[2] = t.data[2], e[3] = t.data[3]) : (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3]);\n                      }\n                    } else {\n                      const e = new Int32Array(this.buffer, s, 3);\n                      t instanceof Be ? (e[0] = t.data[0], e[1] = t.data[1], e[2] = t.data[2]) : (e[0] = t[0], e[1] = t[1], e[2] = t[2]);\n                    }\n                  } else {\n                    const e = new Int32Array(this.buffer, s, 2);\n                    t instanceof Be ? (e[0] = t.data[0], e[1] = t.data[1]) : (e[0] = t[0], e[1] = t[1]);\n                  }\n                } else {\n                  const e = new Float32Array(this.buffer, s, 4);\n                  t instanceof Be ? (e[0] = t.data[0], e[1] = t.data[1], e[2] = t.data[2], e[3] = t.data[3]) : (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3]);\n                }\n              } else {\n                const e = new Float32Array(this.buffer, s, 3);\n                t instanceof Be ? (e[0] = t.data[0], e[1] = t.data[1], e[2] = t.data[2]) : (e[0] = t[0], e[1] = t[1], e[2] = t[2]);\n              }\n            } else {\n              const e = new Float32Array(this.buffer, s, 2);\n              t instanceof Be ? (e[0] = t.data[0], e[1] = t.data[1]) : (e[0] = t[0], e[1] = t[1]);\n            }\n          } else t instanceof Ve && (new Int32Array(this.buffer, s, 1)[0] = t.value);\n        } else t instanceof Ve && (new Uint32Array(this.buffer, s, 1)[0] = t.value);\n      } else t instanceof Ve && (new Int32Array(this.buffer, s, 1)[0] = t.value);\n    } else t instanceof Ve && (new Float32Array(this.buffer, s, 1)[0] = t.value);\n  }\n  getSubData(t, a, i) {\n    var o, l, c;\n    if (null === a) return this;\n    let u = this.offset,\n      h = this.typeInfo;\n    for (; a;) {\n      if (a instanceof ye) {\n        const e = a.index,\n          n = t.evalExpression(e, i);\n        let r = 0;\n        if (n instanceof Ve ? r = n.value : console.error('GetDataValue: Invalid index type', e), h instanceof s) u += r * h.stride, h = h.format;else {\n          const e = h.getTypeName();\n          'mat4x4' === e || 'mat4x4f' === e || 'mat4x4h' === e ? (u += 16 * r, h = t.getTypeInfo('vec4f')) : console.error(`getDataValue: Type ${h.getTypeName()} is not an array`);\n        }\n      } else {\n        if (!(a instanceof he)) return console.error('GetDataValue: Unknown postfix type', a), null;\n        {\n          const s = a.value;\n          if (h instanceof n) {\n            let e = !1;\n            for (const t of h.members) if (t.name === s) {\n              u += t.offset, h = t.type, e = !0;\n              break;\n            }\n            if (!e) return console.error(`GetDataValue: Member ${s} not found`), null;\n          } else if (h instanceof e) {\n            const e = h.getTypeName();\n            if ('vec2f' === e || 'vec3f' === e || 'vec4f' === e || 'vec2i' === e || 'vec3i' === e || 'vec4i' === e || 'vec2u' === e || 'vec3u' === e || 'vec4u' === e || 'vec2b' === e || 'vec3b' === e || 'vec4b' === e || 'vec2h' === e || 'vec3h' === e || 'vec4h' === e || 'vec2' === e || 'vec3' === e || 'vec4' === e) {\n              if (s.length > 0 && s.length < 5) {\n                let n = 'f';\n                const r = [];\n                for (let a = 0; a < s.length; ++a) {\n                  const i = s[a].toLowerCase();\n                  let o = 0;\n                  if ('x' === i || 'r' === i) o = 0;else if ('y' === i || 'g' === i) o = 1;else if ('z' === i || 'b' === i) o = 2;else {\n                    if ('w' !== i && 'a' !== i) return console.error(`Unknown member ${s}`), null;\n                    o = 3;\n                  }\n                  if (1 === s.length) {\n                    if (e.endsWith('f')) return this.buffer.byteLength < u + 4 * o + 4 ? (console.log('Insufficient buffer data'), null) : new Ve(new Float32Array(this.buffer, u + 4 * o, 1), t.getTypeInfo('f32'), this);\n                    if (e.endsWith('h')) return new Ve(new Float32Array(this.buffer, u + 4 * o, 1), t.getTypeInfo('f16'), this);\n                    if (e.endsWith('i')) return new Ve(new Int32Array(this.buffer, u + 4 * o, 1), t.getTypeInfo('i32'), this);\n                    if (e.endsWith('b')) return new Ve(new Int32Array(this.buffer, u + 4 * o, 1), t.getTypeInfo('bool'), this);\n                    if (e.endsWith('u')) return new Ve(new Uint32Array(this.buffer, u + 4 * o, 1), t.getTypeInfo('i32'), this);\n                  }\n                  if ('vec2f' === e) r.push(new Float32Array(this.buffer, u, 2)[o]);else if ('vec3f' === e) {\n                    if (u + 12 >= this.buffer.byteLength) return console.log('Insufficient buffer data'), null;\n                    const e = new Float32Array(this.buffer, u, 3);\n                    r.push(e[o]);\n                  } else if ('vec4f' === e) r.push(new Float32Array(this.buffer, u, 4)[o]);else if ('vec2i' === e) n = 'i', r.push(new Int32Array(this.buffer, u, 2)[o]);else if ('vec3i' === e) n = 'i', r.push(new Int32Array(this.buffer, u, 3)[o]);else if ('vec4i' === e) n = 'i', r.push(new Int32Array(this.buffer, u, 4)[o]);else if ('vec2u' === e) {\n                    n = 'u';\n                    const e = new Uint32Array(this.buffer, u, 2);\n                    r.push(e[o]);\n                  } else 'vec3u' === e ? (n = 'u', r.push(new Uint32Array(this.buffer, u, 3)[o])) : 'vec4u' === e && (n = 'u', r.push(new Uint32Array(this.buffer, u, 4)[o]));\n                }\n                return 2 === r.length ? h = t.getTypeInfo(`vec2${n}`) : 3 === r.length ? h = t.getTypeInfo(`vec3${n}`) : 4 === r.length ? h = t.getTypeInfo(`vec4${n}`) : console.error(`GetDataValue: Invalid vector length ${r.length}`), new Be(r, h, null);\n              }\n              return console.error(`GetDataValue: Unknown member ${s}`), null;\n            }\n            return console.error(`GetDataValue: Type ${e} is not a struct`), null;\n          }\n        }\n      }\n      a = a.postfix;\n    }\n    const f = h.getTypeName();\n    return 'f32' === f ? new Ve(new Float32Array(this.buffer, u, 1), h, this) : 'i32' === f ? new Ve(new Int32Array(this.buffer, u, 1), h, this) : 'u32' === f ? new Ve(new Uint32Array(this.buffer, u, 1), h, this) : 'vec2f' === f ? new Be(new Float32Array(this.buffer, u, 2), h, this) : 'vec3f' === f ? new Be(new Float32Array(this.buffer, u, 3), h, this) : 'vec4f' === f ? new Be(new Float32Array(this.buffer, u, 4), h, this) : 'vec2i' === f ? new Be(new Int32Array(this.buffer, u, 2), h, this) : 'vec3i' === f ? new Be(new Int32Array(this.buffer, u, 3), h, this) : 'vec4i' === f ? new Be(new Int32Array(this.buffer, u, 4), h, this) : 'vec2u' === f ? new Be(new Uint32Array(this.buffer, u, 2), h, this) : 'vec3u' === f ? new Be(new Uint32Array(this.buffer, u, 3), h, this) : 'vec4u' === f ? new Be(new Uint32Array(this.buffer, u, 4), h, this) : h instanceof r && 'atomic' === h.name ? 'u32' === (null === (o = h.format) || void 0 === o ? void 0 : o.name) ? new Ve(new Uint32Array(this.buffer, u, 1)[0], h.format, this) : 'i32' === (null === (l = h.format) || void 0 === l ? void 0 : l.name) ? new Ve(new Int32Array(this.buffer, u, 1)[0], h.format, this) : (console.error(`GetDataValue: Invalid atomic format ${null === (c = h.format) || void 0 === c ? void 0 : c.name}`), null) : new Me(this.buffer, h, u, this);\n  }\n  toString() {\n    let e = '';\n    if (this.typeInfo instanceof s) {\n      if ('f32' === this.typeInfo.format.name) {\n        const t = new Float32Array(this.buffer, this.offset);\n        e = `[${t[0]}`;\n        for (let n = 1; n < t.length; ++n) e += `, ${t[n]}`;\n      } else if ('i32' === this.typeInfo.format.name) {\n        const t = new Int32Array(this.buffer, this.offset);\n        e = `[${t[0]}`;\n        for (let n = 1; n < t.length; ++n) e += `, ${t[n]}`;\n      } else if ('u32' === this.typeInfo.format.name) {\n        const t = new Uint32Array(this.buffer, this.offset);\n        e = `[${t[0]}`;\n        for (let n = 1; n < t.length; ++n) e += `, ${t[n]}`;\n      } else if ('vec2f' === this.typeInfo.format.name) {\n        const t = new Float32Array(this.buffer, this.offset);\n        e = `[${t[0]}, ${t[1]}]`;\n        for (let n = 1; n < t.length / 2; ++n) e += `, [${t[2 * n]}, ${t[2 * n + 1]}]`;\n      } else if ('vec3f' === this.typeInfo.format.name) {\n        const t = new Float32Array(this.buffer, this.offset);\n        e = `[${t[0]}, ${t[1]}, ${t[2]}]`;\n        for (let n = 4; n < t.length; n += 4) e += `, [${t[n]}, ${t[n + 1]}, ${t[n + 2]}]`;\n      } else if ('vec4f' === this.typeInfo.format.name) {\n        const t = new Float32Array(this.buffer, this.offset);\n        e = `[${t[0]}, ${t[1]}, ${t[2]}, ${t[3]}]`;\n        for (let n = 4; n < t.length; n += 4) e += `, [${t[n]}, ${t[n + 1]}, ${t[n + 2]}, ${t[n + 3]}]`;\n      } else e = '[...]';\n    } else this.typeInfo instanceof n ? e += '{...}' : e = '[...]';\n    return e;\n  }\n}\nclass Ue extends Ce {\n  constructor(e, t, n, s) {\n    super(t, null), this.data = e, this.descriptor = n, this.view = s;\n  }\n  clone() {\n    return new Ue(this.data, this.typeInfo, this.descriptor, this.view);\n  }\n  get width() {\n    var e, t;\n    const n = this.descriptor.size;\n    return n instanceof Array && n.length > 0 ? null !== (e = n[0]) && void 0 !== e ? e : 0 : n instanceof Object && null !== (t = n.width) && void 0 !== t ? t : 0;\n  }\n  get height() {\n    var e, t;\n    const n = this.descriptor.size;\n    return n instanceof Array && n.length > 1 ? null !== (e = n[1]) && void 0 !== e ? e : 0 : n instanceof Object && null !== (t = n.height) && void 0 !== t ? t : 0;\n  }\n  get depthOrArrayLayers() {\n    var e, t;\n    const n = this.descriptor.size;\n    return n instanceof Array && n.length > 2 ? null !== (e = n[2]) && void 0 !== e ? e : 0 : n instanceof Object && null !== (t = n.depthOrArrayLayers) && void 0 !== t ? t : 0;\n  }\n  get format() {\n    var e;\n    return this.descriptor && null !== (e = this.descriptor.format) && void 0 !== e ? e : 'rgba8unorm';\n  }\n  get sampleCount() {\n    var e;\n    return this.descriptor && null !== (e = this.descriptor.sampleCount) && void 0 !== e ? e : 1;\n  }\n  get mipLevelCount() {\n    var e;\n    return this.descriptor && null !== (e = this.descriptor.mipLevelCount) && void 0 !== e ? e : 1;\n  }\n  get dimension() {\n    var e;\n    return this.descriptor && null !== (e = this.descriptor.dimension) && void 0 !== e ? e : '2d';\n  }\n  getMipLevelSize(e) {\n    if (e >= this.mipLevelCount) return [0, 0, 0];\n    const t = [this.width, this.height, this.depthOrArrayLayers];\n    for (let n = 0; n < t.length; ++n) t[n] = Math.max(1, t[n] >> e);\n    return t;\n  }\n  get texelByteSize() {\n    const e = this.format,\n      t = I[e];\n    return t ? t.isDepthStencil ? 4 : t.bytesPerBlock : 0;\n  }\n  get bytesPerRow() {\n    return this.width * this.texelByteSize;\n  }\n  get isDepthStencil() {\n    const e = this.format,\n      t = I[e];\n    return !!t && t.isDepthStencil;\n  }\n  getGpuSize() {\n    const e = this.format,\n      t = I[e],\n      n = this.width;\n    if (!e || n <= 0 || !t) return -1;\n    const s = this.height,\n      r = this.depthOrArrayLayers,\n      a = this.dimension;\n    return n / t.blockWidth * ('1d' === a ? 1 : s / t.blockHeight) * t.bytesPerBlock * r;\n  }\n  getPixel(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    const r = this.texelByteSize,\n      a = this.bytesPerRow,\n      i = this.height,\n      o = this.data[s];\n    return v(new Uint8Array(o), e, t, n, s, i, a, r, this.format);\n  }\n  setPixel(e, t, n, s, r) {\n    const a = this.texelByteSize,\n      i = this.bytesPerRow,\n      o = this.height,\n      l = this.data[s];\n    !function (e, t, n, s, r, a, i, o, l, c) {\n      const u = s * (i >>= r) * (a >>= r) + n * i + t * o;\n      switch (l) {\n        case 'r8unorm':\n          return void k(e, u, '8unorm', 1, c);\n        case 'r8snorm':\n          return void k(e, u, '8snorm', 1, c);\n        case 'r8uint':\n          return void k(e, u, '8uint', 1, c);\n        case 'r8sint':\n          return void k(e, u, '8sint', 1, c);\n        case 'rg8unorm':\n          return void k(e, u, '8unorm', 2, c);\n        case 'rg8snorm':\n          return void k(e, u, '8snorm', 2, c);\n        case 'rg8uint':\n          return void k(e, u, '8uint', 2, c);\n        case 'rg8sint':\n          return void k(e, u, '8sint', 2, c);\n        case 'rgba8unorm-srgb':\n        case 'rgba8unorm':\n        case 'bgra8unorm-srgb':\n        case 'bgra8unorm':\n          return void k(e, u, '8unorm', 4, c);\n        case 'rgba8snorm':\n          return void k(e, u, '8snorm', 4, c);\n        case 'rgba8uint':\n          return void k(e, u, '8uint', 4, c);\n        case 'rgba8sint':\n          return void k(e, u, '8sint', 4, c);\n        case 'r16uint':\n          return void k(e, u, '16uint', 1, c);\n        case 'r16sint':\n          return void k(e, u, '16sint', 1, c);\n        case 'r16float':\n          return void k(e, u, '16float', 1, c);\n        case 'rg16uint':\n          return void k(e, u, '16uint', 2, c);\n        case 'rg16sint':\n          return void k(e, u, '16sint', 2, c);\n        case 'rg16float':\n          return void k(e, u, '16float', 2, c);\n        case 'rgba16uint':\n          return void k(e, u, '16uint', 4, c);\n        case 'rgba16sint':\n          return void k(e, u, '16sint', 4, c);\n        case 'rgba16float':\n          return void k(e, u, '16float', 4, c);\n        case 'r32uint':\n          return void k(e, u, '32uint', 1, c);\n        case 'r32sint':\n          return void k(e, u, '32sint', 1, c);\n        case 'depth16unorm':\n        case 'depth24plus':\n        case 'depth24plus-stencil8':\n        case 'depth32float':\n        case 'depth32float-stencil8':\n        case 'r32float':\n          return void k(e, u, '32float', 1, c);\n        case 'rg32uint':\n          return void k(e, u, '32uint', 2, c);\n        case 'rg32sint':\n          return void k(e, u, '32sint', 2, c);\n        case 'rg32float':\n          return void k(e, u, '32float', 2, c);\n        case 'rgba32uint':\n          return void k(e, u, '32uint', 4, c);\n        case 'rgba32sint':\n          return void k(e, u, '32sint', 4, c);\n        case 'rgba32float':\n          return void k(e, u, '32float', 4, c);\n        case 'rg11b10ufloat':\n          console.error('TODO: rg11b10ufloat not supported for writing');\n      }\n    }(new Uint8Array(l), e, t, n, s, o, i, a, this.format, r);\n  }\n}\n(e => {\n  e[e.token = 0] = 'token', e[e.keyword = 1] = 'keyword', e[e.reserved = 2] = 'reserved';\n})(q || (q = {}));\nclass Pe {\n  constructor(e, t, n) {\n    this.name = e, this.type = t, this.rule = n;\n  }\n  toString() {\n    return this.name;\n  }\n}\nclass We {}\nW = We, We.none = new Pe('', q.reserved, ''), We.eof = new Pe('EOF', q.token, ''), We.reserved = {\n  asm: new Pe('asm', q.reserved, 'asm'),\n  bf16: new Pe('bf16', q.reserved, 'bf16'),\n  do: new Pe('do', q.reserved, 'do'),\n  enum: new Pe('enum', q.reserved, 'enum'),\n  f16: new Pe('f16', q.reserved, 'f16'),\n  f64: new Pe('f64', q.reserved, 'f64'),\n  handle: new Pe('handle', q.reserved, 'handle'),\n  i8: new Pe('i8', q.reserved, 'i8'),\n  i16: new Pe('i16', q.reserved, 'i16'),\n  i64: new Pe('i64', q.reserved, 'i64'),\n  mat: new Pe('mat', q.reserved, 'mat'),\n  premerge: new Pe('premerge', q.reserved, 'premerge'),\n  regardless: new Pe('regardless', q.reserved, 'regardless'),\n  typedef: new Pe('typedef', q.reserved, 'typedef'),\n  u8: new Pe('u8', q.reserved, 'u8'),\n  u16: new Pe('u16', q.reserved, 'u16'),\n  u64: new Pe('u64', q.reserved, 'u64'),\n  unless: new Pe('unless', q.reserved, 'unless'),\n  using: new Pe('using', q.reserved, 'using'),\n  vec: new Pe('vec', q.reserved, 'vec'),\n  void: new Pe('void', q.reserved, 'void')\n}, We.keywords = {\n  array: new Pe('array', q.keyword, 'array'),\n  atomic: new Pe('atomic', q.keyword, 'atomic'),\n  bool: new Pe('bool', q.keyword, 'bool'),\n  f32: new Pe('f32', q.keyword, 'f32'),\n  i32: new Pe('i32', q.keyword, 'i32'),\n  mat2x2: new Pe('mat2x2', q.keyword, 'mat2x2'),\n  mat2x3: new Pe('mat2x3', q.keyword, 'mat2x3'),\n  mat2x4: new Pe('mat2x4', q.keyword, 'mat2x4'),\n  mat3x2: new Pe('mat3x2', q.keyword, 'mat3x2'),\n  mat3x3: new Pe('mat3x3', q.keyword, 'mat3x3'),\n  mat3x4: new Pe('mat3x4', q.keyword, 'mat3x4'),\n  mat4x2: new Pe('mat4x2', q.keyword, 'mat4x2'),\n  mat4x3: new Pe('mat4x3', q.keyword, 'mat4x3'),\n  mat4x4: new Pe('mat4x4', q.keyword, 'mat4x4'),\n  ptr: new Pe('ptr', q.keyword, 'ptr'),\n  sampler: new Pe('sampler', q.keyword, 'sampler'),\n  sampler_comparison: new Pe('sampler_comparison', q.keyword, 'sampler_comparison'),\n  struct: new Pe('struct', q.keyword, 'struct'),\n  texture_1d: new Pe('texture_1d', q.keyword, 'texture_1d'),\n  texture_2d: new Pe('texture_2d', q.keyword, 'texture_2d'),\n  texture_2d_array: new Pe('texture_2d_array', q.keyword, 'texture_2d_array'),\n  texture_3d: new Pe('texture_3d', q.keyword, 'texture_3d'),\n  texture_cube: new Pe('texture_cube', q.keyword, 'texture_cube'),\n  texture_cube_array: new Pe('texture_cube_array', q.keyword, 'texture_cube_array'),\n  texture_multisampled_2d: new Pe('texture_multisampled_2d', q.keyword, 'texture_multisampled_2d'),\n  texture_storage_1d: new Pe('texture_storage_1d', q.keyword, 'texture_storage_1d'),\n  texture_storage_2d: new Pe('texture_storage_2d', q.keyword, 'texture_storage_2d'),\n  texture_storage_2d_array: new Pe('texture_storage_2d_array', q.keyword, 'texture_storage_2d_array'),\n  texture_storage_3d: new Pe('texture_storage_3d', q.keyword, 'texture_storage_3d'),\n  texture_depth_2d: new Pe('texture_depth_2d', q.keyword, 'texture_depth_2d'),\n  texture_depth_2d_array: new Pe('texture_depth_2d_array', q.keyword, 'texture_depth_2d_array'),\n  texture_depth_cube: new Pe('texture_depth_cube', q.keyword, 'texture_depth_cube'),\n  texture_depth_cube_array: new Pe('texture_depth_cube_array', q.keyword, 'texture_depth_cube_array'),\n  texture_depth_multisampled_2d: new Pe('texture_depth_multisampled_2d', q.keyword, 'texture_depth_multisampled_2d'),\n  texture_external: new Pe('texture_external', q.keyword, 'texture_external'),\n  u32: new Pe('u32', q.keyword, 'u32'),\n  vec2: new Pe('vec2', q.keyword, 'vec2'),\n  vec3: new Pe('vec3', q.keyword, 'vec3'),\n  vec4: new Pe('vec4', q.keyword, 'vec4'),\n  bitcast: new Pe('bitcast', q.keyword, 'bitcast'),\n  block: new Pe('block', q.keyword, 'block'),\n  break: new Pe('break', q.keyword, 'break'),\n  case: new Pe('case', q.keyword, 'case'),\n  continue: new Pe('continue', q.keyword, 'continue'),\n  continuing: new Pe('continuing', q.keyword, 'continuing'),\n  default: new Pe('default', q.keyword, 'default'),\n  diagnostic: new Pe('diagnostic', q.keyword, 'diagnostic'),\n  discard: new Pe('discard', q.keyword, 'discard'),\n  else: new Pe('else', q.keyword, 'else'),\n  enable: new Pe('enable', q.keyword, 'enable'),\n  fallthrough: new Pe('fallthrough', q.keyword, 'fallthrough'),\n  false: new Pe('false', q.keyword, 'false'),\n  fn: new Pe('fn', q.keyword, 'fn'),\n  for: new Pe('for', q.keyword, 'for'),\n  function: new Pe('function', q.keyword, 'function'),\n  if: new Pe('if', q.keyword, 'if'),\n  let: new Pe('let', q.keyword, 'let'),\n  const: new Pe('const', q.keyword, 'const'),\n  loop: new Pe('loop', q.keyword, 'loop'),\n  while: new Pe('while', q.keyword, 'while'),\n  private: new Pe('private', q.keyword, 'private'),\n  read: new Pe('read', q.keyword, 'read'),\n  read_write: new Pe('read_write', q.keyword, 'read_write'),\n  return: new Pe('return', q.keyword, 'return'),\n  requires: new Pe('requires', q.keyword, 'requires'),\n  storage: new Pe('storage', q.keyword, 'storage'),\n  switch: new Pe('switch', q.keyword, 'switch'),\n  true: new Pe('true', q.keyword, 'true'),\n  alias: new Pe('alias', q.keyword, 'alias'),\n  type: new Pe('type', q.keyword, 'type'),\n  uniform: new Pe('uniform', q.keyword, 'uniform'),\n  var: new Pe('var', q.keyword, 'var'),\n  override: new Pe('override', q.keyword, 'override'),\n  workgroup: new Pe('workgroup', q.keyword, 'workgroup'),\n  write: new Pe('write', q.keyword, 'write'),\n  r8unorm: new Pe('r8unorm', q.keyword, 'r8unorm'),\n  r8snorm: new Pe('r8snorm', q.keyword, 'r8snorm'),\n  r8uint: new Pe('r8uint', q.keyword, 'r8uint'),\n  r8sint: new Pe('r8sint', q.keyword, 'r8sint'),\n  r16uint: new Pe('r16uint', q.keyword, 'r16uint'),\n  r16sint: new Pe('r16sint', q.keyword, 'r16sint'),\n  r16float: new Pe('r16float', q.keyword, 'r16float'),\n  rg8unorm: new Pe('rg8unorm', q.keyword, 'rg8unorm'),\n  rg8snorm: new Pe('rg8snorm', q.keyword, 'rg8snorm'),\n  rg8uint: new Pe('rg8uint', q.keyword, 'rg8uint'),\n  rg8sint: new Pe('rg8sint', q.keyword, 'rg8sint'),\n  r32uint: new Pe('r32uint', q.keyword, 'r32uint'),\n  r32sint: new Pe('r32sint', q.keyword, 'r32sint'),\n  r32float: new Pe('r32float', q.keyword, 'r32float'),\n  rg16uint: new Pe('rg16uint', q.keyword, 'rg16uint'),\n  rg16sint: new Pe('rg16sint', q.keyword, 'rg16sint'),\n  rg16float: new Pe('rg16float', q.keyword, 'rg16float'),\n  rgba8unorm: new Pe('rgba8unorm', q.keyword, 'rgba8unorm'),\n  rgba8unorm_srgb: new Pe('rgba8unorm_srgb', q.keyword, 'rgba8unorm_srgb'),\n  rgba8snorm: new Pe('rgba8snorm', q.keyword, 'rgba8snorm'),\n  rgba8uint: new Pe('rgba8uint', q.keyword, 'rgba8uint'),\n  rgba8sint: new Pe('rgba8sint', q.keyword, 'rgba8sint'),\n  bgra8unorm: new Pe('bgra8unorm', q.keyword, 'bgra8unorm'),\n  bgra8unorm_srgb: new Pe('bgra8unorm_srgb', q.keyword, 'bgra8unorm_srgb'),\n  rgb10a2unorm: new Pe('rgb10a2unorm', q.keyword, 'rgb10a2unorm'),\n  rg11b10float: new Pe('rg11b10float', q.keyword, 'rg11b10float'),\n  rg32uint: new Pe('rg32uint', q.keyword, 'rg32uint'),\n  rg32sint: new Pe('rg32sint', q.keyword, 'rg32sint'),\n  rg32float: new Pe('rg32float', q.keyword, 'rg32float'),\n  rgba16uint: new Pe('rgba16uint', q.keyword, 'rgba16uint'),\n  rgba16sint: new Pe('rgba16sint', q.keyword, 'rgba16sint'),\n  rgba16float: new Pe('rgba16float', q.keyword, 'rgba16float'),\n  rgba32uint: new Pe('rgba32uint', q.keyword, 'rgba32uint'),\n  rgba32sint: new Pe('rgba32sint', q.keyword, 'rgba32sint'),\n  rgba32float: new Pe('rgba32float', q.keyword, 'rgba32float'),\n  static_assert: new Pe('static_assert', q.keyword, 'static_assert')\n}, We.tokens = {\n  decimal_float_literal: new Pe('decimal_float_literal', q.token, /((-?[0-9]*\\.[0-9]+|-?[0-9]+\\.[0-9]*)((e|E)(\\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/),\n  hex_float_literal: new Pe('hex_float_literal', q.token, /-?0x((([0-9a-fA-F]*\\.[0-9a-fA-F]+|[0-9a-fA-F]+\\.[0-9a-fA-F]*)((p|P)(\\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\\+|-)?[0-9]+[fh]?))/),\n  int_literal: new Pe('int_literal', q.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),\n  uint_literal: new Pe('uint_literal', q.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),\n  name: new Pe('name', q.token, /([_\\p{XID_Start}][\\p{XID_Continue}]+)|([\\p{XID_Start}])/u),\n  ident: new Pe('ident', q.token, /[_a-zA-Z][0-9a-zA-Z_]*/),\n  and: new Pe('and', q.token, '&'),\n  and_and: new Pe('and_and', q.token, '&&'),\n  arrow: new Pe('arrow ', q.token, '->'),\n  attr: new Pe('attr', q.token, '@'),\n  forward_slash: new Pe('forward_slash', q.token, '/'),\n  bang: new Pe('bang', q.token, '!'),\n  bracket_left: new Pe('bracket_left', q.token, '['),\n  bracket_right: new Pe('bracket_right', q.token, ']'),\n  brace_left: new Pe('brace_left', q.token, '{'),\n  brace_right: new Pe('brace_right', q.token, '}'),\n  colon: new Pe('colon', q.token, ':'),\n  comma: new Pe('comma', q.token, ','),\n  equal: new Pe('equal', q.token, '='),\n  equal_equal: new Pe('equal_equal', q.token, '=='),\n  not_equal: new Pe('not_equal', q.token, '!='),\n  greater_than: new Pe('greater_than', q.token, '>'),\n  greater_than_equal: new Pe('greater_than_equal', q.token, '>='),\n  shift_right: new Pe('shift_right', q.token, '>>'),\n  less_than: new Pe('less_than', q.token, '<'),\n  less_than_equal: new Pe('less_than_equal', q.token, '<='),\n  shift_left: new Pe('shift_left', q.token, '<<'),\n  modulo: new Pe('modulo', q.token, '%'),\n  minus: new Pe('minus', q.token, '-'),\n  minus_minus: new Pe('minus_minus', q.token, '--'),\n  period: new Pe('period', q.token, '.'),\n  plus: new Pe('plus', q.token, '+'),\n  plus_plus: new Pe('plus_plus', q.token, '++'),\n  or: new Pe('or', q.token, '|'),\n  or_or: new Pe('or_or', q.token, '||'),\n  paren_left: new Pe('paren_left', q.token, '('),\n  paren_right: new Pe('paren_right', q.token, ')'),\n  semicolon: new Pe('semicolon', q.token, ';'),\n  star: new Pe('star', q.token, '*'),\n  tilde: new Pe('tilde', q.token, '~'),\n  underscore: new Pe('underscore', q.token, '_'),\n  xor: new Pe('xor', q.token, '^'),\n  plus_equal: new Pe('plus_equal', q.token, '+='),\n  minus_equal: new Pe('minus_equal', q.token, '-='),\n  times_equal: new Pe('times_equal', q.token, '*='),\n  division_equal: new Pe('division_equal', q.token, '/='),\n  modulo_equal: new Pe('modulo_equal', q.token, '%='),\n  and_equal: new Pe('and_equal', q.token, '&='),\n  or_equal: new Pe('or_equal', q.token, '|='),\n  xor_equal: new Pe('xor_equal', q.token, '^='),\n  shift_right_equal: new Pe('shift_right_equal', q.token, '>>='),\n  shift_left_equal: new Pe('shift_left_equal', q.token, '<<=')\n}, We.simpleTokens = {\n  '@': W.tokens.attr,\n  '{': W.tokens.brace_left,\n  '}': W.tokens.brace_right,\n  ':': W.tokens.colon,\n  ',': W.tokens.comma,\n  '(': W.tokens.paren_left,\n  ')': W.tokens.paren_right,\n  ';': W.tokens.semicolon\n}, We.literalTokens = {\n  '&': W.tokens.and,\n  '&&': W.tokens.and_and,\n  '->': W.tokens.arrow,\n  '/': W.tokens.forward_slash,\n  '!': W.tokens.bang,\n  '[': W.tokens.bracket_left,\n  ']': W.tokens.bracket_right,\n  '=': W.tokens.equal,\n  '==': W.tokens.equal_equal,\n  '!=': W.tokens.not_equal,\n  '>': W.tokens.greater_than,\n  '>=': W.tokens.greater_than_equal,\n  '>>': W.tokens.shift_right,\n  '<': W.tokens.less_than,\n  '<=': W.tokens.less_than_equal,\n  '<<': W.tokens.shift_left,\n  '%': W.tokens.modulo,\n  '-': W.tokens.minus,\n  '--': W.tokens.minus_minus,\n  '.': W.tokens.period,\n  '+': W.tokens.plus,\n  '++': W.tokens.plus_plus,\n  '|': W.tokens.or,\n  '||': W.tokens.or_or,\n  '*': W.tokens.star,\n  '~': W.tokens.tilde,\n  _: W.tokens.underscore,\n  '^': W.tokens.xor,\n  '+=': W.tokens.plus_equal,\n  '-=': W.tokens.minus_equal,\n  '*=': W.tokens.times_equal,\n  '/=': W.tokens.division_equal,\n  '%=': W.tokens.modulo_equal,\n  '&=': W.tokens.and_equal,\n  '|=': W.tokens.or_equal,\n  '^=': W.tokens.xor_equal,\n  '>>=': W.tokens.shift_right_equal,\n  '<<=': W.tokens.shift_left_equal\n}, We.regexTokens = {\n  decimal_float_literal: W.tokens.decimal_float_literal,\n  hex_float_literal: W.tokens.hex_float_literal,\n  int_literal: W.tokens.int_literal,\n  uint_literal: W.tokens.uint_literal,\n  ident: W.tokens.ident\n}, We.storage_class = [W.keywords.function, W.keywords.private, W.keywords.workgroup, W.keywords.uniform, W.keywords.storage], We.access_mode = [W.keywords.read, W.keywords.write, W.keywords.read_write], We.sampler_type = [W.keywords.sampler, W.keywords.sampler_comparison], We.sampled_texture_type = [W.keywords.texture_1d, W.keywords.texture_2d, W.keywords.texture_2d_array, W.keywords.texture_3d, W.keywords.texture_cube, W.keywords.texture_cube_array], We.multisampled_texture_type = [W.keywords.texture_multisampled_2d], We.storage_texture_type = [W.keywords.texture_storage_1d, W.keywords.texture_storage_2d, W.keywords.texture_storage_2d_array, W.keywords.texture_storage_3d], We.depth_texture_type = [W.keywords.texture_depth_2d, W.keywords.texture_depth_2d_array, W.keywords.texture_depth_cube, W.keywords.texture_depth_cube_array, W.keywords.texture_depth_multisampled_2d], We.texture_external_type = [W.keywords.texture_external], We.any_texture_type = [...W.sampled_texture_type, ...W.multisampled_texture_type, ...W.storage_texture_type, ...W.depth_texture_type, ...W.texture_external_type], We.texel_format = [W.keywords.r8unorm, W.keywords.r8snorm, W.keywords.r8uint, W.keywords.r8sint, W.keywords.r16uint, W.keywords.r16sint, W.keywords.r16float, W.keywords.rg8unorm, W.keywords.rg8snorm, W.keywords.rg8uint, W.keywords.rg8sint, W.keywords.r32uint, W.keywords.r32sint, W.keywords.r32float, W.keywords.rg16uint, W.keywords.rg16sint, W.keywords.rg16float, W.keywords.rgba8unorm, W.keywords.rgba8unorm_srgb, W.keywords.rgba8snorm, W.keywords.rgba8uint, W.keywords.rgba8sint, W.keywords.bgra8unorm, W.keywords.bgra8unorm_srgb, W.keywords.rgb10a2unorm, W.keywords.rg11b10float, W.keywords.rg32uint, W.keywords.rg32sint, W.keywords.rg32float, W.keywords.rgba16uint, W.keywords.rgba16sint, W.keywords.rgba16float, W.keywords.rgba32uint, W.keywords.rgba32sint, W.keywords.rgba32float], We.const_literal = [W.tokens.int_literal, W.tokens.uint_literal, W.tokens.decimal_float_literal, W.tokens.hex_float_literal, W.keywords.true, W.keywords.false], We.literal_or_ident = [W.tokens.ident, W.tokens.int_literal, W.tokens.uint_literal, W.tokens.decimal_float_literal, W.tokens.hex_float_literal, W.tokens.name], We.element_count_expression = [W.tokens.int_literal, W.tokens.uint_literal, W.tokens.ident], We.template_types = [W.keywords.vec2, W.keywords.vec3, W.keywords.vec4, W.keywords.mat2x2, W.keywords.mat2x3, W.keywords.mat2x4, W.keywords.mat3x2, W.keywords.mat3x3, W.keywords.mat3x4, W.keywords.mat4x2, W.keywords.mat4x3, W.keywords.mat4x4, W.keywords.atomic, W.keywords.bitcast, ...W.any_texture_type], We.attribute_name = [W.tokens.ident, W.keywords.block, W.keywords.diagnostic], We.assignment_operators = [W.tokens.equal, W.tokens.plus_equal, W.tokens.minus_equal, W.tokens.times_equal, W.tokens.division_equal, W.tokens.modulo_equal, W.tokens.and_equal, W.tokens.or_equal, W.tokens.xor_equal, W.tokens.shift_right_equal, W.tokens.shift_left_equal], We.increment_operators = [W.tokens.plus_plus, W.tokens.minus_minus];\nclass qe {\n  constructor(e, t, n, s, r) {\n    this.type = e, this.lexeme = t, this.line = n, this.start = s, this.end = r;\n  }\n  toString() {\n    return this.lexeme;\n  }\n  isTemplateType() {\n    return -1 != We.template_types.indexOf(this.type);\n  }\n  isArrayType() {\n    return this.type == We.keywords.array;\n  }\n  isArrayOrTemplateType() {\n    return this.isArrayType() || this.isTemplateType();\n  }\n}\nclass He {\n  constructor(e) {\n    this._tokens = [], this._start = 0, this._current = 0, this._line = 1, this._source = null != e ? e : '';\n  }\n  scanTokens() {\n    for (; !this._isAtEnd();) if (this._start = this._current, !this.scanToken()) throw `Invalid syntax at line ${this._line}`;\n    return this._tokens.push(new qe(We.eof, '', this._line, this._current, this._current)), this._tokens;\n  }\n  scanToken() {\n    let e = this._advance();\n    if ('\\n' == e) return this._line++, !0;\n    if (this._isWhitespace(e)) return !0;\n    if ('/' == e) {\n      if ('/' == this._peekAhead()) {\n        for (; '\\n' != e;) {\n          if (this._isAtEnd()) return !0;\n          e = this._advance();\n        }\n        return this._line++, !0;\n      }\n      if ('*' == this._peekAhead()) {\n        this._advance();\n        let t = 1;\n        for (; t > 0;) {\n          if (this._isAtEnd()) return !0;\n          if (e = this._advance(), '\\n' == e) this._line++;else if ('*' == e) {\n            if ('/' == this._peekAhead() && (this._advance(), t--, 0 == t)) return !0;\n          } else '/' == e && '*' == this._peekAhead() && (this._advance(), t++);\n        }\n        return !0;\n      }\n    }\n    const t = We.simpleTokens[e];\n    if (t) return this._addToken(t), !0;\n    let n = We.none;\n    const s = this._isAlpha(e),\n      r = '_' === e;\n    if (this._isAlphaNumeric(e)) {\n      let t = this._peekAhead();\n      for (; this._isAlphaNumeric(t);) e += this._advance(), t = this._peekAhead();\n    }\n    if (s) {\n      const t = We.keywords[e];\n      if (t) return this._addToken(t), !0;\n    }\n    if (s || r) return this._addToken(We.tokens.ident), !0;\n    for (;;) {\n      let t = this._findType(e);\n      const s = this._peekAhead();\n      if ('-' == e && this._tokens.length > 0) {\n        if ('=' == s) return this._current++, e += s, this._addToken(We.tokens.minus_equal), !0;\n        if ('-' == s) return this._current++, e += s, this._addToken(We.tokens.minus_minus), !0;\n        const n = this._tokens.length - 1;\n        if ((-1 != We.literal_or_ident.indexOf(this._tokens[n].type) || this._tokens[n].type == We.tokens.paren_right) && '>' != s) return this._addToken(t), !0;\n      }\n      if ('>' == e && ('>' == s || '=' == s)) {\n        let e = !1,\n          n = this._tokens.length - 1;\n        for (let t = 0; t < 5 && n >= 0 && -1 === We.assignment_operators.indexOf(this._tokens[n].type); ++t, --n) if (this._tokens[n].type === We.tokens.less_than) {\n          n > 0 && this._tokens[n - 1].isArrayOrTemplateType() && (e = !0);\n          break;\n        }\n        if (e) return this._addToken(t), !0;\n      }\n      if (t === We.none) {\n        let s = e,\n          r = 0;\n        const a = 2;\n        for (let e = 0; e < a; ++e) if (s += this._peekAhead(e), t = this._findType(s), t !== We.none) {\n          r = e;\n          break;\n        }\n        if (t === We.none) return n !== We.none && (this._current--, this._addToken(n), !0);\n        e = s, this._current += r + 1;\n      }\n      if (n = t, this._isAtEnd()) break;\n      e += this._advance();\n    }\n    return n !== We.none && (this._addToken(n), !0);\n  }\n  _findType(e) {\n    for (const t in We.regexTokens) {\n      const n = We.regexTokens[t];\n      if (this._match(e, n.rule)) return n;\n    }\n    const t = We.literalTokens[e];\n    return t || We.none;\n  }\n  _match(e, t) {\n    const n = t.exec(e);\n    return n && 0 == n.index && n[0] == e;\n  }\n  _isAtEnd() {\n    return this._current >= this._source.length;\n  }\n  _isAlpha(e) {\n    return !this._isNumeric(e) && !this._isWhitespace(e) && '_' !== e && '.' !== e && '(' !== e && ')' !== e && '[' !== e && ']' !== e && '{' !== e && '}' !== e && ',' !== e && ';' !== e && ':' !== e && '=' !== e && '!' !== e && '<' !== e && '>' !== e && '+' !== e && '-' !== e && '*' !== e && '/' !== e && '%' !== e && '&' !== e && '|' !== e && '^' !== e && '~' !== e && '@' !== e && '#' !== e && '?' !== e && '\\'' !== e && '`' !== e && '\"' !== e && '\\\\' !== e && '\\n' !== e && '\\r' !== e && '\\t' !== e && '\\0' !== e;\n  }\n  _isNumeric(e) {\n    return e >= '0' && e <= '9';\n  }\n  _isAlphaNumeric(e) {\n    return this._isAlpha(e) || this._isNumeric(e) || '_' === e;\n  }\n  _isWhitespace(e) {\n    return ' ' == e || '\\t' == e || '\\r' == e;\n  }\n  _advance() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let t = this._source[this._current];\n    return e = e || 0, e++, this._current += e, t;\n  }\n  _peekAhead() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return e = e || 0, this._current + e >= this._source.length ? '\\0' : this._source[this._current + e];\n  }\n  _addToken(e) {\n    const t = this._source.substring(this._start, this._current);\n    this._tokens.push(new qe(e, t, this._line, this._start, this._current));\n  }\n}\nfunction ze(e) {\n  return Array.isArray(e) || (null == e ? void 0 : e.buffer) instanceof ArrayBuffer;\n}\nconst Re = new Float32Array(1),\n  Ge = new Uint32Array(Re.buffer),\n  Xe = new Uint32Array(Re.buffer),\n  je = new Int32Array(1),\n  Ze = new Float32Array(je.buffer),\n  Qe = new Uint32Array(je.buffer),\n  Ye = new Uint32Array(1),\n  Ke = new Float32Array(Ye.buffer),\n  Je = new Int32Array(Ye.buffer);\nfunction et(e, t, n) {\n  if (t === n) return e;\n  if ('f32' === t) {\n    if ('i32' === n || 'x32' === n) return Re[0] = e, Ge[0];\n    if ('u32' === n) return Re[0] = e, Xe[0];\n  } else if ('i32' === t || 'x32' === t) {\n    if ('f32' === n) return je[0] = e, Ze[0];\n    if ('u32' === n) return je[0] = e, Qe[0];\n  } else if ('u32' === t) {\n    if ('f32' === n) return Ye[0] = e, Ke[0];\n    if ('i32' === n || 'x32' === n) return Ye[0] = e, Je[0];\n  }\n  return console.error(`Unsupported cast from ${t} to ${n}`), e;\n}\nclass tt {\n  constructor(e) {\n    this.resources = null, this.inUse = !1, this.info = null, this.node = e;\n  }\n}\nclass nt {\n  constructor(e, t) {\n    this.align = e, this.size = t;\n  }\n}\nclass st {\n  constructor() {\n    this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new p(), this.functions = [], this._types = new Map(), this._functions = new Map();\n  }\n  _isStorageTexture(e) {\n    return 'texture_storage_1d' == e.name || 'texture_storage_2d' == e.name || 'texture_storage_2d_array' == e.name || 'texture_storage_3d' == e.name;\n  }\n  updateAST(e) {\n    for (const t of e) t instanceof L && this._functions.set(t.name, new tt(t));\n    for (const t of e) if (t instanceof ae) {\n      const e = this.getTypeInfo(t, null);\n      e instanceof n && this.structs.push(e);\n    }\n    for (const t of e) if (t instanceof J) this.aliases.push(this._getAliasInfo(t));else if (t instanceof B) {\n      const e = t,\n        n = this._getAttributeNum(e.attributes, 'id', 0),\n        s = null != e.type ? this.getTypeInfo(e.type, e.attributes) : null;\n      this.overrides.push(new u(e.name, s, e.attributes, n));\n    } else if (this._isUniformVar(t)) {\n      const e = t,\n        n = this._getAttributeNum(e.attributes, 'group', 0),\n        s = this._getAttributeNum(e.attributes, 'binding', 0),\n        r = this.getTypeInfo(e.type, e.attributes),\n        o = new i(e.name, r, n, s, e.attributes, a.Uniform, e.access);\n      o.access || (o.access = 'read'), this.uniforms.push(o);\n    } else if (this._isStorageVar(t)) {\n      const e = t,\n        n = this._getAttributeNum(e.attributes, 'group', 0),\n        s = this._getAttributeNum(e.attributes, 'binding', 0),\n        r = this.getTypeInfo(e.type, e.attributes),\n        o = this._isStorageTexture(r),\n        l = new i(e.name, r, n, s, e.attributes, o ? a.StorageTexture : a.Storage, e.access);\n      l.access || (l.access = 'read'), this.storage.push(l);\n    } else if (this._isTextureVar(t)) {\n      const e = t,\n        n = this._getAttributeNum(e.attributes, 'group', 0),\n        s = this._getAttributeNum(e.attributes, 'binding', 0),\n        r = this.getTypeInfo(e.type, e.attributes),\n        o = this._isStorageTexture(r),\n        l = new i(e.name, r, n, s, e.attributes, o ? a.StorageTexture : a.Texture, e.access);\n      l.access || (l.access = 'read'), o ? this.storage.push(l) : this.textures.push(l);\n    } else if (this._isSamplerVar(t)) {\n      const e = t,\n        n = this._getAttributeNum(e.attributes, 'group', 0),\n        s = this._getAttributeNum(e.attributes, 'binding', 0),\n        r = this.getTypeInfo(e.type, e.attributes),\n        o = new i(e.name, r, n, s, e.attributes, a.Sampler, e.access);\n      this.samplers.push(o);\n    } else if (t instanceof L) {\n      const e = this._getAttribute(t, 'vertex'),\n        n = this._getAttribute(t, 'fragment'),\n        s = this._getAttribute(t, 'compute'),\n        r = e || n || s,\n        a = new f(t.name, null == r ? void 0 : r.name, t.attributes);\n      a.attributes = t.attributes, a.startLine = t.startLine, a.endLine = t.endLine, this.functions.push(a), this._functions.get(t.name).info = a, r && (this._functions.get(t.name).inUse = !0, a.inUse = !0, a.resources = this._findResources(t, !!r), a.inputs = this._getInputs(t.args), a.outputs = this._getOutputs(t.returnType), this.entry[r.name].push(a)), a.arguments = t.args.map(e => new h(e.name, this.getTypeInfo(e.type, e.attributes), e.attributes)), a.returnType = t.returnType ? this.getTypeInfo(t.returnType, t.attributes) : null;\n    } else ;\n    for (const e of this._functions.values()) e.info && (e.info.inUse = e.inUse, this._addCalls(e.node, e.info.calls));\n    for (const e of this._functions.values()) e.node.search(t => {\n      var n, s, r;\n      if (t instanceof Le) {\n        if (t.value) if (ze(t.value)) for (const s of t.value) for (const t of this.overrides) s === t.name && (null === (n = e.info) || void 0 === n || n.overrides.push(t));else for (const n of this.overrides) t.value === n.name && (null === (s = e.info) || void 0 === s || s.overrides.push(n));\n      } else if (t instanceof de) for (const n of this.overrides) t.name === n.name && (null === (r = e.info) || void 0 === r || r.overrides.push(n));\n    });\n    for (const e of this.uniforms) this._markStructsInUse(e.type);\n    for (const e of this.storage) this._markStructsInUse(e.type);\n  }\n  getStructInfo(e) {\n    for (const t of this.structs) if (t.name == e) return t;\n    return null;\n  }\n  getOverrideInfo(e) {\n    for (const t of this.overrides) if (t.name == e) return t;\n    return null;\n  }\n  _markStructsInUse(e) {\n    if (e) if (e.isStruct) {\n      if (e.inUse = !0, e.members) for (const t of e.members) this._markStructsInUse(t.type);\n    } else if (e.isArray) this._markStructsInUse(e.format);else if (e.isTemplate) e.format && this._markStructsInUse(e.format);else {\n      const t = this._getAlias(e.name);\n      t && this._markStructsInUse(t);\n    }\n  }\n  _addCalls(e, t) {\n    var n;\n    for (const s of e.calls) {\n      const e = null === (n = this._functions.get(s.name)) || void 0 === n ? void 0 : n.info;\n      e && t.add(e);\n    }\n  }\n  findResource(e, t, n) {\n    if (n) {\n      for (const s of this.entry.compute) if (s.name === n) for (const n of s.resources) if (n.group == e && n.binding == t) return n;\n      for (const s of this.entry.vertex) if (s.name === n) for (const n of s.resources) if (n.group == e && n.binding == t) return n;\n      for (const s of this.entry.fragment) if (s.name === n) for (const n of s.resources) if (n.group == e && n.binding == t) return n;\n    }\n    for (const n of this.uniforms) if (n.group == e && n.binding == t) return n;\n    for (const n of this.storage) if (n.group == e && n.binding == t) return n;\n    for (const n of this.textures) if (n.group == e && n.binding == t) return n;\n    for (const n of this.samplers) if (n.group == e && n.binding == t) return n;\n    return null;\n  }\n  _findResource(e) {\n    for (const t of this.uniforms) if (t.name == e) return t;\n    for (const t of this.storage) if (t.name == e) return t;\n    for (const t of this.textures) if (t.name == e) return t;\n    for (const t of this.samplers) if (t.name == e) return t;\n    return null;\n  }\n  _markStructsFromAST(e) {\n    const t = this.getTypeInfo(e, null);\n    this._markStructsInUse(t);\n  }\n  _findResources(e, t) {\n    const n = [],\n      s = this,\n      r = [];\n    return e.search(a => {\n      if (a instanceof S) r.push({});else if (a instanceof A) r.pop();else if (a instanceof O) {\n        const e = a;\n        t && null !== e.type && this._markStructsFromAST(e.type), r.length > 0 && (r[r.length - 1][e.name] = e);\n      } else if (a instanceof fe) {\n        const e = a;\n        t && null !== e.type && this._markStructsFromAST(e.type);\n      } else if (a instanceof F) {\n        const e = a;\n        t && null !== e.type && this._markStructsFromAST(e.type), r.length > 0 && (r[r.length - 1][e.name] = e);\n      } else if (a instanceof de) {\n        const e = a;\n        if (r.length > 0) {\n          if (r[r.length - 1][e.name]) return;\n        }\n        const t = s._findResource(e.name);\n        t && n.push(t);\n      } else if (a instanceof pe) {\n        const r = a,\n          i = s._functions.get(r.name);\n        i && (t && (i.inUse = !0), e.calls.add(i.node), null === i.resources && (i.resources = s._findResources(i.node, t)), n.push(...i.resources));\n      } else if (a instanceof R) {\n        const r = a,\n          i = s._functions.get(r.name);\n        i && (t && (i.inUse = !0), e.calls.add(i.node), null === i.resources && (i.resources = s._findResources(i.node, t)), n.push(...i.resources));\n      }\n    }), [...new Map(n.map(e => [e.name, e])).values()];\n  }\n  getBindGroups() {\n    const e = [];\n    function t(t, n) {\n      t >= e.length && (e.length = t + 1), void 0 === e[t] && (e[t] = []), n >= e[t].length && (e[t].length = n + 1);\n    }\n    for (const n of this.uniforms) {\n      t(n.group, n.binding);\n      e[n.group][n.binding] = n;\n    }\n    for (const n of this.storage) {\n      t(n.group, n.binding);\n      e[n.group][n.binding] = n;\n    }\n    for (const n of this.textures) {\n      t(n.group, n.binding);\n      e[n.group][n.binding] = n;\n    }\n    for (const n of this.samplers) {\n      t(n.group, n.binding);\n      e[n.group][n.binding] = n;\n    }\n    return e;\n  }\n  _getOutputs(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : void 0;\n    if (void 0 === t && (t = []), e instanceof ae) this._getStructOutputs(e, t);else {\n      const n = this._getOutputInfo(e);\n      null !== n && t.push(n);\n    }\n    return t;\n  }\n  _getStructOutputs(e, t) {\n    for (const n of e.members) if (n.type instanceof ae) this._getStructOutputs(n.type, t);else {\n      const e = this._getAttribute(n, 'location') || this._getAttribute(n, 'builtin');\n      if (null !== e) {\n        const s = this.getTypeInfo(n.type, n.type.attributes),\n          r = this._parseInt(e.value),\n          a = new c(n.name, s, e.name, r);\n        t.push(a);\n      }\n    }\n  }\n  _getOutputInfo(e) {\n    const t = this._getAttribute(e, 'location') || this._getAttribute(e, 'builtin');\n    if (null !== t) {\n      const n = this.getTypeInfo(e, e.attributes),\n        s = this._parseInt(t.value);\n      return new c('', n, t.name, s);\n    }\n    return null;\n  }\n  _getInputs(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : void 0;\n    void 0 === t && (t = []);\n    for (const n of e) if (n.type instanceof ae) this._getStructInputs(n.type, t);else {\n      const e = this._getInputInfo(n);\n      null !== e && t.push(e);\n    }\n    return t;\n  }\n  _getStructInputs(e, t) {\n    for (const n of e.members) if (n.type instanceof ae) this._getStructInputs(n.type, t);else {\n      const e = this._getInputInfo(n);\n      null !== e && t.push(e);\n    }\n  }\n  _getInputInfo(e) {\n    const t = this._getAttribute(e, 'location') || this._getAttribute(e, 'builtin');\n    if (null !== t) {\n      const n = this._getAttribute(e, 'interpolation'),\n        s = this.getTypeInfo(e.type, e.attributes),\n        r = this._parseInt(t.value),\n        a = new l(e.name, s, t.name, r);\n      return null !== n && (a.interpolation = this._parseString(n.value)), a;\n    }\n    return null;\n  }\n  _parseString(e) {\n    return e instanceof Array && (e = e[0]), e;\n  }\n  _parseInt(e) {\n    e instanceof Array && (e = e[0]);\n    const t = parseInt(e);\n    return isNaN(t) ? e : t;\n  }\n  _getAlias(e) {\n    for (const t of this.aliases) if (t.name == e) return t.type;\n    return null;\n  }\n  _getAliasInfo(e) {\n    return new o(e.name, this.getTypeInfo(e.type, null));\n  }\n  getTypeInfoByName(e) {\n    for (const t of this.structs) if (t.name == e) return t;\n    for (const t of this.aliases) if (t.name == e) return t.type;\n    return null;\n  }\n  getTypeInfo(a) {\n    let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (this._types.has(a)) return this._types.get(a);\n    if (a instanceof le) {\n      const e = a,\n        t = e.format ? this.getTypeInfo(e.format, e.attributes) : null,\n        n = new s(e.name, i);\n      return n.format = t, n.count = e.count, this._types.set(a, n), this._updateTypeInfo(n), n;\n    }\n    if (a instanceof ae) {\n      const e = a,\n        s = new n(e.name, i);\n      s.startLine = e.startLine, s.endLine = e.endLine;\n      for (const n of e.members) {\n        const e = this.getTypeInfo(n.type, n.attributes);\n        s.members.push(new t(n.name, e, n.attributes));\n      }\n      return this._types.set(a, s), this._updateTypeInfo(s), s;\n    }\n    if (a instanceof ce) {\n      const t = a,\n        n = t.format instanceof se,\n        s = t.format ? n ? this.getTypeInfo(t.format, null) : new e(t.format, null) : null,\n        o = new r(t.name, s, i, t.access);\n      return this._types.set(a, o), this._updateTypeInfo(o), o;\n    }\n    if (a instanceof ie) {\n      const e = a,\n        t = e.format ? this.getTypeInfo(e.format, null) : null,\n        n = new r(e.name, t, i, e.access);\n      return this._types.set(a, n), this._updateTypeInfo(n), n;\n    }\n    const o = new e(a.name, i);\n    return this._types.set(a, o), this._updateTypeInfo(o), o;\n  }\n  _updateTypeInfo(e) {\n    var t, r, a;\n    const i = this._getTypeSize(e);\n    if (e.size = null !== (t = null == i ? void 0 : i.size) && void 0 !== t ? t : 0, e instanceof s && e.format) {\n      const t = this._getTypeSize(e.format);\n      e.stride = Math.max(null !== (r = null == t ? void 0 : t.size) && void 0 !== r ? r : 0, null !== (a = null == t ? void 0 : t.align) && void 0 !== a ? a : 0), this._updateTypeInfo(e.format);\n    }\n    e instanceof n && this._updateStructInfo(e);\n  }\n  _updateStructInfo(e) {\n    var t;\n    let n = 0,\n      s = 0,\n      r = 0,\n      a = 0;\n    for (let i = 0, o = e.members.length; i < o; ++i) {\n      const o = e.members[i],\n        l = this._getTypeSize(o);\n      if (!l) continue;\n      null !== (t = this._getAlias(o.type.name)) && void 0 !== t || o.type;\n      const c = l.align,\n        u = l.size;\n      n = this._roundUp(c, n + s), s = u, r = n, a = Math.max(a, c), o.offset = n, o.size = u, this._updateTypeInfo(o.type);\n    }\n    e.size = this._roundUp(a, r + s), e.align = a;\n  }\n  _getTypeSize(r) {\n    var a, i;\n    if (null == r) return null;\n    const o = this._getAttributeNum(r.attributes, 'size', 0),\n      l = this._getAttributeNum(r.attributes, 'align', 0);\n    if (r instanceof t && (r = r.type), r instanceof e) {\n      const e = this._getAlias(r.name);\n      null !== e && (r = e);\n    }\n    {\n      const e = st._typeInfo[r.name];\n      if (void 0 !== e) {\n        const t = 'f16' === (null === (a = r.format) || void 0 === a ? void 0 : a.name) ? 2 : 1;\n        return new nt(Math.max(l, e.align / t), Math.max(o, e.size / t));\n      }\n    }\n    {\n      const e = st._typeInfo[r.name.substring(0, r.name.length - 1)];\n      if (e) {\n        const t = 'h' === r.name[r.name.length - 1] ? 2 : 1;\n        return new nt(Math.max(l, e.align / t), Math.max(o, e.size / t));\n      }\n    }\n    if (r instanceof s) {\n      let e = r,\n        t = 8,\n        n = 8;\n      const s = this._getTypeSize(e.format);\n      null !== s && (n = s.size, t = s.align);\n      return n = e.count * this._getAttributeNum(null !== (i = null == r ? void 0 : r.attributes) && void 0 !== i ? i : null, 'stride', this._roundUp(t, n)), o && (n = o), new nt(Math.max(l, t), Math.max(o, n));\n    }\n    if (r instanceof n) {\n      let e = 0,\n        t = 0,\n        n = 0,\n        s = 0,\n        a = 0;\n      for (const t of r.members) {\n        const r = this._getTypeSize(t.type);\n        null !== r && (e = Math.max(r.align, e), n = this._roundUp(r.align, n + s), s = r.size, a = n);\n      }\n      return t = this._roundUp(e, a + s), new nt(Math.max(l, e), Math.max(o, t));\n    }\n    return null;\n  }\n  _isUniformVar(e) {\n    return e instanceof O && 'uniform' == e.storage;\n  }\n  _isStorageVar(e) {\n    return e instanceof O && 'storage' == e.storage;\n  }\n  _isTextureVar(e) {\n    return e instanceof O && null !== e.type && -1 != st._textureTypes.indexOf(e.type.name);\n  }\n  _isSamplerVar(e) {\n    return e instanceof O && null !== e.type && -1 != st._samplerTypes.indexOf(e.type.name);\n  }\n  _getAttribute(e, t) {\n    const n = e;\n    if (!n || !n.attributes) return null;\n    const s = n.attributes;\n    for (let e of s) if (e.name == t) return e;\n    return null;\n  }\n  _getAttributeNum(e, t, n) {\n    if (null === e) return n;\n    for (let s of e) if (s.name == t) {\n      let e = null !== s && null !== s.value ? s.value : n;\n      return e instanceof Array && (e = e[0]), 'number' == typeof e ? e : 'string' == typeof e ? parseInt(e) : n;\n    }\n    return n;\n  }\n  _roundUp(e, t) {\n    return Math.ceil(t / e) * e;\n  }\n}\nst._typeInfo = {\n  f16: {\n    align: 2,\n    size: 2\n  },\n  i32: {\n    align: 4,\n    size: 4\n  },\n  u32: {\n    align: 4,\n    size: 4\n  },\n  f32: {\n    align: 4,\n    size: 4\n  },\n  atomic: {\n    align: 4,\n    size: 4\n  },\n  vec2: {\n    align: 8,\n    size: 8\n  },\n  vec3: {\n    align: 16,\n    size: 12\n  },\n  vec4: {\n    align: 16,\n    size: 16\n  },\n  mat2x2: {\n    align: 8,\n    size: 16\n  },\n  mat3x2: {\n    align: 8,\n    size: 24\n  },\n  mat4x2: {\n    align: 8,\n    size: 32\n  },\n  mat2x3: {\n    align: 16,\n    size: 32\n  },\n  mat3x3: {\n    align: 16,\n    size: 48\n  },\n  mat4x3: {\n    align: 16,\n    size: 64\n  },\n  mat2x4: {\n    align: 16,\n    size: 32\n  },\n  mat3x4: {\n    align: 16,\n    size: 48\n  },\n  mat4x4: {\n    align: 16,\n    size: 64\n  }\n}, st._textureTypes = We.any_texture_type.map(e => e.name), st._samplerTypes = We.sampler_type.map(e => e.name);\nclass rt {\n  constructor(e, t, n) {\n    this.name = e, this.value = t, this.node = n;\n  }\n  clone() {\n    return new rt(this.name, this.value, this.node);\n  }\n}\nclass at {\n  constructor(e) {\n    this.name = e.name, this.node = e;\n  }\n  clone() {\n    return new at(this.node);\n  }\n}\nclass it {\n  constructor(e) {\n    this.parent = null, this.variables = new Map(), this.functions = new Map(), this.currentFunctionName = '', e && (this.parent = e, this.currentFunctionName = e.currentFunctionName);\n  }\n  getVariable(e) {\n    var t;\n    return this.variables.has(e) ? null !== (t = this.variables.get(e)) && void 0 !== t ? t : null : this.parent ? this.parent.getVariable(e) : null;\n  }\n  getFunction(e) {\n    var t;\n    return this.functions.has(e) ? null !== (t = this.functions.get(e)) && void 0 !== t ? t : null : this.parent ? this.parent.getFunction(e) : null;\n  }\n  createVariable(e, t, n) {\n    this.variables.set(e, new rt(e, t, null != n ? n : null));\n  }\n  setVariable(e, t, n) {\n    const s = this.getVariable(e);\n    null !== s ? s.value = t : this.createVariable(e, t, n);\n  }\n  getVariableValue(e) {\n    var t;\n    const n = this.getVariable(e);\n    return null !== (t = null == n ? void 0 : n.value) && void 0 !== t ? t : null;\n  }\n  clone() {\n    return new it(this);\n  }\n}\nclass ot {\n  evalExpression(e, t) {\n    return null;\n  }\n  getTypeInfo(e) {\n    return null;\n  }\n  getVariableName(e, t) {\n    return '';\n  }\n}\nclass lt {\n  constructor(e) {\n    this.exec = e;\n  }\n  getTypeInfo(e) {\n    return this.exec.getTypeInfo(e);\n  }\n  All(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    let s = !0;\n    if (n instanceof Be) return n.data.forEach(e => {\n      e || (s = !1);\n    }), new Ve(s ? 1 : 0, this.getTypeInfo('bool'));\n    throw new Error(`All() expects a vector argument. Line ${e.line}`);\n  }\n  Any(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) {\n      const e = n.data.some(e => e);\n      return new Ve(e ? 1 : 0, this.getTypeInfo('bool'));\n    }\n    throw new Error(`Any() expects a vector argument. Line ${e.line}`);\n  }\n  Select(e, t) {\n    const n = this.exec.evalExpression(e.args[2], t);\n    if (!(n instanceof Ve)) throw new Error(`Select() expects a bool condition. Line ${e.line}`);\n    return n.value ? this.exec.evalExpression(e.args[1], t) : this.exec.evalExpression(e.args[0], t);\n  }\n  ArrayLength(e, t) {\n    let n = e.args[0];\n    n instanceof ve && (n = n.right);\n    const s = this.exec.evalExpression(n, t);\n    if (s instanceof Me && 0 === s.typeInfo.size) {\n      const e = s.typeInfo,\n        t = s.buffer.byteLength / e.stride;\n      return new Ve(t, this.getTypeInfo('u32'));\n    }\n    return new Ve(s.typeInfo.size, this.getTypeInfo('u32'));\n  }\n  Abs(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.abs(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.abs(s.value), s.typeInfo);\n  }\n  Acos(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.acos(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.acos(s.value), n.typeInfo);\n  }\n  Acosh(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.acosh(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.acosh(s.value), n.typeInfo);\n  }\n  Asin(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.asin(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.asin(s.value), n.typeInfo);\n  }\n  Asinh(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.asinh(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.asinh(s.value), n.typeInfo);\n  }\n  Atan(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.atan(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.atan(s.value), n.typeInfo);\n  }\n  Atanh(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.atanh(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.atanh(s.value), n.typeInfo);\n  }\n  Atan2(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t),\n      s = this.exec.evalExpression(e.args[1], t);\n    if (n instanceof Be && s instanceof Be) return new Be(n.data.map((e, t) => Math.atan2(e, s.data[t])), n.typeInfo);\n    const r = n,\n      a = s;\n    return new Ve(Math.atan2(r.value, a.value), n.typeInfo);\n  }\n  Ceil(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.ceil(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.ceil(s.value), n.typeInfo);\n  }\n  _clamp(e, t, n) {\n    return Math.min(Math.max(e, t), n);\n  }\n  Clamp(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t),\n      s = this.exec.evalExpression(e.args[1], t),\n      r = this.exec.evalExpression(e.args[2], t);\n    if (n instanceof Be && s instanceof Be && r instanceof Be) return new Be(n.data.map((e, t) => this._clamp(e, s.data[t], r.data[t])), n.typeInfo);\n    const a = n,\n      i = s,\n      o = r;\n    return new Ve(this._clamp(a.value, i.value, o.value), n.typeInfo);\n  }\n  Cos(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.cos(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.cos(s.value), n.typeInfo);\n  }\n  Cosh(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.cosh(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.cos(s.value), n.typeInfo);\n  }\n  CountLeadingZeros(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.clz32(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.clz32(s.value), n.typeInfo);\n  }\n  _countOneBits(e) {\n    let t = 0;\n    for (; 0 !== e;) 1 & e && t++, e >>= 1;\n    return t;\n  }\n  CountOneBits(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => this._countOneBits(e)), n.typeInfo);\n    const s = n;\n    return new Ve(this._countOneBits(s.value), n.typeInfo);\n  }\n  _countTrailingZeros(e) {\n    if (0 === e) return 32;\n    let t = 0;\n    for (; !(1 & e);) e >>= 1, t++;\n    return t;\n  }\n  CountTrailingZeros(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => this._countTrailingZeros(e)), n.typeInfo);\n    const s = n;\n    return new Ve(this._countTrailingZeros(s.value), n.typeInfo);\n  }\n  Cross(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t),\n      s = this.exec.evalExpression(e.args[1], t);\n    if (n instanceof Be && s instanceof Be) {\n      if (3 !== n.data.length || 3 !== s.data.length) return console.error(`Cross() expects 3D vectors. Line ${e.line}`), null;\n      const t = n.data,\n        r = s.data;\n      return new Be([t[1] * r[2] - r[1] * t[2], t[2] * r[0] - r[2] * t[0], t[0] * r[1] - r[0] * t[1]], n.typeInfo);\n    }\n    return console.error(`Cross() expects vector arguments. Line ${e.line}`), null;\n  }\n  Degrees(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t),\n      s = 180 / Math.PI;\n    if (n instanceof Be) return new Be(n.data.map(e => e * s), n.typeInfo);\n    return new Ve(n.value * s, this.getTypeInfo('f32'));\n  }\n  Determinant(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Fe) {\n      const e = n.data,\n        t = n.typeInfo.getTypeName(),\n        s = t.endsWith('h') ? this.getTypeInfo('f16') : this.getTypeInfo('f32');\n      if ('mat2x2' === t || 'mat2x2f' === t || 'mat2x2h' === t) return new Ve(e[0] * e[3] - e[1] * e[2], s);\n      if ('mat2x3' === t || 'mat2x3f' === t || 'mat2x3h' === t) return new Ve(e[0] * (e[4] * e[8] - e[5] * e[7]) - e[1] * (e[3] * e[8] - e[5] * e[6]) + e[2] * (e[3] * e[7] - e[4] * e[6]), s);\n      if ('mat2x4' === t || 'mat2x4f' === t || 'mat2x4h' === t) console.error(`TODO: Determinant for ${t}`);else if ('mat3x2' === t || 'mat3x2f' === t || 'mat3x2h' === t) console.error(`TODO: Determinant for ${t}`);else {\n        if ('mat3x3' === t || 'mat3x3f' === t || 'mat3x3h' === t) return new Ve(e[0] * (e[4] * e[8] - e[5] * e[7]) - e[1] * (e[3] * e[8] - e[5] * e[6]) + e[2] * (e[3] * e[7] - e[4] * e[6]), s);\n        'mat3x4' === t || 'mat3x4f' === t || 'mat3x4h' === t || 'mat4x2' === t || 'mat4x2f' === t || 'mat4x2h' === t || 'mat4x3' === t || 'mat4x3f' === t || 'mat4x3h' === t ? console.error(`TODO: Determinant for ${t}`) : 'mat4x4' !== t && 'mat4x4f' !== t && 'mat4x4h' !== t || console.error(`TODO: Determinant for ${t}`);\n      }\n    }\n    return console.error(`Determinant expects a matrix argument. Line ${e.line}`), null;\n  }\n  Distance(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t),\n      s = this.exec.evalExpression(e.args[1], t);\n    if (n instanceof Be && s instanceof Be) {\n      let e = 0;\n      for (let t = 0; t < n.data.length; ++t) e += (n.data[t] - s.data[t]) * (n.data[t] - s.data[t]);\n      return new Ve(Math.sqrt(e), this.getTypeInfo('f32'));\n    }\n    const r = n,\n      a = s;\n    return new Ve(Math.abs(r.value - a.value), n.typeInfo);\n  }\n  _dot(e, t) {\n    let n = 0;\n    for (let s = 0; s < e.length; ++s) n += t[s] * e[s];\n    return n;\n  }\n  Dot(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t),\n      s = this.exec.evalExpression(e.args[1], t);\n    return n instanceof Be && s instanceof Be ? new Ve(this._dot(n.data, s.data), this.getTypeInfo('f32')) : (console.error(`Dot() expects vector arguments. Line ${e.line}`), null);\n  }\n  Dot4U8Packed(e, t) {\n    return console.error(`TODO: dot4U8Packed. Line ${e.line}`), null;\n  }\n  Dot4I8Packed(e, t) {\n    return console.error(`TODO: dot4I8Packed. Line ${e.line}`), null;\n  }\n  Exp(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.exp(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.exp(s.value), n.typeInfo);\n  }\n  Exp2(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.pow(2, e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.pow(2, s.value), n.typeInfo);\n  }\n  ExtractBits(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t),\n      s = this.exec.evalExpression(e.args[1], t),\n      r = this.exec.evalExpression(e.args[2], t);\n    if ('u32' !== s.typeInfo.name && 'x32' !== s.typeInfo.name) return console.error(`ExtractBits() expects an i32 offset argument. Line ${e.line}`), null;\n    if ('u32' !== r.typeInfo.name && 'x32' !== r.typeInfo.name) return console.error(`ExtractBits() expects an i32 count argument. Line ${e.line}`), null;\n    const a = s.value,\n      i = r.value;\n    if (n instanceof Be) return new Be(n.data.map(e => e >> a & (1 << i) - 1), n.typeInfo);\n    if ('i32' !== n.typeInfo.name && 'x32' !== n.typeInfo.name) return console.error(`ExtractBits() expects an i32 argument. Line ${e.line}`), null;\n    const o = n.value;\n    return new Ve(o >> a & (1 << i) - 1, this.getTypeInfo('i32'));\n  }\n  FaceForward(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t),\n      s = this.exec.evalExpression(e.args[1], t),\n      r = this.exec.evalExpression(e.args[2], t);\n    if (n instanceof Be && s instanceof Be && r instanceof Be) {\n      const e = this._dot(s.data, r.data);\n      return new Be(e < 0 ? Array.from(n.data) : n.data.map(e => -e), n.typeInfo);\n    }\n    return console.error(`FaceForward() expects vector arguments. Line ${e.line}`), null;\n  }\n  _firstLeadingBit(e) {\n    return 0 === e ? -1 : 31 - Math.clz32(e);\n  }\n  FirstLeadingBit(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => this._firstLeadingBit(e)), n.typeInfo);\n    const s = n;\n    return new Ve(this._firstLeadingBit(s.value), n.typeInfo);\n  }\n  _firstTrailingBit(e) {\n    return 0 === e ? -1 : Math.log2(e & -e);\n  }\n  FirstTrailingBit(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => this._firstTrailingBit(e)), n.typeInfo);\n    const s = n;\n    return new Ve(this._firstTrailingBit(s.value), n.typeInfo);\n  }\n  Floor(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.floor(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.floor(s.value), n.typeInfo);\n  }\n  Fma(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t),\n      s = this.exec.evalExpression(e.args[1], t),\n      r = this.exec.evalExpression(e.args[2], t);\n    if (n instanceof Be && s instanceof Be && r instanceof Be) return n.data.length !== s.data.length || n.data.length !== r.data.length ? (console.error(`Fma() expects vectors of the same length. Line ${e.line}`), null) : new Be(n.data.map((e, t) => e * s.data[t] + r.data[t]), n.typeInfo);\n    const a = n,\n      i = s,\n      o = r;\n    return new Ve(a.value * i.value + o.value, a.typeInfo);\n  }\n  Fract(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => e - Math.floor(e)), n.typeInfo);\n    const s = n;\n    return new Ve(s.value - Math.floor(s.value), n.typeInfo);\n  }\n  Frexp(e, t) {\n    return console.error(`TODO: frexp. Line ${e.line}`), null;\n  }\n  InsertBits(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t),\n      s = this.exec.evalExpression(e.args[1], t),\n      r = this.exec.evalExpression(e.args[2], t),\n      a = this.exec.evalExpression(e.args[3], t);\n    if ('u32' !== r.typeInfo.name && 'x32' !== r.typeInfo.name) return console.error(`InsertBits() expects an i32 offset argument. Line ${e.line}`), null;\n    const i = r.value,\n      o = (1 << a.value) - 1 << i,\n      l = ~o;\n    if (n instanceof Be && s instanceof Be) return new Be(n.data.map((e, t) => e & l | s.data[t] << i & o), n.typeInfo);\n    const c = n.value,\n      u = s.value;\n    return new Ve(c & l | u << i & o, n.typeInfo);\n  }\n  InverseSqrt(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => 1 / Math.sqrt(e)), n.typeInfo);\n    const s = n;\n    return new Ve(1 / Math.sqrt(s.value), n.typeInfo);\n  }\n  Ldexp(e, t) {\n    return console.error(`TODO: ldexp. Line ${e.line}`), null;\n  }\n  Length(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) {\n      let e = 0;\n      return n.data.forEach(t => {\n        e += t * t;\n      }), new Ve(Math.sqrt(e), this.getTypeInfo('f32'));\n    }\n    const s = n;\n    return new Ve(Math.abs(s.value), n.typeInfo);\n  }\n  Log(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.log(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.log(s.value), n.typeInfo);\n  }\n  Log2(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.log2(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.log2(s.value), n.typeInfo);\n  }\n  Max(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t),\n      s = this.exec.evalExpression(e.args[1], t);\n    if (n instanceof Be && s instanceof Be) return new Be(n.data.map((e, t) => Math.max(e, s.data[t])), n.typeInfo);\n    const r = n,\n      a = s;\n    return new Ve(Math.max(r.value, a.value), n.typeInfo);\n  }\n  Min(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t),\n      s = this.exec.evalExpression(e.args[1], t);\n    if (n instanceof Be && s instanceof Be) return new Be(n.data.map((e, t) => Math.min(e, s.data[t])), n.typeInfo);\n    const r = n,\n      a = s;\n    return new Ve(Math.min(r.value, a.value), n.typeInfo);\n  }\n  Mix(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t),\n      s = this.exec.evalExpression(e.args[1], t),\n      r = this.exec.evalExpression(e.args[2], t);\n    if (n instanceof Be && s instanceof Be && r instanceof Be) return new Be(n.data.map((e, t) => n.data[t] * (1 - r.data[t]) + s.data[t] * r.data[t]), n.typeInfo);\n    const a = s,\n      i = r;\n    return new Ve(n.value * (1 - i.value) + a.value * i.value, n.typeInfo);\n  }\n  Modf(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t),\n      s = this.exec.evalExpression(e.args[1], t);\n    if (n instanceof Be && s instanceof Be) return new Be(n.data.map((e, t) => e % s.data[t]), n.typeInfo);\n    const r = s;\n    return new Ve(n.value % r.value, n.typeInfo);\n  }\n  Normalize(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) {\n      const s = this.Length(e, t).value;\n      return new Be(n.data.map(e => e / s), n.typeInfo);\n    }\n    return console.error(`Normalize() expects a vector argument. Line ${e.line}`), null;\n  }\n  Pow(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t),\n      s = this.exec.evalExpression(e.args[1], t);\n    if (n instanceof Be && s instanceof Be) return new Be(n.data.map((e, t) => Math.pow(e, s.data[t])), n.typeInfo);\n    const r = n,\n      a = s;\n    return new Ve(Math.pow(r.value, a.value), n.typeInfo);\n  }\n  QuantizeToF16(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => e), n.typeInfo);\n    return new Ve(n.value, n.typeInfo);\n  }\n  Radians(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => e * Math.PI / 180), n.typeInfo);\n    return new Ve(n.value * Math.PI / 180, this.getTypeInfo('f32'));\n  }\n  Reflect(e, t) {\n    let n = this.exec.evalExpression(e.args[0], t),\n      s = this.exec.evalExpression(e.args[1], t);\n    if (n instanceof Be && s instanceof Be) {\n      const e = this._dot(n.data, s.data);\n      return new Be(n.data.map((t, n) => t - 2 * e * s.data[n]), n.typeInfo);\n    }\n    return console.error(`Reflect() expects vector arguments. Line ${e.line}`), null;\n  }\n  Refract(e, t) {\n    let n = this.exec.evalExpression(e.args[0], t),\n      s = this.exec.evalExpression(e.args[1], t),\n      r = this.exec.evalExpression(e.args[2], t);\n    if (n instanceof Be && s instanceof Be && r instanceof Ve) {\n      const e = this._dot(s.data, n.data);\n      return new Be(n.data.map((t, n) => {\n        const a = 1 - r.value * r.value * (1 - e * e);\n        if (a < 0) return 0;\n        const i = Math.sqrt(a);\n        return r.value * t - (r.value * e + i) * s.data[n];\n      }), n.typeInfo);\n    }\n    return console.error(`Refract() expects vector arguments and a scalar argument. Line ${e.line}`), null;\n  }\n  ReverseBits(e, t) {\n    return console.error(`TODO: reverseBits. Line ${e.line}`), null;\n  }\n  Round(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.round(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.round(s.value), n.typeInfo);\n  }\n  Saturate(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.min(Math.max(e, 0), 1)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.min(Math.max(s.value, 0), 1), n.typeInfo);\n  }\n  Sign(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.sign(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.sign(s.value), n.typeInfo);\n  }\n  Sin(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.sin(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.sin(s.value), n.typeInfo);\n  }\n  Sinh(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.sinh(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.sinh(s.value), n.typeInfo);\n  }\n  _smoothstep(e, t, n) {\n    const s = Math.min(Math.max((n - e) / (t - e), 0), 1);\n    return s * s * (3 - 2 * s);\n  }\n  SmoothStep(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t),\n      s = this.exec.evalExpression(e.args[1], t),\n      r = this.exec.evalExpression(e.args[2], t);\n    if (r instanceof Be && n instanceof Be && s instanceof Be) return new Be(r.data.map((e, t) => this._smoothstep(n.data[t], s.data[t], e)), r.typeInfo);\n    const a = n,\n      i = s,\n      o = r;\n    return new Ve(this._smoothstep(a.value, i.value, o.value), r.typeInfo);\n  }\n  Sqrt(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.sqrt(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.sqrt(s.value), n.typeInfo);\n  }\n  Step(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t),\n      s = this.exec.evalExpression(e.args[1], t);\n    if (s instanceof Be && n instanceof Be) return new Be(s.data.map((e, t) => e < n.data[t] ? 0 : 1), s.typeInfo);\n    const r = n;\n    return new Ve(s.value < r.value ? 0 : 1, r.typeInfo);\n  }\n  Tan(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.tan(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.tan(s.value), n.typeInfo);\n  }\n  Tanh(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.tanh(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.tanh(s.value), n.typeInfo);\n  }\n  _getTransposeType(e) {\n    const t = e.getTypeName();\n    return 'mat2x2f' === t || 'mat2x2h' === t ? e : 'mat2x3f' === t ? this.getTypeInfo('mat3x2f') : 'mat2x3h' === t ? this.getTypeInfo('mat3x2h') : 'mat2x4f' === t ? this.getTypeInfo('mat4x2f') : 'mat2x4h' === t ? this.getTypeInfo('mat4x2h') : 'mat3x2f' === t ? this.getTypeInfo('mat2x3f') : 'mat3x2h' === t ? this.getTypeInfo('mat2x3h') : 'mat3x3f' === t || 'mat3x3h' === t ? e : 'mat3x4f' === t ? this.getTypeInfo('mat4x3f') : 'mat3x4h' === t ? this.getTypeInfo('mat4x3h') : 'mat4x2f' === t ? this.getTypeInfo('mat2x4f') : 'mat4x2h' === t ? this.getTypeInfo('mat2x4h') : 'mat4x3f' === t ? this.getTypeInfo('mat3x4f') : 'mat4x3h' === t ? this.getTypeInfo('mat3x4h') : ('mat4x4f' === t || 'mat4x4h' === t || console.error(`Invalid matrix type ${t}`), e);\n  }\n  Transpose(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (!(n instanceof Fe)) return console.error(`Transpose() expects a matrix argument. Line ${e.line}`), null;\n    const s = this._getTransposeType(n.typeInfo);\n    if ('mat2x2' === n.typeInfo.name || 'mat2x2f' === n.typeInfo.name || 'mat2x2h' === n.typeInfo.name) {\n      const e = n.data;\n      return new Fe([e[0], e[2], e[1], e[3]], s);\n    }\n    if ('mat2x3' === n.typeInfo.name || 'mat2x3f' === n.typeInfo.name || 'mat2x3h' === n.typeInfo.name) {\n      const e = n.data;\n      return new Fe([e[0], e[3], e[6], e[1], e[4], e[7]], s);\n    }\n    if ('mat2x4' === n.typeInfo.name || 'mat2x4f' === n.typeInfo.name || 'mat2x4h' === n.typeInfo.name) {\n      const e = n.data;\n      return new Fe([e[0], e[4], e[8], e[12], e[1], e[5], e[9], e[13]], s);\n    }\n    if ('mat3x2' === n.typeInfo.name || 'mat3x2f' === n.typeInfo.name || 'mat3x2h' === n.typeInfo.name) {\n      const e = n.data;\n      return new Fe([e[0], e[3], e[1], e[4], e[2], e[5]], s);\n    }\n    if ('mat3x3' === n.typeInfo.name || 'mat3x3f' === n.typeInfo.name || 'mat3x3h' === n.typeInfo.name) {\n      const e = n.data;\n      return new Fe([e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]], s);\n    }\n    if ('mat3x4' === n.typeInfo.name || 'mat3x4f' === n.typeInfo.name || 'mat3x4h' === n.typeInfo.name) {\n      const e = n.data;\n      return new Fe([e[0], e[4], e[8], e[12], e[1], e[5], e[9], e[13], e[2], e[6], e[10], e[14]], s);\n    }\n    if ('mat4x2' === n.typeInfo.name || 'mat4x2f' === n.typeInfo.name || 'mat4x2h' === n.typeInfo.name) {\n      const e = n.data;\n      return new Fe([e[0], e[4], e[1], e[5], e[2], e[6]], s);\n    }\n    if ('mat4x3' === n.typeInfo.name || 'mat4x3f' === n.typeInfo.name || 'mat4x3h' === n.typeInfo.name) {\n      const e = n.data;\n      return new Fe([e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]], s);\n    }\n    if ('mat4x4' === n.typeInfo.name || 'mat4x4f' === n.typeInfo.name || 'mat4x4h' === n.typeInfo.name) {\n      const e = n.data;\n      return new Fe([e[0], e[4], e[8], e[12], e[1], e[5], e[9], e[13], e[2], e[6], e[10], e[14], e[3], e[7], e[11], e[15]], s);\n    }\n    return console.error(`Invalid matrix type ${n.typeInfo.name}`), null;\n  }\n  Trunc(e, t) {\n    const n = this.exec.evalExpression(e.args[0], t);\n    if (n instanceof Be) return new Be(n.data.map(e => Math.trunc(e)), n.typeInfo);\n    const s = n;\n    return new Ve(Math.trunc(s.value), n.typeInfo);\n  }\n  Dpdx(e, t) {\n    return console.error(`TODO: dpdx. Line ${e.line}`), null;\n  }\n  DpdxCoarse(e, t) {\n    return console.error(`TODO: dpdxCoarse. Line ${e.line}`), null;\n  }\n  DpdxFine(e, t) {\n    return console.error('TODO: dpdxFine'), null;\n  }\n  Dpdy(e, t) {\n    return console.error('TODO: dpdy'), null;\n  }\n  DpdyCoarse(e, t) {\n    return console.error('TODO: dpdyCoarse'), null;\n  }\n  DpdyFine(e, t) {\n    return console.error('TODO: dpdyFine'), null;\n  }\n  Fwidth(e, t) {\n    return console.error('TODO: fwidth'), null;\n  }\n  FwidthCoarse(e, t) {\n    return console.error('TODO: fwidthCoarse'), null;\n  }\n  FwidthFine(e, t) {\n    return console.error('TODO: fwidthFine'), null;\n  }\n  TextureDimensions(e, t) {\n    const n = e.args[0],\n      s = e.args.length > 1 ? this.exec.evalExpression(e.args[1], t).value : 0;\n    if (n instanceof de) {\n      const r = n.name,\n        a = t.getVariableValue(r);\n      if (a instanceof Ue) {\n        if (s < 0 || s >= a.mipLevelCount) return console.error(`Invalid mip level for textureDimensions. Line ${e.line}`), null;\n        const t = a.getMipLevelSize(s),\n          n = a.dimension;\n        return '1d' === n ? new Ve(t[0], this.getTypeInfo('u32')) : '3d' === n ? new Be(t, this.getTypeInfo('vec3u')) : '2d' === n ? new Be(t.slice(0, 2), this.getTypeInfo('vec2u')) : (console.error(`Invalid texture dimension ${n} not found. Line ${e.line}`), null);\n      }\n      return console.error(`Texture ${r} not found. Line ${e.line}`), null;\n    }\n    return console.error(`Invalid texture argument for textureDimensions. Line ${e.line}`), null;\n  }\n  TextureGather(e, t) {\n    return console.error('TODO: textureGather'), null;\n  }\n  TextureGatherCompare(e, t) {\n    return console.error('TODO: textureGatherCompare'), null;\n  }\n  TextureLoad(e, t) {\n    const n = e.args[0],\n      s = this.exec.evalExpression(e.args[1], t),\n      r = e.args.length > 2 ? this.exec.evalExpression(e.args[2], t).value : 0;\n    if (!(s instanceof Be) || 2 !== s.data.length) return console.error(`Invalid UV argument for textureLoad. Line ${e.line}`), null;\n    if (n instanceof de) {\n      const a = n.name,\n        i = t.getVariableValue(a);\n      if (i instanceof Ue) {\n        const t = Math.floor(s.data[0]),\n          n = Math.floor(s.data[1]);\n        if (t < 0 || t >= i.width || n < 0 || n >= i.height) return console.error(`Texture ${a} out of bounds. Line ${e.line}`), null;\n        const o = i.getPixel(t, n, 0, r);\n        return null === o ? (console.error(`Invalid texture format for textureLoad. Line ${e.line}`), null) : new Be(o, this.getTypeInfo('vec4f'));\n      }\n      return console.error(`Texture ${a} not found. Line ${e.line}`), null;\n    }\n    return console.error(`Invalid texture argument for textureLoad. Line ${e.line}`), null;\n  }\n  TextureNumLayers(e, t) {\n    const n = e.args[0];\n    if (n instanceof de) {\n      const s = n.name,\n        r = t.getVariableValue(s);\n      return r instanceof Ue ? new Ve(r.depthOrArrayLayers, this.getTypeInfo('u32')) : (console.error(`Texture ${s} not found. Line ${e.line}`), null);\n    }\n    return console.error(`Invalid texture argument for textureNumLayers. Line ${e.line}`), null;\n  }\n  TextureNumLevels(e, t) {\n    const n = e.args[0];\n    if (n instanceof de) {\n      const s = n.name,\n        r = t.getVariableValue(s);\n      return r instanceof Ue ? new Ve(r.mipLevelCount, this.getTypeInfo('u32')) : (console.error(`Texture ${s} not found. Line ${e.line}`), null);\n    }\n    return console.error(`Invalid texture argument for textureNumLevels. Line ${e.line}`), null;\n  }\n  TextureNumSamples(e, t) {\n    const n = e.args[0];\n    if (n instanceof de) {\n      const s = n.name,\n        r = t.getVariableValue(s);\n      return r instanceof Ue ? new Ve(r.sampleCount, this.getTypeInfo('u32')) : (console.error(`Texture ${s} not found. Line ${e.line}`), null);\n    }\n    return console.error(`Invalid texture argument for textureNumSamples. Line ${e.line}`), null;\n  }\n  TextureSample(e, t) {\n    return console.error('TODO: textureSample'), null;\n  }\n  TextureSampleBias(e, t) {\n    return console.error('TODO: textureSampleBias'), null;\n  }\n  TextureSampleCompare(e, t) {\n    return console.error('TODO: textureSampleCompare'), null;\n  }\n  TextureSampleCompareLevel(e, t) {\n    return console.error('TODO: textureSampleCompareLevel'), null;\n  }\n  TextureSampleGrad(e, t) {\n    return console.error('TODO: textureSampleGrad'), null;\n  }\n  TextureSampleLevel(e, t) {\n    return console.error('TODO: textureSampleLevel'), null;\n  }\n  TextureSampleBaseClampToEdge(e, t) {\n    return console.error('TODO: textureSampleBaseClampToEdge'), null;\n  }\n  TextureStore(e, t) {\n    const n = e.args[0],\n      s = this.exec.evalExpression(e.args[1], t),\n      r = 4 === e.args.length ? this.exec.evalExpression(e.args[2], t).value : 0,\n      a = 4 === e.args.length ? this.exec.evalExpression(e.args[3], t).data : this.exec.evalExpression(e.args[2], t).data;\n    if (4 !== a.length) return console.error(`Invalid value argument for textureStore. Line ${e.line}`), null;\n    if (!(s instanceof Be) || 2 !== s.data.length) return console.error(`Invalid UV argument for textureStore. Line ${e.line}`), null;\n    if (n instanceof de) {\n      const i = n.name,\n        o = t.getVariableValue(i);\n      if (o instanceof Ue) {\n        const t = o.getMipLevelSize(0),\n          n = Math.floor(s.data[0]),\n          l = Math.floor(s.data[1]);\n        return n < 0 || n >= t[0] || l < 0 || l >= t[1] ? (console.error(`Texture ${i} out of bounds. Line ${e.line}`), null) : (o.setPixel(n, l, 0, r, Array.from(a)), null);\n      }\n      return console.error(`Texture ${i} not found. Line ${e.line}`), null;\n    }\n    return console.error(`Invalid texture argument for textureStore. Line ${e.line}`), null;\n  }\n  AtomicLoad(e, t) {\n    let n = e.args[0];\n    n instanceof ve && (n = n.right);\n    const s = this.exec.getVariableName(n, t);\n    return t.getVariable(s).value.getSubData(this.exec, n.postfix, t);\n  }\n  AtomicStore(e, t) {\n    let n = e.args[0];\n    n instanceof ve && (n = n.right);\n    const s = this.exec.getVariableName(n, t),\n      r = t.getVariable(s);\n    let a = e.args[1];\n    const i = this.exec.evalExpression(a, t),\n      o = r.value.getSubData(this.exec, n.postfix, t);\n    return o instanceof Ve && i instanceof Ve && (o.value = i.value), r.value instanceof Me && r.value.setDataValue(this.exec, o, n.postfix, t), null;\n  }\n  AtomicAdd(e, t) {\n    let n = e.args[0];\n    n instanceof ve && (n = n.right);\n    const s = this.exec.getVariableName(n, t),\n      r = t.getVariable(s);\n    let a = e.args[1];\n    const i = this.exec.evalExpression(a, t),\n      o = r.value.getSubData(this.exec, n.postfix, t),\n      l = new Ve(o.value, o.typeInfo);\n    return o instanceof Ve && i instanceof Ve && (o.value += i.value), r.value instanceof Me && r.value.setDataValue(this.exec, o, n.postfix, t), l;\n  }\n  AtomicSub(e, t) {\n    let n = e.args[0];\n    n instanceof ve && (n = n.right);\n    const s = this.exec.getVariableName(n, t),\n      r = t.getVariable(s);\n    let a = e.args[1];\n    const i = this.exec.evalExpression(a, t),\n      o = r.value.getSubData(this.exec, n.postfix, t),\n      l = new Ve(o.value, o.typeInfo);\n    return o instanceof Ve && i instanceof Ve && (o.value -= i.value), r.value instanceof Me && r.value.setDataValue(this.exec, o, n.postfix, t), l;\n  }\n  AtomicMax(e, t) {\n    let n = e.args[0];\n    n instanceof ve && (n = n.right);\n    const s = this.exec.getVariableName(n, t),\n      r = t.getVariable(s);\n    let a = e.args[1];\n    const i = this.exec.evalExpression(a, t),\n      o = r.value.getSubData(this.exec, n.postfix, t),\n      l = new Ve(o.value, o.typeInfo);\n    return o instanceof Ve && i instanceof Ve && (o.value = Math.max(o.value, i.value)), r.value instanceof Me && r.value.setDataValue(this.exec, o, n.postfix, t), l;\n  }\n  AtomicMin(e, t) {\n    let n = e.args[0];\n    n instanceof ve && (n = n.right);\n    const s = this.exec.getVariableName(n, t),\n      r = t.getVariable(s);\n    let a = e.args[1];\n    const i = this.exec.evalExpression(a, t),\n      o = r.value.getSubData(this.exec, n.postfix, t),\n      l = new Ve(o.value, o.typeInfo);\n    return o instanceof Ve && i instanceof Ve && (o.value = Math.min(o.value, i.value)), r.value instanceof Me && r.value.setDataValue(this.exec, o, n.postfix, t), l;\n  }\n  AtomicAnd(e, t) {\n    let n = e.args[0];\n    n instanceof ve && (n = n.right);\n    const s = this.exec.getVariableName(n, t),\n      r = t.getVariable(s);\n    let a = e.args[1];\n    const i = this.exec.evalExpression(a, t),\n      o = r.value.getSubData(this.exec, n.postfix, t),\n      l = new Ve(o.value, o.typeInfo);\n    return o instanceof Ve && i instanceof Ve && (o.value = o.value & i.value), r.value instanceof Me && r.value.setDataValue(this.exec, o, n.postfix, t), l;\n  }\n  AtomicOr(e, t) {\n    let n = e.args[0];\n    n instanceof ve && (n = n.right);\n    const s = this.exec.getVariableName(n, t),\n      r = t.getVariable(s);\n    let a = e.args[1];\n    const i = this.exec.evalExpression(a, t),\n      o = r.value.getSubData(this.exec, n.postfix, t),\n      l = new Ve(o.value, o.typeInfo);\n    return o instanceof Ve && i instanceof Ve && (o.value = o.value | i.value), r.value instanceof Me && r.value.setDataValue(this.exec, o, n.postfix, t), l;\n  }\n  AtomicXor(e, t) {\n    let n = e.args[0];\n    n instanceof ve && (n = n.right);\n    const s = this.exec.getVariableName(n, t),\n      r = t.getVariable(s);\n    let a = e.args[1];\n    const i = this.exec.evalExpression(a, t),\n      o = r.value.getSubData(this.exec, n.postfix, t),\n      l = new Ve(o.value, o.typeInfo);\n    return o instanceof Ve && i instanceof Ve && (o.value = o.value ^ i.value), r.value instanceof Me && r.value.setDataValue(this.exec, o, n.postfix, t), l;\n  }\n  AtomicExchange(e, t) {\n    let n = e.args[0];\n    n instanceof ve && (n = n.right);\n    const s = this.exec.getVariableName(n, t),\n      r = t.getVariable(s);\n    let a = e.args[1];\n    const i = this.exec.evalExpression(a, t),\n      o = r.value.getSubData(this.exec, n.postfix, t),\n      l = new Ve(o.value, o.typeInfo);\n    return o instanceof Ve && i instanceof Ve && (o.value = i.value), r.value instanceof Me && r.value.setDataValue(this.exec, o, n.postfix, t), l;\n  }\n  AtomicCompareExchangeWeak(e, t) {\n    return console.error('TODO: atomicCompareExchangeWeak'), null;\n  }\n  Pack4x8snorm(e, t) {\n    return console.error('TODO: pack4x8snorm'), null;\n  }\n  Pack4x8unorm(e, t) {\n    return console.error('TODO: pack4x8unorm'), null;\n  }\n  Pack4xI8(e, t) {\n    return console.error('TODO: pack4xI8'), null;\n  }\n  Pack4xU8(e, t) {\n    return console.error('TODO: pack4xU8'), null;\n  }\n  Pack4x8Clamp(e, t) {\n    return console.error('TODO: pack4x8Clamp'), null;\n  }\n  Pack4xU8Clamp(e, t) {\n    return console.error('TODO: pack4xU8Clamp'), null;\n  }\n  Pack2x16snorm(e, t) {\n    return console.error('TODO: pack2x16snorm'), null;\n  }\n  Pack2x16unorm(e, t) {\n    return console.error('TODO: pack2x16unorm'), null;\n  }\n  Pack2x16float(e, t) {\n    return console.error('TODO: pack2x16float'), null;\n  }\n  Unpack4x8snorm(e, t) {\n    return console.error('TODO: unpack4x8snorm'), null;\n  }\n  Unpack4x8unorm(e, t) {\n    return console.error('TODO: unpack4x8unorm'), null;\n  }\n  Unpack4xI8(e, t) {\n    return console.error('TODO: unpack4xI8'), null;\n  }\n  Unpack4xU8(e, t) {\n    return console.error('TODO: unpack4xU8'), null;\n  }\n  Unpack2x16snorm(e, t) {\n    return console.error('TODO: unpack2x16snorm'), null;\n  }\n  Unpack2x16unorm(e, t) {\n    return console.error('TODO: unpack2x16unorm'), null;\n  }\n  Unpack2x16float(e, t) {\n    return console.error('TODO: unpack2x16float'), null;\n  }\n  StorageBarrier(e, t) {\n    return null;\n  }\n  TextureBarrier(e, t) {\n    return null;\n  }\n  WorkgroupBarrier(e, t) {\n    return null;\n  }\n  WorkgroupUniformLoad(e, t) {\n    return null;\n  }\n  SubgroupAdd(e, t) {\n    return console.error('TODO: subgroupAdd'), null;\n  }\n  SubgroupExclusiveAdd(e, t) {\n    return console.error('TODO: subgroupExclusiveAdd'), null;\n  }\n  SubgroupInclusiveAdd(e, t) {\n    return console.error('TODO: subgroupInclusiveAdd'), null;\n  }\n  SubgroupAll(e, t) {\n    return console.error('TODO: subgroupAll'), null;\n  }\n  SubgroupAnd(e, t) {\n    return console.error('TODO: subgroupAnd'), null;\n  }\n  SubgroupAny(e, t) {\n    return console.error('TODO: subgroupAny'), null;\n  }\n  SubgroupBallot(e, t) {\n    return console.error('TODO: subgroupBallot'), null;\n  }\n  SubgroupBroadcast(e, t) {\n    return console.error('TODO: subgroupBroadcast'), null;\n  }\n  SubgroupBroadcastFirst(e, t) {\n    return console.error('TODO: subgroupBroadcastFirst'), null;\n  }\n  SubgroupElect(e, t) {\n    return console.error('TODO: subgroupElect'), null;\n  }\n  SubgroupMax(e, t) {\n    return console.error('TODO: subgroupMax'), null;\n  }\n  SubgroupMin(e, t) {\n    return console.error('TODO: subgroupMin'), null;\n  }\n  SubgroupMul(e, t) {\n    return console.error('TODO: subgroupMul'), null;\n  }\n  SubgroupExclusiveMul(e, t) {\n    return console.error('TODO: subgroupExclusiveMul'), null;\n  }\n  SubgroupInclusiveMul(e, t) {\n    return console.error('TODO: subgroupInclusiveMul'), null;\n  }\n  SubgroupOr(e, t) {\n    return console.error('TODO: subgroupOr'), null;\n  }\n  SubgroupShuffle(e, t) {\n    return console.error('TODO: subgroupShuffle'), null;\n  }\n  SubgroupShuffleDown(e, t) {\n    return console.error('TODO: subgroupShuffleDown'), null;\n  }\n  SubgroupShuffleUp(e, t) {\n    return console.error('TODO: subgroupShuffleUp'), null;\n  }\n  SubgroupShuffleXor(e, t) {\n    return console.error('TODO: subgroupShuffleXor'), null;\n  }\n  SubgroupXor(e, t) {\n    return console.error('TODO: subgroupXor'), null;\n  }\n  QuadBroadcast(e, t) {\n    return console.error('TODO: quadBroadcast'), null;\n  }\n  QuadSwapDiagonal(e, t) {\n    return console.error('TODO: quadSwapDiagonal'), null;\n  }\n  QuadSwapX(e, t) {\n    return console.error('TODO: quadSwapX'), null;\n  }\n  QuadSwapY(e, t) {\n    return console.error('TODO: quadSwapY'), null;\n  }\n}\nconst ct = {\n    vec2: 2,\n    vec2f: 2,\n    vec2i: 2,\n    vec2u: 2,\n    vec2b: 2,\n    vec2h: 2,\n    vec3: 3,\n    vec3f: 3,\n    vec3i: 3,\n    vec3u: 3,\n    vec3b: 3,\n    vec3h: 3,\n    vec4: 4,\n    vec4f: 4,\n    vec4i: 4,\n    vec4u: 4,\n    vec4b: 4,\n    vec4h: 4\n  },\n  ut = {\n    mat2x2: [2, 2, 4],\n    mat2x2f: [2, 2, 4],\n    mat2x2h: [2, 2, 4],\n    mat2x3: [2, 3, 6],\n    mat2x3f: [2, 3, 6],\n    mat2x3h: [2, 3, 6],\n    mat2x4: [2, 4, 8],\n    mat2x4f: [2, 4, 8],\n    mat2x4h: [2, 4, 8],\n    mat3x2: [3, 2, 6],\n    mat3x2f: [3, 2, 6],\n    mat3x2h: [3, 2, 6],\n    mat3x3: [3, 3, 9],\n    mat3x3f: [3, 3, 9],\n    mat3x3h: [3, 3, 9],\n    mat3x4: [3, 4, 12],\n    mat3x4f: [3, 4, 12],\n    mat3x4h: [3, 4, 12],\n    mat4x2: [4, 2, 8],\n    mat4x2f: [4, 2, 8],\n    mat4x2h: [4, 2, 8],\n    mat4x3: [4, 3, 12],\n    mat4x3f: [4, 3, 12],\n    mat4x3h: [4, 3, 12],\n    mat4x4: [4, 4, 16],\n    mat4x4f: [4, 4, 16],\n    mat4x4h: [4, 4, 16]\n  };\nclass ht extends ot {\n  constructor(e, t) {\n    var n;\n    super(), this.ast = null != e ? e : [], this.reflection = new st(), this.reflection.updateAST(this.ast), this.context = null !== (n = null == t ? void 0 : t.clone()) && void 0 !== n ? n : new it(), this.builtins = new lt(this), this.typeInfo = {\n      bool: this.getTypeInfo(se.bool),\n      i32: this.getTypeInfo(se.i32),\n      u32: this.getTypeInfo(se.u32),\n      f32: this.getTypeInfo(se.f32),\n      f16: this.getTypeInfo(se.f16),\n      vec2f: this.getTypeInfo(ie.vec2f),\n      vec2u: this.getTypeInfo(ie.vec2u),\n      vec2i: this.getTypeInfo(ie.vec2i),\n      vec2h: this.getTypeInfo(ie.vec2h),\n      vec3f: this.getTypeInfo(ie.vec3f),\n      vec3u: this.getTypeInfo(ie.vec3u),\n      vec3i: this.getTypeInfo(ie.vec3i),\n      vec3h: this.getTypeInfo(ie.vec3h),\n      vec4f: this.getTypeInfo(ie.vec4f),\n      vec4u: this.getTypeInfo(ie.vec4u),\n      vec4i: this.getTypeInfo(ie.vec4i),\n      vec4h: this.getTypeInfo(ie.vec4h),\n      mat2x2f: this.getTypeInfo(ie.mat2x2f),\n      mat2x3f: this.getTypeInfo(ie.mat2x3f),\n      mat2x4f: this.getTypeInfo(ie.mat2x4f),\n      mat3x2f: this.getTypeInfo(ie.mat3x2f),\n      mat3x3f: this.getTypeInfo(ie.mat3x3f),\n      mat3x4f: this.getTypeInfo(ie.mat3x4f),\n      mat4x2f: this.getTypeInfo(ie.mat4x2f),\n      mat4x3f: this.getTypeInfo(ie.mat4x3f),\n      mat4x4f: this.getTypeInfo(ie.mat4x4f)\n    };\n  }\n  getVariableValue(e) {\n    var t, n;\n    const r = null !== (n = null === (t = this.context.getVariable(e)) || void 0 === t ? void 0 : t.value) && void 0 !== n ? n : null;\n    if (null === r) return null;\n    if (r instanceof Ve) return r.value;\n    if (r instanceof Be) return Array.from(r.data);\n    if (r instanceof Fe) return Array.from(r.data);\n    if (r instanceof Me && r.typeInfo instanceof s) {\n      if ('u32' === r.typeInfo.format.name) return Array.from(new Uint32Array(r.buffer, r.offset, r.typeInfo.count));\n      if ('i32' === r.typeInfo.format.name) return Array.from(new Int32Array(r.buffer, r.offset, r.typeInfo.count));\n      if ('f32' === r.typeInfo.format.name) return Array.from(new Float32Array(r.buffer, r.offset, r.typeInfo.count));\n    }\n    return console.error(`Unsupported return variable type ${r.typeInfo.name}`), null;\n  }\n  execute(e) {\n    (e = null != e ? e : {}).constants && this._setOverrides(e.constants, this.context), this._execStatements(this.ast, this.context);\n  }\n  dispatchWorkgroups(e, t, n, s) {\n    const r = this.context.clone();\n    (s = null != s ? s : {}).constants && this._setOverrides(s.constants, r), this._execStatements(this.ast, r);\n    const a = r.getFunction(e);\n    if (!a) return void console.error(`Function ${e} not found`);\n    if ('number' == typeof t) t = [t, 1, 1];else {\n      if (0 === t.length) return void console.error('Invalid dispatch count');\n      1 === t.length ? t = [t[0], 1, 1] : 2 === t.length ? t = [t[0], t[1], 1] : t.length > 3 && (t = [t[0], t[1], t[2]]);\n    }\n    const i = t[0],\n      o = t[1],\n      l = t[2],\n      c = this.getTypeInfo('vec3u');\n    r.setVariable('@num_workgroups', new Be(t, c));\n    for (const e in n) for (const t in n[e]) {\n      const s = n[e][t];\n      r.variables.forEach(n => {\n        var r;\n        const a = n.node;\n        if (null == a ? void 0 : a.attributes) {\n          let i = null,\n            o = null;\n          for (const e of a.attributes) 'binding' === e.name ? i = e.value : 'group' === e.name && (o = e.value);\n          if (t == i && e == o) if (void 0 !== s.texture && void 0 !== s.descriptor) {\n            const e = new Ue(s.texture, this.getTypeInfo(a.type), s.descriptor, null !== (r = s.texture.view) && void 0 !== r ? r : null);\n            n.value = e;\n          } else void 0 !== s.uniform ? n.value = new Me(s.uniform, this.getTypeInfo(a.type)) : n.value = new Me(s, this.getTypeInfo(a.type));\n        }\n      });\n    }\n    for (let e = 0; e < l; ++e) for (let t = 0; t < o; ++t) for (let n = 0; n < i; ++n) r.setVariable('@workgroup_id', new Be([n, t, e], this.getTypeInfo('vec3u'))), this._dispatchWorkgroup(a, [n, t, e], r);\n  }\n  execStatement(e, t) {\n    if (e instanceof Z) return this.evalExpression(e.value, t);\n    if (e instanceof te) {\n      if (e.condition) {\n        const n = this.evalExpression(e.condition, t);\n        if (!(n instanceof Ve)) throw new Error('Invalid break-if condition');\n        if (!n.value) return null;\n      }\n      return ht._breakObj;\n    }\n    if (e instanceof ne) return ht._continueObj;\n    if (e instanceof F) this._let(e, t);else if (e instanceof O) this._var(e, t);else if (e instanceof M) this._const(e, t);else if (e instanceof L) this._function(e, t);else {\n      if (e instanceof j) return this._if(e, t);\n      if (e instanceof X) return this._switch(e, t);\n      if (e instanceof V) return this._for(e, t);\n      if (e instanceof D) return this._while(e, t);\n      if (e instanceof G) return this._loop(e, t);\n      if (e instanceof N) {\n        const n = t.clone();\n        return n.currentFunctionName = t.currentFunctionName, this._execStatements(e.body, n);\n      }\n      if (e instanceof z) this._assign(e, t);else if (e instanceof H) this._increment(e, t);else {\n        if (e instanceof ae) return null;\n        if (e instanceof B) {\n          const n = e.name;\n          null === t.getVariable(n) && t.setVariable(n, new Ve(0, this.getTypeInfo('u32')));\n        } else if (e instanceof R) this._call(e, t);else {\n          if (e instanceof K) return null;\n          if (e instanceof J) return null;\n          console.error('Invalid statement type.', e, `Line ${e.line}`);\n        }\n      }\n    }\n    return null;\n  }\n  evalExpression(e, t) {\n    return e instanceof we ? this._evalBinaryOp(e, t) : e instanceof _e ? this._evalLiteral(e, t) : e instanceof de ? this._evalVariable(e, t) : e instanceof pe ? this._evalCall(e, t) : e instanceof fe ? this._evalCreate(e, t) : e instanceof me ? this._evalConst(e, t) : e instanceof ge ? this._evalBitcast(e, t) : e instanceof ve ? this._evalUnaryOp(e, t) : (console.error('Invalid expression type', e, `Line ${e.line}`), null);\n  }\n  getTypeInfo(e) {\n    var t;\n    if (e instanceof se) {\n      const t = this.reflection.getTypeInfo(e);\n      if (null !== t) return t;\n    }\n    let n = null !== (t = this.typeInfo[e]) && void 0 !== t ? t : null;\n    return null !== n || (n = this.reflection.getTypeInfoByName(e)), n;\n  }\n  _setOverrides(e, t) {\n    for (const n in e) {\n      const s = e[n],\n        r = this.reflection.getOverrideInfo(n);\n      null !== r ? (null === r.type && (r.type = this.getTypeInfo('u32')), 'u32' === r.type.name || 'i32' === r.type.name || 'f32' === r.type.name || 'f16' === r.type.name ? t.setVariable(n, new Ve(s, r.type)) : 'bool' === r.type.name ? t.setVariable(n, new Ve(s ? 1 : 0, r.type)) : 'vec2' === r.type.name || 'vec3' === r.type.name || 'vec4' === r.type.name || 'vec2f' === r.type.name || 'vec3f' === r.type.name || 'vec4f' === r.type.name || 'vec2i' === r.type.name || 'vec3i' === r.type.name || 'vec4i' === r.type.name || 'vec2u' === r.type.name || 'vec3u' === r.type.name || 'vec4u' === r.type.name || 'vec2h' === r.type.name || 'vec3h' === r.type.name || 'vec4h' === r.type.name ? t.setVariable(n, new Be(s, r.type)) : console.error(`Invalid constant type for ${n}`)) : console.error(`Override ${n} does not exist in the shader.`);\n    }\n  }\n  _dispatchWorkgroup(e, t, n) {\n    const s = [1, 1, 1];\n    for (const t of e.node.attributes) if ('workgroup_size' === t.name) {\n      if (t.value.length > 0) {\n        const e = n.getVariableValue(t.value[0]);\n        s[0] = e instanceof Ve ? e.value : parseInt(t.value[0]);\n      }\n      if (t.value.length > 1) {\n        const e = n.getVariableValue(t.value[1]);\n        s[1] = e instanceof Ve ? e.value : parseInt(t.value[1]);\n      }\n      if (t.value.length > 2) {\n        const e = n.getVariableValue(t.value[2]);\n        s[2] = e instanceof Ve ? e.value : parseInt(t.value[2]);\n      }\n    }\n    const r = this.getTypeInfo('vec3u'),\n      a = this.getTypeInfo('u32');\n    n.setVariable('@workgroup_size', new Be(s, r));\n    const i = s[0],\n      o = s[1],\n      l = s[2];\n    for (let c = 0, u = 0; c < l; ++c) for (let l = 0; l < o; ++l) for (let o = 0; o < i; ++o, ++u) {\n      const i = [o, l, c],\n        h = [o + t[0] * s[0], l + t[1] * s[1], c + t[2] * s[2]];\n      n.setVariable('@local_invocation_id', new Be(i, r)), n.setVariable('@global_invocation_id', new Be(h, r)), n.setVariable('@local_invocation_index', new Ve(u, a)), this._dispatchExec(e, n);\n    }\n  }\n  _dispatchExec(e, t) {\n    for (const n of e.node.args) for (const e of n.attributes) if ('builtin' === e.name) {\n      const s = `@${e.value}`,\n        r = t.getVariable(s);\n      void 0 !== r && t.variables.set(n.name, r);\n    }\n    this._execStatements(e.node.body, t);\n  }\n  getVariableName(e, t) {\n    for (; e instanceof ve;) e = e.right;\n    return e instanceof de ? e.name : (console.error('Unknown variable type', e, 'Line', e.line), null);\n  }\n  _execStatements(e, t) {\n    for (const n of e) {\n      if (n instanceof Array) {\n        const e = t.clone(),\n          s = this._execStatements(n, e);\n        if (s) return s;\n        continue;\n      }\n      const e = this.execStatement(n, t);\n      if (e) return e;\n    }\n    return null;\n  }\n  _call(e, t) {\n    const n = t.clone();\n    n.currentFunctionName = e.name;\n    const s = t.getFunction(e.name);\n    if (s) {\n      for (let t = 0; t < s.node.args.length; ++t) {\n        const r = s.node.args[t],\n          a = this.evalExpression(e.args[t], n);\n        n.setVariable(r.name, a, r);\n      }\n      this._execStatements(s.node.body, n);\n    } else if (e.isBuiltin) this._callBuiltinFunction(e, n);else {\n      this.getTypeInfo(e.name) && this._evalCreate(e, t);\n    }\n  }\n  _increment(e, t) {\n    const n = this.getVariableName(e.variable, t),\n      s = t.getVariable(n);\n    s ? '++' === e.operator ? s.value instanceof Ve ? s.value.value++ : console.error(`Variable ${n} is not a scalar. Line ${e.line}`) : '--' === e.operator ? s.value instanceof Ve ? s.value.value-- : console.error(`Variable ${n} is not a scalar. Line ${e.line}`) : console.error(`Unknown increment operator ${e.operator}. Line ${e.line}`) : console.error(`Variable ${n} not found. Line ${e.line}`);\n  }\n  _getVariableData(e, t) {\n    if (e instanceof de) {\n      const n = this.getVariableName(e, t),\n        s = t.getVariable(n);\n      return null === s ? (console.error(`Variable ${n} not found. Line ${e.line}`), null) : s.value.getSubData(this, e.postfix, t);\n    }\n    if (e instanceof ve) {\n      if ('*' === e.operator) {\n        const n = this._getVariableData(e.right, t);\n        return n instanceof Ne ? n.reference.getSubData(this, e.postfix, t) : (console.error(`Variable ${e.right} is not a pointer. Line ${e.line}`), null);\n      }\n      if ('&' === e.operator) {\n        const n = this._getVariableData(e.right, t);\n        return new Ne(n);\n      }\n    }\n    return null;\n  }\n  _assign(e, t) {\n    let n = null,\n      s = '<var>',\n      r = null;\n    if (e.variable instanceof ve) {\n      const n = this._getVariableData(e.variable, t),\n        s = this.evalExpression(e.value, t),\n        r = e.operator;\n      if ('=' === r) {\n        if (n instanceof Ve || n instanceof Be || n instanceof Fe) {\n          if (s instanceof Ve || s instanceof Be || s instanceof Fe && n.data.length === s.data.length) return void n.data.set(s.data);\n          console.error(`Invalid assignment. Line ${e.line}`);\n        } else if (n instanceof Me && s instanceof Me && n.buffer.byteLength - n.offset >= s.buffer.byteLength - s.offset) return void (n.buffer.byteLength % 4 == 0 ? new Uint32Array(n.buffer, n.offset, n.typeInfo.size / 4).set(new Uint32Array(s.buffer, s.offset, s.typeInfo.size / 4)) : new Uint8Array(n.buffer, n.offset, n.typeInfo.size).set(new Uint8Array(s.buffer, s.offset, s.typeInfo.size)));\n        return console.error(`Invalid assignment. Line ${e.line}`), null;\n      }\n      if ('+=' === r) return n instanceof Ve || n instanceof Be || n instanceof Fe ? s instanceof Ve || s instanceof Be || s instanceof Fe ? void n.data.set(s.data.map((e, t) => n.data[t] + e)) : void console.error(`Invalid assignment . Line ${e.line}`) : void console.error(`Invalid assignment. Line ${e.line}`);\n      if ('-=' === r) return (n instanceof Ve || n instanceof Be || n instanceof Fe) && (s instanceof Ve || s instanceof Be || s instanceof Fe) ? void n.data.set(s.data.map((e, t) => n.data[t] - e)) : void console.error(`Invalid assignment. Line ${e.line}`);\n    }\n    if (e.variable instanceof ve) {\n      if ('*' === e.variable.operator) {\n        s = this.getVariableName(e.variable.right, t);\n        const r = t.getVariable(s);\n        if (!(r && r.value instanceof Ne)) return void console.error(`Variable ${s} is not a pointer. Line ${e.line}`);\n        n = r.value.reference;\n        let a = e.variable.postfix;\n        if (!a) {\n          let t = e.variable.right;\n          for (; t instanceof ve;) {\n            if (t.postfix) {\n              a = t.postfix;\n              break;\n            }\n            t = t.right;\n          }\n        }\n        a && (n = n.getSubData(this, a, t));\n      }\n    } else {\n      r = e.variable.postfix, s = this.getVariableName(e.variable, t);\n      const a = t.getVariable(s);\n      if (null === a) return void console.error(`Variable ${s} not found. Line ${e.line}`);\n      n = a.value;\n    }\n    if (n instanceof Ne && (n = n.reference), null === n) return void console.error(`Variable ${s} not found. Line ${e.line}`);\n    const a = this.evalExpression(e.value, t),\n      i = e.operator;\n    if ('=' === i) {\n      if (n instanceof Me) n.setDataValue(this, a, r, t);else if (r) {\n        if (!(n instanceof Be || n instanceof Fe)) return void console.error(`Variable ${s} is not a vector or matrix. Line ${e.line}`);\n        if (r instanceof ye) {\n          const i = this.evalExpression(r.index, t).value;\n          if (n instanceof Be) {\n            if (!(a instanceof Ve)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);\n            n.data[i] = a.value;\n          } else {\n            if (!(n instanceof Fe)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);\n            {\n              const i = this.evalExpression(r.index, t).value;\n              if (i < 0) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);\n              if (!(a instanceof Be)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);\n              {\n                const t = n.typeInfo.getTypeName();\n                if ('mat2x2' === t || 'mat2x2f' === t || 'mat2x2h' === t) {\n                  if (!(i < 2 && 2 === a.data.length)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);\n                  n.data[2 * i] = a.data[0], n.data[2 * i + 1] = a.data[1];\n                } else if ('mat2x3' === t || 'mat2x3f' === t || 'mat2x3h' === t) {\n                  if (!(i < 2 && 3 === a.data.length)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);\n                  n.data[3 * i] = a.data[0], n.data[3 * i + 1] = a.data[1], n.data[3 * i + 2] = a.data[2];\n                } else if ('mat2x4' === t || 'mat2x4f' === t || 'mat2x4h' === t) {\n                  if (!(i < 2 && 4 === a.data.length)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);\n                  n.data[4 * i] = a.data[0], n.data[4 * i + 1] = a.data[1], n.data[4 * i + 2] = a.data[2], n.data[4 * i + 3] = a.data[3];\n                } else if ('mat3x2' === t || 'mat3x2f' === t || 'mat3x2h' === t) {\n                  if (!(i < 3 && 2 === a.data.length)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);\n                  n.data[2 * i] = a.data[0], n.data[2 * i + 1] = a.data[1];\n                } else if ('mat3x3' === t || 'mat3x3f' === t || 'mat3x3h' === t) {\n                  if (!(i < 3 && 3 === a.data.length)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);\n                  n.data[3 * i] = a.data[0], n.data[3 * i + 1] = a.data[1], n.data[3 * i + 2] = a.data[2];\n                } else if ('mat3x4' === t || 'mat3x4f' === t || 'mat3x4h' === t) {\n                  if (!(i < 3 && 4 === a.data.length)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);\n                  n.data[4 * i] = a.data[0], n.data[4 * i + 1] = a.data[1], n.data[4 * i + 2] = a.data[2], n.data[4 * i + 3] = a.data[3];\n                } else if ('mat4x2' === t || 'mat4x2f' === t || 'mat4x2h' === t) {\n                  if (!(i < 4 && 2 === a.data.length)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);\n                  n.data[2 * i] = a.data[0], n.data[2 * i + 1] = a.data[1];\n                } else if ('mat4x3' === t || 'mat4x3f' === t || 'mat4x3h' === t) {\n                  if (!(i < 4 && 3 === a.data.length)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);\n                  n.data[3 * i] = a.data[0], n.data[3 * i + 1] = a.data[1], n.data[3 * i + 2] = a.data[2];\n                } else {\n                  if ('mat4x4' !== t && 'mat4x4f' !== t && 'mat4x4h' !== t) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);\n                  if (!(i < 4 && 4 === a.data.length)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);\n                  n.data[4 * i] = a.data[0], n.data[4 * i + 1] = a.data[1], n.data[4 * i + 2] = a.data[2], n.data[4 * i + 3] = a.data[3];\n                }\n              }\n            }\n          }\n        } else if (r instanceof he) {\n          const t = r.value;\n          if (!(n instanceof Be)) return void console.error(`Invalid assignment to ${t}. Variable ${s} is not a vector. Line ${e.line}`);\n          if (a instanceof Ve) {\n            if (t.length > 1) return void console.error(`Invalid assignment to ${t} for variable ${s}. Line ${e.line}`);\n            if ('x' === t) n.data[0] = a.value;else if ('y' === t) {\n              if (n.data.length < 2) return void console.error(`Invalid assignment to ${t} for variable ${s}. Line ${e.line}`);\n              n.data[1] = a.value;\n            } else if ('z' === t) {\n              if (n.data.length < 3) return void console.error(`Invalid assignment to ${t} for variable ${s}. Line ${e.line}`);\n              n.data[2] = a.value;\n            } else if ('w' === t) {\n              if (n.data.length < 4) return void console.error(`Invalid assignment to ${t} for variable ${s}. Line ${e.line}`);\n              n.data[3] = a.value;\n            }\n          } else {\n            if (!(a instanceof Be)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);\n            if (t.length !== a.data.length) return void console.error(`Invalid assignment to ${t} for variable ${s}. Line ${e.line}`);\n            for (let r = 0; r < t.length; ++r) {\n              const i = t[r];\n              if ('x' === i || 'r' === i) n.data[0] = a.data[r];else if ('y' === i || 'g' === i) {\n                if (a.data.length < 2) return void console.error(`Invalid assignment to ${i} for variable ${s}. Line ${e.line}`);\n                n.data[1] = a.data[r];\n              } else if ('z' === i || 'b' === i) {\n                if (a.data.length < 3) return void console.error(`Invalid assignment to ${i} for variable ${s}. Line ${e.line}`);\n                n.data[2] = a.data[r];\n              } else {\n                if ('w' !== i && 'a' !== i) return void console.error(`Invalid assignment to ${i} for variable ${s}. Line ${e.line}`);\n                if (a.data.length < 4) return void console.error(`Invalid assignment to ${i} for variable ${s}. Line ${e.line}`);\n                n.data[3] = a.data[r];\n              }\n            }\n          }\n        }\n      } else n instanceof Ve && a instanceof Ve ? n.value = a.value : n instanceof Be && a instanceof Be || n instanceof Fe && a instanceof Fe ? n.data.set(a.data) : console.error(`Invalid assignment to ${s}. Line ${e.line}`);\n    } else {\n      const s = n.getSubData(this, r, t);\n      if (s instanceof Be && a instanceof Ve) {\n        const t = s.data,\n          n = a.value;\n        if ('+=' === i) for (let e = 0; e < t.length; ++e) t[e] += n;else if ('-=' === i) for (let e = 0; e < t.length; ++e) t[e] -= n;else if ('*=' === i) for (let e = 0; e < t.length; ++e) t[e] *= n;else if ('/=' === i) for (let e = 0; e < t.length; ++e) t[e] /= n;else if ('%=' === i) for (let e = 0; e < t.length; ++e) t[e] %= n;else if ('&=' === i) for (let e = 0; e < t.length; ++e) t[e] &= n;else if ('|=' === i) for (let e = 0; e < t.length; ++e) t[e] |= n;else if ('^=' === i) for (let e = 0; e < t.length; ++e) t[e] ^= n;else if ('<<=' === i) for (let e = 0; e < t.length; ++e) t[e] <<= n;else if ('>>=' === i) for (let e = 0; e < t.length; ++e) t[e] >>= n;else console.error(`Invalid operator ${i}. Line ${e.line}`);\n      } else if (s instanceof Be && a instanceof Be) {\n        const t = s.data,\n          n = a.data;\n        if (t.length !== n.length) return void console.error(`Vector length mismatch. Line ${e.line}`);\n        if ('+=' === i) for (let e = 0; e < t.length; ++e) t[e] += n[e];else if ('-=' === i) for (let e = 0; e < t.length; ++e) t[e] -= n[e];else if ('*=' === i) for (let e = 0; e < t.length; ++e) t[e] *= n[e];else if ('/=' === i) for (let e = 0; e < t.length; ++e) t[e] /= n[e];else if ('%=' === i) for (let e = 0; e < t.length; ++e) t[e] %= n[e];else if ('&=' === i) for (let e = 0; e < t.length; ++e) t[e] &= n[e];else if ('|=' === i) for (let e = 0; e < t.length; ++e) t[e] |= n[e];else if ('^=' === i) for (let e = 0; e < t.length; ++e) t[e] ^= n[e];else if ('<<=' === i) for (let e = 0; e < t.length; ++e) t[e] <<= n[e];else if ('>>=' === i) for (let e = 0; e < t.length; ++e) t[e] >>= n[e];else console.error(`Invalid operator ${i}. Line ${e.line}`);\n      } else {\n        if (!(s instanceof Ve && a instanceof Ve)) return void console.error(`Invalid type for ${e.operator} operator. Line ${e.line}`);\n        '+=' === i ? s.value += a.value : '-=' === i ? s.value -= a.value : '*=' === i ? s.value *= a.value : '/=' === i ? s.value /= a.value : '%=' === i ? s.value %= a.value : '&=' === i ? s.value &= a.value : '|=' === i ? s.value |= a.value : '^=' === i ? s.value ^= a.value : '<<=' === i ? s.value <<= a.value : '>>=' === i ? s.value >>= a.value : console.error(`Invalid operator ${i}. Line ${e.line}`);\n      }\n      n instanceof Me && n.setDataValue(this, s, r, t);\n    }\n  }\n  _function(e, t) {\n    const n = new at(e);\n    t.functions.set(e.name, n);\n  }\n  _const(e, t) {\n    let n = null;\n    null !== e.value && (n = this.evalExpression(e.value, t)), t.createVariable(e.name, n, e);\n  }\n  _let(e, t) {\n    let n = null;\n    if (null !== e.value) {\n      if (n = this.evalExpression(e.value, t), null === n) return void console.error(`Invalid value for variable ${e.name}. Line ${e.line}`);\n      e.value instanceof ve || (n = n.clone());\n    } else {\n      const s = e.type.name;\n      if ('f32' === s || 'i32' === s || 'u32' === s || 'bool' === s || 'f16' === s || 'vec2' === s || 'vec3' === s || 'vec4' === s || 'vec2f' === s || 'vec3f' === s || 'vec4f' === s || 'vec2i' === s || 'vec3i' === s || 'vec4i' === s || 'vec2u' === s || 'vec3u' === s || 'vec4u' === s || 'vec2h' === s || 'vec3h' === s || 'vec4h' === s || 'vec2b' === s || 'vec3b' === s || 'vec4b' === s || 'mat2x2' === s || 'mat2x3' === s || 'mat2x4' === s || 'mat3x2' === s || 'mat3x3' === s || 'mat3x4' === s || 'mat4x2' === s || 'mat4x3' === s || 'mat4x4' === s || 'mat2x2f' === s || 'mat2x3f' === s || 'mat2x4f' === s || 'mat3x2f' === s || 'mat3x3f' === s || 'mat3x4f' === s || 'mat4x2f' === s || 'mat4x3f' === s || 'mat4x4f' === s || 'mat2x2h' === s || 'mat2x3h' === s || 'mat2x4h' === s || 'mat3x2h' === s || 'mat3x3h' === s || 'mat3x4h' === s || 'mat4x2h' === s || 'mat4x3h' === s || 'mat4x4h' === s || 'array' === s) {\n        const s = new fe(e.type, []);\n        n = this._evalCreate(s, t);\n      }\n    }\n    t.createVariable(e.name, n, e);\n  }\n  _var(e, t) {\n    let n = null;\n    if (null !== e.value) {\n      if (n = this.evalExpression(e.value, t), null === n) return void console.error(`Invalid value for variable ${e.name}. Line ${e.line}`);\n      e.value instanceof ve || (n = n.clone());\n    } else {\n      if (null === e.type) return void console.error(`Variable ${e.name} has no type. Line ${e.line}`);\n      const s = e.type.name;\n      if ('f32' === s || 'i32' === s || 'u32' === s || 'bool' === s || 'f16' === s || 'vec2' === s || 'vec3' === s || 'vec4' === s || 'vec2f' === s || 'vec3f' === s || 'vec4f' === s || 'vec2i' === s || 'vec3i' === s || 'vec4i' === s || 'vec2u' === s || 'vec3u' === s || 'vec4u' === s || 'vec2h' === s || 'vec3h' === s || 'vec4h' === s || 'vec2b' === s || 'vec3b' === s || 'vec4b' === s || 'mat2x2' === s || 'mat2x3' === s || 'mat2x4' === s || 'mat3x2' === s || 'mat3x3' === s || 'mat3x4' === s || 'mat4x2' === s || 'mat4x3' === s || 'mat4x4' === s || 'mat2x2f' === s || 'mat2x3f' === s || 'mat2x4f' === s || 'mat3x2f' === s || 'mat3x3f' === s || 'mat3x4f' === s || 'mat4x2f' === s || 'mat4x3f' === s || 'mat4x4f' === s || 'mat2x2h' === s || 'mat2x3h' === s || 'mat2x4h' === s || 'mat3x2h' === s || 'mat3x3h' === s || 'mat3x4h' === s || 'mat4x2h' === s || 'mat4x3h' === s || 'mat4x4h' === s || e.type instanceof le || e.type instanceof ae || e.type instanceof ie) {\n        const s = new fe(e.type, []);\n        n = this._evalCreate(s, t);\n      }\n    }\n    t.createVariable(e.name, n, e);\n  }\n  _switch(e, t) {\n    t = t.clone();\n    const n = this.evalExpression(e.condition, t);\n    if (!(n instanceof Ve)) return console.error(`Invalid if condition. Line ${e.line}`), null;\n    let s = null;\n    for (const r of e.cases) if (r instanceof Te) for (const a of r.selectors) {\n      if (a instanceof Ie) {\n        s = r;\n        continue;\n      }\n      const i = this.evalExpression(a, t);\n      if (!(i instanceof Ve)) return console.error(`Invalid case selector. Line ${e.line}`), null;\n      if (i.value === n.value) return this._execStatements(r.body, t);\n    } else r instanceof Se && (s = r);\n    return s ? this._execStatements(s.body, t) : null;\n  }\n  _if(e, t) {\n    t = t.clone();\n    const n = this.evalExpression(e.condition, t);\n    if (!(n instanceof Ve)) return console.error(`Invalid if condition. Line ${e.line}`), null;\n    if (n.value) return this._execStatements(e.body, t);\n    for (const n of e.elseif) {\n      const s = this.evalExpression(n.condition, t);\n      if (!(s instanceof Ve)) return console.error(`Invalid if condition. Line ${e.line}`), null;\n      if (s.value) return this._execStatements(n.body, t);\n    }\n    return e.else ? this._execStatements(e.else, t) : null;\n  }\n  _getScalarValue(e) {\n    return e instanceof Ve ? e.value : (console.error('Expected scalar value.', e), 0);\n  }\n  _for(e, t) {\n    for (t = t.clone(), this.execStatement(e.init, t); this._getScalarValue(this.evalExpression(e.condition, t));) {\n      const n = this._execStatements(e.body, t);\n      if (n === ht._breakObj) break;\n      if (null !== n && n !== ht._continueObj) return n;\n      this.execStatement(e.increment, t);\n    }\n    return null;\n  }\n  _loop(e, t) {\n    for (t = t.clone();;) {\n      const n = this._execStatements(e.body, t);\n      if (n === ht._breakObj) break;\n      if (n === ht._continueObj) {\n        if (e.continuing) {\n          if (this._execStatements(e.continuing.body, t) === ht._breakObj) break;\n        }\n      } else if (null !== n) return n;\n    }\n    return null;\n  }\n  _while(e, t) {\n    for (t = t.clone(); this._getScalarValue(this.evalExpression(e.condition, t));) {\n      const n = this._execStatements(e.body, t);\n      if (n === ht._breakObj) break;\n      if (n !== ht._continueObj && null !== n) return n;\n    }\n    return null;\n  }\n  _evalBitcast(e, t) {\n    const n = this.evalExpression(e.value, t),\n      s = e.type;\n    if (n instanceof Ve) {\n      const e = et(n.value, n.typeInfo.name, s.name);\n      return new Ve(e, this.getTypeInfo(s));\n    }\n    if (n instanceof Be) {\n      const t = n.typeInfo.getTypeName();\n      let r = '';\n      if (t.endsWith('f')) r = 'f32';else if (t.endsWith('i')) r = 'i32';else if (t.endsWith('u')) r = 'u32';else if (t.endsWith('b')) r = 'bool';else {\n        if (!t.endsWith('h')) return console.error(`Unknown vector type ${t}. Line ${e.line}`), null;\n        r = 'f16';\n      }\n      const a = s.getTypeName();\n      let i = '';\n      if (a.endsWith('f')) i = 'f32';else if (a.endsWith('i')) i = 'i32';else if (a.endsWith('u')) i = 'u32';else if (a.endsWith('b')) i = 'bool';else {\n        if (!a.endsWith('h')) return console.error(`Unknown vector type ${i}. Line ${e.line}`), null;\n        i = 'f16';\n      }\n      const o = function (e, t, n) {\n        if (t === n) return e;\n        const s = new Array(e.length);\n        for (let r = 0; r < e.length; r++) s[r] = et(e[r], t, n);\n        return s;\n      }(Array.from(n.data), r, i);\n      return new Be(o, this.getTypeInfo(s));\n    }\n    return console.error(`TODO: bitcast for ${n.typeInfo.name}. Line ${e.line}`), null;\n  }\n  _evalConst(e, t) {\n    return t.getVariableValue(e.name).clone().getSubData(this, e.postfix, t);\n  }\n  _evalCreate(e, t) {\n    var r;\n    if (e instanceof fe) {\n      if (null === e.type) return De.void;\n      switch (e.type.getTypeName()) {\n        case 'bool':\n        case 'i32':\n        case 'u32':\n        case 'f32':\n        case 'f16':\n          return this._callConstructorValue(e, t);\n        case 'vec2':\n        case 'vec3':\n        case 'vec4':\n        case 'vec2f':\n        case 'vec3f':\n        case 'vec4f':\n        case 'vec2h':\n        case 'vec3h':\n        case 'vec4h':\n        case 'vec2i':\n        case 'vec3i':\n        case 'vec4i':\n        case 'vec2u':\n        case 'vec3u':\n        case 'vec4u':\n        case 'vec2b':\n        case 'vec3b':\n        case 'vec4b':\n          return this._callConstructorVec(e, t);\n        case 'mat2x2':\n        case 'mat2x2f':\n        case 'mat2x2h':\n        case 'mat2x3':\n        case 'mat2x3f':\n        case 'mat2x3h':\n        case 'mat2x4':\n        case 'mat2x4f':\n        case 'mat2x4h':\n        case 'mat3x2':\n        case 'mat3x2f':\n        case 'mat3x2h':\n        case 'mat3x3':\n        case 'mat3x3f':\n        case 'mat3x3h':\n        case 'mat3x4':\n        case 'mat3x4f':\n        case 'mat3x4h':\n        case 'mat4x2':\n        case 'mat4x2f':\n        case 'mat4x2h':\n        case 'mat4x3':\n        case 'mat4x3f':\n        case 'mat4x3h':\n        case 'mat4x4':\n        case 'mat4x4f':\n        case 'mat4x4h':\n          return this._callConstructorMatrix(e, t);\n      }\n    }\n    const a = e instanceof fe ? e.type.name : e.name,\n      i = e instanceof fe ? this.getTypeInfo(e.type) : this.getTypeInfo(e.name);\n    if (null === i) return console.error(`Unknown type ${a}. Line ${e.line}`), null;\n    if (0 === i.size) return null;\n    const o = new Me(new ArrayBuffer(i.size), i, 0);\n    if (i instanceof n) {\n      if (e.args) for (let n = 0; n < e.args.length; ++n) {\n        const s = i.members[n],\n          r = e.args[n],\n          a = this.evalExpression(r, t);\n        o.setData(this, a, s.type, s.offset, t);\n      }\n    } else if (i instanceof s) {\n      let n = 0;\n      if (e.args) for (let s = 0; s < e.args.length; ++s) {\n        const a = e.args[s],\n          l = this.evalExpression(a, t);\n        null === i.format && ('x32' === (null === (r = l.typeInfo) || void 0 === r ? void 0 : r.name) ? i.format = this.getTypeInfo('i32') : i.format = l.typeInfo), o.setData(this, l, i.format, n, t), n += i.stride;\n      }\n    } else console.error(`Unknown type \"${a}\". Line ${e.line}`);\n    return e instanceof fe ? o.getSubData(this, e.postfix, t) : o;\n  }\n  _evalLiteral(e, t) {\n    const n = this.getTypeInfo(e.type),\n      s = n.name;\n    if ('x32' === s || 'u32' === s || 'f32' === s || 'f16' === s || 'i32' === s || 'bool' === s) {\n      return new Ve(e.scalarValue, n);\n    }\n    return 'vec2' === s || 'vec3' === s || 'vec4' === s || 'vec2f' === s || 'vec3f' === s || 'vec4f' === s || 'vec2h' === s || 'vec3h' === s || 'vec4h' === s || 'vec2i' === s || 'vec3i' === s || 'vec4i' === s || 'vec2u' === s || 'vec3u' === s || 'vec4u' === s ? this._callConstructorVec(e, t) : 'mat2x2' === s || 'mat2x3' === s || 'mat2x4' === s || 'mat3x2' === s || 'mat3x3' === s || 'mat3x4' === s || 'mat4x2' === s || 'mat4x3' === s || 'mat4x4' === s || 'mat2x2f' === s || 'mat2x3f' === s || 'mat2x4f' === s || 'mat3x2f' === s || 'mat3x3f' === s || 'mat3x4f' === s || 'mat4x2f' === s || 'mat4x3f' === s || 'mat4x4f' === s || 'mat2x2h' === s || 'mat2x3h' === s || 'mat2x4h' === s || 'mat3x2h' === s || 'mat3x3h' === s || 'mat3x4h' === s || 'mat4x2h' === s || 'mat4x3h' === s || 'mat4x4h' === s ? this._callConstructorMatrix(e, t) : e.value;\n  }\n  _evalVariable(e, t) {\n    const n = t.getVariableValue(e.name);\n    return null === n ? n : n.getSubData(this, e.postfix, t);\n  }\n  _maxFormatTypeInfo(e) {\n    let t = e[0];\n    if ('f32' === t.name) return t;\n    for (let n = 1; n < e.length; ++n) {\n      const s = ht._priority.get(t.name);\n      ht._priority.get(e[n].name) < s && (t = e[n]);\n    }\n    return 'x32' === t.name ? this.getTypeInfo('i32') : t;\n  }\n  _evalUnaryOp(e, t) {\n    const n = this.evalExpression(e.right, t);\n    if ('&' === e.operator) return new Ne(n);\n    if ('*' === e.operator) return n instanceof Ne ? n.reference.getSubData(this, e.postfix, t) : (console.error(`Invalid dereference. Line ${e.line}`), null);\n    const s = n instanceof Ve ? n.value : n instanceof Be ? Array.from(n.data) : null;\n    switch (e.operator) {\n      case '+':\n        {\n          if (ze(s)) {\n            const e = s.map((e, t) => +e);\n            return new Be(e, n.typeInfo);\n          }\n          const e = s,\n            t = this._maxFormatTypeInfo([n.typeInfo, n.typeInfo]);\n          return new Ve(+e, t);\n        }\n      case '-':\n        {\n          if (ze(s)) {\n            const e = s.map((e, t) => -e);\n            return new Be(e, n.typeInfo);\n          }\n          const e = s,\n            t = this._maxFormatTypeInfo([n.typeInfo, n.typeInfo]);\n          return new Ve(-e, t);\n        }\n      case '!':\n        {\n          if (ze(s)) {\n            const e = s.map((e, t) => e ? 0 : 1);\n            return new Be(e, n.typeInfo);\n          }\n          const e = s,\n            t = this._maxFormatTypeInfo([n.typeInfo, n.typeInfo]);\n          return new Ve(e ? 0 : 1, t);\n        }\n      case '~':\n        {\n          if (ze(s)) {\n            const e = s.map((e, t) => ~e);\n            return new Be(e, n.typeInfo);\n          }\n          const e = s,\n            t = this._maxFormatTypeInfo([n.typeInfo, n.typeInfo]);\n          return new Ve(~e, t);\n        }\n    }\n    return console.error(`Invalid unary operator ${e.operator}. Line ${e.line}`), null;\n  }\n  _evalBinaryOp(e, t) {\n    const n = this.evalExpression(e.left, t),\n      s = this.evalExpression(e.right, t),\n      r = n instanceof Ve ? n.value : n instanceof Be || n instanceof Fe ? Array.from(n.data) : null,\n      a = s instanceof Ve ? s.value : s instanceof Be || s instanceof Fe ? Array.from(s.data) : null;\n    switch (e.operator) {\n      case '+':\n        {\n          if (ze(r) && ze(a)) {\n            const t = r,\n              s = a;\n            if (t.length !== s.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;\n            const i = t.map((e, t) => e + s[t]);\n            return new Be(i, n.typeInfo);\n          }\n          if (ze(r)) {\n            const e = a,\n              t = r.map((t, n) => t + e);\n            return new Be(t, n.typeInfo);\n          }\n          if (ze(a)) {\n            const e = r,\n              t = a.map((t, n) => e + t);\n            return new Be(t, s.typeInfo);\n          }\n          const t = r,\n            i = a,\n            o = this._maxFormatTypeInfo([n.typeInfo, s.typeInfo]);\n          return new Ve(t + i, o);\n        }\n      case '-':\n        {\n          if (ze(r) && ze(a)) {\n            const t = r,\n              s = a;\n            if (t.length !== s.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;\n            const i = t.map((e, t) => e - s[t]);\n            return new Be(i, n.typeInfo);\n          }\n          if (ze(r)) {\n            const e = a,\n              t = r.map((t, n) => t - e);\n            return new Be(t, n.typeInfo);\n          }\n          if (ze(a)) {\n            const e = r,\n              t = a.map((t, n) => e - t);\n            return new Be(t, s.typeInfo);\n          }\n          const t = r,\n            i = a,\n            o = this._maxFormatTypeInfo([n.typeInfo, s.typeInfo]);\n          return new Ve(t - i, o);\n        }\n      case '*':\n        {\n          if (ze(r) && ze(a)) {\n            const t = r,\n              i = a;\n            if (n instanceof Fe && s instanceof Fe) {\n              const r = function (e, t, n, s) {\n                if (void 0 === ut[t.name] || void 0 === ut[s.name]) return null;\n                const r = ut[t.name][0],\n                  a = ut[t.name][1],\n                  i = ut[s.name][0];\n                if (r !== ut[s.name][1]) return null;\n                const o = new Array(i * a);\n                for (let t = 0; t < a; t++) for (let s = 0; s < i; s++) {\n                  let l = 0;\n                  for (let i = 0; i < r; i++) l += e[i * a + t] * n[s * r + i];\n                  o[t * i + s] = l;\n                }\n                return o;\n              }(t, n.typeInfo, i, s.typeInfo);\n              if (null === r) return console.error(`Matrix multiplication failed. Line ${e.line}.`), null;\n              const a = ut[s.typeInfo.name][0],\n                o = ut[n.typeInfo.name][1],\n                l = this.getTypeInfo(`mat${a}x${o}f`);\n              return new Fe(r, l);\n            }\n            if (n instanceof Fe && s instanceof Be) {\n              const r = function (e, t, n, s) {\n                if (void 0 === ut[t.name] || void 0 === ct[s.name]) return null;\n                const r = ut[t.name][0],\n                  a = ut[t.name][1];\n                if (r !== n.length) return null;\n                const i = new Array(a);\n                for (let t = 0; t < a; t++) {\n                  let s = 0;\n                  for (let i = 0; i < r; i++) s += e[i * a + t] * n[i];\n                  i[t] = s;\n                }\n                return i;\n              }(t, n.typeInfo, i, s.typeInfo);\n              return null === r ? (console.error(`Matrix vector multiplication failed. Line ${e.line}.`), null) : new Be(r, s.typeInfo);\n            }\n            if (n instanceof Be && s instanceof Fe) {\n              const r = function (e, t, n, s) {\n                if (void 0 === ct[t.name] || void 0 === ut[s.name]) return null;\n                const r = ut[s.name][0],\n                  a = ut[s.name][1];\n                if (a !== e.length) return null;\n                const i = [];\n                for (let t = 0; t < r; t++) {\n                  let s = 0;\n                  for (let i = 0; i < a; i++) s += e[i] * n[i * r + t];\n                  i[t] = s;\n                }\n                return i;\n              }(t, n.typeInfo, i, s.typeInfo);\n              return null === r ? (console.error(`Matrix vector multiplication failed. Line ${e.line}.`), null) : new Be(r, n.typeInfo);\n            }\n            {\n              if (t.length !== i.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;\n              const s = t.map((e, t) => e * i[t]);\n              return new Be(s, n.typeInfo);\n            }\n          }\n          if (ze(r)) {\n            const e = a,\n              t = r.map((t, n) => t * e);\n            return n instanceof Fe ? new Fe(t, n.typeInfo) : new Be(t, n.typeInfo);\n          }\n          if (ze(a)) {\n            const e = r,\n              t = a.map((t, n) => e * t);\n            return s instanceof Fe ? new Fe(t, s.typeInfo) : new Be(t, s.typeInfo);\n          }\n          const t = r,\n            i = a,\n            o = this._maxFormatTypeInfo([n.typeInfo, s.typeInfo]);\n          return new Ve(t * i, o);\n        }\n      case '%':\n        {\n          if (ze(r) && ze(a)) {\n            const t = r,\n              s = a;\n            if (t.length !== s.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;\n            const i = t.map((e, t) => e % s[t]);\n            return new Be(i, n.typeInfo);\n          }\n          if (ze(r)) {\n            const e = a,\n              t = r.map((t, n) => t % e);\n            return new Be(t, n.typeInfo);\n          }\n          if (ze(a)) {\n            const e = r,\n              t = a.map((t, n) => e % t);\n            return new Be(t, s.typeInfo);\n          }\n          const t = r,\n            i = a,\n            o = this._maxFormatTypeInfo([n.typeInfo, s.typeInfo]);\n          return new Ve(t % i, o);\n        }\n      case '/':\n        {\n          if (ze(r) && ze(a)) {\n            const t = r,\n              s = a;\n            if (t.length !== s.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;\n            const i = t.map((e, t) => e / s[t]);\n            return new Be(i, n.typeInfo);\n          }\n          if (ze(r)) {\n            const e = a,\n              t = r.map((t, n) => t / e);\n            return new Be(t, n.typeInfo);\n          }\n          if (ze(a)) {\n            const e = r,\n              t = a.map((t, n) => e / t);\n            return new Be(t, s.typeInfo);\n          }\n          const t = r,\n            i = a,\n            o = this._maxFormatTypeInfo([n.typeInfo, s.typeInfo]);\n          return new Ve(t / i, o);\n        }\n      case '&':\n        {\n          if (ze(r) && ze(a)) {\n            const t = r,\n              s = a;\n            if (t.length !== s.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;\n            const i = t.map((e, t) => e & s[t]);\n            return new Be(i, n.typeInfo);\n          }\n          if (ze(r)) {\n            const e = a,\n              t = r.map((t, n) => t & e);\n            return new Be(t, n.typeInfo);\n          }\n          if (ze(a)) {\n            const e = r,\n              t = a.map((t, n) => e & t);\n            return new Be(t, s.typeInfo);\n          }\n          const t = r,\n            i = a,\n            o = this._maxFormatTypeInfo([n.typeInfo, s.typeInfo]);\n          return new Ve(t & i, o);\n        }\n      case '|':\n        {\n          if (ze(r) && ze(a)) {\n            const t = r,\n              s = a;\n            if (t.length !== s.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;\n            const i = t.map((e, t) => e | s[t]);\n            return new Be(i, n.typeInfo);\n          }\n          if (ze(r)) {\n            const e = a,\n              t = r.map((t, n) => t | e);\n            return new Be(t, n.typeInfo);\n          }\n          if (ze(a)) {\n            const e = r,\n              t = a.map((t, n) => e | t);\n            return new Be(t, s.typeInfo);\n          }\n          const t = r,\n            i = a,\n            o = this._maxFormatTypeInfo([n.typeInfo, s.typeInfo]);\n          return new Ve(t | i, o);\n        }\n      case '^':\n        {\n          if (ze(r) && ze(a)) {\n            const t = r,\n              s = a;\n            if (t.length !== s.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;\n            const i = t.map((e, t) => e ^ s[t]);\n            return new Be(i, n.typeInfo);\n          }\n          if (ze(r)) {\n            const e = a,\n              t = r.map((t, n) => t ^ e);\n            return new Be(t, n.typeInfo);\n          }\n          if (ze(a)) {\n            const e = r,\n              t = a.map((t, n) => e ^ t);\n            return new Be(t, s.typeInfo);\n          }\n          const t = r,\n            i = a,\n            o = this._maxFormatTypeInfo([n.typeInfo, s.typeInfo]);\n          return new Ve(t ^ i, o);\n        }\n      case '<<':\n        {\n          if (ze(r) && ze(a)) {\n            const t = r,\n              s = a;\n            if (t.length !== s.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;\n            const i = t.map((e, t) => e << s[t]);\n            return new Be(i, n.typeInfo);\n          }\n          if (ze(r)) {\n            const e = a,\n              t = r.map((t, n) => t << e);\n            return new Be(t, n.typeInfo);\n          }\n          if (ze(a)) {\n            const e = r,\n              t = a.map((t, n) => e << t);\n            return new Be(t, s.typeInfo);\n          }\n          const t = r,\n            i = a,\n            o = this._maxFormatTypeInfo([n.typeInfo, s.typeInfo]);\n          return new Ve(t << i, o);\n        }\n      case '>>':\n        {\n          if (ze(r) && ze(a)) {\n            const t = r,\n              s = a;\n            if (t.length !== s.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;\n            const i = t.map((e, t) => e >> s[t]);\n            return new Be(i, n.typeInfo);\n          }\n          if (ze(r)) {\n            const e = a,\n              t = r.map((t, n) => t >> e);\n            return new Be(t, n.typeInfo);\n          }\n          if (ze(a)) {\n            const e = r,\n              t = a.map((t, n) => e >> t);\n            return new Be(t, s.typeInfo);\n          }\n          const t = r,\n            i = a,\n            o = this._maxFormatTypeInfo([n.typeInfo, s.typeInfo]);\n          return new Ve(t >> i, o);\n        }\n      case '>':\n        if (ze(r) && ze(a)) {\n          const t = r,\n            s = a;\n          if (t.length !== s.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;\n          const i = t.map((e, t) => e > s[t] ? 1 : 0);\n          return new Be(i, n.typeInfo);\n        }\n        if (ze(r)) {\n          const e = a,\n            t = r.map((t, n) => t > e ? 1 : 0);\n          return new Be(t, n.typeInfo);\n        }\n        if (ze(a)) {\n          const e = r,\n            t = a.map((t, n) => e > t ? 1 : 0);\n          return new Be(t, s.typeInfo);\n        }\n        return new Ve(r > a ? 1 : 0, this.getTypeInfo('bool'));\n      case '<':\n        if (ze(r) && ze(a)) {\n          const t = r,\n            s = a;\n          if (t.length !== s.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;\n          const i = t.map((e, t) => e < s[t] ? 1 : 0);\n          return new Be(i, n.typeInfo);\n        }\n        if (ze(r)) {\n          const e = a,\n            t = r.map((t, n) => t < e ? 1 : 0);\n          return new Be(t, n.typeInfo);\n        }\n        if (ze(a)) {\n          const e = r,\n            t = a.map((t, n) => e < t ? 1 : 0);\n          return new Be(t, s.typeInfo);\n        }\n        return new Ve(r < a ? 1 : 0, this.getTypeInfo('bool'));\n      case '==':\n        if (ze(r) && ze(a)) {\n          const t = r,\n            s = a;\n          if (t.length !== s.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;\n          const i = t.map((e, t) => e === s[t] ? 1 : 0);\n          return new Be(i, n.typeInfo);\n        }\n        if (ze(r)) {\n          const e = a,\n            t = r.map((t, n) => t == e ? 1 : 0);\n          return new Be(t, n.typeInfo);\n        }\n        if (ze(a)) {\n          const e = r,\n            t = a.map((t, n) => e == t ? 1 : 0);\n          return new Be(t, s.typeInfo);\n        }\n        return new Ve(r === a ? 1 : 0, this.getTypeInfo('bool'));\n      case '!=':\n        if (ze(r) && ze(a)) {\n          const t = r,\n            s = a;\n          if (t.length !== s.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;\n          const i = t.map((e, t) => e !== s[t] ? 1 : 0);\n          return new Be(i, n.typeInfo);\n        }\n        if (ze(r)) {\n          const e = a,\n            t = r.map((t, n) => t !== e ? 1 : 0);\n          return new Be(t, n.typeInfo);\n        }\n        if (ze(a)) {\n          const e = r,\n            t = a.map((t, n) => e !== t ? 1 : 0);\n          return new Be(t, s.typeInfo);\n        }\n        return new Ve(r !== a ? 1 : 0, this.getTypeInfo('bool'));\n      case '>=':\n        if (ze(r) && ze(a)) {\n          const t = r,\n            s = a;\n          if (t.length !== s.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;\n          const i = t.map((e, t) => e >= s[t] ? 1 : 0);\n          return new Be(i, n.typeInfo);\n        }\n        if (ze(r)) {\n          const e = a,\n            t = r.map((t, n) => t >= e ? 1 : 0);\n          return new Be(t, n.typeInfo);\n        }\n        if (ze(a)) {\n          const e = r,\n            t = a.map((t, n) => e >= t ? 1 : 0);\n          return new Be(t, s.typeInfo);\n        }\n        return new Ve(r >= a ? 1 : 0, this.getTypeInfo('bool'));\n      case '<=':\n        if (ze(r) && ze(a)) {\n          const t = r,\n            s = a;\n          if (t.length !== s.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;\n          const i = t.map((e, t) => e <= s[t] ? 1 : 0);\n          return new Be(i, n.typeInfo);\n        }\n        if (ze(r)) {\n          const e = a,\n            t = r.map((t, n) => t <= e ? 1 : 0);\n          return new Be(t, n.typeInfo);\n        }\n        if (ze(a)) {\n          const e = r,\n            t = a.map((t, n) => e <= t ? 1 : 0);\n          return new Be(t, s.typeInfo);\n        }\n        return new Ve(r <= a ? 1 : 0, this.getTypeInfo('bool'));\n      case '&&':\n        if (ze(r) && ze(a)) {\n          const t = r,\n            s = a;\n          if (t.length !== s.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;\n          const i = t.map((e, t) => e && s[t] ? 1 : 0);\n          return new Be(i, n.typeInfo);\n        }\n        if (ze(r)) {\n          const e = a,\n            t = r.map((t, n) => t && e ? 1 : 0);\n          return new Be(t, n.typeInfo);\n        }\n        if (ze(a)) {\n          const e = r,\n            t = a.map((t, n) => e && t ? 1 : 0);\n          return new Be(t, s.typeInfo);\n        }\n        return new Ve(r && a ? 1 : 0, this.getTypeInfo('bool'));\n      case '||':\n        if (ze(r) && ze(a)) {\n          const t = r,\n            s = a;\n          if (t.length !== s.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;\n          const i = t.map((e, t) => e || s[t] ? 1 : 0);\n          return new Be(i, n.typeInfo);\n        }\n        if (ze(r)) {\n          const e = a,\n            t = r.map((t, n) => t || e ? 1 : 0);\n          return new Be(t, n.typeInfo);\n        }\n        if (ze(a)) {\n          const e = r,\n            t = a.map((t, n) => e || t ? 1 : 0);\n          return new Be(t, s.typeInfo);\n        }\n        return new Ve(r || a ? 1 : 0, this.getTypeInfo('bool'));\n    }\n    return console.error(`Unknown operator ${e.operator}. Line ${e.line}`), null;\n  }\n  _evalCall(e, t) {\n    if (null !== e.cachedReturnValue) return e.cachedReturnValue;\n    const n = t.clone();\n    n.currentFunctionName = e.name;\n    const s = t.getFunction(e.name);\n    if (!s) {\n      if (e.isBuiltin) return this._callBuiltinFunction(e, n);\n      return this.getTypeInfo(e.name) ? this._evalCreate(e, t) : (console.error(`Unknown function \"${e.name}\". Line ${e.line}`), null);\n    }\n    for (let t = 0; t < s.node.args.length; ++t) {\n      const r = s.node.args[t],\n        a = this.evalExpression(e.args[t], n);\n      n.createVariable(r.name, a, r);\n    }\n    return this._execStatements(s.node.body, n);\n  }\n  _callBuiltinFunction(e, t) {\n    switch (e.name) {\n      case 'all':\n        return this.builtins.All(e, t);\n      case 'any':\n        return this.builtins.Any(e, t);\n      case 'select':\n        return this.builtins.Select(e, t);\n      case 'arrayLength':\n        return this.builtins.ArrayLength(e, t);\n      case 'abs':\n        return this.builtins.Abs(e, t);\n      case 'acos':\n        return this.builtins.Acos(e, t);\n      case 'acosh':\n        return this.builtins.Acosh(e, t);\n      case 'asin':\n        return this.builtins.Asin(e, t);\n      case 'asinh':\n        return this.builtins.Asinh(e, t);\n      case 'atan':\n        return this.builtins.Atan(e, t);\n      case 'atanh':\n        return this.builtins.Atanh(e, t);\n      case 'atan2':\n        return this.builtins.Atan2(e, t);\n      case 'ceil':\n        return this.builtins.Ceil(e, t);\n      case 'clamp':\n        return this.builtins.Clamp(e, t);\n      case 'cos':\n        return this.builtins.Cos(e, t);\n      case 'cosh':\n        return this.builtins.Cosh(e, t);\n      case 'countLeadingZeros':\n        return this.builtins.CountLeadingZeros(e, t);\n      case 'countOneBits':\n        return this.builtins.CountOneBits(e, t);\n      case 'countTrailingZeros':\n        return this.builtins.CountTrailingZeros(e, t);\n      case 'cross':\n        return this.builtins.Cross(e, t);\n      case 'degrees':\n        return this.builtins.Degrees(e, t);\n      case 'determinant':\n        return this.builtins.Determinant(e, t);\n      case 'distance':\n        return this.builtins.Distance(e, t);\n      case 'dot':\n        return this.builtins.Dot(e, t);\n      case 'dot4U8Packed':\n        return this.builtins.Dot4U8Packed(e, t);\n      case 'dot4I8Packed':\n        return this.builtins.Dot4I8Packed(e, t);\n      case 'exp':\n        return this.builtins.Exp(e, t);\n      case 'exp2':\n        return this.builtins.Exp2(e, t);\n      case 'extractBits':\n        return this.builtins.ExtractBits(e, t);\n      case 'faceForward':\n        return this.builtins.FaceForward(e, t);\n      case 'firstLeadingBit':\n        return this.builtins.FirstLeadingBit(e, t);\n      case 'firstTrailingBit':\n        return this.builtins.FirstTrailingBit(e, t);\n      case 'floor':\n        return this.builtins.Floor(e, t);\n      case 'fma':\n        return this.builtins.Fma(e, t);\n      case 'fract':\n        return this.builtins.Fract(e, t);\n      case 'frexp':\n        return this.builtins.Frexp(e, t);\n      case 'insertBits':\n        return this.builtins.InsertBits(e, t);\n      case 'inverseSqrt':\n        return this.builtins.InverseSqrt(e, t);\n      case 'ldexp':\n        return this.builtins.Ldexp(e, t);\n      case 'length':\n        return this.builtins.Length(e, t);\n      case 'log':\n        return this.builtins.Log(e, t);\n      case 'log2':\n        return this.builtins.Log2(e, t);\n      case 'max':\n        return this.builtins.Max(e, t);\n      case 'min':\n        return this.builtins.Min(e, t);\n      case 'mix':\n        return this.builtins.Mix(e, t);\n      case 'modf':\n        return this.builtins.Modf(e, t);\n      case 'normalize':\n        return this.builtins.Normalize(e, t);\n      case 'pow':\n        return this.builtins.Pow(e, t);\n      case 'quantizeToF16':\n        return this.builtins.QuantizeToF16(e, t);\n      case 'radians':\n        return this.builtins.Radians(e, t);\n      case 'reflect':\n        return this.builtins.Reflect(e, t);\n      case 'refract':\n        return this.builtins.Refract(e, t);\n      case 'reverseBits':\n        return this.builtins.ReverseBits(e, t);\n      case 'round':\n        return this.builtins.Round(e, t);\n      case 'saturate':\n        return this.builtins.Saturate(e, t);\n      case 'sign':\n        return this.builtins.Sign(e, t);\n      case 'sin':\n        return this.builtins.Sin(e, t);\n      case 'sinh':\n        return this.builtins.Sinh(e, t);\n      case 'smoothStep':\n        return this.builtins.SmoothStep(e, t);\n      case 'sqrt':\n        return this.builtins.Sqrt(e, t);\n      case 'step':\n        return this.builtins.Step(e, t);\n      case 'tan':\n        return this.builtins.Tan(e, t);\n      case 'tanh':\n        return this.builtins.Tanh(e, t);\n      case 'transpose':\n        return this.builtins.Transpose(e, t);\n      case 'trunc':\n        return this.builtins.Trunc(e, t);\n      case 'dpdx':\n        return this.builtins.Dpdx(e, t);\n      case 'dpdxCoarse':\n        return this.builtins.DpdxCoarse(e, t);\n      case 'dpdxFine':\n        return this.builtins.DpdxFine(e, t);\n      case 'dpdy':\n        return this.builtins.Dpdy(e, t);\n      case 'dpdyCoarse':\n        return this.builtins.DpdyCoarse(e, t);\n      case 'dpdyFine':\n        return this.builtins.DpdyFine(e, t);\n      case 'fwidth':\n        return this.builtins.Fwidth(e, t);\n      case 'fwidthCoarse':\n        return this.builtins.FwidthCoarse(e, t);\n      case 'fwidthFine':\n        return this.builtins.FwidthFine(e, t);\n      case 'textureDimensions':\n        return this.builtins.TextureDimensions(e, t);\n      case 'textureGather':\n        return this.builtins.TextureGather(e, t);\n      case 'textureGatherCompare':\n        return this.builtins.TextureGatherCompare(e, t);\n      case 'textureLoad':\n        return this.builtins.TextureLoad(e, t);\n      case 'textureNumLayers':\n        return this.builtins.TextureNumLayers(e, t);\n      case 'textureNumLevels':\n        return this.builtins.TextureNumLevels(e, t);\n      case 'textureNumSamples':\n        return this.builtins.TextureNumSamples(e, t);\n      case 'textureSample':\n        return this.builtins.TextureSample(e, t);\n      case 'textureSampleBias':\n        return this.builtins.TextureSampleBias(e, t);\n      case 'textureSampleCompare':\n        return this.builtins.TextureSampleCompare(e, t);\n      case 'textureSampleCompareLevel':\n        return this.builtins.TextureSampleCompareLevel(e, t);\n      case 'textureSampleGrad':\n        return this.builtins.TextureSampleGrad(e, t);\n      case 'textureSampleLevel':\n        return this.builtins.TextureSampleLevel(e, t);\n      case 'textureSampleBaseClampToEdge':\n        return this.builtins.TextureSampleBaseClampToEdge(e, t);\n      case 'textureStore':\n        return this.builtins.TextureStore(e, t);\n      case 'atomicLoad':\n        return this.builtins.AtomicLoad(e, t);\n      case 'atomicStore':\n        return this.builtins.AtomicStore(e, t);\n      case 'atomicAdd':\n        return this.builtins.AtomicAdd(e, t);\n      case 'atomicSub':\n        return this.builtins.AtomicSub(e, t);\n      case 'atomicMax':\n        return this.builtins.AtomicMax(e, t);\n      case 'atomicMin':\n        return this.builtins.AtomicMin(e, t);\n      case 'atomicAnd':\n        return this.builtins.AtomicAnd(e, t);\n      case 'atomicOr':\n        return this.builtins.AtomicOr(e, t);\n      case 'atomicXor':\n        return this.builtins.AtomicXor(e, t);\n      case 'atomicExchange':\n        return this.builtins.AtomicExchange(e, t);\n      case 'atomicCompareExchangeWeak':\n        return this.builtins.AtomicCompareExchangeWeak(e, t);\n      case 'pack4x8snorm':\n        return this.builtins.Pack4x8snorm(e, t);\n      case 'pack4x8unorm':\n        return this.builtins.Pack4x8unorm(e, t);\n      case 'pack4xI8':\n        return this.builtins.Pack4xI8(e, t);\n      case 'pack4xU8':\n        return this.builtins.Pack4xU8(e, t);\n      case 'pack4x8Clamp':\n        return this.builtins.Pack4x8Clamp(e, t);\n      case 'pack4xU8Clamp':\n        return this.builtins.Pack4xU8Clamp(e, t);\n      case 'pack2x16snorm':\n        return this.builtins.Pack2x16snorm(e, t);\n      case 'pack2x16unorm':\n        return this.builtins.Pack2x16unorm(e, t);\n      case 'pack2x16float':\n        return this.builtins.Pack2x16float(e, t);\n      case 'unpack4x8snorm':\n        return this.builtins.Unpack4x8snorm(e, t);\n      case 'unpack4x8unorm':\n        return this.builtins.Unpack4x8unorm(e, t);\n      case 'unpack4xI8':\n        return this.builtins.Unpack4xI8(e, t);\n      case 'unpack4xU8':\n        return this.builtins.Unpack4xU8(e, t);\n      case 'unpack2x16snorm':\n        return this.builtins.Unpack2x16snorm(e, t);\n      case 'unpack2x16unorm':\n        return this.builtins.Unpack2x16unorm(e, t);\n      case 'unpack2x16float':\n        return this.builtins.Unpack2x16float(e, t);\n      case 'storageBarrier':\n        return this.builtins.StorageBarrier(e, t);\n      case 'textureBarrier':\n        return this.builtins.TextureBarrier(e, t);\n      case 'workgroupBarrier':\n        return this.builtins.WorkgroupBarrier(e, t);\n      case 'workgroupUniformLoad':\n        return this.builtins.WorkgroupUniformLoad(e, t);\n      case 'subgroupAdd':\n        return this.builtins.SubgroupAdd(e, t);\n      case 'subgroupExclusiveAdd':\n        return this.builtins.SubgroupExclusiveAdd(e, t);\n      case 'subgroupInclusiveAdd':\n        return this.builtins.SubgroupInclusiveAdd(e, t);\n      case 'subgroupAll':\n        return this.builtins.SubgroupAll(e, t);\n      case 'subgroupAnd':\n        return this.builtins.SubgroupAnd(e, t);\n      case 'subgroupAny':\n        return this.builtins.SubgroupAny(e, t);\n      case 'subgroupBallot':\n        return this.builtins.SubgroupBallot(e, t);\n      case 'subgroupBroadcast':\n        return this.builtins.SubgroupBroadcast(e, t);\n      case 'subgroupBroadcastFirst':\n        return this.builtins.SubgroupBroadcastFirst(e, t);\n      case 'subgroupElect':\n        return this.builtins.SubgroupElect(e, t);\n      case 'subgroupMax':\n        return this.builtins.SubgroupMax(e, t);\n      case 'subgroupMin':\n        return this.builtins.SubgroupMin(e, t);\n      case 'subgroupMul':\n        return this.builtins.SubgroupMul(e, t);\n      case 'subgroupExclusiveMul':\n        return this.builtins.SubgroupExclusiveMul(e, t);\n      case 'subgroupInclusiveMul':\n        return this.builtins.SubgroupInclusiveMul(e, t);\n      case 'subgroupOr':\n        return this.builtins.SubgroupOr(e, t);\n      case 'subgroupShuffle':\n        return this.builtins.SubgroupShuffle(e, t);\n      case 'subgroupShuffleDown':\n        return this.builtins.SubgroupShuffleDown(e, t);\n      case 'subgroupShuffleUp':\n        return this.builtins.SubgroupShuffleUp(e, t);\n      case 'subgroupShuffleXor':\n        return this.builtins.SubgroupShuffleXor(e, t);\n      case 'subgroupXor':\n        return this.builtins.SubgroupXor(e, t);\n      case 'quadBroadcast':\n        return this.builtins.QuadBroadcast(e, t);\n      case 'quadSwapDiagonal':\n        return this.builtins.QuadSwapDiagonal(e, t);\n      case 'quadSwapX':\n        return this.builtins.QuadSwapX(e, t);\n      case 'quadSwapY':\n        return this.builtins.QuadSwapY(e, t);\n    }\n    const n = t.getFunction(e.name);\n    if (n) {\n      const s = t.clone();\n      for (let t = 0; t < n.node.args.length; ++t) {\n        const r = n.node.args[t],\n          a = this.evalExpression(e.args[t], s);\n        s.setVariable(r.name, a, r);\n      }\n      return this._execStatements(n.node.body, s);\n    }\n    return null;\n  }\n  _callConstructorValue(e, t) {\n    if (!e.args || 0 === e.args.length) return new Ve(0, this.getTypeInfo(e.type));\n    const n = this.evalExpression(e.args[0], t);\n    return n.typeInfo = this.getTypeInfo(e.type), n.getSubData(this, e.postfix, t).clone();\n  }\n  _callConstructorVec(e, t) {\n    const n = this.getTypeInfo(e.type),\n      s = e.type.getTypeName(),\n      r = ct[s];\n    if (void 0 === r) return console.error(`Invalid vec constructor ${s}. Line ${e.line}`), null;\n    const a = [];\n    if (e instanceof _e) {\n      if (e.isVector) {\n        const t = e.vectorValue;\n        for (const e of t) a.push(e);\n      } else a.push(e.scalarValue);\n    } else if (e.args) for (const n of e.args) {\n      const e = this.evalExpression(n, t);\n      if (e instanceof Be) {\n        const t = e.data;\n        for (let e = 0; e < t.length; ++e) {\n          let n = t[e];\n          a.push(n);\n        }\n      } else if (e instanceof Ve) {\n        let t = e.value;\n        a.push(t);\n      }\n    }\n    if (e.type instanceof ie && null === e.type.format && (e.type.format = ie.f32), 0 === a.length) {\n      const s = new Array(r).fill(0);\n      return new Be(s, n).getSubData(this, e.postfix, t);\n    }\n    if (1 === a.length) for (; a.length < r;) a.push(a[0]);\n    if (a.length < r) return console.error(`Invalid vec constructor. Line ${e.line}`), null;\n    return new Be(a.length > r ? a.slice(0, r) : a, n).getSubData(this, e.postfix, t);\n  }\n  _callConstructorMatrix(e, t) {\n    const n = this.getTypeInfo(e.type),\n      s = e.type.getTypeName(),\n      a = ut[s];\n    if (void 0 === a) return console.error(`Invalid matrix constructor ${s}. Line ${e.line}`), null;\n    const i = [];\n    if (e instanceof _e) {\n      if (e.isVector) {\n        const t = e.vectorValue;\n        for (const e of t) i.push(e);\n      } else i.push(e.scalarValue);\n    } else if (e.args) for (const n of e.args) {\n      const e = this.evalExpression(n, t);\n      e instanceof Be ? i.push(...e.data) : e instanceof Ve ? i.push(e.value) : e instanceof Fe && i.push(...e.data);\n    }\n    if (n instanceof r && null === n.format && (n.format = this.getTypeInfo('f32')), 0 === i.length) {\n      const s = new Array(a[2]).fill(0);\n      return new Fe(s, n).getSubData(this, e.postfix, t);\n    }\n    return i.length !== a[2] ? (console.error(`Invalid matrix constructor. Line ${e.line}`), null) : new Fe(i, n).getSubData(this, e.postfix, t);\n  }\n}\nht._breakObj = new Ce(new e('BREAK', null), null), ht._continueObj = new Ce(new e('CONTINUE', null), null), ht._priority = new Map([['f32', 0], ['f16', 1], ['u32', 2], ['i32', 3], ['x32', 3]]);\nclass ft {\n  constructor() {\n    this.constants = new Map(), this.aliases = new Map(), this.structs = new Map();\n  }\n}\nclass pt {\n  constructor() {\n    this._tokens = [], this._current = 0, this._currentLine = 1, this._deferArrayCountEval = [], this._currentLoop = [], this._context = new ft(), this._exec = new ht(), this._forwardTypeCount = 0;\n  }\n  parse(e) {\n    this._initialize(e), this._deferArrayCountEval.length = 0;\n    const t = [];\n    for (; !this._isAtEnd();) {\n      const e = this._global_decl_or_directive();\n      if (!e) break;\n      t.push(e);\n    }\n    if (this._deferArrayCountEval.length > 0) {\n      for (const e of this._deferArrayCountEval) {\n        const t = e.arrayType,\n          n = e.countNode;\n        if (n instanceof de) {\n          const e = n.name,\n            s = this._context.constants.get(e);\n          if (s) try {\n            const e = s.constEvaluate(this._exec);\n            t.count = e;\n          } catch (e) {}\n        }\n      }\n      this._deferArrayCountEval.length = 0;\n    }\n    if (this._forwardTypeCount > 0) for (const e of t) e.search(e => {\n      e instanceof $e || e instanceof oe ? e.type = this._forwardType(e.type) : e instanceof le ? e.format = this._forwardType(e.format) : e instanceof O || e instanceof F || e instanceof M ? e.type = this._forwardType(e.type) : e instanceof L ? e.returnType = this._forwardType(e.returnType) : e instanceof Ae && (e.type = this._forwardType(e.type));\n    });\n    return t;\n  }\n  _forwardType(e) {\n    if (e instanceof re) {\n      const t = this._getType(e.name);\n      if (t) return t;\n    } else e instanceof oe ? e.type = this._forwardType(e.type) : e instanceof le && (e.format = this._forwardType(e.format));\n    return e;\n  }\n  _initialize(e) {\n    if (e) {\n      if ('string' == typeof e) {\n        const t = new He(e);\n        this._tokens = t.scanTokens();\n      } else this._tokens = e;\n    } else this._tokens = [];\n    this._current = 0;\n  }\n  _updateNode(e, t) {\n    return e.line = null != t ? t : this._currentLine, e;\n  }\n  _error(e, t) {\n    return {\n      token: e,\n      message: t,\n      toString: () => `${t}`\n    };\n  }\n  _isAtEnd() {\n    return this._current >= this._tokens.length || this._peek().type == We.eof;\n  }\n  _match(e) {\n    if (e instanceof Pe) return !!this._check(e) && (this._advance(), !0);\n    for (let t = 0, n = e.length; t < n; ++t) {\n      const n = e[t];\n      if (this._check(n)) return this._advance(), !0;\n    }\n    return !1;\n  }\n  _consume(e, t) {\n    if (this._check(e)) return this._advance();\n    throw this._error(this._peek(), `${t}. Line:${this._currentLine}`);\n  }\n  _check(e) {\n    if (this._isAtEnd()) return !1;\n    const t = this._peek();\n    if (e instanceof Array) {\n      const n = t.type;\n      let s = !1;\n      for (const t of e) {\n        if (n === t) return !0;\n        t === We.tokens.name && (s = !0);\n      }\n      if (s) {\n        const e = We.tokens.name.rule.exec(t.lexeme);\n        if (e && 0 == e.index && e[0] == t.lexeme) return !0;\n      }\n      return !1;\n    }\n    if (t.type === e) return !0;\n    if (e === We.tokens.name) {\n      const e = We.tokens.name.rule.exec(t.lexeme);\n      return e && 0 == e.index && e[0] == t.lexeme;\n    }\n    return !1;\n  }\n  _advance() {\n    var e, t;\n    return this._currentLine = null !== (t = null === (e = this._peek()) || void 0 === e ? void 0 : e.line) && void 0 !== t ? t : -1, this._isAtEnd() || this._current++, this._previous();\n  }\n  _peek() {\n    return this._tokens[this._current];\n  }\n  _previous() {\n    return this._tokens[this._current - 1];\n  }\n  _global_decl_or_directive() {\n    for (; this._match(We.tokens.semicolon) && !this._isAtEnd(););\n    if (this._match(We.keywords.alias)) {\n      const e = this._type_alias();\n      return this._consume(We.tokens.semicolon, 'Expected \\';\\''), this._exec.reflection.updateAST([e]), e;\n    }\n    if (this._match(We.keywords.diagnostic)) {\n      const e = this._diagnostic();\n      return this._consume(We.tokens.semicolon, 'Expected \\';\\''), this._exec.reflection.updateAST([e]), e;\n    }\n    if (this._match(We.keywords.requires)) {\n      const e = this._requires_directive();\n      return this._consume(We.tokens.semicolon, 'Expected \\';\\''), this._exec.reflection.updateAST([e]), e;\n    }\n    if (this._match(We.keywords.enable)) {\n      const e = this._enable_directive();\n      return this._consume(We.tokens.semicolon, 'Expected \\';\\''), this._exec.reflection.updateAST([e]), e;\n    }\n    const e = this._attribute();\n    if (this._check(We.keywords.var)) {\n      const t = this._global_variable_decl();\n      return null != t && (t.attributes = e), this._consume(We.tokens.semicolon, 'Expected \\';\\'.'), this._exec.reflection.updateAST([t]), t;\n    }\n    if (this._check(We.keywords.override)) {\n      const t = this._override_variable_decl();\n      return null != t && (t.attributes = e), this._consume(We.tokens.semicolon, 'Expected \\';\\'.'), this._exec.reflection.updateAST([t]), t;\n    }\n    if (this._check(We.keywords.let)) {\n      const t = this._global_let_decl();\n      return null != t && (t.attributes = e), this._consume(We.tokens.semicolon, 'Expected \\';\\'.'), this._exec.reflection.updateAST([t]), t;\n    }\n    if (this._check(We.keywords.const)) {\n      const t = this._global_const_decl();\n      return null != t && (t.attributes = e), this._consume(We.tokens.semicolon, 'Expected \\';\\'.'), this._exec.reflection.updateAST([t]), t;\n    }\n    if (this._check(We.keywords.struct)) {\n      const t = this._struct_decl();\n      return null != t && (t.attributes = e), this._exec.reflection.updateAST([t]), t;\n    }\n    if (this._check(We.keywords.fn)) {\n      const t = this._function_decl();\n      return null != t && (t.attributes = e), this._exec.reflection.updateAST([t]), t;\n    }\n    return null;\n  }\n  _function_decl() {\n    if (!this._match(We.keywords.fn)) return null;\n    const e = this._currentLine,\n      t = this._consume(We.tokens.ident, 'Expected function name.').toString();\n    this._consume(We.tokens.paren_left, 'Expected \\'(\\' for function arguments.');\n    const n = [];\n    if (!this._check(We.tokens.paren_right)) do {\n      if (this._check(We.tokens.paren_right)) break;\n      const e = this._attribute(),\n        t = this._consume(We.tokens.name, 'Expected argument name.').toString();\n      this._consume(We.tokens.colon, 'Expected \\':\\' for argument type.');\n      const s = this._attribute(),\n        r = this._type_decl();\n      null != r && (r.attributes = s, n.push(this._updateNode(new Ae(t, r, e))));\n    } while (this._match(We.tokens.comma));\n    this._consume(We.tokens.paren_right, 'Expected \\')\\' after function arguments.');\n    let s = null;\n    if (this._match(We.tokens.arrow)) {\n      const e = this._attribute();\n      s = this._type_decl(), null != s && (s.attributes = e);\n    }\n    const r = this._compound_statement(),\n      a = this._currentLine;\n    return this._updateNode(new L(t, n, s, r, e, a), e);\n  }\n  _compound_statement() {\n    const e = [];\n    for (this._consume(We.tokens.brace_left, 'Expected \\'{\\' for block.'); !this._check(We.tokens.brace_right);) {\n      const t = this._statement();\n      null !== t && e.push(t);\n    }\n    return this._consume(We.tokens.brace_right, 'Expected \\'}\\' for block.'), e;\n  }\n  _statement() {\n    for (; this._match(We.tokens.semicolon) && !this._isAtEnd(););\n    if (this._check(We.tokens.attr) && this._attribute(), this._check(We.keywords.if)) return this._if_statement();\n    if (this._check(We.keywords.switch)) return this._switch_statement();\n    if (this._check(We.keywords.loop)) return this._loop_statement();\n    if (this._check(We.keywords.for)) return this._for_statement();\n    if (this._check(We.keywords.while)) return this._while_statement();\n    if (this._check(We.keywords.continuing)) return this._continuing_statement();\n    if (this._check(We.keywords.static_assert)) return this._static_assert_statement();\n    if (this._check(We.tokens.brace_left)) return this._compound_statement();\n    let e = null;\n    if (this._check(We.keywords.return)) e = this._return_statement();else if (this._check([We.keywords.var, We.keywords.let, We.keywords.const])) e = this._variable_statement();else if (this._match(We.keywords.discard)) e = this._updateNode(new ee());else if (this._match(We.keywords.break)) {\n      const t = this._updateNode(new te());\n      if (this._currentLoop.length > 0) {\n        const e = this._currentLoop[this._currentLoop.length - 1];\n        t.loopId = e.id;\n      }\n      e = t, this._check(We.keywords.if) && (this._advance(), t.condition = this._optional_paren_expression());\n    } else if (this._match(We.keywords.continue)) {\n      const t = this._updateNode(new ne());\n      if (!(this._currentLoop.length > 0)) throw this._error(this._peek(), `Continue statement must be inside a loop. Line: ${t.line}`);\n      {\n        const e = this._currentLoop[this._currentLoop.length - 1];\n        t.loopId = e.id;\n      }\n      e = t;\n    } else e = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();\n    return null != e && this._consume(We.tokens.semicolon, 'Expected \\';\\' after statement.'), e;\n  }\n  _static_assert_statement() {\n    if (!this._match(We.keywords.static_assert)) return null;\n    const e = this._currentLine,\n      t = this._optional_paren_expression();\n    return this._updateNode(new C(t), e);\n  }\n  _while_statement() {\n    if (!this._match(We.keywords.while)) return null;\n    const e = this._updateNode(new D(null, null));\n    return this._currentLoop.push(e), e.condition = this._optional_paren_expression(), this._check(We.tokens.attr) && this._attribute(), e.body = this._compound_statement(), this._currentLoop.pop(), e;\n  }\n  _continuing_statement() {\n    const e = this._currentLoop.length > 0 ? this._currentLoop[this._currentLoop.length - 1].id : -1;\n    if (!this._match(We.keywords.continuing)) return null;\n    const t = this._currentLine,\n      n = this._compound_statement();\n    return this._updateNode(new N(n, e), t);\n  }\n  _for_statement() {\n    if (!this._match(We.keywords.for)) return null;\n    this._consume(We.tokens.paren_left, 'Expected \\'(\\'.');\n    const e = this._updateNode(new V(null, null, null, null));\n    return this._currentLoop.push(e), e.init = this._check(We.tokens.semicolon) ? null : this._for_init(), this._consume(We.tokens.semicolon, 'Expected \\';\\'.'), e.condition = this._check(We.tokens.semicolon) ? null : this._short_circuit_or_expression(), this._consume(We.tokens.semicolon, 'Expected \\';\\'.'), e.increment = this._check(We.tokens.paren_right) ? null : this._for_increment(), this._consume(We.tokens.paren_right, 'Expected \\')\\'.'), this._check(We.tokens.attr) && this._attribute(), e.body = this._compound_statement(), this._currentLoop.pop(), e;\n  }\n  _for_init() {\n    return this._variable_statement() || this._func_call_statement() || this._assignment_statement();\n  }\n  _for_increment() {\n    return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();\n  }\n  _variable_statement() {\n    if (this._check(We.keywords.var)) {\n      const e = this._variable_decl();\n      if (null === e) throw this._error(this._peek(), 'Variable declaration expected.');\n      let t = null;\n      return this._match(We.tokens.equal) && (t = this._short_circuit_or_expression()), this._updateNode(new O(e.name, e.type, e.storage, e.access, t), e.line);\n    }\n    if (this._match(We.keywords.let)) {\n      const e = this._currentLine,\n        t = this._consume(We.tokens.name, 'Expected name for let.').toString();\n      let n = null;\n      if (this._match(We.tokens.colon)) {\n        const e = this._attribute();\n        n = this._type_decl(), null != n && (n.attributes = e);\n      }\n      this._consume(We.tokens.equal, 'Expected \\'=\\' for let.');\n      const s = this._short_circuit_or_expression();\n      return this._updateNode(new F(t, n, null, null, s), e);\n    }\n    if (this._match(We.keywords.const)) {\n      const e = this._currentLine,\n        t = this._consume(We.tokens.name, 'Expected name for const.').toString();\n      let n = null;\n      if (this._match(We.tokens.colon)) {\n        const e = this._attribute();\n        n = this._type_decl(), null != n && (n.attributes = e);\n      }\n      this._consume(We.tokens.equal, 'Expected \\'=\\' for const.');\n      const s = this._short_circuit_or_expression();\n      return null === n && s instanceof _e && (n = s.type), this._updateNode(new M(t, n, null, null, s), e);\n    }\n    return null;\n  }\n  _increment_decrement_statement() {\n    const e = this._current,\n      t = this._unary_expression();\n    if (null == t) return null;\n    if (!this._check(We.increment_operators)) return this._current = e, null;\n    const n = this._consume(We.increment_operators, 'Expected increment operator');\n    return this._updateNode(new H(n.type === We.tokens.plus_plus ? U.increment : U.decrement, t));\n  }\n  _assignment_statement() {\n    let e = null;\n    const t = this._currentLine;\n    if (this._check(We.tokens.brace_right)) return null;\n    let n = this._match(We.tokens.underscore);\n    if (n || (e = this._unary_expression()), !n && null == e) return null;\n    const s = this._consume(We.assignment_operators, 'Expected assignment operator.'),\n      r = this._short_circuit_or_expression();\n    return this._updateNode(new z(P.parse(s.lexeme), e, r), t);\n  }\n  _func_call_statement() {\n    if (!this._check(We.tokens.ident)) return null;\n    const e = this._currentLine,\n      t = this._current,\n      n = this._consume(We.tokens.ident, 'Expected function name.'),\n      s = this._argument_expression_list();\n    return null === s ? (this._current = t, null) : this._updateNode(new R(n.lexeme, s), e);\n  }\n  _loop_statement() {\n    if (!this._match(We.keywords.loop)) return null;\n    this._check(We.tokens.attr) && this._attribute(), this._consume(We.tokens.brace_left, 'Expected \\'{\\' for loop.');\n    const e = this._updateNode(new G([], null));\n    this._currentLoop.push(e);\n    let t = this._statement();\n    for (; null !== t;) {\n      if (Array.isArray(t)) for (let n of t) e.body.push(n);else e.body.push(t);\n      if (t instanceof N) {\n        e.continuing = t;\n        break;\n      }\n      t = this._statement();\n    }\n    return this._currentLoop.pop(), this._consume(We.tokens.brace_right, 'Expected \\'}\\' for loop.'), e;\n  }\n  _switch_statement() {\n    if (!this._match(We.keywords.switch)) return null;\n    const e = this._updateNode(new X(null, []));\n    if (this._currentLoop.push(e), e.condition = this._optional_paren_expression(), this._check(We.tokens.attr) && this._attribute(), this._consume(We.tokens.brace_left, 'Expected \\'{\\' for switch.'), e.cases = this._switch_body(), null == e.cases || 0 == e.cases.length) throw this._error(this._previous(), 'Expected \\'case\\' or \\'default\\'.');\n    return this._consume(We.tokens.brace_right, 'Expected \\'}\\' for switch.'), this._currentLoop.pop(), e;\n  }\n  _switch_body() {\n    const e = [];\n    let t = !1;\n    for (; this._check([We.keywords.default, We.keywords.case]);) {\n      if (this._match(We.keywords.case)) {\n        const n = this._case_selectors();\n        for (const e of n) if (e instanceof Ie) {\n          if (t) throw this._error(this._previous(), 'Multiple default cases in switch statement.');\n          t = !0;\n          break;\n        }\n        this._match(We.tokens.colon), this._check(We.tokens.attr) && this._attribute(), this._consume(We.tokens.brace_left, 'Exected \\'{\\' for switch case.');\n        const s = this._case_body();\n        this._consume(We.tokens.brace_right, 'Exected \\'}\\' for switch case.'), e.push(this._updateNode(new Te(n, s)));\n      }\n      if (this._match(We.keywords.default)) {\n        if (t) throw this._error(this._previous(), 'Multiple default cases in switch statement.');\n        this._match(We.tokens.colon), this._check(We.tokens.attr) && this._attribute(), this._consume(We.tokens.brace_left, 'Exected \\'{\\' for switch default.');\n        const n = this._case_body();\n        this._consume(We.tokens.brace_right, 'Exected \\'}\\' for switch default.'), e.push(this._updateNode(new Se(n)));\n      }\n    }\n    return e;\n  }\n  _case_selectors() {\n    const e = [];\n    for (this._match(We.keywords.default) ? e.push(this._updateNode(new Ie())) : e.push(this._shift_expression()); this._match(We.tokens.comma);) this._match(We.keywords.default) ? e.push(this._updateNode(new Ie())) : e.push(this._shift_expression());\n    return e;\n  }\n  _case_body() {\n    if (this._match(We.keywords.fallthrough)) return this._consume(We.tokens.semicolon, 'Expected \\';\\''), [];\n    let e = this._statement();\n    if (null == e) return [];\n    e instanceof Array || (e = [e]);\n    const t = this._case_body();\n    return 0 == t.length ? e : [...e, t[0]];\n  }\n  _if_statement() {\n    if (!this._match(We.keywords.if)) return null;\n    const e = this._currentLine,\n      t = this._optional_paren_expression();\n    this._check(We.tokens.attr) && this._attribute();\n    const n = this._compound_statement();\n    let s = [];\n    this._match_elseif() && (this._check(We.tokens.attr) && this._attribute(), s = this._elseif_statement(s));\n    let r = null;\n    return this._match(We.keywords.else) && (this._check(We.tokens.attr) && this._attribute(), r = this._compound_statement()), this._updateNode(new j(t, n, s, r), e);\n  }\n  _match_elseif() {\n    return this._tokens[this._current].type === We.keywords.else && this._tokens[this._current + 1].type === We.keywords.if && (this._advance(), this._advance(), !0);\n  }\n  _elseif_statement() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    const t = this._optional_paren_expression(),\n      n = this._compound_statement();\n    return e.push(this._updateNode(new Ee(t, n))), this._match_elseif() && (this._check(We.tokens.attr) && this._attribute(), this._elseif_statement(e)), e;\n  }\n  _return_statement() {\n    if (!this._match(We.keywords.return)) return null;\n    const e = this._short_circuit_or_expression();\n    return this._updateNode(new Z(e));\n  }\n  _short_circuit_or_expression() {\n    let e = this._short_circuit_and_expr();\n    for (; this._match(We.tokens.or_or);) e = this._updateNode(new we(this._previous().toString(), e, this._short_circuit_and_expr()));\n    return e;\n  }\n  _short_circuit_and_expr() {\n    let e = this._inclusive_or_expression();\n    for (; this._match(We.tokens.and_and);) e = this._updateNode(new we(this._previous().toString(), e, this._inclusive_or_expression()));\n    return e;\n  }\n  _inclusive_or_expression() {\n    let e = this._exclusive_or_expression();\n    for (; this._match(We.tokens.or);) e = this._updateNode(new we(this._previous().toString(), e, this._exclusive_or_expression()));\n    return e;\n  }\n  _exclusive_or_expression() {\n    let e = this._and_expression();\n    for (; this._match(We.tokens.xor);) e = this._updateNode(new we(this._previous().toString(), e, this._and_expression()));\n    return e;\n  }\n  _and_expression() {\n    let e = this._equality_expression();\n    for (; this._match(We.tokens.and);) e = this._updateNode(new we(this._previous().toString(), e, this._equality_expression()));\n    return e;\n  }\n  _equality_expression() {\n    const e = this._relational_expression();\n    return this._match([We.tokens.equal_equal, We.tokens.not_equal]) ? this._updateNode(new we(this._previous().toString(), e, this._relational_expression())) : e;\n  }\n  _relational_expression() {\n    let e = this._shift_expression();\n    for (; this._match([We.tokens.less_than, We.tokens.greater_than, We.tokens.less_than_equal, We.tokens.greater_than_equal]);) e = this._updateNode(new we(this._previous().toString(), e, this._shift_expression()));\n    return e;\n  }\n  _shift_expression() {\n    let e = this._additive_expression();\n    for (; this._match([We.tokens.shift_left, We.tokens.shift_right]);) e = this._updateNode(new we(this._previous().toString(), e, this._additive_expression()));\n    return e;\n  }\n  _additive_expression() {\n    let e = this._multiplicative_expression();\n    for (; this._match([We.tokens.plus, We.tokens.minus]);) e = this._updateNode(new we(this._previous().toString(), e, this._multiplicative_expression()));\n    return e;\n  }\n  _multiplicative_expression() {\n    let e = this._unary_expression();\n    for (; this._match([We.tokens.star, We.tokens.forward_slash, We.tokens.modulo]);) e = this._updateNode(new we(this._previous().toString(), e, this._unary_expression()));\n    return e;\n  }\n  _unary_expression() {\n    return this._match([We.tokens.minus, We.tokens.bang, We.tokens.tilde, We.tokens.star, We.tokens.and]) ? this._updateNode(new ve(this._previous().toString(), this._unary_expression())) : this._singular_expression();\n  }\n  _singular_expression() {\n    const e = this._primary_expression(),\n      t = this._postfix_expression();\n    return t && (e.postfix = t), e;\n  }\n  _postfix_expression() {\n    if (this._match(We.tokens.bracket_left)) {\n      const e = this._short_circuit_or_expression();\n      this._consume(We.tokens.bracket_right, 'Expected \\']\\'.');\n      const t = this._updateNode(new ye(e)),\n        n = this._postfix_expression();\n      return n && (t.postfix = n), t;\n    }\n    if (this._match(We.tokens.period)) {\n      const e = this._consume(We.tokens.name, 'Expected member name.'),\n        t = this._postfix_expression(),\n        n = this._updateNode(new he(e.lexeme));\n      return t && (n.postfix = t), n;\n    }\n    return null;\n  }\n  _getStruct(e) {\n    if (this._context.aliases.has(e)) {\n      return this._context.aliases.get(e).type;\n    }\n    if (this._context.structs.has(e)) {\n      return this._context.structs.get(e);\n    }\n    return null;\n  }\n  _getType(e) {\n    const t = this._getStruct(e);\n    if (null !== t) return t;\n    switch (e) {\n      case 'void':\n        return se.void;\n      case 'bool':\n        return se.bool;\n      case 'i32':\n        return se.i32;\n      case 'u32':\n        return se.u32;\n      case 'f32':\n        return se.f32;\n      case 'f16':\n        return se.f16;\n      case 'vec2f':\n        return ie.vec2f;\n      case 'vec3f':\n        return ie.vec3f;\n      case 'vec4f':\n        return ie.vec4f;\n      case 'vec2i':\n        return ie.vec2i;\n      case 'vec3i':\n        return ie.vec3i;\n      case 'vec4i':\n        return ie.vec4i;\n      case 'vec2u':\n        return ie.vec2u;\n      case 'vec3u':\n        return ie.vec3u;\n      case 'vec4u':\n        return ie.vec4u;\n      case 'vec2h':\n        return ie.vec2h;\n      case 'vec3h':\n        return ie.vec3h;\n      case 'vec4h':\n        return ie.vec4h;\n      case 'mat2x2f':\n        return ie.mat2x2f;\n      case 'mat2x3f':\n        return ie.mat2x3f;\n      case 'mat2x4f':\n        return ie.mat2x4f;\n      case 'mat3x2f':\n        return ie.mat3x2f;\n      case 'mat3x3f':\n        return ie.mat3x3f;\n      case 'mat3x4f':\n        return ie.mat3x4f;\n      case 'mat4x2f':\n        return ie.mat4x2f;\n      case 'mat4x3f':\n        return ie.mat4x3f;\n      case 'mat4x4f':\n        return ie.mat4x4f;\n      case 'mat2x2h':\n        return ie.mat2x2h;\n      case 'mat2x3h':\n        return ie.mat2x3h;\n      case 'mat2x4h':\n        return ie.mat2x4h;\n      case 'mat3x2h':\n        return ie.mat3x2h;\n      case 'mat3x3h':\n        return ie.mat3x3h;\n      case 'mat3x4h':\n        return ie.mat3x4h;\n      case 'mat4x2h':\n        return ie.mat4x2h;\n      case 'mat4x3h':\n        return ie.mat4x3h;\n      case 'mat4x4h':\n        return ie.mat4x4h;\n      case 'mat2x2i':\n        return ie.mat2x2i;\n      case 'mat2x3i':\n        return ie.mat2x3i;\n      case 'mat2x4i':\n        return ie.mat2x4i;\n      case 'mat3x2i':\n        return ie.mat3x2i;\n      case 'mat3x3i':\n        return ie.mat3x3i;\n      case 'mat3x4i':\n        return ie.mat3x4i;\n      case 'mat4x2i':\n        return ie.mat4x2i;\n      case 'mat4x3i':\n        return ie.mat4x3i;\n      case 'mat4x4i':\n        return ie.mat4x4i;\n      case 'mat2x2u':\n        return ie.mat2x2u;\n      case 'mat2x3u':\n        return ie.mat2x3u;\n      case 'mat2x4u':\n        return ie.mat2x4u;\n      case 'mat3x2u':\n        return ie.mat3x2u;\n      case 'mat3x3u':\n        return ie.mat3x3u;\n      case 'mat3x4u':\n        return ie.mat3x4u;\n      case 'mat4x2u':\n        return ie.mat4x2u;\n      case 'mat4x3u':\n        return ie.mat4x3u;\n      case 'mat4x4u':\n        return ie.mat4x4u;\n    }\n    return null;\n  }\n  _validateTypeRange(e, t) {\n    if ('i32' === t.name) {\n      if (e < -2147483648 || e > 2147483647) throw this._error(this._previous(), `Value out of range for i32: ${e}. Line: ${this._currentLine}.`);\n    } else if ('u32' === t.name && (e < 0 || e > 4294967295)) throw this._error(this._previous(), `Value out of range for u32: ${e}. Line: ${this._currentLine}.`);\n  }\n  _primary_expression() {\n    if (this._match(We.tokens.ident)) {\n      const e = this._previous().toString();\n      if (this._check(We.tokens.paren_left)) {\n        const t = this._argument_expression_list(),\n          n = this._getType(e);\n        return null !== n ? this._updateNode(new fe(n, t)) : this._updateNode(new pe(e, t));\n      }\n      if (this._context.constants.has(e)) {\n        const t = this._context.constants.get(e);\n        return this._updateNode(new me(e, t.value));\n      }\n      return this._updateNode(new de(e));\n    }\n    if (this._match(We.tokens.int_literal)) {\n      const e = this._previous().toString();\n      let t = e.endsWith('i') || e.endsWith('i') ? se.i32 : e.endsWith('u') || e.endsWith('U') ? se.u32 : se.x32;\n      const n = parseInt(e);\n      return this._validateTypeRange(n, t), this._updateNode(new _e(new Ve(n, this._exec.getTypeInfo(t)), t));\n    }\n    if (this._match(We.tokens.uint_literal)) {\n      const e = parseInt(this._previous().toString());\n      return this._validateTypeRange(e, se.u32), this._updateNode(new _e(new Ve(e, this._exec.getTypeInfo(se.u32)), se.u32));\n    }\n    if (this._match([We.tokens.decimal_float_literal, We.tokens.hex_float_literal])) {\n      let e = this._previous().toString(),\n        t = e.endsWith('h');\n      t && (e = e.substring(0, e.length - 1));\n      const n = parseFloat(e);\n      this._validateTypeRange(n, t ? se.f16 : se.f32);\n      const s = t ? se.f16 : se.f32;\n      return this._updateNode(new _e(new Ve(n, this._exec.getTypeInfo(s)), s));\n    }\n    if (this._match([We.keywords.true, We.keywords.false])) {\n      let e = this._previous().toString() === We.keywords.true.rule;\n      return this._updateNode(new _e(new Ve(e ? 1 : 0, this._exec.getTypeInfo(se.bool)), se.bool));\n    }\n    if (this._check(We.tokens.paren_left)) return this._paren_expression();\n    if (this._match(We.keywords.bitcast)) {\n      this._consume(We.tokens.less_than, 'Expected \\'<\\'.');\n      const e = this._type_decl();\n      this._consume(We.tokens.greater_than, 'Expected \\'>\\'.');\n      const t = this._paren_expression();\n      return this._updateNode(new ge(e, t));\n    }\n    const e = this._type_decl(),\n      t = this._argument_expression_list();\n    return this._updateNode(new fe(e, t));\n  }\n  _argument_expression_list() {\n    if (!this._match(We.tokens.paren_left)) return null;\n    const e = [];\n    do {\n      if (this._check(We.tokens.paren_right)) break;\n      const t = this._short_circuit_or_expression();\n      e.push(t);\n    } while (this._match(We.tokens.comma));\n    return this._consume(We.tokens.paren_right, 'Expected \\')\\' for agument list'), e;\n  }\n  _optional_paren_expression() {\n    this._match(We.tokens.paren_left);\n    const e = this._short_circuit_or_expression();\n    return this._match(We.tokens.paren_right), e;\n  }\n  _paren_expression() {\n    this._consume(We.tokens.paren_left, 'Expected \\'(\\'.');\n    const e = this._short_circuit_or_expression();\n    return this._consume(We.tokens.paren_right, 'Expected \\')\\'.'), e;\n  }\n  _struct_decl() {\n    if (!this._match(We.keywords.struct)) return null;\n    const e = this._currentLine,\n      t = this._consume(We.tokens.ident, 'Expected name for struct.').toString();\n    this._consume(We.tokens.brace_left, 'Expected \\'{\\' for struct body.');\n    const n = [];\n    for (; !this._check(We.tokens.brace_right);) {\n      const e = this._attribute(),\n        t = this._consume(We.tokens.name, 'Expected variable name.').toString();\n      this._consume(We.tokens.colon, 'Expected \\':\\' for struct member type.');\n      const s = this._attribute(),\n        r = this._type_decl();\n      null != r && (r.attributes = s), this._check(We.tokens.brace_right) ? this._match(We.tokens.comma) : this._consume(We.tokens.comma, 'Expected \\',\\' for struct member.'), n.push(this._updateNode(new $e(t, r, e)));\n    }\n    this._consume(We.tokens.brace_right, 'Expected \\'}\\' after struct body.');\n    const s = this._currentLine,\n      r = this._updateNode(new ae(t, n, e, s), e);\n    return this._context.structs.set(t, r), r;\n  }\n  _global_variable_decl() {\n    const e = this._variable_decl();\n    if (!e) return null;\n    if (this._match(We.tokens.equal)) {\n      const t = this._const_expression();\n      e.value = t;\n    }\n    if (null !== e.type && e.value instanceof _e) {\n      if ('x32' !== e.value.type.name) {\n        if (e.type.getTypeName() !== e.value.type.getTypeName()) throw this._error(this._peek(), `Invalid cast from ${e.value.type.name} to ${e.type.name}. Line:${this._currentLine}`);\n      }\n      e.value.isScalar && this._validateTypeRange(e.value.scalarValue, e.type), e.value.type = e.type;\n    } else null === e.type && e.value instanceof _e && (e.type = 'x32' === e.value.type.name ? se.i32 : e.value.type, e.value.isScalar && this._validateTypeRange(e.value.scalarValue, e.type));\n    return e;\n  }\n  _override_variable_decl() {\n    const e = this._override_decl();\n    return e && this._match(We.tokens.equal) && (e.value = this._const_expression()), e;\n  }\n  _global_const_decl() {\n    var e;\n    if (!this._match(We.keywords.const)) return null;\n    const t = this._consume(We.tokens.name, 'Expected variable name'),\n      n = this._currentLine;\n    let s = null;\n    if (this._match(We.tokens.colon)) {\n      const e = this._attribute();\n      s = this._type_decl(), null != s && (s.attributes = e);\n    }\n    let a = null;\n    this._consume(We.tokens.equal, 'const declarations require an assignment');\n    const i = this._short_circuit_or_expression();\n    try {\n      let e = [se.f32],\n        n = i.constEvaluate(this._exec, e);\n      n instanceof Ve && this._validateTypeRange(n.value, e[0]), e[0] instanceof ie && null === e[0].format && n.typeInfo instanceof r && null !== n.typeInfo.format && ('f16' === n.typeInfo.format.name ? e[0].format = se.f16 : 'f32' === n.typeInfo.format.name ? e[0].format = se.f32 : 'i32' === n.typeInfo.format.name ? e[0].format = se.i32 : 'u32' === n.typeInfo.format.name ? e[0].format = se.u32 : 'bool' === n.typeInfo.format.name ? e[0].format = se.bool : console.error(`TODO: impelement template format type ${n.typeInfo.format.name}`)), a = this._updateNode(new _e(n, e[0])), this._exec.context.setVariable(t.toString(), n);\n    } catch (e) {\n      a = i;\n    }\n    if (null !== s && a instanceof _e) {\n      if ('x32' !== a.type.name) {\n        if (s.getTypeName() !== a.type.getTypeName()) throw this._error(this._peek(), `Invalid cast from ${a.type.name} to ${s.name}. Line:${this._currentLine}`);\n      }\n      a.type = s, a.isScalar && this._validateTypeRange(a.scalarValue, a.type);\n    } else null === s && a instanceof _e && (s = null !== (e = null == a ? void 0 : a.type) && void 0 !== e ? e : se.f32, s === se.x32 && (s = se.i32));\n    const o = this._updateNode(new M(t.toString(), s, '', '', a), n);\n    return this._context.constants.set(o.name, o), o;\n  }\n  _global_let_decl() {\n    if (!this._match(We.keywords.let)) return null;\n    const e = this._currentLine,\n      t = this._consume(We.tokens.name, 'Expected variable name');\n    let n = null;\n    if (this._match(We.tokens.colon)) {\n      const e = this._attribute();\n      n = this._type_decl(), null != n && (n.attributes = e);\n    }\n    let s = null;\n    if (this._match(We.tokens.equal) && (s = this._const_expression()), null !== n && s instanceof _e) {\n      if ('x32' !== s.type.name) {\n        if (n.getTypeName() !== s.type.getTypeName()) throw this._error(this._peek(), `Invalid cast from ${s.type.name} to ${n.name}. Line:${this._currentLine}`);\n      }\n      s.type = n;\n    } else null === n && s instanceof _e && (n = 'x32' === s.type.name ? se.i32 : s.type);\n    return s instanceof _e && s.isScalar && this._validateTypeRange(s.scalarValue, n), this._updateNode(new F(t.toString(), n, '', '', s), e);\n  }\n  _const_expression() {\n    return this._short_circuit_or_expression();\n  }\n  _variable_decl() {\n    if (!this._match(We.keywords.var)) return null;\n    const e = this._currentLine;\n    let t = '',\n      n = '';\n    this._match(We.tokens.less_than) && (t = this._consume(We.storage_class, 'Expected storage_class.').toString(), this._match(We.tokens.comma) && (n = this._consume(We.access_mode, 'Expected access_mode.').toString()), this._consume(We.tokens.greater_than, 'Expected \\'>\\'.'));\n    const s = this._consume(We.tokens.name, 'Expected variable name');\n    let r = null;\n    if (this._match(We.tokens.colon)) {\n      const e = this._attribute();\n      r = this._type_decl(), null != r && (r.attributes = e);\n    }\n    return this._updateNode(new O(s.toString(), r, t, n, null), e);\n  }\n  _override_decl() {\n    if (!this._match(We.keywords.override)) return null;\n    const e = this._consume(We.tokens.name, 'Expected variable name');\n    let t = null;\n    if (this._match(We.tokens.colon)) {\n      const e = this._attribute();\n      t = this._type_decl(), null != t && (t.attributes = e);\n    }\n    return this._updateNode(new B(e.toString(), t, null));\n  }\n  _diagnostic() {\n    this._consume(We.tokens.paren_left, 'Expected \\'(\\'');\n    const e = this._consume(We.tokens.ident, 'Expected severity control name.');\n    this._consume(We.tokens.comma, 'Expected \\',\\'');\n    let t = this._consume(We.tokens.ident, 'Expected diagnostic rule name.').toString();\n    if (this._match(We.tokens.period)) {\n      t += `.${this._consume(We.tokens.ident, 'Expected diagnostic message.').toString()}`;\n    }\n    return this._consume(We.tokens.paren_right, 'Expected \\')\\''), this._updateNode(new K(e.toString(), t));\n  }\n  _enable_directive() {\n    const e = this._consume(We.tokens.ident, 'identity expected.');\n    return this._updateNode(new Q(e.toString()));\n  }\n  _requires_directive() {\n    const e = [this._consume(We.tokens.ident, 'identity expected.').toString()];\n    for (; this._match(We.tokens.comma);) {\n      const t = this._consume(We.tokens.ident, 'identity expected.');\n      e.push(t.toString());\n    }\n    return this._updateNode(new Y(e));\n  }\n  _type_alias() {\n    const e = this._consume(We.tokens.ident, 'identity expected.');\n    this._consume(We.tokens.equal, 'Expected \\'=\\' for type alias.');\n    let t = this._type_decl();\n    if (null === t) throw this._error(this._peek(), 'Expected Type for Alias.');\n    this._context.aliases.has(t.name) && (t = this._context.aliases.get(t.name).type);\n    const n = this._updateNode(new J(e.toString(), t));\n    return this._context.aliases.set(n.name, n), n;\n  }\n  _type_decl() {\n    if (this._check([We.tokens.ident, ...We.texel_format, We.keywords.bool, We.keywords.f32, We.keywords.i32, We.keywords.u32])) {\n      const e = this._advance().toString();\n      if (this._context.structs.has(e)) return this._context.structs.get(e);\n      if (this._context.aliases.has(e)) return this._context.aliases.get(e).type;\n      if (!this._getType(e)) {\n        const t = this._updateNode(new re(e));\n        return this._forwardTypeCount++, t;\n      }\n      return this._updateNode(new se(e));\n    }\n    let e = this._texture_sampler_types();\n    if (e) return e;\n    if (this._check(We.template_types)) {\n      let e = this._advance().toString(),\n        t = null,\n        n = null;\n      this._match(We.tokens.less_than) && (t = this._type_decl(), n = null, this._match(We.tokens.comma) && (n = this._consume(We.access_mode, 'Expected access_mode for pointer').toString()), this._consume(We.tokens.greater_than, 'Expected \\'>\\' for type.'));\n      return this._updateNode(new ie(e, t, n));\n    }\n    if (this._match(We.keywords.ptr)) {\n      let e = this._previous().toString();\n      this._consume(We.tokens.less_than, 'Expected \\'<\\' for pointer.');\n      const t = this._consume(We.storage_class, 'Expected storage_class for pointer');\n      this._consume(We.tokens.comma, 'Expected \\',\\' for pointer.');\n      const n = this._type_decl();\n      let s = null;\n      this._match(We.tokens.comma) && (s = this._consume(We.access_mode, 'Expected access_mode for pointer').toString()), this._consume(We.tokens.greater_than, 'Expected \\'>\\' for pointer.');\n      return this._updateNode(new oe(e, t.toString(), n, s));\n    }\n    const t = this._attribute();\n    if (this._match(We.keywords.array)) {\n      let e = null,\n        n = -1;\n      const s = this._previous();\n      let r = null;\n      if (this._match(We.tokens.less_than)) {\n        e = this._type_decl(), this._context.aliases.has(e.name) && (e = this._context.aliases.get(e.name).type);\n        let t = '';\n        if (this._match(We.tokens.comma)) {\n          r = this._shift_expression();\n          try {\n            t = r.constEvaluate(this._exec).toString(), r = null;\n          } catch (e) {\n            t = '1';\n          }\n        }\n        this._consume(We.tokens.greater_than, 'Expected \\'>\\' for array.'), n = t ? parseInt(t) : 0;\n      }\n      const a = this._updateNode(new le(s.toString(), t, e, n));\n      return r && this._deferArrayCountEval.push({\n        arrayType: a,\n        countNode: r\n      }), a;\n    }\n    return null;\n  }\n  _texture_sampler_types() {\n    if (this._match(We.sampler_type)) return this._updateNode(new ce(this._previous().toString(), null, null));\n    if (this._match(We.depth_texture_type)) return this._updateNode(new ce(this._previous().toString(), null, null));\n    if (this._match(We.sampled_texture_type) || this._match(We.multisampled_texture_type)) {\n      const e = this._previous();\n      this._consume(We.tokens.less_than, 'Expected \\'<\\' for sampler type.');\n      const t = this._type_decl();\n      return this._consume(We.tokens.greater_than, 'Expected \\'>\\' for sampler type.'), this._updateNode(new ce(e.toString(), t, null));\n    }\n    if (this._match(We.storage_texture_type)) {\n      const e = this._previous();\n      this._consume(We.tokens.less_than, 'Expected \\'<\\' for sampler type.');\n      const t = this._consume(We.texel_format, 'Invalid texel format.').toString();\n      this._consume(We.tokens.comma, 'Expected \\',\\' after texel format.');\n      const n = this._consume(We.access_mode, 'Expected access mode for storage texture type.').toString();\n      return this._consume(We.tokens.greater_than, 'Expected \\'>\\' for sampler type.'), this._updateNode(new ce(e.toString(), t, n));\n    }\n    return null;\n  }\n  _attribute() {\n    let e = [];\n    for (; this._match(We.tokens.attr);) {\n      const t = this._consume(We.attribute_name, 'Expected attribute name'),\n        n = this._updateNode(new Le(t.toString(), null));\n      if (this._match(We.tokens.paren_left)) {\n        if (n.value = this._consume(We.literal_or_ident, 'Expected attribute value').toString(), this._check(We.tokens.comma)) {\n          this._advance();\n          do {\n            const e = this._consume(We.literal_or_ident, 'Expected attribute value').toString();\n            n.value instanceof Array || (n.value = [n.value]), n.value.push(e);\n          } while (this._match(We.tokens.comma));\n        }\n        this._consume(We.tokens.paren_right, 'Expected \\')\\'');\n      }\n      e.push(n);\n    }\n    return 0 == e.length ? null : e;\n  }\n}\nclass dt extends st {\n  constructor(e) {\n    super(), e && this.update(e);\n  }\n  update(e) {\n    const t = new pt().parse(e);\n    this.updateAST(t);\n  }\n}\nclass mt {\n  get line() {\n    return -1;\n  }\n}\nclass _t extends mt {\n  constructor(e) {\n    super(), this.node = e;\n  }\n  get line() {\n    return this.node.line;\n  }\n}\nclass gt extends mt {\n  constructor(e, t) {\n    super(), this.node = e, this.statement = t;\n  }\n  get line() {\n    return this.statement.line;\n  }\n}\nclass xt extends mt {\n  constructor(e) {\n    super(), this.id = e;\n  }\n}\nclass yt extends mt {\n  constructor(e) {\n    super(), this.id = e;\n  }\n}\nclass bt extends mt {\n  constructor(e, t) {\n    super(), this.id = e, this.node = t;\n  }\n  get line() {\n    return this.node.line;\n  }\n}\nclass vt extends mt {\n  constructor(e, t, n) {\n    super(), this.id = e, this.condition = t, this.node = n;\n  }\n  get line() {\n    return this.node.line;\n  }\n}\nclass wt extends mt {\n  constructor(e, t, n) {\n    super(), this.lineNo = -1, this.condition = e, this.position = t, this.lineNo = n;\n  }\n  get line() {\n    var e, t;\n    return null !== (t = null === (e = this.condition) || void 0 === e ? void 0 : e.line) && void 0 !== t ? t : this.lineNo;\n  }\n}\nclass kt extends mt {\n  constructor(e) {\n    super(), this.statements = [], this.statements = e;\n  }\n  get line() {\n    return this.statements.length > 0 ? this.statements[0].line : -1;\n  }\n}\nclass It {\n  constructor(e, t) {\n    this.parent = null, this.commands = [], this.current = 0, this.parentCallExpr = null, this.context = e, this.parent = null != t ? t : null;\n  }\n  get isAtEnd() {\n    return this.current >= this.commands.length;\n  }\n  getNextCommand() {\n    if (this.current >= this.commands.length) return null;\n    const e = this.commands[this.current];\n    return this.current++, e;\n  }\n  getCurrentCommand() {\n    return this.current >= this.commands.length ? null : this.commands[this.current];\n  }\n}\nclass Tt {\n  constructor() {\n    this.states = [];\n  }\n  get isEmpty() {\n    return 0 == this.states.length;\n  }\n  get last() {\n    var e;\n    return null !== (e = this.states[this.states.length - 1]) && void 0 !== e ? e : null;\n  }\n  pop() {\n    this.states.pop();\n  }\n}\nclass St {\n  constructor(e, t) {\n    this._runTimer = null, this.breakpoints = new Set(), this.runStateCallback = null, this._code = e;\n    const n = new pt().parse(e);\n    this._exec = new ht(n), this.runStateCallback = null != t ? t : null;\n  }\n  getVariableValue(e) {\n    var t, n;\n    const s = null !== (n = null === (t = this.context.getVariable(e)) || void 0 === t ? void 0 : t.value) && void 0 !== n ? n : null;\n    return null === s ? null : s instanceof Ve ? s.value : s instanceof Be || s instanceof Fe ? Array.from(s.data) : (console.error(`Unsupported return variable type ${s.typeInfo.name}`), null);\n  }\n  reset() {\n    this._exec = new ht(this._exec.ast), this.startDebug();\n  }\n  startDebug() {\n    this._execStack = new Tt();\n    const e = this._createState(this._exec.ast, this._exec.context);\n    this._execStack.states.push(e);\n  }\n  get context() {\n    const e = this.currentState;\n    return null === e ? this._exec.context : e.context;\n  }\n  get currentState() {\n    for (;;) {\n      if (this._execStack.isEmpty) return null;\n      let e = this._execStack.last;\n      if (null === e) return null;\n      if (e.isAtEnd) {\n        if (this._execStack.pop(), this._execStack.isEmpty) return null;\n        e = this._execStack.last;\n      }\n      return e;\n    }\n  }\n  get currentCommand() {\n    for (;;) {\n      if (this._execStack.isEmpty) return null;\n      let e = this._execStack.last;\n      if (null === e) return null;\n      if (e.isAtEnd) {\n        if (this._execStack.pop(), this._execStack.isEmpty) return null;\n        e = this._execStack.last;\n      }\n      const t = e.getCurrentCommand();\n      if (null !== t) return t;\n    }\n  }\n  toggleBreakpoint(e) {\n    this.breakpoints.has(e) ? this.breakpoints.delete(e) : this.breakpoints.add(e);\n  }\n  clearBreakpoints() {\n    this.breakpoints.clear();\n  }\n  get isRunning() {\n    return null !== this._runTimer;\n  }\n  run() {\n    this.isRunning || (this._runTimer = setInterval(() => {\n      const e = this.currentCommand;\n      if (e && this.breakpoints.has(e.line)) return clearInterval(this._runTimer), this._runTimer = null, void (null !== this.runStateCallback && this.runStateCallback());\n      this.stepNext(!0) || (clearInterval(this._runTimer), this._runTimer = null, null !== this.runStateCallback && this.runStateCallback());\n    }, 0), null !== this.runStateCallback && this.runStateCallback());\n  }\n  pause() {\n    null !== this._runTimer && (clearInterval(this._runTimer), this._runTimer = null, null !== this.runStateCallback && this.runStateCallback());\n  }\n  _setOverrides(e, t) {\n    for (const n in e) {\n      const s = e[n],\n        r = this._exec.reflection.getOverrideInfo(n);\n      null !== r ? (null === r.type && (r.type = this._exec.getTypeInfo('u32')), 'u32' === r.type.name || 'i32' === r.type.name || 'f32' === r.type.name || 'f16' === r.type.name ? t.setVariable(n, new Ve(s, r.type)) : 'bool' === r.type.name ? t.setVariable(n, new Ve(s ? 1 : 0, r.type)) : 'vec2' === r.type.name || 'vec3' === r.type.name || 'vec4' === r.type.name || 'vec2f' === r.type.name || 'vec3f' === r.type.name || 'vec4f' === r.type.name || 'vec2i' === r.type.name || 'vec3i' === r.type.name || 'vec4i' === r.type.name || 'vec2u' === r.type.name || 'vec3u' === r.type.name || 'vec4u' === r.type.name || 'vec2h' === r.type.name || 'vec3h' === r.type.name || 'vec4h' === r.type.name ? t.setVariable(n, new Be(s, r.type)) : console.error(`Invalid constant type for ${n}`)) : console.error(`Override ${n} does not exist in the shader.`);\n    }\n  }\n  debugWorkgroup(e, t, n, s, r) {\n    this._execStack = new Tt();\n    const a = this._exec.context;\n    a.currentFunctionName = e, this._dispatchId = t, (r = null != r ? r : {}).constants && this._setOverrides(r.constants, a), this._exec._execStatements(this._exec.ast, a);\n    const i = a.getFunction(e);\n    if (!i) return console.error(`Function ${e} not found`), !1;\n    if ('number' == typeof n) n = [n, 1, 1];else {\n      if (0 === n.length) return console.error('Invalid dispatch count'), !1;\n      1 === n.length ? n = [n[0], 1, 1] : 2 === n.length ? n = [n[0], n[1], 1] : n.length > 3 && (n = [n[0], n[1], n[2]]);\n    }\n    const o = n[2],\n      l = n[1],\n      c = n[0],\n      u = this._exec.typeInfo.vec3u;\n    a.setVariable('@num_workgroups', new Be(n, u));\n    for (const e in s) for (const t in s[e]) {\n      const n = s[e][t];\n      a.variables.forEach(s => {\n        var r;\n        const a = s.node;\n        if (null == a ? void 0 : a.attributes) {\n          let i = null,\n            o = null;\n          for (const e of a.attributes) 'binding' === e.name ? i = e.value : 'group' === e.name && (o = e.value);\n          if (t == i && e == o) if (void 0 !== n.texture && void 0 !== n.descriptor) {\n            const e = new Ue(n.texture, this._exec.getTypeInfo(a.type), n.descriptor, null !== (r = n.texture.view) && void 0 !== r ? r : null);\n            s.value = e;\n          } else void 0 !== n.uniform ? s.value = new Me(n.uniform, this._exec.getTypeInfo(a.type)) : s.value = new Me(n, this._exec.getTypeInfo(a.type));\n        }\n      });\n    }\n    let h = !1;\n    for (let e = 0; e < o && !h; ++e) for (let t = 0; t < l && !h; ++t) for (let n = 0; n < c && !h; ++n) if (a.setVariable('@workgroup_id', new Be([n, t, e], u)), this._dispatchWorkgroup(i, [n, t, e], a)) {\n      h = !0;\n      break;\n    }\n    return h;\n  }\n  _shouldExecuteNextCommand() {\n    const e = this.currentCommand;\n    if (null === e) return !1;\n    if (e instanceof wt) {\n      if (null === e.condition) return !0;\n    } else if (e instanceof xt || e instanceof yt) return !0;\n    return !1;\n  }\n  stepInto() {\n    this.isRunning || this.stepNext(!0);\n  }\n  stepOver() {\n    this.isRunning || this.stepNext(!1);\n  }\n  stepOut() {\n    const e = this.currentState;\n    if (null === e) return;\n    const t = e.parent;\n    this.isRunning && (clearInterval(this._runTimer), this._runTimer = null), this._runTimer = setInterval(() => {\n      const e = this.currentCommand;\n      if (e && this.breakpoints.has(e.line)) return clearInterval(this._runTimer), this._runTimer = null, void (null !== this.runStateCallback && this.runStateCallback());\n      this.stepNext(!0) || (clearInterval(this._runTimer), this._runTimer = null, null !== this.runStateCallback && this.runStateCallback());\n      this.currentState === t && (clearInterval(this._runTimer), this._runTimer = null, null !== this.runStateCallback && this.runStateCallback());\n    }, 0), null !== this.runStateCallback && this.runStateCallback();\n  }\n  stepNext() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n    if (!this._execStack) {\n      this._execStack = new Tt();\n      const e = this._createState(this._exec.ast, this._exec.context);\n      this._execStack.states.push(e);\n    }\n    for (;;) {\n      if (this._execStack.isEmpty) return !1;\n      let t = this._execStack.last;\n      if (null === t) return !1;\n      if (t.isAtEnd) {\n        if (this._execStack.pop(), this._execStack.isEmpty) return !1;\n        t = this._execStack.last;\n      }\n      const n = t.getNextCommand();\n      if (null !== n) {\n        if (e && n instanceof gt) {\n          const e = n.node,\n            s = t.context.getFunction(e.name);\n          if (!s) continue;\n          const r = this._createState(s.node.body, t.context.clone(), t);\n          for (let t = 0; t < s.node.args.length; ++t) {\n            const n = s.node.args[t],\n              a = this._exec.evalExpression(e.args[t], r.context);\n            r.context.createVariable(n.name, a, n);\n          }\n          if (r.parentCallExpr = e, this._execStack.states.push(r), r.context.currentFunctionName = s.name, this._shouldExecuteNextCommand()) continue;\n          return !0;\n        }\n        if (n instanceof _t) {\n          const s = n.node;\n          if (e && s instanceof R) {\n            const e = t.context.getFunction(s.name);\n            if (e) {\n              const n = this._createState(e.node.body, t.context.clone(), t);\n              for (let t = 0; t < e.node.args.length; ++t) {\n                const r = e.node.args[t],\n                  a = this._exec.evalExpression(s.args[t], n.context);\n                n.context.createVariable(r.name, a, r);\n              }\n              if (this._execStack.states.push(n), n.context.currentFunctionName = e.name, this._shouldExecuteNextCommand()) continue;\n              return !0;\n            }\n          }\n          const r = this._exec.execStatement(s, t.context);\n          if (null != r && !(r instanceof De)) {\n            let e = t;\n            for (; e;) {\n              if (e.parentCallExpr) {\n                e.parentCallExpr.setCachedReturnValue(r);\n                break;\n              }\n              e = e.parent;\n            }\n            if (null === e && console.error('Could not find CallExpr to store return value in'), this._shouldExecuteNextCommand()) continue;\n            return !0;\n          }\n        } else {\n          if (n instanceof xt) continue;\n          if (n instanceof yt) continue;\n          if (n instanceof bt) {\n            const e = n.id;\n            for (; !this._execStack.isEmpty;) {\n              t = this._execStack.last;\n              for (let n = t.commands.length - 1; n >= 0; --n) {\n                const s = t.commands[n];\n                if (s instanceof xt && s.id === e) return t.current = n + 1, !0;\n              }\n              this._execStack.pop();\n            }\n            return console.error('Continue statement used outside of a loop'), !1;\n          }\n          if (n instanceof vt) {\n            const e = n.id;\n            if (n.condition) {\n              const e = this._exec.evalExpression(n.condition, t.context);\n              if (!(e instanceof Ve)) return console.error('Condition must be a scalar'), !1;\n              if (!e.value) {\n                if (this._shouldExecuteNextCommand()) continue;\n                return !0;\n              }\n            }\n            for (; !this._execStack.isEmpty;) {\n              t = this._execStack.last;\n              for (let n = t.commands.length - 1; n >= 0; --n) {\n                const s = t.commands[n];\n                if (s instanceof yt && s.id === e) return t.current = n + 1, !0;\n              }\n              this._execStack.pop();\n            }\n            return console.error('Break statement used outside of a loop'), !1;\n          }\n          if (n instanceof wt) {\n            if (n.condition) {\n              const e = this._exec.evalExpression(n.condition, t.context);\n              if (!(e instanceof Ve)) return console.error('Condition must be a scalar'), !1;\n              if (e.value) {\n                if (this._shouldExecuteNextCommand()) continue;\n                return !0;\n              }\n            }\n            if (t.current = n.position, this._shouldExecuteNextCommand()) continue;\n            return !0;\n          }\n          if (n instanceof kt) {\n            const e = this._createState(n.statements, t.context.clone(), t);\n            this._execStack.states.push(e);\n            continue;\n          }\n        }\n        if (t.isAtEnd && (this._execStack.pop(), this._execStack.isEmpty)) return !1;\n        if (!this._shouldExecuteNextCommand()) return !0;\n      }\n    }\n  }\n  _dispatchWorkgroup(e, t, n) {\n    const s = [1, 1, 1];\n    for (const t of e.node.attributes) if ('workgroup_size' === t.name) if (Array.isArray(t.value)) {\n      if (t.value.length > 0) {\n        const e = n.getVariableValue(t.value[0]);\n        s[0] = e instanceof Ve ? e.value : parseInt(t.value[0]);\n      }\n      if (t.value.length > 1) {\n        const e = n.getVariableValue(t.value[1]);\n        s[1] = e instanceof Ve ? e.value : parseInt(t.value[1]);\n      }\n      if (t.value.length > 2) {\n        const e = n.getVariableValue(t.value[2]);\n        s[2] = e instanceof Ve ? e.value : parseInt(t.value[2]);\n      }\n    } else {\n      const e = n.getVariableValue(t.value);\n      e instanceof Ve ? s[0] = e.value : e instanceof Be ? (s[0] = e.data[0], s[1] = e.data.length > 1 ? e.data[1] : 1, s[2] = e.data.length > 2 ? e.data[2] : 1) : s[0] = parseInt(t.value);\n    }\n    const r = this._exec.typeInfo.vec3u,\n      a = this._exec.typeInfo.u32;\n    n.setVariable('@workgroup_size', new Be(s, r));\n    const i = s[0],\n      o = s[1],\n      l = s[2];\n    let c = !1;\n    for (let e = 0, u = 0; e < l && !c; ++e) for (let l = 0; l < o && !c; ++l) for (let o = 0; o < i && !c; ++o, ++u) {\n      const i = [o, l, e],\n        h = [o + t[0] * s[0], l + t[1] * s[1], e + t[2] * s[2]];\n      if (n.setVariable('@local_invocation_id', new Be(i, r)), n.setVariable('@global_invocation_id', new Be(h, r)), n.setVariable('@local_invocation_index', new Ve(u, a)), h[0] === this._dispatchId[0] && h[1] === this._dispatchId[1] && h[2] === this._dispatchId[2]) {\n        c = !0;\n        break;\n      }\n    }\n    return c && this._dispatchExec(e, n), c;\n  }\n  _dispatchExec(e, t) {\n    for (const n of e.node.args) for (const e of n.attributes) if ('builtin' === e.name) {\n      const s = `@${e.value}`,\n        r = t.getVariable(s);\n      null !== r && t.variables.set(n.name, r);\n    }\n    const n = this._createState(e.node.body, t);\n    this._execStack.states.push(n);\n  }\n  _createState(e, t, n) {\n    const s = new It(t, null != n ? n : null);\n    for (const t of e) if (t instanceof F || t instanceof O || t instanceof M || t instanceof z) {\n      const e = [];\n      this._collectFunctionCalls(t.value, e);\n      for (const n of e) s.commands.push(new gt(n, t));\n      s.commands.push(new _t(t));\n    } else if (t instanceof R) {\n      const e = [];\n      for (const n of t.args) this._collectFunctionCalls(n, e);\n      for (const n of e) s.commands.push(new gt(n, t));\n      s.commands.push(new _t(t));\n    } else if (t instanceof Z) {\n      const e = [];\n      this._collectFunctionCalls(t.value, e);\n      for (const n of e) s.commands.push(new gt(n, t));\n      s.commands.push(new _t(t));\n    } else if (t instanceof H) s.commands.push(new _t(t));else {\n      if (t instanceof L) {\n        const e = new at(t);\n        s.context.functions.set(t.name, e);\n        continue;\n      }\n      if (t instanceof j) {\n        const e = [];\n        this._collectFunctionCalls(t.condition, e);\n        for (const n of e) s.commands.push(new gt(n, t));\n        let n = new wt(t.condition, 0, t.line);\n        s.commands.push(n), t.body.length > 0 && s.commands.push(new kt(t.body));\n        const r = new wt(null, 0, t.line);\n        s.commands.push(r);\n        for (const e of t.elseif) {\n          n.position = s.commands.length;\n          const a = [];\n          this._collectFunctionCalls(e.condition, a);\n          for (const e of a) s.commands.push(new gt(e, t));\n          n = new wt(e.condition, 0, e.line), s.commands.push(n), e.body.length > 0 && s.commands.push(new kt(e.body)), s.commands.push(r);\n        }\n        n.position = s.commands.length, t.else && s.commands.push(new kt(t.else)), r.position = s.commands.length;\n      } else if (t instanceof X) {\n        const e = [];\n        this._collectFunctionCalls(t.condition, e);\n        for (const n of e) s.commands.push(new gt(n, t));\n        let n = null;\n        for (const e of t.cases) {\n          if (e instanceof Se) {\n            n = e;\n            break;\n          }\n          if (e instanceof Te) for (const t of e.selectors) if (t instanceof Ie) {\n            n = e;\n            break;\n          }\n        }\n        const r = [];\n        for (const e of t.cases) {\n          if (e === n) continue;\n          if (!(e instanceof Te)) continue;\n          let a = null;\n          for (const n of e.selectors) {\n            let e = new we('==', t.condition, n);\n            a && (e = new we('||', a, e)), a = e;\n          }\n          const i = new wt(a, 0, e.line);\n          s.commands.push(i), e.body.length > 0 && s.commands.push(new kt(e.body));\n          const o = new wt(null, 0, e.line);\n          r.push(o), s.commands.push(o), i.position = s.commands.length;\n        }\n        n && s.commands.push(new kt(n.body)), s.commands.push(new yt(t.id));\n        const a = s.commands.length;\n        for (let e = 0; e < r.length; ++e) r[e].position = a;\n      } else if (t instanceof D) {\n        const e = [];\n        s.commands.push(new xt(t.id)), this._collectFunctionCalls(t.condition, e);\n        for (const n of e) s.commands.push(new gt(n, t));\n        const n = new wt(t.condition, 0, t.line);\n        s.commands.push(n);\n        let r = t.line;\n        t.body.length > 0 && (s.commands.push(new kt(t.body)), r = t.body[t.body.length - 1].line), s.commands.push(new wt(t.condition, 0, r)), s.commands.push(new yt(t.id)), n.position = s.commands.length;\n      } else if (t instanceof V) {\n        t.init && s.commands.push(new _t(t.init));\n        let e = s.commands.length;\n        null === t.increment && s.commands.push(new xt(t.id));\n        let n = null;\n        if (t.condition) {\n          const e = [];\n          this._collectFunctionCalls(t.condition, e);\n          for (const n of e) s.commands.push(new gt(n, t));\n          n = new wt(t.condition, 0, t.line), s.commands.push(n);\n        }\n        let r = t.line;\n        t.body.length > 0 && (s.commands.push(new kt(t.body)), r = t.body[t.body.length - 1].line), t.increment && (s.commands.push(new xt(t.id)), s.commands.push(new _t(t.increment))), s.commands.push(new wt(null, e, r)), s.commands.push(new yt(t.id)), n.position = s.commands.length;\n      } else if (t instanceof G) {\n        let e = s.commands.length;\n        t.continuing || s.commands.push(new xt(t.id));\n        let n = t.line;\n        t.body.length > 0 && (s.commands.push(new kt(t.body)), n = t.body[t.body.length - 1].line), s.commands.push(new wt(null, e, n)), s.commands.push(new yt(t.id));\n      } else t instanceof N ? (s.commands.push(new xt(t.loopId)), s.commands.push(new kt(t.body))) : t instanceof ne ? s.commands.push(new bt(t.loopId, t)) : t instanceof te ? s.commands.push(new vt(t.loopId, t.condition, t)) : t instanceof C ? s.commands.push(new _t(t)) : t instanceof ae || console.error(`TODO: statement type ${t.constructor.name}`);\n    }\n    return s;\n  }\n  _collectFunctionCalls(e, t) {\n    if (e instanceof pe) {\n      if (e.args) for (const n of e.args) this._collectFunctionCalls(n, t);\n      e.isBuiltin || t.push(e);\n    } else if (e instanceof we) this._collectFunctionCalls(e.left, t), this._collectFunctionCalls(e.right, t);else if (e instanceof ve) this._collectFunctionCalls(e.right, t);else if (e instanceof fe) {\n      if (e.args) for (const n of e.args) this._collectFunctionCalls(n, t);\n    } else e instanceof ge ? this._collectFunctionCalls(e.value, t) : e instanceof ye ? this._collectFunctionCalls(e.index, t) : _e || console.error(`TODO: expression type ${e.constructor.name}`);\n  }\n}\nexport { J as Alias, o as AliasInfo, Ae as Argument, h as ArgumentInfo, ye as ArrayIndex, s as ArrayInfo, le as ArrayType, z as Assign, P as AssignOperator, Le as Attribute, we as BinaryOperator, ge as BitcastExpr, te as Break, R as Call, pe as CallExpr, Te as Case, M as Const, me as ConstExpr, ne as Continue, N as Continuing, fe as CreateExpr, Ce as Data, Se as Default, Ie as DefaultSelector, K as Diagnostic, ee as Discard, Ee as ElseIf, Q as Enable, p as EntryFunctions, ue as Expression, V as For, re as ForwardType, L as Function, f as FunctionInfo, j as If, H as Increment, U as IncrementOperator, l as InputInfo, F as Let, _e as LiteralExpr, G as Loop, Fe as MatrixData, $e as Member, t as MemberInfo, T as Node, be as Operator, c as OutputInfo, B as Override, u as OverrideInfo, Ne as PointerData, oe as PointerType, Y as Requires, a as ResourceType, Z as Return, ce as SamplerType, Ve as ScalarData, $ as Statement, C as StaticAssert, he as StringExpr, ae as Struct, n as StructInfo, X as Switch, ke as SwitchCase, r as TemplateInfo, ie as TemplateType, Ue as TextureData, qe as Token, q as TokenClass, Pe as TokenType, We as TokenTypes, se as Type, e as TypeInfo, xe as TypecastExpr, Me as TypedData, ve as UnaryOperator, O as Var, de as VariableExpr, i as VariableInfo, Be as VectorData, De as VoidData, St as WgslDebug, ht as WgslExec, pt as WgslParser, dt as WgslReflect, He as WgslScanner, D as While, A as _BlockEnd, S as _BlockStart };\n//# sourceMappingURL=wgsl_reflect.module.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}