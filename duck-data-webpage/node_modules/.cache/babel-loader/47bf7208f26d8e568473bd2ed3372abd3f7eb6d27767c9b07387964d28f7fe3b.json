{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport function isTable(table) {\n  const shape = typeof table === 'object' && table?.shape;\n  switch (shape) {\n    case 'array-row-table':\n    case 'object-row-table':\n      return Array.isArray(table.data);\n    case 'geojson-table':\n      return Array.isArray(table.features);\n    case 'columnar-table':\n      return table.data && typeof table.data === 'object';\n    case 'arrow-table':\n      return Boolean(table?.data?.numRows !== undefined);\n    default:\n      return false;\n  }\n}\n/**\n * Returns the length of the table (i.e. the number of rows)\n */\nexport function getTableLength(table) {\n  switch (table.shape) {\n    case 'array-row-table':\n    case 'object-row-table':\n      return table.data.length;\n    case 'geojson-table':\n      return table.features.length;\n    case 'arrow-table':\n      const arrowTable = table.data;\n      return arrowTable.numRows;\n    case 'columnar-table':\n      for (const column of Object.values(table.data)) {\n        return column.length || 0;\n      }\n      return 0;\n    default:\n      throw new Error('table');\n  }\n}\n/**\n * Returns the number of columns in the table\n * @throws Fails to deduce number of columns if the table has no schema and is empty\n */\nexport function getTableNumCols(table) {\n  if (table.schema) {\n    return table.schema.fields.length;\n  }\n  if (getTableLength(table) === 0) {\n    throw new Error('empty table');\n  }\n  switch (table.shape) {\n    case 'array-row-table':\n      return table.data[0].length;\n    case 'object-row-table':\n      return Object.keys(table.data[0]).length;\n    case 'geojson-table':\n      return Object.keys(table.features[0]).length;\n    case 'columnar-table':\n      return Object.keys(table.data).length;\n    case 'arrow-table':\n      const arrowTable = table.data;\n      return arrowTable.numCols;\n    default:\n      throw new Error('table');\n  }\n}\n/** Get a table cell value at row index and column name */\nexport function getTableCell(table, rowIndex, columnName) {\n  switch (table.shape) {\n    case 'array-row-table':\n      const columnIndex = getTableColumnIndex(table, columnName);\n      return table.data[rowIndex][columnIndex];\n    case 'object-row-table':\n      return table.data[rowIndex][columnName];\n    case 'geojson-table':\n      return table.features[rowIndex][columnName];\n    case 'columnar-table':\n      const column = table.data[columnName];\n      return column[rowIndex];\n    case 'arrow-table':\n      const arrowTable = table.data;\n      const arrowColumnIndex = arrowTable.schema.fields.findIndex(field => field.name === columnName);\n      return arrowTable.getChildAt(arrowColumnIndex)?.get(rowIndex);\n    default:\n      throw new Error('todo');\n  }\n}\n/** Get a table cell value at row index and column name */\nexport function getTableCellAt(table, rowIndex, columnIndex) {\n  switch (table.shape) {\n    case 'array-row-table':\n      return table.data[rowIndex][columnIndex];\n    case 'object-row-table':\n      const columnName1 = getTableColumnName(table, columnIndex);\n      return table.data[rowIndex][columnName1];\n    case 'geojson-table':\n      const columnName2 = getTableColumnName(table, columnIndex);\n      return table.features[rowIndex][columnName2];\n    case 'columnar-table':\n      const columnName3 = getTableColumnName(table, columnIndex);\n      const column = table.data[columnName3];\n      return column[rowIndex];\n    case 'arrow-table':\n      const arrowTable = table.data;\n      return arrowTable.getChildAt(columnIndex)?.get(rowIndex);\n    default:\n      throw new Error('todo');\n  }\n}\n/** Deduce the table row shape */\nexport function getTableRowShape(table) {\n  switch (table.shape) {\n    case 'array-row-table':\n    case 'object-row-table':\n      return table.shape;\n    case 'geojson-table':\n      // TODO - this is not correct, geojson-table is not a row table\n      return 'object-row-table';\n    case 'columnar-table':\n    default:\n      throw new Error('Not a row table');\n  }\n}\n/** Get the index of a named table column. Requires the table to have a schema */\nexport function getTableColumnIndex(table, columnName) {\n  const columnIndex = table.schema?.fields.findIndex(field => field.name === columnName);\n  if (columnIndex === undefined) {\n    throw new Error(columnName);\n  }\n  return columnIndex;\n}\n/** Get the name of a table column by index. Requires the table to have a schema */\nexport function getTableColumnName(table, columnIndex) {\n  const columnName = table.schema?.fields[columnIndex]?.name;\n  if (!columnName) {\n    throw new Error(`${columnIndex}`);\n  }\n  return columnName;\n}\n/**\n * Returns one row of the table in object format.\n * @param target Optional parameter will be used if needed to store the row. Can be reused between calls to improve performance\n * @returns an array representing the row. May be the original array in the row, a new object, or the target parameter\n */\n// eslint-disable-next-line complexity\nexport function getTableRowAsObject(table, rowIndex, target, copy) {\n  switch (table.shape) {\n    case 'object-row-table':\n      return copy ? Object.fromEntries(Object.entries(table.data[rowIndex])) : table.data[rowIndex];\n    case 'array-row-table':\n      if (table.schema) {\n        const objectRow = target || {};\n        for (let i = 0; i < table.schema.fields.length; i++) {\n          objectRow[table.schema.fields[i].name] = table.data[rowIndex][i];\n        }\n        return objectRow;\n      }\n      throw new Error('no schema');\n    case 'geojson-table':\n      if (table.schema) {\n        const objectRow = target || {};\n        // TODO - should lift properties to top level\n        for (let i = 0; i < table.schema.fields.length; i++) {\n          objectRow[table.schema.fields[i].name] = table.features[rowIndex][i];\n        }\n        return objectRow;\n      }\n      throw new Error('no schema');\n    case 'columnar-table':\n      if (table.schema) {\n        const objectRow = target || {};\n        for (let i = 0; i < table.schema.fields.length; i++) {\n          objectRow[table.schema.fields[i].name] = table.data[table.schema.fields[i].name][rowIndex];\n        }\n        return objectRow;\n      } else {\n        // eslint-disable-line no-else-return\n        const objectRow = target || {};\n        for (const [name, column] of Object.entries(table.data)) {\n          objectRow[name] = column[rowIndex];\n        }\n        return objectRow;\n      }\n    case 'arrow-table':\n      const arrowTable = table.data;\n      const objectRow = target || {};\n      const row = arrowTable.get(rowIndex);\n      const schema = arrowTable.schema;\n      for (let i = 0; i < schema.fields.length; i++) {\n        objectRow[schema.fields[i].name] = row?.[schema.fields[i].name];\n      }\n      return objectRow;\n    default:\n      throw new Error('shape');\n  }\n}\n/**\n * Returns one row of the table in array format.\n * @param target Optional parameter will be used if needed to store the row. Can be reused between calls to improve performance.\n * @returns an array representing the row. May be the original array in the row, a new object, or the target parameter\n */\n// eslint-disable-next-line complexity\nexport function getTableRowAsArray(table, rowIndex, target, copy) {\n  switch (table.shape) {\n    case 'array-row-table':\n      return copy ? Array.from(table.data[rowIndex]) : table.data[rowIndex];\n    case 'object-row-table':\n      if (table.schema) {\n        const arrayRow = target || [];\n        for (let i = 0; i < table.schema.fields.length; i++) {\n          arrayRow[i] = table.data[rowIndex][table.schema.fields[i].name];\n        }\n        return arrayRow;\n      }\n      // Warning: just slap on the values, this risks mismatches between rows\n      return Object.values(table.data[rowIndex]);\n    case 'geojson-table':\n      if (table.schema) {\n        const arrayRow = target || [];\n        // TODO - should lift properties to top level\n        for (let i = 0; i < table.schema.fields.length; i++) {\n          arrayRow[i] = table.features[rowIndex][table.schema.fields[i].name];\n        }\n        return arrayRow;\n      }\n      // Warning: just slap on the values, this risks mismatches between rows\n      return Object.values(table.features[rowIndex]);\n    case 'columnar-table':\n      if (table.schema) {\n        const arrayRow = target || [];\n        for (let i = 0; i < table.schema.fields.length; i++) {\n          arrayRow[i] = table.data[table.schema.fields[i].name][rowIndex];\n        }\n        return arrayRow;\n      } else {\n        // eslint-disable-line no-else-return\n        const arrayRow = target || [];\n        let i = 0;\n        for (const column of Object.values(table.data)) {\n          arrayRow[i] = column[rowIndex];\n          i++;\n        }\n        return arrayRow;\n      }\n    case 'arrow-table':\n      const arrowTable = table.data;\n      const arrayRow = target || [];\n      const row = arrowTable.get(rowIndex);\n      const schema = arrowTable.schema;\n      for (let i = 0; i < schema.fields.length; i++) {\n        arrayRow[i] = row?.[schema.fields[i].name];\n      }\n      return arrayRow;\n    default:\n      throw new Error('shape');\n  }\n}\n/** Convert any table into array row format */\nexport function makeArrayRowTable(table) {\n  if (table.shape === 'array-row-table') {\n    return table;\n  }\n  const length = getTableLength(table);\n  const data = new Array(length);\n  for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n    data[rowIndex] = getTableRowAsArray(table, rowIndex);\n  }\n  return {\n    shape: 'array-row-table',\n    schema: table.schema,\n    data\n  };\n}\n/** Convert any table into object row format */\nexport function makeObjectRowTable(table) {\n  if (table.shape === 'object-row-table') {\n    return table;\n  }\n  const length = getTableLength(table);\n  const data = new Array(length);\n  for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n    data[rowIndex] = getTableRowAsObject(table, rowIndex);\n  }\n  return {\n    shape: 'object-row-table',\n    schema: table.schema,\n    data\n  };\n}\n/** Convert any table into object row format */\nexport function makeColumnarTable(table) {\n  if (table.shape === 'object-row-table') {\n    return table;\n  }\n  const length = getTableLength(table);\n  const data = new Array(length);\n  for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n    data[rowIndex] = getTableRowAsObject(table, rowIndex);\n  }\n  return {\n    shape: 'object-row-table',\n    schema: table.schema,\n    data\n  };\n}\n// Row Iterators\n/**\n * Iterate over table rows\n * @param table\n * @param shape\n */\nexport function* makeRowIterator(table, shape) {\n  switch (shape) {\n    case 'array-row-table':\n      yield* makeArrayRowIterator(table);\n      break;\n    case 'object-row-table':\n      yield* makeObjectRowIterator(table);\n      break;\n    default:\n      throw new Error(`Unknown row type ${shape}`);\n  }\n}\n/**\n * Streaming processing: Iterate over table, yielding array rows\n * @param table\n * @param shape\n */\nexport function* makeArrayRowIterator(table, target = []) {\n  const length = getTableLength(table);\n  for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n    yield getTableRowAsArray(table, rowIndex, target);\n  }\n}\n/**\n * Streaming processing: Iterate over table, yielding object rows\n * @param table\n * @param shape\n */\nexport function* makeObjectRowIterator(table, target = {}) {\n  const length = getTableLength(table);\n  for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n    yield getTableRowAsObject(table, rowIndex, target);\n  }\n}","map":{"version":3,"names":["isTable","table","shape","Array","isArray","data","features","Boolean","numRows","undefined","getTableLength","length","arrowTable","column","Object","values","Error","getTableNumCols","schema","fields","keys","numCols","getTableCell","rowIndex","columnName","columnIndex","getTableColumnIndex","arrowColumnIndex","findIndex","field","name","getChildAt","get","getTableCellAt","columnName1","getTableColumnName","columnName2","columnName3","getTableRowShape","getTableRowAsObject","target","copy","fromEntries","entries","objectRow","i","row","getTableRowAsArray","from","arrayRow","makeArrayRowTable","makeObjectRowTable","makeColumnarTable","makeRowIterator","makeArrayRowIterator","makeObjectRowIterator"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/schema/dist/lib/table/simple-table/table-accessors.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport function isTable(table) {\n    const shape = typeof table === 'object' && table?.shape;\n    switch (shape) {\n        case 'array-row-table':\n        case 'object-row-table':\n            return Array.isArray(table.data);\n        case 'geojson-table':\n            return Array.isArray(table.features);\n        case 'columnar-table':\n            return table.data && typeof table.data === 'object';\n        case 'arrow-table':\n            return Boolean(table?.data?.numRows !== undefined);\n        default:\n            return false;\n    }\n}\n/**\n * Returns the length of the table (i.e. the number of rows)\n */\nexport function getTableLength(table) {\n    switch (table.shape) {\n        case 'array-row-table':\n        case 'object-row-table':\n            return table.data.length;\n        case 'geojson-table':\n            return table.features.length;\n        case 'arrow-table':\n            const arrowTable = table.data;\n            return arrowTable.numRows;\n        case 'columnar-table':\n            for (const column of Object.values(table.data)) {\n                return column.length || 0;\n            }\n            return 0;\n        default:\n            throw new Error('table');\n    }\n}\n/**\n * Returns the number of columns in the table\n * @throws Fails to deduce number of columns if the table has no schema and is empty\n */\nexport function getTableNumCols(table) {\n    if (table.schema) {\n        return table.schema.fields.length;\n    }\n    if (getTableLength(table) === 0) {\n        throw new Error('empty table');\n    }\n    switch (table.shape) {\n        case 'array-row-table':\n            return table.data[0].length;\n        case 'object-row-table':\n            return Object.keys(table.data[0]).length;\n        case 'geojson-table':\n            return Object.keys(table.features[0]).length;\n        case 'columnar-table':\n            return Object.keys(table.data).length;\n        case 'arrow-table':\n            const arrowTable = table.data;\n            return arrowTable.numCols;\n        default:\n            throw new Error('table');\n    }\n}\n/** Get a table cell value at row index and column name */\nexport function getTableCell(table, rowIndex, columnName) {\n    switch (table.shape) {\n        case 'array-row-table':\n            const columnIndex = getTableColumnIndex(table, columnName);\n            return table.data[rowIndex][columnIndex];\n        case 'object-row-table':\n            return table.data[rowIndex][columnName];\n        case 'geojson-table':\n            return table.features[rowIndex][columnName];\n        case 'columnar-table':\n            const column = table.data[columnName];\n            return column[rowIndex];\n        case 'arrow-table':\n            const arrowTable = table.data;\n            const arrowColumnIndex = arrowTable.schema.fields.findIndex((field) => field.name === columnName);\n            return arrowTable.getChildAt(arrowColumnIndex)?.get(rowIndex);\n        default:\n            throw new Error('todo');\n    }\n}\n/** Get a table cell value at row index and column name */\nexport function getTableCellAt(table, rowIndex, columnIndex) {\n    switch (table.shape) {\n        case 'array-row-table':\n            return table.data[rowIndex][columnIndex];\n        case 'object-row-table':\n            const columnName1 = getTableColumnName(table, columnIndex);\n            return table.data[rowIndex][columnName1];\n        case 'geojson-table':\n            const columnName2 = getTableColumnName(table, columnIndex);\n            return table.features[rowIndex][columnName2];\n        case 'columnar-table':\n            const columnName3 = getTableColumnName(table, columnIndex);\n            const column = table.data[columnName3];\n            return column[rowIndex];\n        case 'arrow-table':\n            const arrowTable = table.data;\n            return arrowTable.getChildAt(columnIndex)?.get(rowIndex);\n        default:\n            throw new Error('todo');\n    }\n}\n/** Deduce the table row shape */\nexport function getTableRowShape(table) {\n    switch (table.shape) {\n        case 'array-row-table':\n        case 'object-row-table':\n            return table.shape;\n        case 'geojson-table':\n            // TODO - this is not correct, geojson-table is not a row table\n            return 'object-row-table';\n        case 'columnar-table':\n        default:\n            throw new Error('Not a row table');\n    }\n}\n/** Get the index of a named table column. Requires the table to have a schema */\nexport function getTableColumnIndex(table, columnName) {\n    const columnIndex = table.schema?.fields.findIndex((field) => field.name === columnName);\n    if (columnIndex === undefined) {\n        throw new Error(columnName);\n    }\n    return columnIndex;\n}\n/** Get the name of a table column by index. Requires the table to have a schema */\nexport function getTableColumnName(table, columnIndex) {\n    const columnName = table.schema?.fields[columnIndex]?.name;\n    if (!columnName) {\n        throw new Error(`${columnIndex}`);\n    }\n    return columnName;\n}\n/**\n * Returns one row of the table in object format.\n * @param target Optional parameter will be used if needed to store the row. Can be reused between calls to improve performance\n * @returns an array representing the row. May be the original array in the row, a new object, or the target parameter\n */\n// eslint-disable-next-line complexity\nexport function getTableRowAsObject(table, rowIndex, target, copy) {\n    switch (table.shape) {\n        case 'object-row-table':\n            return copy ? Object.fromEntries(Object.entries(table.data[rowIndex])) : table.data[rowIndex];\n        case 'array-row-table':\n            if (table.schema) {\n                const objectRow = target || {};\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    objectRow[table.schema.fields[i].name] = table.data[rowIndex][i];\n                }\n                return objectRow;\n            }\n            throw new Error('no schema');\n        case 'geojson-table':\n            if (table.schema) {\n                const objectRow = target || {};\n                // TODO - should lift properties to top level\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    objectRow[table.schema.fields[i].name] = table.features[rowIndex][i];\n                }\n                return objectRow;\n            }\n            throw new Error('no schema');\n        case 'columnar-table':\n            if (table.schema) {\n                const objectRow = target || {};\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    objectRow[table.schema.fields[i].name] =\n                        table.data[table.schema.fields[i].name][rowIndex];\n                }\n                return objectRow;\n            }\n            else {\n                // eslint-disable-line no-else-return\n                const objectRow = target || {};\n                for (const [name, column] of Object.entries(table.data)) {\n                    objectRow[name] = column[rowIndex];\n                }\n                return objectRow;\n            }\n        case 'arrow-table':\n            const arrowTable = table.data;\n            const objectRow = target || {};\n            const row = arrowTable.get(rowIndex);\n            const schema = arrowTable.schema;\n            for (let i = 0; i < schema.fields.length; i++) {\n                objectRow[schema.fields[i].name] = row?.[schema.fields[i].name];\n            }\n            return objectRow;\n        default:\n            throw new Error('shape');\n    }\n}\n/**\n * Returns one row of the table in array format.\n * @param target Optional parameter will be used if needed to store the row. Can be reused between calls to improve performance.\n * @returns an array representing the row. May be the original array in the row, a new object, or the target parameter\n */\n// eslint-disable-next-line complexity\nexport function getTableRowAsArray(table, rowIndex, target, copy) {\n    switch (table.shape) {\n        case 'array-row-table':\n            return copy ? Array.from(table.data[rowIndex]) : table.data[rowIndex];\n        case 'object-row-table':\n            if (table.schema) {\n                const arrayRow = target || [];\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    arrayRow[i] = table.data[rowIndex][table.schema.fields[i].name];\n                }\n                return arrayRow;\n            }\n            // Warning: just slap on the values, this risks mismatches between rows\n            return Object.values(table.data[rowIndex]);\n        case 'geojson-table':\n            if (table.schema) {\n                const arrayRow = target || [];\n                // TODO - should lift properties to top level\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    arrayRow[i] = table.features[rowIndex][table.schema.fields[i].name];\n                }\n                return arrayRow;\n            }\n            // Warning: just slap on the values, this risks mismatches between rows\n            return Object.values(table.features[rowIndex]);\n        case 'columnar-table':\n            if (table.schema) {\n                const arrayRow = target || [];\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    arrayRow[i] = table.data[table.schema.fields[i].name][rowIndex];\n                }\n                return arrayRow;\n            }\n            else {\n                // eslint-disable-line no-else-return\n                const arrayRow = target || [];\n                let i = 0;\n                for (const column of Object.values(table.data)) {\n                    arrayRow[i] = column[rowIndex];\n                    i++;\n                }\n                return arrayRow;\n            }\n        case 'arrow-table':\n            const arrowTable = table.data;\n            const arrayRow = target || [];\n            const row = arrowTable.get(rowIndex);\n            const schema = arrowTable.schema;\n            for (let i = 0; i < schema.fields.length; i++) {\n                arrayRow[i] = row?.[schema.fields[i].name];\n            }\n            return arrayRow;\n        default:\n            throw new Error('shape');\n    }\n}\n/** Convert any table into array row format */\nexport function makeArrayRowTable(table) {\n    if (table.shape === 'array-row-table') {\n        return table;\n    }\n    const length = getTableLength(table);\n    const data = new Array(length);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        data[rowIndex] = getTableRowAsArray(table, rowIndex);\n    }\n    return {\n        shape: 'array-row-table',\n        schema: table.schema,\n        data\n    };\n}\n/** Convert any table into object row format */\nexport function makeObjectRowTable(table) {\n    if (table.shape === 'object-row-table') {\n        return table;\n    }\n    const length = getTableLength(table);\n    const data = new Array(length);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        data[rowIndex] = getTableRowAsObject(table, rowIndex);\n    }\n    return {\n        shape: 'object-row-table',\n        schema: table.schema,\n        data\n    };\n}\n/** Convert any table into object row format */\nexport function makeColumnarTable(table) {\n    if (table.shape === 'object-row-table') {\n        return table;\n    }\n    const length = getTableLength(table);\n    const data = new Array(length);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        data[rowIndex] = getTableRowAsObject(table, rowIndex);\n    }\n    return {\n        shape: 'object-row-table',\n        schema: table.schema,\n        data\n    };\n}\n// Row Iterators\n/**\n * Iterate over table rows\n * @param table\n * @param shape\n */\nexport function* makeRowIterator(table, shape) {\n    switch (shape) {\n        case 'array-row-table':\n            yield* makeArrayRowIterator(table);\n            break;\n        case 'object-row-table':\n            yield* makeObjectRowIterator(table);\n            break;\n        default:\n            throw new Error(`Unknown row type ${shape}`);\n    }\n}\n/**\n * Streaming processing: Iterate over table, yielding array rows\n * @param table\n * @param shape\n */\nexport function* makeArrayRowIterator(table, target = []) {\n    const length = getTableLength(table);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        yield getTableRowAsArray(table, rowIndex, target);\n    }\n}\n/**\n * Streaming processing: Iterate over table, yielding object rows\n * @param table\n * @param shape\n */\nexport function* makeObjectRowIterator(table, target = {}) {\n    const length = getTableLength(table);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        yield getTableRowAsObject(table, rowIndex, target);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}