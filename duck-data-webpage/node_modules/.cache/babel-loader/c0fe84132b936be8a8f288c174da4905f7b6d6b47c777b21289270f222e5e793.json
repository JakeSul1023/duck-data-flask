{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport Resource from \"./resource.js\";\nexport default class ResourceManager {\n  constructor(props) {\n    this.protocol = props.protocol || 'resource://';\n    this._context = {\n      device: props.device,\n      // @ts-expect-error\n      gl: props.device?.gl,\n      resourceManager: this\n    };\n    this._resources = {};\n    this._consumers = {};\n    this._pruneRequest = null;\n  }\n  contains(resourceId) {\n    if (resourceId.startsWith(this.protocol)) {\n      return true;\n    }\n    return resourceId in this._resources;\n  }\n  add({\n    resourceId,\n    data,\n    forceUpdate = false,\n    persistent = true\n  }) {\n    let res = this._resources[resourceId];\n    if (res) {\n      res.setData(data, forceUpdate);\n    } else {\n      res = new Resource(resourceId, data, this._context);\n      this._resources[resourceId] = res;\n    }\n    // persistent resources can only be removed by calling `remove`\n    // non-persistent resources may be released when there are no more consumers\n    res.persistent = persistent;\n  }\n  remove(resourceId) {\n    const res = this._resources[resourceId];\n    if (res) {\n      res.delete();\n      delete this._resources[resourceId];\n    }\n  }\n  unsubscribe({\n    consumerId\n  }) {\n    const consumer = this._consumers[consumerId];\n    if (consumer) {\n      for (const requestId in consumer) {\n        const request = consumer[requestId];\n        const resource = this._resources[request.resourceId];\n        if (resource) {\n          resource.unsubscribe(request);\n        }\n      }\n      delete this._consumers[consumerId];\n      this.prune();\n    }\n  }\n  subscribe({\n    resourceId,\n    onChange,\n    consumerId,\n    requestId = 'default'\n  }) {\n    const {\n      _resources: resources,\n      protocol\n    } = this;\n    if (resourceId.startsWith(protocol)) {\n      resourceId = resourceId.replace(protocol, '');\n      if (!resources[resourceId]) {\n        // Add placeholder. When this resource becomes available, the consumer will be notified.\n        this.add({\n          resourceId,\n          data: null,\n          persistent: false\n        });\n      }\n    }\n    const res = resources[resourceId];\n    this._track(consumerId, requestId, res, onChange);\n    if (res) {\n      return res.getData();\n    }\n    return undefined;\n  }\n  prune() {\n    if (!this._pruneRequest) {\n      // prune() may be called multiple times in the same animation frame.\n      // Batch multiple requests together\n      // @ts-ignore setTimeout returns NodeJS.Timeout in node\n      this._pruneRequest = setTimeout(() => this._prune(), 0);\n    }\n  }\n  finalize() {\n    for (const key in this._resources) {\n      this._resources[key].delete();\n    }\n  }\n  _track(consumerId, requestId, resource, onChange) {\n    const consumers = this._consumers;\n    const consumer = consumers[consumerId] = consumers[consumerId] || {};\n    let request = consumer[requestId];\n    const oldResource = request && request.resourceId && this._resources[request.resourceId];\n    if (oldResource) {\n      oldResource.unsubscribe(request);\n      this.prune();\n    }\n    if (resource) {\n      if (request) {\n        request.onChange = onChange;\n        request.resourceId = resource.id;\n      } else {\n        request = {\n          onChange,\n          resourceId: resource.id\n        };\n      }\n      consumer[requestId] = request;\n      resource.subscribe(request);\n    }\n  }\n  _prune() {\n    this._pruneRequest = null;\n    for (const key of Object.keys(this._resources)) {\n      const res = this._resources[key];\n      if (!res.persistent && !res.inUse()) {\n        res.delete();\n        delete this._resources[key];\n      }\n    }\n  }\n}\n//# sourceMappingURL=resource-manager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}