{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport Layer from \"./layer.js\";\nimport debug from \"../debug/index.js\";\nimport { flatten } from \"../utils/flatten.js\";\nimport { PROP_TYPES_SYMBOL } from \"../lifecycle/constants.js\";\nconst TRACE_RENDER_LAYERS = 'compositeLayer.renderLayers';\nclass CompositeLayer extends Layer {\n  /** `true` if this layer renders other layers */\n  get isComposite() {\n    return true;\n  }\n  /** `true` if the layer renders to screen */\n  get isDrawable() {\n    return false;\n  }\n  /** Returns true if all async resources are loaded */\n  get isLoaded() {\n    return super.isLoaded && this.getSubLayers().every(layer => layer.isLoaded);\n  }\n  /** Return last rendered sub layers */\n  getSubLayers() {\n    return this.internalState && this.internalState.subLayers || [];\n  }\n  // initializeState is usually not needed for composite layers\n  // Provide empty definition to disable check for missing definition\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  initializeState(context) {}\n  /** Updates selected state members and marks the composite layer to need rerender */\n  setState(updateObject) {\n    super.setState(updateObject);\n    // Trigger a layer update\n    // Although conceptually layer.draw and compositeLayer.renderLayers are equivalent,\n    // they are executed during different lifecycles.\n    // draw can be called without calling updateState (e.g. most viewport changes),\n    // while renderLayers can only be called during a recursive layer update.\n    this.setNeedsUpdate();\n  }\n  /** called to augment the info object that is bubbled up from a sublayer\n      override Layer.getPickingInfo() because decoding / setting uniform do\n      not apply to a composite layer. */\n  getPickingInfo({\n    info\n  }) {\n    const {\n      object\n    } = info;\n    const isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;\n    if (!isDataWrapped) {\n      return info;\n    }\n    // override object with picked data\n    info.object = object.__source.object;\n    info.index = object.__source.index;\n    return info;\n  }\n  /**\n   * Filters sub layers at draw time. Return true if the sub layer should be drawn.\n   */\n  filterSubLayer(context) {\n    return true;\n  }\n  /** Returns true if sub layer needs to be rendered */\n  shouldRenderSubLayer(subLayerId, data) {\n    return data && data.length;\n  }\n  /** Returns sub layer class for a specific sublayer */\n  getSubLayerClass(subLayerId, DefaultLayerClass) {\n    const {\n      _subLayerProps: overridingProps\n    } = this.props;\n    return overridingProps && overridingProps[subLayerId] && overridingProps[subLayerId].type || DefaultLayerClass;\n  }\n  /** When casting user data into another format to pass to sublayers,\n      add reference to the original object and object index */\n  getSubLayerRow(row, sourceObject, sourceObjectIndex) {\n    // @ts-ignore (TS2339) adding undefined property\n    row.__source = {\n      parent: this,\n      object: sourceObject,\n      index: sourceObjectIndex\n    };\n    return row;\n  }\n  /** Some composite layers cast user data into another format before passing to sublayers\n    We need to unwrap them before calling the accessor so that they see the original data\n    objects */\n  getSubLayerAccessor(accessor) {\n    if (typeof accessor === 'function') {\n      const objectInfo = {\n        index: -1,\n        // @ts-ignore accessing resolved data\n        data: this.props.data,\n        target: []\n      };\n      return (x, i) => {\n        if (x && x.__source) {\n          objectInfo.index = x.__source.index;\n          // @ts-ignore (TS2349) Out is never a function\n          return accessor(x.__source.object, objectInfo);\n        }\n        // @ts-ignore (TS2349) Out is never a function\n        return accessor(x, i);\n      };\n    }\n    return accessor;\n  }\n  /** Returns sub layer props for a specific sublayer */\n  // eslint-disable-next-line complexity\n  getSubLayerProps(sublayerProps = {}) {\n    const {\n      opacity,\n      pickable,\n      visible,\n      parameters,\n      getPolygonOffset,\n      highlightedObjectIndex,\n      autoHighlight,\n      highlightColor,\n      coordinateSystem,\n      coordinateOrigin,\n      wrapLongitude,\n      positionFormat,\n      modelMatrix,\n      extensions,\n      fetch,\n      operation,\n      _subLayerProps: overridingProps\n    } = this.props;\n    const newProps = {\n      id: '',\n      updateTriggers: {},\n      opacity,\n      pickable,\n      visible,\n      parameters,\n      getPolygonOffset,\n      highlightedObjectIndex,\n      autoHighlight,\n      highlightColor,\n      coordinateSystem,\n      coordinateOrigin,\n      wrapLongitude,\n      positionFormat,\n      modelMatrix,\n      extensions,\n      fetch,\n      operation\n    };\n    const overridingSublayerProps = overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];\n    const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;\n    const sublayerId = sublayerProps.id || 'sublayer';\n    if (overridingSublayerProps) {\n      const propTypes = this.props[PROP_TYPES_SYMBOL];\n      const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};\n      for (const key in overridingSublayerProps) {\n        const propType = subLayerPropTypes[key] || propTypes[key];\n        // eslint-disable-next-line\n        if (propType && propType.type === 'accessor') {\n          overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);\n        }\n      }\n    }\n    Object.assign(newProps, sublayerProps,\n    // experimental feature that allows users to override sublayer props via parent layer prop\n    overridingSublayerProps);\n    newProps.id = `${this.props.id}-${sublayerId}`;\n    newProps.updateTriggers = {\n      all: this.props.updateTriggers?.all,\n      ...sublayerProps.updateTriggers,\n      ...overridingSublayerTriggers\n    };\n    // Pass through extension props\n    // @ts-ignore (TS2532) extensions is always defined after merging with default props\n    for (const extension of extensions) {\n      const passThroughProps = extension.getSubLayerProps.call(this, extension);\n      if (passThroughProps) {\n        Object.assign(newProps, passThroughProps, {\n          updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)\n        });\n      }\n    }\n    return newProps;\n  }\n  /** Update sub layers to highlight the hovered object */\n  _updateAutoHighlight(info) {\n    for (const layer of this.getSubLayers()) {\n      layer.updateAutoHighlight(info);\n    }\n  }\n  /** Override base Layer method */\n  _getAttributeManager() {\n    return null;\n  }\n  /** (Internal) Called after an update to rerender sub layers */\n  _postUpdate(updateParams, forceUpdate) {\n    // @ts-ignore (TS2531) this method is only called internally when internalState is defined\n    let subLayers = this.internalState.subLayers;\n    const shouldUpdate = !subLayers || this.needsUpdate();\n    if (shouldUpdate) {\n      const subLayersList = this.renderLayers();\n      // Flatten the returned array, removing any null, undefined or false\n      // this allows layers to render sublayers conditionally\n      // (see CompositeLayer.renderLayers docs)\n      subLayers = flatten(subLayersList, Boolean);\n      // @ts-ignore (TS2531) this method is only called internally when internalState is defined\n      this.internalState.subLayers = subLayers;\n    }\n    debug(TRACE_RENDER_LAYERS, this, shouldUpdate, subLayers);\n    // populate reference to parent layer (this layer)\n    // NOTE: needs to be done even when reusing layers as the parent may have changed\n    for (const layer of subLayers) {\n      layer.parent = this;\n    }\n  }\n}\nCompositeLayer.layerName = 'CompositeLayer';\nexport default CompositeLayer;","map":{"version":3,"names":["Layer","debug","flatten","PROP_TYPES_SYMBOL","TRACE_RENDER_LAYERS","CompositeLayer","isComposite","isDrawable","isLoaded","getSubLayers","every","layer","internalState","subLayers","initializeState","context","setState","updateObject","setNeedsUpdate","getPickingInfo","info","object","isDataWrapped","__source","parent","id","index","filterSubLayer","shouldRenderSubLayer","subLayerId","data","length","getSubLayerClass","DefaultLayerClass","_subLayerProps","overridingProps","props","type","getSubLayerRow","row","sourceObject","sourceObjectIndex","getSubLayerAccessor","accessor","objectInfo","target","x","i","getSubLayerProps","sublayerProps","opacity","pickable","visible","parameters","getPolygonOffset","highlightedObjectIndex","autoHighlight","highlightColor","coordinateSystem","coordinateOrigin","wrapLongitude","positionFormat","modelMatrix","extensions","fetch","operation","newProps","updateTriggers","overridingSublayerProps","overridingSublayerTriggers","sublayerId","propTypes","subLayerPropTypes","_propTypes","key","propType","Object","assign","all","extension","passThroughProps","call","_updateAutoHighlight","updateAutoHighlight","_getAttributeManager","_postUpdate","updateParams","forceUpdate","shouldUpdate","needsUpdate","subLayersList","renderLayers","Boolean","layerName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\lib\\composite-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport Layer, {UpdateParameters} from './layer';\nimport debug from '../debug/index';\nimport {flatten} from '../utils/flatten';\n\nimport type AttributeManager from './attribute/attribute-manager';\nimport type {PickingInfo, GetPickingInfoParams} from './picking/pick-info';\nimport type {FilterContext} from '../passes/layers-pass';\nimport type {LayersList, LayerContext} from './layer-manager';\nimport type {CompositeLayerProps, Accessor, AccessorContext} from '../types/layer-props';\nimport {ConstructorOf} from '../types/types';\nimport {PROP_TYPES_SYMBOL} from '../lifecycle/constants';\n\nconst TRACE_RENDER_LAYERS = 'compositeLayer.renderLayers';\n\nexport default abstract class CompositeLayer<PropsT extends {} = {}> extends Layer<\n  PropsT & Required<CompositeLayerProps>\n> {\n  static layerName: string = 'CompositeLayer';\n\n  /** `true` if this layer renders other layers */\n  get isComposite(): boolean {\n    return true;\n  }\n\n  /** `true` if the layer renders to screen */\n  get isDrawable(): boolean {\n    return false;\n  }\n\n  /** Returns true if all async resources are loaded */\n  get isLoaded(): boolean {\n    return super.isLoaded && this.getSubLayers().every(layer => layer.isLoaded);\n  }\n\n  /** Return last rendered sub layers */\n  getSubLayers(): Layer[] {\n    return (this.internalState && this.internalState.subLayers) || [];\n  }\n\n  // initializeState is usually not needed for composite layers\n  // Provide empty definition to disable check for missing definition\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  initializeState(context: LayerContext): void {}\n\n  /** Updates selected state members and marks the composite layer to need rerender */\n  setState(updateObject: any): void {\n    super.setState(updateObject);\n    // Trigger a layer update\n    // Although conceptually layer.draw and compositeLayer.renderLayers are equivalent,\n    // they are executed during different lifecycles.\n    // draw can be called without calling updateState (e.g. most viewport changes),\n    // while renderLayers can only be called during a recursive layer update.\n    this.setNeedsUpdate();\n  }\n\n  /** called to augment the info object that is bubbled up from a sublayer\n      override Layer.getPickingInfo() because decoding / setting uniform do\n      not apply to a composite layer. */\n  getPickingInfo({info}: GetPickingInfoParams): PickingInfo {\n    const {object} = info;\n    const isDataWrapped =\n      object && object.__source && object.__source.parent && object.__source.parent.id === this.id;\n\n    if (!isDataWrapped) {\n      return info;\n    }\n\n    // override object with picked data\n    info.object = object.__source.object;\n    info.index = object.__source.index;\n\n    return info;\n  }\n\n  // Implement to generate subLayers\n  abstract renderLayers(): Layer | null | LayersList;\n\n  /**\n   * Filters sub layers at draw time. Return true if the sub layer should be drawn.\n   */\n  filterSubLayer(context: FilterContext): boolean {\n    return true;\n  }\n\n  /** Returns true if sub layer needs to be rendered */\n  protected shouldRenderSubLayer(subLayerId: string, data: any): boolean {\n    return data && data.length;\n  }\n\n  /** Returns sub layer class for a specific sublayer */\n  protected getSubLayerClass<T extends Layer>(\n    subLayerId: string,\n    DefaultLayerClass: ConstructorOf<T>\n  ): ConstructorOf<T> {\n    const {_subLayerProps: overridingProps} = this.props;\n\n    return (\n      (overridingProps &&\n        overridingProps[subLayerId] &&\n        (overridingProps[subLayerId].type as ConstructorOf<T>)) ||\n      DefaultLayerClass\n    );\n  }\n\n  /** When casting user data into another format to pass to sublayers,\n      add reference to the original object and object index */\n  protected getSubLayerRow<T>(row: T, sourceObject: any, sourceObjectIndex: number): T {\n    // @ts-ignore (TS2339) adding undefined property\n    row.__source = {\n      parent: this,\n      object: sourceObject,\n      index: sourceObjectIndex\n    };\n    return row;\n  }\n\n  /** Some composite layers cast user data into another format before passing to sublayers\n    We need to unwrap them before calling the accessor so that they see the original data\n    objects */\n  protected getSubLayerAccessor<In, Out>(accessor: Accessor<In, Out>): Accessor<In, Out> {\n    if (typeof accessor === 'function') {\n      const objectInfo: AccessorContext<In> = {\n        index: -1,\n        // @ts-ignore accessing resolved data\n        data: this.props.data,\n        target: []\n      };\n      return (x: any, i: AccessorContext<In>) => {\n        if (x && x.__source) {\n          objectInfo.index = x.__source.index;\n          // @ts-ignore (TS2349) Out is never a function\n          return accessor(x.__source.object as In, objectInfo);\n        }\n        // @ts-ignore (TS2349) Out is never a function\n        return accessor(x as In, i);\n      };\n    }\n    return accessor;\n  }\n\n  /** Returns sub layer props for a specific sublayer */\n  // eslint-disable-next-line complexity\n  protected getSubLayerProps(\n    sublayerProps: {\n      id?: string;\n      updateTriggers?: Record<string, any>;\n      [propName: string]: any;\n    } = {}\n  ): any {\n    const {\n      opacity,\n      pickable,\n      visible,\n      parameters,\n      getPolygonOffset,\n      highlightedObjectIndex,\n      autoHighlight,\n      highlightColor,\n      coordinateSystem,\n      coordinateOrigin,\n      wrapLongitude,\n      positionFormat,\n      modelMatrix,\n      extensions,\n      fetch,\n      operation,\n      _subLayerProps: overridingProps\n    } = this.props;\n    const newProps = {\n      id: '',\n      updateTriggers: {},\n      opacity,\n      pickable,\n      visible,\n      parameters,\n      getPolygonOffset,\n      highlightedObjectIndex,\n      autoHighlight,\n      highlightColor,\n      coordinateSystem,\n      coordinateOrigin,\n      wrapLongitude,\n      positionFormat,\n      modelMatrix,\n      extensions,\n      fetch,\n      operation\n    };\n\n    const overridingSublayerProps =\n      overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];\n    const overridingSublayerTriggers =\n      overridingSublayerProps && overridingSublayerProps.updateTriggers;\n    const sublayerId = sublayerProps.id || 'sublayer';\n\n    if (overridingSublayerProps) {\n      const propTypes = this.props[PROP_TYPES_SYMBOL];\n      const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};\n      for (const key in overridingSublayerProps) {\n        const propType = subLayerPropTypes[key] || propTypes[key];\n        // eslint-disable-next-line\n        if (propType && propType.type === 'accessor') {\n          overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);\n        }\n      }\n    }\n\n    Object.assign(\n      newProps,\n      sublayerProps,\n      // experimental feature that allows users to override sublayer props via parent layer prop\n      overridingSublayerProps\n    );\n    newProps.id = `${this.props.id}-${sublayerId}`;\n    newProps.updateTriggers = {\n      all: this.props.updateTriggers?.all,\n      ...sublayerProps.updateTriggers,\n      ...overridingSublayerTriggers\n    };\n\n    // Pass through extension props\n    // @ts-ignore (TS2532) extensions is always defined after merging with default props\n    for (const extension of extensions) {\n      const passThroughProps = extension.getSubLayerProps.call(this, extension);\n      if (passThroughProps) {\n        Object.assign(newProps, passThroughProps, {\n          updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)\n        });\n      }\n    }\n\n    return newProps;\n  }\n\n  /** Update sub layers to highlight the hovered object */\n  protected _updateAutoHighlight(info: PickingInfo): void {\n    for (const layer of this.getSubLayers()) {\n      layer.updateAutoHighlight(info);\n    }\n  }\n\n  /** Override base Layer method */\n  protected _getAttributeManager(): AttributeManager | null {\n    return null;\n  }\n\n  /** (Internal) Called after an update to rerender sub layers */\n  protected _postUpdate(updateParams: UpdateParameters<this>, forceUpdate: boolean) {\n    // @ts-ignore (TS2531) this method is only called internally when internalState is defined\n    let subLayers = this.internalState.subLayers as Layer[];\n    const shouldUpdate = !subLayers || this.needsUpdate();\n    if (shouldUpdate) {\n      const subLayersList = this.renderLayers();\n      // Flatten the returned array, removing any null, undefined or false\n      // this allows layers to render sublayers conditionally\n      // (see CompositeLayer.renderLayers docs)\n      subLayers = flatten(subLayersList, Boolean) as Layer[];\n      // @ts-ignore (TS2531) this method is only called internally when internalState is defined\n      this.internalState.subLayers = subLayers;\n    }\n    debug(TRACE_RENDER_LAYERS, this, shouldUpdate, subLayers);\n\n    // populate reference to parent layer (this layer)\n    // NOTE: needs to be done even when reusing layers as the parent may have changed\n    for (const layer of subLayers) {\n      layer.parent = this;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}