{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { padArray } from \"../utils/array-utils.js\";\nimport Attribute from \"../lib/attribute/attribute.js\";\nimport { GL } from '@luma.gl/constants';\n/** Create a new empty attribute with the same settings: type, shader layout etc. */\nexport function cloneAttribute(attribute) {\n  // `attribute.settings` is the original options passed when constructing the attribute.\n  // This ensures that we set the proper `doublePrecision` flag and shader attributes.\n  const {\n    device,\n    settings,\n    value\n  } = attribute;\n  const newAttribute = new Attribute(device, settings);\n  // Placeholder value - necessary for generating the correct buffer layout\n  newAttribute.setData({\n    value: value instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),\n    normalized: settings.normalized\n  });\n  return newAttribute;\n}\n/** Returns the GLSL attribute type for the given number of float32 components. */\nexport function getAttributeTypeFromSize(size) {\n  switch (size) {\n    case 1:\n      return 'float';\n    case 2:\n      return 'vec2';\n    case 3:\n      return 'vec3';\n    case 4:\n      return 'vec4';\n    default:\n      throw new Error(`No defined attribute type for size \"${size}\"`);\n  }\n}\n/** Returns the {@link VertexFormat} for the given number of float32 components. */\nexport function getFloat32VertexFormat(size) {\n  switch (size) {\n    case 1:\n      return 'float32';\n    case 2:\n      return 'float32x2';\n    case 3:\n      return 'float32x3';\n    case 4:\n      return 'float32x4';\n    default:\n      throw new Error('invalid type size');\n  }\n}\nexport function cycleBuffers(buffers) {\n  buffers.push(buffers.shift());\n}\nexport function getAttributeBufferLength(attribute, numInstances) {\n  const {\n    doublePrecision,\n    settings,\n    value,\n    size\n  } = attribute;\n  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;\n  let maxVertexOffset = 0;\n  const {\n    shaderAttributes\n  } = attribute.settings;\n  if (shaderAttributes) {\n    for (const shaderAttribute of Object.values(shaderAttributes)) {\n      maxVertexOffset = Math.max(maxVertexOffset, shaderAttribute.vertexOffset ?? 0);\n    }\n  }\n  return (settings.noAlloc ? value.length : (numInstances + maxVertexOffset) * size) * multiplier;\n}\nexport function matchBuffer(_ref) {\n  let {\n    device,\n    source,\n    target\n  } = _ref;\n  if (!target || target.byteLength < source.byteLength) {\n    target?.destroy();\n    target = device.createBuffer({\n      byteLength: source.byteLength,\n      usage: source.usage\n    });\n  }\n  return target;\n}\n/* eslint-disable complexity */\n// This helper is used when transitioning attributes from a set of values in one buffer layout\n// to a set of values in a different buffer layout. (Buffer layouts are used when attribute values\n// within a buffer should be grouped for drawElements, like the Polygon layer.) For example, a\n// buffer layout of [3, 4] might have data [A1, A2, A3, B1, B2, B3, B4]. If it needs to transition\n// to a buffer layout of [4, 2], it should produce a buffer, using the transition setting's `enter`\n// function, that looks like this: [A1, A2, A3, A4 (user `enter` fn), B1, B2, 0]. Note: the final\n// 0 in this buffer is because we never shrink buffers, only grow them, for performance reasons.\n//\n// padBuffer may return either the original buffer, or a new buffer if the size of the original\n// was insufficient. Callers are responsible for disposing of the original buffer if needed.\nexport function padBuffer(_ref2) {\n  let {\n    device,\n    buffer,\n    attribute,\n    fromLength,\n    toLength,\n    fromStartIndices,\n    getData = x => x\n  } = _ref2;\n  // TODO: move the precisionMultiplier logic to the attribute when retrieving\n  // its `size` and `elementOffset`?\n  const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;\n  const size = attribute.size * precisionMultiplier;\n  const byteOffset = attribute.byteOffset;\n  // Transform feedback can only write to float varyings\n  // Attributes of format unorm8/uint8 (1 byte per element) etc will be padded to float32 (4 bytes per element)\n  const targetByteOffset = attribute.settings.bytesPerElement < 4 ? byteOffset / attribute.settings.bytesPerElement * 4 : byteOffset;\n  const toStartIndices = attribute.startIndices;\n  const hasStartIndices = fromStartIndices && toStartIndices;\n  const isConstant = attribute.isConstant;\n  // check if buffer needs to be padded\n  if (!hasStartIndices && buffer && fromLength >= toLength) {\n    return buffer;\n  }\n  const ArrayType = attribute.value instanceof Float64Array ? Float32Array : attribute.value.constructor;\n  const toData = isConstant ? attribute.value :\n  // TODO(v9.1): Avoid non-portable synchronous reads.\n  new ArrayType(attribute.getBuffer().readSyncWebGL(byteOffset, toLength * ArrayType.BYTES_PER_ELEMENT).buffer);\n  if (attribute.settings.normalized && !isConstant) {\n    const getter = getData;\n    getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));\n  }\n  const getMissingData = isConstant ? (i, chunk) => getData(toData, chunk) : (i, chunk) => getData(toData.subarray(i + byteOffset, i + byteOffset + size), chunk);\n  // TODO(v9.1): Avoid non-portable synchronous reads.\n  const source = buffer ? new Float32Array(buffer.readSyncWebGL(targetByteOffset, fromLength * 4).buffer) : new Float32Array(0);\n  const target = new Float32Array(toLength);\n  padArray({\n    source,\n    target,\n    sourceStartIndices: fromStartIndices,\n    targetStartIndices: toStartIndices,\n    size,\n    getData: getMissingData\n  });\n  if (!buffer || buffer.byteLength < target.byteLength + targetByteOffset) {\n    buffer?.destroy();\n    buffer = device.createBuffer({\n      byteLength: target.byteLength + targetByteOffset,\n      usage: 35050\n    });\n  }\n  buffer.write(target, targetByteOffset);\n  return buffer;\n}\n//# sourceMappingURL=gpu-transition-utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}