{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** @returns annotated errors or warnings */\nexport function formatCompilerLog(shaderLog, source, options) {\n  let formattedLog = '';\n  const lines = source.split(/\\r?\\n/);\n  const log = shaderLog.slice().sort((a, b) => a.lineNum - b.lineNum);\n  switch (options?.showSourceCode || 'no') {\n    case 'all':\n      // Parse the error - note: browser and driver dependent\n      let currentMessage = 0;\n      for (let lineNum = 1; lineNum <= lines.length; lineNum++) {\n        formattedLog += getNumberedLine(lines[lineNum - 1], lineNum, options);\n        while (log.length > currentMessage && log[currentMessage].lineNum === lineNum) {\n          const message = log[currentMessage++];\n          formattedLog += formatCompilerMessage(message, lines, message.lineNum, {\n            ...options,\n            inlineSource: false\n          });\n        }\n      }\n      return formattedLog;\n    case 'issues':\n    case 'no':\n      // Parse the error - note: browser and driver dependent\n      for (const message of shaderLog) {\n        formattedLog += formatCompilerMessage(message, lines, message.lineNum, {\n          inlineSource: options?.showSourceCode !== 'no'\n        });\n      }\n      return formattedLog;\n  }\n}\n// Helpers\n/** Format one message */\nfunction formatCompilerMessage(message, lines, lineNum, options) {\n  if (options?.inlineSource) {\n    const numberedLines = getNumberedLines(lines, lineNum);\n    // If we got error position on line add a `^^^` indicator on next line\n    const positionIndicator = message.linePos > 0 ? `${' '.repeat(message.linePos + 5)}^^^\\n` : '';\n    return `\n${numberedLines}${positionIndicator}${message.type.toUpperCase()}: ${message.message}\n\n`;\n  }\n  const color = message.type === 'error' ? 'red' : '#8B4000'; // dark orange\n  return options?.html ? `<div class='luma-compiler-log-error' style=\"color:${color};\"><b> ${message.type.toUpperCase()}: ${message.message}</b></div>` : `${message.type.toUpperCase()}: ${message.message}`;\n}\nfunction getNumberedLines(lines, lineNum, options) {\n  let numberedLines = '';\n  for (let lineIndex = lineNum - 2; lineIndex <= lineNum; lineIndex++) {\n    const sourceLine = lines[lineIndex - 1];\n    if (sourceLine !== undefined) {\n      numberedLines += getNumberedLine(sourceLine, lineNum, options);\n    }\n  }\n  return numberedLines;\n}\nfunction getNumberedLine(line, lineNum, options) {\n  const escapedLine = options?.html ? escapeHTML(line) : line;\n  return `${padLeft(String(lineNum), 4)}: ${escapedLine}${options?.html ? '<br/>' : '\\n'}`;\n}\n/**\n * Pads a string with a number of spaces (space characters) to the left\n * @param {String} string - string to pad\n * @param {Number} digits - number of spaces to add\n * @return {String} string - The padded string\n */\nfunction padLeft(string, paddedLength) {\n  let result = '';\n  for (let i = string.length; i < paddedLength; ++i) {\n    result += ' ';\n  }\n  return result + string;\n}\nfunction escapeHTML(unsafe) {\n  return unsafe.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;').replaceAll('\"', '&quot;').replaceAll(\"'\", '&#039;');\n}\n//# sourceMappingURL=format-compiler-log.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}