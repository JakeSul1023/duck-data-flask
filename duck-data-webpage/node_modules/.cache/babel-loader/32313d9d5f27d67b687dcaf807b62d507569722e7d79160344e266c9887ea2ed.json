{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { flatGeojsonToBinary } from '@loaders.gl/gis';\nimport { log } from '@loaders.gl/loader-utils';\nimport Protobuf from 'pbf';\nimport { VectorTile } from \"./vector-tile/vector-tile.js\";\n/**\n * Parse MVT arrayBuffer and return GeoJSON.\n *\n * @param arrayBuffer A MVT arrayBuffer\n * @param options\n * @returns A GeoJSON geometry object or a binary representation\n */\nexport function parseMVT(arrayBuffer, options) {\n  const mvtOptions = checkOptions(options);\n  const shape = options?.gis?.format || options?.mvt?.shape || options?.shape;\n  switch (shape) {\n    case 'columnar-table':\n      // binary + some JS arrays\n      return {\n        shape: 'columnar-table',\n        data: parseToBinary(arrayBuffer, mvtOptions)\n      };\n    case 'geojson-table':\n      {\n        const table = {\n          shape: 'geojson-table',\n          type: 'FeatureCollection',\n          features: parseToGeojsonFeatures(arrayBuffer, mvtOptions)\n        };\n        return table;\n      }\n    case 'geojson':\n      return parseToGeojsonFeatures(arrayBuffer, mvtOptions);\n    case 'binary-geometry':\n      return parseToBinary(arrayBuffer, mvtOptions);\n    case 'binary':\n      return parseToBinary(arrayBuffer, mvtOptions);\n    default:\n      throw new Error(shape || 'undefined shape');\n  }\n}\nfunction parseToBinary(arrayBuffer, options) {\n  const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer, options);\n  const binaryData = flatGeojsonToBinary(flatGeoJsonFeatures, geometryInfo);\n  // Add the original byteLength (as a reasonable approximation of the size of the binary data)\n  // TODO decide where to store extra fields like byteLength (header etc) and document\n  // @ts-ignore\n  binaryData.byteLength = arrayBuffer.byteLength;\n  return binaryData;\n}\nfunction parseToFlatGeoJson(arrayBuffer, options) {\n  const features = [];\n  const geometryInfo = {\n    coordLength: 2,\n    pointPositionsCount: 0,\n    pointFeaturesCount: 0,\n    linePositionsCount: 0,\n    linePathsCount: 0,\n    lineFeaturesCount: 0,\n    polygonPositionsCount: 0,\n    polygonObjectsCount: 0,\n    polygonRingsCount: 0,\n    polygonFeaturesCount: 0\n  };\n  if (arrayBuffer.byteLength <= 0) {\n    return [features, geometryInfo];\n  }\n  const tile = new VectorTile(new Protobuf(arrayBuffer));\n  const selectedLayers = options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);\n  selectedLayers.forEach(layerName => {\n    const vectorTileLayer = tile.layers[layerName];\n    if (!vectorTileLayer) {\n      return;\n    }\n    for (let i = 0; i < vectorTileLayer.length; i++) {\n      const vectorTileFeature = vectorTileLayer.getBinaryFeature(i, geometryInfo);\n      const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);\n      features.push(decodedFeature);\n    }\n  });\n  return [features, geometryInfo];\n}\nfunction parseToGeojsonFeatures(arrayBuffer, options) {\n  if (arrayBuffer.byteLength <= 0) {\n    return [];\n  }\n  const features = [];\n  const tile = new VectorTile(new Protobuf(arrayBuffer));\n  const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);\n  selectedLayers.forEach(layerName => {\n    const vectorTileLayer = tile.layers[layerName];\n    if (!vectorTileLayer) {\n      return;\n    }\n    for (let i = 0; i < vectorTileLayer.length; i++) {\n      const vectorTileFeature = vectorTileLayer.getGeoJSONFeature(i);\n      const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);\n      features.push(decodedFeature);\n    }\n  });\n  return features;\n}\n/** Check that options are good */\nfunction checkOptions(options) {\n  if (!options?.mvt) {\n    throw new Error('mvt options required');\n  }\n  if (options.mvt?.coordinates === 'wgs84' && !options.mvt.tileIndex) {\n    throw new Error('MVT Loader: WGS84 coordinates need tileIndex property');\n  }\n  if (options.gis) {\n    log.warn('MVTLoader: \"options.gis\" is deprecated, use \"options.mvt.shape\" instead')();\n  }\n  return options.mvt;\n}\n/**\n * @param feature\n * @param options\n * @returns decoded feature\n */\nfunction getDecodedFeature(feature, options, layerName) {\n  const decodedFeature = feature.toGeoJSONFeature(options.coordinates || 'local', options.tileIndex);\n  // Add layer name to GeoJSON properties\n  if (options.layerProperty) {\n    decodedFeature.properties ||= {};\n    decodedFeature.properties[options.layerProperty] = layerName;\n  }\n  return decodedFeature;\n}\n/**\n * @param feature\n * @param options\n * @returns decoded binary feature\n */\nfunction getDecodedFeatureBinary(feature, options, layerName) {\n  const decodedFeature = feature.toBinaryFeature(options.coordinates || 'local', options.tileIndex);\n  // Add layer name to GeoJSON properties\n  if (options.layerProperty && decodedFeature.properties) {\n    decodedFeature.properties[options.layerProperty] = layerName;\n  }\n  return decodedFeature;\n}","map":{"version":3,"names":["flatGeojsonToBinary","log","Protobuf","VectorTile","parseMVT","arrayBuffer","options","mvtOptions","checkOptions","shape","gis","format","mvt","data","parseToBinary","table","type","features","parseToGeojsonFeatures","Error","flatGeoJsonFeatures","geometryInfo","parseToFlatGeoJson","binaryData","byteLength","coordLength","pointPositionsCount","pointFeaturesCount","linePositionsCount","linePathsCount","lineFeaturesCount","polygonPositionsCount","polygonObjectsCount","polygonRingsCount","polygonFeaturesCount","tile","selectedLayers","Array","isArray","layers","Object","keys","forEach","layerName","vectorTileLayer","i","length","vectorTileFeature","getBinaryFeature","decodedFeature","getDecodedFeatureBinary","push","getGeoJSONFeature","getDecodedFeature","coordinates","tileIndex","warn","feature","toGeoJSONFeature","layerProperty","properties","toBinaryFeature"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/mvt/dist/lib/parse-mvt.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { flatGeojsonToBinary } from '@loaders.gl/gis';\nimport { log } from '@loaders.gl/loader-utils';\nimport Protobuf from 'pbf';\nimport { VectorTile } from \"./vector-tile/vector-tile.js\";\n/**\n * Parse MVT arrayBuffer and return GeoJSON.\n *\n * @param arrayBuffer A MVT arrayBuffer\n * @param options\n * @returns A GeoJSON geometry object or a binary representation\n */\nexport function parseMVT(arrayBuffer, options) {\n    const mvtOptions = checkOptions(options);\n    const shape = options?.gis?.format || options?.mvt?.shape || options?.shape;\n    switch (shape) {\n        case 'columnar-table': // binary + some JS arrays\n            return { shape: 'columnar-table', data: parseToBinary(arrayBuffer, mvtOptions) };\n        case 'geojson-table': {\n            const table = {\n                shape: 'geojson-table',\n                type: 'FeatureCollection',\n                features: parseToGeojsonFeatures(arrayBuffer, mvtOptions)\n            };\n            return table;\n        }\n        case 'geojson':\n            return parseToGeojsonFeatures(arrayBuffer, mvtOptions);\n        case 'binary-geometry':\n            return parseToBinary(arrayBuffer, mvtOptions);\n        case 'binary':\n            return parseToBinary(arrayBuffer, mvtOptions);\n        default:\n            throw new Error(shape || 'undefined shape');\n    }\n}\nfunction parseToBinary(arrayBuffer, options) {\n    const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer, options);\n    const binaryData = flatGeojsonToBinary(flatGeoJsonFeatures, geometryInfo);\n    // Add the original byteLength (as a reasonable approximation of the size of the binary data)\n    // TODO decide where to store extra fields like byteLength (header etc) and document\n    // @ts-ignore\n    binaryData.byteLength = arrayBuffer.byteLength;\n    return binaryData;\n}\nfunction parseToFlatGeoJson(arrayBuffer, options) {\n    const features = [];\n    const geometryInfo = {\n        coordLength: 2,\n        pointPositionsCount: 0,\n        pointFeaturesCount: 0,\n        linePositionsCount: 0,\n        linePathsCount: 0,\n        lineFeaturesCount: 0,\n        polygonPositionsCount: 0,\n        polygonObjectsCount: 0,\n        polygonRingsCount: 0,\n        polygonFeaturesCount: 0\n    };\n    if (arrayBuffer.byteLength <= 0) {\n        return [features, geometryInfo];\n    }\n    const tile = new VectorTile(new Protobuf(arrayBuffer));\n    const selectedLayers = options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);\n    selectedLayers.forEach((layerName) => {\n        const vectorTileLayer = tile.layers[layerName];\n        if (!vectorTileLayer) {\n            return;\n        }\n        for (let i = 0; i < vectorTileLayer.length; i++) {\n            const vectorTileFeature = vectorTileLayer.getBinaryFeature(i, geometryInfo);\n            const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);\n            features.push(decodedFeature);\n        }\n    });\n    return [features, geometryInfo];\n}\nfunction parseToGeojsonFeatures(arrayBuffer, options) {\n    if (arrayBuffer.byteLength <= 0) {\n        return [];\n    }\n    const features = [];\n    const tile = new VectorTile(new Protobuf(arrayBuffer));\n    const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);\n    selectedLayers.forEach((layerName) => {\n        const vectorTileLayer = tile.layers[layerName];\n        if (!vectorTileLayer) {\n            return;\n        }\n        for (let i = 0; i < vectorTileLayer.length; i++) {\n            const vectorTileFeature = vectorTileLayer.getGeoJSONFeature(i);\n            const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);\n            features.push(decodedFeature);\n        }\n    });\n    return features;\n}\n/** Check that options are good */\nfunction checkOptions(options) {\n    if (!options?.mvt) {\n        throw new Error('mvt options required');\n    }\n    if (options.mvt?.coordinates === 'wgs84' && !options.mvt.tileIndex) {\n        throw new Error('MVT Loader: WGS84 coordinates need tileIndex property');\n    }\n    if (options.gis) {\n        log.warn('MVTLoader: \"options.gis\" is deprecated, use \"options.mvt.shape\" instead')();\n    }\n    return options.mvt;\n}\n/**\n * @param feature\n * @param options\n * @returns decoded feature\n */\nfunction getDecodedFeature(feature, options, layerName) {\n    const decodedFeature = feature.toGeoJSONFeature(options.coordinates || 'local', options.tileIndex);\n    // Add layer name to GeoJSON properties\n    if (options.layerProperty) {\n        decodedFeature.properties ||= {};\n        decodedFeature.properties[options.layerProperty] = layerName;\n    }\n    return decodedFeature;\n}\n/**\n * @param feature\n * @param options\n * @returns decoded binary feature\n */\nfunction getDecodedFeatureBinary(feature, options, layerName) {\n    const decodedFeature = feature.toBinaryFeature(options.coordinates || 'local', options.tileIndex);\n    // Add layer name to GeoJSON properties\n    if (options.layerProperty && decodedFeature.properties) {\n        decodedFeature.properties[options.layerProperty] = layerName;\n    }\n    return decodedFeature;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}