{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { pickingUniforms, GLSL_UNIFORMS, WGSL_UNIFORMS } from \"./picking-uniforms.js\";\nconst source = /* wgsl */`\\\n${WGSL_UNIFORMS}\n`;\nconst vs = /* glsl */`\\\n${GLSL_UNIFORMS}\nout vec4 picking_vRGBcolor_Avalid;\n\n// Normalize unsigned byte color to 0-1 range\nvec3 picking_normalizeColor(vec3 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\n// Normalize unsigned byte color to 0-1 range\nvec4 picking_normalizeColor(vec4 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\nbool picking_isColorZero(vec3 color) {\n  return dot(color, vec3(1.0)) < 0.00001;\n}\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.00001;\n}\n\n// Check if this vertex is highlighted \nbool isVertexHighlighted(vec3 vertexColor) {\n  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\n  return\n    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\n\n// Set the current picking color\nvoid picking_setPickingColor(vec3 pickingColor) {\n  pickingColor = picking_normalizeColor(pickingColor);\n\n  if (bool(picking.isActive)) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!bool(picking.isAttribute)) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n  }\n}\n\nvoid picking_setObjectIndex(uint objectIndex) {\n  if (bool(picking.isActive)) {\n    uint index = objectIndex;\n    if (picking.indexMode == PICKING_INDEX_MODE_INSTANCE) {\n      index = uint(gl_InstanceID);\n    }\n    picking_vRGBcolor_Avalid.r = float(index % 255) / 255.0;\n    picking_vRGBcolor_Avalid.g = float((index / 255) % 255) / 255.0;\n    picking_vRGBcolor_Avalid.b = float((index / 255 / 255) %255) / 255.0;\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec2 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec3 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n`;\nconst fs = /* glsl */`\\\n${GLSL_UNIFORMS}\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (picking.isActive > 0.5) {\n    return color;\n  }\n\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    // Blend in highlight color based on its alpha value\n    float highLightAlpha = picking.highlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highlightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highlightColor);\n}\n`;\n/**\n * Provides support for color-coding-based picking and highlighting.\n * In particular, supports picking a specific instance in an instanced\n * draw call and highlighting an instance based on its picking color,\n * and correspondingly, supports picking and highlighting groups of\n * primitives with the same picking color in non-instanced draw-calls\n */\nexport const picking = {\n  ...pickingUniforms,\n  name: 'picking',\n  source,\n  vs,\n  fs\n};\n// function getUniforms(opts: PickingProps = {}, prevUniforms?: PickingUniforms): PickingUniforms {\n//   const uniforms = {} as PickingUniforms;\n//   if (opts.highlightedObjectColor === undefined) {\n//     // Unless highlightedObjectColor explicitly null or set, do not update state\n//   } else if (opts.highlightedObjectColor === null) {\n//     uniforms.isHighlightActive = false;\n//   } else {\n//     uniforms.isHighlightActive = true;\n//     const highlightedObjectColor = opts.highlightedObjectColor.slice(0, 3);\n//     uniforms.highlightedObjectColor = highlightedObjectColor;\n//   }\n//   if (opts.highlightColor) {\n//     const color = Array.from(opts.highlightColor, x => x / 255);\n//     if (!Number.isFinite(color[3])) {\n//       color[3] = 1;\n//     }\n//     uniforms.highlightColor = color;\n//   }\n//   if (opts.isActive !== undefined) {\n//     uniforms.isActive = Boolean(opts.isActive);\n//     uniforms.isAttribute = Boolean(opts.isAttribute);\n//   }\n//   if (opts.useFloatColors !== undefined) {\n//     uniforms.useFloatColors = Boolean(opts.useFloatColors);\n//   }\n//   return uniforms;\n// }","map":{"version":3,"names":["pickingUniforms","GLSL_UNIFORMS","WGSL_UNIFORMS","source","vs","fs","picking","name"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\engine\\src\\modules\\picking\\color-picking.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nimport type {PickingProps, PickingUniforms, PickingBindings} from './picking-uniforms';\nimport {pickingUniforms, GLSL_UNIFORMS, WGSL_UNIFORMS} from './picking-uniforms';\n\nconst source = /* wgsl */ `\\\n${WGSL_UNIFORMS}\n`;\n\nconst vs = /* glsl */ `\\\n${GLSL_UNIFORMS}\nout vec4 picking_vRGBcolor_Avalid;\n\n// Normalize unsigned byte color to 0-1 range\nvec3 picking_normalizeColor(vec3 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\n// Normalize unsigned byte color to 0-1 range\nvec4 picking_normalizeColor(vec4 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\nbool picking_isColorZero(vec3 color) {\n  return dot(color, vec3(1.0)) < 0.00001;\n}\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.00001;\n}\n\n// Check if this vertex is highlighted \nbool isVertexHighlighted(vec3 vertexColor) {\n  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\n  return\n    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\n\n// Set the current picking color\nvoid picking_setPickingColor(vec3 pickingColor) {\n  pickingColor = picking_normalizeColor(pickingColor);\n\n  if (bool(picking.isActive)) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!bool(picking.isAttribute)) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n  }\n}\n\nvoid picking_setObjectIndex(uint objectIndex) {\n  if (bool(picking.isActive)) {\n    uint index = objectIndex;\n    if (picking.indexMode == PICKING_INDEX_MODE_INSTANCE) {\n      index = uint(gl_InstanceID);\n    }\n    picking_vRGBcolor_Avalid.r = float(index % 255) / 255.0;\n    picking_vRGBcolor_Avalid.g = float((index / 255) % 255) / 255.0;\n    picking_vRGBcolor_Avalid.b = float((index / 255 / 255) %255) / 255.0;\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec2 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec3 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n`;\n\nconst fs = /* glsl */ `\\\n${GLSL_UNIFORMS}\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (picking.isActive > 0.5) {\n    return color;\n  }\n\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    // Blend in highlight color based on its alpha value\n    float highLightAlpha = picking.highlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highlightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highlightColor);\n}\n`;\n\n/**\n * Provides support for color-coding-based picking and highlighting.\n * In particular, supports picking a specific instance in an instanced\n * draw call and highlighting an instance based on its picking color,\n * and correspondingly, supports picking and highlighting groups of\n * primitives with the same picking color in non-instanced draw-calls\n */\nexport const picking = {\n  ...pickingUniforms,\n  name: 'picking',\n  source,\n  vs,\n  fs\n} as const satisfies ShaderModule<PickingProps, PickingUniforms, PickingBindings>;\n\n// function getUniforms(opts: PickingProps = {}, prevUniforms?: PickingUniforms): PickingUniforms {\n//   const uniforms = {} as PickingUniforms;\n\n//   if (opts.highlightedObjectColor === undefined) {\n//     // Unless highlightedObjectColor explicitly null or set, do not update state\n//   } else if (opts.highlightedObjectColor === null) {\n//     uniforms.isHighlightActive = false;\n//   } else {\n//     uniforms.isHighlightActive = true;\n//     const highlightedObjectColor = opts.highlightedObjectColor.slice(0, 3);\n//     uniforms.highlightedObjectColor = highlightedObjectColor;\n//   }\n\n//   if (opts.highlightColor) {\n//     const color = Array.from(opts.highlightColor, x => x / 255);\n//     if (!Number.isFinite(color[3])) {\n//       color[3] = 1;\n//     }\n//     uniforms.highlightColor = color;\n//   }\n\n//   if (opts.isActive !== undefined) {\n//     uniforms.isActive = Boolean(opts.isActive);\n//     uniforms.isAttribute = Boolean(opts.isAttribute);\n//   }\n\n//   if (opts.useFloatColors !== undefined) {\n//     uniforms.useFloatColors = Boolean(opts.useFloatColors);\n//   }\n\n//   return uniforms;\n// }\n"],"mappings":"AAAA;AACA;AACA;AAKA,SAAQA,eAAe,EAAEC,aAAa,EAAEC,aAAa,QAAC;AAEtD,MAAMC,MAAM,GAAG,UAAW;EACxBD,aAAa;CACd;AAED,MAAME,EAAE,GAAG,UAAW;EACpBH,aAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2Ed;AAED,MAAMI,EAAE,GAAG,UAAW;EACpBJ,aAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiDd;AAED;;;;;;;AAOA,OAAO,MAAMK,OAAO,GAAG;EACrB,GAAGN,eAAe;EAClBO,IAAI,EAAE,SAAS;EACfJ,MAAM;EACNC,EAAE;EACFC;CAC+E;AAEjF;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}