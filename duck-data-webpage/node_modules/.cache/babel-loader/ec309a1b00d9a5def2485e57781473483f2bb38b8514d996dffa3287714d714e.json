{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { _deepEqual as deepEqual } from '@deck.gl/core';\nimport { sortBins, packBinIds } from \"./sort-bins.js\";\nimport { aggregate, BUILT_IN_OPERATIONS } from \"./aggregate.js\";\nimport { evaluateVertexAccessor } from \"./vertex-accessor.js\";\n/** An Aggregator implementation that calculates aggregation on the CPU */\nexport class CPUAggregator {\n  constructor(props) {\n    this.bins = [];\n    this.binIds = null;\n    this.results = [];\n    this.dimensions = props.dimensions;\n    this.channelCount = props.getValue.length;\n    this.props = {\n      ...props,\n      binOptions: {},\n      pointCount: 0,\n      operations: [],\n      customOperations: [],\n      attributes: {}\n    };\n    this.needsUpdate = true;\n    this.setProps(props);\n  }\n  destroy() {}\n  get binCount() {\n    return this.bins.length;\n  }\n  /** Update aggregation props */\n  setProps(props) {\n    const oldProps = this.props;\n    if (props.binOptions) {\n      if (!deepEqual(props.binOptions, oldProps.binOptions, 2)) {\n        this.setNeedsUpdate();\n      }\n    }\n    if (props.operations) {\n      for (let channel = 0; channel < this.channelCount; channel++) {\n        if (props.operations[channel] !== oldProps.operations[channel]) {\n          this.setNeedsUpdate(channel);\n        }\n      }\n    }\n    if (props.customOperations) {\n      for (let channel = 0; channel < this.channelCount; channel++) {\n        if (Boolean(props.customOperations[channel]) !== Boolean(oldProps.customOperations[channel])) {\n          this.setNeedsUpdate(channel);\n        }\n      }\n    }\n    if (props.pointCount !== undefined && props.pointCount !== oldProps.pointCount) {\n      this.setNeedsUpdate();\n    }\n    if (props.attributes) {\n      props.attributes = {\n        ...oldProps.attributes,\n        ...props.attributes\n      };\n    }\n    Object.assign(this.props, props);\n  }\n  /** Flags a channel to need update\n   * This is called internally by setProps() if certain props change\n   * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed\n   * the underlying buffers could have been updated and require rerunning the aggregation\n   * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.\n   */\n  setNeedsUpdate(channel) {\n    if (channel === undefined) {\n      this.needsUpdate = true;\n    } else if (this.needsUpdate !== true) {\n      this.needsUpdate = this.needsUpdate || [];\n      this.needsUpdate[channel] = true;\n    }\n  }\n  /** Run aggregation */\n  update() {\n    if (this.needsUpdate === true) {\n      this.bins = sortBins({\n        pointCount: this.props.pointCount,\n        getBinId: evaluateVertexAccessor(this.props.getBin, this.props.attributes, this.props.binOptions)\n      });\n      const value = packBinIds({\n        bins: this.bins,\n        dimensions: this.dimensions,\n        // Reuse allocated typed array\n        target: this.binIds?.value\n      });\n      this.binIds = {\n        value,\n        type: 'float32',\n        size: this.dimensions\n      };\n    }\n    for (let channel = 0; channel < this.channelCount; channel++) {\n      if (this.needsUpdate === true || this.needsUpdate[channel]) {\n        const operation = this.props.customOperations[channel] || BUILT_IN_OPERATIONS[this.props.operations[channel]];\n        const {\n          value,\n          domain\n        } = aggregate({\n          bins: this.bins,\n          getValue: evaluateVertexAccessor(this.props.getValue[channel], this.props.attributes, undefined),\n          operation,\n          // Reuse allocated typed array\n          target: this.results[channel]?.value\n        });\n        this.results[channel] = {\n          value,\n          domain,\n          type: 'float32',\n          size: 1\n        };\n        this.props.onUpdate?.({\n          channel\n        });\n      }\n    }\n    this.needsUpdate = false;\n  }\n  preDraw() {}\n  /** Returns an accessor to the bins. */\n  getBins() {\n    return this.binIds;\n  }\n  /** Returns an accessor to the output for a given channel. */\n  getResult(channel) {\n    return this.results[channel];\n  }\n  /** Returns the [min, max] of aggregated values for a given channel. */\n  getResultDomain(channel) {\n    return this.results[channel]?.domain ?? [Infinity, -Infinity];\n  }\n  /** Returns the information for a given bin. */\n  getBin(index) {\n    const bin = this.bins[index];\n    if (!bin) {\n      return null;\n    }\n    const value = new Array(this.channelCount);\n    for (let i = 0; i < value.length; i++) {\n      const result = this.results[i];\n      value[i] = result?.value[index];\n    }\n    return {\n      id: bin.id,\n      value,\n      count: bin.points.length,\n      pointIndices: bin.points\n    };\n  }\n}\n//# sourceMappingURL=cpu-aggregator.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}