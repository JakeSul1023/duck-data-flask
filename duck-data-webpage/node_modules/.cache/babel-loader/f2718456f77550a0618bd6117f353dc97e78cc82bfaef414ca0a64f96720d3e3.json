{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst EMPTY_ARRAY = [];\nconst placeholderArray = [];\n/*\n * Create an Iterable\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\n * and a \"context\" tracker from the given data\n */\nexport function createIterable(data, startRow = 0, endRow = Infinity) {\n  let iterable = EMPTY_ARRAY;\n  const objectInfo = {\n    index: -1,\n    data,\n    // visitor can optionally utilize this to avoid constructing a new array for every object\n    target: []\n  };\n  if (!data) {\n    iterable = EMPTY_ARRAY;\n  } else if (typeof data[Symbol.iterator] === 'function') {\n    // data is already an iterable\n    iterable = data;\n  } else if (data.length > 0) {\n    placeholderArray.length = data.length;\n    iterable = placeholderArray;\n  }\n  if (startRow > 0 || Number.isFinite(endRow)) {\n    iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);\n    objectInfo.index = startRow - 1;\n  }\n  return {\n    iterable,\n    objectInfo\n  };\n}\n/*\n * Returns true if data is an async iterable object\n */\nexport function isAsyncIterable(data) {\n  return data && data[Symbol.asyncIterator];\n}\n/*\n * Create an accessor function from a flat buffer that yields the value at each object index\n */\nexport function getAccessorFromBuffer(typedArray, options) {\n  const {\n    size,\n    stride,\n    offset,\n    startIndices,\n    nested\n  } = options;\n  const bytesPerElement = typedArray.BYTES_PER_ELEMENT;\n  const elementStride = stride ? stride / bytesPerElement : size;\n  const elementOffset = offset ? offset / bytesPerElement : 0;\n  const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);\n  return (_, {\n    index,\n    target\n  }) => {\n    if (!startIndices) {\n      const sourceIndex = index * elementStride + elementOffset;\n      for (let j = 0; j < size; j++) {\n        target[j] = typedArray[sourceIndex + j];\n      }\n      return target;\n    }\n    const startIndex = startIndices[index];\n    const endIndex = startIndices[index + 1] || vertexCount;\n    let result;\n    if (nested) {\n      result = new Array(endIndex - startIndex);\n      for (let i = startIndex; i < endIndex; i++) {\n        const sourceIndex = i * elementStride + elementOffset;\n        target = new Array(size);\n        for (let j = 0; j < size; j++) {\n          target[j] = typedArray[sourceIndex + j];\n        }\n        result[i - startIndex] = target;\n      }\n    } else if (elementStride === size) {\n      result = typedArray.subarray(startIndex * size + elementOffset, endIndex * size + elementOffset);\n    } else {\n      result = new typedArray.constructor((endIndex - startIndex) * size);\n      let targetIndex = 0;\n      for (let i = startIndex; i < endIndex; i++) {\n        const sourceIndex = i * elementStride + elementOffset;\n        for (let j = 0; j < size; j++) {\n          result[targetIndex++] = typedArray[sourceIndex + j];\n        }\n      }\n    }\n    return result;\n  };\n}","map":{"version":3,"names":["EMPTY_ARRAY","placeholderArray","createIterable","data","startRow","endRow","Infinity","iterable","objectInfo","index","target","Symbol","iterator","length","Number","isFinite","Array","isArray","from","slice","isAsyncIterable","asyncIterator","getAccessorFromBuffer","typedArray","options","size","stride","offset","startIndices","nested","bytesPerElement","BYTES_PER_ELEMENT","elementStride","elementOffset","vertexCount","Math","floor","_","sourceIndex","j","startIndex","endIndex","result","i","subarray","constructor","targetIndex"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\utils\\iterable-utils.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {NumericArray} from '../types/types';\nimport type {AccessorFunction} from '../types/layer-props';\n\nconst EMPTY_ARRAY = [];\nconst placeholderArray = [];\n\n/*\n * Create an Iterable\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\n * and a \"context\" tracker from the given data\n */\nexport function createIterable(\n  data,\n  startRow = 0,\n  endRow = Infinity\n): {\n  iterable: Iterable<any>;\n  objectInfo: {\n    index: number;\n    data: any;\n    target: any[];\n  };\n} {\n  let iterable: Iterable<any> = EMPTY_ARRAY;\n\n  const objectInfo = {\n    index: -1,\n    data,\n    // visitor can optionally utilize this to avoid constructing a new array for every object\n    target: []\n  };\n\n  if (!data) {\n    iterable = EMPTY_ARRAY;\n  } else if (typeof data[Symbol.iterator] === 'function') {\n    // data is already an iterable\n    iterable = data;\n  } else if (data.length > 0) {\n    placeholderArray.length = data.length;\n    iterable = placeholderArray;\n  }\n\n  if (startRow > 0 || Number.isFinite(endRow)) {\n    iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);\n    objectInfo.index = startRow - 1;\n  }\n\n  return {iterable, objectInfo};\n}\n\n/*\n * Returns true if data is an async iterable object\n */\nexport function isAsyncIterable(data): boolean {\n  return data && data[Symbol.asyncIterator];\n}\n\n/*\n * Create an accessor function from a flat buffer that yields the value at each object index\n */\nexport function getAccessorFromBuffer(\n  typedArray,\n  options: {\n    size: number;\n    stride?: number;\n    offset?: number;\n    startIndices?: NumericArray;\n    nested?: boolean;\n  }\n): AccessorFunction<any, NumericArray> {\n  const {size, stride, offset, startIndices, nested} = options;\n  const bytesPerElement = typedArray.BYTES_PER_ELEMENT;\n  const elementStride = stride ? stride / bytesPerElement : size;\n  const elementOffset = offset ? offset / bytesPerElement : 0;\n  const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);\n\n  return (_, {index, target}) => {\n    if (!startIndices) {\n      const sourceIndex = index * elementStride + elementOffset;\n      for (let j = 0; j < size; j++) {\n        target[j] = typedArray[sourceIndex + j];\n      }\n      return target;\n    }\n    const startIndex = startIndices[index];\n    const endIndex = startIndices[index + 1] || vertexCount;\n    let result;\n\n    if (nested) {\n      result = new Array(endIndex - startIndex);\n      for (let i = startIndex; i < endIndex; i++) {\n        const sourceIndex = i * elementStride + elementOffset;\n        target = new Array(size);\n        for (let j = 0; j < size; j++) {\n          target[j] = typedArray[sourceIndex + j];\n        }\n        result[i - startIndex] = target;\n      }\n    } else if (elementStride === size) {\n      result = typedArray.subarray(\n        startIndex * size + elementOffset,\n        endIndex * size + elementOffset\n      );\n    } else {\n      result = new typedArray.constructor((endIndex - startIndex) * size);\n      let targetIndex = 0;\n      for (let i = startIndex; i < endIndex; i++) {\n        const sourceIndex = i * elementStride + elementOffset;\n        for (let j = 0; j < size; j++) {\n          result[targetIndex++] = typedArray[sourceIndex + j];\n        }\n      }\n    }\n\n    return result;\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}