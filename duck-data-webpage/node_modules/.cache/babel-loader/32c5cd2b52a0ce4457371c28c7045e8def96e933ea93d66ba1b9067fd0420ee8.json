{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { canEncodeWithWorker, NodeFile, resolvePath, isBrowser } from '@loaders.gl/loader-utils';\nimport { processOnWorker } from '@loaders.gl/worker-utils';\nimport { fetchFile } from \"../fetch/fetch-file.js\";\nimport { getLoaderOptions } from \"./loader-options.js\";\n/**\n * Encode loaded data into a binary ArrayBuffer using the specified Writer.\n */\nexport async function encode(data, writer, options_) {\n  const globalOptions = getLoaderOptions();\n  // const globalOptions: WriterOptions = {}; // getWriterOptions();\n  const options = {\n    ...globalOptions,\n    ...options_\n  };\n  // Handle the special case where we are invoking external command-line tools\n  if (writer.encodeURLtoURL) {\n    return encodeWithCommandLineTool(writer, data, options);\n  }\n  // Worker support\n  if (canEncodeWithWorker(writer, options)) {\n    return await processOnWorker(writer, data, options);\n  }\n  // TODO Merge default writer options with options argument like it is done in load module.\n  return await writer.encode(data, options);\n}\n/**\n * Encode loaded data into a binary ArrayBuffer using the specified Writer.\n */\nexport function encodeSync(data, writer, options) {\n  if (writer.encodeSync) {\n    return writer.encodeSync(data, options);\n  }\n  if (writer.encodeTextSync) {\n    return new TextEncoder().encode(writer.encodeTextSync(data, options));\n  }\n  throw new Error(`Writer ${writer.name} could not synchronously encode data`);\n}\n/**\n * Encode loaded data to text using the specified Writer\n * @note This is a convenience function not intended for production use on large input data.\n * It is not optimized for performance. Data maybe converted from text to binary and back.\n * @throws if the writer does not generate text output\n */\nexport async function encodeText(data, writer, options) {\n  if (writer.encodeText) {\n    return await writer.encodeText(data, options);\n  }\n  if (writer.encodeTextSync) {\n    return writer.encodeTextSync(data, options);\n  }\n  if (writer.text) {\n    const arrayBuffer = await writer.encode(data, options);\n    return new TextDecoder().decode(arrayBuffer);\n  }\n  throw new Error(`Writer ${writer.name} could not encode data as text`);\n}\n/**\n * Encode loaded data to text using the specified Writer\n * @note This is a convenience function not intended for production use on large input data.\n * It is not optimized for performance. Data maybe converted from text to binary and back.\n * @throws if the writer does not generate text output\n */\nexport function encodeTextSync(data, writer, options) {\n  if (writer.encodeTextSync) {\n    return writer.encodeTextSync(data, options);\n  }\n  if (writer.text && writer.encodeSync) {\n    const arrayBuffer = encodeSync(data, writer, options);\n    return new TextDecoder().decode(arrayBuffer);\n  }\n  throw new Error(`Writer ${writer.name} could not encode data as text`);\n}\n/**\n * Encode loaded data into a sequence (iterator) of binary ArrayBuffers using the specified Writer.\n */\nexport function encodeInBatches(data, writer, options) {\n  if (writer.encodeInBatches) {\n    const dataIterator = getIterator(data);\n    // @ts-expect-error\n    return writer.encodeInBatches(dataIterator, options);\n  }\n  // TODO -fall back to atomic encode?\n  throw new Error(`Writer ${writer.name} could not encode in batches`);\n}\n/**\n * Encode loaded data into a sequence (iterator) of binary ArrayBuffers using the specified Writer.\n */\nexport function encodeTextInBatches(data, writer, options) {\n  if (writer.encodeTextInBatches) {\n    const dataIterator = getIterator(data);\n    // @ts-expect-error\n    return writer.encodeTextInBatches(dataIterator, options);\n  }\n  // TODO -fall back to atomic encode?\n  throw new Error(`Writer ${writer.name} could not encode text in batches`);\n}\n/**\n * Encode data stored in a file (on disk) to another file.\n * @note Node.js only. This function enables using command-line converters as \"writers\".\n */\nexport async function encodeURLtoURL(inputUrl, outputUrl, writer, options) {\n  inputUrl = resolvePath(inputUrl);\n  outputUrl = resolvePath(outputUrl);\n  if (isBrowser || !writer.encodeURLtoURL) {\n    throw new Error();\n  }\n  const outputFilename = await writer.encodeURLtoURL(inputUrl, outputUrl, options);\n  return outputFilename;\n}\n/** Helper function to encode via external tool (typically command line execution in Node.js) */\nasync function encodeWithCommandLineTool(writer, data, options) {\n  if (isBrowser) {\n    throw new Error(`Writer ${writer.name} not supported in browser`);\n  }\n  // TODO - how to generate filenames with correct extensions?\n  const tmpInputFilename = getTemporaryFilename('input');\n  const file = new NodeFile(tmpInputFilename, 'w');\n  await file.write(data);\n  const tmpOutputFilename = getTemporaryFilename('output');\n  const outputFilename = await encodeURLtoURL(tmpInputFilename, tmpOutputFilename, writer, options);\n  const response = await fetchFile(outputFilename);\n  return response.arrayBuffer();\n}\n/**\n * @todo TODO - this is an unacceptable hack!!!\n */\nfunction getIterator(data) {\n  const dataIterator = [{\n    ...data,\n    start: 0,\n    end: data.length\n  }];\n  return dataIterator;\n}\n/**\n * @todo Move to utils\n */\nfunction getTemporaryFilename(filename) {\n  return `/tmp/${filename}`;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}