{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { XMLLoader } from '@loaders.gl/xml';\nimport { getXMLArray, getXMLStringArray, getXMLInteger, getXMLFloat, getXMLBoolean } from \"../xml/parse-xml-helpers.js\";\n/**\n * Parses a typed data structure from raw XML for `GetCapabilities` response\n * @note Error handlings is fairly weak\n */\nexport function parseWMSCapabilities(xmlText, options) {\n  const parsedXML = XMLLoader.parseTextSync?.(xmlText, options);\n  const xmlCapabilities = parsedXML.WMT_MS_Capabilities || parsedXML.WMS_Capabilities || parsedXML;\n  const capabilities = extractCapabilities(xmlCapabilities);\n  // In case the processed, normalized capabilities do not contain everything,\n  // the user can get the parsed XML structure.\n  if (options?.inheritedLayerProps) {\n    // Traverse layers and inject missing props from parents\n    for (const layer of capabilities.layers) {\n      addInheritedLayerProps(layer, null);\n    }\n    // Not yet implemented\n  }\n  if (options?.includeRawJSON) {\n    capabilities.json = xmlCapabilities;\n  }\n  if (options?.includeXMLText) {\n    capabilities.xml = xmlText;\n  }\n  return capabilities;\n}\n/** Extract typed capability data from XML */\nfunction extractCapabilities(xml) {\n  const capabilities = {\n    version: String(xml.version || ''),\n    name: String(xml.Service?.Name || 'unnamed'),\n    title: xml.Service?.Title ? String(xml.Service?.Title) : undefined,\n    abstract: xml.Service?.Abstract ? String(xml.Service?.Abstract) : undefined,\n    keywords: getXMLStringArray(xml.Service?.KeywordList?.Keyword),\n    fees: xml.Service?.Fees ? JSON.stringify(xml.Service?.Fees) : undefined,\n    accessConstraints: xml.Service?.AccessConstraints ? JSON.stringify(xml.Service?.AccessConstraints) : undefined,\n    layerLimit: getXMLInteger(xml.Service?.LayerLimit),\n    maxWidth: getXMLInteger(xml.Service?.maxWidth),\n    maxHeight: getXMLInteger(xml.Service?.maxHeight),\n    layers: [],\n    requests: extractRequests(xml.Capability?.Request),\n    exceptions: extractExceptions(xml.Exception)\n    // contact field is a mess of largely irrelevant information, put it last\n    // contact: xml.Service?.Contact ? JSON.stringify(xml.Service?.Contact) : undefined,\n  };\n  // LAYERS\n  const xmlLayers = getXMLArray(xml.Capability?.Layer);\n  for (const xmlSubLayer of xmlLayers) {\n    capabilities.layers.push(extractLayer(xmlSubLayer));\n  }\n  // Clean up object\n  for (const [key, value] of Object.entries(capabilities)) {\n    if (value === undefined) {\n      delete capabilities[key];\n    }\n  }\n  return capabilities;\n}\n/** Extract typed request metadata from XML requests field */\nfunction extractRequests(xmlRequests) {\n  const requests = {};\n  for (const [name, xmlRequest] of Object.entries(xmlRequests || {})) {\n    const mimeTypes = getXMLStringArray(xmlRequest?.Format);\n    requests[name] = {\n      mimeTypes\n    };\n  }\n  return requests;\n}\nfunction extractExceptions(xmlException) {\n  const xmlExceptionFormats = getXMLArray(xmlException?.Format);\n  if (xmlExceptionFormats.length > 0) {\n    return {\n      mimeTypes: getXMLStringArray(xmlException)\n    };\n  }\n  return undefined;\n}\n/** Extract request data */\n// eslint-disable-next-line complexity, max-statements\nfunction extractLayer(xmlLayer) {\n  const layer = {\n    // All layers must have a title\n    title: String(xmlLayer?.Title || ''),\n    // Name is required only if renderable\n    name: xmlLayer?.Name && String(xmlLayer?.Name),\n    abstract: xmlLayer?.Name && String(xmlLayer?.Abstract),\n    keywords: getXMLStringArray(xmlLayer.KeywordList?.Keyword)\n  };\n  // WMS 1.3.0 changes SRS to CRS\n  const crs = xmlLayer?.CRS || xmlLayer?.SRS;\n  if (crs && Array.isArray(crs) && crs.every(_ => typeof _ === 'string')) {\n    layer.crs = crs;\n  }\n  // v1.3.0 extract simple geographic bounding box\n  let geographicBoundingBox = xmlLayer?.EX_GeographicBoundingBox && extractEXBoundingBox(xmlLayer?.EX_GeographicBoundingBox);\n  if (geographicBoundingBox) {\n    layer.geographicBoundingBox = geographicBoundingBox;\n  }\n  // v1.1.1 extract simple geographic bounding box\n  geographicBoundingBox = xmlLayer?.LatLonBoundingBox && extractLatLonBoundingBox(xmlLayer?.LatLonBoundingBox);\n  if (geographicBoundingBox) {\n    layer.geographicBoundingBox = geographicBoundingBox;\n  }\n  // Extract per-CRS bounding boxes\n  const boundingBoxes = xmlLayer?.BoundingBox && extractWMSBoundingBoxes(xmlLayer?.BoundingBox);\n  if (boundingBoxes && boundingBoxes.length > 0) {\n    layer.boundingBoxes = boundingBoxes;\n  }\n  // Extract dimensions\n  const xmlDimensions = getXMLArray(xmlLayer?.Dimension);\n  const dimensions = xmlDimensions.map(xml => extractDimension(xml));\n  if (dimensions.length) {\n    layer.dimensions = dimensions;\n  }\n  if (xmlLayer?.opaque) {\n    layer.opaque = getXMLBoolean(xmlLayer?.opaque);\n  }\n  if (xmlLayer?.cascaded) {\n    layer.cascaded = getXMLBoolean(xmlLayer?.cascaded);\n  }\n  if (xmlLayer?.queryable) {\n    layer.queryable = getXMLBoolean(xmlLayer?.queryable);\n  }\n  // Single layer is not represented as array in XML\n  const xmlLayers = getXMLArray(xmlLayer?.Layer);\n  const layers = [];\n  for (const xmlSubLayer of xmlLayers) {\n    layers.push(extractLayer(xmlSubLayer));\n  }\n  if (layers.length > 0) {\n    layer.layers = layers;\n  }\n  // Clean up object\n  for (const [key, value] of Object.entries(layer)) {\n    if (value === undefined) {\n      delete layer[key];\n    }\n  }\n  return layer;\n}\n/** WMS 1.3.0 Loosely defined geospatial bounding box in unspecified CRS for quick content searches */\nfunction extractEXBoundingBox(xmlBoundingBox) {\n  const {\n    westBoundLongitude: w,\n    northBoundLatitude: n,\n    eastBoundLongitude: e,\n    southBoundLatitude: s\n  } = xmlBoundingBox;\n  return [[w, s], [e, n]];\n}\n/** WMS 1.1.1 Loosely defined geospatial bounding box in unspecified CRS for quick content searches */\nfunction extractLatLonBoundingBox(xmlBoundingBox) {\n  const {\n    minx,\n    miny,\n    maxx,\n    maxy\n  } = xmlBoundingBox;\n  return [[minx, miny], [maxx, maxy]];\n}\n/** Loosely defined geospatial bounding box in unspecified CRS for quick content searches */\nfunction extractWMSBoundingBoxes(xmlBoundingBoxes) {\n  const xmlBoxes = getXMLArray(xmlBoundingBoxes);\n  return xmlBoxes.map(xmlBox => extractWMSBoundingBox(xmlBox));\n}\n/** Loosely defined geospatial bounding box in unspecified CRS for quick content searches */\nfunction extractWMSBoundingBox(xmlBoundingBox) {\n  const {\n    CRS,\n    SRS,\n    minx,\n    miny,\n    maxx,\n    maxy,\n    resx,\n    resy\n  } = xmlBoundingBox;\n  const boundingBox = {\n    // CRS in 1.3.0, SRS in 1.1.1\n    crs: CRS || SRS,\n    boundingBox: [[getXMLFloat(minx), getXMLFloat(miny)], [getXMLFloat(maxx), getXMLFloat(maxy)]]\n  };\n  if (resx) {\n    boundingBox.xResolution = resx;\n  }\n  if (resy) {\n    boundingBox.yResolution = resy;\n  }\n  return boundingBox;\n}\n/**\n * Extracts optional WMS Dimension layer field\n * @param xmlDimension\n * @example <Dimension name=\"time\" units=\"ISO8601\" default=\"2018-01-01\" nearestValue=\"0\">2001-01-01/2018-01-01/P1Y</Dimension>\n * @see https://mapserver.org/ogc/wms_dimension.html\n */\nfunction extractDimension(xmlDimension) {\n  const {\n    name,\n    units,\n    value: extent\n  } = xmlDimension;\n  const dimension = {\n    name,\n    units,\n    extent\n  };\n  if (xmlDimension.unitSymbol) {\n    dimension.unitSymbol = xmlDimension.unitSymbol;\n  }\n  if (xmlDimension.default) {\n    dimension.defaultValue = xmlDimension.default;\n  }\n  if (xmlDimension.multipleValues) {\n    dimension.multipleValues = getXMLBoolean(xmlDimension.multipleValues);\n  }\n  if (xmlDimension.nearestValue) {\n    dimension.nearestValue = getXMLBoolean(xmlDimension.nearestValue);\n  }\n  if (xmlDimension.current) {\n    dimension.current = getXMLBoolean(xmlDimension.current);\n  }\n  return dimension;\n}\n/** Traverse layers and inject missing props from parents */\n// eslint-disable-next-line complexity\nfunction addInheritedLayerProps(layer, parent) {\n  if (parent?.geographicBoundingBox && !layer.geographicBoundingBox) {\n    layer.geographicBoundingBox = [...parent.geographicBoundingBox];\n  }\n  if (parent?.crs && !layer.crs) {\n    layer.crs = [...parent.crs];\n  }\n  if (parent?.boundingBoxes && !layer.boundingBoxes) {\n    layer.boundingBoxes = [...parent.boundingBoxes];\n  }\n  if (parent?.dimensions && !layer.dimensions) {\n    layer.dimensions = [...parent.dimensions];\n  }\n  for (const subLayer of layer.layers || []) {\n    addInheritedLayerProps(subLayer, layer);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}