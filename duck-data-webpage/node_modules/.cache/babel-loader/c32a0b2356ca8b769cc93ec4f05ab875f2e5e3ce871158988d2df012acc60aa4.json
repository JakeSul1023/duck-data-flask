{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n// TODO - Dynamic screen space error provides an optimization when looking at\n// tilesets from above\n/* eslint-disable */\n// @ts-nocheck\nimport { Matrix4, Vector3, clamp } from '@math.gl/core';\nconst scratchPositionNormal = new Vector3();\nconst scratchCartographic = new Vector3();\nconst scratchMatrix = new Matrix4();\nconst scratchCenter = new Vector3();\nconst scratchPosition = new Vector3();\nconst scratchDirection = new Vector3();\n// eslint-disable-next-line max-statements, complexity\nexport function calculateDynamicScreenSpaceError(root, {\n  camera,\n  mapProjection\n}, options = {}) {\n  const {\n    dynamicScreenSpaceErrorHeightFalloff = 0.25,\n    dynamicScreenSpaceErrorDensity = 0.00278\n  } = options;\n  let up;\n  let direction;\n  let height;\n  let minimumHeight;\n  let maximumHeight;\n  const tileBoundingVolume = root.contentBoundingVolume;\n  if (tileBoundingVolume instanceof TileBoundingRegion) {\n    up = Cartesian3.normalize(camera.positionWC, scratchPositionNormal);\n    direction = camera.directionWC;\n    height = camera.positionCartographic.height;\n    minimumHeight = tileBoundingVolume.minimumHeight;\n    maximumHeight = tileBoundingVolume.maximumHeight;\n  } else {\n    // Transform camera position and direction into the local coordinate system of the tileset\n    const transformLocal = Matrix4.inverseTransformation(root.computedTransform, scratchMatrix);\n    const ellipsoid = mapProjection.ellipsoid;\n    const boundingVolume = tileBoundingVolume.boundingVolume;\n    const centerLocal = Matrix4.multiplyByPoint(transformLocal, boundingVolume.center, scratchCenter);\n    if (Cartesian3.magnitude(centerLocal) > ellipsoid.minimumRadius) {\n      // The tileset is defined in WGS84. Approximate the minimum and maximum height.\n      const centerCartographic = Cartographic.fromCartesian(centerLocal, ellipsoid, scratchCartographic);\n      up = Cartesian3.normalize(camera.positionWC, scratchPositionNormal);\n      direction = camera.directionWC;\n      height = camera.positionCartographic.height;\n      minimumHeight = 0.0;\n      maximumHeight = centerCartographic.height * 2.0;\n    } else {\n      // The tileset is defined in local coordinates (z-up)\n      const positionLocal = Matrix4.multiplyByPoint(transformLocal, camera.positionWC, scratchPosition);\n      up = Cartesian3.UNIT_Z;\n      direction = Matrix4.multiplyByPointAsVector(transformLocal, camera.directionWC, scratchDirection);\n      direction = Cartesian3.normalize(direction, direction);\n      height = positionLocal.z;\n      if (tileBoundingVolume instanceof TileOrientedBoundingBox) {\n        // Assuming z-up, the last component stores the half-height of the box\n        const boxHeight = root._header.boundingVolume.box[11];\n        minimumHeight = centerLocal.z - boxHeight;\n        maximumHeight = centerLocal.z + boxHeight;\n      } else if (tileBoundingVolume instanceof TileBoundingSphere) {\n        const radius = boundingVolume.radius;\n        minimumHeight = centerLocal.z - radius;\n        maximumHeight = centerLocal.z + radius;\n      }\n    }\n  }\n  // The range where the density starts to lessen. Start at the quarter height of the tileset.\n  const heightFalloff = dynamicScreenSpaceErrorHeightFalloff;\n  const heightClose = minimumHeight + (maximumHeight - minimumHeight) * heightFalloff;\n  const heightFar = maximumHeight;\n  const t = clamp((height - heightClose) / (heightFar - heightClose), 0.0, 1.0);\n  // Increase density as the camera tilts towards the horizon\n  const dot = Math.abs(Cartesian3.dot(direction, up));\n  let horizonFactor = 1.0 - dot;\n  // Weaken the horizon factor as the camera height increases, implying the camera is further away from the tileset.\n  // The goal is to increase density for the \"street view\", not when viewing the tileset from a distance.\n  horizonFactor = horizonFactor * (1.0 - t);\n  return dynamicScreenSpaceErrorDensity * horizonFactor;\n}\nexport function fog(distanceToCamera, density) {\n  const scalar = distanceToCamera * density;\n  return 1.0 - Math.exp(-(scalar * scalar));\n}\nexport function getDynamicScreenSpaceError(tileset, distanceToCamera) {\n  if (tileset.dynamicScreenSpaceError && tileset.dynamicScreenSpaceErrorComputedDensity) {\n    const density = tileset.dynamicScreenSpaceErrorComputedDensity;\n    const factor = tileset.dynamicScreenSpaceErrorFactor;\n    // TODO: Refined screen space error that minimizes tiles in non-first-person\n    const dynamicError = fog(distanceToCamera, density) * factor;\n    return dynamicError;\n  }\n  return 0;\n}\nexport function getTiles3DScreenSpaceError(tile, frameState, useParentLodMetric) {\n  const tileset = tile.tileset;\n  const parentLodMetricValue = tile.parent && tile.parent.lodMetricValue || tile.lodMetricValue;\n  const lodMetricValue = useParentLodMetric ? parentLodMetricValue : tile.lodMetricValue;\n  // Leaf tiles do not have any error so save the computation\n  if (lodMetricValue === 0.0) {\n    return 0.0;\n  }\n  // TODO: Orthographic Frustum needs special treatment?\n  // this._getOrthograhicScreenSpaceError();\n  // Avoid divide by zero when viewer is inside the tile\n  const distance = Math.max(tile._distanceToCamera, 1e-7);\n  const {\n    height,\n    sseDenominator\n  } = frameState;\n  const {\n    viewDistanceScale\n  } = tileset.options;\n  let error = lodMetricValue * height * (viewDistanceScale || 1.0) / (distance * sseDenominator);\n  error -= getDynamicScreenSpaceError(tileset, distance);\n  return error;\n}","map":{"version":3,"names":["Matrix4","Vector3","clamp","scratchPositionNormal","scratchCartographic","scratchMatrix","scratchCenter","scratchPosition","scratchDirection","calculateDynamicScreenSpaceError","root","camera","mapProjection","options","dynamicScreenSpaceErrorHeightFalloff","dynamicScreenSpaceErrorDensity","up","direction","height","minimumHeight","maximumHeight","tileBoundingVolume","contentBoundingVolume","TileBoundingRegion","Cartesian3","normalize","positionWC","directionWC","positionCartographic","transformLocal","inverseTransformation","computedTransform","ellipsoid","boundingVolume","centerLocal","multiplyByPoint","center","magnitude","minimumRadius","centerCartographic","Cartographic","fromCartesian","positionLocal","UNIT_Z","multiplyByPointAsVector","z","TileOrientedBoundingBox","boxHeight","_header","box","TileBoundingSphere","radius","heightFalloff","heightClose","heightFar","t","dot","Math","abs","horizonFactor","fog","distanceToCamera","density","scalar","exp","getDynamicScreenSpaceError","tileset","dynamicScreenSpaceError","dynamicScreenSpaceErrorComputedDensity","factor","dynamicScreenSpaceErrorFactor","dynamicError","getTiles3DScreenSpaceError","tile","frameState","useParentLodMetric","parentLodMetricValue","parent","lodMetricValue","distance","max","_distanceToCamera","sseDenominator","viewDistanceScale","error"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/tiles/dist/tileset/helpers/tiles-3d-lod.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n// TODO - Dynamic screen space error provides an optimization when looking at\n// tilesets from above\n/* eslint-disable */\n// @ts-nocheck\nimport { Matrix4, Vector3, clamp } from '@math.gl/core';\nconst scratchPositionNormal = new Vector3();\nconst scratchCartographic = new Vector3();\nconst scratchMatrix = new Matrix4();\nconst scratchCenter = new Vector3();\nconst scratchPosition = new Vector3();\nconst scratchDirection = new Vector3();\n// eslint-disable-next-line max-statements, complexity\nexport function calculateDynamicScreenSpaceError(root, { camera, mapProjection }, options = {}) {\n    const { dynamicScreenSpaceErrorHeightFalloff = 0.25, dynamicScreenSpaceErrorDensity = 0.00278 } = options;\n    let up;\n    let direction;\n    let height;\n    let minimumHeight;\n    let maximumHeight;\n    const tileBoundingVolume = root.contentBoundingVolume;\n    if (tileBoundingVolume instanceof TileBoundingRegion) {\n        up = Cartesian3.normalize(camera.positionWC, scratchPositionNormal);\n        direction = camera.directionWC;\n        height = camera.positionCartographic.height;\n        minimumHeight = tileBoundingVolume.minimumHeight;\n        maximumHeight = tileBoundingVolume.maximumHeight;\n    }\n    else {\n        // Transform camera position and direction into the local coordinate system of the tileset\n        const transformLocal = Matrix4.inverseTransformation(root.computedTransform, scratchMatrix);\n        const ellipsoid = mapProjection.ellipsoid;\n        const boundingVolume = tileBoundingVolume.boundingVolume;\n        const centerLocal = Matrix4.multiplyByPoint(transformLocal, boundingVolume.center, scratchCenter);\n        if (Cartesian3.magnitude(centerLocal) > ellipsoid.minimumRadius) {\n            // The tileset is defined in WGS84. Approximate the minimum and maximum height.\n            const centerCartographic = Cartographic.fromCartesian(centerLocal, ellipsoid, scratchCartographic);\n            up = Cartesian3.normalize(camera.positionWC, scratchPositionNormal);\n            direction = camera.directionWC;\n            height = camera.positionCartographic.height;\n            minimumHeight = 0.0;\n            maximumHeight = centerCartographic.height * 2.0;\n        }\n        else {\n            // The tileset is defined in local coordinates (z-up)\n            const positionLocal = Matrix4.multiplyByPoint(transformLocal, camera.positionWC, scratchPosition);\n            up = Cartesian3.UNIT_Z;\n            direction = Matrix4.multiplyByPointAsVector(transformLocal, camera.directionWC, scratchDirection);\n            direction = Cartesian3.normalize(direction, direction);\n            height = positionLocal.z;\n            if (tileBoundingVolume instanceof TileOrientedBoundingBox) {\n                // Assuming z-up, the last component stores the half-height of the box\n                const boxHeight = root._header.boundingVolume.box[11];\n                minimumHeight = centerLocal.z - boxHeight;\n                maximumHeight = centerLocal.z + boxHeight;\n            }\n            else if (tileBoundingVolume instanceof TileBoundingSphere) {\n                const radius = boundingVolume.radius;\n                minimumHeight = centerLocal.z - radius;\n                maximumHeight = centerLocal.z + radius;\n            }\n        }\n    }\n    // The range where the density starts to lessen. Start at the quarter height of the tileset.\n    const heightFalloff = dynamicScreenSpaceErrorHeightFalloff;\n    const heightClose = minimumHeight + (maximumHeight - minimumHeight) * heightFalloff;\n    const heightFar = maximumHeight;\n    const t = clamp((height - heightClose) / (heightFar - heightClose), 0.0, 1.0);\n    // Increase density as the camera tilts towards the horizon\n    const dot = Math.abs(Cartesian3.dot(direction, up));\n    let horizonFactor = 1.0 - dot;\n    // Weaken the horizon factor as the camera height increases, implying the camera is further away from the tileset.\n    // The goal is to increase density for the \"street view\", not when viewing the tileset from a distance.\n    horizonFactor = horizonFactor * (1.0 - t);\n    return dynamicScreenSpaceErrorDensity * horizonFactor;\n}\nexport function fog(distanceToCamera, density) {\n    const scalar = distanceToCamera * density;\n    return 1.0 - Math.exp(-(scalar * scalar));\n}\nexport function getDynamicScreenSpaceError(tileset, distanceToCamera) {\n    if (tileset.dynamicScreenSpaceError && tileset.dynamicScreenSpaceErrorComputedDensity) {\n        const density = tileset.dynamicScreenSpaceErrorComputedDensity;\n        const factor = tileset.dynamicScreenSpaceErrorFactor;\n        // TODO: Refined screen space error that minimizes tiles in non-first-person\n        const dynamicError = fog(distanceToCamera, density) * factor;\n        return dynamicError;\n    }\n    return 0;\n}\nexport function getTiles3DScreenSpaceError(tile, frameState, useParentLodMetric) {\n    const tileset = tile.tileset;\n    const parentLodMetricValue = (tile.parent && tile.parent.lodMetricValue) || tile.lodMetricValue;\n    const lodMetricValue = useParentLodMetric ? parentLodMetricValue : tile.lodMetricValue;\n    // Leaf tiles do not have any error so save the computation\n    if (lodMetricValue === 0.0) {\n        return 0.0;\n    }\n    // TODO: Orthographic Frustum needs special treatment?\n    // this._getOrthograhicScreenSpaceError();\n    // Avoid divide by zero when viewer is inside the tile\n    const distance = Math.max(tile._distanceToCamera, 1e-7);\n    const { height, sseDenominator } = frameState;\n    const { viewDistanceScale } = tileset.options;\n    let error = (lodMetricValue * height * (viewDistanceScale || 1.0)) / (distance * sseDenominator);\n    error -= getDynamicScreenSpaceError(tileset, distance);\n    return error;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,OAAO,EAAEC,OAAO,EAAEC,KAAK,QAAQ,eAAe;AACvD,MAAMC,qBAAqB,GAAG,IAAIF,OAAO,CAAC,CAAC;AAC3C,MAAMG,mBAAmB,GAAG,IAAIH,OAAO,CAAC,CAAC;AACzC,MAAMI,aAAa,GAAG,IAAIL,OAAO,CAAC,CAAC;AACnC,MAAMM,aAAa,GAAG,IAAIL,OAAO,CAAC,CAAC;AACnC,MAAMM,eAAe,GAAG,IAAIN,OAAO,CAAC,CAAC;AACrC,MAAMO,gBAAgB,GAAG,IAAIP,OAAO,CAAC,CAAC;AACtC;AACA,OAAO,SAASQ,gCAAgCA,CAACC,IAAI,EAAE;EAAEC,MAAM;EAAEC;AAAc,CAAC,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EAC5F,MAAM;IAAEC,oCAAoC,GAAG,IAAI;IAAEC,8BAA8B,GAAG;EAAQ,CAAC,GAAGF,OAAO;EACzG,IAAIG,EAAE;EACN,IAAIC,SAAS;EACb,IAAIC,MAAM;EACV,IAAIC,aAAa;EACjB,IAAIC,aAAa;EACjB,MAAMC,kBAAkB,GAAGX,IAAI,CAACY,qBAAqB;EACrD,IAAID,kBAAkB,YAAYE,kBAAkB,EAAE;IAClDP,EAAE,GAAGQ,UAAU,CAACC,SAAS,CAACd,MAAM,CAACe,UAAU,EAAEvB,qBAAqB,CAAC;IACnEc,SAAS,GAAGN,MAAM,CAACgB,WAAW;IAC9BT,MAAM,GAAGP,MAAM,CAACiB,oBAAoB,CAACV,MAAM;IAC3CC,aAAa,GAAGE,kBAAkB,CAACF,aAAa;IAChDC,aAAa,GAAGC,kBAAkB,CAACD,aAAa;EACpD,CAAC,MACI;IACD;IACA,MAAMS,cAAc,GAAG7B,OAAO,CAAC8B,qBAAqB,CAACpB,IAAI,CAACqB,iBAAiB,EAAE1B,aAAa,CAAC;IAC3F,MAAM2B,SAAS,GAAGpB,aAAa,CAACoB,SAAS;IACzC,MAAMC,cAAc,GAAGZ,kBAAkB,CAACY,cAAc;IACxD,MAAMC,WAAW,GAAGlC,OAAO,CAACmC,eAAe,CAACN,cAAc,EAAEI,cAAc,CAACG,MAAM,EAAE9B,aAAa,CAAC;IACjG,IAAIkB,UAAU,CAACa,SAAS,CAACH,WAAW,CAAC,GAAGF,SAAS,CAACM,aAAa,EAAE;MAC7D;MACA,MAAMC,kBAAkB,GAAGC,YAAY,CAACC,aAAa,CAACP,WAAW,EAAEF,SAAS,EAAE5B,mBAAmB,CAAC;MAClGY,EAAE,GAAGQ,UAAU,CAACC,SAAS,CAACd,MAAM,CAACe,UAAU,EAAEvB,qBAAqB,CAAC;MACnEc,SAAS,GAAGN,MAAM,CAACgB,WAAW;MAC9BT,MAAM,GAAGP,MAAM,CAACiB,oBAAoB,CAACV,MAAM;MAC3CC,aAAa,GAAG,GAAG;MACnBC,aAAa,GAAGmB,kBAAkB,CAACrB,MAAM,GAAG,GAAG;IACnD,CAAC,MACI;MACD;MACA,MAAMwB,aAAa,GAAG1C,OAAO,CAACmC,eAAe,CAACN,cAAc,EAAElB,MAAM,CAACe,UAAU,EAAEnB,eAAe,CAAC;MACjGS,EAAE,GAAGQ,UAAU,CAACmB,MAAM;MACtB1B,SAAS,GAAGjB,OAAO,CAAC4C,uBAAuB,CAACf,cAAc,EAAElB,MAAM,CAACgB,WAAW,EAAEnB,gBAAgB,CAAC;MACjGS,SAAS,GAAGO,UAAU,CAACC,SAAS,CAACR,SAAS,EAAEA,SAAS,CAAC;MACtDC,MAAM,GAAGwB,aAAa,CAACG,CAAC;MACxB,IAAIxB,kBAAkB,YAAYyB,uBAAuB,EAAE;QACvD;QACA,MAAMC,SAAS,GAAGrC,IAAI,CAACsC,OAAO,CAACf,cAAc,CAACgB,GAAG,CAAC,EAAE,CAAC;QACrD9B,aAAa,GAAGe,WAAW,CAACW,CAAC,GAAGE,SAAS;QACzC3B,aAAa,GAAGc,WAAW,CAACW,CAAC,GAAGE,SAAS;MAC7C,CAAC,MACI,IAAI1B,kBAAkB,YAAY6B,kBAAkB,EAAE;QACvD,MAAMC,MAAM,GAAGlB,cAAc,CAACkB,MAAM;QACpChC,aAAa,GAAGe,WAAW,CAACW,CAAC,GAAGM,MAAM;QACtC/B,aAAa,GAAGc,WAAW,CAACW,CAAC,GAAGM,MAAM;MAC1C;IACJ;EACJ;EACA;EACA,MAAMC,aAAa,GAAGtC,oCAAoC;EAC1D,MAAMuC,WAAW,GAAGlC,aAAa,GAAG,CAACC,aAAa,GAAGD,aAAa,IAAIiC,aAAa;EACnF,MAAME,SAAS,GAAGlC,aAAa;EAC/B,MAAMmC,CAAC,GAAGrD,KAAK,CAAC,CAACgB,MAAM,GAAGmC,WAAW,KAAKC,SAAS,GAAGD,WAAW,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC;EAC7E;EACA,MAAMG,GAAG,GAAGC,IAAI,CAACC,GAAG,CAAClC,UAAU,CAACgC,GAAG,CAACvC,SAAS,EAAED,EAAE,CAAC,CAAC;EACnD,IAAI2C,aAAa,GAAG,GAAG,GAAGH,GAAG;EAC7B;EACA;EACAG,aAAa,GAAGA,aAAa,IAAI,GAAG,GAAGJ,CAAC,CAAC;EACzC,OAAOxC,8BAA8B,GAAG4C,aAAa;AACzD;AACA,OAAO,SAASC,GAAGA,CAACC,gBAAgB,EAAEC,OAAO,EAAE;EAC3C,MAAMC,MAAM,GAAGF,gBAAgB,GAAGC,OAAO;EACzC,OAAO,GAAG,GAAGL,IAAI,CAACO,GAAG,CAAC,EAAED,MAAM,GAAGA,MAAM,CAAC,CAAC;AAC7C;AACA,OAAO,SAASE,0BAA0BA,CAACC,OAAO,EAAEL,gBAAgB,EAAE;EAClE,IAAIK,OAAO,CAACC,uBAAuB,IAAID,OAAO,CAACE,sCAAsC,EAAE;IACnF,MAAMN,OAAO,GAAGI,OAAO,CAACE,sCAAsC;IAC9D,MAAMC,MAAM,GAAGH,OAAO,CAACI,6BAA6B;IACpD;IACA,MAAMC,YAAY,GAAGX,GAAG,CAACC,gBAAgB,EAAEC,OAAO,CAAC,GAAGO,MAAM;IAC5D,OAAOE,YAAY;EACvB;EACA,OAAO,CAAC;AACZ;AACA,OAAO,SAASC,0BAA0BA,CAACC,IAAI,EAAEC,UAAU,EAAEC,kBAAkB,EAAE;EAC7E,MAAMT,OAAO,GAAGO,IAAI,CAACP,OAAO;EAC5B,MAAMU,oBAAoB,GAAIH,IAAI,CAACI,MAAM,IAAIJ,IAAI,CAACI,MAAM,CAACC,cAAc,IAAKL,IAAI,CAACK,cAAc;EAC/F,MAAMA,cAAc,GAAGH,kBAAkB,GAAGC,oBAAoB,GAAGH,IAAI,CAACK,cAAc;EACtF;EACA,IAAIA,cAAc,KAAK,GAAG,EAAE;IACxB,OAAO,GAAG;EACd;EACA;EACA;EACA;EACA,MAAMC,QAAQ,GAAGtB,IAAI,CAACuB,GAAG,CAACP,IAAI,CAACQ,iBAAiB,EAAE,IAAI,CAAC;EACvD,MAAM;IAAE/D,MAAM;IAAEgE;EAAe,CAAC,GAAGR,UAAU;EAC7C,MAAM;IAAES;EAAkB,CAAC,GAAGjB,OAAO,CAACrD,OAAO;EAC7C,IAAIuE,KAAK,GAAIN,cAAc,GAAG5D,MAAM,IAAIiE,iBAAiB,IAAI,GAAG,CAAC,IAAKJ,QAAQ,GAAGG,cAAc,CAAC;EAChGE,KAAK,IAAInB,0BAA0B,CAACC,OAAO,EAAEa,QAAQ,CAAC;EACtD,OAAOK,KAAK;AAChB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}