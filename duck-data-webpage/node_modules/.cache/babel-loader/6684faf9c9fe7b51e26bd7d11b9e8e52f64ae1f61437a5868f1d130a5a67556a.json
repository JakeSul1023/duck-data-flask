{"ast":null,"code":"import { useContext, useMemo, useEffect } from 'react';\nimport { DeckGlContext } from \"./deckgl-context.js\";\nimport { log, _deepEqual as deepEqual } from '@deck.gl/core';\nexport function useWidget(WidgetClass, props) {\n  const context = useContext(DeckGlContext);\n  const {\n    widgets,\n    deck\n  } = context;\n  useEffect(() => {\n    // warn if the user supplied a pure-js widget, since it will be ignored\n    // NOTE: This effect runs once per widget. Context widgets and deck widget props are synced after first effect runs.\n    const internalWidgets = deck?.props.widgets;\n    if (widgets?.length && internalWidgets?.length && !deepEqual(internalWidgets, widgets, 1)) {\n      log.warn('\"widgets\" prop will be ignored because React widgets are in use.')();\n    }\n    return () => {\n      // Remove widget from context when it is unmounted\n      const index = widgets?.indexOf(widget);\n      if (index && index !== -1) {\n        widgets?.splice(index, 1);\n        deck?.setProps({\n          widgets\n        });\n      }\n    };\n  }, []);\n  const widget = useMemo(() => new WidgetClass(props), [WidgetClass]);\n  // Hook rebuilds widgets on every render: [] then [FirstWidget] then [FirstWidget, SecondWidget]\n  widgets?.push(widget);\n  widget.setProps(props);\n  useEffect(() => {\n    deck?.setProps({\n      widgets\n    });\n  }, [widgets]);\n  return widget;\n}\n//# sourceMappingURL=use-widget.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}