{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { GeoJsonLayer } from '@deck.gl/layers';\nimport { ClipExtension } from '@deck.gl/extensions';\nimport { Matrix4 } from '@math.gl/core';\nimport { MVTWorkerLoader } from '@loaders.gl/mvt';\nimport { binaryToGeojson } from '@loaders.gl/gis';\nimport { transform } from \"./coordinate-transform.js\";\nimport findIndexBinary from \"./find-index-binary.js\";\nimport TileLayer from \"../tile-layer/tile-layer.js\";\nimport { urlType, getURLFromTemplate, isGeoBoundingBox, isURLTemplate } from \"../tileset-2d/index.js\";\nconst WORLD_SIZE = 512;\nconst defaultProps = {\n  ...GeoJsonLayer.defaultProps,\n  data: urlType,\n  onDataLoad: {\n    type: 'function',\n    value: null,\n    optional: true,\n    compare: false\n  },\n  uniqueIdProperty: '',\n  highlightedFeatureId: null,\n  loaders: [MVTWorkerLoader],\n  binary: true\n};\n/** Render data formatted as [Mapbox Vector Tiles](https://docs.mapbox.com/vector-tiles/specification/). */\nclass MVTLayer extends TileLayer {\n  initializeState() {\n    super.initializeState();\n    // GlobeView doesn't work well with binary data\n    const binary = this.context.viewport.resolution !== undefined ? false : this.props.binary;\n    this.setState({\n      binary,\n      data: null,\n      tileJSON: null,\n      hoveredFeatureId: null,\n      hoveredFeatureLayerName: null\n    });\n  }\n  get isLoaded() {\n    return Boolean(this.state?.data && super.isLoaded);\n  }\n  updateState({\n    props,\n    oldProps,\n    context,\n    changeFlags\n  }) {\n    if (changeFlags.dataChanged) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._updateTileData();\n    }\n    if (this.state?.data) {\n      super.updateState({\n        props,\n        oldProps,\n        context,\n        changeFlags\n      });\n      this._setWGS84PropertyForTiles();\n    }\n    const {\n      highlightColor\n    } = props;\n    if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {\n      this.setState({\n        highlightColor\n      });\n    }\n  }\n  /* eslint-disable complexity */\n  async _updateTileData() {\n    let data = this.props.data;\n    let tileJSON = null;\n    if (typeof data === 'string' && !isURLTemplate(data)) {\n      const {\n        onDataLoad,\n        fetch\n      } = this.props;\n      this.setState({\n        data: null,\n        tileJSON: null\n      });\n      try {\n        tileJSON = await fetch(data, {\n          propName: 'data',\n          layer: this,\n          loaders: []\n        });\n      } catch (error) {\n        this.raiseError(error, 'loading TileJSON');\n        data = null;\n      }\n      if (onDataLoad) {\n        onDataLoad(tileJSON, {\n          propName: 'data',\n          layer: this\n        });\n      }\n    } else if (data && typeof data === 'object' && 'tilejson' in data) {\n      tileJSON = data;\n    }\n    if (tileJSON) {\n      data = tileJSON.tiles;\n    }\n    this.setState({\n      data,\n      tileJSON\n    });\n  }\n  _getTilesetOptions() {\n    const opts = super._getTilesetOptions();\n    const tileJSON = this.state.tileJSON;\n    const {\n      minZoom,\n      maxZoom\n    } = this.props;\n    if (tileJSON) {\n      if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > minZoom) {\n        opts.minZoom = tileJSON.minzoom;\n      }\n      if (Number.isFinite(tileJSON.maxzoom) && (!Number.isFinite(maxZoom) || tileJSON.maxzoom < maxZoom)) {\n        opts.maxZoom = tileJSON.maxzoom;\n      }\n    }\n    return opts;\n  }\n  /* eslint-disable complexity */\n  renderLayers() {\n    if (!this.state?.data) return null;\n    return super.renderLayers();\n  }\n  getTileData(loadProps) {\n    const {\n      data,\n      binary\n    } = this.state;\n    const {\n      index,\n      signal\n    } = loadProps;\n    const url = getURLFromTemplate(data, loadProps);\n    if (!url) {\n      return Promise.reject('Invalid URL');\n    }\n    let loadOptions = this.getLoadOptions();\n    const {\n      fetch\n    } = this.props;\n    loadOptions = {\n      ...loadOptions,\n      mimeType: 'application/x-protobuf',\n      mvt: {\n        ...loadOptions?.mvt,\n        coordinates: this.context.viewport.resolution ? 'wgs84' : 'local',\n        tileIndex: index\n        // Local worker debug\n        // workerUrl: `modules/mvt/dist/mvt-loader.worker.js`\n        // Set worker to null to skip web workers\n        // workerUrl: null\n      },\n      gis: binary ? {\n        format: 'binary'\n      } : {}\n    };\n    return fetch(url, {\n      propName: 'data',\n      layer: this,\n      loadOptions,\n      signal\n    });\n  }\n  renderSubLayers(props) {\n    const {\n      x,\n      y,\n      z\n    } = props.tile.index;\n    const worldScale = Math.pow(2, z);\n    const xScale = WORLD_SIZE / worldScale;\n    const yScale = -xScale;\n    const xOffset = WORLD_SIZE * x / worldScale;\n    const yOffset = WORLD_SIZE * (1 - y / worldScale);\n    const modelMatrix = new Matrix4().scale([xScale, yScale, 1]);\n    props.autoHighlight = false;\n    if (!this.context.viewport.resolution) {\n      props.modelMatrix = modelMatrix;\n      props.coordinateOrigin = [xOffset, yOffset, 0];\n      props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;\n      props.extensions = [...(props.extensions || []), new ClipExtension()];\n    }\n    const subLayers = super.renderSubLayers(props);\n    if (this.state.binary && !(subLayers instanceof GeoJsonLayer)) {\n      log.warn('renderSubLayers() must return GeoJsonLayer when using binary:true')();\n    }\n    return subLayers;\n  }\n  _updateAutoHighlight(info) {\n    const {\n      uniqueIdProperty\n    } = this.props;\n    const {\n      hoveredFeatureId,\n      hoveredFeatureLayerName\n    } = this.state;\n    const hoveredFeature = info.object;\n    let newHoveredFeatureId = null;\n    let newHoveredFeatureLayerName = null;\n    if (hoveredFeature) {\n      newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);\n      newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);\n    }\n    let {\n      highlightColor\n    } = this.props;\n    if (typeof highlightColor === 'function') {\n      highlightColor = highlightColor(info);\n    }\n    if (hoveredFeatureId !== newHoveredFeatureId || hoveredFeatureLayerName !== newHoveredFeatureLayerName) {\n      this.setState({\n        highlightColor,\n        hoveredFeatureId: newHoveredFeatureId,\n        hoveredFeatureLayerName: newHoveredFeatureLayerName\n      });\n    }\n  }\n  _isWGS84() {\n    return Boolean(this.context.viewport.resolution);\n  }\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    if (this.state.binary && info.index !== -1) {\n      const {\n        data\n      } = params.sourceLayer.props;\n      info.object = binaryToGeojson(data, {\n        globalFeatureId: info.index\n      });\n    }\n    if (info.object && !this._isWGS84()) {\n      info.object = transformTileCoordsToWGS84(info.object, info.tile.bbox,\n      // eslint-disable-line\n      this.context.viewport);\n    }\n    return info;\n  }\n  getSubLayerPropsByTile(tile) {\n    return {\n      highlightedObjectIndex: this.getHighlightedObjectIndex(tile),\n      highlightColor: this.state.highlightColor\n    };\n  }\n  getHighlightedObjectIndex(tile) {\n    const {\n      hoveredFeatureId,\n      hoveredFeatureLayerName,\n      binary\n    } = this.state;\n    const {\n      uniqueIdProperty,\n      highlightedFeatureId\n    } = this.props;\n    const data = tile.content;\n    const isHighlighted = isFeatureIdDefined(highlightedFeatureId);\n    const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;\n    if (!isFeatureIdPresent) {\n      return -1;\n    }\n    const featureIdToHighlight = isHighlighted ? highlightedFeatureId : hoveredFeatureId;\n    // Iterable data\n    if (Array.isArray(data)) {\n      return data.findIndex(feature => {\n        const isMatchingId = getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;\n        const isMatchingLayer = isHighlighted || getFeatureLayerName(feature) === hoveredFeatureLayerName;\n        return isMatchingId && isMatchingLayer;\n      });\n      // Non-iterable data\n    } else if (data && binary) {\n      // Get the feature index of the selected item to highlight\n      return findIndexBinary(data, uniqueIdProperty, featureIdToHighlight, isHighlighted ? '' : hoveredFeatureLayerName);\n    }\n    return -1;\n  }\n  _pickObjects(maxObjects) {\n    const {\n      deck,\n      viewport\n    } = this.context;\n    const width = viewport.width;\n    const height = viewport.height;\n    const x = viewport.x;\n    const y = viewport.y;\n    const layerIds = [this.id];\n    return deck.pickObjects({\n      x,\n      y,\n      width,\n      height,\n      layerIds,\n      maxObjects\n    });\n  }\n  /** Get the rendered features in the current viewport. */\n  getRenderedFeatures(maxFeatures = null) {\n    const features = this._pickObjects(maxFeatures);\n    const featureCache = new Set();\n    const renderedFeatures = [];\n    for (const f of features) {\n      const featureId = getFeatureUniqueId(f.object, this.props.uniqueIdProperty);\n      if (featureId === undefined) {\n        // we have no id for the feature, we just add to the list\n        renderedFeatures.push(f.object);\n      } else if (!featureCache.has(featureId)) {\n        // Add removing duplicates\n        featureCache.add(featureId);\n        renderedFeatures.push(f.object);\n      }\n    }\n    return renderedFeatures;\n  }\n  _setWGS84PropertyForTiles() {\n    const propName = 'dataInWGS84';\n    const tileset = this.state.tileset;\n    // @ts-expect-error selectedTiles are always initialized when tile is being processed\n    tileset.selectedTiles.forEach(tile => {\n      if (!tile.hasOwnProperty(propName)) {\n        // eslint-disable-next-line accessor-pairs\n        Object.defineProperty(tile, propName, {\n          get: () => {\n            // Still loading or encountered an error\n            if (!tile.content) {\n              return null;\n            }\n            if (this.state.binary && Array.isArray(tile.content) && !tile.content.length) {\n              // TODO: @loaders.gl/mvt returns [] when no content. It should return a valid empty binary.\n              // https://github.com/visgl/loaders.gl/pull/1137\n              return [];\n            }\n            const {\n              bbox\n            } = tile;\n            if (tile._contentWGS84 === undefined && isGeoBoundingBox(bbox)) {\n              // Create a cache to transform only once\n              const content = this.state.binary ? binaryToGeojson(tile.content) : tile.content;\n              tile._contentWGS84 = content.map(feature => transformTileCoordsToWGS84(feature, bbox, this.context.viewport));\n            }\n            return tile._contentWGS84;\n          }\n        });\n      }\n    });\n  }\n}\nMVTLayer.layerName = 'MVTLayer';\nMVTLayer.defaultProps = defaultProps;\nexport default MVTLayer;\nfunction getFeatureUniqueId(feature, uniqueIdProperty) {\n  if (feature.properties && uniqueIdProperty) {\n    return feature.properties[uniqueIdProperty];\n  }\n  if ('id' in feature) {\n    return feature.id;\n  }\n  return undefined;\n}\nfunction getFeatureLayerName(feature) {\n  return feature.properties?.layerName || null;\n}\nfunction isFeatureIdDefined(value) {\n  return value !== undefined && value !== null && value !== '';\n}\nfunction transformTileCoordsToWGS84(object, bbox, viewport) {\n  const feature = {\n    ...object,\n    geometry: {\n      type: object.geometry.type\n    }\n  };\n  // eslint-disable-next-line accessor-pairs\n  Object.defineProperty(feature.geometry, 'coordinates', {\n    get: () => {\n      const wgs84Geom = transform(object.geometry, bbox, viewport);\n      return wgs84Geom.coordinates;\n    }\n  });\n  return feature;\n}","map":{"version":3,"names":["log","COORDINATE_SYSTEM","GeoJsonLayer","ClipExtension","Matrix4","MVTWorkerLoader","binaryToGeojson","transform","findIndexBinary","TileLayer","urlType","getURLFromTemplate","isGeoBoundingBox","isURLTemplate","WORLD_SIZE","defaultProps","data","onDataLoad","type","value","optional","compare","uniqueIdProperty","highlightedFeatureId","loaders","binary","MVTLayer","initializeState","context","viewport","resolution","undefined","props","setState","tileJSON","hoveredFeatureId","hoveredFeatureLayerName","isLoaded","Boolean","state","updateState","oldProps","changeFlags","dataChanged","_updateTileData","_setWGS84PropertyForTiles","highlightColor","Array","isArray","fetch","propName","layer","error","raiseError","tiles","_getTilesetOptions","opts","minZoom","maxZoom","Number","isFinite","minzoom","maxzoom","renderLayers","getTileData","loadProps","index","signal","url","Promise","reject","loadOptions","getLoadOptions","mimeType","mvt","coordinates","tileIndex","gis","format","renderSubLayers","x","y","z","tile","worldScale","Math","pow","xScale","yScale","xOffset","yOffset","modelMatrix","scale","autoHighlight","coordinateOrigin","coordinateSystem","CARTESIAN","extensions","subLayers","warn","_updateAutoHighlight","info","hoveredFeature","object","newHoveredFeatureId","newHoveredFeatureLayerName","getFeatureUniqueId","getFeatureLayerName","_isWGS84","getPickingInfo","params","sourceLayer","globalFeatureId","transformTileCoordsToWGS84","bbox","getSubLayerPropsByTile","highlightedObjectIndex","getHighlightedObjectIndex","content","isHighlighted","isFeatureIdDefined","isFeatureIdPresent","featureIdToHighlight","findIndex","feature","isMatchingId","isMatchingLayer","_pickObjects","maxObjects","deck","width","height","layerIds","id","pickObjects","getRenderedFeatures","maxFeatures","features","featureCache","Set","renderedFeatures","f","featureId","push","has","add","tileset","selectedTiles","forEach","hasOwnProperty","Object","defineProperty","get","length","_contentWGS84","map","layerName","properties","geometry","wgs84Geom"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\geo-layers\\src\\mvt-layer\\mvt-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  Layer,\n  LayersList,\n  log,\n  PickingInfo,\n  UpdateParameters,\n  GetPickingInfoParams,\n  Viewport,\n  COORDINATE_SYSTEM,\n  DefaultProps\n} from '@deck.gl/core';\nimport {GeoJsonLayer, GeoJsonLayerProps} from '@deck.gl/layers';\nimport {ClipExtension} from '@deck.gl/extensions';\n\nimport {Matrix4} from '@math.gl/core';\nimport {MVTWorkerLoader} from '@loaders.gl/mvt';\nimport {binaryToGeojson} from '@loaders.gl/gis';\n\nimport type {Loader} from '@loaders.gl/loader-utils';\nimport type {BinaryFeatureCollection} from '@loaders.gl/schema';\nimport type {Feature, Geometry} from 'geojson';\n\nimport {transform} from './coordinate-transform';\nimport findIndexBinary from './find-index-binary';\n\nimport TileLayer, {TileLayerPickingInfo, TileLayerProps} from '../tile-layer/tile-layer';\n\nimport type {Tileset2DProps, TileLoadProps, GeoBoundingBox} from '../tileset-2d/index';\nimport {\n  urlType,\n  Tileset2D,\n  Tile2DHeader,\n  getURLFromTemplate,\n  URLTemplate,\n  isGeoBoundingBox,\n  isURLTemplate\n} from '../tileset-2d/index';\n\nconst WORLD_SIZE = 512;\n\nconst defaultProps: DefaultProps<MVTLayerProps> = {\n  ...GeoJsonLayer.defaultProps,\n  data: urlType,\n  onDataLoad: {type: 'function', value: null, optional: true, compare: false},\n  uniqueIdProperty: '',\n  highlightedFeatureId: null,\n  loaders: [MVTWorkerLoader],\n  binary: true\n};\n\nexport type TileJson = {\n  tilejson: string;\n  tiles: string[];\n  // eslint-disable-next-line camelcase\n  vector_layers: any[];\n  attribution?: string;\n  scheme?: string;\n  maxzoom?: number;\n  minzoom?: number;\n  version?: string;\n};\n\ntype ParsedMvtTile = Feature[] | BinaryFeatureCollection;\n\nexport type MVTLayerPickingInfo<FeaturePropertiesT = {}> = TileLayerPickingInfo<\n  ParsedMvtTile,\n  PickingInfo<Feature<Geometry, FeaturePropertiesT>>\n>;\n\n/** All props supported by the MVTLayer */\nexport type MVTLayerProps<FeaturePropertiesT = unknown> = _MVTLayerProps<FeaturePropertiesT> &\n  Omit<TileLayerProps<ParsedMvtTile>, 'data'>;\n\n/** Props added by the MVTLayer  */\nexport type _MVTLayerProps<FeaturePropertiesT> = Omit<\n  GeoJsonLayerProps<FeaturePropertiesT>,\n  'data'\n> & {\n  data: TileJson | URLTemplate;\n\n  /** Called if `data` is a TileJSON URL when it is successfully fetched. */\n  onDataLoad?: ((tilejson: TileJson | null) => void) | null;\n\n  /** Needed for highlighting a feature split across two or more tiles. */\n  uniqueIdProperty?: string;\n\n  /** A feature with ID corresponding to the supplied value will be highlighted. */\n  highlightedFeatureId?: string | number | null;\n\n  /**\n   * Use tile data in binary format.\n   *\n   * @default true\n   */\n  binary?: boolean;\n\n  /**\n   * Loaders used to transform tiles into `data` property passed to `renderSubLayers`.\n   *\n   * @default [MVTWorkerLoader] from `@loaders.gl/mvt`\n   */\n  loaders?: Loader[];\n};\n\ntype ContentWGS84Cache = {_contentWGS84?: Feature[]};\n\n/** Render data formatted as [Mapbox Vector Tiles](https://docs.mapbox.com/vector-tiles/specification/). */\nexport default class MVTLayer<\n  FeaturePropertiesT = any,\n  ExtraProps extends {} = {}\n> extends TileLayer<ParsedMvtTile, Required<_MVTLayerProps<FeaturePropertiesT>> & ExtraProps> {\n  static layerName = 'MVTLayer';\n  static defaultProps = defaultProps;\n\n  state!: TileLayer<ParsedMvtTile>['state'] & {\n    binary: boolean;\n    data: URLTemplate;\n    tileJSON: TileJson | null;\n    highlightColor?: number[];\n    hoveredFeatureId: number | string | null;\n    hoveredFeatureLayerName: string | null;\n  };\n\n  initializeState(): void {\n    super.initializeState();\n    // GlobeView doesn't work well with binary data\n    const binary = this.context.viewport.resolution !== undefined ? false : this.props.binary;\n    this.setState({\n      binary,\n      data: null,\n      tileJSON: null,\n      hoveredFeatureId: null,\n      hoveredFeatureLayerName: null\n    });\n  }\n\n  get isLoaded(): boolean {\n    return Boolean(this.state?.data && super.isLoaded);\n  }\n\n  updateState({props, oldProps, context, changeFlags}: UpdateParameters<this>) {\n    if (changeFlags.dataChanged) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._updateTileData();\n    }\n\n    if (this.state?.data) {\n      super.updateState({props, oldProps, context, changeFlags});\n      this._setWGS84PropertyForTiles();\n    }\n    const {highlightColor} = props;\n    if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {\n      this.setState({highlightColor});\n    }\n  }\n\n  /* eslint-disable complexity */\n  private async _updateTileData(): Promise<void> {\n    let data = this.props.data;\n    let tileJSON: TileJson | null = null;\n\n    if (typeof data === 'string' && !isURLTemplate(data)) {\n      const {onDataLoad, fetch} = this.props;\n      this.setState({data: null, tileJSON: null});\n      try {\n        tileJSON = await fetch(data, {propName: 'data', layer: this, loaders: []});\n      } catch (error: any) {\n        this.raiseError(error, 'loading TileJSON');\n        data = null;\n      }\n\n      if (onDataLoad) {\n        onDataLoad(tileJSON, {propName: 'data', layer: this});\n      }\n    } else if (data && typeof data === 'object' && 'tilejson' in data) {\n      tileJSON = data;\n    }\n\n    if (tileJSON) {\n      data = tileJSON.tiles;\n    }\n\n    this.setState({data, tileJSON});\n  }\n\n  _getTilesetOptions(): Tileset2DProps {\n    const opts = super._getTilesetOptions();\n    const tileJSON: TileJson | null = this.state.tileJSON;\n    const {minZoom, maxZoom} = this.props;\n\n    if (tileJSON) {\n      if (Number.isFinite(tileJSON.minzoom) && (tileJSON.minzoom as number) > (minZoom as number)) {\n        opts.minZoom = tileJSON.minzoom;\n      }\n\n      if (\n        Number.isFinite(tileJSON.maxzoom) &&\n        (!Number.isFinite(maxZoom) || (tileJSON.maxzoom as number) < (maxZoom as number))\n      ) {\n        opts.maxZoom = tileJSON.maxzoom;\n      }\n    }\n    return opts;\n  }\n\n  /* eslint-disable complexity */\n\n  renderLayers(): Layer | null | LayersList {\n    if (!this.state?.data) return null;\n    return super.renderLayers();\n  }\n\n  getTileData(loadProps: TileLoadProps): Promise<ParsedMvtTile> {\n    const {data, binary} = this.state;\n    const {index, signal} = loadProps;\n\n    const url = getURLFromTemplate(data, loadProps);\n    if (!url) {\n      return Promise.reject('Invalid URL');\n    }\n    let loadOptions = this.getLoadOptions();\n    const {fetch} = this.props;\n    loadOptions = {\n      ...loadOptions,\n      mimeType: 'application/x-protobuf',\n      mvt: {\n        ...loadOptions?.mvt,\n        coordinates: this.context.viewport.resolution ? 'wgs84' : 'local',\n        tileIndex: index\n        // Local worker debug\n        // workerUrl: `modules/mvt/dist/mvt-loader.worker.js`\n        // Set worker to null to skip web workers\n        // workerUrl: null\n      },\n      gis: binary ? {format: 'binary'} : {}\n    };\n    return fetch(url, {propName: 'data', layer: this, loadOptions, signal});\n  }\n\n  renderSubLayers(\n    props: TileLayer['props'] & {\n      id: string;\n      data: ParsedMvtTile;\n      _offset: number;\n      tile: Tile2DHeader<ParsedMvtTile>;\n    }\n  ): Layer | null | LayersList {\n    const {x, y, z} = props.tile.index;\n    const worldScale = Math.pow(2, z);\n\n    const xScale = WORLD_SIZE / worldScale;\n    const yScale = -xScale;\n\n    const xOffset = (WORLD_SIZE * x) / worldScale;\n    const yOffset = WORLD_SIZE * (1 - y / worldScale);\n\n    const modelMatrix = new Matrix4().scale([xScale, yScale, 1]);\n\n    props.autoHighlight = false;\n\n    if (!this.context.viewport.resolution) {\n      props.modelMatrix = modelMatrix;\n      props.coordinateOrigin = [xOffset, yOffset, 0];\n      props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;\n      props.extensions = [...(props.extensions || []), new ClipExtension()];\n    }\n\n    const subLayers = super.renderSubLayers(props);\n\n    if (this.state.binary && !(subLayers instanceof GeoJsonLayer)) {\n      log.warn('renderSubLayers() must return GeoJsonLayer when using binary:true')();\n    }\n\n    return subLayers;\n  }\n\n  protected _updateAutoHighlight(info: PickingInfo): void {\n    const {uniqueIdProperty} = this.props;\n\n    const {hoveredFeatureId, hoveredFeatureLayerName} = this.state;\n    const hoveredFeature = info.object;\n    let newHoveredFeatureId: string | number | null = null;\n    let newHoveredFeatureLayerName: string | null = null;\n\n    if (hoveredFeature) {\n      newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);\n      newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);\n    }\n    let {highlightColor} = this.props;\n    if (typeof highlightColor === 'function') {\n      highlightColor = highlightColor(info);\n    }\n\n    if (\n      hoveredFeatureId !== newHoveredFeatureId ||\n      hoveredFeatureLayerName !== newHoveredFeatureLayerName\n    ) {\n      this.setState({\n        highlightColor,\n        hoveredFeatureId: newHoveredFeatureId,\n        hoveredFeatureLayerName: newHoveredFeatureLayerName\n      });\n    }\n  }\n\n  protected _isWGS84(): boolean {\n    return Boolean(this.context.viewport.resolution);\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): MVTLayerPickingInfo<FeaturePropertiesT> {\n    const info = super.getPickingInfo(params);\n\n    if (this.state.binary && info.index !== -1) {\n      const {data} = params.sourceLayer!.props;\n      info.object = binaryToGeojson(data as BinaryFeatureCollection, {\n        globalFeatureId: info.index\n      }) as Feature;\n    }\n    if (info.object && !this._isWGS84()) {\n      info.object = transformTileCoordsToWGS84(\n        info.object,\n        info.tile!.bbox as GeoBoundingBox, // eslint-disable-line\n        this.context.viewport\n      );\n    }\n\n    return info;\n  }\n\n  getSubLayerPropsByTile(tile: Tile2DHeader<ParsedMvtTile>): Record<string, any> {\n    return {\n      highlightedObjectIndex: this.getHighlightedObjectIndex(tile),\n      highlightColor: this.state.highlightColor\n    };\n  }\n\n  private getHighlightedObjectIndex(tile: Tile2DHeader<ParsedMvtTile>): number {\n    const {hoveredFeatureId, hoveredFeatureLayerName, binary} = this.state;\n    const {uniqueIdProperty, highlightedFeatureId} = this.props;\n    const data = tile.content;\n\n    const isHighlighted = isFeatureIdDefined(highlightedFeatureId);\n    const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;\n\n    if (!isFeatureIdPresent) {\n      return -1;\n    }\n\n    const featureIdToHighlight = isHighlighted ? highlightedFeatureId! : hoveredFeatureId!;\n\n    // Iterable data\n    if (Array.isArray(data)) {\n      return data.findIndex(feature => {\n        const isMatchingId = getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;\n        const isMatchingLayer =\n          isHighlighted || getFeatureLayerName(feature) === hoveredFeatureLayerName;\n        return isMatchingId && isMatchingLayer;\n      });\n\n      // Non-iterable data\n    } else if (data && binary) {\n      // Get the feature index of the selected item to highlight\n      return findIndexBinary(\n        data,\n        uniqueIdProperty,\n        featureIdToHighlight,\n        isHighlighted ? '' : hoveredFeatureLayerName!\n      );\n    }\n\n    return -1;\n  }\n\n  private _pickObjects(maxObjects: number | null): PickingInfo[] {\n    const {deck, viewport} = this.context;\n    const width = viewport.width;\n    const height = viewport.height;\n    const x = viewport.x;\n    const y = viewport.y;\n    const layerIds = [this.id];\n    return deck!.pickObjects({x, y, width, height, layerIds, maxObjects});\n  }\n\n  /** Get the rendered features in the current viewport. */\n  getRenderedFeatures(maxFeatures: number | null = null): Feature[] {\n    const features = this._pickObjects(maxFeatures);\n    const featureCache = new Set();\n    const renderedFeatures: Feature[] = [];\n\n    for (const f of features) {\n      const featureId = getFeatureUniqueId(f.object, this.props.uniqueIdProperty);\n\n      if (featureId === undefined) {\n        // we have no id for the feature, we just add to the list\n        renderedFeatures.push(f.object as Feature);\n      } else if (!featureCache.has(featureId)) {\n        // Add removing duplicates\n        featureCache.add(featureId);\n        renderedFeatures.push(f.object as Feature);\n      }\n    }\n\n    return renderedFeatures;\n  }\n\n  private _setWGS84PropertyForTiles(): void {\n    const propName = 'dataInWGS84';\n    const tileset: Tileset2D = this.state.tileset!;\n\n    // @ts-expect-error selectedTiles are always initialized when tile is being processed\n    tileset.selectedTiles.forEach((tile: Tile2DHeader & ContentWGS84Cache) => {\n      if (!tile.hasOwnProperty(propName)) {\n        // eslint-disable-next-line accessor-pairs\n        Object.defineProperty(tile, propName, {\n          get: () => {\n            // Still loading or encountered an error\n            if (!tile.content) {\n              return null;\n            }\n\n            if (this.state.binary && Array.isArray(tile.content) && !tile.content.length) {\n              // TODO: @loaders.gl/mvt returns [] when no content. It should return a valid empty binary.\n              // https://github.com/visgl/loaders.gl/pull/1137\n              return [];\n            }\n\n            const {bbox} = tile;\n            if (tile._contentWGS84 === undefined && isGeoBoundingBox(bbox)) {\n              // Create a cache to transform only once\n\n              const content = this.state.binary ? binaryToGeojson(tile.content) : tile.content;\n              tile._contentWGS84 = content.map(feature =>\n                transformTileCoordsToWGS84(feature, bbox, this.context.viewport)\n              );\n            }\n            return tile._contentWGS84;\n          }\n        });\n      }\n    });\n  }\n}\n\nfunction getFeatureUniqueId(feature: Feature, uniqueIdProperty: string | undefined) {\n  if (feature.properties && uniqueIdProperty) {\n    return feature.properties[uniqueIdProperty];\n  }\n\n  if ('id' in feature) {\n    return feature.id;\n  }\n\n  return undefined;\n}\n\nfunction getFeatureLayerName(feature: Feature): string | null {\n  return feature.properties?.layerName || null;\n}\n\nfunction isFeatureIdDefined(value: unknown): boolean {\n  return value !== undefined && value !== null && value !== '';\n}\n\nfunction transformTileCoordsToWGS84(\n  object: Feature,\n  bbox: GeoBoundingBox,\n  viewport: Viewport\n): Feature {\n  const feature = {\n    ...object,\n    geometry: {\n      type: object.geometry.type\n    }\n  };\n\n  // eslint-disable-next-line accessor-pairs\n  Object.defineProperty(feature.geometry, 'coordinates', {\n    get: () => {\n      const wgs84Geom = transform(object.geometry, bbox, viewport);\n      return wgs84Geom.coordinates;\n    }\n  });\n\n  return feature as Feature;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}