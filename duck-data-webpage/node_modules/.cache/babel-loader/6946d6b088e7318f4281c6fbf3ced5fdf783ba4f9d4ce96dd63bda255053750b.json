{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { RenderPipeline, ComputePipeline } from '@luma.gl/core';\n/**\n * Efficiently creates / caches pipelines\n */\nexport class PipelineFactory {\n  static defaultProps = {\n    ...RenderPipeline.defaultProps\n  };\n  /** Get the singleton default pipeline factory for the specified device */\n  static getDefaultPipelineFactory(device) {\n    device._lumaData.defaultPipelineFactory = device._lumaData.defaultPipelineFactory || new PipelineFactory(device);\n    return device._lumaData.defaultPipelineFactory;\n  }\n  device;\n  destroyPolicy;\n  _hashCounter = 0;\n  _hashes = {};\n  _renderPipelineCache = {};\n  _computePipelineCache = {};\n  constructor(device) {\n    this.device = device;\n    this.destroyPolicy = device.props._factoryDestroyPolicy;\n  }\n  /** Return a RenderPipeline matching props. Reuses a similar pipeline if already created. */\n  createRenderPipeline(props) {\n    const allProps = {\n      ...RenderPipeline.defaultProps,\n      ...props\n    };\n    const hash = this._hashRenderPipeline(allProps);\n    if (!this._renderPipelineCache[hash]) {\n      const pipeline = this.device.createRenderPipeline({\n        ...allProps,\n        id: allProps.id ? `${allProps.id}-cached` : undefined\n      });\n      pipeline.hash = hash;\n      this._renderPipelineCache[hash] = {\n        pipeline,\n        useCount: 0\n      };\n    }\n    this._renderPipelineCache[hash].useCount++;\n    return this._renderPipelineCache[hash].pipeline;\n  }\n  createComputePipeline(props) {\n    const allProps = {\n      ...ComputePipeline.defaultProps,\n      ...props\n    };\n    const hash = this._hashComputePipeline(allProps);\n    if (!this._computePipelineCache[hash]) {\n      const pipeline = this.device.createComputePipeline({\n        ...allProps,\n        id: allProps.id ? `${allProps.id}-cached` : undefined\n      });\n      pipeline.hash = hash;\n      this._computePipelineCache[hash] = {\n        pipeline,\n        useCount: 0\n      };\n    }\n    this._computePipelineCache[hash].useCount++;\n    return this._computePipelineCache[hash].pipeline;\n  }\n  release(pipeline) {\n    const hash = pipeline.hash;\n    const cache = pipeline instanceof ComputePipeline ? this._computePipelineCache : this._renderPipelineCache;\n    cache[hash].useCount--;\n    if (cache[hash].useCount === 0) {\n      if (this.destroyPolicy === 'unused') {\n        cache[hash].pipeline.destroy();\n        delete cache[hash];\n      }\n    }\n  }\n  // PRIVATE\n  _hashComputePipeline(props) {\n    const shaderHash = this._getHash(props.shader.source);\n    return `${shaderHash}`;\n  }\n  /** Calculate a hash based on all the inputs for a render pipeline */\n  _hashRenderPipeline(props) {\n    const vsHash = props.vs ? this._getHash(props.vs.source) : 0;\n    const fsHash = props.fs ? this._getHash(props.fs.source) : 0;\n    // WebGL specific\n    // const {varyings = [], bufferMode = {}} = props;\n    // const varyingHashes = varyings.map((v) => this._getHash(v));\n    const varyingHash = '-'; // `${varyingHashes.join('/')}B${bufferMode}`\n    const bufferLayoutHash = this._getHash(JSON.stringify(props.bufferLayout));\n    switch (this.device.type) {\n      case 'webgl':\n        // WebGL is more dynamic\n        return `${vsHash}/${fsHash}V${varyingHash}BL${bufferLayoutHash}`;\n      default:\n        // On WebGPU we need to rebuild the pipeline if topology, parameters or bufferLayout change\n        const parameterHash = this._getHash(JSON.stringify(props.parameters));\n        // TODO - Can json.stringify() generate different strings for equivalent objects if order of params is different?\n        // create a deepHash() to deduplicate?\n        return `${vsHash}/${fsHash}V${varyingHash}T${props.topology}P${parameterHash}BL${bufferLayoutHash}`;\n    }\n  }\n  _getHash(key) {\n    if (this._hashes[key] === undefined) {\n      this._hashes[key] = this._hashCounter++;\n    }\n    return this._hashes[key];\n  }\n}\n//# sourceMappingURL=pipeline-factory.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}