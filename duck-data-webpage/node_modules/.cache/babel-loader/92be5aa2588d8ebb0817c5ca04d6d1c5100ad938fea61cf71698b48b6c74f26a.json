{"ast":null,"code":"import { log, TransformFeedback } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\nimport { WEBGLBuffer } from \"../../index.js\";\nimport { getGLPrimitive } from \"../helpers/webgl-topology-utils.js\";\nexport class WEBGLTransformFeedback extends TransformFeedback {\n  device;\n  gl;\n  handle;\n  /**\n   * NOTE: The Model already has this information while drawing, but\n   * TransformFeedback currently needs it internally, to look up\n   * varying information outside of a draw() call.\n   */\n  layout;\n  buffers = {};\n  unusedBuffers = {};\n  /**\n   * Allows us to avoid a Chrome bug where a buffer that is already bound to a\n   * different target cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n   * This a major workaround, see: https://github.com/KhronosGroup/WebGL/issues/2346\n   */\n  bindOnUse = true;\n  _bound = false;\n  constructor(device, props) {\n    super(device, props);\n    this.device = device;\n    this.gl = device.gl;\n    this.handle = this.props.handle || this.gl.createTransformFeedback();\n    this.layout = this.props.layout;\n    if (props.buffers) {\n      this.setBuffers(props.buffers);\n    }\n    Object.seal(this);\n  }\n  destroy() {\n    this.gl.deleteTransformFeedback(this.handle);\n    super.destroy();\n  }\n  begin(topology = 'point-list') {\n    this.gl.bindTransformFeedback(36386, this.handle);\n    if (this.bindOnUse) {\n      this._bindBuffers();\n    }\n    this.gl.beginTransformFeedback(getGLPrimitive(topology));\n  }\n  end() {\n    this.gl.endTransformFeedback();\n    if (this.bindOnUse) {\n      this._unbindBuffers();\n    }\n    this.gl.bindTransformFeedback(36386, null);\n  }\n  // SUBCLASS\n  setBuffers(buffers) {\n    this.buffers = {};\n    this.unusedBuffers = {};\n    this.bind(() => {\n      for (const bufferName in buffers) {\n        this.setBuffer(bufferName, buffers[bufferName]);\n      }\n    });\n  }\n  setBuffer(locationOrName, bufferOrRange) {\n    const location = this._getVaryingIndex(locationOrName);\n    const {\n      buffer,\n      byteLength,\n      byteOffset\n    } = this._getBufferRange(bufferOrRange);\n    if (location < 0) {\n      this.unusedBuffers[locationOrName] = buffer;\n      log.warn(`${this.id} unusedBuffers varying buffer ${locationOrName}`)();\n      return;\n    }\n    this.buffers[location] = {\n      buffer,\n      byteLength,\n      byteOffset\n    };\n    // Need to avoid chrome bug where buffer that is already bound to a different target\n    // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n    if (!this.bindOnUse) {\n      this._bindBuffer(location, buffer, byteOffset, byteLength);\n    }\n  }\n  getBuffer(locationOrName) {\n    if (isIndex(locationOrName)) {\n      return this.buffers[locationOrName] || null;\n    }\n    const location = this._getVaryingIndex(locationOrName);\n    return location >= 0 ? this.buffers[location] : null;\n  }\n  bind(funcOrHandle = this.handle) {\n    if (typeof funcOrHandle !== 'function') {\n      this.gl.bindTransformFeedback(36386, funcOrHandle);\n      return this;\n    }\n    let value;\n    if (!this._bound) {\n      this.gl.bindTransformFeedback(36386, this.handle);\n      this._bound = true;\n      value = funcOrHandle();\n      this._bound = false;\n      this.gl.bindTransformFeedback(36386, null);\n    } else {\n      value = funcOrHandle();\n    }\n    return value;\n  }\n  unbind() {\n    this.bind(null);\n  }\n  // PRIVATE METHODS\n  /** Extract offsets for bindBufferRange */\n  _getBufferRange(bufferOrRange) {\n    if (bufferOrRange instanceof WEBGLBuffer) {\n      return {\n        buffer: bufferOrRange,\n        byteOffset: 0,\n        byteLength: bufferOrRange.byteLength\n      };\n    }\n    // To use bindBufferRange either offset or size must be specified.\n    // @ts-expect-error Must be a BufferRange.\n    const {\n      buffer,\n      byteOffset = 0,\n      byteLength = bufferOrRange.buffer.byteLength\n    } = bufferOrRange;\n    return {\n      buffer,\n      byteOffset,\n      byteLength\n    };\n  }\n  _getVaryingIndex(locationOrName) {\n    if (isIndex(locationOrName)) {\n      return Number(locationOrName);\n    }\n    for (const varying of this.layout.varyings) {\n      if (locationOrName === varying.name) {\n        return varying.location;\n      }\n    }\n    return -1;\n  }\n  /**\n   * Need to avoid chrome bug where buffer that is already bound to a different target\n   * cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n   */\n  _bindBuffers() {\n    for (const bufferIndex in this.buffers) {\n      const {\n        buffer,\n        byteLength,\n        byteOffset\n      } = this._getBufferRange(this.buffers[bufferIndex]);\n      this._bindBuffer(Number(bufferIndex), buffer, byteOffset, byteLength);\n    }\n  }\n  _unbindBuffers() {\n    for (const bufferIndex in this.buffers) {\n      this.gl.bindBufferBase(35982, Number(bufferIndex), null);\n    }\n  }\n  _bindBuffer(index, buffer, byteOffset = 0, byteLength) {\n    const handle = buffer && buffer.handle;\n    if (!handle || byteLength === undefined) {\n      this.gl.bindBufferBase(35982, index, handle);\n    } else {\n      this.gl.bindBufferRange(35982, index, handle, byteOffset, byteLength);\n    }\n  }\n}\n/**\n * Returns true if the given value is an integer, or a string that\n * trivially converts to an integer (only numeric characters).\n */\nfunction isIndex(value) {\n  if (typeof value === 'number') {\n    return Number.isInteger(value);\n  }\n  return /^\\d+$/.test(value);\n}","map":{"version":3,"names":["log","TransformFeedback","GL","WEBGLBuffer","getGLPrimitive","WEBGLTransformFeedback","device","gl","handle","layout","buffers","unusedBuffers","bindOnUse","_bound","constructor","props","createTransformFeedback","setBuffers","Object","seal","destroy","deleteTransformFeedback","begin","topology","bindTransformFeedback","_bindBuffers","beginTransformFeedback","end","endTransformFeedback","_unbindBuffers","bind","bufferName","setBuffer","locationOrName","bufferOrRange","location","_getVaryingIndex","buffer","byteLength","byteOffset","_getBufferRange","warn","id","_bindBuffer","getBuffer","isIndex","funcOrHandle","value","unbind","Number","varying","varyings","name","bufferIndex","bindBufferBase","index","undefined","bindBufferRange","isInteger","test"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\webgl\\src\\adapter\\resources\\webgl-transform-feedback.ts"],"sourcesContent":["import type {PrimitiveTopology, ShaderLayout, TransformFeedbackProps} from '@luma.gl/core';\nimport {log, TransformFeedback, Buffer, BufferRange} from '@luma.gl/core';\nimport {GL} from '@luma.gl/constants';\nimport {WebGLDevice} from '../webgl-device';\nimport {WEBGLBuffer} from '../../index';\nimport {getGLPrimitive} from '../helpers/webgl-topology-utils';\n\nexport class WEBGLTransformFeedback extends TransformFeedback {\n  readonly device: WebGLDevice;\n  readonly gl: WebGL2RenderingContext;\n  readonly handle: WebGLTransformFeedback;\n\n  /**\n   * NOTE: The Model already has this information while drawing, but\n   * TransformFeedback currently needs it internally, to look up\n   * varying information outside of a draw() call.\n   */\n  readonly layout: ShaderLayout;\n  buffers: Record<string, BufferRange> = {};\n  unusedBuffers: Record<string, Buffer> = {};\n  /**\n   * Allows us to avoid a Chrome bug where a buffer that is already bound to a\n   * different target cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n   * This a major workaround, see: https://github.com/KhronosGroup/WebGL/issues/2346\n   */\n  bindOnUse = true;\n  private _bound: boolean = false;\n\n  constructor(device: WebGLDevice, props: TransformFeedbackProps) {\n    super(device, props);\n\n    this.device = device;\n    this.gl = device.gl;\n    this.handle = this.props.handle || this.gl.createTransformFeedback();\n    this.layout = this.props.layout;\n\n    if (props.buffers) {\n      this.setBuffers(props.buffers);\n    }\n\n    Object.seal(this);\n  }\n\n  override destroy(): void {\n    this.gl.deleteTransformFeedback(this.handle);\n    super.destroy();\n  }\n\n  begin(topology: PrimitiveTopology = 'point-list'): void {\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, this.handle);\n    if (this.bindOnUse) {\n      this._bindBuffers();\n    }\n    this.gl.beginTransformFeedback(getGLPrimitive(topology));\n  }\n\n  end(): void {\n    this.gl.endTransformFeedback();\n    if (this.bindOnUse) {\n      this._unbindBuffers();\n    }\n    this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, null);\n  }\n\n  // SUBCLASS\n\n  setBuffers(buffers: Record<string, Buffer | BufferRange>): void {\n    this.buffers = {};\n    this.unusedBuffers = {};\n\n    this.bind(() => {\n      for (const bufferName in buffers) {\n        this.setBuffer(bufferName, buffers[bufferName]);\n      }\n    });\n  }\n\n  setBuffer(locationOrName: string | number, bufferOrRange: Buffer | BufferRange): void {\n    const location = this._getVaryingIndex(locationOrName);\n    const {buffer, byteLength, byteOffset} = this._getBufferRange(bufferOrRange);\n\n    if (location < 0) {\n      this.unusedBuffers[locationOrName] = buffer;\n      log.warn(`${this.id} unusedBuffers varying buffer ${locationOrName}`)();\n      return;\n    }\n\n    this.buffers[location] = {buffer, byteLength, byteOffset};\n\n    // Need to avoid chrome bug where buffer that is already bound to a different target\n    // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n    if (!this.bindOnUse) {\n      this._bindBuffer(location, buffer, byteOffset, byteLength);\n    }\n  }\n\n  getBuffer(locationOrName: string | number): Buffer | BufferRange | null {\n    if (isIndex(locationOrName)) {\n      return this.buffers[locationOrName] || null;\n    }\n    const location = this._getVaryingIndex(locationOrName);\n    return location >= 0 ? this.buffers[location] : null;\n  }\n\n  bind(funcOrHandle = this.handle) {\n    if (typeof funcOrHandle !== 'function') {\n      this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, funcOrHandle);\n      return this;\n    }\n\n    let value: unknown;\n\n    if (!this._bound) {\n      this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, this.handle);\n      this._bound = true;\n      value = funcOrHandle();\n      this._bound = false;\n      this.gl.bindTransformFeedback(GL.TRANSFORM_FEEDBACK, null);\n    } else {\n      value = funcOrHandle();\n    }\n\n    return value;\n  }\n\n  unbind() {\n    this.bind(null);\n  }\n\n  // PRIVATE METHODS\n\n  /** Extract offsets for bindBufferRange */\n  protected _getBufferRange(\n    bufferOrRange: Buffer | {buffer: Buffer; byteOffset?: number; byteLength?: number}\n  ): Required<BufferRange> {\n    if (bufferOrRange instanceof WEBGLBuffer) {\n      return {buffer: bufferOrRange, byteOffset: 0, byteLength: bufferOrRange.byteLength};\n    }\n\n    // To use bindBufferRange either offset or size must be specified.\n    // @ts-expect-error Must be a BufferRange.\n    const {buffer, byteOffset = 0, byteLength = bufferOrRange.buffer.byteLength} = bufferOrRange;\n    return {buffer, byteOffset, byteLength};\n  }\n\n  protected _getVaryingIndex(locationOrName: string | number): number {\n    if (isIndex(locationOrName)) {\n      return Number(locationOrName);\n    }\n\n    for (const varying of this.layout.varyings) {\n      if (locationOrName === varying.name) {\n        return varying.location;\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Need to avoid chrome bug where buffer that is already bound to a different target\n   * cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.\n   */\n  protected _bindBuffers(): void {\n    for (const bufferIndex in this.buffers) {\n      const {buffer, byteLength, byteOffset} = this._getBufferRange(this.buffers[bufferIndex]);\n      this._bindBuffer(Number(bufferIndex), buffer, byteOffset, byteLength);\n    }\n  }\n\n  protected _unbindBuffers(): void {\n    for (const bufferIndex in this.buffers) {\n      this.gl.bindBufferBase(GL.TRANSFORM_FEEDBACK_BUFFER, Number(bufferIndex), null);\n    }\n  }\n\n  protected _bindBuffer(index: number, buffer: Buffer, byteOffset = 0, byteLength?: number): void {\n    const handle = buffer && (buffer as WEBGLBuffer).handle;\n    if (!handle || byteLength === undefined) {\n      this.gl.bindBufferBase(GL.TRANSFORM_FEEDBACK_BUFFER, index, handle);\n    } else {\n      this.gl.bindBufferRange(GL.TRANSFORM_FEEDBACK_BUFFER, index, handle, byteOffset, byteLength);\n    }\n  }\n}\n\n/**\n * Returns true if the given value is an integer, or a string that\n * trivially converts to an integer (only numeric characters).\n */\nfunction isIndex(value: string | number): boolean {\n  if (typeof value === 'number') {\n    return Number.isInteger(value);\n  }\n  return /^\\d+$/.test(value);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}