{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBrowser } from '@probe.gl/env';\nimport { log } from \"../utils/log.js\";\nimport { uid } from \"../utils/uid.js\";\n/**\n * Manages a canvas. Supports both HTML or offscreen canvas\n * - Creates a new canvas or looks up a canvas from the DOM\n * - Provides check for DOM loaded\n * @todo commit(): https://github.com/w3ctag/design-reviews/issues/288\n * @todo transferControlToOffscreen: https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/transferControlToOffscreen\n */\nexport class CanvasContext {\n  static defaultProps = {\n    canvas: null,\n    width: 800,\n    // width are height are only used by headless gl\n    height: 600,\n    useDevicePixels: true,\n    autoResize: true,\n    container: null,\n    visible: true,\n    alphaMode: 'opaque',\n    colorSpace: 'srgb'\n  };\n  id;\n  props;\n  canvas;\n  htmlCanvas;\n  offscreenCanvas;\n  type;\n  width = 1;\n  height = 1;\n  resizeObserver;\n  /** State used by luma.gl classes: TODO - move to canvasContext*/\n  _canvasSizeInfo = {\n    clientWidth: 0,\n    clientHeight: 0,\n    devicePixelRatio: 1\n  };\n  toString() {\n    return `${this[Symbol.toStringTag]}(${this.id})`;\n  }\n  constructor(props) {\n    this.props = {\n      ...CanvasContext.defaultProps,\n      ...props\n    };\n    props = this.props;\n    if (!isBrowser()) {\n      this.id = 'node-canvas-context';\n      this.type = 'node';\n      this.width = this.props.width;\n      this.height = this.props.height;\n      // TODO - does this prevent app from using jsdom style polyfills?\n      this.canvas = null;\n      return;\n    }\n    if (!props.canvas) {\n      const canvas = createCanvas(props);\n      const container = getContainer(props?.container || null);\n      container.insertBefore(canvas, container.firstChild);\n      this.canvas = canvas;\n      if (!props?.visible) {\n        this.canvas.style.visibility = 'hidden';\n      }\n    } else if (typeof props.canvas === 'string') {\n      this.canvas = getCanvasFromDOM(props.canvas);\n    } else {\n      this.canvas = props.canvas;\n    }\n    if (this.canvas instanceof HTMLCanvasElement) {\n      this.id = this.canvas.id;\n      this.type = 'html-canvas';\n      this.htmlCanvas = this.canvas;\n    } else {\n      this.id = 'offscreen-canvas';\n      this.type = 'offscreen-canvas';\n      this.offscreenCanvas = this.canvas;\n    }\n    // React to size changes\n    if (this.canvas instanceof HTMLCanvasElement && props.autoResize) {\n      this.resizeObserver = new ResizeObserver(entries => {\n        for (const entry of entries) {\n          if (entry.target === this.canvas) {\n            this.update();\n          }\n        }\n      });\n      this.resizeObserver.observe(this.canvas);\n    }\n  }\n  /**\n   * Returns the current DPR, if props.useDevicePixels is true\n   * Device refers to physical\n   */\n  getDevicePixelRatio(useDevicePixels) {\n    if (typeof OffscreenCanvas !== 'undefined' && this.canvas instanceof OffscreenCanvas) {\n      return 1;\n    }\n    useDevicePixels = useDevicePixels === undefined ? this.props.useDevicePixels : useDevicePixels;\n    if (!useDevicePixels || useDevicePixels <= 0) {\n      return 1;\n    }\n    // The param was mainly provide to support the test cases, could be removed\n    if (useDevicePixels === true) {\n      const dpr = typeof window !== 'undefined' && window.devicePixelRatio;\n      return dpr || 1;\n    }\n    return useDevicePixels;\n  }\n  /**\n   * Returns the size of drawing buffer in device pixels.\n   * @note This can be different from the 'CSS' size of a canvas, and also from the\n   * canvas' internal drawing buffer size (.width, .height).\n   * This is the size required to cover the canvas, adjusted for DPR\n   */\n  getPixelSize() {\n    switch (this.type) {\n      case 'node':\n        return [this.width, this.height];\n      case 'offscreen-canvas':\n        return [this.canvas.width, this.canvas.height];\n      case 'html-canvas':\n        const dpr = this.getDevicePixelRatio();\n        const canvas = this.canvas;\n        // If not attached to DOM client size can be 0\n        return canvas.parentElement ? [canvas.clientWidth * dpr, canvas.clientHeight * dpr] : [this.canvas.width, this.canvas.height];\n      default:\n        throw new Error(this.type);\n    }\n  }\n  getAspect() {\n    const [width, height] = this.getPixelSize();\n    return width / height;\n  }\n  /**\n   * Returns multiplier need to convert CSS size to Device size\n   */\n  cssToDeviceRatio() {\n    try {\n      // For headless gl we might have used custom width and height\n      // hence use cached clientWidth\n      const [drawingBufferWidth] = this.getDrawingBufferSize();\n      // _canvasSizeInfo may not be populated if `setDevicePixelRatio` is never called\n      const clientWidth = this._canvasSizeInfo.clientWidth || this.htmlCanvas?.clientWidth;\n      return clientWidth ? drawingBufferWidth / clientWidth : 1;\n    } catch {\n      return 1;\n    }\n  }\n  /**\n   * Maps CSS pixel position to device pixel position\n   */\n  cssToDevicePixels(cssPixel, yInvert = true) {\n    const ratio = this.cssToDeviceRatio();\n    const [width, height] = this.getDrawingBufferSize();\n    return scalePixels(cssPixel, ratio, width, height, yInvert);\n  }\n  /**\n   * Use devicePixelRatio to set canvas width and height\n   * @note this is a raw port of luma.gl v8 code. Might be worth a review\n   */\n  setDevicePixelRatio(devicePixelRatio, options = {}) {\n    if (!this.htmlCanvas) {\n      return;\n    }\n    // NOTE: if options.width and options.height not used remove in v8\n    let clientWidth = 'width' in options ? options.width : this.htmlCanvas.clientWidth;\n    let clientHeight = 'height' in options ? options.height : this.htmlCanvas.clientHeight;\n    if (!clientWidth || !clientHeight) {\n      log.log(1, 'Canvas clientWidth/clientHeight is 0')();\n      // by forcing devicePixel ratio to 1, we do not scale canvas.width and height in each frame.\n      devicePixelRatio = 1;\n      clientWidth = this.htmlCanvas.width || 1;\n      clientHeight = this.htmlCanvas.height || 1;\n    }\n    const cachedSize = this._canvasSizeInfo;\n    // Check if canvas needs to be resized\n    if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {\n      let clampedPixelRatio = devicePixelRatio;\n      const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);\n      const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);\n      this.htmlCanvas.width = canvasWidth;\n      this.htmlCanvas.height = canvasHeight;\n      // @ts-expect-error This only works for WebGL\n      const gl = this.device.gl;\n      if (gl) {\n        // Note: when devicePixelRatio is too high, it is possible we might hit system limit for\n        // drawing buffer width and hight, in those cases they get clamped and resulting aspect ration may not be maintained\n        // for those cases, reduce devicePixelRatio.\n        const [drawingBufferWidth, drawingBufferHeight] = this.getDrawingBufferSize();\n        if (drawingBufferWidth !== canvasWidth || drawingBufferHeight !== canvasHeight) {\n          clampedPixelRatio = Math.min(drawingBufferWidth / clientWidth, drawingBufferHeight / clientHeight);\n          this.htmlCanvas.width = Math.floor(clientWidth * clampedPixelRatio);\n          this.htmlCanvas.height = Math.floor(clientHeight * clampedPixelRatio);\n          log.warn('Device pixel ratio clamped')();\n        }\n        this._canvasSizeInfo.clientWidth = clientWidth;\n        this._canvasSizeInfo.clientHeight = clientHeight;\n        this._canvasSizeInfo.devicePixelRatio = devicePixelRatio;\n      }\n    }\n  }\n  // PRIVATE\n  /** @todo Major hack done to port the CSS methods above, base canvas context should not depend on WebGL */\n  getDrawingBufferSize() {\n    // @ts-expect-error This only works for WebGL\n    const gl = this.device.gl;\n    if (!gl) {\n      // use default device pixel ratio\n      return this.getPixelSize();\n    }\n    return [gl.drawingBufferWidth, gl.drawingBufferHeight];\n  }\n  /**\n   * Allows subclass constructor to override the canvas id for auto created canvases.\n   * This can really help when debugging DOM in apps that create multiple devices\n   */\n  _setAutoCreatedCanvasId(id) {\n    if (this.htmlCanvas?.id === 'lumagl-auto-created-canvas') {\n      this.htmlCanvas.id = id;\n    }\n  }\n}\n// HELPER FUNCTIONS\nfunction getContainer(container) {\n  if (typeof container === 'string') {\n    const element = document.getElementById(container);\n    if (!element) {\n      throw new Error(`${container} is not an HTML element`);\n    }\n    return element;\n  } else if (container) {\n    return container;\n  }\n  return document.body;\n}\n/** Get a Canvas element from DOM id */\nfunction getCanvasFromDOM(canvasId) {\n  const canvas = document.getElementById(canvasId);\n  if (!(canvas instanceof HTMLCanvasElement)) {\n    throw new Error('Object is not a canvas element');\n  }\n  return canvas;\n}\n/** Create a new canvas */\nfunction createCanvas(props) {\n  const {\n    width,\n    height\n  } = props;\n  const targetCanvas = document.createElement('canvas');\n  targetCanvas.id = uid('lumagl-auto-created-canvas');\n  targetCanvas.width = width || 1;\n  targetCanvas.height = height || 1;\n  targetCanvas.style.width = Number.isFinite(width) ? `${width}px` : '100%';\n  targetCanvas.style.height = Number.isFinite(height) ? `${height}px` : '100%';\n  return targetCanvas;\n}\n/**\n *\n * @param pixel\n * @param ratio\n * @param width\n * @param height\n * @param yInvert\n * @returns\n */\nfunction scalePixels(pixel, ratio, width, height, yInvert) {\n  const point = pixel;\n  const x = scaleX(point[0], ratio, width);\n  let y = scaleY(point[1], ratio, height, yInvert);\n  // Find boundaries of next pixel to provide valid range of device pixel locations\n  let t = scaleX(point[0] + 1, ratio, width);\n  // If next pixel's position is clamped to boundary, use it as is, otherwise subtract 1 for current pixel boundary\n  const xHigh = t === width - 1 ? t : t - 1;\n  t = scaleY(point[1] + 1, ratio, height, yInvert);\n  let yHigh;\n  if (yInvert) {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    t = t === 0 ? t : t + 1;\n    // swap y and yHigh\n    yHigh = y;\n    y = t;\n  } else {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    yHigh = t === height - 1 ? t : t - 1;\n    // y remains same\n  }\n  return {\n    x,\n    y,\n    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.\n    width: Math.max(xHigh - x + 1, 1),\n    height: Math.max(yHigh - y + 1, 1)\n  };\n}\nfunction scaleX(x, ratio, width) {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  const r = Math.min(Math.round(x * ratio), width - 1);\n  return r;\n}\nfunction scaleY(y, ratio, height, yInvert) {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);\n}","map":{"version":3,"names":["isBrowser","log","uid","CanvasContext","defaultProps","canvas","width","height","useDevicePixels","autoResize","container","visible","alphaMode","colorSpace","id","props","htmlCanvas","offscreenCanvas","type","resizeObserver","_canvasSizeInfo","clientWidth","clientHeight","devicePixelRatio","toString","Symbol","toStringTag","constructor","createCanvas","getContainer","insertBefore","firstChild","style","visibility","getCanvasFromDOM","HTMLCanvasElement","ResizeObserver","entries","entry","target","update","observe","getDevicePixelRatio","OffscreenCanvas","undefined","dpr","window","getPixelSize","parentElement","Error","getAspect","cssToDeviceRatio","drawingBufferWidth","getDrawingBufferSize","cssToDevicePixels","cssPixel","yInvert","ratio","scalePixels","setDevicePixelRatio","options","cachedSize","clampedPixelRatio","canvasWidth","Math","floor","canvasHeight","gl","device","drawingBufferHeight","min","warn","_setAutoCreatedCanvasId","element","document","getElementById","body","canvasId","targetCanvas","createElement","Number","isFinite","pixel","point","x","scaleX","y","scaleY","t","xHigh","yHigh","max","r","round"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\core\\src\\adapter\\canvas-context.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {isBrowser} from '@probe.gl/env';\nimport type {Device} from './device';\nimport type {Framebuffer} from './resources/framebuffer';\nimport {log} from '../utils/log';\nimport {uid} from '../utils/uid';\nimport type {TextureFormat} from '../gpu-type-utils/texture-formats';\n\n/** Properties for a CanvasContext */\nexport type CanvasContextProps = {\n  /** If a canvas not supplied, one will be created and added to the DOM. If a string, a canvas with that id will be looked up in the DOM */\n  canvas?: HTMLCanvasElement | OffscreenCanvas | string | null;\n  /** If new canvas is created, it will be created in the specified container, otherwise is appended as a child of document.body */\n  container?: HTMLElement | string | null;\n  /** Width in pixels of the canvas - used when creating a new canvas */\n  width?: number;\n  /** Height in pixels of the canvas - used when creating a new canvas */\n  height?: number;\n  /** Visibility (only used if new canvas is created). */\n  visible?: boolean;\n  /** Whether to apply a device pixels scale factor (`true` uses browser DPI) */\n  useDevicePixels?: boolean | number;\n  /** Whether to track window resizes */\n  autoResize?: boolean;\n  /** https://developer.mozilla.org/en-US/docs/Web/API/GPUCanvasContext/configure#alphamode */\n  alphaMode?: 'opaque' | 'premultiplied';\n  /** https://developer.mozilla.org/en-US/docs/Web/API/GPUCanvasContext/configure#colorspace */\n  colorSpace?: 'srgb'; // GPUPredefinedColorSpace\n};\n\n/**\n * Manages a canvas. Supports both HTML or offscreen canvas\n * - Creates a new canvas or looks up a canvas from the DOM\n * - Provides check for DOM loaded\n * @todo commit(): https://github.com/w3ctag/design-reviews/issues/288\n * @todo transferControlToOffscreen: https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/transferControlToOffscreen\n */\nexport abstract class CanvasContext {\n  static defaultProps: Required<CanvasContextProps> = {\n    canvas: null,\n    width: 800, // width are height are only used by headless gl\n    height: 600,\n    useDevicePixels: true,\n    autoResize: true,\n    container: null,\n    visible: true,\n    alphaMode: 'opaque',\n    colorSpace: 'srgb'\n  };\n\n  abstract readonly device: Device;\n  readonly id: string;\n  readonly props: Required<CanvasContextProps>;\n  readonly canvas: HTMLCanvasElement | OffscreenCanvas;\n  readonly htmlCanvas?: HTMLCanvasElement;\n  readonly offscreenCanvas?: OffscreenCanvas;\n  readonly type: 'html-canvas' | 'offscreen-canvas' | 'node';\n\n  /** Format of returned textures: \"bgra8unorm\", \"rgba8unorm\" */\n  abstract readonly format: TextureFormat;\n  /** Default stencil format for depth textures */\n  abstract readonly depthStencilFormat: TextureFormat;\n\n  width: number = 1;\n  height: number = 1;\n\n  readonly resizeObserver: ResizeObserver | undefined;\n\n  /** State used by luma.gl classes: TODO - move to canvasContext*/\n  readonly _canvasSizeInfo = {clientWidth: 0, clientHeight: 0, devicePixelRatio: 1};\n\n  abstract get [Symbol.toStringTag](): string;\n\n  toString(): string {\n    return `${this[Symbol.toStringTag]}(${this.id})`;\n  }\n\n  constructor(props?: CanvasContextProps) {\n    this.props = {...CanvasContext.defaultProps, ...props};\n    props = this.props;\n\n    if (!isBrowser()) {\n      this.id = 'node-canvas-context';\n      this.type = 'node';\n      this.width = this.props.width;\n      this.height = this.props.height;\n      // TODO - does this prevent app from using jsdom style polyfills?\n      this.canvas = null!;\n      return;\n    }\n\n    if (!props.canvas) {\n      const canvas = createCanvas(props);\n      const container = getContainer(props?.container || null);\n      container.insertBefore(canvas, container.firstChild);\n\n      this.canvas = canvas;\n\n      if (!props?.visible) {\n        this.canvas.style.visibility = 'hidden';\n      }\n    } else if (typeof props.canvas === 'string') {\n      this.canvas = getCanvasFromDOM(props.canvas);\n    } else {\n      this.canvas = props.canvas;\n    }\n\n    if (this.canvas instanceof HTMLCanvasElement) {\n      this.id = this.canvas.id;\n      this.type = 'html-canvas';\n      this.htmlCanvas = this.canvas;\n    } else {\n      this.id = 'offscreen-canvas';\n      this.type = 'offscreen-canvas';\n      this.offscreenCanvas = this.canvas;\n    }\n\n    // React to size changes\n    if (this.canvas instanceof HTMLCanvasElement && props.autoResize) {\n      this.resizeObserver = new ResizeObserver(entries => {\n        for (const entry of entries) {\n          if (entry.target === this.canvas) {\n            this.update();\n          }\n        }\n      });\n      this.resizeObserver.observe(this.canvas);\n    }\n  }\n\n  /** Returns a framebuffer with properly resized current 'swap chain' textures */\n  abstract getCurrentFramebuffer(): Framebuffer;\n\n  /**\n   * Returns the current DPR, if props.useDevicePixels is true\n   * Device refers to physical\n   */\n  getDevicePixelRatio(useDevicePixels?: boolean | number): number {\n    if (typeof OffscreenCanvas !== 'undefined' && this.canvas instanceof OffscreenCanvas) {\n      return 1;\n    }\n\n    useDevicePixels = useDevicePixels === undefined ? this.props.useDevicePixels : useDevicePixels;\n\n    if (!useDevicePixels || (useDevicePixels as number) <= 0) {\n      return 1;\n    }\n\n    // The param was mainly provide to support the test cases, could be removed\n    if (useDevicePixels === true) {\n      const dpr = typeof window !== 'undefined' && window.devicePixelRatio;\n      return dpr || 1;\n    }\n\n    return useDevicePixels;\n  }\n\n  /**\n   * Returns the size of drawing buffer in device pixels.\n   * @note This can be different from the 'CSS' size of a canvas, and also from the\n   * canvas' internal drawing buffer size (.width, .height).\n   * This is the size required to cover the canvas, adjusted for DPR\n   */\n  getPixelSize(): [number, number] {\n    switch (this.type) {\n      case 'node':\n        return [this.width, this.height];\n      case 'offscreen-canvas':\n        return [this.canvas.width, this.canvas.height];\n      case 'html-canvas':\n        const dpr = this.getDevicePixelRatio();\n        const canvas = this.canvas as HTMLCanvasElement;\n        // If not attached to DOM client size can be 0\n        return canvas.parentElement\n          ? [canvas.clientWidth * dpr, canvas.clientHeight * dpr]\n          : [this.canvas.width, this.canvas.height];\n      default:\n        throw new Error(this.type);\n    }\n  }\n\n  getAspect(): number {\n    const [width, height] = this.getPixelSize();\n    return width / height;\n  }\n\n  /**\n   * Returns multiplier need to convert CSS size to Device size\n   */\n  cssToDeviceRatio(): number {\n    try {\n      // For headless gl we might have used custom width and height\n      // hence use cached clientWidth\n      const [drawingBufferWidth] = this.getDrawingBufferSize();\n      // _canvasSizeInfo may not be populated if `setDevicePixelRatio` is never called\n      const clientWidth = this._canvasSizeInfo.clientWidth || this.htmlCanvas?.clientWidth;\n      return clientWidth ? drawingBufferWidth / clientWidth : 1;\n    } catch {\n      return 1;\n    }\n  }\n\n  /**\n   * Maps CSS pixel position to device pixel position\n   */\n  cssToDevicePixels(\n    cssPixel: number[],\n    yInvert: boolean = true\n  ): {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  } {\n    const ratio = this.cssToDeviceRatio();\n    const [width, height] = this.getDrawingBufferSize();\n    return scalePixels(cssPixel, ratio, width, height, yInvert);\n  }\n\n  /**\n   * Use devicePixelRatio to set canvas width and height\n   * @note this is a raw port of luma.gl v8 code. Might be worth a review\n   */\n  setDevicePixelRatio(\n    devicePixelRatio: number,\n    options: {width?: number; height?: number} = {}\n  ): void {\n    if (!this.htmlCanvas) {\n      return;\n    }\n\n    // NOTE: if options.width and options.height not used remove in v8\n    let clientWidth = 'width' in options ? options.width : this.htmlCanvas.clientWidth;\n    let clientHeight = 'height' in options ? options.height : this.htmlCanvas.clientHeight;\n\n    if (!clientWidth || !clientHeight) {\n      log.log(1, 'Canvas clientWidth/clientHeight is 0')();\n      // by forcing devicePixel ratio to 1, we do not scale canvas.width and height in each frame.\n      devicePixelRatio = 1;\n      clientWidth = this.htmlCanvas.width || 1;\n      clientHeight = this.htmlCanvas.height || 1;\n    }\n\n    const cachedSize = this._canvasSizeInfo;\n    // Check if canvas needs to be resized\n    if (\n      cachedSize.clientWidth !== clientWidth ||\n      cachedSize.clientHeight !== clientHeight ||\n      cachedSize.devicePixelRatio !== devicePixelRatio\n    ) {\n      let clampedPixelRatio = devicePixelRatio;\n\n      const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);\n      const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);\n      this.htmlCanvas.width = canvasWidth;\n      this.htmlCanvas.height = canvasHeight;\n\n      // @ts-expect-error This only works for WebGL\n      const gl = this.device.gl;\n      if (gl) {\n        // Note: when devicePixelRatio is too high, it is possible we might hit system limit for\n        // drawing buffer width and hight, in those cases they get clamped and resulting aspect ration may not be maintained\n        // for those cases, reduce devicePixelRatio.\n        const [drawingBufferWidth, drawingBufferHeight] = this.getDrawingBufferSize();\n\n        if (drawingBufferWidth !== canvasWidth || drawingBufferHeight !== canvasHeight) {\n          clampedPixelRatio = Math.min(\n            drawingBufferWidth / clientWidth,\n            drawingBufferHeight / clientHeight\n          );\n\n          this.htmlCanvas.width = Math.floor(clientWidth * clampedPixelRatio);\n          this.htmlCanvas.height = Math.floor(clientHeight * clampedPixelRatio);\n\n          log.warn('Device pixel ratio clamped')();\n        }\n\n        this._canvasSizeInfo.clientWidth = clientWidth;\n        this._canvasSizeInfo.clientHeight = clientHeight;\n        this._canvasSizeInfo.devicePixelRatio = devicePixelRatio;\n      }\n    }\n  }\n\n  // PRIVATE\n\n  /** @todo Major hack done to port the CSS methods above, base canvas context should not depend on WebGL */\n  getDrawingBufferSize(): [number, number] {\n    // @ts-expect-error This only works for WebGL\n    const gl = this.device.gl;\n    if (!gl) {\n      // use default device pixel ratio\n      return this.getPixelSize();\n    }\n    return [gl.drawingBufferWidth, gl.drawingBufferHeight];\n  }\n\n  abstract resize(options?: {\n    width?: number;\n    height?: number;\n    useDevicePixels?: boolean | number;\n  }): void;\n\n  /** Perform platform specific updates (WebGPU vs WebGL) */\n  protected abstract update(): void;\n\n  /**\n   * Allows subclass constructor to override the canvas id for auto created canvases.\n   * This can really help when debugging DOM in apps that create multiple devices\n   */\n  protected _setAutoCreatedCanvasId(id: string) {\n    if (this.htmlCanvas?.id === 'lumagl-auto-created-canvas') {\n      this.htmlCanvas.id = id;\n    }\n  }\n}\n\n// HELPER FUNCTIONS\n\nfunction getContainer(container: HTMLElement | string | null): HTMLElement {\n  if (typeof container === 'string') {\n    const element = document.getElementById(container);\n    if (!element) {\n      throw new Error(`${container} is not an HTML element`);\n    }\n    return element;\n  } else if (container) {\n    return container;\n  }\n  return document.body;\n}\n\n/** Get a Canvas element from DOM id */\nfunction getCanvasFromDOM(canvasId: string): HTMLCanvasElement {\n  const canvas = document.getElementById(canvasId);\n  if (!(canvas instanceof HTMLCanvasElement)) {\n    throw new Error('Object is not a canvas element');\n  }\n  return canvas;\n}\n\n/** Create a new canvas */\nfunction createCanvas(props: CanvasContextProps) {\n  const {width, height} = props;\n  const targetCanvas = document.createElement('canvas');\n  targetCanvas.id = uid('lumagl-auto-created-canvas');\n  targetCanvas.width = width || 1;\n  targetCanvas.height = height || 1;\n  targetCanvas.style.width = Number.isFinite(width) ? `${width}px` : '100%';\n  targetCanvas.style.height = Number.isFinite(height) ? `${height}px` : '100%';\n  return targetCanvas;\n}\n\n/**\n *\n * @param pixel\n * @param ratio\n * @param width\n * @param height\n * @param yInvert\n * @returns\n */\nfunction scalePixels(\n  pixel: number[],\n  ratio: number,\n  width: number,\n  height: number,\n  yInvert: boolean\n): {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n} {\n  const point = pixel as [number, number];\n\n  const x = scaleX(point[0], ratio, width);\n  let y = scaleY(point[1], ratio, height, yInvert);\n\n  // Find boundaries of next pixel to provide valid range of device pixel locations\n\n  let t = scaleX(point[0] + 1, ratio, width);\n  // If next pixel's position is clamped to boundary, use it as is, otherwise subtract 1 for current pixel boundary\n  const xHigh = t === width - 1 ? t : t - 1;\n\n  t = scaleY(point[1] + 1, ratio, height, yInvert);\n  let yHigh;\n  if (yInvert) {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    t = t === 0 ? t : t + 1;\n    // swap y and yHigh\n    yHigh = y;\n    y = t;\n  } else {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    yHigh = t === height - 1 ? t : t - 1;\n    // y remains same\n  }\n  return {\n    x,\n    y,\n    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.\n    width: Math.max(xHigh - x + 1, 1),\n    height: Math.max(yHigh - y + 1, 1)\n  };\n}\n\nfunction scaleX(x: number, ratio: number, width: number): number {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  const r = Math.min(Math.round(x * ratio), width - 1);\n  return r;\n}\n\nfunction scaleY(y: number, ratio: number, height: number, yInvert: boolean): number {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  return yInvert\n    ? Math.max(0, height - 1 - Math.round(y * ratio))\n    : Math.min(Math.round(y * ratio), height - 1);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}