{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { assert } from \"../utils/assert.js\";\n/** Minimal validators for number and array types */\nconst DEFAULT_PROP_VALIDATORS = {\n  number: {\n    type: 'number',\n    validate(value, propType) {\n      return Number.isFinite(value) && typeof propType === 'object' && (propType.max === undefined || value <= propType.max) && (propType.min === undefined || value >= propType.min);\n    }\n  },\n  array: {\n    type: 'array',\n    validate(value, propType) {\n      return Array.isArray(value) || ArrayBuffer.isView(value);\n    }\n  }\n};\n/**\n * Parse a list of property types into property definitions that can be used to validate\n * values passed in by applications.\n * @param propTypes\n * @returns\n */\nexport function makePropValidators(propTypes) {\n  const propValidators = {};\n  for (const [name, propType] of Object.entries(propTypes)) {\n    propValidators[name] = makePropValidator(propType);\n  }\n  return propValidators;\n}\n/**\n * Validate a map of user supplied properties against a map of validators\n * Inject default values when user doesn't supply a property\n * @param properties\n * @param propValidators\n * @returns\n */\nexport function getValidatedProperties(properties, propValidators, errorMessage) {\n  const validated = {};\n  for (const [key, propsValidator] of Object.entries(propValidators)) {\n    if (properties && key in properties && !propsValidator.private) {\n      if (propsValidator.validate) {\n        assert(propsValidator.validate(properties[key], propsValidator), `${errorMessage}: invalid ${key}`);\n      }\n      validated[key] = properties[key];\n    } else {\n      // property not supplied - use default value\n      validated[key] = propsValidator.value;\n    }\n  }\n  // TODO - warn for unused properties that don't match a validator?\n  return validated;\n}\n/**\n * Creates a property validator for a prop type. Either contains:\n * - a valid prop type object ({type, ...})\n * - or just a default value, in which case type and name inference is used\n */\nfunction makePropValidator(propType) {\n  let type = getTypeOf(propType);\n  if (type !== 'object') {\n    return {\n      value: propType,\n      ...DEFAULT_PROP_VALIDATORS[type],\n      type\n    };\n  }\n  // Special handling for objects\n  if (typeof propType === 'object') {\n    if (!propType) {\n      return {\n        type: 'object',\n        value: null\n      };\n    }\n    if (propType.type !== undefined) {\n      return {\n        ...propType,\n        ...DEFAULT_PROP_VALIDATORS[propType.type],\n        type: propType.type\n      };\n    }\n    // If no type and value this object is likely the value\n    if (propType.value === undefined) {\n      return {\n        type: 'object',\n        value: propType\n      };\n    }\n    type = getTypeOf(propType.value);\n    return {\n      ...propType,\n      ...DEFAULT_PROP_VALIDATORS[type],\n      type\n    };\n  }\n  throw new Error('props');\n}\n/**\n * \"improved\" version of javascript typeof that can distinguish arrays and null values\n */\nfunction getTypeOf(value) {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n  return typeof value;\n}\n//# sourceMappingURL=prop-types.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}