{"ast":null,"code":"import { lerp } from \"./math-utils.js\";\nimport { scaleToZoom, zoomToScale, lngLatToWorld, worldToLngLat } from \"./web-mercator-utils.js\";\nimport { vec2 } from '@math.gl/core';\nconst EPSILON = 0.01;\nconst VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];\nconst DEFAULT_OPTS = {\n  curve: 1.414,\n  speed: 1.2\n  // screenSpeed and maxDuration are used only if specified\n};\n/**\n * mapbox-gl-js flyTo : https://www.mapbox.com/mapbox-gl-js/api/#map#flyto.\n * It implements “Smooth and efficient zooming and panning.” algorithm by\n * \"Jarke J. van Wijk and Wim A.A. Nuij\"\n */\nexport function flyToViewport(startProps, endProps, t, options) {\n  // Equations from above paper are referred where needed.\n  const {\n    startZoom,\n    startCenterXY,\n    uDelta,\n    w0,\n    u1,\n    S,\n    rho,\n    rho2,\n    r0\n  } = getFlyToTransitionParams(startProps, endProps, options);\n  // If change in center is too small, do linear interpolaiton.\n  if (u1 < EPSILON) {\n    const viewport = {};\n    for (const key of VIEWPORT_TRANSITION_PROPS) {\n      const startValue = startProps[key];\n      const endValue = endProps[key];\n      // @ts-ignore-error properties are populated dynamically\n      viewport[key] = lerp(startValue, endValue, t);\n    }\n    // @ts-expect-error properties are populated dynamically\n    return viewport;\n  }\n  const s = t * S;\n  const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);\n  const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;\n  const scaleIncrement = 1 / w; // Using w method for scaling.\n  const newZoom = startZoom + scaleToZoom(scaleIncrement);\n  const newCenterWorld = vec2.scale([], uDelta, u);\n  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);\n  const newCenter = worldToLngLat(newCenterWorld);\n  return {\n    longitude: newCenter[0],\n    latitude: newCenter[1],\n    zoom: newZoom\n  };\n}\n// returns transition duration in milliseconds\nexport function getFlyToDuration(startProps, endProps, options) {\n  const opts = {\n    ...DEFAULT_OPTS,\n    ...options\n  };\n  const {\n    screenSpeed,\n    speed,\n    maxDuration\n  } = opts;\n  const {\n    S,\n    rho\n  } = getFlyToTransitionParams(startProps, endProps, opts);\n  const length = 1000 * S;\n  let duration;\n  if (Number.isFinite(screenSpeed)) {\n    duration = length / (screenSpeed / rho);\n  } else {\n    duration = length / speed;\n  }\n  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;\n}\n// Private Methods\n// Calculate all parameters that are static for given startProps and endProps\nfunction getFlyToTransitionParams(startProps, endProps, opts) {\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  const rho = opts.curve;\n  const startZoom = startProps.zoom;\n  const startCenter = [startProps.longitude, startProps.latitude];\n  const startScale = zoomToScale(startZoom);\n  const endZoom = endProps.zoom;\n  const endCenter = [endProps.longitude, endProps.latitude];\n  const scale = zoomToScale(endZoom - startZoom);\n  const startCenterXY = lngLatToWorld(startCenter);\n  const endCenterXY = lngLatToWorld(endCenter);\n  const uDelta = vec2.sub([], endCenterXY, startCenterXY);\n  const w0 = Math.max(startProps.width, startProps.height);\n  const w1 = w0 / scale;\n  const u1 = vec2.length(uDelta) * startScale;\n  // u0 is treated as '0' in Eq (9).\n  // If u1 is too small, will generate invalid number\n  const _u1 = Math.max(u1, EPSILON);\n  // Implement Equation (9) from above algorithm.\n  const rho2 = rho * rho;\n  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);\n  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);\n  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  const S = (r1 - r0) / rho;\n  return {\n    startZoom,\n    startCenterXY,\n    uDelta,\n    w0,\n    u1,\n    S,\n    rho,\n    rho2,\n    r0,\n    r1\n  };\n}","map":{"version":3,"names":["lerp","scaleToZoom","zoomToScale","lngLatToWorld","worldToLngLat","vec2","EPSILON","VIEWPORT_TRANSITION_PROPS","DEFAULT_OPTS","curve","speed","flyToViewport","startProps","endProps","t","options","startZoom","startCenterXY","uDelta","w0","u1","S","rho","rho2","r0","getFlyToTransitionParams","viewport","key","startValue","endValue","s","w","Math","cosh","u","tanh","sinh","scaleIncrement","newZoom","newCenterWorld","scale","add","newCenter","longitude","latitude","zoom","getFlyToDuration","opts","screenSpeed","maxDuration","length","duration","Number","isFinite","Object","assign","startCenter","startScale","endZoom","endCenter","endCenterXY","sub","max","width","height","w1","_u1","b0","b1","log","sqrt","r1"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\web-mercator\\src\\fly-to-viewport.ts"],"sourcesContent":["import {lerp} from './math-utils';\nimport {scaleToZoom, zoomToScale, lngLatToWorld, worldToLngLat} from './web-mercator-utils';\nimport {vec2} from '@math.gl/core';\n\nimport type {ViewportProps} from './normalize-viewport-props';\n\nconst EPSILON = 0.01;\nconst VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'] as const;\nconst DEFAULT_OPTS = {\n  curve: 1.414,\n  speed: 1.2\n  // screenSpeed and maxDuration are used only if specified\n};\n\nexport type FlytoTransitionOptions = {\n  curve?: number;\n  speed?: number;\n  screenSpeed?: number;\n  maxDuration?: number;\n};\n\n/**\n * mapbox-gl-js flyTo : https://www.mapbox.com/mapbox-gl-js/api/#map#flyto.\n * It implements “Smooth and efficient zooming and panning.” algorithm by\n * \"Jarke J. van Wijk and Wim A.A. Nuij\"\n */\nexport function flyToViewport(\n  startProps: ViewportProps,\n  endProps: ViewportProps,\n  t: number,\n  options?: FlytoTransitionOptions\n): {\n  longitude: number;\n  latitude: number;\n  zoom: number;\n} {\n  // Equations from above paper are referred where needed.\n\n  const {startZoom, startCenterXY, uDelta, w0, u1, S, rho, rho2, r0} = getFlyToTransitionParams(\n    startProps,\n    endProps,\n    options\n  );\n\n  // If change in center is too small, do linear interpolaiton.\n  if (u1 < EPSILON) {\n    const viewport = {};\n    for (const key of VIEWPORT_TRANSITION_PROPS) {\n      const startValue = startProps[key];\n      const endValue = endProps[key];\n      // @ts-ignore-error properties are populated dynamically\n      viewport[key] = lerp(startValue, endValue, t);\n    }\n    // @ts-expect-error properties are populated dynamically\n    return viewport;\n  }\n\n  const s = t * S;\n\n  const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);\n  const u = (w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2)) / u1;\n\n  const scaleIncrement = 1 / w; // Using w method for scaling.\n  const newZoom = startZoom + scaleToZoom(scaleIncrement);\n\n  const newCenterWorld = vec2.scale([], uDelta, u);\n  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);\n\n  const newCenter = worldToLngLat(newCenterWorld);\n  return {\n    longitude: newCenter[0],\n    latitude: newCenter[1],\n    zoom: newZoom\n  };\n}\n\n// returns transition duration in milliseconds\nexport function getFlyToDuration(\n  startProps: ViewportProps,\n  endProps: ViewportProps,\n  options?: FlytoTransitionOptions\n): number {\n  const opts = {...DEFAULT_OPTS, ...options};\n  const {screenSpeed, speed, maxDuration} = opts;\n  const {S, rho} = getFlyToTransitionParams(startProps, endProps, opts);\n  const length = 1000 * S;\n  let duration: number;\n  if (Number.isFinite(screenSpeed)) {\n    duration = length / (screenSpeed / rho);\n  } else {\n    duration = length / speed;\n  }\n\n  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;\n}\n\n// Private Methods\n\n// Calculate all parameters that are static for given startProps and endProps\nfunction getFlyToTransitionParams(\n  startProps: ViewportProps,\n  endProps: ViewportProps,\n  opts: FlytoTransitionOptions\n): {\n  startZoom: number;\n  startCenterXY: number[];\n  uDelta: number[];\n  w0: number;\n  u1: number;\n  S: number;\n  rho: number;\n  rho2: number;\n  r0: number;\n  r1: number;\n} {\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  const rho = opts.curve;\n  const startZoom = startProps.zoom;\n  const startCenter = [startProps.longitude, startProps.latitude];\n  const startScale = zoomToScale(startZoom);\n  const endZoom = endProps.zoom;\n  const endCenter = [endProps.longitude, endProps.latitude];\n  const scale = zoomToScale(endZoom - startZoom);\n\n  const startCenterXY = lngLatToWorld(startCenter);\n  const endCenterXY = lngLatToWorld(endCenter);\n  const uDelta = vec2.sub([] as number[], endCenterXY, startCenterXY);\n\n  const w0 = Math.max(startProps.width, startProps.height);\n  const w1 = w0 / scale;\n  const u1 = vec2.length(uDelta) * startScale;\n  // u0 is treated as '0' in Eq (9).\n\n  // If u1 is too small, will generate invalid number\n  const _u1 = Math.max(u1, EPSILON);\n\n  // Implement Equation (9) from above algorithm.\n  const rho2 = rho * rho;\n  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);\n  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);\n  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  const S = (r1 - r0) / rho;\n\n  return {startZoom, startCenterXY, uDelta, w0, u1, S, rho, rho2, r0, r1};\n}\n"],"mappings":"AAAA,SAAQA,IAAI,QAAC;AACb,SAAQC,WAAW,EAAEC,WAAW,EAAEC,aAAa,EAAEC,aAAa,QAAC;AAC/D,SAAQC,IAAI,QAAO,eAAe;AAIlC,MAAMC,OAAO,GAAG,IAAI;AACpB,MAAMC,yBAAyB,GAAG,CAAC,WAAW,EAAE,UAAU,EAAE,MAAM,CAAU;AAC5E,MAAMC,YAAY,GAAG;EACnBC,KAAK,EAAE,KAAK;EACZC,KAAK,EAAE;EACP;CACD;AASD;;;;;AAKA,OAAM,SAAUC,aAAaA,CAC3BC,UAAyB,EACzBC,QAAuB,EACvBC,CAAS,EACTC,OAAgC;EAMhC;EAEA,MAAM;IAACC,SAAS;IAAEC,aAAa;IAAEC,MAAM;IAAEC,EAAE;IAAEC,EAAE;IAAEC,CAAC;IAAEC,GAAG;IAAEC,IAAI;IAAEC;EAAE,CAAC,GAAGC,wBAAwB,CAC3Fb,UAAU,EACVC,QAAQ,EACRE,OAAO,CACR;EAED;EACA,IAAIK,EAAE,GAAGd,OAAO,EAAE;IAChB,MAAMoB,QAAQ,GAAG,EAAE;IACnB,KAAK,MAAMC,GAAG,IAAIpB,yBAAyB,EAAE;MAC3C,MAAMqB,UAAU,GAAGhB,UAAU,CAACe,GAAG,CAAC;MAClC,MAAME,QAAQ,GAAGhB,QAAQ,CAACc,GAAG,CAAC;MAC9B;MACAD,QAAQ,CAACC,GAAG,CAAC,GAAG3B,IAAI,CAAC4B,UAAU,EAAEC,QAAQ,EAAEf,CAAC,CAAC;IAC/C;IACA;IACA,OAAOY,QAAQ;EACjB;EAEA,MAAMI,CAAC,GAAGhB,CAAC,GAAGO,CAAC;EAEf,MAAMU,CAAC,GAAGC,IAAI,CAACC,IAAI,CAACT,EAAE,CAAC,GAAGQ,IAAI,CAACC,IAAI,CAACT,EAAE,GAAGF,GAAG,GAAGQ,CAAC,CAAC;EACjD,MAAMI,CAAC,GAAIf,EAAE,IAAI,CAACa,IAAI,CAACC,IAAI,CAACT,EAAE,CAAC,GAAGQ,IAAI,CAACG,IAAI,CAACX,EAAE,GAAGF,GAAG,GAAGQ,CAAC,CAAC,GAAGE,IAAI,CAACI,IAAI,CAACZ,EAAE,CAAC,IAAID,IAAI,CAAC,GAAIH,EAAE;EAExF,MAAMiB,cAAc,GAAG,CAAC,GAAGN,CAAC,CAAC,CAAC;EAC9B,MAAMO,OAAO,GAAGtB,SAAS,GAAGf,WAAW,CAACoC,cAAc,CAAC;EAEvD,MAAME,cAAc,GAAGlC,IAAI,CAACmC,KAAK,CAAC,EAAE,EAAEtB,MAAM,EAAEgB,CAAC,CAAC;EAChD7B,IAAI,CAACoC,GAAG,CAACF,cAAc,EAAEA,cAAc,EAAEtB,aAAa,CAAC;EAEvD,MAAMyB,SAAS,GAAGtC,aAAa,CAACmC,cAAc,CAAC;EAC/C,OAAO;IACLI,SAAS,EAAED,SAAS,CAAC,CAAC,CAAC;IACvBE,QAAQ,EAAEF,SAAS,CAAC,CAAC,CAAC;IACtBG,IAAI,EAAEP;GACP;AACH;AAEA;AACA,OAAM,SAAUQ,gBAAgBA,CAC9BlC,UAAyB,EACzBC,QAAuB,EACvBE,OAAgC;EAEhC,MAAMgC,IAAI,GAAG;IAAC,GAAGvC,YAAY;IAAE,GAAGO;EAAO,CAAC;EAC1C,MAAM;IAACiC,WAAW;IAAEtC,KAAK;IAAEuC;EAAW,CAAC,GAAGF,IAAI;EAC9C,MAAM;IAAC1B,CAAC;IAAEC;EAAG,CAAC,GAAGG,wBAAwB,CAACb,UAAU,EAAEC,QAAQ,EAAEkC,IAAI,CAAC;EACrE,MAAMG,MAAM,GAAG,IAAI,GAAG7B,CAAC;EACvB,IAAI8B,QAAgB;EACpB,IAAIC,MAAM,CAACC,QAAQ,CAACL,WAAW,CAAC,EAAE;IAChCG,QAAQ,GAAGD,MAAM,IAAIF,WAAW,GAAG1B,GAAG,CAAC;EACzC,CAAC,MAAM;IACL6B,QAAQ,GAAGD,MAAM,GAAGxC,KAAK;EAC3B;EAEA,OAAO0C,MAAM,CAACC,QAAQ,CAACJ,WAAW,CAAC,IAAIE,QAAQ,GAAGF,WAAW,GAAG,CAAC,GAAGE,QAAQ;AAC9E;AAEA;AAEA;AACA,SAAS1B,wBAAwBA,CAC/Bb,UAAyB,EACzBC,QAAuB,EACvBkC,IAA4B;EAa5BA,IAAI,GAAGO,MAAM,CAACC,MAAM,CAAC,EAAE,EAAE/C,YAAY,EAAEuC,IAAI,CAAC;EAC5C,MAAMzB,GAAG,GAAGyB,IAAI,CAACtC,KAAK;EACtB,MAAMO,SAAS,GAAGJ,UAAU,CAACiC,IAAI;EACjC,MAAMW,WAAW,GAAG,CAAC5C,UAAU,CAAC+B,SAAS,EAAE/B,UAAU,CAACgC,QAAQ,CAAC;EAC/D,MAAMa,UAAU,GAAGvD,WAAW,CAACc,SAAS,CAAC;EACzC,MAAM0C,OAAO,GAAG7C,QAAQ,CAACgC,IAAI;EAC7B,MAAMc,SAAS,GAAG,CAAC9C,QAAQ,CAAC8B,SAAS,EAAE9B,QAAQ,CAAC+B,QAAQ,CAAC;EACzD,MAAMJ,KAAK,GAAGtC,WAAW,CAACwD,OAAO,GAAG1C,SAAS,CAAC;EAE9C,MAAMC,aAAa,GAAGd,aAAa,CAACqD,WAAW,CAAC;EAChD,MAAMI,WAAW,GAAGzD,aAAa,CAACwD,SAAS,CAAC;EAC5C,MAAMzC,MAAM,GAAGb,IAAI,CAACwD,GAAG,CAAC,EAAc,EAAED,WAAW,EAAE3C,aAAa,CAAC;EAEnE,MAAME,EAAE,GAAGa,IAAI,CAAC8B,GAAG,CAAClD,UAAU,CAACmD,KAAK,EAAEnD,UAAU,CAACoD,MAAM,CAAC;EACxD,MAAMC,EAAE,GAAG9C,EAAE,GAAGqB,KAAK;EACrB,MAAMpB,EAAE,GAAGf,IAAI,CAAC6C,MAAM,CAAChC,MAAM,CAAC,GAAGuC,UAAU;EAC3C;EAEA;EACA,MAAMS,GAAG,GAAGlC,IAAI,CAAC8B,GAAG,CAAC1C,EAAE,EAAEd,OAAO,CAAC;EAEjC;EACA,MAAMiB,IAAI,GAAGD,GAAG,GAAGA,GAAG;EACtB,MAAM6C,EAAE,GAAG,CAACF,EAAE,GAAGA,EAAE,GAAG9C,EAAE,GAAGA,EAAE,GAAGI,IAAI,GAAGA,IAAI,GAAG2C,GAAG,GAAGA,GAAG,KAAK,CAAC,GAAG/C,EAAE,GAAGI,IAAI,GAAG2C,GAAG,CAAC;EAChF,MAAME,EAAE,GAAG,CAACH,EAAE,GAAGA,EAAE,GAAG9C,EAAE,GAAGA,EAAE,GAAGI,IAAI,GAAGA,IAAI,GAAG2C,GAAG,GAAGA,GAAG,KAAK,CAAC,GAAGD,EAAE,GAAG1C,IAAI,GAAG2C,GAAG,CAAC;EAChF,MAAM1C,EAAE,GAAGQ,IAAI,CAACqC,GAAG,CAACrC,IAAI,CAACsC,IAAI,CAACH,EAAE,GAAGA,EAAE,GAAG,CAAC,CAAC,GAAGA,EAAE,CAAC;EAChD,MAAMI,EAAE,GAAGvC,IAAI,CAACqC,GAAG,CAACrC,IAAI,CAACsC,IAAI,CAACF,EAAE,GAAGA,EAAE,GAAG,CAAC,CAAC,GAAGA,EAAE,CAAC;EAChD,MAAM/C,CAAC,GAAG,CAACkD,EAAE,GAAG/C,EAAE,IAAIF,GAAG;EAEzB,OAAO;IAACN,SAAS;IAAEC,aAAa;IAAEC,MAAM;IAAEC,EAAE;IAAEC,EAAE;IAAEC,CAAC;IAAEC,GAAG;IAAEC,IAAI;IAAEC,EAAE;IAAE+C;EAAE,CAAC;AACzE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}