{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getBinaryImageMetadata } from '@loaders.gl/images';\nimport { padToNBytes, copyToArray } from '@loaders.gl/loader-utils';\nimport { assert } from \"../utils/assert.js\";\nimport { getAccessorTypeFromSize, getComponentTypeFromArray } from \"../gltf-utils/gltf-utils.js\";\nimport { getTypedArrayForAccessor as _getTypedArrayForAccessor } from \"../gltf-utils/get-typed-array.js\";\nfunction makeDefaultGLTFJson() {\n  return {\n    asset: {\n      version: '2.0',\n      generator: 'loaders.gl'\n    },\n    buffers: [],\n    extensions: {},\n    extensionsRequired: [],\n    extensionsUsed: []\n  };\n}\n/**\n * Class for structured access to GLTF data\n */\nexport class GLTFScenegraph {\n  // internal\n  gltf;\n  sourceBuffers;\n  byteLength;\n  // TODO - why is this not GLTFWithBuffers - what happens to images?\n  constructor(gltf) {\n    // Declare locally so\n    this.gltf = {\n      json: gltf?.json || makeDefaultGLTFJson(),\n      buffers: gltf?.buffers || [],\n      images: gltf?.images || []\n    };\n    this.sourceBuffers = [];\n    this.byteLength = 0;\n    // Initialize buffers\n    if (this.gltf.buffers && this.gltf.buffers[0]) {\n      this.byteLength = this.gltf.buffers[0].byteLength;\n      this.sourceBuffers = [this.gltf.buffers[0]];\n    }\n  }\n  // Accessors\n  get json() {\n    return this.gltf.json;\n  }\n  getApplicationData(key) {\n    // TODO - Data is already unpacked by GLBParser\n    const data = this.json[key];\n    return data;\n  }\n  getExtraData(key) {\n    // TODO - Data is already unpacked by GLBParser\n    const extras = this.json.extras || {};\n    return extras[key];\n  }\n  hasExtension(extensionName) {\n    const isUsedExtension = this.getUsedExtensions().find(name => name === extensionName);\n    const isRequiredExtension = this.getRequiredExtensions().find(name => name === extensionName);\n    return typeof isUsedExtension === 'string' || typeof isRequiredExtension === 'string';\n  }\n  getExtension(extensionName) {\n    const isExtension = this.getUsedExtensions().find(name => name === extensionName);\n    const extensions = this.json.extensions || {};\n    return isExtension ? extensions[extensionName] : null;\n  }\n  getRequiredExtension(extensionName) {\n    const isRequired = this.getRequiredExtensions().find(name => name === extensionName);\n    return isRequired ? this.getExtension(extensionName) : null;\n  }\n  getRequiredExtensions() {\n    return this.json.extensionsRequired || [];\n  }\n  getUsedExtensions() {\n    return this.json.extensionsUsed || [];\n  }\n  getRemovedExtensions() {\n    return this.json.extensionsRemoved || [];\n  }\n  getObjectExtension(object, extensionName) {\n    const extensions = object.extensions || {};\n    return extensions[extensionName];\n  }\n  getScene(index) {\n    return this.getObject('scenes', index);\n  }\n  getNode(index) {\n    return this.getObject('nodes', index);\n  }\n  getSkin(index) {\n    return this.getObject('skins', index);\n  }\n  getMesh(index) {\n    return this.getObject('meshes', index);\n  }\n  getMaterial(index) {\n    return this.getObject('materials', index);\n  }\n  getAccessor(index) {\n    return this.getObject('accessors', index);\n  }\n  // getCamera(index: number): object | null {\n  //   return null; // TODO: fix thi: object  as null;\n  // }\n  getTexture(index) {\n    return this.getObject('textures', index);\n  }\n  getSampler(index) {\n    return this.getObject('samplers', index);\n  }\n  getImage(index) {\n    return this.getObject('images', index);\n  }\n  getBufferView(index) {\n    return this.getObject('bufferViews', index);\n  }\n  getBuffer(index) {\n    return this.getObject('buffers', index);\n  }\n  getObject(array, index) {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      throw new Error(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n  /**\n   * Accepts buffer view index or buffer view object\n   * @returns a `Uint8Array`\n   */\n  getTypedArrayForBufferView(bufferView) {\n    bufferView = this.getBufferView(bufferView);\n    // @ts-ignore\n    const bufferIndex = bufferView.buffer;\n    // Get hold of the arrayBuffer\n    // const buffer = this.getBuffer(bufferIndex);\n    const binChunk = this.gltf.buffers[bufferIndex];\n    assert(binChunk);\n    // @ts-ignore\n    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n    // @ts-ignore\n    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n  /** Accepts accessor index or accessor object\n   * @returns a typed array with type that matches the types\n   */\n  getTypedArrayForAccessor(accessor) {\n    // @ts-ignore\n    const gltfAccessor = this.getAccessor(accessor);\n    return _getTypedArrayForAccessor(this.gltf.json, this.gltf.buffers, gltfAccessor);\n  }\n  /** accepts accessor index or accessor object\n   * returns a `Uint8Array`\n   */\n  getTypedArrayForImageData(image) {\n    // @ts-ignore\n    image = this.getAccessor(image);\n    // @ts-ignore\n    const bufferView = this.getBufferView(image.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    // @ts-ignore\n    const arrayBuffer = buffer.data;\n    const byteOffset = bufferView.byteOffset || 0;\n    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n  // MODIFERS\n  /**\n   * Add an extra application-defined key to the top-level data structure\n   */\n  addApplicationData(key, data) {\n    this.json[key] = data;\n    return this;\n  }\n  /**\n   * `extras` - Standard GLTF field for storing application specific data\n   */\n  addExtraData(key, data) {\n    this.json.extras = this.json.extras || {};\n    this.json.extras[key] = data;\n    return this;\n  }\n  addObjectExtension(object, extensionName, data) {\n    // @ts-ignore\n    object.extensions = object.extensions || {};\n    // TODO - clobber or merge?\n    // @ts-ignore\n    object.extensions[extensionName] = data;\n    this.registerUsedExtension(extensionName);\n    return this;\n  }\n  setObjectExtension(object, extensionName, data) {\n    const extensions = object.extensions || {};\n    extensions[extensionName] = data;\n    // TODO - add to usedExtensions...\n  }\n  removeObjectExtension(object, extensionName) {\n    const extensions = object?.extensions || {};\n    if (extensions[extensionName]) {\n      this.json.extensionsRemoved = this.json.extensionsRemoved || [];\n      const extensionsRemoved = this.json.extensionsRemoved;\n      if (!extensionsRemoved.includes(extensionName)) {\n        extensionsRemoved.push(extensionName);\n      }\n    }\n    delete extensions[extensionName];\n  }\n  /**\n   * Add to standard GLTF top level extension object, mark as used\n   */\n  addExtension(extensionName, extensionData = {}) {\n    assert(extensionData);\n    this.json.extensions = this.json.extensions || {};\n    this.json.extensions[extensionName] = extensionData;\n    this.registerUsedExtension(extensionName);\n    return extensionData;\n  }\n  /**\n   * Standard GLTF top level extension object, mark as used and required\n   */\n  addRequiredExtension(extensionName, extensionData = {}) {\n    assert(extensionData);\n    this.addExtension(extensionName, extensionData);\n    this.registerRequiredExtension(extensionName);\n    return extensionData;\n  }\n  /**\n   * Add extensionName to list of used extensions\n   */\n  registerUsedExtension(extensionName) {\n    this.json.extensionsUsed = this.json.extensionsUsed || [];\n    if (!this.json.extensionsUsed.find(ext => ext === extensionName)) {\n      this.json.extensionsUsed.push(extensionName);\n    }\n  }\n  /**\n   * Add extensionName to list of required extensions\n   */\n  registerRequiredExtension(extensionName) {\n    this.registerUsedExtension(extensionName);\n    this.json.extensionsRequired = this.json.extensionsRequired || [];\n    if (!this.json.extensionsRequired.find(ext => ext === extensionName)) {\n      this.json.extensionsRequired.push(extensionName);\n    }\n  }\n  /**\n   * Removes an extension from the top-level list\n   */\n  removeExtension(extensionName) {\n    if (this.json.extensions?.[extensionName]) {\n      this.json.extensionsRemoved = this.json.extensionsRemoved || [];\n      const extensionsRemoved = this.json.extensionsRemoved;\n      if (!extensionsRemoved.includes(extensionName)) {\n        extensionsRemoved.push(extensionName);\n      }\n    }\n    if (this.json.extensions) {\n      delete this.json.extensions[extensionName];\n    }\n    if (this.json.extensionsRequired) {\n      this._removeStringFromArray(this.json.extensionsRequired, extensionName);\n    }\n    if (this.json.extensionsUsed) {\n      this._removeStringFromArray(this.json.extensionsUsed, extensionName);\n    }\n  }\n  /**\n   *  Set default scene which is to be displayed at load time\n   */\n  setDefaultScene(sceneIndex) {\n    this.json.scene = sceneIndex;\n  }\n  /**\n   * @todo: add more properties for scene initialization:\n   *   name`, `extensions`, `extras`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene\n   */\n  addScene(scene) {\n    const {\n      nodeIndices\n    } = scene;\n    this.json.scenes = this.json.scenes || [];\n    this.json.scenes.push({\n      nodes: nodeIndices\n    });\n    return this.json.scenes.length - 1;\n  }\n  /**\n   * @todo: add more properties for node initialization:\n   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node\n   */\n  addNode(node) {\n    const {\n      meshIndex,\n      matrix\n    } = node;\n    this.json.nodes = this.json.nodes || [];\n    const nodeData = {\n      mesh: meshIndex\n    };\n    if (matrix) {\n      // @ts-ignore\n      nodeData.matrix = matrix;\n    }\n    this.json.nodes.push(nodeData);\n    return this.json.nodes.length - 1;\n  }\n  /** Adds a mesh to the json part */\n  addMesh(mesh) {\n    const {\n      attributes,\n      indices,\n      material,\n      mode = 4\n    } = mesh;\n    const accessors = this._addAttributes(attributes);\n    const glTFMesh = {\n      primitives: [{\n        attributes: accessors,\n        mode\n      }]\n    };\n    if (indices) {\n      const indicesAccessor = this._addIndices(indices);\n      // @ts-ignore\n      glTFMesh.primitives[0].indices = indicesAccessor;\n    }\n    if (Number.isFinite(material)) {\n      // @ts-ignore\n      glTFMesh.primitives[0].material = material;\n    }\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n  addPointCloud(attributes) {\n    // @ts-ignore\n    const accessorIndices = this._addAttributes(attributes);\n    const glTFMesh = {\n      primitives: [{\n        attributes: accessorIndices,\n        mode: 0 // GL.POINTS\n      }]\n    };\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n  /**\n   * Adds a binary image. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes as glTF image\n   * @param imageData\n   * @param mimeType\n   */\n  addImage(imageData, mimeTypeOpt) {\n    // If image is referencing a bufferView instead of URI, mimeType must be defined:\n    //   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#images\n    //   \"a reference to a bufferView; in that case mimeType must be defined.\"\n    const metadata = getBinaryImageMetadata(imageData);\n    const mimeType = mimeTypeOpt || metadata?.mimeType;\n    const bufferViewIndex = this.addBufferView(imageData);\n    const glTFImage = {\n      bufferView: bufferViewIndex,\n      mimeType\n    };\n    this.json.images = this.json.images || [];\n    this.json.images.push(glTFImage);\n    return this.json.images.length - 1;\n  }\n  /**\n   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index\n   * @param buffer\n   */\n  addBufferView(buffer, bufferIndex = 0, byteOffset = this.byteLength) {\n    const byteLength = buffer.byteLength;\n    assert(Number.isFinite(byteLength));\n    // Add this buffer to the list of buffers to be written to the body.\n    this.sourceBuffers = this.sourceBuffers || [];\n    this.sourceBuffers.push(buffer);\n    const glTFBufferView = {\n      buffer: bufferIndex,\n      // Write offset from the start of the binary body\n      byteOffset,\n      byteLength\n    };\n    // We've now added the contents to the body, so update the total length\n    // Every sub-chunk needs to be 4-byte align ed\n    this.byteLength += padToNBytes(byteLength, 4);\n    // Add a bufferView indicating start and length of this binary sub-chunk\n    this.json.bufferViews = this.json.bufferViews || [];\n    this.json.bufferViews.push(glTFBufferView);\n    return this.json.bufferViews.length - 1;\n  }\n  /**\n   * Adds an accessor to a bufferView\n   * @param bufferViewIndex\n   * @param accessor\n   */\n  addAccessor(bufferViewIndex, accessor) {\n    const glTFAccessor = {\n      bufferView: bufferViewIndex,\n      // @ts-ignore\n      type: getAccessorTypeFromSize(accessor.size),\n      // @ts-ignore\n      componentType: accessor.componentType,\n      // @ts-ignore\n      count: accessor.count,\n      // @ts-ignore\n      max: accessor.max,\n      // @ts-ignore\n      min: accessor.min\n    };\n    this.json.accessors = this.json.accessors || [];\n    this.json.accessors.push(glTFAccessor);\n    return this.json.accessors.length - 1;\n  }\n  /**\n   * Add a binary buffer. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes buffers as glTF accessors, but this could be optimized\n   * @param sourceBuffer\n   * @param accessor\n   */\n  addBinaryBuffer(sourceBuffer, accessor = {\n    size: 3\n  }) {\n    const bufferViewIndex = this.addBufferView(sourceBuffer);\n    // @ts-ignore\n    let minMax = {\n      min: accessor.min,\n      max: accessor.max\n    };\n    if (!minMax.min || !minMax.max) {\n      // @ts-ignore\n      minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);\n    }\n    const accessorDefaults = {\n      // @ts-ignore\n      size: accessor.size,\n      componentType: getComponentTypeFromArray(sourceBuffer),\n      // @ts-ignore\n      count: Math.round(sourceBuffer.length / accessor.size),\n      min: minMax.min,\n      max: minMax.max\n    };\n    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));\n  }\n  /**\n   * Adds a texture to the json part\n   * @todo: add more properties for texture initialization\n   * `sampler`, `name`, `extensions`, `extras`\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\n   */\n  addTexture(texture) {\n    const {\n      imageIndex\n    } = texture;\n    const glTFTexture = {\n      source: imageIndex\n    };\n    this.json.textures = this.json.textures || [];\n    this.json.textures.push(glTFTexture);\n    return this.json.textures.length - 1;\n  }\n  /** Adds a material to the json part */\n  addMaterial(pbrMaterialInfo) {\n    this.json.materials = this.json.materials || [];\n    this.json.materials.push(pbrMaterialInfo);\n    return this.json.materials.length - 1;\n  }\n  /** Pack the binary chunk */\n  createBinaryChunk() {\n    // Allocate total array\n    const totalByteLength = this.byteLength;\n    const arrayBuffer = new ArrayBuffer(totalByteLength);\n    const targetArray = new Uint8Array(arrayBuffer);\n    // Copy each array into\n    let dstByteOffset = 0;\n    for (const sourceBuffer of this.sourceBuffers || []) {\n      dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);\n    }\n    // Update the glTF BIN CHUNK byte length\n    if (this.json?.buffers?.[0]) {\n      this.json.buffers[0].byteLength = totalByteLength;\n    } else {\n      this.json.buffers = [{\n        byteLength: totalByteLength\n      }];\n    }\n    // Save generated arrayBuffer\n    this.gltf.binary = arrayBuffer;\n    // Put arrayBuffer to sourceBuffers for possible additional writing data in the chunk\n    this.sourceBuffers = [arrayBuffer];\n    this.gltf.buffers = [{\n      arrayBuffer,\n      byteOffset: 0,\n      byteLength: arrayBuffer.byteLength\n    }];\n  }\n  // PRIVATE\n  _removeStringFromArray(array, string) {\n    let found = true;\n    while (found) {\n      const index = array.indexOf(string);\n      if (index > -1) {\n        array.splice(index, 1);\n      } else {\n        found = false;\n      }\n    }\n  }\n  /**\n   * Add attributes to buffers and create `attributes` object which is part of `mesh`\n   */\n  _addAttributes(attributes = {}) {\n    const result = {};\n    for (const attributeKey in attributes) {\n      const attributeData = attributes[attributeKey];\n      const attrName = this._getGltfAttributeName(attributeKey);\n      const accessor = this.addBinaryBuffer(attributeData.value, attributeData);\n      result[attrName] = accessor;\n    }\n    return result;\n  }\n  /**\n   * Add indices to buffers\n   */\n  _addIndices(indices) {\n    return this.addBinaryBuffer(indices, {\n      size: 1\n    });\n  }\n  /**\n   * Deduce gltf specific attribue name from input attribute name\n   */\n  _getGltfAttributeName(attributeName) {\n    switch (attributeName.toLowerCase()) {\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return 'POSITION';\n      case 'normal':\n      case 'normals':\n        return 'NORMAL';\n      case 'color':\n      case 'colors':\n        return 'COLOR_0';\n      case 'texcoord':\n      case 'texcoords':\n        return 'TEXCOORD_0';\n      default:\n        return attributeName;\n    }\n  }\n  /**\n   * Calculate `min` and `max` arrays of accessor according to spec:\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor\n   */\n  _getAccessorMinMax(buffer, size) {\n    const result = {\n      min: null,\n      max: null\n    };\n    if (buffer.length < size) {\n      return result;\n    }\n    // @ts-ignore\n    result.min = [];\n    // @ts-ignore\n    result.max = [];\n    const initValues = buffer.subarray(0, size);\n    for (const value of initValues) {\n      // @ts-ignore\n      result.min.push(value);\n      // @ts-ignore\n      result.max.push(value);\n    }\n    for (let index = size; index < buffer.length; index += size) {\n      for (let componentIndex = 0; componentIndex < size; componentIndex++) {\n        // @ts-ignore\n        result.min[0 + componentIndex] = Math.min(\n        // @ts-ignore\n        result.min[0 + componentIndex], buffer[index + componentIndex]);\n        // @ts-ignore\n        result.max[0 + componentIndex] = Math.max(\n        // @ts-ignore\n        result.max[0 + componentIndex], buffer[index + componentIndex]);\n      }\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["getBinaryImageMetadata","padToNBytes","copyToArray","assert","getAccessorTypeFromSize","getComponentTypeFromArray","getTypedArrayForAccessor","_getTypedArrayForAccessor","makeDefaultGLTFJson","asset","version","generator","buffers","extensions","extensionsRequired","extensionsUsed","GLTFScenegraph","gltf","sourceBuffers","byteLength","constructor","json","images","getApplicationData","key","data","getExtraData","extras","hasExtension","extensionName","isUsedExtension","getUsedExtensions","find","name","isRequiredExtension","getRequiredExtensions","getExtension","isExtension","getRequiredExtension","isRequired","getRemovedExtensions","extensionsRemoved","getObjectExtension","object","getScene","index","getObject","getNode","getSkin","getMesh","getMaterial","getAccessor","getTexture","getSampler","getImage","getBufferView","getBuffer","array","Error","getTypedArrayForBufferView","bufferView","bufferIndex","buffer","binChunk","byteOffset","Uint8Array","arrayBuffer","accessor","gltfAccessor","getTypedArrayForImageData","image","addApplicationData","addExtraData","addObjectExtension","registerUsedExtension","setObjectExtension","removeObjectExtension","includes","push","addExtension","extensionData","addRequiredExtension","registerRequiredExtension","ext","removeExtension","_removeStringFromArray","setDefaultScene","sceneIndex","scene","addScene","nodeIndices","scenes","nodes","length","addNode","node","meshIndex","matrix","nodeData","mesh","addMesh","attributes","indices","material","mode","accessors","_addAttributes","glTFMesh","primitives","indicesAccessor","_addIndices","Number","isFinite","meshes","addPointCloud","accessorIndices","addImage","imageData","mimeTypeOpt","metadata","mimeType","bufferViewIndex","addBufferView","glTFImage","glTFBufferView","bufferViews","addAccessor","glTFAccessor","type","size","componentType","count","max","min","addBinaryBuffer","sourceBuffer","minMax","_getAccessorMinMax","accessorDefaults","Math","round","Object","assign","addTexture","texture","imageIndex","glTFTexture","source","textures","addMaterial","pbrMaterialInfo","materials","createBinaryChunk","totalByteLength","ArrayBuffer","targetArray","dstByteOffset","binary","string","found","indexOf","splice","result","attributeKey","attributeData","attrName","_getGltfAttributeName","value","attributeName","toLowerCase","initValues","subarray","componentIndex"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/gltf/dist/lib/api/gltf-scenegraph.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getBinaryImageMetadata } from '@loaders.gl/images';\nimport { padToNBytes, copyToArray } from '@loaders.gl/loader-utils';\nimport { assert } from \"../utils/assert.js\";\nimport { getAccessorTypeFromSize, getComponentTypeFromArray } from \"../gltf-utils/gltf-utils.js\";\nimport { getTypedArrayForAccessor as _getTypedArrayForAccessor } from \"../gltf-utils/get-typed-array.js\";\nfunction makeDefaultGLTFJson() {\n    return {\n        asset: {\n            version: '2.0',\n            generator: 'loaders.gl'\n        },\n        buffers: [],\n        extensions: {},\n        extensionsRequired: [],\n        extensionsUsed: []\n    };\n}\n/**\n * Class for structured access to GLTF data\n */\nexport class GLTFScenegraph {\n    // internal\n    gltf;\n    sourceBuffers;\n    byteLength;\n    // TODO - why is this not GLTFWithBuffers - what happens to images?\n    constructor(gltf) {\n        // Declare locally so\n        this.gltf = {\n            json: gltf?.json || makeDefaultGLTFJson(),\n            buffers: gltf?.buffers || [],\n            images: gltf?.images || []\n        };\n        this.sourceBuffers = [];\n        this.byteLength = 0;\n        // Initialize buffers\n        if (this.gltf.buffers && this.gltf.buffers[0]) {\n            this.byteLength = this.gltf.buffers[0].byteLength;\n            this.sourceBuffers = [this.gltf.buffers[0]];\n        }\n    }\n    // Accessors\n    get json() {\n        return this.gltf.json;\n    }\n    getApplicationData(key) {\n        // TODO - Data is already unpacked by GLBParser\n        const data = this.json[key];\n        return data;\n    }\n    getExtraData(key) {\n        // TODO - Data is already unpacked by GLBParser\n        const extras = (this.json.extras || {});\n        return extras[key];\n    }\n    hasExtension(extensionName) {\n        const isUsedExtension = this.getUsedExtensions().find((name) => name === extensionName);\n        const isRequiredExtension = this.getRequiredExtensions().find((name) => name === extensionName);\n        return typeof isUsedExtension === 'string' || typeof isRequiredExtension === 'string';\n    }\n    getExtension(extensionName) {\n        const isExtension = this.getUsedExtensions().find((name) => name === extensionName);\n        const extensions = this.json.extensions || {};\n        return isExtension ? extensions[extensionName] : null;\n    }\n    getRequiredExtension(extensionName) {\n        const isRequired = this.getRequiredExtensions().find((name) => name === extensionName);\n        return isRequired ? this.getExtension(extensionName) : null;\n    }\n    getRequiredExtensions() {\n        return this.json.extensionsRequired || [];\n    }\n    getUsedExtensions() {\n        return this.json.extensionsUsed || [];\n    }\n    getRemovedExtensions() {\n        return (this.json.extensionsRemoved || []);\n    }\n    getObjectExtension(object, extensionName) {\n        const extensions = object.extensions || {};\n        return extensions[extensionName];\n    }\n    getScene(index) {\n        return this.getObject('scenes', index);\n    }\n    getNode(index) {\n        return this.getObject('nodes', index);\n    }\n    getSkin(index) {\n        return this.getObject('skins', index);\n    }\n    getMesh(index) {\n        return this.getObject('meshes', index);\n    }\n    getMaterial(index) {\n        return this.getObject('materials', index);\n    }\n    getAccessor(index) {\n        return this.getObject('accessors', index);\n    }\n    // getCamera(index: number): object | null {\n    //   return null; // TODO: fix thi: object  as null;\n    // }\n    getTexture(index) {\n        return this.getObject('textures', index);\n    }\n    getSampler(index) {\n        return this.getObject('samplers', index);\n    }\n    getImage(index) {\n        return this.getObject('images', index);\n    }\n    getBufferView(index) {\n        return this.getObject('bufferViews', index);\n    }\n    getBuffer(index) {\n        return this.getObject('buffers', index);\n    }\n    getObject(array, index) {\n        // check if already resolved\n        if (typeof index === 'object') {\n            return index;\n        }\n        const object = this.json[array] && this.json[array][index];\n        if (!object) {\n            throw new Error(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n        }\n        return object;\n    }\n    /**\n     * Accepts buffer view index or buffer view object\n     * @returns a `Uint8Array`\n     */\n    getTypedArrayForBufferView(bufferView) {\n        bufferView = this.getBufferView(bufferView);\n        // @ts-ignore\n        const bufferIndex = bufferView.buffer;\n        // Get hold of the arrayBuffer\n        // const buffer = this.getBuffer(bufferIndex);\n        const binChunk = this.gltf.buffers[bufferIndex];\n        assert(binChunk);\n        // @ts-ignore\n        const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n        // @ts-ignore\n        return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n    }\n    /** Accepts accessor index or accessor object\n     * @returns a typed array with type that matches the types\n     */\n    getTypedArrayForAccessor(accessor) {\n        // @ts-ignore\n        const gltfAccessor = this.getAccessor(accessor);\n        return _getTypedArrayForAccessor(this.gltf.json, this.gltf.buffers, gltfAccessor);\n    }\n    /** accepts accessor index or accessor object\n     * returns a `Uint8Array`\n     */\n    getTypedArrayForImageData(image) {\n        // @ts-ignore\n        image = this.getAccessor(image);\n        // @ts-ignore\n        const bufferView = this.getBufferView(image.bufferView);\n        const buffer = this.getBuffer(bufferView.buffer);\n        // @ts-ignore\n        const arrayBuffer = buffer.data;\n        const byteOffset = bufferView.byteOffset || 0;\n        return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n    }\n    // MODIFERS\n    /**\n     * Add an extra application-defined key to the top-level data structure\n     */\n    addApplicationData(key, data) {\n        this.json[key] = data;\n        return this;\n    }\n    /**\n     * `extras` - Standard GLTF field for storing application specific data\n     */\n    addExtraData(key, data) {\n        this.json.extras = this.json.extras || {};\n        this.json.extras[key] = data;\n        return this;\n    }\n    addObjectExtension(object, extensionName, data) {\n        // @ts-ignore\n        object.extensions = object.extensions || {};\n        // TODO - clobber or merge?\n        // @ts-ignore\n        object.extensions[extensionName] = data;\n        this.registerUsedExtension(extensionName);\n        return this;\n    }\n    setObjectExtension(object, extensionName, data) {\n        const extensions = object.extensions || {};\n        extensions[extensionName] = data;\n        // TODO - add to usedExtensions...\n    }\n    removeObjectExtension(object, extensionName) {\n        const extensions = object?.extensions || {};\n        if (extensions[extensionName]) {\n            this.json.extensionsRemoved = this.json.extensionsRemoved || [];\n            const extensionsRemoved = this.json.extensionsRemoved;\n            if (!extensionsRemoved.includes(extensionName)) {\n                extensionsRemoved.push(extensionName);\n            }\n        }\n        delete extensions[extensionName];\n    }\n    /**\n     * Add to standard GLTF top level extension object, mark as used\n     */\n    addExtension(extensionName, extensionData = {}) {\n        assert(extensionData);\n        this.json.extensions = this.json.extensions || {};\n        this.json.extensions[extensionName] = extensionData;\n        this.registerUsedExtension(extensionName);\n        return extensionData;\n    }\n    /**\n     * Standard GLTF top level extension object, mark as used and required\n     */\n    addRequiredExtension(extensionName, extensionData = {}) {\n        assert(extensionData);\n        this.addExtension(extensionName, extensionData);\n        this.registerRequiredExtension(extensionName);\n        return extensionData;\n    }\n    /**\n     * Add extensionName to list of used extensions\n     */\n    registerUsedExtension(extensionName) {\n        this.json.extensionsUsed = this.json.extensionsUsed || [];\n        if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {\n            this.json.extensionsUsed.push(extensionName);\n        }\n    }\n    /**\n     * Add extensionName to list of required extensions\n     */\n    registerRequiredExtension(extensionName) {\n        this.registerUsedExtension(extensionName);\n        this.json.extensionsRequired = this.json.extensionsRequired || [];\n        if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {\n            this.json.extensionsRequired.push(extensionName);\n        }\n    }\n    /**\n     * Removes an extension from the top-level list\n     */\n    removeExtension(extensionName) {\n        if (this.json.extensions?.[extensionName]) {\n            this.json.extensionsRemoved = this.json.extensionsRemoved || [];\n            const extensionsRemoved = this.json.extensionsRemoved;\n            if (!extensionsRemoved.includes(extensionName)) {\n                extensionsRemoved.push(extensionName);\n            }\n        }\n        if (this.json.extensions) {\n            delete this.json.extensions[extensionName];\n        }\n        if (this.json.extensionsRequired) {\n            this._removeStringFromArray(this.json.extensionsRequired, extensionName);\n        }\n        if (this.json.extensionsUsed) {\n            this._removeStringFromArray(this.json.extensionsUsed, extensionName);\n        }\n    }\n    /**\n     *  Set default scene which is to be displayed at load time\n     */\n    setDefaultScene(sceneIndex) {\n        this.json.scene = sceneIndex;\n    }\n    /**\n     * @todo: add more properties for scene initialization:\n     *   name`, `extensions`, `extras`\n     *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene\n     */\n    addScene(scene) {\n        const { nodeIndices } = scene;\n        this.json.scenes = this.json.scenes || [];\n        this.json.scenes.push({ nodes: nodeIndices });\n        return this.json.scenes.length - 1;\n    }\n    /**\n     * @todo: add more properties for node initialization:\n     *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`\n     *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node\n     */\n    addNode(node) {\n        const { meshIndex, matrix } = node;\n        this.json.nodes = this.json.nodes || [];\n        const nodeData = { mesh: meshIndex };\n        if (matrix) {\n            // @ts-ignore\n            nodeData.matrix = matrix;\n        }\n        this.json.nodes.push(nodeData);\n        return this.json.nodes.length - 1;\n    }\n    /** Adds a mesh to the json part */\n    addMesh(mesh) {\n        const { attributes, indices, material, mode = 4 } = mesh;\n        const accessors = this._addAttributes(attributes);\n        const glTFMesh = {\n            primitives: [\n                {\n                    attributes: accessors,\n                    mode\n                }\n            ]\n        };\n        if (indices) {\n            const indicesAccessor = this._addIndices(indices);\n            // @ts-ignore\n            glTFMesh.primitives[0].indices = indicesAccessor;\n        }\n        if (Number.isFinite(material)) {\n            // @ts-ignore\n            glTFMesh.primitives[0].material = material;\n        }\n        this.json.meshes = this.json.meshes || [];\n        this.json.meshes.push(glTFMesh);\n        return this.json.meshes.length - 1;\n    }\n    addPointCloud(attributes) {\n        // @ts-ignore\n        const accessorIndices = this._addAttributes(attributes);\n        const glTFMesh = {\n            primitives: [\n                {\n                    attributes: accessorIndices,\n                    mode: 0 // GL.POINTS\n                }\n            ]\n        };\n        this.json.meshes = this.json.meshes || [];\n        this.json.meshes.push(glTFMesh);\n        return this.json.meshes.length - 1;\n    }\n    /**\n     * Adds a binary image. Builds glTF \"JSON metadata\" and saves buffer reference\n     * Buffer will be copied into BIN chunk during \"pack\"\n     * Currently encodes as glTF image\n     * @param imageData\n     * @param mimeType\n     */\n    addImage(imageData, mimeTypeOpt) {\n        // If image is referencing a bufferView instead of URI, mimeType must be defined:\n        //   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#images\n        //   \"a reference to a bufferView; in that case mimeType must be defined.\"\n        const metadata = getBinaryImageMetadata(imageData);\n        const mimeType = mimeTypeOpt || metadata?.mimeType;\n        const bufferViewIndex = this.addBufferView(imageData);\n        const glTFImage = {\n            bufferView: bufferViewIndex,\n            mimeType\n        };\n        this.json.images = this.json.images || [];\n        this.json.images.push(glTFImage);\n        return this.json.images.length - 1;\n    }\n    /**\n     * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index\n     * @param buffer\n     */\n    addBufferView(buffer, bufferIndex = 0, byteOffset = this.byteLength) {\n        const byteLength = buffer.byteLength;\n        assert(Number.isFinite(byteLength));\n        // Add this buffer to the list of buffers to be written to the body.\n        this.sourceBuffers = this.sourceBuffers || [];\n        this.sourceBuffers.push(buffer);\n        const glTFBufferView = {\n            buffer: bufferIndex,\n            // Write offset from the start of the binary body\n            byteOffset,\n            byteLength\n        };\n        // We've now added the contents to the body, so update the total length\n        // Every sub-chunk needs to be 4-byte align ed\n        this.byteLength += padToNBytes(byteLength, 4);\n        // Add a bufferView indicating start and length of this binary sub-chunk\n        this.json.bufferViews = this.json.bufferViews || [];\n        this.json.bufferViews.push(glTFBufferView);\n        return this.json.bufferViews.length - 1;\n    }\n    /**\n     * Adds an accessor to a bufferView\n     * @param bufferViewIndex\n     * @param accessor\n     */\n    addAccessor(bufferViewIndex, accessor) {\n        const glTFAccessor = {\n            bufferView: bufferViewIndex,\n            // @ts-ignore\n            type: getAccessorTypeFromSize(accessor.size),\n            // @ts-ignore\n            componentType: accessor.componentType,\n            // @ts-ignore\n            count: accessor.count,\n            // @ts-ignore\n            max: accessor.max,\n            // @ts-ignore\n            min: accessor.min\n        };\n        this.json.accessors = this.json.accessors || [];\n        this.json.accessors.push(glTFAccessor);\n        return this.json.accessors.length - 1;\n    }\n    /**\n     * Add a binary buffer. Builds glTF \"JSON metadata\" and saves buffer reference\n     * Buffer will be copied into BIN chunk during \"pack\"\n     * Currently encodes buffers as glTF accessors, but this could be optimized\n     * @param sourceBuffer\n     * @param accessor\n     */\n    addBinaryBuffer(sourceBuffer, accessor = { size: 3 }) {\n        const bufferViewIndex = this.addBufferView(sourceBuffer);\n        // @ts-ignore\n        let minMax = { min: accessor.min, max: accessor.max };\n        if (!minMax.min || !minMax.max) {\n            // @ts-ignore\n            minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);\n        }\n        const accessorDefaults = {\n            // @ts-ignore\n            size: accessor.size,\n            componentType: getComponentTypeFromArray(sourceBuffer),\n            // @ts-ignore\n            count: Math.round(sourceBuffer.length / accessor.size),\n            min: minMax.min,\n            max: minMax.max\n        };\n        return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));\n    }\n    /**\n     * Adds a texture to the json part\n     * @todo: add more properties for texture initialization\n     * `sampler`, `name`, `extensions`, `extras`\n     * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\n     */\n    addTexture(texture) {\n        const { imageIndex } = texture;\n        const glTFTexture = {\n            source: imageIndex\n        };\n        this.json.textures = this.json.textures || [];\n        this.json.textures.push(glTFTexture);\n        return this.json.textures.length - 1;\n    }\n    /** Adds a material to the json part */\n    addMaterial(pbrMaterialInfo) {\n        this.json.materials = this.json.materials || [];\n        this.json.materials.push(pbrMaterialInfo);\n        return this.json.materials.length - 1;\n    }\n    /** Pack the binary chunk */\n    createBinaryChunk() {\n        // Allocate total array\n        const totalByteLength = this.byteLength;\n        const arrayBuffer = new ArrayBuffer(totalByteLength);\n        const targetArray = new Uint8Array(arrayBuffer);\n        // Copy each array into\n        let dstByteOffset = 0;\n        for (const sourceBuffer of this.sourceBuffers || []) {\n            dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);\n        }\n        // Update the glTF BIN CHUNK byte length\n        if (this.json?.buffers?.[0]) {\n            this.json.buffers[0].byteLength = totalByteLength;\n        }\n        else {\n            this.json.buffers = [{ byteLength: totalByteLength }];\n        }\n        // Save generated arrayBuffer\n        this.gltf.binary = arrayBuffer;\n        // Put arrayBuffer to sourceBuffers for possible additional writing data in the chunk\n        this.sourceBuffers = [arrayBuffer];\n        this.gltf.buffers = [{ arrayBuffer, byteOffset: 0, byteLength: arrayBuffer.byteLength }];\n    }\n    // PRIVATE\n    _removeStringFromArray(array, string) {\n        let found = true;\n        while (found) {\n            const index = array.indexOf(string);\n            if (index > -1) {\n                array.splice(index, 1);\n            }\n            else {\n                found = false;\n            }\n        }\n    }\n    /**\n     * Add attributes to buffers and create `attributes` object which is part of `mesh`\n     */\n    _addAttributes(attributes = {}) {\n        const result = {};\n        for (const attributeKey in attributes) {\n            const attributeData = attributes[attributeKey];\n            const attrName = this._getGltfAttributeName(attributeKey);\n            const accessor = this.addBinaryBuffer(attributeData.value, attributeData);\n            result[attrName] = accessor;\n        }\n        return result;\n    }\n    /**\n     * Add indices to buffers\n     */\n    _addIndices(indices) {\n        return this.addBinaryBuffer(indices, { size: 1 });\n    }\n    /**\n     * Deduce gltf specific attribue name from input attribute name\n     */\n    _getGltfAttributeName(attributeName) {\n        switch (attributeName.toLowerCase()) {\n            case 'position':\n            case 'positions':\n            case 'vertices':\n                return 'POSITION';\n            case 'normal':\n            case 'normals':\n                return 'NORMAL';\n            case 'color':\n            case 'colors':\n                return 'COLOR_0';\n            case 'texcoord':\n            case 'texcoords':\n                return 'TEXCOORD_0';\n            default:\n                return attributeName;\n        }\n    }\n    /**\n     * Calculate `min` and `max` arrays of accessor according to spec:\n     * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor\n     */\n    _getAccessorMinMax(buffer, size) {\n        const result = { min: null, max: null };\n        if (buffer.length < size) {\n            return result;\n        }\n        // @ts-ignore\n        result.min = [];\n        // @ts-ignore\n        result.max = [];\n        const initValues = buffer.subarray(0, size);\n        for (const value of initValues) {\n            // @ts-ignore\n            result.min.push(value);\n            // @ts-ignore\n            result.max.push(value);\n        }\n        for (let index = size; index < buffer.length; index += size) {\n            for (let componentIndex = 0; componentIndex < size; componentIndex++) {\n                // @ts-ignore\n                result.min[0 + componentIndex] = Math.min(\n                // @ts-ignore\n                result.min[0 + componentIndex], buffer[index + componentIndex]);\n                // @ts-ignore\n                result.max[0 + componentIndex] = Math.max(\n                // @ts-ignore\n                result.max[0 + componentIndex], buffer[index + componentIndex]);\n            }\n        }\n        return result;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}