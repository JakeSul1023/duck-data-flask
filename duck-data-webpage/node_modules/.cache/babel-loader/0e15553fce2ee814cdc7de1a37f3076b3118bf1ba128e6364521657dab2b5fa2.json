{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\nimport { Vector3, assert, equals as equalsEpsilon } from '@math.gl/core';\nconst EPSILON14 = 1e-14;\nconst scratchOrigin = new Vector3();\n// Caclulate third axis from given two axii\nconst VECTOR_PRODUCT_LOCAL_FRAME = {\n  up: {\n    south: 'east',\n    north: 'west',\n    west: 'south',\n    east: 'north'\n  },\n  down: {\n    south: 'west',\n    north: 'east',\n    west: 'north',\n    east: 'south'\n  },\n  south: {\n    up: 'west',\n    down: 'east',\n    west: 'down',\n    east: 'up'\n  },\n  north: {\n    up: 'east',\n    down: 'west',\n    west: 'up',\n    east: 'down'\n  },\n  west: {\n    up: 'north',\n    down: 'south',\n    north: 'down',\n    south: 'up'\n  },\n  east: {\n    up: 'south',\n    down: 'north',\n    north: 'up',\n    south: 'down'\n  }\n};\nconst degeneratePositionLocalFrame = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1]\n};\nconst scratchAxisVectors = {\n  east: new Vector3(),\n  north: new Vector3(),\n  up: new Vector3(),\n  west: new Vector3(),\n  south: new Vector3(),\n  down: new Vector3()\n};\nconst scratchVector1 = new Vector3();\nconst scratchVector2 = new Vector3();\nconst scratchVector3 = new Vector3();\n// Computes a 4x4 transformation matrix from a reference frame\n// centered at the provided origin to the provided ellipsoid's fixed reference frame.\n// eslint-disable-next-line max-statements, max-params, complexity\nexport function localFrameToFixedFrame(ellipsoid, firstAxis, secondAxis, thirdAxis, cartesianOrigin, result) {\n  const thirdAxisInferred = VECTOR_PRODUCT_LOCAL_FRAME[firstAxis] && VECTOR_PRODUCT_LOCAL_FRAME[firstAxis][secondAxis];\n  // firstAxis and secondAxis must be east, north, up, west, south or down.');\n  assert(thirdAxisInferred && (!thirdAxis || thirdAxis === thirdAxisInferred));\n  let firstAxisVector;\n  let secondAxisVector;\n  let thirdAxisVector;\n  const origin = scratchOrigin.copy(cartesianOrigin);\n  // If x and y are zero, assume origin is at a pole, which is a special case.\n  const atPole = equalsEpsilon(origin.x, 0.0, EPSILON14) && equalsEpsilon(origin.y, 0.0, EPSILON14);\n  if (atPole) {\n    // Look up axis value and adjust\n    const sign = Math.sign(origin.z);\n    firstAxisVector = scratchVector1.fromArray(degeneratePositionLocalFrame[firstAxis]);\n    if (firstAxis !== 'east' && firstAxis !== 'west') {\n      firstAxisVector.scale(sign);\n    }\n    secondAxisVector = scratchVector2.fromArray(degeneratePositionLocalFrame[secondAxis]);\n    if (secondAxis !== 'east' && secondAxis !== 'west') {\n      secondAxisVector.scale(sign);\n    }\n    thirdAxisVector = scratchVector3.fromArray(degeneratePositionLocalFrame[thirdAxis]);\n    if (thirdAxis !== 'east' && thirdAxis !== 'west') {\n      thirdAxisVector.scale(sign);\n    }\n  } else {\n    // Calculate all axis\n    const {\n      up,\n      east,\n      north\n    } = scratchAxisVectors;\n    east.set(-origin.y, origin.x, 0.0).normalize();\n    ellipsoid.geodeticSurfaceNormal(origin, up);\n    north.copy(up).cross(east);\n    const {\n      down,\n      west,\n      south\n    } = scratchAxisVectors;\n    down.copy(up).scale(-1);\n    west.copy(east).scale(-1);\n    south.copy(north).scale(-1);\n    // Pick three axis based on desired orientation\n    firstAxisVector = scratchAxisVectors[firstAxis];\n    secondAxisVector = scratchAxisVectors[secondAxis];\n    thirdAxisVector = scratchAxisVectors[thirdAxis];\n  }\n  // TODO - assuming the result is column-major\n  result[0] = firstAxisVector.x;\n  result[1] = firstAxisVector.y;\n  result[2] = firstAxisVector.z;\n  result[3] = 0.0;\n  result[4] = secondAxisVector.x;\n  result[5] = secondAxisVector.y;\n  result[6] = secondAxisVector.z;\n  result[7] = 0.0;\n  result[8] = thirdAxisVector.x;\n  result[9] = thirdAxisVector.y;\n  result[10] = thirdAxisVector.z;\n  result[11] = 0.0;\n  result[12] = origin.x;\n  result[13] = origin.y;\n  result[14] = origin.z;\n  result[15] = 1.0;\n  return result;\n}","map":{"version":3,"names":["Vector3","assert","equals","equalsEpsilon","EPSILON14","scratchOrigin","VECTOR_PRODUCT_LOCAL_FRAME","up","south","north","west","east","down","degeneratePositionLocalFrame","scratchAxisVectors","scratchVector1","scratchVector2","scratchVector3","localFrameToFixedFrame","ellipsoid","firstAxis","secondAxis","thirdAxis","cartesianOrigin","result","thirdAxisInferred","firstAxisVector","secondAxisVector","thirdAxisVector","origin","copy","atPole","x","y","sign","Math","z","fromArray","scale","set","normalize","geodeticSurfaceNormal","cross"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\geospatial\\src\\ellipsoid\\helpers\\ellipsoid-transform.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\nimport {NumericArray} from '@math.gl/types';\nimport {Vector3, assert, equals as equalsEpsilon} from '@math.gl/core';\n\nimport type {Ellipsoid} from '../ellipsoid';\n\nconst EPSILON14 = 1e-14;\n\nconst scratchOrigin = new Vector3();\n\nexport type AxisDirection = 'up' | 'down' | 'north' | 'east' | 'south' | 'west';\n\n// Caclulate third axis from given two axii\nconst VECTOR_PRODUCT_LOCAL_FRAME: Record<\n  AxisDirection,\n  Partial<Record<AxisDirection, AxisDirection>>\n> = {\n  up: {\n    south: 'east',\n    north: 'west',\n    west: 'south',\n    east: 'north'\n  },\n  down: {\n    south: 'west',\n    north: 'east',\n    west: 'north',\n    east: 'south'\n  },\n  south: {\n    up: 'west',\n    down: 'east',\n    west: 'down',\n    east: 'up'\n  },\n  north: {\n    up: 'east',\n    down: 'west',\n    west: 'up',\n    east: 'down'\n  },\n  west: {\n    up: 'north',\n    down: 'south',\n    north: 'down',\n    south: 'up'\n  },\n  east: {\n    up: 'south',\n    down: 'north',\n    north: 'up',\n    south: 'down'\n  }\n} as const;\n\nconst degeneratePositionLocalFrame = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1]\n} as const;\n\nconst scratchAxisVectors = {\n  east: new Vector3(),\n  north: new Vector3(),\n  up: new Vector3(),\n  west: new Vector3(),\n  south: new Vector3(),\n  down: new Vector3()\n};\n\nconst scratchVector1 = new Vector3();\nconst scratchVector2 = new Vector3();\nconst scratchVector3 = new Vector3();\n\n// Computes a 4x4 transformation matrix from a reference frame\n// centered at the provided origin to the provided ellipsoid's fixed reference frame.\n// eslint-disable-next-line max-statements, max-params, complexity\nexport function localFrameToFixedFrame(\n  ellipsoid: Ellipsoid,\n  firstAxis: AxisDirection,\n  secondAxis: AxisDirection,\n  thirdAxis: AxisDirection,\n  cartesianOrigin: Readonly<NumericArray>,\n  result: number[]\n): number[] {\n  const thirdAxisInferred =\n    VECTOR_PRODUCT_LOCAL_FRAME[firstAxis] && VECTOR_PRODUCT_LOCAL_FRAME[firstAxis][secondAxis];\n  // firstAxis and secondAxis must be east, north, up, west, south or down.');\n  assert(thirdAxisInferred && (!thirdAxis || thirdAxis === thirdAxisInferred));\n\n  let firstAxisVector: Vector3;\n  let secondAxisVector: Vector3;\n  let thirdAxisVector: Vector3;\n\n  const origin = scratchOrigin.copy(cartesianOrigin);\n\n  // If x and y are zero, assume origin is at a pole, which is a special case.\n  const atPole = equalsEpsilon(origin.x, 0.0, EPSILON14) && equalsEpsilon(origin.y, 0.0, EPSILON14);\n\n  if (atPole) {\n    // Look up axis value and adjust\n    const sign = Math.sign(origin.z);\n\n    firstAxisVector = scratchVector1.fromArray(degeneratePositionLocalFrame[firstAxis]);\n    if (firstAxis !== 'east' && firstAxis !== 'west') {\n      firstAxisVector.scale(sign);\n    }\n\n    secondAxisVector = scratchVector2.fromArray(degeneratePositionLocalFrame[secondAxis]);\n    if (secondAxis !== 'east' && secondAxis !== 'west') {\n      secondAxisVector.scale(sign);\n    }\n\n    thirdAxisVector = scratchVector3.fromArray(degeneratePositionLocalFrame[thirdAxis]);\n    if (thirdAxis !== 'east' && thirdAxis !== 'west') {\n      thirdAxisVector.scale(sign);\n    }\n  } else {\n    // Calculate all axis\n    const {up, east, north} = scratchAxisVectors;\n\n    east.set(-origin.y, origin.x, 0.0).normalize();\n    ellipsoid.geodeticSurfaceNormal(origin, up);\n    north.copy(up).cross(east);\n\n    const {down, west, south} = scratchAxisVectors;\n\n    down.copy(up).scale(-1);\n    west.copy(east).scale(-1);\n    south.copy(north).scale(-1);\n\n    // Pick three axis based on desired orientation\n    firstAxisVector = scratchAxisVectors[firstAxis];\n    secondAxisVector = scratchAxisVectors[secondAxis];\n    thirdAxisVector = scratchAxisVectors[thirdAxis];\n  }\n\n  // TODO - assuming the result is column-major\n  result[0] = firstAxisVector.x;\n  result[1] = firstAxisVector.y;\n  result[2] = firstAxisVector.z;\n  result[3] = 0.0;\n  result[4] = secondAxisVector.x;\n  result[5] = secondAxisVector.y;\n  result[6] = secondAxisVector.z;\n  result[7] = 0.0;\n  result[8] = thirdAxisVector.x;\n  result[9] = thirdAxisVector.y;\n  result[10] = thirdAxisVector.z;\n  result[11] = 0.0;\n  result[12] = origin.x;\n  result[13] = origin.y;\n  result[14] = origin.z;\n  result[15] = 1.0;\n  return result;\n}\n"],"mappings":"AAAA;AACA;AACA;AAGA,SAAQA,OAAO,EAAEC,MAAM,EAAEC,MAAM,IAAIC,aAAa,QAAO,eAAe;AAItE,MAAMC,SAAS,GAAG,KAAK;AAEvB,MAAMC,aAAa,GAAG,IAAIL,OAAO,EAAE;AAInC;AACA,MAAMM,0BAA0B,GAG5B;EACFC,EAAE,EAAE;IACFC,KAAK,EAAE,MAAM;IACbC,KAAK,EAAE,MAAM;IACbC,IAAI,EAAE,OAAO;IACbC,IAAI,EAAE;GACP;EACDC,IAAI,EAAE;IACJJ,KAAK,EAAE,MAAM;IACbC,KAAK,EAAE,MAAM;IACbC,IAAI,EAAE,OAAO;IACbC,IAAI,EAAE;GACP;EACDH,KAAK,EAAE;IACLD,EAAE,EAAE,MAAM;IACVK,IAAI,EAAE,MAAM;IACZF,IAAI,EAAE,MAAM;IACZC,IAAI,EAAE;GACP;EACDF,KAAK,EAAE;IACLF,EAAE,EAAE,MAAM;IACVK,IAAI,EAAE,MAAM;IACZF,IAAI,EAAE,IAAI;IACVC,IAAI,EAAE;GACP;EACDD,IAAI,EAAE;IACJH,EAAE,EAAE,OAAO;IACXK,IAAI,EAAE,OAAO;IACbH,KAAK,EAAE,MAAM;IACbD,KAAK,EAAE;GACR;EACDG,IAAI,EAAE;IACJJ,EAAE,EAAE,OAAO;IACXK,IAAI,EAAE,OAAO;IACbH,KAAK,EAAE,IAAI;IACXD,KAAK,EAAE;;CAED;AAEV,MAAMK,4BAA4B,GAAG;EACnCJ,KAAK,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACjBE,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACfJ,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACbC,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAChBE,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;EAChBE,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;CACP;AAEV,MAAME,kBAAkB,GAAG;EACzBH,IAAI,EAAE,IAAIX,OAAO,EAAE;EACnBS,KAAK,EAAE,IAAIT,OAAO,EAAE;EACpBO,EAAE,EAAE,IAAIP,OAAO,EAAE;EACjBU,IAAI,EAAE,IAAIV,OAAO,EAAE;EACnBQ,KAAK,EAAE,IAAIR,OAAO,EAAE;EACpBY,IAAI,EAAE,IAAIZ,OAAO;CAClB;AAED,MAAMe,cAAc,GAAG,IAAIf,OAAO,EAAE;AACpC,MAAMgB,cAAc,GAAG,IAAIhB,OAAO,EAAE;AACpC,MAAMiB,cAAc,GAAG,IAAIjB,OAAO,EAAE;AAEpC;AACA;AACA;AACA,OAAM,SAAUkB,sBAAsBA,CACpCC,SAAoB,EACpBC,SAAwB,EACxBC,UAAyB,EACzBC,SAAwB,EACxBC,eAAuC,EACvCC,MAAgB;EAEhB,MAAMC,iBAAiB,GACrBnB,0BAA0B,CAACc,SAAS,CAAC,IAAId,0BAA0B,CAACc,SAAS,CAAC,CAACC,UAAU,CAAC;EAC5F;EACApB,MAAM,CAACwB,iBAAiB,KAAK,CAACH,SAAS,IAAIA,SAAS,KAAKG,iBAAiB,CAAC,CAAC;EAE5E,IAAIC,eAAwB;EAC5B,IAAIC,gBAAyB;EAC7B,IAAIC,eAAwB;EAE5B,MAAMC,MAAM,GAAGxB,aAAa,CAACyB,IAAI,CAACP,eAAe,CAAC;EAElD;EACA,MAAMQ,MAAM,GAAG5B,aAAa,CAAC0B,MAAM,CAACG,CAAC,EAAE,GAAG,EAAE5B,SAAS,CAAC,IAAID,aAAa,CAAC0B,MAAM,CAACI,CAAC,EAAE,GAAG,EAAE7B,SAAS,CAAC;EAEjG,IAAI2B,MAAM,EAAE;IACV;IACA,MAAMG,IAAI,GAAGC,IAAI,CAACD,IAAI,CAACL,MAAM,CAACO,CAAC,CAAC;IAEhCV,eAAe,GAAGX,cAAc,CAACsB,SAAS,CAACxB,4BAA4B,CAACO,SAAS,CAAC,CAAC;IACnF,IAAIA,SAAS,KAAK,MAAM,IAAIA,SAAS,KAAK,MAAM,EAAE;MAChDM,eAAe,CAACY,KAAK,CAACJ,IAAI,CAAC;IAC7B;IAEAP,gBAAgB,GAAGX,cAAc,CAACqB,SAAS,CAACxB,4BAA4B,CAACQ,UAAU,CAAC,CAAC;IACrF,IAAIA,UAAU,KAAK,MAAM,IAAIA,UAAU,KAAK,MAAM,EAAE;MAClDM,gBAAgB,CAACW,KAAK,CAACJ,IAAI,CAAC;IAC9B;IAEAN,eAAe,GAAGX,cAAc,CAACoB,SAAS,CAACxB,4BAA4B,CAACS,SAAS,CAAC,CAAC;IACnF,IAAIA,SAAS,KAAK,MAAM,IAAIA,SAAS,KAAK,MAAM,EAAE;MAChDM,eAAe,CAACU,KAAK,CAACJ,IAAI,CAAC;IAC7B;EACF,CAAC,MAAM;IACL;IACA,MAAM;MAAC3B,EAAE;MAAEI,IAAI;MAAEF;IAAK,CAAC,GAAGK,kBAAkB;IAE5CH,IAAI,CAAC4B,GAAG,CAAC,CAACV,MAAM,CAACI,CAAC,EAAEJ,MAAM,CAACG,CAAC,EAAE,GAAG,CAAC,CAACQ,SAAS,EAAE;IAC9CrB,SAAS,CAACsB,qBAAqB,CAACZ,MAAM,EAAEtB,EAAE,CAAC;IAC3CE,KAAK,CAACqB,IAAI,CAACvB,EAAE,CAAC,CAACmC,KAAK,CAAC/B,IAAI,CAAC;IAE1B,MAAM;MAACC,IAAI;MAAEF,IAAI;MAAEF;IAAK,CAAC,GAAGM,kBAAkB;IAE9CF,IAAI,CAACkB,IAAI,CAACvB,EAAE,CAAC,CAAC+B,KAAK,CAAC,CAAC,CAAC,CAAC;IACvB5B,IAAI,CAACoB,IAAI,CAACnB,IAAI,CAAC,CAAC2B,KAAK,CAAC,CAAC,CAAC,CAAC;IACzB9B,KAAK,CAACsB,IAAI,CAACrB,KAAK,CAAC,CAAC6B,KAAK,CAAC,CAAC,CAAC,CAAC;IAE3B;IACAZ,eAAe,GAAGZ,kBAAkB,CAACM,SAAS,CAAC;IAC/CO,gBAAgB,GAAGb,kBAAkB,CAACO,UAAU,CAAC;IACjDO,eAAe,GAAGd,kBAAkB,CAACQ,SAAS,CAAC;EACjD;EAEA;EACAE,MAAM,CAAC,CAAC,CAAC,GAAGE,eAAe,CAACM,CAAC;EAC7BR,MAAM,CAAC,CAAC,CAAC,GAAGE,eAAe,CAACO,CAAC;EAC7BT,MAAM,CAAC,CAAC,CAAC,GAAGE,eAAe,CAACU,CAAC;EAC7BZ,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG;EACfA,MAAM,CAAC,CAAC,CAAC,GAAGG,gBAAgB,CAACK,CAAC;EAC9BR,MAAM,CAAC,CAAC,CAAC,GAAGG,gBAAgB,CAACM,CAAC;EAC9BT,MAAM,CAAC,CAAC,CAAC,GAAGG,gBAAgB,CAACS,CAAC;EAC9BZ,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG;EACfA,MAAM,CAAC,CAAC,CAAC,GAAGI,eAAe,CAACI,CAAC;EAC7BR,MAAM,CAAC,CAAC,CAAC,GAAGI,eAAe,CAACK,CAAC;EAC7BT,MAAM,CAAC,EAAE,CAAC,GAAGI,eAAe,CAACQ,CAAC;EAC9BZ,MAAM,CAAC,EAAE,CAAC,GAAG,GAAG;EAChBA,MAAM,CAAC,EAAE,CAAC,GAAGK,MAAM,CAACG,CAAC;EACrBR,MAAM,CAAC,EAAE,CAAC,GAAGK,MAAM,CAACI,CAAC;EACrBT,MAAM,CAAC,EAAE,CAAC,GAAGK,MAAM,CAACO,CAAC;EACrBZ,MAAM,CAAC,EAAE,CAAC,GAAG,GAAG;EAChB,OAAOA,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}