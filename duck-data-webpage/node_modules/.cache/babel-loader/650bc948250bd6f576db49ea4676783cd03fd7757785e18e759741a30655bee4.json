{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Copyright (c) 2017 Uber Technologies, Inc.\nimport { MathArray } from \"./base/math-array.js\";\nimport { checkNumber, checkVector } from \"../lib/validators.js\";\nimport { Vector4 } from \"./vector4.js\";\n// @ts-ignore gl-matrix types...\nimport { fromMat3 as quat_fromMat3, setAxisAngle as quat_setAxisAngle, identity as quat_identity, length as quat_length, squaredLength as quat_squaredLength, dot as quat_dot,\n// getAxisAngle as quat_getAxisAngle,\nrotationTo as quat_rotationTo, add as quat_add, calculateW as quat_calculateW, conjugate as quat_conjugate, invert as quat_invert, lerp as quat_lerp, multiply as quat_multiply, rotateX as quat_rotateX, rotateY as quat_rotateY, rotateZ as quat_rotateZ, scale as quat_scale, slerp as quat_slerp } from \"../gl-matrix/quat.js\";\n// @ts-ignore gl-matrix types...\nimport { transformQuat as vec4_transformQuat } from \"../gl-matrix/vec4.js\";\nconst IDENTITY_QUATERNION = [0, 0, 0, 1];\nexport class Quaternion extends MathArray {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    // PERF NOTE: initialize elements as double precision numbers\n    super(-0, -0, -0, -0);\n    // eslint-disable-next-line prefer-rest-params\n    if (Array.isArray(x) && arguments.length === 1) {\n      this.copy(x);\n    } else {\n      this.set(x, y, z, w);\n    }\n  }\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    this[3] = array[3];\n    return this.check();\n  }\n  set(x, y, z, w) {\n    this[0] = x;\n    this[1] = y;\n    this[2] = z;\n    this[3] = w;\n    return this.check();\n  }\n  fromObject(object) {\n    this[0] = object.x;\n    this[1] = object.y;\n    this[2] = object.z;\n    this[3] = object.w;\n    return this.check();\n  }\n  /**\n   * Creates a quaternion from the given 3x3 rotation matrix.\n   * NOTE: The resultant quaternion is not normalized, so you should\n   * be sure to renormalize the quaternion yourself where necessary.\n   * @param m\n   * @returns\n   */\n  fromMatrix3(m) {\n    quat_fromMat3(this, m);\n    return this.check();\n  }\n  fromAxisRotation(axis, rad) {\n    quat_setAxisAngle(this, axis, rad);\n    return this.check();\n  }\n  /** Set a quat to the identity quaternion */\n  identity() {\n    quat_identity(this);\n    return this.check();\n  }\n  // Set the components of a quat to the given values\n  // set(i, j, k, l) {\n  //   quat_set(this, i, j, k, l);\n  //   return this.check();\n  // }\n  // Sets a quat from the given angle and rotation axis, then returns it.\n  setAxisAngle(axis, rad) {\n    return this.fromAxisRotation(axis, rad);\n  }\n  // Getters/setters\n  get ELEMENTS() {\n    return 4;\n  }\n  get x() {\n    return this[0];\n  }\n  set x(value) {\n    this[0] = checkNumber(value);\n  }\n  get y() {\n    return this[1];\n  }\n  set y(value) {\n    this[1] = checkNumber(value);\n  }\n  get z() {\n    return this[2];\n  }\n  set z(value) {\n    this[2] = checkNumber(value);\n  }\n  get w() {\n    return this[3];\n  }\n  set w(value) {\n    this[3] = checkNumber(value);\n  }\n  // Calculates the length of a quat\n  len() {\n    return quat_length(this);\n  }\n  // Calculates the squared length of a quat\n  lengthSquared() {\n    return quat_squaredLength(this);\n  }\n  // Calculates the dot product of two quat's\n  // @return {Number}\n  dot(a) {\n    return quat_dot(this, a);\n  }\n  // Gets the rotation axis and angle for a given quaternion.\n  // If a quaternion is created with setAxisAngle, this method will\n  // return the same values as providied in the original parameter\n  // list OR functionally equivalent values.\n  // Example: The quaternion formed by axis [0, 0, 1] and angle -90\n  // is the same as the quaternion formed by [0, 0, 1] and 270.\n  // This method favors the latter.\n  // @return {{[x,y,z], Number}}\n  // getAxisAngle() {\n  //   const axis = [];\n  // //   const angle = quat_getAxisAngle(axis, this);\n  //   return {axis, angle};\n  // }\n  // MODIFIERS\n  // Sets a quaternion to represent the shortest rotation from one vector\n  // to another. Both vectors are assumed to be unit length.\n  rotationTo(vectorA, vectorB) {\n    quat_rotationTo(this, vectorA, vectorB);\n    return this.check();\n  }\n  // Sets the specified quaternion with values corresponding to the given axes.\n  // Each axis is a vec3 and is expected to be unit length and perpendicular\n  // to all other specified axes.\n  // setAxes() {\n  //   Number\n  // }\n  // Performs a spherical linear interpolation with two control points\n  // sqlerp() {\n  //   Number;\n  // }\n  // Adds two quat's\n  add(a) {\n    quat_add(this, this, a);\n    return this.check();\n  }\n  // Calculates the W component of a quat from the X, Y, and Z components.\n  // Any existing W component will be ignored.\n  calculateW() {\n    quat_calculateW(this, this);\n    return this.check();\n  }\n  // Calculates the conjugate of a quat If the quaternion is normalized,\n  // this function is faster than quat_invert and produces the same result.\n  conjugate() {\n    quat_conjugate(this, this);\n    return this.check();\n  }\n  // Calculates the inverse of a quat\n  invert() {\n    quat_invert(this, this);\n    return this.check();\n  }\n  // Performs a linear interpolation between two quat's\n  lerp(a, b, t) {\n    if (t === undefined) {\n      return this.lerp(this, a, b);\n    }\n    quat_lerp(this, a, b, t);\n    return this.check();\n  }\n  // Multiplies two quat's\n  multiplyRight(a) {\n    quat_multiply(this, this, a);\n    return this.check();\n  }\n  multiplyLeft(a) {\n    quat_multiply(this, a, this);\n    return this.check();\n  }\n  // Normalize a quat\n  normalize() {\n    // Handle 0 case\n    const length = this.len();\n    const l = length > 0 ? 1 / length : 0;\n    this[0] = this[0] * l;\n    this[1] = this[1] * l;\n    this[2] = this[2] * l;\n    this[3] = this[3] * l;\n    // Set to [0, 0, 0, 1] if length is 0\n    if (length === 0) {\n      this[3] = 1;\n    }\n    return this.check();\n  }\n  // Rotates a quaternion by the given angle about the X axis\n  rotateX(rad) {\n    quat_rotateX(this, this, rad);\n    return this.check();\n  }\n  // Rotates a quaternion by the given angle about the Y axis\n  rotateY(rad) {\n    quat_rotateY(this, this, rad);\n    return this.check();\n  }\n  // Rotates a quaternion by the given angle about the Z axis\n  rotateZ(rad) {\n    quat_rotateZ(this, this, rad);\n    return this.check();\n  }\n  // Scales a quat by a scalar number\n  scale(b) {\n    quat_scale(this, this, b);\n    return this.check();\n  }\n  // Performs a spherical linear interpolation between two quat\n  slerp(arg0, arg1, arg2) {\n    let start;\n    let target;\n    let ratio;\n    // eslint-disable-next-line prefer-rest-params\n    switch (arguments.length) {\n      case 1:\n        // Deprecated signature ({start, target, ratio})\n        // eslint-disable-next-line prefer-rest-params\n        ({\n          start = IDENTITY_QUATERNION,\n          target,\n          ratio\n        } = arg0);\n        break;\n      case 2:\n        // THREE.js compatibility signature (target, ration)\n        start = this; // eslint-disable-line\n        target = arg0;\n        ratio = arg1;\n        break;\n      default:\n        // Default signature: (start, target, ratio)\n        start = arg0;\n        target = arg1;\n        ratio = arg2;\n    }\n    quat_slerp(this, start, target, ratio);\n    return this.check();\n  }\n  transformVector4(vector, result = new Vector4()) {\n    vec4_transformQuat(result, vector, this);\n    return checkVector(result, 4);\n  }\n  // THREE.js Math API compatibility\n  lengthSq() {\n    return this.lengthSquared();\n  }\n  setFromAxisAngle(axis, rad) {\n    return this.setAxisAngle(axis, rad);\n  }\n  premultiply(a) {\n    return this.multiplyLeft(a);\n  }\n  multiply(a) {\n    return this.multiplyRight(a);\n  }\n}","map":{"version":3,"names":["MathArray","checkNumber","checkVector","Vector4","fromMat3","quat_fromMat3","setAxisAngle","quat_setAxisAngle","identity","quat_identity","length","quat_length","squaredLength","quat_squaredLength","dot","quat_dot","rotationTo","quat_rotationTo","add","quat_add","calculateW","quat_calculateW","conjugate","quat_conjugate","invert","quat_invert","lerp","quat_lerp","multiply","quat_multiply","rotateX","quat_rotateX","rotateY","quat_rotateY","rotateZ","quat_rotateZ","scale","quat_scale","slerp","quat_slerp","transformQuat","vec4_transformQuat","IDENTITY_QUATERNION","Quaternion","constructor","x","y","z","w","Array","isArray","arguments","copy","set","array","check","fromObject","object","fromMatrix3","m","fromAxisRotation","axis","rad","ELEMENTS","value","len","lengthSquared","a","vectorA","vectorB","b","t","undefined","multiplyRight","multiplyLeft","normalize","l","arg0","arg1","arg2","start","target","ratio","transformVector4","vector","result","lengthSq","setFromAxisAngle","premultiply"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\core\\src\\classes\\quaternion.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Copyright (c) 2017 Uber Technologies, Inc.\n\nimport {NumericArray} from '@math.gl/types';\nimport {MathArray} from './base/math-array';\nimport {checkNumber, checkVector} from '../lib/validators';\nimport {Vector4} from './vector4';\n// @ts-ignore gl-matrix types...\nimport {\n  fromMat3 as quat_fromMat3,\n  setAxisAngle as quat_setAxisAngle,\n  identity as quat_identity,\n  length as quat_length,\n  squaredLength as quat_squaredLength,\n  dot as quat_dot,\n  // getAxisAngle as quat_getAxisAngle,\n  rotationTo as quat_rotationTo,\n  add as quat_add,\n  calculateW as quat_calculateW,\n  conjugate as quat_conjugate,\n  invert as quat_invert,\n  lerp as quat_lerp,\n  multiply as quat_multiply,\n  rotateX as quat_rotateX,\n  rotateY as quat_rotateY,\n  rotateZ as quat_rotateZ,\n  scale as quat_scale,\n  slerp as quat_slerp\n} from '../gl-matrix/quat';\n// @ts-ignore gl-matrix types...\nimport {transformQuat as vec4_transformQuat} from '../gl-matrix/vec4';\n\nconst IDENTITY_QUATERNION = [0, 0, 0, 1] as const;\n\nexport class Quaternion extends MathArray {\n  constructor(x: number | Readonly<NumericArray> = 0, y = 0, z = 0, w = 1) {\n    // PERF NOTE: initialize elements as double precision numbers\n    super(-0, -0, -0, -0);\n    // eslint-disable-next-line prefer-rest-params\n    if (Array.isArray(x) && arguments.length === 1) {\n      this.copy(x);\n    } else {\n      this.set(x as number, y, z, w);\n    }\n  }\n\n  copy(array: Readonly<NumericArray>): this {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    this[3] = array[3];\n    return this.check();\n  }\n\n  set(x: number, y: number, z: number, w: number): this {\n    this[0] = x;\n    this[1] = y;\n    this[2] = z;\n    this[3] = w;\n    return this.check();\n  }\n\n  fromObject(object: {x: number; y: number; z: number; w: number}): this {\n    this[0] = object.x;\n    this[1] = object.y;\n    this[2] = object.z;\n    this[3] = object.w;\n    return this.check();\n  }\n\n  /**\n   * Creates a quaternion from the given 3x3 rotation matrix.\n   * NOTE: The resultant quaternion is not normalized, so you should\n   * be sure to renormalize the quaternion yourself where necessary.\n   * @param m\n   * @returns\n   */\n  fromMatrix3(m: Readonly<NumericArray>): this {\n    quat_fromMat3(this, m);\n    return this.check();\n  }\n\n  fromAxisRotation(axis: Readonly<NumericArray>, rad: number): this {\n    quat_setAxisAngle(this, axis, rad);\n    return this.check();\n  }\n\n  /** Set a quat to the identity quaternion */\n  identity(): this {\n    quat_identity(this);\n    return this.check();\n  }\n\n  // Set the components of a quat to the given values\n  // set(i, j, k, l) {\n  //   quat_set(this, i, j, k, l);\n  //   return this.check();\n  // }\n\n  // Sets a quat from the given angle and rotation axis, then returns it.\n  setAxisAngle(axis: Readonly<NumericArray>, rad: number): this {\n    return this.fromAxisRotation(axis, rad);\n  }\n\n  // Getters/setters\n  get ELEMENTS(): number {\n    return 4;\n  }\n\n  get x(): number {\n    return this[0];\n  }\n  set x(value: number) {\n    this[0] = checkNumber(value);\n  }\n\n  get y(): number {\n    return this[1];\n  }\n  set y(value: number) {\n    this[1] = checkNumber(value);\n  }\n\n  get z(): number {\n    return this[2];\n  }\n  set z(value: number) {\n    this[2] = checkNumber(value);\n  }\n\n  get w(): number {\n    return this[3];\n  }\n  set w(value: number) {\n    this[3] = checkNumber(value);\n  }\n\n  // Calculates the length of a quat\n  len(): number {\n    return quat_length(this);\n  }\n\n  // Calculates the squared length of a quat\n  lengthSquared(): number {\n    return quat_squaredLength(this);\n  }\n\n  // Calculates the dot product of two quat's\n  // @return {Number}\n  dot(a: Readonly<NumericArray>): number {\n    return quat_dot(this, a);\n  }\n\n  // Gets the rotation axis and angle for a given quaternion.\n  // If a quaternion is created with setAxisAngle, this method will\n  // return the same values as providied in the original parameter\n  // list OR functionally equivalent values.\n  // Example: The quaternion formed by axis [0, 0, 1] and angle -90\n  // is the same as the quaternion formed by [0, 0, 1] and 270.\n  // This method favors the latter.\n  // @return {{[x,y,z], Number}}\n  // getAxisAngle() {\n  //   const axis = [];\n  // //   const angle = quat_getAxisAngle(axis, this);\n  //   return {axis, angle};\n  // }\n  // MODIFIERS\n  // Sets a quaternion to represent the shortest rotation from one vector\n  // to another. Both vectors are assumed to be unit length.\n  rotationTo(vectorA: NumericArray, vectorB: NumericArray): this {\n    quat_rotationTo(this, vectorA, vectorB);\n    return this.check();\n  }\n\n  // Sets the specified quaternion with values corresponding to the given axes.\n  // Each axis is a vec3 and is expected to be unit length and perpendicular\n  // to all other specified axes.\n  // setAxes() {\n  //   Number\n  // }\n  // Performs a spherical linear interpolation with two control points\n  // sqlerp() {\n  //   Number;\n  // }\n  // Adds two quat's\n  override add(a: Readonly<NumericArray>): this {\n    quat_add(this, this, a);\n    return this.check();\n  }\n\n  // Calculates the W component of a quat from the X, Y, and Z components.\n  // Any existing W component will be ignored.\n  calculateW(): this {\n    quat_calculateW(this, this);\n    return this.check();\n  }\n\n  // Calculates the conjugate of a quat If the quaternion is normalized,\n  // this function is faster than quat_invert and produces the same result.\n  conjugate(): this {\n    quat_conjugate(this, this);\n    return this.check();\n  }\n\n  // Calculates the inverse of a quat\n  invert(): this {\n    quat_invert(this, this);\n    return this.check();\n  }\n\n  // Performs a linear interpolation between two quat's\n  override lerp(a: Readonly<NumericArray>, b: Readonly<NumericArray> | number, t?: number): this {\n    if (t === undefined) {\n      return this.lerp(this, a, b as number);\n    }\n    quat_lerp(this, a, b as NumericArray, t);\n    return this.check();\n  }\n\n  // Multiplies two quat's\n  multiplyRight(a: Readonly<NumericArray>): this {\n    quat_multiply(this, this, a);\n    return this.check();\n  }\n\n  multiplyLeft(a: Readonly<NumericArray>): this {\n    quat_multiply(this, a, this);\n    return this.check();\n  }\n\n  // Normalize a quat\n  normalize(): this {\n    // Handle 0 case\n    const length = this.len();\n    const l = length > 0 ? 1 / length : 0;\n    this[0] = this[0] * l;\n    this[1] = this[1] * l;\n    this[2] = this[2] * l;\n    this[3] = this[3] * l;\n    // Set to [0, 0, 0, 1] if length is 0\n    if (length === 0) {\n      this[3] = 1;\n    }\n    return this.check();\n  }\n\n  // Rotates a quaternion by the given angle about the X axis\n  rotateX(rad: number): this {\n    quat_rotateX(this, this, rad);\n    return this.check();\n  }\n\n  // Rotates a quaternion by the given angle about the Y axis\n  rotateY(rad: number): this {\n    quat_rotateY(this, this, rad);\n    return this.check();\n  }\n\n  // Rotates a quaternion by the given angle about the Z axis\n  rotateZ(rad: number): this {\n    quat_rotateZ(this, this, rad);\n    return this.check();\n  }\n\n  // Scales a quat by a scalar number\n  override scale(b: number): this {\n    quat_scale(this, this, b);\n    return this.check();\n  }\n\n  slerp(target: Readonly<NumericArray>, ratio: number): this;\n  slerp(start: Readonly<NumericArray>, target: Readonly<NumericArray>, ratio: number): this;\n  slerp(params: {\n    start: Readonly<NumericArray>;\n    target: Readonly<NumericArray>;\n    ratio: number;\n  }): this;\n\n  // Performs a spherical linear interpolation between two quat\n  slerp(\n    arg0:\n      | Readonly<NumericArray>\n      | {\n          start: Readonly<NumericArray>;\n          target: Readonly<NumericArray>;\n          ratio: number;\n        },\n    arg1?: Readonly<NumericArray> | number,\n    arg2?: number\n  ): this {\n    let start: Readonly<NumericArray>;\n    let target: Readonly<NumericArray>;\n    let ratio: number;\n    // eslint-disable-next-line prefer-rest-params\n    switch (arguments.length) {\n      case 1: // Deprecated signature ({start, target, ratio})\n        // eslint-disable-next-line prefer-rest-params\n        ({\n          start = IDENTITY_QUATERNION,\n          target,\n          ratio\n        } = arg0 as {\n          start: Readonly<NumericArray>;\n          target: Readonly<NumericArray>;\n          ratio: number;\n        });\n        break;\n      case 2: // THREE.js compatibility signature (target, ration)\n        start = this; // eslint-disable-line\n        target = arg0 as Readonly<NumericArray>;\n        ratio = arg1 as number;\n        break;\n      default:\n        // Default signature: (start, target, ratio)\n        start = arg0 as Readonly<NumericArray>;\n        target = arg1 as Readonly<NumericArray>;\n        ratio = arg2;\n    }\n    quat_slerp(this, start, target, ratio);\n    return this.check();\n  }\n\n  transformVector4(\n    vector: Readonly<NumericArray>,\n    result: NumericArray = new Vector4()\n  ): NumericArray {\n    vec4_transformQuat(result, vector, this);\n    return checkVector(result, 4);\n  }\n\n  // THREE.js Math API compatibility\n  lengthSq(): number {\n    return this.lengthSquared();\n  }\n\n  setFromAxisAngle(axis: Readonly<NumericArray>, rad: number): this {\n    return this.setAxisAngle(axis, rad);\n  }\n\n  premultiply(a: Readonly<NumericArray>): this {\n    return this.multiplyLeft(a);\n  }\n\n  multiply(a: Readonly<NumericArray>): this {\n    return this.multiplyRight(a);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}