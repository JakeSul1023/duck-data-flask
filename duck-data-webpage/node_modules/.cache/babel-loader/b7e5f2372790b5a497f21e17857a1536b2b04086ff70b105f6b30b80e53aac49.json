{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { setGLParameters, getGLParameters } from \"../parameters/unified-parameter-api.js\";\nimport { deepArrayEqual } from \"./deep-array-equal.js\";\nimport { GL_PARAMETER_DEFAULTS, GL_HOOKED_SETTERS, NON_CACHE_PARAMETERS } from \"../parameters/webgl-parameter-tables.js\";\n// HELPER CLASS - WebGLStateTracker\n/**\n * Support for listening to context state changes and intercepting state queries\n * NOTE: this system does not handle buffer bindings\n */\nexport class WebGLStateTracker {\n  static get(gl) {\n    // @ts-expect-error\n    return gl.state;\n  }\n  gl;\n  program = null;\n  stateStack = [];\n  enable = true;\n  cache = null;\n  log;\n  initialized = false;\n  constructor(gl, props) {\n    this.gl = gl;\n    this.log = props?.log || (() => {});\n    this._updateCache = this._updateCache.bind(this);\n    Object.seal(this);\n  }\n  push(values = {}) {\n    this.stateStack.push({});\n  }\n  pop() {\n    // assert(this.stateStack.length > 0);\n    // Use the saved values in the state stack to restore parameters\n    const oldValues = this.stateStack[this.stateStack.length - 1];\n    setGLParameters(this.gl, oldValues);\n    // Don't pop until we have reset parameters (to make sure other \"stack frames\" are not affected)\n    this.stateStack.pop();\n  }\n  /**\n   * Initialize WebGL state caching on a context\n   * can be called multiple times to enable/disable\n   *\n   * @note After calling this function, context state will be cached\n   * .push() and .pop() will be available for saving,\n   * temporarily modifying, and then restoring state.\n   */\n  trackState(gl, options) {\n    this.cache = options.copyState ? getGLParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);\n    if (this.initialized) {\n      throw new Error('WebGLStateTracker');\n    }\n    this.initialized = true;\n    // @ts-expect-error\n    this.gl.state = this;\n    installProgramSpy(gl);\n    // intercept all setter functions in the table\n    for (const key in GL_HOOKED_SETTERS) {\n      const setter = GL_HOOKED_SETTERS[key];\n      installSetterSpy(gl, key, setter);\n    }\n    // intercept all getter functions in the table\n    installGetterOverride(gl, 'getParameter');\n    installGetterOverride(gl, 'isEnabled');\n  }\n  /**\n  // interceptor for context set functions - update our cache and our stack\n  // values (Object) - the key values for this setter\n   * @param values\n   * @returns\n   */\n  _updateCache(values) {\n    let valueChanged = false;\n    let oldValue; // = undefined\n    const oldValues = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;\n    for (const key in values) {\n      // assert(key !== undefined);\n      const value = values[key];\n      const cached = this.cache[key];\n      // Check that value hasn't already been shadowed\n      if (!deepArrayEqual(value, cached)) {\n        valueChanged = true;\n        oldValue = cached;\n        // First, save current value being shadowed\n        // If a state stack frame is active, save the current parameter values for pop\n        // but first check that value hasn't already been shadowed and saved\n        if (oldValues && !(key in oldValues)) {\n          oldValues[key] = cached;\n        }\n        // Save current value being shadowed\n        this.cache[key] = value;\n      }\n    }\n    return {\n      valueChanged,\n      oldValue\n    };\n  }\n}\n// HELPER FUNCTIONS - INSTALL GET/SET INTERCEPTORS (SPYS) ON THE CONTEXT\n/**\n// Overrides a WebGL2RenderingContext state \"getter\" function\n// to return values directly from cache\n * @param gl\n * @param functionName\n */\nfunction installGetterOverride(gl, functionName) {\n  // Get the original function from the WebGL2RenderingContext\n  const originalGetterFunc = gl[functionName].bind(gl);\n  // Wrap it with a spy so that we can update our state cache when it gets called\n  gl[functionName] = function get(pname) {\n    if (pname === undefined || NON_CACHE_PARAMETERS.has(pname)) {\n      // Invalid or blacklisted parameter, do not cache\n      return originalGetterFunc(pname);\n    }\n    const glState = WebGLStateTracker.get(gl);\n    if (!(pname in glState.cache)) {\n      // WebGL limits are not prepopulated in the cache, call the original getter when first queried.\n      glState.cache[pname] = originalGetterFunc(pname);\n    }\n    // Optionally call the original function to do a \"hard\" query from the WebGL2RenderingContext\n    return glState.enable ?\n    // Call the getter the params so that it can e.g. serve from a cache\n    glState.cache[pname] :\n    // Optionally call the original function to do a \"hard\" query from the WebGL2RenderingContext\n    originalGetterFunc(pname);\n  };\n  // Set the name of this anonymous function to help in debugging and profiling\n  Object.defineProperty(gl[functionName], 'name', {\n    value: `${functionName}-from-cache`,\n    configurable: false\n  });\n}\n/**\n// Overrides a WebGL2RenderingContext state \"setter\" function\n// to call a setter spy before the actual setter. Allows us to keep a cache\n// updated with a copy of the WebGL context state.\n * @param gl\n * @param functionName\n * @param setter\n * @returns\n */\nfunction installSetterSpy(gl, functionName, setter) {\n  // Get the original function from the WebGL2RenderingContext\n  if (!gl[functionName]) {\n    // TODO - remove?\n    // This could happen if we try to intercept WebGL2 method on a WebGL1 context\n    return;\n  }\n  const originalSetterFunc = gl[functionName].bind(gl);\n  // Wrap it with a spy so that we can update our state cache when it gets called\n  gl[functionName] = function set(...params) {\n    // Update the value\n    // Call the setter with the state cache and the params so that it can store the parameters\n    const glState = WebGLStateTracker.get(gl);\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const {\n      valueChanged,\n      oldValue\n    } = setter(glState._updateCache, ...params);\n    // Call the original WebGL2RenderingContext func to make sure the context actually gets updated\n    if (valueChanged) {\n      originalSetterFunc(...params);\n    }\n    // Note: if the original function fails to set the value, our state cache will be bad\n    // No solution for this at the moment, but assuming that this is unlikely to be a real problem\n    // We could call the setter after the originalSetterFunc. Concern is that this would\n    // cause different behavior in debug mode, where originalSetterFunc can throw exceptions\n    return oldValue;\n  };\n  // Set the name of this anonymous function to help in debugging and profiling\n  Object.defineProperty(gl[functionName], 'name', {\n    value: `${functionName}-to-cache`,\n    configurable: false\n  });\n}\nfunction installProgramSpy(gl) {\n  const originalUseProgram = gl.useProgram.bind(gl);\n  gl.useProgram = function useProgramLuma(handle) {\n    const glState = WebGLStateTracker.get(gl);\n    if (glState.program !== handle) {\n      originalUseProgram(handle);\n      glState.program = handle;\n    }\n  };\n}\n//# sourceMappingURL=webgl-state-tracker.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}