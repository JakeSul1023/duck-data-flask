{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { DataSource, resolvePath } from '@loaders.gl/loader-utils';\nimport { ImageLoader, getBinaryImageMetadata } from '@loaders.gl/images';\nimport { MVTLoader, TileJSONLoader } from '@loaders.gl/mvt';\n/** Creates an MVTTileSource */\nexport const MVTSource = {\n  name: 'MVT',\n  id: 'mvt',\n  module: 'mvt',\n  version: '0.0.0',\n  extensions: ['mvt'],\n  mimeTypes: ['application/octet-stream'],\n  options: {\n    mvt: {\n      // TODO - add options here\n    }\n  },\n  type: 'mvt',\n  fromUrl: true,\n  fromBlob: false,\n  testURL: url => true,\n  createDataSource(url, props) {\n    return new MVTTileSource(url, props);\n  }\n};\n/**\n * MVT data source for Mapbox Vector Tiles v1.\n */\n/**\n * A PMTiles data source\n * @note Can be either a raster or vector tile source depending on the contents of the PMTiles file.\n */\nexport class MVTTileSource extends DataSource {\n  props;\n  url;\n  metadataUrl = null;\n  data;\n  schema = 'tms';\n  metadata;\n  extension;\n  mimeType = null;\n  constructor(url, props) {\n    super(props);\n    this.props = props;\n    this.url = resolvePath(url);\n    this.metadataUrl = props.mvt?.metadataUrl || `${this.url}/tilejson.json`;\n    this.extension = props.mvt?.extension || '.png';\n    this.data = this.url;\n    this.getTileData = this.getTileData.bind(this);\n    this.metadata = this.getMetadata();\n    if (isURLTemplate(this.url)) {\n      this.schema = 'template';\n    }\n  }\n  // @ts-ignore - Metadata type misalignment\n  async getMetadata() {\n    if (!this.metadataUrl) {\n      return null;\n    }\n    let response;\n    try {\n      // Annoyingly, on CORS errors, fetch doesn't use the response status/ok mechanism but instead throws\n      // CORS errors are common when requesting an unavailable sub resource such as a metadata file or an unavailable tile)\n      response = await this.fetch(this.metadataUrl);\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      console.error(error.message);\n      return null;\n    }\n    if (!response.ok) {\n      // eslint-disable-next-line no-console\n      console.error(response.statusText);\n      return null;\n    }\n    const tileJSON = await response.text();\n    const metadata = TileJSONLoader.parseTextSync?.(tileJSON) || null;\n    // TODO add metadata attributions\n    // metadata.attributions = [...this.props.attributions, ...(metadata.attributions || [])];\n    // if (metadata?.mimeType) {\n    //   this.mimeType = metadata?.tileMIMEType;\n    // }\n    return metadata;\n  }\n  getTileMIMEType() {\n    return this.mimeType;\n  }\n  async getTile(parameters) {\n    const {\n      x,\n      y,\n      z\n    } = parameters;\n    const tileUrl = this.getTileURL(x, y, z);\n    const response = await this.fetch(tileUrl);\n    if (!response.ok) {\n      return null;\n    }\n    const arrayBuffer = await response.arrayBuffer();\n    return arrayBuffer;\n  }\n  // Tile Source interface implementation: deck.gl compatible API\n  // TODO - currently only handles image tiles, not vector tiles\n  async getTileData(parameters) {\n    const {\n      x,\n      y,\n      z\n    } = parameters.index;\n    // const metadata = await this.metadata;\n    // mimeType = metadata?.tileMIMEType || 'application/vnd.mapbox-vector-tile';\n    const arrayBuffer = await this.getTile({\n      x,\n      y,\n      z,\n      layers: []\n    });\n    if (arrayBuffer === null) {\n      return null;\n    }\n    const imageMetadata = getBinaryImageMetadata(arrayBuffer);\n    this.mimeType = this.mimeType || imageMetadata?.mimeType || 'application/vnd.mapbox-vector-tile';\n    switch (this.mimeType) {\n      case 'application/vnd.mapbox-vector-tile':\n        return await this._parseVectorTile(arrayBuffer, {\n          x,\n          y,\n          z,\n          layers: []\n        });\n      default:\n        return await this._parseImageTile(arrayBuffer);\n    }\n  }\n  // ImageTileSource interface implementation\n  async getImageTile(tileParams) {\n    const arrayBuffer = await this.getTile(tileParams);\n    return arrayBuffer ? this._parseImageTile(arrayBuffer) : null;\n  }\n  async _parseImageTile(arrayBuffer) {\n    return await ImageLoader.parse(arrayBuffer, this.loadOptions);\n  }\n  // VectorTileSource interface implementation\n  async getVectorTile(tileParams) {\n    const arrayBuffer = await this.getTile(tileParams);\n    return arrayBuffer ? this._parseVectorTile(arrayBuffer, tileParams) : null;\n  }\n  async _parseVectorTile(arrayBuffer, tileParams) {\n    const loadOptions = {\n      shape: 'geojson-table',\n      mvt: {\n        coordinates: 'wgs84',\n        tileIndex: {\n          x: tileParams.x,\n          y: tileParams.y,\n          z: tileParams.z\n        },\n        ...this.loadOptions?.mvt\n      },\n      ...this.loadOptions\n    };\n    return await MVTLoader.parse(arrayBuffer, loadOptions);\n  }\n  getMetadataUrl() {\n    return this.metadataUrl;\n  }\n  getTileURL(x, y, z) {\n    switch (this.schema) {\n      case 'xyz':\n        return `${this.url}/${x}/${y}/${z}${this.extension}`;\n      case 'tms':\n        return `${this.url}/${z}/${x}/${y}${this.extension}`;\n      case 'template':\n        return getURLFromTemplate(this.url, x, y, z, '0');\n      default:\n        throw new Error(this.schema);\n    }\n  }\n}\nexport function isURLTemplate(s) {\n  return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))|(?=.*{x})(?=.*({y}|{-y})(?=.*{z}))/.test(s);\n}\nconst xRegex = new RegExp('{x}', 'g');\nconst yRegex = new RegExp('{y}', 'g');\nconst zRegex = new RegExp('{z}', 'g');\n/**\n * Get a URL from a URL template\n * @note copied from deck.gl/modules/geo-layers/src/tileset-2d/utils.ts\n * @param template - URL template\n * @param x - tile x coordinate\n * @param y - tile y coordinate\n * @param z - tile z coordinate\n * @param id - tile id\n * @returns URL\n */\nexport function getURLFromTemplate(template, x, y, z, id = '0') {\n  if (Array.isArray(template)) {\n    const i = stringHash(id) % template.length;\n    template = template[i];\n  }\n  let url = template;\n  url = url.replace(xRegex, String(x));\n  url = url.replace(yRegex, String(y));\n  url = url.replace(zRegex, String(z));\n  // Back-compatible support for {-y}\n  if (Number.isInteger(y) && Number.isInteger(z)) {\n    url = url.replace(/\\{-y\\}/g, String(Math.pow(2, z) - y - 1));\n  }\n  return url;\n}\nfunction stringHash(s) {\n  return Math.abs(s.split('').reduce((a, b) => (a << 5) - a + b.charCodeAt(0) | 0, 0));\n}","map":{"version":3,"names":["DataSource","resolvePath","ImageLoader","getBinaryImageMetadata","MVTLoader","TileJSONLoader","MVTSource","name","id","module","version","extensions","mimeTypes","options","mvt","type","fromUrl","fromBlob","testURL","url","createDataSource","props","MVTTileSource","metadataUrl","data","schema","metadata","extension","mimeType","constructor","getTileData","bind","getMetadata","isURLTemplate","response","fetch","error","console","message","ok","statusText","tileJSON","text","parseTextSync","getTileMIMEType","getTile","parameters","x","y","z","tileUrl","getTileURL","arrayBuffer","index","layers","imageMetadata","_parseVectorTile","_parseImageTile","getImageTile","tileParams","parse","loadOptions","getVectorTile","shape","coordinates","tileIndex","getMetadataUrl","getURLFromTemplate","Error","s","test","xRegex","RegExp","yRegex","zRegex","template","Array","isArray","i","stringHash","length","replace","String","Number","isInteger","Math","pow","abs","split","reduce","a","b","charCodeAt"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/mvt/dist/mvt-source.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { DataSource, resolvePath } from '@loaders.gl/loader-utils';\nimport { ImageLoader, getBinaryImageMetadata } from '@loaders.gl/images';\nimport { MVTLoader, TileJSONLoader } from '@loaders.gl/mvt';\n/** Creates an MVTTileSource */\nexport const MVTSource = {\n    name: 'MVT',\n    id: 'mvt',\n    module: 'mvt',\n    version: '0.0.0',\n    extensions: ['mvt'],\n    mimeTypes: ['application/octet-stream'],\n    options: {\n        mvt: {\n        // TODO - add options here\n        }\n    },\n    type: 'mvt',\n    fromUrl: true,\n    fromBlob: false,\n    testURL: (url) => true,\n    createDataSource(url, props) {\n        return new MVTTileSource(url, props);\n    }\n};\n/**\n * MVT data source for Mapbox Vector Tiles v1.\n */\n/**\n * A PMTiles data source\n * @note Can be either a raster or vector tile source depending on the contents of the PMTiles file.\n */\nexport class MVTTileSource extends DataSource {\n    props;\n    url;\n    metadataUrl = null;\n    data;\n    schema = 'tms';\n    metadata;\n    extension;\n    mimeType = null;\n    constructor(url, props) {\n        super(props);\n        this.props = props;\n        this.url = resolvePath(url);\n        this.metadataUrl = props.mvt?.metadataUrl || `${this.url}/tilejson.json`;\n        this.extension = props.mvt?.extension || '.png';\n        this.data = this.url;\n        this.getTileData = this.getTileData.bind(this);\n        this.metadata = this.getMetadata();\n        if (isURLTemplate(this.url)) {\n            this.schema = 'template';\n        }\n    }\n    // @ts-ignore - Metadata type misalignment\n    async getMetadata() {\n        if (!this.metadataUrl) {\n            return null;\n        }\n        let response;\n        try {\n            // Annoyingly, on CORS errors, fetch doesn't use the response status/ok mechanism but instead throws\n            // CORS errors are common when requesting an unavailable sub resource such as a metadata file or an unavailable tile)\n            response = await this.fetch(this.metadataUrl);\n        }\n        catch (error) {\n            // eslint-disable-next-line no-console\n            console.error(error.message);\n            return null;\n        }\n        if (!response.ok) {\n            // eslint-disable-next-line no-console\n            console.error(response.statusText);\n            return null;\n        }\n        const tileJSON = await response.text();\n        const metadata = TileJSONLoader.parseTextSync?.(tileJSON) || null;\n        // TODO add metadata attributions\n        // metadata.attributions = [...this.props.attributions, ...(metadata.attributions || [])];\n        // if (metadata?.mimeType) {\n        //   this.mimeType = metadata?.tileMIMEType;\n        // }\n        return metadata;\n    }\n    getTileMIMEType() {\n        return this.mimeType;\n    }\n    async getTile(parameters) {\n        const { x, y, z } = parameters;\n        const tileUrl = this.getTileURL(x, y, z);\n        const response = await this.fetch(tileUrl);\n        if (!response.ok) {\n            return null;\n        }\n        const arrayBuffer = await response.arrayBuffer();\n        return arrayBuffer;\n    }\n    // Tile Source interface implementation: deck.gl compatible API\n    // TODO - currently only handles image tiles, not vector tiles\n    async getTileData(parameters) {\n        const { x, y, z } = parameters.index;\n        // const metadata = await this.metadata;\n        // mimeType = metadata?.tileMIMEType || 'application/vnd.mapbox-vector-tile';\n        const arrayBuffer = await this.getTile({ x, y, z, layers: [] });\n        if (arrayBuffer === null) {\n            return null;\n        }\n        const imageMetadata = getBinaryImageMetadata(arrayBuffer);\n        this.mimeType =\n            this.mimeType || imageMetadata?.mimeType || 'application/vnd.mapbox-vector-tile';\n        switch (this.mimeType) {\n            case 'application/vnd.mapbox-vector-tile':\n                return await this._parseVectorTile(arrayBuffer, { x, y, z, layers: [] });\n            default:\n                return await this._parseImageTile(arrayBuffer);\n        }\n    }\n    // ImageTileSource interface implementation\n    async getImageTile(tileParams) {\n        const arrayBuffer = await this.getTile(tileParams);\n        return arrayBuffer ? this._parseImageTile(arrayBuffer) : null;\n    }\n    async _parseImageTile(arrayBuffer) {\n        return await ImageLoader.parse(arrayBuffer, this.loadOptions);\n    }\n    // VectorTileSource interface implementation\n    async getVectorTile(tileParams) {\n        const arrayBuffer = await this.getTile(tileParams);\n        return arrayBuffer ? this._parseVectorTile(arrayBuffer, tileParams) : null;\n    }\n    async _parseVectorTile(arrayBuffer, tileParams) {\n        const loadOptions = {\n            shape: 'geojson-table',\n            mvt: {\n                coordinates: 'wgs84',\n                tileIndex: { x: tileParams.x, y: tileParams.y, z: tileParams.z },\n                ...this.loadOptions?.mvt\n            },\n            ...this.loadOptions\n        };\n        return await MVTLoader.parse(arrayBuffer, loadOptions);\n    }\n    getMetadataUrl() {\n        return this.metadataUrl;\n    }\n    getTileURL(x, y, z) {\n        switch (this.schema) {\n            case 'xyz':\n                return `${this.url}/${x}/${y}/${z}${this.extension}`;\n            case 'tms':\n                return `${this.url}/${z}/${x}/${y}${this.extension}`;\n            case 'template':\n                return getURLFromTemplate(this.url, x, y, z, '0');\n            default:\n                throw new Error(this.schema);\n        }\n    }\n}\nexport function isURLTemplate(s) {\n    return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))|(?=.*{x})(?=.*({y}|{-y})(?=.*{z}))/.test(s);\n}\nconst xRegex = new RegExp('{x}', 'g');\nconst yRegex = new RegExp('{y}', 'g');\nconst zRegex = new RegExp('{z}', 'g');\n/**\n * Get a URL from a URL template\n * @note copied from deck.gl/modules/geo-layers/src/tileset-2d/utils.ts\n * @param template - URL template\n * @param x - tile x coordinate\n * @param y - tile y coordinate\n * @param z - tile z coordinate\n * @param id - tile id\n * @returns URL\n */\nexport function getURLFromTemplate(template, x, y, z, id = '0') {\n    if (Array.isArray(template)) {\n        const i = stringHash(id) % template.length;\n        template = template[i];\n    }\n    let url = template;\n    url = url.replace(xRegex, String(x));\n    url = url.replace(yRegex, String(y));\n    url = url.replace(zRegex, String(z));\n    // Back-compatible support for {-y}\n    if (Number.isInteger(y) && Number.isInteger(z)) {\n        url = url.replace(/\\{-y\\}/g, String(Math.pow(2, z) - y - 1));\n    }\n    return url;\n}\nfunction stringHash(s) {\n    return Math.abs(s.split('').reduce((a, b) => ((a << 5) - a + b.charCodeAt(0)) | 0, 0));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}