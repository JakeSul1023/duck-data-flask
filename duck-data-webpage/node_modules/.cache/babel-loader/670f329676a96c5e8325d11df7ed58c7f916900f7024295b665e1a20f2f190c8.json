{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport log from \"../utils/log.js\";\nimport { createMat4, getCameraPosition, getFrustumPlanes } from \"../utils/math-utils.js\";\nimport { Matrix4, Vector3, equals, clamp, mat4 } from '@math.gl/core';\nimport { getDistanceScales, getMeterZoom, lngLatToWorld, worldToLngLat, worldToPixels, pixelsToWorld } from '@math.gl/web-mercator';\nimport { PROJECTION_MODE } from \"../lib/constants.js\";\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nconst IDENTITY = createMat4();\nconst ZERO_VECTOR = [0, 0, 0];\nconst DEFAULT_DISTANCE_SCALES = {\n  unitsPerMeter: [1, 1, 1],\n  metersPerUnit: [1, 1, 1]\n};\n// / Helpers\nfunction createProjectionMatrix({\n  width,\n  height,\n  orthographic,\n  fovyRadians,\n  focalDistance,\n  padding,\n  near,\n  far\n}) {\n  const aspect = width / height;\n  const matrix = orthographic ? new Matrix4().orthographic({\n    fovy: fovyRadians,\n    aspect,\n    focalDistance,\n    near,\n    far\n  }) : new Matrix4().perspective({\n    fovy: fovyRadians,\n    aspect,\n    near,\n    far\n  });\n  if (padding) {\n    const {\n      left = 0,\n      right = 0,\n      top = 0,\n      bottom = 0\n    } = padding;\n    const offsetX = clamp((left + width - right) / 2, 0, width) - width / 2;\n    const offsetY = clamp((top + height - bottom) / 2, 0, height) - height / 2;\n    // pixels to clip space\n    matrix[8] -= offsetX * 2 / width;\n    matrix[9] += offsetY * 2 / height;\n  }\n  return matrix;\n}\n/**\n * Manages coordinate system transformations.\n *\n * Note: The Viewport is immutable in the sense that it only has accessors.\n * A new viewport instance should be created if any parameters have changed.\n */\nclass Viewport {\n  // eslint-disable-next-line complexity\n  constructor(opts = {}) {\n    this._frustumPlanes = {};\n    // @ts-ignore\n    this.id = opts.id || this.constructor.displayName || 'viewport';\n    this.x = opts.x || 0;\n    this.y = opts.y || 0;\n    // Silently allow apps to send in w,h = 0,0\n    this.width = opts.width || 1;\n    this.height = opts.height || 1;\n    this.zoom = opts.zoom || 0;\n    this.padding = opts.padding;\n    this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;\n    this.focalDistance = opts.focalDistance || 1;\n    this.position = opts.position || ZERO_VECTOR;\n    this.modelMatrix = opts.modelMatrix || null;\n    const {\n      longitude,\n      latitude\n    } = opts;\n    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);\n    this._initProps(opts);\n    this._initMatrices(opts);\n    // Bind methods for easy access\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    this.projectFlat = this.projectFlat.bind(this);\n    this.unprojectFlat = this.unprojectFlat.bind(this);\n  }\n  get subViewports() {\n    return null;\n  }\n  get metersPerPixel() {\n    return this.distanceScales.metersPerUnit[2] / this.scale;\n  }\n  get projectionMode() {\n    if (this.isGeospatial) {\n      return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;\n    }\n    return PROJECTION_MODE.IDENTITY;\n  }\n  // Two viewports are equal if width and height are identical, and if\n  // their view and projection matrices are (approximately) equal.\n  equals(viewport) {\n    if (!(viewport instanceof Viewport)) {\n      return false;\n    }\n    if (this === viewport) {\n      return true;\n    }\n    return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && equals(viewport.projectionMatrix, this.projectionMatrix) && equals(viewport.viewMatrix, this.viewMatrix);\n    // TODO - check distance scales?\n  }\n  /**\n   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n   * using viewport projection parameters\n   * - [longitude, latitude] to [x, y]\n   * - [longitude, latitude, Z] => [x, y, z]\n   * Note: By default, returns top-left coordinates for canvas/SVG type render\n   *\n   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]\n   * @param {Object} opts - options\n   * @param {Object} opts.topLeft=true - Whether projected coords are top left\n   * @return {Array} - [x, y] or [x, y, z] in top left coords\n   */\n  project(xyz, {\n    topLeft = true\n  } = {}) {\n    const worldPosition = this.projectPosition(xyz);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  }\n  /**\n   * Unproject pixel coordinates on screen onto world coordinates,\n   * (possibly [lon, lat]) on map.\n   * - [x, y] => [lng, lat]\n   * - [x, y, z] => [lng, lat, Z]\n   * @param {Array} xyz -\n   * @param {Object} opts - options\n   * @param {Object} opts.topLeft=true - Whether origin is top left\n   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]\n   */\n  unproject(xyz, {\n    topLeft = true,\n    targetZ\n  } = {}) {\n    const [x, y, z] = xyz;\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  }\n  // NON_LINEAR PROJECTION HOOKS\n  // Used for web meractor projection\n  projectPosition(xyz) {\n    const [X, Y] = this.projectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n    return [X, Y, Z];\n  }\n  unprojectPosition(xyz) {\n    const [X, Y] = this.unprojectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n    return [X, Y, Z];\n  }\n  /**\n   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n   * Performs the nonlinear part of the web mercator projection.\n   * Remaining projection is done with 4x4 matrices which also handles\n   * perspective.\n   * @param {Array} lngLat - [lng, lat] coordinates\n   *   Specifies a point on the sphere to project onto the map.\n   * @return {Array} [x,y] coordinates.\n   */\n  projectFlat(xyz) {\n    if (this.isGeospatial) {\n      // Shader clamps latitude to +-89.9, see /shaderlib/project/project.glsl.js\n      // lngLatToWorld([0, -89.9])[1] = -317.9934163758329\n      // lngLatToWorld([0, 89.9])[1] = 829.9934163758271\n      const result = lngLatToWorld(xyz);\n      result[1] = clamp(result[1], -318, 830);\n      return result;\n    }\n    return xyz;\n  }\n  /**\n   * Unproject world point [x,y] on map onto {lat, lon} on sphere\n   * @param {object|Vector} xy - object with {x,y} members\n   *  representing point on projected map plane\n   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n   *   Has toArray method if you need a GeoJSON Array.\n   *   Per cartographic tradition, lat and lon are specified as degrees.\n   */\n  unprojectFlat(xyz) {\n    if (this.isGeospatial) {\n      return worldToLngLat(xyz);\n    }\n    return xyz;\n  }\n  /**\n   * Get bounds of the current viewport\n   * @return {Array} - [minX, minY, maxX, maxY]\n   */\n  getBounds(options = {}) {\n    const unprojectOption = {\n      targetZ: options.z || 0\n    };\n    const topLeft = this.unproject([0, 0], unprojectOption);\n    const topRight = this.unproject([this.width, 0], unprojectOption);\n    const bottomLeft = this.unproject([0, this.height], unprojectOption);\n    const bottomRight = this.unproject([this.width, this.height], unprojectOption);\n    return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];\n  }\n  getDistanceScales(coordinateOrigin) {\n    if (coordinateOrigin && this.isGeospatial) {\n      return getDistanceScales({\n        longitude: coordinateOrigin[0],\n        latitude: coordinateOrigin[1],\n        highPrecision: true\n      });\n    }\n    return this.distanceScales;\n  }\n  containsPixel({\n    x,\n    y,\n    width = 1,\n    height = 1\n  }) {\n    return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;\n  }\n  // Extract frustum planes in common space\n  getFrustumPlanes() {\n    if (this._frustumPlanes.near) {\n      // @ts-ignore\n      return this._frustumPlanes;\n    }\n    Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));\n    // @ts-ignore\n    return this._frustumPlanes;\n  }\n  // EXPERIMENTAL METHODS\n  /**\n   * Needed by panning and linear transition\n   * Pan the viewport to place a given world coordinate at screen point [x, y]\n   *\n   * @param {Array} coords - world coordinates\n   * @param {Array} pixel - [x,y] coordinates on screen\n   * @return {Object} props of the new viewport\n   */\n  panByPosition(coords, pixel) {\n    return null;\n  }\n  // INTERNAL METHODS\n  /* eslint-disable complexity, max-statements */\n  _initProps(opts) {\n    const longitude = opts.longitude;\n    const latitude = opts.latitude;\n    if (this.isGeospatial) {\n      if (!Number.isFinite(opts.zoom)) {\n        this.zoom = getMeterZoom({\n          latitude\n        }) + Math.log2(this.focalDistance);\n      }\n      this.distanceScales = opts.distanceScales || getDistanceScales({\n        latitude,\n        longitude\n      });\n    }\n    const scale = Math.pow(2, this.zoom);\n    this.scale = scale;\n    const {\n      position,\n      modelMatrix\n    } = opts;\n    let meterOffset = ZERO_VECTOR;\n    if (position) {\n      meterOffset = modelMatrix ? new Matrix4(modelMatrix).transformAsVector(position, []) : position;\n    }\n    if (this.isGeospatial) {\n      // Determine camera center in common space\n      const center = this.projectPosition([longitude, latitude, 0]);\n      this.center = new Vector3(meterOffset)\n      // Convert to pixels in current zoom\n      .scale(this.distanceScales.unitsPerMeter).add(center);\n    } else {\n      this.center = this.projectPosition(meterOffset);\n    }\n  }\n  /* eslint-enable complexity, max-statements */\n  _initMatrices(opts) {\n    const {\n      // View matrix\n      viewMatrix = IDENTITY,\n      // Projection matrix\n      projectionMatrix = null,\n      // Projection matrix parameters, used if projectionMatrix not supplied\n      orthographic = false,\n      fovyRadians,\n      fovy = 75,\n      near = 0.1,\n      // Distance of near clipping plane\n      far = 1000,\n      // Distance of far clipping plane\n      padding = null,\n      // Center offset in pixels\n      focalDistance = 1\n    } = opts;\n    this.viewMatrixUncentered = viewMatrix;\n    // Make a centered version of the matrix for projection modes without an offset\n    this.viewMatrix = new Matrix4()\n    // Apply the uncentered view matrix\n    .multiplyRight(viewMatrix)\n    // And center it\n    .translate(new Vector3(this.center).negate());\n    this.projectionMatrix = projectionMatrix || createProjectionMatrix({\n      width: this.width,\n      height: this.height,\n      orthographic,\n      fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS,\n      focalDistance,\n      padding,\n      near,\n      far\n    });\n    // Note: As usual, matrix operations should be applied in \"reverse\" order\n    // since vectors will be multiplied in from the right during transformation\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, this.projectionMatrix);\n    mat4.multiply(vpm, vpm, this.viewMatrix);\n    this.viewProjectionMatrix = vpm;\n    // console.log('VPM', this.viewMatrix, this.projectionMatrix, this.viewProjectionMatrix);\n    // Calculate inverse view matrix\n    this.viewMatrixInverse = mat4.invert([], this.viewMatrix) || this.viewMatrix;\n    // Decompose camera parameters\n    this.cameraPosition = getCameraPosition(this.viewMatrixInverse);\n    /*\n     * Builds matrices that converts preprojected lngLats to screen pixels\n     * and vice versa.\n     * Note: Currently returns bottom-left coordinates!\n     * Note: Starts with the GL projection matrix and adds steps to the\n     *       scale and translate that matrix onto the window.\n     * Note: WebGL controls clip space to screen projection with gl.viewport\n     *       and does not need this step.\n     */\n    // matrix for conversion from world location to screen (pixel) coordinates\n    const viewportMatrix = createMat4(); // matrix from NDC to viewport.\n    const pixelProjectionMatrix = createMat4(); // matrix from world space to viewport.\n    mat4.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);\n    mat4.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);\n    mat4.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);\n    this.pixelProjectionMatrix = pixelProjectionMatrix;\n    this.pixelUnprojectionMatrix = mat4.invert(createMat4(), this.pixelProjectionMatrix);\n    if (!this.pixelUnprojectionMatrix) {\n      log.warn('Pixel project matrix not invertible')();\n      // throw new Error('Pixel project matrix not invertible');\n    }\n  }\n}\nViewport.displayName = 'Viewport';\nexport default Viewport;\n//# sourceMappingURL=viewport.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}