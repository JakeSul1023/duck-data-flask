{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { COORDINATE_SYSTEM, project32, Viewport, _deepEqual } from '@deck.gl/core';\nimport { PathLayer, SolidPolygonLayer } from '@deck.gl/layers';\nimport { WebGLAggregator, CPUAggregator } from \"../common/aggregator/index.js\";\nimport AggregationLayer from \"../common/aggregation-layer.js\";\nimport { generateContours } from \"./contour-utils.js\";\nimport { getAggregatorValueReader } from \"./value-reader.js\";\nimport { getBinIdRange } from \"../common/utils/bounds-utils.js\";\nimport { Matrix4 } from '@math.gl/core';\nimport { binOptionsUniforms } from \"./bin-options-uniforms.js\";\nconst DEFAULT_COLOR = [255, 255, 255, 255];\nconst DEFAULT_STROKE_WIDTH = 1;\nconst defaultProps = {\n  // grid aggregation\n  cellSize: {\n    type: 'number',\n    min: 1,\n    value: 1000\n  },\n  gridOrigin: {\n    type: 'array',\n    compare: true,\n    value: [0, 0]\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  gpuAggregation: true,\n  aggregation: 'SUM',\n  // contour lines\n  contours: {\n    type: 'object',\n    value: [{\n      threshold: 1\n    }],\n    optional: true,\n    compare: 3\n  },\n  zOffset: 0.005\n};\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\nclass GridLayer extends AggregationLayer {\n  getAggregatorType() {\n    return this.props.gpuAggregation && WebGLAggregator.isSupported(this.context.device) ? 'gpu' : 'cpu';\n  }\n  createAggregator(type) {\n    if (type === 'cpu') {\n      return new CPUAggregator({\n        dimensions: 2,\n        getBin: {\n          sources: ['positions'],\n          getValue: ({\n            positions\n          }, index, opts) => {\n            const viewport = this.state.aggregatorViewport;\n            // project to common space\n            const p = viewport.projectPosition(positions);\n            const {\n              cellSizeCommon,\n              cellOriginCommon\n            } = opts;\n            return [Math.floor((p[0] - cellOriginCommon[0]) / cellSizeCommon[0]), Math.floor((p[1] - cellOriginCommon[1]) / cellSizeCommon[1])];\n          }\n        },\n        getValue: [{\n          sources: ['counts'],\n          getValue: ({\n            counts\n          }) => counts\n        }],\n        onUpdate: this._onAggregationUpdate.bind(this)\n      });\n    }\n    return new WebGLAggregator(this.context.device, {\n      dimensions: 2,\n      channelCount: 1,\n      bufferLayout: this.getAttributeManager().getBufferLayouts({\n        isInstanced: false\n      }),\n      ...super.getShaders({\n        modules: [project32, binOptionsUniforms],\n        vs: /* glsl */`\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float counts;\n\n  void getBin(out ivec2 binId) {\n    vec3 positionCommon = project_position(positions, positions64Low);\n    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);\n    binId = ivec2(gridCoords);\n  }\n  void getValue(out float value) {\n    value = counts;\n  }\n  `\n      }),\n      onUpdate: this._onAggregationUpdate.bind(this)\n    });\n  }\n  initializeState() {\n    super.initializeState();\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 'float64',\n        fp64: this.use64bitPositions()\n      },\n      counts: {\n        size: 1,\n        accessor: 'getWeight'\n      }\n    });\n  }\n  updateState(params) {\n    const aggregatorChanged = super.updateState(params);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const {\n      aggregator\n    } = this.state;\n    if (aggregatorChanged || changeFlags.dataChanged || props.cellSize !== oldProps.cellSize || !_deepEqual(props.gridOrigin, oldProps.gridOrigin, 1) || props.aggregation !== oldProps.aggregation) {\n      this._updateBinOptions();\n      const {\n        cellSizeCommon,\n        cellOriginCommon,\n        binIdRange\n      } = this.state;\n      aggregator.setProps({\n        // @ts-expect-error only used by GPUAggregator\n        binIdRange,\n        pointCount: this.getNumInstances(),\n        operations: [props.aggregation],\n        binOptions: {\n          cellSizeCommon,\n          cellOriginCommon\n        }\n      });\n    }\n    if (!_deepEqual(oldProps.contours, props.contours, 2)) {\n      // Recalculate contours\n      this.setState({\n        contourData: null\n      });\n    }\n    return aggregatorChanged;\n  }\n  _updateBinOptions() {\n    const bounds = this.getBounds();\n    const cellSizeCommon = [1, 1];\n    let cellOriginCommon = [0, 0];\n    let binIdRange = [[0, 1], [0, 1]];\n    let viewport = this.context.viewport;\n    if (bounds && Number.isFinite(bounds[0][0])) {\n      let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];\n      const {\n        cellSize,\n        gridOrigin\n      } = this.props;\n      const {\n        unitsPerMeter\n      } = viewport.getDistanceScales(centroid);\n      cellSizeCommon[0] = unitsPerMeter[0] * cellSize;\n      cellSizeCommon[1] = unitsPerMeter[1] * cellSize;\n      // Offset common space to center at the origin of the grid cell where the data center is in\n      // This improves precision without affecting the cell positions\n      const centroidCommon = viewport.projectFlat(centroid);\n      cellOriginCommon = [Math.floor((centroidCommon[0] - gridOrigin[0]) / cellSizeCommon[0]) * cellSizeCommon[0] + gridOrigin[0], Math.floor((centroidCommon[1] - gridOrigin[1]) / cellSizeCommon[1]) * cellSizeCommon[1] + gridOrigin[1]];\n      centroid = viewport.unprojectFlat(cellOriginCommon);\n      const ViewportType = viewport.constructor;\n      // We construct a viewport for the GPU aggregator's project module\n      // This viewport is determined by data\n      // removes arbitrary precision variance that depends on initial view state\n      viewport = viewport.isGeospatial ? new ViewportType({\n        longitude: centroid[0],\n        latitude: centroid[1],\n        zoom: 12\n      }) : new Viewport({\n        position: [centroid[0], centroid[1], 0],\n        zoom: 12\n      });\n      // Round to the nearest 32-bit float to match CPU and GPU results\n      cellOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];\n      binIdRange = getBinIdRange({\n        dataBounds: bounds,\n        getBinId: p => {\n          const positionCommon = viewport.projectFlat(p);\n          return [Math.floor((positionCommon[0] - cellOriginCommon[0]) / cellSizeCommon[0]), Math.floor((positionCommon[1] - cellOriginCommon[1]) / cellSizeCommon[1])];\n        }\n      });\n    }\n    this.setState({\n      cellSizeCommon,\n      cellOriginCommon,\n      binIdRange,\n      aggregatorViewport: viewport\n    });\n  }\n  draw(opts) {\n    // Replaces render time viewport with our own\n    if (opts.shaderModuleProps.project) {\n      opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;\n    }\n    super.draw(opts);\n  }\n  _onAggregationUpdate() {\n    const {\n      aggregator,\n      binIdRange\n    } = this.state;\n    this.setState({\n      aggregatedValueReader: getAggregatorValueReader({\n        aggregator,\n        binIdRange,\n        channel: 0\n      }),\n      contourData: null\n    });\n  }\n  _getContours() {\n    const {\n      aggregatedValueReader\n    } = this.state;\n    if (!aggregatedValueReader) {\n      return null;\n    }\n    if (!this.state.contourData) {\n      const {\n        binIdRange\n      } = this.state;\n      const {\n        contours\n      } = this.props;\n      const contourData = generateContours({\n        contours,\n        getValue: aggregatedValueReader,\n        xRange: binIdRange[0],\n        yRange: binIdRange[1]\n      });\n      this.state.contourData = contourData;\n    }\n    return this.state.contourData;\n  }\n  onAttributeChange(id) {\n    const {\n      aggregator\n    } = this.state;\n    switch (id) {\n      case 'positions':\n        aggregator.setNeedsUpdate();\n        this._updateBinOptions();\n        const {\n          cellSizeCommon,\n          cellOriginCommon,\n          binIdRange\n        } = this.state;\n        aggregator.setProps({\n          // @ts-expect-error only used by GPUAggregator\n          binIdRange,\n          binOptions: {\n            cellSizeCommon,\n            cellOriginCommon\n          }\n        });\n        break;\n      case 'counts':\n        aggregator.setNeedsUpdate(0);\n        break;\n      default:\n      // This should not happen\n    }\n  }\n  renderLayers() {\n    const contourData = this._getContours();\n    if (!contourData) {\n      return null;\n    }\n    const {\n      lines,\n      polygons\n    } = contourData;\n    const {\n      zOffset\n    } = this.props;\n    const {\n      cellOriginCommon,\n      cellSizeCommon\n    } = this.state;\n    const LinesSubLayerClass = this.getSubLayerClass('lines', PathLayer);\n    const BandsSubLayerClass = this.getSubLayerClass('bands', SolidPolygonLayer);\n    const modelMatrix = new Matrix4().translate([cellOriginCommon[0], cellOriginCommon[1], 0]).scale([cellSizeCommon[0], cellSizeCommon[1], zOffset]);\n    // Contour lines layer\n    const lineLayer = lines && lines.length > 0 && new LinesSubLayerClass(this.getSubLayerProps({\n      id: 'lines'\n    }), {\n      data: lines,\n      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n      modelMatrix,\n      getPath: d => d.vertices,\n      getColor: d => d.contour.color ?? DEFAULT_COLOR,\n      getWidth: d => d.contour.strokeWidth ?? DEFAULT_STROKE_WIDTH,\n      widthUnits: 'pixels'\n    });\n    // Contour bands layer\n    const bandsLayer = polygons && polygons.length > 0 && new BandsSubLayerClass(this.getSubLayerProps({\n      id: 'bands'\n    }), {\n      data: polygons,\n      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n      modelMatrix,\n      getPolygon: d => d.vertices,\n      getFillColor: d => d.contour.color ?? DEFAULT_COLOR\n    });\n    return [lineLayer, bandsLayer];\n  }\n  getPickingInfo(params) {\n    const info = params.info;\n    const {\n      object\n    } = info;\n    if (object) {\n      info.object = {\n        contour: object.contour\n      };\n    }\n    return info;\n  }\n}\nGridLayer.layerName = 'ContourLayer';\nGridLayer.defaultProps = defaultProps;\nexport default GridLayer;\n//# sourceMappingURL=contour-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}