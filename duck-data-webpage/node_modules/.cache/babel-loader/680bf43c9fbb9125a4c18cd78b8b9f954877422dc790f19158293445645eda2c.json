{"ast":null,"code":"/* eslint-disable camelcase */\nimport * as KHR_binary_glTF from \"../extensions/KHR_binary_gltf.js\";\n// Binary format changes (mainly implemented by GLBLoader)\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n// JSON format changes:\n// https://github.com/khronosgroup/gltf/issues/605\n// - [x] Top-level JSON objects are arrays now\n// - [ ] Removed indirection from animation: sampler now refers directly to accessors, #712\n// - [ ] material.parameter.value and technique.parameter.value must be an array, #690\n// - [ ] Node can have only one mesh #821\n// - [ ] Added reqs on JSON encoding\n// - [ ] Added reqs on binary data alignment #802 (comment)\n// Additions:\n// - [ ] Added accessor.normalized, #691, #706\n// - [ ] Added glExtensionsUsed property and 5125 (UNSIGNED_INT) accessor.componentType value, #619\n// - [ ] Added extensionsRequired property, #720, #721\n// - [ ] Added \"STEP\" as valid animation.sampler.interpolation value, #712\n// Removals:\n// - [x] Removed buffer.type, #786, #629\n// - [ ] Removed revision number from profile.version, #709\n// - [ ] Removed technique.functions.scissor and removed 3089 (SCISSOR_TEST) as a valid value for technique.states.enable, #681\n// - [ ] Techniques, programs, and shaders were moved out to KHR_technique_webgl extension.\n// Other edits:\n// - [x] asset is now required, #642\n// - [ ] buffer.byteLength and bufferView.byteLength are now required, #560.\n// - [ ] accessor.min and accessor.max are now required, #593, and clarified that the JSON value and binary data must be the same, #628.\n// - [ ] Clarified animation.sampler and animation.channel restrictions, #712\n// - [ ] skin.inverseBindMatrices is now optional, #461.\n// - [ ] Attribute parameters can't have a value defined in the technique or parameter, #563 (comment).\n// - [ ] Only TEXCOORD and COLOR attribute semantics can be written in the form [semantic]_[set_index], #563 (comment).\n// - [ ] TEXCOORD and COLOR attribute semantics must be written in the form [semantic]_[set_index], e.g., just TEXCOORD should be TEXCOORD_0, and just COLOR should be COLOR_0, #649\n// - [ ] camera.perspective.aspectRatio and camera.perspective.yfov must now be > 0, not >= 0, #563 (comment).\n// - [ ] Application-specific parameter semantics must start with an underscore, e.g., _TEMPERATURE and _SIMULATION_TIME, #563 (comment).\n// - [ ] Properties in technique.parameters must be defined in technique.uniforms or technique.attributes,\n// #563 (comment).\n// - [ ] technique.parameter.count can only be defined when the semantic is JOINTMATRIX or an application-specific semantic is used. It can never be defined for attribute parameters; only uniforms, d2f6945\n// - [ ] technique.parameter.semantic is required when the parameter is an attribute, 28e113d\n// - [ ] Mesh-only models are allowed, e.g., without materials, #642\n// - [ ] Skeleton hierarchies (nodes containing jointName) must be separated from non-skeleton hierarchies., #647\n// - [ ] technique.states.functions.blendColor and technique.states.functions.depthRange parameters now must match WebGL function min/max, #707\nconst GLTF_ARRAYS = {\n  accessors: 'accessor',\n  animations: 'animation',\n  buffers: 'buffer',\n  bufferViews: 'bufferView',\n  images: 'image',\n  materials: 'material',\n  meshes: 'mesh',\n  nodes: 'node',\n  samplers: 'sampler',\n  scenes: 'scene',\n  skins: 'skin',\n  textures: 'texture'\n};\nconst GLTF_KEYS = {\n  accessor: 'accessors',\n  animations: 'animation',\n  buffer: 'buffers',\n  bufferView: 'bufferViews',\n  image: 'images',\n  material: 'materials',\n  mesh: 'meshes',\n  node: 'nodes',\n  sampler: 'samplers',\n  scene: 'scenes',\n  skin: 'skins',\n  texture: 'textures'\n};\n/**\n * Converts (normalizes) glTF v1 to v2\n */\nclass GLTFV1Normalizer {\n  idToIndexMap = {\n    animations: {},\n    accessors: {},\n    buffers: {},\n    bufferViews: {},\n    images: {},\n    materials: {},\n    meshes: {},\n    nodes: {},\n    samplers: {},\n    scenes: {},\n    skins: {},\n    textures: {}\n  };\n  json;\n  // constructor() {}\n  /**\n   * Convert (normalize) glTF < 2.0 to glTF 2.0\n   * @param gltf - object with json and binChunks\n   * @param options\n   * @param options normalize Whether to actually normalize\n   */\n  normalize(gltf, options) {\n    this.json = gltf.json;\n    const json = gltf.json;\n    // Check version\n    switch (json.asset && json.asset.version) {\n      // We are converting to v2 format. Return if there is nothing to do\n      case '2.0':\n        return;\n      // This class is written to convert 1.0\n      case undefined:\n      case '1.0':\n        break;\n      default:\n        // eslint-disable-next-line no-undef, no-console\n        console.warn(`glTF: Unknown version ${json.asset.version}`);\n        return;\n    }\n    if (!options.normalize) {\n      // We are still missing a few conversion tricks, remove once addressed\n      throw new Error('glTF v1 is not supported.');\n    }\n    // eslint-disable-next-line no-undef, no-console\n    console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');\n    this._addAsset(json);\n    // In glTF2 top-level fields are Arrays not Object maps\n    this._convertTopLevelObjectsToArrays(json);\n    // Extract bufferView indices for images\n    // (this extension needs to be invoked early in the normalization process)\n    // TODO can this be handled by standard extension processing instead of called explicitly?\n    KHR_binary_glTF.preprocess(gltf);\n    // Convert object references from ids to indices\n    this._convertObjectIdsToArrayIndices(json);\n    this._updateObjects(json);\n    this._updateMaterial(json);\n  }\n  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639\n  _addAsset(json) {\n    json.asset = json.asset || {};\n    // We are normalizing to glTF v2, so change version to \"2.0\"\n    json.asset.version = '2.0';\n    json.asset.generator = json.asset.generator || 'Normalized to glTF 2.0 by loaders.gl';\n  }\n  _convertTopLevelObjectsToArrays(json) {\n    // TODO check that all arrays are covered\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertTopLevelObjectToArray(json, arrayName);\n    }\n  }\n  /** Convert one top level object to array */\n  _convertTopLevelObjectToArray(json, mapName) {\n    const objectMap = json[mapName];\n    if (!objectMap || Array.isArray(objectMap)) {\n      return;\n    }\n    // Rewrite the top-level field as an array\n    json[mapName] = [];\n    // Copy the map key into object.id\n    for (const id in objectMap) {\n      const object = objectMap[id];\n      object.id = object.id || id; // Mutates the loaded object\n      const index = json[mapName].length;\n      json[mapName].push(object);\n      this.idToIndexMap[mapName][id] = index;\n    }\n  }\n  /** Go through all objects in all top-level arrays and replace ids with indices */\n  _convertObjectIdsToArrayIndices(json) {\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertIdsToIndices(json, arrayName);\n    }\n    if ('scene' in json) {\n      json.scene = this._convertIdToIndex(json.scene, 'scene');\n    }\n    // Convert any index references that are not using array names\n    // texture.source (image)\n    for (const texture of json.textures) {\n      this._convertTextureIds(texture);\n    }\n    for (const mesh of json.meshes) {\n      this._convertMeshIds(mesh);\n    }\n    for (const node of json.nodes) {\n      this._convertNodeIds(node);\n    }\n    for (const node of json.scenes) {\n      this._convertSceneIds(node);\n    }\n  }\n  _convertTextureIds(texture) {\n    if (texture.source) {\n      texture.source = this._convertIdToIndex(texture.source, 'image');\n    }\n  }\n  _convertMeshIds(mesh) {\n    for (const primitive of mesh.primitives) {\n      const {\n        attributes,\n        indices,\n        material\n      } = primitive;\n      for (const attributeName in attributes) {\n        attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], 'accessor');\n      }\n      if (indices) {\n        primitive.indices = this._convertIdToIndex(indices, 'accessor');\n      }\n      if (material) {\n        primitive.material = this._convertIdToIndex(material, 'material');\n      }\n    }\n  }\n  _convertNodeIds(node) {\n    if (node.children) {\n      node.children = node.children.map(child => this._convertIdToIndex(child, 'node'));\n    }\n    if (node.meshes) {\n      node.meshes = node.meshes.map(mesh => this._convertIdToIndex(mesh, 'mesh'));\n    }\n  }\n  _convertSceneIds(scene) {\n    if (scene.nodes) {\n      scene.nodes = scene.nodes.map(node => this._convertIdToIndex(node, 'node'));\n    }\n  }\n  /** Go through all objects in a top-level array and replace ids with indices */\n  _convertIdsToIndices(json, topLevelArrayName) {\n    if (!json[topLevelArrayName]) {\n      console.warn(`gltf v1: json doesn't contain attribute ${topLevelArrayName}`); // eslint-disable-line no-console, no-undef\n      json[topLevelArrayName] = [];\n    }\n    for (const object of json[topLevelArrayName]) {\n      for (const key in object) {\n        const id = object[key];\n        const index = this._convertIdToIndex(id, key);\n        object[key] = index;\n      }\n    }\n  }\n  _convertIdToIndex(id, key) {\n    const arrayName = GLTF_KEYS[key];\n    if (arrayName in this.idToIndexMap) {\n      const index = this.idToIndexMap[arrayName][id];\n      if (!Number.isFinite(index)) {\n        throw new Error(`gltf v1: failed to resolve ${key} with id ${id}`);\n      }\n      return index;\n    }\n    return id;\n  }\n  /**\n   *\n   * @param {*} json\n   */\n  _updateObjects(json) {\n    for (const buffer of this.json.buffers) {\n      // - [x] Removed buffer.type, #786, #629\n      delete buffer.type;\n    }\n  }\n  /**\n   * Update material (set pbrMetallicRoughness)\n   * @param {*} json\n   */\n  _updateMaterial(json) {\n    for (const material of json.materials) {\n      material.pbrMetallicRoughness = {\n        baseColorFactor: [1, 1, 1, 1],\n        metallicFactor: 1,\n        roughnessFactor: 1\n      };\n      const textureId = material.values?.tex || material.values?.texture2d_0 || material.values?.diffuseTex;\n      const textureIndex = json.textures.findIndex(texture => texture.id === textureId);\n      if (textureIndex !== -1) {\n        material.pbrMetallicRoughness.baseColorTexture = {\n          index: textureIndex\n        };\n      }\n    }\n  }\n}\nexport function normalizeGLTFV1(gltf, options = {}) {\n  return new GLTFV1Normalizer().normalize(gltf, options);\n}","map":{"version":3,"names":["KHR_binary_glTF","GLTF_ARRAYS","accessors","animations","buffers","bufferViews","images","materials","meshes","nodes","samplers","scenes","skins","textures","GLTF_KEYS","accessor","buffer","bufferView","image","material","mesh","node","sampler","scene","skin","texture","GLTFV1Normalizer","idToIndexMap","json","normalize","gltf","options","asset","version","undefined","console","warn","Error","_addAsset","_convertTopLevelObjectsToArrays","preprocess","_convertObjectIdsToArrayIndices","_updateObjects","_updateMaterial","generator","arrayName","_convertTopLevelObjectToArray","mapName","objectMap","Array","isArray","id","object","index","length","push","_convertIdsToIndices","_convertIdToIndex","_convertTextureIds","_convertMeshIds","_convertNodeIds","_convertSceneIds","source","primitive","primitives","attributes","indices","attributeName","children","map","child","topLevelArrayName","key","Number","isFinite","type","pbrMetallicRoughness","baseColorFactor","metallicFactor","roughnessFactor","textureId","values","tex","texture2d_0","diffuseTex","textureIndex","findIndex","baseColorTexture","normalizeGLTFV1"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/gltf/dist/lib/api/normalize-gltf-v1.js"],"sourcesContent":["/* eslint-disable camelcase */\nimport * as KHR_binary_glTF from \"../extensions/KHR_binary_gltf.js\";\n// Binary format changes (mainly implemented by GLBLoader)\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n// JSON format changes:\n// https://github.com/khronosgroup/gltf/issues/605\n// - [x] Top-level JSON objects are arrays now\n// - [ ] Removed indirection from animation: sampler now refers directly to accessors, #712\n// - [ ] material.parameter.value and technique.parameter.value must be an array, #690\n// - [ ] Node can have only one mesh #821\n// - [ ] Added reqs on JSON encoding\n// - [ ] Added reqs on binary data alignment #802 (comment)\n// Additions:\n// - [ ] Added accessor.normalized, #691, #706\n// - [ ] Added glExtensionsUsed property and 5125 (UNSIGNED_INT) accessor.componentType value, #619\n// - [ ] Added extensionsRequired property, #720, #721\n// - [ ] Added \"STEP\" as valid animation.sampler.interpolation value, #712\n// Removals:\n// - [x] Removed buffer.type, #786, #629\n// - [ ] Removed revision number from profile.version, #709\n// - [ ] Removed technique.functions.scissor and removed 3089 (SCISSOR_TEST) as a valid value for technique.states.enable, #681\n// - [ ] Techniques, programs, and shaders were moved out to KHR_technique_webgl extension.\n// Other edits:\n// - [x] asset is now required, #642\n// - [ ] buffer.byteLength and bufferView.byteLength are now required, #560.\n// - [ ] accessor.min and accessor.max are now required, #593, and clarified that the JSON value and binary data must be the same, #628.\n// - [ ] Clarified animation.sampler and animation.channel restrictions, #712\n// - [ ] skin.inverseBindMatrices is now optional, #461.\n// - [ ] Attribute parameters can't have a value defined in the technique or parameter, #563 (comment).\n// - [ ] Only TEXCOORD and COLOR attribute semantics can be written in the form [semantic]_[set_index], #563 (comment).\n// - [ ] TEXCOORD and COLOR attribute semantics must be written in the form [semantic]_[set_index], e.g., just TEXCOORD should be TEXCOORD_0, and just COLOR should be COLOR_0, #649\n// - [ ] camera.perspective.aspectRatio and camera.perspective.yfov must now be > 0, not >= 0, #563 (comment).\n// - [ ] Application-specific parameter semantics must start with an underscore, e.g., _TEMPERATURE and _SIMULATION_TIME, #563 (comment).\n// - [ ] Properties in technique.parameters must be defined in technique.uniforms or technique.attributes,\n// #563 (comment).\n// - [ ] technique.parameter.count can only be defined when the semantic is JOINTMATRIX or an application-specific semantic is used. It can never be defined for attribute parameters; only uniforms, d2f6945\n// - [ ] technique.parameter.semantic is required when the parameter is an attribute, 28e113d\n// - [ ] Mesh-only models are allowed, e.g., without materials, #642\n// - [ ] Skeleton hierarchies (nodes containing jointName) must be separated from non-skeleton hierarchies., #647\n// - [ ] technique.states.functions.blendColor and technique.states.functions.depthRange parameters now must match WebGL function min/max, #707\nconst GLTF_ARRAYS = {\n    accessors: 'accessor',\n    animations: 'animation',\n    buffers: 'buffer',\n    bufferViews: 'bufferView',\n    images: 'image',\n    materials: 'material',\n    meshes: 'mesh',\n    nodes: 'node',\n    samplers: 'sampler',\n    scenes: 'scene',\n    skins: 'skin',\n    textures: 'texture'\n};\nconst GLTF_KEYS = {\n    accessor: 'accessors',\n    animations: 'animation',\n    buffer: 'buffers',\n    bufferView: 'bufferViews',\n    image: 'images',\n    material: 'materials',\n    mesh: 'meshes',\n    node: 'nodes',\n    sampler: 'samplers',\n    scene: 'scenes',\n    skin: 'skins',\n    texture: 'textures'\n};\n/**\n * Converts (normalizes) glTF v1 to v2\n */\nclass GLTFV1Normalizer {\n    idToIndexMap = {\n        animations: {},\n        accessors: {},\n        buffers: {},\n        bufferViews: {},\n        images: {},\n        materials: {},\n        meshes: {},\n        nodes: {},\n        samplers: {},\n        scenes: {},\n        skins: {},\n        textures: {}\n    };\n    json;\n    // constructor() {}\n    /**\n     * Convert (normalize) glTF < 2.0 to glTF 2.0\n     * @param gltf - object with json and binChunks\n     * @param options\n     * @param options normalize Whether to actually normalize\n     */\n    normalize(gltf, options) {\n        this.json = gltf.json;\n        const json = gltf.json;\n        // Check version\n        switch (json.asset && json.asset.version) {\n            // We are converting to v2 format. Return if there is nothing to do\n            case '2.0':\n                return;\n            // This class is written to convert 1.0\n            case undefined:\n            case '1.0':\n                break;\n            default:\n                // eslint-disable-next-line no-undef, no-console\n                console.warn(`glTF: Unknown version ${json.asset.version}`);\n                return;\n        }\n        if (!options.normalize) {\n            // We are still missing a few conversion tricks, remove once addressed\n            throw new Error('glTF v1 is not supported.');\n        }\n        // eslint-disable-next-line no-undef, no-console\n        console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');\n        this._addAsset(json);\n        // In glTF2 top-level fields are Arrays not Object maps\n        this._convertTopLevelObjectsToArrays(json);\n        // Extract bufferView indices for images\n        // (this extension needs to be invoked early in the normalization process)\n        // TODO can this be handled by standard extension processing instead of called explicitly?\n        KHR_binary_glTF.preprocess(gltf);\n        // Convert object references from ids to indices\n        this._convertObjectIdsToArrayIndices(json);\n        this._updateObjects(json);\n        this._updateMaterial(json);\n    }\n    // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639\n    _addAsset(json) {\n        json.asset = json.asset || {};\n        // We are normalizing to glTF v2, so change version to \"2.0\"\n        json.asset.version = '2.0';\n        json.asset.generator = json.asset.generator || 'Normalized to glTF 2.0 by loaders.gl';\n    }\n    _convertTopLevelObjectsToArrays(json) {\n        // TODO check that all arrays are covered\n        for (const arrayName in GLTF_ARRAYS) {\n            this._convertTopLevelObjectToArray(json, arrayName);\n        }\n    }\n    /** Convert one top level object to array */\n    _convertTopLevelObjectToArray(json, mapName) {\n        const objectMap = json[mapName];\n        if (!objectMap || Array.isArray(objectMap)) {\n            return;\n        }\n        // Rewrite the top-level field as an array\n        json[mapName] = [];\n        // Copy the map key into object.id\n        for (const id in objectMap) {\n            const object = objectMap[id];\n            object.id = object.id || id; // Mutates the loaded object\n            const index = json[mapName].length;\n            json[mapName].push(object);\n            this.idToIndexMap[mapName][id] = index;\n        }\n    }\n    /** Go through all objects in all top-level arrays and replace ids with indices */\n    _convertObjectIdsToArrayIndices(json) {\n        for (const arrayName in GLTF_ARRAYS) {\n            this._convertIdsToIndices(json, arrayName);\n        }\n        if ('scene' in json) {\n            json.scene = this._convertIdToIndex(json.scene, 'scene');\n        }\n        // Convert any index references that are not using array names\n        // texture.source (image)\n        for (const texture of json.textures) {\n            this._convertTextureIds(texture);\n        }\n        for (const mesh of json.meshes) {\n            this._convertMeshIds(mesh);\n        }\n        for (const node of json.nodes) {\n            this._convertNodeIds(node);\n        }\n        for (const node of json.scenes) {\n            this._convertSceneIds(node);\n        }\n    }\n    _convertTextureIds(texture) {\n        if (texture.source) {\n            texture.source = this._convertIdToIndex(texture.source, 'image');\n        }\n    }\n    _convertMeshIds(mesh) {\n        for (const primitive of mesh.primitives) {\n            const { attributes, indices, material } = primitive;\n            for (const attributeName in attributes) {\n                attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], 'accessor');\n            }\n            if (indices) {\n                primitive.indices = this._convertIdToIndex(indices, 'accessor');\n            }\n            if (material) {\n                primitive.material = this._convertIdToIndex(material, 'material');\n            }\n        }\n    }\n    _convertNodeIds(node) {\n        if (node.children) {\n            node.children = node.children.map((child) => this._convertIdToIndex(child, 'node'));\n        }\n        if (node.meshes) {\n            node.meshes = node.meshes.map((mesh) => this._convertIdToIndex(mesh, 'mesh'));\n        }\n    }\n    _convertSceneIds(scene) {\n        if (scene.nodes) {\n            scene.nodes = scene.nodes.map((node) => this._convertIdToIndex(node, 'node'));\n        }\n    }\n    /** Go through all objects in a top-level array and replace ids with indices */\n    _convertIdsToIndices(json, topLevelArrayName) {\n        if (!json[topLevelArrayName]) {\n            console.warn(`gltf v1: json doesn't contain attribute ${topLevelArrayName}`); // eslint-disable-line no-console, no-undef\n            json[topLevelArrayName] = [];\n        }\n        for (const object of json[topLevelArrayName]) {\n            for (const key in object) {\n                const id = object[key];\n                const index = this._convertIdToIndex(id, key);\n                object[key] = index;\n            }\n        }\n    }\n    _convertIdToIndex(id, key) {\n        const arrayName = GLTF_KEYS[key];\n        if (arrayName in this.idToIndexMap) {\n            const index = this.idToIndexMap[arrayName][id];\n            if (!Number.isFinite(index)) {\n                throw new Error(`gltf v1: failed to resolve ${key} with id ${id}`);\n            }\n            return index;\n        }\n        return id;\n    }\n    /**\n     *\n     * @param {*} json\n     */\n    _updateObjects(json) {\n        for (const buffer of this.json.buffers) {\n            // - [x] Removed buffer.type, #786, #629\n            delete buffer.type;\n        }\n    }\n    /**\n     * Update material (set pbrMetallicRoughness)\n     * @param {*} json\n     */\n    _updateMaterial(json) {\n        for (const material of json.materials) {\n            material.pbrMetallicRoughness = {\n                baseColorFactor: [1, 1, 1, 1],\n                metallicFactor: 1,\n                roughnessFactor: 1\n            };\n            const textureId = material.values?.tex || material.values?.texture2d_0 || material.values?.diffuseTex;\n            const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);\n            if (textureIndex !== -1) {\n                material.pbrMetallicRoughness.baseColorTexture = { index: textureIndex };\n            }\n        }\n    }\n}\nexport function normalizeGLTFV1(gltf, options = {}) {\n    return new GLTFV1Normalizer().normalize(gltf, options);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}