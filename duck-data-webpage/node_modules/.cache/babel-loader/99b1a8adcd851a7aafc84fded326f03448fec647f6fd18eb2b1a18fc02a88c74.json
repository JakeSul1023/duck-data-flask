{"ast":null,"code":"import { padToNBytes, assert } from '@loaders.gl/loader-utils';\n/** Binary GLTF is little endian. */\nconst LITTLE_ENDIAN = true;\n/** 'glTF' in Big-Endian ASCII */\nconst MAGIC_glTF = 0x676c5446;\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\nconst GLB_V1_CONTENT_FORMAT_JSON = 0x0;\n/** @deprecated - Backward compatibility for old xviz files */\nconst GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;\n/** @deprecated - Backward compatibility for old xviz files */\nconst GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;\nfunction getMagicString(dataView, byteOffset = 0) {\n  return `\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;\n}\n/** Check if the contents of an array buffer contains GLB byte markers */\nexport function isGLB(arrayBuffer, byteOffset = 0, options = {}) {\n  const dataView = new DataView(arrayBuffer);\n  // Check that GLB Header starts with the magic number\n  const {\n    magic = MAGIC_glTF\n  } = options;\n  const magic1 = dataView.getUint32(byteOffset, false);\n  return magic1 === magic || magic1 === MAGIC_glTF;\n}\n/**\n * Synchronously parse a GLB\n * @param glb - Target, Output is stored there\n * @param arrayBuffer - Input data\n * @param byteOffset - Offset into arrayBuffer to start parsing from (for \"embedded\" GLBs, e.g. in 3D tiles)\n * @param options\n * @returns\n */\nexport function parseGLBSync(glb, arrayBuffer, byteOffset = 0, options = {}) {\n  // Check that GLB Header starts with the magic number\n  const dataView = new DataView(arrayBuffer);\n  // Compare format with GLBLoader documentation\n  const type = getMagicString(dataView, byteOffset + 0);\n  const version = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN); // Version 2 of binary glTF container format\n  const byteLength = dataView.getUint32(byteOffset + 8, LITTLE_ENDIAN); // Total byte length of binary file\n  Object.assign(glb, {\n    // Put less important stuff in a header, to avoid clutter\n    header: {\n      byteOffset,\n      // Byte offset into the initial arrayBuffer\n      byteLength,\n      hasBinChunk: false\n    },\n    type,\n    version,\n    json: {},\n    binChunks: []\n  });\n  byteOffset += GLB_FILE_HEADER_SIZE;\n  switch (glb.version) {\n    case 1:\n      return parseGLBV1(glb, dataView, byteOffset);\n    case 2:\n      return parseGLBV2(glb, dataView, byteOffset, options = {});\n    default:\n      throw new Error(`Invalid GLB version ${glb.version}. Only supports version 1 and 2.`);\n  }\n}\n/**\n * Parse a V1 GLB\n * @param glb - target, output is stored in this object\n * @param dataView - Input, memory to be parsed\n * @param byteOffset - Offset of first byte of GLB data in the data view\n * @returns Number of bytes parsed (there could be additional non-GLB data after the GLB)\n */\nfunction parseGLBV1(glb, dataView, byteOffset) {\n  // Sanity: ensure file is big enough to hold at least the headers\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n  // Explanation of GLB structure:\n  // https://cloud.githubusercontent.com/assets/3479527/22600725/36b87122-ea55-11e6-9d40-6fd42819fcab.png\n  const contentLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN); // Byte length of chunk\n  const contentFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN); // Chunk format as uint32\n  byteOffset += GLB_CHUNK_HEADER_SIZE;\n  // GLB v1 only supports a single chunk type\n  assert(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);\n  parseJSONChunk(glb, dataView, byteOffset, contentLength);\n  // No need to call the function padToBytes() from parseJSONChunk()\n  byteOffset += contentLength;\n  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);\n  return byteOffset;\n}\n/**\n * Parse a V2 GLB\n * @param glb - target, output is stored in this object\n * @param dataView - Input, memory to be parsed\n * @param byteOffset - Offset of first byte of GLB data in the data view\n * @returns Number of bytes parsed (there could be additional non-GLB data after the GLB)\n */\nfunction parseGLBV2(glb, dataView, byteOffset, options) {\n  // Sanity: ensure file is big enough to hold at least the first chunk header\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n  parseGLBChunksSync(glb, dataView, byteOffset, options);\n  return byteOffset + glb.header.byteLength;\n}\n/** Iterate over GLB chunks and parse them */\nfunction parseGLBChunksSync(glb, dataView, byteOffset, options) {\n  // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n  // Iterate as long as there is space left for another chunk header\n  while (byteOffset + 8 <= glb.header.byteLength) {\n    const chunkLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN); // Byte length of chunk\n    const chunkFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN); // Chunk format as uint32\n    byteOffset += GLB_CHUNK_HEADER_SIZE;\n    // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n    switch (chunkFormat) {\n      case GLB_CHUNK_TYPE_JSON:\n        parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n      case GLB_CHUNK_TYPE_BIN:\n        parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n      // Backward compatibility for very old xviz files\n      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n      default:\n        // Ignore, per spec\n        // console.warn(`Unknown GLB chunk type`); // eslint-disable-line\n        break;\n    }\n    byteOffset += padToNBytes(chunkLength, 4);\n  }\n  return byteOffset;\n}\n/* Parse a GLB JSON chunk */\nfunction parseJSONChunk(glb, dataView, byteOffset, chunkLength) {\n  // 1. Create a \"view\" of the binary encoded JSON data inside the GLB\n  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);\n  // 2. Decode the JSON binary array into clear text\n  const textDecoder = new TextDecoder('utf8');\n  const jsonText = textDecoder.decode(jsonChunk);\n  // 3. Parse the JSON text into a JavaScript data structure\n  glb.json = JSON.parse(jsonText);\n  return padToNBytes(chunkLength, 4);\n}\n/** Parse a GLB BIN chunk */\nfunction parseBINChunk(glb, dataView, byteOffset, chunkLength) {\n  // Note: BIN chunk can be optional\n  glb.header.hasBinChunk = true;\n  glb.binChunks.push({\n    byteOffset,\n    byteLength: chunkLength,\n    arrayBuffer: dataView.buffer\n    // TODO - copy, or create typed array view?\n  });\n  return padToNBytes(chunkLength, 4);\n}","map":{"version":3,"names":["padToNBytes","assert","LITTLE_ENDIAN","MAGIC_glTF","GLB_FILE_HEADER_SIZE","GLB_CHUNK_HEADER_SIZE","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","GLB_V1_CONTENT_FORMAT_JSON","GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED","GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED","getMagicString","dataView","byteOffset","String","fromCharCode","getUint8","isGLB","arrayBuffer","options","DataView","magic","magic1","getUint32","parseGLBSync","glb","type","version","byteLength","Object","assign","header","hasBinChunk","json","binChunks","parseGLBV1","parseGLBV2","Error","contentLength","contentFormat","parseJSONChunk","parseBINChunk","parseGLBChunksSync","chunkLength","chunkFormat","strict","jsonChunk","Uint8Array","buffer","textDecoder","TextDecoder","jsonText","decode","JSON","parse","push"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-glb.js"],"sourcesContent":["import { padToNBytes, assert } from '@loaders.gl/loader-utils';\n/** Binary GLTF is little endian. */\nconst LITTLE_ENDIAN = true;\n/** 'glTF' in Big-Endian ASCII */\nconst MAGIC_glTF = 0x676c5446;\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\nconst GLB_V1_CONTENT_FORMAT_JSON = 0x0;\n/** @deprecated - Backward compatibility for old xviz files */\nconst GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;\n/** @deprecated - Backward compatibility for old xviz files */\nconst GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;\nfunction getMagicString(dataView, byteOffset = 0) {\n    return `\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;\n}\n/** Check if the contents of an array buffer contains GLB byte markers */\nexport function isGLB(arrayBuffer, byteOffset = 0, options = {}) {\n    const dataView = new DataView(arrayBuffer);\n    // Check that GLB Header starts with the magic number\n    const { magic = MAGIC_glTF } = options;\n    const magic1 = dataView.getUint32(byteOffset, false);\n    return magic1 === magic || magic1 === MAGIC_glTF;\n}\n/**\n * Synchronously parse a GLB\n * @param glb - Target, Output is stored there\n * @param arrayBuffer - Input data\n * @param byteOffset - Offset into arrayBuffer to start parsing from (for \"embedded\" GLBs, e.g. in 3D tiles)\n * @param options\n * @returns\n */\nexport function parseGLBSync(glb, arrayBuffer, byteOffset = 0, options = {}) {\n    // Check that GLB Header starts with the magic number\n    const dataView = new DataView(arrayBuffer);\n    // Compare format with GLBLoader documentation\n    const type = getMagicString(dataView, byteOffset + 0);\n    const version = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN); // Version 2 of binary glTF container format\n    const byteLength = dataView.getUint32(byteOffset + 8, LITTLE_ENDIAN); // Total byte length of binary file\n    Object.assign(glb, {\n        // Put less important stuff in a header, to avoid clutter\n        header: {\n            byteOffset, // Byte offset into the initial arrayBuffer\n            byteLength,\n            hasBinChunk: false\n        },\n        type,\n        version,\n        json: {},\n        binChunks: []\n    });\n    byteOffset += GLB_FILE_HEADER_SIZE;\n    switch (glb.version) {\n        case 1:\n            return parseGLBV1(glb, dataView, byteOffset);\n        case 2:\n            return parseGLBV2(glb, dataView, byteOffset, (options = {}));\n        default:\n            throw new Error(`Invalid GLB version ${glb.version}. Only supports version 1 and 2.`);\n    }\n}\n/**\n * Parse a V1 GLB\n * @param glb - target, output is stored in this object\n * @param dataView - Input, memory to be parsed\n * @param byteOffset - Offset of first byte of GLB data in the data view\n * @returns Number of bytes parsed (there could be additional non-GLB data after the GLB)\n */\nfunction parseGLBV1(glb, dataView, byteOffset) {\n    // Sanity: ensure file is big enough to hold at least the headers\n    assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n    // Explanation of GLB structure:\n    // https://cloud.githubusercontent.com/assets/3479527/22600725/36b87122-ea55-11e6-9d40-6fd42819fcab.png\n    const contentLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN); // Byte length of chunk\n    const contentFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN); // Chunk format as uint32\n    byteOffset += GLB_CHUNK_HEADER_SIZE;\n    // GLB v1 only supports a single chunk type\n    assert(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);\n    parseJSONChunk(glb, dataView, byteOffset, contentLength);\n    // No need to call the function padToBytes() from parseJSONChunk()\n    byteOffset += contentLength;\n    byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);\n    return byteOffset;\n}\n/**\n * Parse a V2 GLB\n * @param glb - target, output is stored in this object\n * @param dataView - Input, memory to be parsed\n * @param byteOffset - Offset of first byte of GLB data in the data view\n * @returns Number of bytes parsed (there could be additional non-GLB data after the GLB)\n */\nfunction parseGLBV2(glb, dataView, byteOffset, options) {\n    // Sanity: ensure file is big enough to hold at least the first chunk header\n    assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n    parseGLBChunksSync(glb, dataView, byteOffset, options);\n    return byteOffset + glb.header.byteLength;\n}\n/** Iterate over GLB chunks and parse them */\nfunction parseGLBChunksSync(glb, dataView, byteOffset, options) {\n    // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n    // Iterate as long as there is space left for another chunk header\n    while (byteOffset + 8 <= glb.header.byteLength) {\n        const chunkLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN); // Byte length of chunk\n        const chunkFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN); // Chunk format as uint32\n        byteOffset += GLB_CHUNK_HEADER_SIZE;\n        // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n        switch (chunkFormat) {\n            case GLB_CHUNK_TYPE_JSON:\n                parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n                break;\n            case GLB_CHUNK_TYPE_BIN:\n                parseBINChunk(glb, dataView, byteOffset, chunkLength);\n                break;\n            // Backward compatibility for very old xviz files\n            case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:\n                if (!options.strict) {\n                    parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n                }\n                break;\n            case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:\n                if (!options.strict) {\n                    parseBINChunk(glb, dataView, byteOffset, chunkLength);\n                }\n                break;\n            default:\n                // Ignore, per spec\n                // console.warn(`Unknown GLB chunk type`); // eslint-disable-line\n                break;\n        }\n        byteOffset += padToNBytes(chunkLength, 4);\n    }\n    return byteOffset;\n}\n/* Parse a GLB JSON chunk */\nfunction parseJSONChunk(glb, dataView, byteOffset, chunkLength) {\n    // 1. Create a \"view\" of the binary encoded JSON data inside the GLB\n    const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);\n    // 2. Decode the JSON binary array into clear text\n    const textDecoder = new TextDecoder('utf8');\n    const jsonText = textDecoder.decode(jsonChunk);\n    // 3. Parse the JSON text into a JavaScript data structure\n    glb.json = JSON.parse(jsonText);\n    return padToNBytes(chunkLength, 4);\n}\n/** Parse a GLB BIN chunk */\nfunction parseBINChunk(glb, dataView, byteOffset, chunkLength) {\n    // Note: BIN chunk can be optional\n    glb.header.hasBinChunk = true;\n    glb.binChunks.push({\n        byteOffset,\n        byteLength: chunkLength,\n        arrayBuffer: dataView.buffer\n        // TODO - copy, or create typed array view?\n    });\n    return padToNBytes(chunkLength, 4);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}