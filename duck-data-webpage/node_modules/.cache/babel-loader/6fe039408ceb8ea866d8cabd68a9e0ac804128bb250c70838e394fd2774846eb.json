{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { equals } from '@math.gl/core';\nimport { _deepEqual as deepEqual } from '@deck.gl/core';\nimport CollisionFilterPass from \"./collision-filter-pass.js\";\n// Factor by which to downscale Collision FBO relative to canvas\nconst DOWNSCALE = 2;\nexport default class CollisionFilterEffect {\n  constructor() {\n    this.id = 'collision-filter-effect';\n    this.props = null;\n    this.useInPicking = true;\n    this.order = 1;\n    this.channels = {};\n    this.collisionFBOs = {};\n  }\n  setup(context) {\n    this.context = context;\n    const {\n      device\n    } = context;\n    this.dummyCollisionMap = device.createTexture({\n      width: 1,\n      height: 1\n    });\n    this.collisionFilterPass = new CollisionFilterPass(device, {\n      id: 'default-collision-filter'\n    });\n  }\n  preRender(_ref) {\n    let {\n      effects: allEffects,\n      layers,\n      layerFilter,\n      viewports,\n      onViewportActive,\n      views,\n      isPicking,\n      preRenderStats = {}\n    } = _ref;\n    // This can only be called in preRender() after setup() where context is populated\n    const {\n      device\n    } = this.context;\n    if (isPicking) {\n      // Do not update on picking pass\n      return;\n    }\n    const collisionLayers = layers.filter(\n    // @ts-ignore\n    _ref2 => {\n      let {\n        props: {\n          visible,\n          collisionEnabled\n        }\n      } = _ref2;\n      return visible && collisionEnabled;\n    });\n    if (collisionLayers.length === 0) {\n      this.channels = {};\n      return;\n    }\n    // Detect if mask has rendered. TODO: better dependency system for Effects\n    const effects = allEffects?.filter(e => e.useInPicking && preRenderStats[e.id]);\n    const maskEffectRendered = preRenderStats['mask-effect']?.didRender;\n    // Collect layers to render\n    const channels = this._groupByCollisionGroup(device, collisionLayers);\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport) || maskEffectRendered;\n    // Resize framebuffers to match canvas\n    for (const collisionGroup in channels) {\n      const collisionFBO = this.collisionFBOs[collisionGroup];\n      const renderInfo = channels[collisionGroup];\n      // @ts-expect-error TODO - assuming WebGL context\n      const [width, height] = device.canvasContext.getPixelSize();\n      collisionFBO.resize({\n        width: width / DOWNSCALE,\n        height: height / DOWNSCALE\n      });\n      this._render(renderInfo, {\n        effects,\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n    }\n    // debugFBO(this.collisionFBOs[Object.keys(channels)[0]], {minimap: true});\n  }\n  _render(renderInfo, _ref3) {\n    let {\n      effects,\n      layerFilter,\n      onViewportActive,\n      views,\n      viewport,\n      viewportChanged\n    } = _ref3;\n    const {\n      collisionGroup\n    } = renderInfo;\n    const oldRenderInfo = this.channels[collisionGroup];\n    if (!oldRenderInfo) {\n      return;\n    }\n    const needsRender = viewportChanged ||\n    // If render info is new\n    renderInfo === oldRenderInfo ||\n    // If sublayers have changed\n    !deepEqual(oldRenderInfo.layers, renderInfo.layers, 1) ||\n    // If a sublayer's bounds have been updated\n    renderInfo.layerBounds.some((b, i) => !equals(b, oldRenderInfo.layerBounds[i])) ||\n    // If a sublayer's isLoaded state has been updated\n    renderInfo.allLayersLoaded !== oldRenderInfo.allLayersLoaded ||\n    // Some prop is in transition\n    renderInfo.layers.some(layer => layer.props.transitions);\n    this.channels[collisionGroup] = renderInfo;\n    if (needsRender) {\n      this.lastViewport = viewport;\n      const collisionFBO = this.collisionFBOs[collisionGroup];\n      // Rerender collision FBO\n      this.collisionFilterPass.renderCollisionMap(collisionFBO, {\n        pass: 'collision-filter',\n        isPicking: true,\n        layers: renderInfo.layers,\n        effects,\n        layerFilter,\n        viewports: viewport ? [viewport] : [],\n        onViewportActive,\n        views,\n        shaderModuleProps: {\n          collision: {\n            enabled: true,\n            // To avoid feedback loop forming between Framebuffer and active Texture.\n            dummyCollisionMap: this.dummyCollisionMap\n          },\n          project: {\n            // @ts-expect-error TODO - assuming WebGL context\n            devicePixelRatio: collisionFBO.device.canvasContext.getDevicePixelRatio() / DOWNSCALE\n          }\n        }\n      });\n    }\n  }\n  /**\n   * Group layers by collisionGroup\n   * Returns a map from collisionGroup to render info\n   */\n  _groupByCollisionGroup(device, collisionLayers) {\n    const channelMap = {};\n    for (const layer of collisionLayers) {\n      const collisionGroup = layer.props.collisionGroup;\n      let channelInfo = channelMap[collisionGroup];\n      if (!channelInfo) {\n        channelInfo = {\n          collisionGroup,\n          layers: [],\n          layerBounds: [],\n          allLayersLoaded: true\n        };\n        channelMap[collisionGroup] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n      if (!layer.isLoaded) {\n        channelInfo.allLayersLoaded = false;\n      }\n    }\n    // Create any new passes and remove any old ones\n    for (const collisionGroup of Object.keys(channelMap)) {\n      if (!this.collisionFBOs[collisionGroup]) {\n        this.createFBO(device, collisionGroup);\n      }\n      if (!this.channels[collisionGroup]) {\n        this.channels[collisionGroup] = channelMap[collisionGroup];\n      }\n    }\n    for (const collisionGroup of Object.keys(this.collisionFBOs)) {\n      if (!channelMap[collisionGroup]) {\n        this.destroyFBO(collisionGroup);\n      }\n    }\n    return channelMap;\n  }\n  getShaderModuleProps(layer) {\n    const {\n      collisionGroup,\n      collisionEnabled\n    } = layer.props;\n    const {\n      collisionFBOs,\n      dummyCollisionMap\n    } = this;\n    const collisionFBO = collisionFBOs[collisionGroup];\n    const enabled = collisionEnabled && Boolean(collisionFBO);\n    return {\n      collision: {\n        enabled,\n        collisionFBO,\n        dummyCollisionMap: dummyCollisionMap\n      }\n    };\n  }\n  cleanup() {\n    if (this.dummyCollisionMap) {\n      this.dummyCollisionMap.delete();\n      this.dummyCollisionMap = undefined;\n    }\n    this.channels = {};\n    for (const collisionGroup of Object.keys(this.collisionFBOs)) {\n      this.destroyFBO(collisionGroup);\n    }\n    this.collisionFBOs = {};\n    this.lastViewport = undefined;\n  }\n  createFBO(device, collisionGroup) {\n    // @ts-expect-error\n    const {\n      width,\n      height\n    } = device.gl.canvas;\n    const collisionMap = device.createTexture({\n      format: 'rgba8unorm',\n      width,\n      height,\n      sampler: {\n        minFilter: 'nearest',\n        magFilter: 'nearest',\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge'\n      }\n    });\n    // @ts-ignore\n    const depthStencilAttachment = device.createTexture({\n      format: 'depth16unorm',\n      width,\n      height,\n      mipmaps: false\n    });\n    this.collisionFBOs[collisionGroup] = device.createFramebuffer({\n      id: `collision-${collisionGroup}`,\n      width,\n      height,\n      colorAttachments: [collisionMap],\n      depthStencilAttachment\n    });\n  }\n  destroyFBO(collisionGroup) {\n    const fbo = this.collisionFBOs[collisionGroup];\n    fbo.colorAttachments[0]?.destroy();\n    fbo.depthStencilAttachment?.destroy();\n    fbo.destroy();\n    delete this.collisionFBOs[collisionGroup];\n  }\n}\n//# sourceMappingURL=collision-filter-effect.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}