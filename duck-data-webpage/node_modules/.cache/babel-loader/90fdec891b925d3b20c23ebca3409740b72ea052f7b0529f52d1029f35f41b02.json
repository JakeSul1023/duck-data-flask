{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { INVALID_INDEX } from \"./picking-uniforms.js\";\n/**\n * Helper class for using the new picking module\n * @todo Port to WebGPU\n * @todo Support multiple models\n * @todo Switching picking module\n */\nexport class PickingManager {\n  device;\n  props;\n  /** Info from latest pick operation */\n  pickInfo = {\n    batchIndex: null,\n    objectIndex: null\n  };\n  /** Framebuffer used for picking */\n  framebuffer = null;\n  static defaultProps = (() => ({\n    shaderInputs: undefined,\n    onObjectPicked: () => {}\n  }))();\n  constructor(device, props) {\n    this.device = device;\n    this.props = {\n      ...PickingManager.defaultProps,\n      ...props\n    };\n  }\n  destroy() {\n    this.framebuffer?.destroy();\n  }\n  // TODO - Ask for a cached framebuffer? a Framebuffer factory?\n  getFramebuffer() {\n    if (!this.framebuffer) {\n      this.framebuffer = this.device.createFramebuffer({\n        colorAttachments: ['rgba8unorm', 'rg32sint'],\n        depthStencilAttachment: 'depth24plus'\n      });\n    }\n    return this.framebuffer;\n  }\n  /** Clear highlighted / picked object */\n  clearPickState() {\n    this.props.shaderInputs.setProps({\n      picking: {\n        highlightedObjectIndex: null\n      }\n    });\n  }\n  /** Prepare for rendering picking colors */\n  beginRenderPass() {\n    const framebuffer = this.getFramebuffer();\n    framebuffer.resize(this.device.getDefaultCanvasContext().getPixelSize());\n    this.props.shaderInputs?.setProps({\n      picking: {\n        isActive: true\n      }\n    });\n    const pickingPass = this.device.beginRenderPass({\n      framebuffer,\n      clearColors: [new Float32Array([0, 0, 0, 0]), new Int32Array([-1, -1, 0, 0])],\n      clearDepth: 1\n    });\n    return pickingPass;\n  }\n  getPickInfo(mousePosition) {\n    const framebuffer = this.getFramebuffer();\n    // use the center pixel location in device pixel range\n    const [pickX, pickY] = this.getPickPosition(mousePosition);\n    // Read back\n    const pixelData = this.device.readPixelsToArrayWebGL(framebuffer, {\n      sourceX: pickX,\n      sourceY: pickY,\n      sourceWidth: 1,\n      sourceHeight: 1,\n      sourceAttachment: 1\n    });\n    if (!pixelData) {\n      return null;\n    }\n    const pickInfo = {\n      objectIndex: pixelData[0] === INVALID_INDEX ? null : pixelData[0],\n      batchIndex: pixelData[1] === INVALID_INDEX ? null : pixelData[1]\n    };\n    // Call callback if picked object has changed\n    if (pickInfo.objectIndex !== this.pickInfo.objectIndex || pickInfo.batchIndex !== this.pickInfo.batchIndex) {\n      this.pickInfo = pickInfo;\n      this.props.onObjectPicked(pickInfo);\n      // console.log(`Object ${pickInfo.objectIndex} in batch ${pickInfo.batchIndex} was picked`)\n    }\n    this.props.shaderInputs?.setProps({\n      picking: {\n        isActive: false,\n        highlightedBatchIndex: pickInfo.batchIndex,\n        highlightedObjectIndex: pickInfo.objectIndex\n      }\n    });\n    return this.pickInfo;\n  }\n  /**\n   * Get pick position in device pixel range\n   * use the center pixel location in device pixel range\n   */\n  getPickPosition(mousePosition) {\n    const devicePixels = this.device.getDefaultCanvasContext().cssToDevicePixels(mousePosition);\n    const pickX = devicePixels.x + Math.floor(devicePixels.width / 2);\n    const pickY = devicePixels.y + Math.floor(devicePixels.height / 2);\n    return [pickX, pickY];\n  }\n}\n//# sourceMappingURL=picking-manager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}