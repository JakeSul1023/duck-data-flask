{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { createRenderTarget } from \"./utils.js\";\nimport { joinLayerBounds, makeViewport, getRenderBounds } from \"../utils/projection-utils.js\";\n/**\n * Manages the lifecycle of the terrain cover (draped textures over a terrain mesh).\n * One terrain cover is created for each unique terrain layer (primitive layer with operation:terrain).\n * It is updated when the terrain source layer's mesh changes or when any of the terrainDrawMode:drape\n * layers requires redraw.\n * During the draw call of a terrain layer, the drape texture is overlaid on top of the layer's own color.\n */\nexport class TerrainCover {\n  constructor(targetLayer) {\n    this.isDirty = true;\n    /** Viewport used to draw into the texture */\n    this.renderViewport = null;\n    /** Bounds of the terrain cover texture, in cartesian space */\n    this.bounds = null;\n    this.layers = [];\n    /** Cached version of targetLayer.getBounds() */\n    this.targetBounds = null;\n    /** targetBounds in cartesian space */\n    this.targetBoundsCommon = null;\n    this.targetLayer = targetLayer;\n    this.tile = getTile(targetLayer);\n  }\n  get id() {\n    return this.targetLayer.id;\n  }\n  /** returns true if the target layer is still in use (i.e. not finalized) */\n  get isActive() {\n    return Boolean(this.targetLayer.getCurrentLayer());\n  }\n  shouldUpdate({\n    targetLayer,\n    viewport,\n    layers,\n    layerNeedsRedraw\n  }) {\n    if (targetLayer) {\n      this.targetLayer = targetLayer;\n    }\n    const sizeChanged = viewport ? this._updateViewport(viewport) : false;\n    let layersChanged = layers ? this._updateLayers(layers) : false;\n    if (layerNeedsRedraw) {\n      for (const id of this.layers) {\n        if (layerNeedsRedraw[id]) {\n          layersChanged = true;\n          // console.log('layer needs redraw', id);\n          break;\n        }\n      }\n    }\n    return layersChanged || sizeChanged;\n  }\n  /** Compare layers with the last version. Only rerender if necessary. */\n  _updateLayers(layers) {\n    let needsRedraw = false;\n    layers = this.tile ? getIntersectingLayers(this.tile, layers) : layers;\n    if (layers.length !== this.layers.length) {\n      needsRedraw = true;\n      // console.log('layers count changed', this.layers.length, '>>', layers.length);\n    } else {\n      for (let i = 0; i < layers.length; i++) {\n        const id = layers[i].id;\n        if (id !== this.layers[i]) {\n          needsRedraw = true;\n          // console.log('layer added/removed', id);\n          break;\n        }\n      }\n    }\n    if (needsRedraw) {\n      this.layers = layers.map(layer => layer.id);\n    }\n    return needsRedraw;\n  }\n  /** Compare viewport and terrain bounds with the last version. Only rerender if necesary. */\n  _updateViewport(viewport) {\n    const targetLayer = this.targetLayer;\n    let shouldRedraw = false;\n    if (this.tile && 'boundingBox' in this.tile) {\n      if (!this.targetBounds) {\n        shouldRedraw = true;\n        this.targetBounds = this.tile.boundingBox;\n        const bottomLeftCommon = viewport.projectPosition(this.targetBounds[0]);\n        const topRightCommon = viewport.projectPosition(this.targetBounds[1]);\n        this.targetBoundsCommon = [bottomLeftCommon[0], bottomLeftCommon[1], topRightCommon[0], topRightCommon[1]];\n      }\n    } else if (this.targetBounds !== targetLayer.getBounds()) {\n      // console.log('bounds changed', this.bounds, '>>', newBounds);\n      shouldRedraw = true;\n      this.targetBounds = targetLayer.getBounds();\n      this.targetBoundsCommon = joinLayerBounds([targetLayer], viewport);\n    }\n    if (!this.targetBoundsCommon) {\n      return false;\n    }\n    const newZoom = Math.ceil(viewport.zoom + 0.5);\n    // If the terrain layer is bound to a tile, always render a texture that cover the whole tile.\n    // Otherwise, use the smaller of layer bounds and the viewport bounds.\n    if (this.tile) {\n      this.bounds = this.targetBoundsCommon;\n    } else {\n      const oldZoom = this.renderViewport?.zoom;\n      shouldRedraw = shouldRedraw || newZoom !== oldZoom;\n      const newBounds = getRenderBounds(this.targetBoundsCommon, viewport);\n      const oldBounds = this.bounds;\n      shouldRedraw = shouldRedraw || !oldBounds || newBounds.some((x, i) => x !== oldBounds[i]);\n      this.bounds = newBounds;\n    }\n    if (shouldRedraw) {\n      this.renderViewport = makeViewport({\n        bounds: this.bounds,\n        zoom: newZoom,\n        viewport\n      });\n    }\n    return shouldRedraw;\n  }\n  getRenderFramebuffer() {\n    if (!this.renderViewport || this.layers.length === 0) {\n      return null;\n    }\n    if (!this.fbo) {\n      this.fbo = createRenderTarget(this.targetLayer.context.device, {\n        id: this.id\n      });\n    }\n    return this.fbo;\n  }\n  getPickingFramebuffer() {\n    if (!this.renderViewport || this.layers.length === 0 && !this.targetLayer.props.pickable) {\n      return null;\n    }\n    if (!this.pickingFbo) {\n      this.pickingFbo = createRenderTarget(this.targetLayer.context.device, {\n        id: `${this.id}-picking`,\n        interpolate: false\n      });\n    }\n    return this.pickingFbo;\n  }\n  filterLayers(layers) {\n    return layers.filter(({\n      id\n    }) => this.layers.includes(id));\n  }\n  delete() {\n    const {\n      fbo,\n      pickingFbo\n    } = this;\n    if (fbo) {\n      fbo.colorAttachments[0].destroy();\n      fbo.destroy();\n    }\n    if (pickingFbo) {\n      pickingFbo.colorAttachments[0].destroy();\n      pickingFbo.destroy();\n    }\n  }\n}\n/**\n * Remove layers that do not overlap with the current terrain cover.\n * This implementation only has effect when a TileLayer is overlaid on top of a TileLayer\n */\nfunction getIntersectingLayers(sourceTile, layers) {\n  return layers.filter(layer => {\n    const tile = getTile(layer);\n    if (tile) {\n      return intersect(sourceTile.boundingBox, tile.boundingBox);\n    }\n    return true;\n  });\n}\n/** If layer is the descendent of a TileLayer, return the corresponding tile. */\nfunction getTile(layer) {\n  while (layer) {\n    // @ts-expect-error tile may not exist\n    const {\n      tile\n    } = layer.props;\n    if (tile) {\n      return tile;\n    }\n    layer = layer.parent;\n  }\n  return null;\n}\nfunction intersect(b1, b2) {\n  if (b1 && b2) {\n    return b1[0][0] < b2[1][0] && b2[0][0] < b1[1][0] && b1[0][1] < b2[1][1] && b2[0][1] < b1[1][1];\n  }\n  return false;\n}","map":{"version":3,"names":["createRenderTarget","joinLayerBounds","makeViewport","getRenderBounds","TerrainCover","constructor","targetLayer","isDirty","renderViewport","bounds","layers","targetBounds","targetBoundsCommon","tile","getTile","id","isActive","Boolean","getCurrentLayer","shouldUpdate","viewport","layerNeedsRedraw","sizeChanged","_updateViewport","layersChanged","_updateLayers","needsRedraw","getIntersectingLayers","length","i","map","layer","shouldRedraw","boundingBox","bottomLeftCommon","projectPosition","topRightCommon","getBounds","newZoom","Math","ceil","zoom","oldZoom","newBounds","oldBounds","some","x","getRenderFramebuffer","fbo","context","device","getPickingFramebuffer","props","pickable","pickingFbo","interpolate","filterLayers","filter","includes","delete","colorAttachments","destroy","sourceTile","intersect","parent","b1","b2"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\extensions\\src\\terrain\\terrain-cover.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Framebuffer} from '@luma.gl/core';\n\nimport type {Layer, Viewport} from '@deck.gl/core';\n\nimport {createRenderTarget} from './utils';\nimport {joinLayerBounds, makeViewport, getRenderBounds, Bounds} from '../utils/projection-utils';\n\ntype TileHeader = {\n  boundingBox: [min: number[], max: number[]];\n};\n\n/**\n * Manages the lifecycle of the terrain cover (draped textures over a terrain mesh).\n * One terrain cover is created for each unique terrain layer (primitive layer with operation:terrain).\n * It is updated when the terrain source layer's mesh changes or when any of the terrainDrawMode:drape\n * layers requires redraw.\n * During the draw call of a terrain layer, the drape texture is overlaid on top of the layer's own color.\n */\nexport class TerrainCover {\n  isDirty: boolean = true;\n  /** The terrain layer that this instance belongs to */\n  targetLayer: Layer;\n  /** Viewport used to draw into the texture */\n  renderViewport: Viewport | null = null;\n  /** Bounds of the terrain cover texture, in cartesian space */\n  bounds: Bounds | null = null;\n\n  private fbo?: Framebuffer;\n  private pickingFbo?: Framebuffer;\n  private layers: string[] = [];\n  private tile: TileHeader | null;\n  /** Cached version of targetLayer.getBounds() */\n  private targetBounds: [number[], number[]] | null = null;\n  /** targetBounds in cartesian space */\n  private targetBoundsCommon: Bounds | null = null;\n\n  constructor(targetLayer: Layer) {\n    this.targetLayer = targetLayer;\n    this.tile = getTile(targetLayer);\n  }\n\n  get id() {\n    return this.targetLayer.id;\n  }\n\n  /** returns true if the target layer is still in use (i.e. not finalized) */\n  get isActive(): boolean {\n    return Boolean(this.targetLayer.getCurrentLayer());\n  }\n\n  shouldUpdate({\n    targetLayer,\n    viewport,\n    layers,\n    layerNeedsRedraw\n  }: {\n    targetLayer?: Layer;\n    viewport?: Viewport;\n    layers?: Layer[];\n    layerNeedsRedraw?: Record<string, boolean>;\n  }): boolean {\n    if (targetLayer) {\n      this.targetLayer = targetLayer;\n    }\n    const sizeChanged = viewport ? this._updateViewport(viewport) : false;\n\n    let layersChanged = layers ? this._updateLayers(layers) : false;\n\n    if (layerNeedsRedraw) {\n      for (const id of this.layers) {\n        if (layerNeedsRedraw[id]) {\n          layersChanged = true;\n          // console.log('layer needs redraw', id);\n          break;\n        }\n      }\n    }\n\n    return layersChanged || sizeChanged;\n  }\n\n  /** Compare layers with the last version. Only rerender if necessary. */\n  private _updateLayers(layers: Layer[]): boolean {\n    let needsRedraw = false;\n    layers = this.tile ? getIntersectingLayers(this.tile, layers) : layers;\n\n    if (layers.length !== this.layers.length) {\n      needsRedraw = true;\n      // console.log('layers count changed', this.layers.length, '>>', layers.length);\n    } else {\n      for (let i = 0; i < layers.length; i++) {\n        const id = layers[i].id;\n        if (id !== this.layers[i]) {\n          needsRedraw = true;\n          // console.log('layer added/removed', id);\n          break;\n        }\n      }\n    }\n    if (needsRedraw) {\n      this.layers = layers.map(layer => layer.id);\n    }\n    return needsRedraw;\n  }\n\n  /** Compare viewport and terrain bounds with the last version. Only rerender if necesary. */\n  private _updateViewport(viewport: Viewport): boolean {\n    const targetLayer = this.targetLayer;\n    let shouldRedraw = false;\n\n    if (this.tile && 'boundingBox' in this.tile) {\n      if (!this.targetBounds) {\n        shouldRedraw = true;\n        this.targetBounds = this.tile.boundingBox;\n\n        const bottomLeftCommon = viewport.projectPosition(this.targetBounds[0]);\n        const topRightCommon = viewport.projectPosition(this.targetBounds[1]);\n        this.targetBoundsCommon = [\n          bottomLeftCommon[0],\n          bottomLeftCommon[1],\n          topRightCommon[0],\n          topRightCommon[1]\n        ];\n      }\n    } else if (this.targetBounds !== targetLayer.getBounds()) {\n      // console.log('bounds changed', this.bounds, '>>', newBounds);\n      shouldRedraw = true;\n      this.targetBounds = targetLayer.getBounds();\n      this.targetBoundsCommon = joinLayerBounds([targetLayer], viewport);\n    }\n\n    if (!this.targetBoundsCommon) {\n      return false;\n    }\n\n    const newZoom = Math.ceil(viewport.zoom + 0.5);\n    // If the terrain layer is bound to a tile, always render a texture that cover the whole tile.\n    // Otherwise, use the smaller of layer bounds and the viewport bounds.\n    if (this.tile) {\n      this.bounds = this.targetBoundsCommon;\n    } else {\n      const oldZoom = this.renderViewport?.zoom;\n      shouldRedraw = shouldRedraw || newZoom !== oldZoom;\n      const newBounds = getRenderBounds(this.targetBoundsCommon, viewport);\n      const oldBounds = this.bounds;\n      shouldRedraw = shouldRedraw || !oldBounds || newBounds.some((x, i) => x !== oldBounds[i]);\n      this.bounds = newBounds;\n    }\n\n    if (shouldRedraw) {\n      this.renderViewport = makeViewport({\n        bounds: this.bounds,\n        zoom: newZoom,\n        viewport\n      });\n    }\n\n    return shouldRedraw;\n  }\n\n  getRenderFramebuffer(): Framebuffer | null {\n    if (!this.renderViewport || this.layers.length === 0) {\n      return null;\n    }\n    if (!this.fbo) {\n      this.fbo = createRenderTarget(this.targetLayer.context.device, {id: this.id});\n    }\n    return this.fbo;\n  }\n\n  getPickingFramebuffer(): Framebuffer | null {\n    if (!this.renderViewport || (this.layers.length === 0 && !this.targetLayer.props.pickable)) {\n      return null;\n    }\n    if (!this.pickingFbo) {\n      this.pickingFbo = createRenderTarget(this.targetLayer.context.device, {\n        id: `${this.id}-picking`,\n        interpolate: false\n      });\n    }\n    return this.pickingFbo;\n  }\n\n  filterLayers(layers: Layer[]) {\n    return layers.filter(({id}) => this.layers.includes(id));\n  }\n\n  delete() {\n    const {fbo, pickingFbo} = this;\n    if (fbo) {\n      fbo.colorAttachments[0].destroy();\n      fbo.destroy();\n    }\n    if (pickingFbo) {\n      pickingFbo.colorAttachments[0].destroy();\n      pickingFbo.destroy();\n    }\n  }\n}\n\n/**\n * Remove layers that do not overlap with the current terrain cover.\n * This implementation only has effect when a TileLayer is overlaid on top of a TileLayer\n */\nfunction getIntersectingLayers(sourceTile: TileHeader, layers: Layer[]): Layer[] {\n  return layers.filter(layer => {\n    const tile = getTile(layer);\n    if (tile) {\n      return intersect(sourceTile.boundingBox, tile.boundingBox);\n    }\n    return true;\n  });\n}\n\n/** If layer is the descendent of a TileLayer, return the corresponding tile. */\nfunction getTile(layer: Layer): TileHeader | null {\n  while (layer) {\n    // @ts-expect-error tile may not exist\n    const {tile} = layer.props;\n    if (tile) {\n      return tile;\n    }\n    layer = layer.parent as Layer;\n  }\n  return null;\n}\n\nfunction intersect(b1?: [number[], number[]], b2?: [number[], number[]]): boolean {\n  if (b1 && b2) {\n    return b1[0][0] < b2[1][0] && b2[0][0] < b1[1][0] && b1[0][1] < b2[1][1] && b2[0][1] < b1[1][1];\n  }\n  return false;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}