{"ast":null,"code":"import { isBrowser, WorkerFarm, getWorkerURL } from '@loaders.gl/worker-utils';\n/**\n * Determines if a loader can parse with worker\n * @param loader\n * @param options\n */\nexport function canParseWithWorker(loader, options) {\n  if (!WorkerFarm.isSupported()) {\n    return false;\n  }\n  // Node workers are still experimental\n  if (!isBrowser && !options?._nodeWorkers) {\n    return false;\n  }\n  return loader.worker && options?.worker;\n}\n/**\n * this function expects that the worker function sends certain messages,\n * this can be automated if the worker is wrapper by a call to createLoaderWorker in @loaders.gl/loader-utils.\n */\nexport async function parseWithWorker(loader, data, options, context, parseOnMainThread) {\n  const name = loader.id; // TODO\n  const url = getWorkerURL(loader, options);\n  const workerFarm = WorkerFarm.getWorkerFarm(options);\n  const workerPool = workerFarm.getWorkerPool({\n    name,\n    url\n  });\n  // options.log object contains functions which cannot be transferred\n  // context.fetch & context.parse functions cannot be transferred\n  // TODO - decide how to handle logging on workers\n  options = JSON.parse(JSON.stringify(options));\n  context = JSON.parse(JSON.stringify(context || {}));\n  const job = await workerPool.startJob('process-on-worker',\n  // @ts-expect-error\n  onMessage.bind(null, parseOnMainThread) // eslint-disable-line @typescript-eslint/no-misused-promises\n  );\n  job.postMessage('process', {\n    // @ts-ignore\n    input: data,\n    options,\n    context\n  });\n  const result = await job.result;\n  // TODO - what is going on here?\n  return await result.result;\n}\n/**\n * Handle worker's responses to the main thread\n * @param job\n * @param type\n * @param payload\n */\nasync function onMessage(parseOnMainThread, job, type, payload) {\n  switch (type) {\n    case 'done':\n      job.done(payload);\n      break;\n    case 'error':\n      job.error(new Error(payload.error));\n      break;\n    case 'process':\n      // Worker is asking for main thread to parseO\n      const {\n        id,\n        input,\n        options\n      } = payload;\n      try {\n        const result = await parseOnMainThread(input, options);\n        job.postMessage('done', {\n          id,\n          result\n        });\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'unknown error';\n        job.postMessage('error', {\n          id,\n          error: message\n        });\n      }\n      break;\n    default:\n      // eslint-disable-next-line\n      console.warn(`parse-with-worker unknown message ${type}`);\n  }\n}","map":{"version":3,"names":["isBrowser","WorkerFarm","getWorkerURL","canParseWithWorker","loader","options","isSupported","_nodeWorkers","worker","parseWithWorker","data","context","parseOnMainThread","name","id","url","workerFarm","getWorkerFarm","workerPool","getWorkerPool","JSON","parse","stringify","job","startJob","onMessage","bind","postMessage","input","result","type","payload","done","error","Error","message","console","warn"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js"],"sourcesContent":["import { isBrowser, WorkerFarm, getWorkerURL } from '@loaders.gl/worker-utils';\n/**\n * Determines if a loader can parse with worker\n * @param loader\n * @param options\n */\nexport function canParseWithWorker(loader, options) {\n    if (!WorkerFarm.isSupported()) {\n        return false;\n    }\n    // Node workers are still experimental\n    if (!isBrowser && !options?._nodeWorkers) {\n        return false;\n    }\n    return loader.worker && options?.worker;\n}\n/**\n * this function expects that the worker function sends certain messages,\n * this can be automated if the worker is wrapper by a call to createLoaderWorker in @loaders.gl/loader-utils.\n */\nexport async function parseWithWorker(loader, data, options, context, parseOnMainThread) {\n    const name = loader.id; // TODO\n    const url = getWorkerURL(loader, options);\n    const workerFarm = WorkerFarm.getWorkerFarm(options);\n    const workerPool = workerFarm.getWorkerPool({ name, url });\n    // options.log object contains functions which cannot be transferred\n    // context.fetch & context.parse functions cannot be transferred\n    // TODO - decide how to handle logging on workers\n    options = JSON.parse(JSON.stringify(options));\n    context = JSON.parse(JSON.stringify(context || {}));\n    const job = await workerPool.startJob('process-on-worker', \n    // @ts-expect-error\n    onMessage.bind(null, parseOnMainThread) // eslint-disable-line @typescript-eslint/no-misused-promises\n    );\n    job.postMessage('process', {\n        // @ts-ignore\n        input: data,\n        options,\n        context\n    });\n    const result = await job.result;\n    // TODO - what is going on here?\n    return await result.result;\n}\n/**\n * Handle worker's responses to the main thread\n * @param job\n * @param type\n * @param payload\n */\nasync function onMessage(parseOnMainThread, job, type, payload) {\n    switch (type) {\n        case 'done':\n            job.done(payload);\n            break;\n        case 'error':\n            job.error(new Error(payload.error));\n            break;\n        case 'process':\n            // Worker is asking for main thread to parseO\n            const { id, input, options } = payload;\n            try {\n                const result = await parseOnMainThread(input, options);\n                job.postMessage('done', { id, result });\n            }\n            catch (error) {\n                const message = error instanceof Error ? error.message : 'unknown error';\n                job.postMessage('error', { id, error: message });\n            }\n            break;\n        default:\n            // eslint-disable-next-line\n            console.warn(`parse-with-worker unknown message ${type}`);\n    }\n}\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,UAAU,EAAEC,YAAY,QAAQ,0BAA0B;AAC9E;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,kBAAkBA,CAACC,MAAM,EAAEC,OAAO,EAAE;EAChD,IAAI,CAACJ,UAAU,CAACK,WAAW,CAAC,CAAC,EAAE;IAC3B,OAAO,KAAK;EAChB;EACA;EACA,IAAI,CAACN,SAAS,IAAI,CAACK,OAAO,EAAEE,YAAY,EAAE;IACtC,OAAO,KAAK;EAChB;EACA,OAAOH,MAAM,CAACI,MAAM,IAAIH,OAAO,EAAEG,MAAM;AAC3C;AACA;AACA;AACA;AACA;AACA,OAAO,eAAeC,eAAeA,CAACL,MAAM,EAAEM,IAAI,EAAEL,OAAO,EAAEM,OAAO,EAAEC,iBAAiB,EAAE;EACrF,MAAMC,IAAI,GAAGT,MAAM,CAACU,EAAE,CAAC,CAAC;EACxB,MAAMC,GAAG,GAAGb,YAAY,CAACE,MAAM,EAAEC,OAAO,CAAC;EACzC,MAAMW,UAAU,GAAGf,UAAU,CAACgB,aAAa,CAACZ,OAAO,CAAC;EACpD,MAAMa,UAAU,GAAGF,UAAU,CAACG,aAAa,CAAC;IAAEN,IAAI;IAAEE;EAAI,CAAC,CAAC;EAC1D;EACA;EACA;EACAV,OAAO,GAAGe,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACjB,OAAO,CAAC,CAAC;EAC7CM,OAAO,GAAGS,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACX,OAAO,IAAI,CAAC,CAAC,CAAC,CAAC;EACnD,MAAMY,GAAG,GAAG,MAAML,UAAU,CAACM,QAAQ,CAAC,mBAAmB;EACzD;EACAC,SAAS,CAACC,IAAI,CAAC,IAAI,EAAEd,iBAAiB,CAAC,CAAC;EACxC,CAAC;EACDW,GAAG,CAACI,WAAW,CAAC,SAAS,EAAE;IACvB;IACAC,KAAK,EAAElB,IAAI;IACXL,OAAO;IACPM;EACJ,CAAC,CAAC;EACF,MAAMkB,MAAM,GAAG,MAAMN,GAAG,CAACM,MAAM;EAC/B;EACA,OAAO,MAAMA,MAAM,CAACA,MAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeJ,SAASA,CAACb,iBAAiB,EAAEW,GAAG,EAAEO,IAAI,EAAEC,OAAO,EAAE;EAC5D,QAAQD,IAAI;IACR,KAAK,MAAM;MACPP,GAAG,CAACS,IAAI,CAACD,OAAO,CAAC;MACjB;IACJ,KAAK,OAAO;MACRR,GAAG,CAACU,KAAK,CAAC,IAAIC,KAAK,CAACH,OAAO,CAACE,KAAK,CAAC,CAAC;MACnC;IACJ,KAAK,SAAS;MACV;MACA,MAAM;QAAEnB,EAAE;QAAEc,KAAK;QAAEvB;MAAQ,CAAC,GAAG0B,OAAO;MACtC,IAAI;QACA,MAAMF,MAAM,GAAG,MAAMjB,iBAAiB,CAACgB,KAAK,EAAEvB,OAAO,CAAC;QACtDkB,GAAG,CAACI,WAAW,CAAC,MAAM,EAAE;UAAEb,EAAE;UAAEe;QAAO,CAAC,CAAC;MAC3C,CAAC,CACD,OAAOI,KAAK,EAAE;QACV,MAAME,OAAO,GAAGF,KAAK,YAAYC,KAAK,GAAGD,KAAK,CAACE,OAAO,GAAG,eAAe;QACxEZ,GAAG,CAACI,WAAW,CAAC,OAAO,EAAE;UAAEb,EAAE;UAAEmB,KAAK,EAAEE;QAAQ,CAAC,CAAC;MACpD;MACA;IACJ;MACI;MACAC,OAAO,CAACC,IAAI,CAAC,qCAAqCP,IAAI,EAAE,CAAC;EACjE;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}