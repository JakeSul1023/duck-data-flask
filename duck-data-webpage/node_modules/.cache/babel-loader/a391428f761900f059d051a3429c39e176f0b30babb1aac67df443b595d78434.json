{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { path } from '@loaders.gl/loader-utils';\nimport { Tile3DSubtreeLoader } from \"../../tile-3d-subtree-loader.js\";\nimport { load } from '@loaders.gl/core';\nimport { LOD_METRIC_TYPE, TILE_REFINEMENT, TILE_TYPE } from '@loaders.gl/tiles';\nimport { parseImplicitTiles, replaceContentUrlTemplate } from \"./helpers/parse-3d-implicit-tiles.js\";\nimport { convertS2BoundingVolumetoOBB } from \"../utils/obb/s2-corners-to-obb.js\";\nfunction getTileType(tile) {\n  let tileContentUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  if (!tileContentUrl) {\n    return TILE_TYPE.EMPTY;\n  }\n  const contentUrl = tileContentUrl.split('?')[0]; // Discard query string\n  const fileExtension = contentUrl.split('.').pop();\n  switch (fileExtension) {\n    case 'pnts':\n      return TILE_TYPE.POINTCLOUD;\n    case 'i3dm':\n    case 'b3dm':\n    case 'glb':\n    case 'gltf':\n      return TILE_TYPE.SCENEGRAPH;\n    default:\n      return fileExtension || TILE_TYPE.EMPTY;\n  }\n}\nfunction getRefine(refine) {\n  switch (refine) {\n    case 'REPLACE':\n    case 'replace':\n      return TILE_REFINEMENT.REPLACE;\n    case 'ADD':\n    case 'add':\n      return TILE_REFINEMENT.ADD;\n    default:\n      return refine;\n  }\n}\nfunction resolveUri(uri, basePath) {\n  // url scheme per RFC3986\n  const urlSchemeRegex = /^[a-z][0-9a-z+.-]*:/i;\n  if (urlSchemeRegex.test(basePath)) {\n    const url = new URL(uri, `${basePath}/`);\n    return decodeURI(url.toString());\n  } else if (uri.startsWith('/')) {\n    return uri;\n  }\n  return path.resolve(basePath, uri);\n}\nexport function normalizeTileData(tile, basePath) {\n  if (!tile) {\n    return null;\n  }\n  let tileContentUrl;\n  if (tile.content) {\n    const contentUri = tile.content.uri || tile.content?.url;\n    if (typeof contentUri !== 'undefined') {\n      // sparse implicit tilesets may not define content for all nodes\n      tileContentUrl = resolveUri(contentUri, basePath);\n    }\n  }\n  const tilePostprocessed = {\n    ...tile,\n    id: tileContentUrl,\n    contentUrl: tileContentUrl,\n    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n    lodMetricValue: tile.geometricError,\n    transformMatrix: tile.transform,\n    type: getTileType(tile, tileContentUrl),\n    refine: getRefine(tile.refine)\n  };\n  return tilePostprocessed;\n}\n// normalize tile headers\nexport async function normalizeTileHeaders(tileset, basePath, options) {\n  let root = null;\n  const rootImplicitTilingExtension = getImplicitTilingExtensionData(tileset.root);\n  if (rootImplicitTilingExtension && tileset.root) {\n    root = await normalizeImplicitTileHeaders(tileset.root, tileset, basePath, rootImplicitTilingExtension, options);\n  } else {\n    root = normalizeTileData(tileset.root, basePath);\n  }\n  const stack = [];\n  stack.push(root);\n  while (stack.length > 0) {\n    const tile = stack.pop() || {};\n    const children = tile.children || [];\n    const childrenPostprocessed = [];\n    for (const childHeader of children) {\n      const childImplicitTilingExtension = getImplicitTilingExtensionData(childHeader);\n      let childHeaderPostprocessed;\n      if (childImplicitTilingExtension) {\n        childHeaderPostprocessed = await normalizeImplicitTileHeaders(childHeader, tileset, basePath, childImplicitTilingExtension, options);\n      } else {\n        childHeaderPostprocessed = normalizeTileData(childHeader, basePath);\n      }\n      if (childHeaderPostprocessed) {\n        childrenPostprocessed.push(childHeaderPostprocessed);\n        stack.push(childHeaderPostprocessed);\n      }\n    }\n    tile.children = childrenPostprocessed;\n  }\n  return root;\n}\n/**\n * Do normalisation of implicit tile headers\n * TODO Check if Tile3D class can be a return type here.\n * @param tileset\n */\nexport async function normalizeImplicitTileHeaders(tile, tileset, basePath, implicitTilingExtension, options) {\n  const {\n    subdivisionScheme,\n    maximumLevel,\n    availableLevels,\n    subtreeLevels,\n    subtrees: {\n      uri: subtreesUriTemplate\n    }\n  } = implicitTilingExtension;\n  const replacedUrlTemplate = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);\n  const subtreeUrl = resolveUri(replacedUrlTemplate, basePath);\n  const subtree = await load(subtreeUrl, Tile3DSubtreeLoader, options);\n  const tileContentUri = tile.content?.uri;\n  const contentUrlTemplate = tileContentUri ? resolveUri(tileContentUri, basePath) : '';\n  const refine = tileset?.root?.refine;\n  // @ts-ignore\n  const rootLodMetricValue = tile.geometricError;\n  // Replace tile.boundingVolume with the the bounding volume specified by the extensions['3DTILES_bounding_volume_S2']\n  const s2VolumeInfo = tile.boundingVolume.extensions?.['3DTILES_bounding_volume_S2'];\n  if (s2VolumeInfo) {\n    const box = convertS2BoundingVolumetoOBB(s2VolumeInfo);\n    const s2VolumeBox = {\n      box,\n      s2VolumeInfo\n    };\n    tile.boundingVolume = s2VolumeBox;\n  }\n  const rootBoundingVolume = tile.boundingVolume;\n  const implicitOptions = {\n    contentUrlTemplate,\n    subtreesUriTemplate,\n    subdivisionScheme,\n    subtreeLevels,\n    maximumLevel: Number.isFinite(availableLevels) ? availableLevels - 1 : maximumLevel,\n    refine,\n    basePath,\n    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n    rootLodMetricValue,\n    rootBoundingVolume,\n    getTileType,\n    getRefine\n  };\n  return await normalizeImplicitTileData(tile, basePath, subtree, implicitOptions, options);\n}\n/**\n * Do implicit data normalisation to create hierarchical tile structure\n * @param tile\n * @param rootSubtree\n * @param options\n * @returns\n */\nexport async function normalizeImplicitTileData(tile, basePath, rootSubtree, implicitOptions, loaderOptions) {\n  if (!tile) {\n    return null;\n  }\n  const {\n    children,\n    contentUrl\n  } = await parseImplicitTiles({\n    subtree: rootSubtree,\n    implicitOptions,\n    loaderOptions\n  });\n  let tileContentUrl;\n  let tileContent = null;\n  if (contentUrl) {\n    tileContentUrl = contentUrl;\n    tileContent = {\n      uri: contentUrl.replace(`${basePath}/`, '')\n    };\n  }\n  const tilePostprocessed = {\n    ...tile,\n    id: tileContentUrl,\n    contentUrl: tileContentUrl,\n    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n    lodMetricValue: tile.geometricError,\n    transformMatrix: tile.transform,\n    type: getTileType(tile, tileContentUrl),\n    refine: getRefine(tile.refine),\n    content: tileContent || tile.content,\n    children\n  };\n  return tilePostprocessed;\n}\n/**\n * Implicit Tiling data can be in 3DTILES_implicit_tiling for 3DTiles v.Next or directly in implicitTiling object for 3DTiles v1.1.\n * Spec 3DTiles v.Next - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling\n * Spec 3DTiles v.1.1 - https://github.com/CesiumGS/3d-tiles/tree/draft-1.1/specification/ImplicitTiling\n * @param tile\n * @returns\n */\nfunction getImplicitTilingExtensionData(tile) {\n  return tile?.extensions?.['3DTILES_implicit_tiling'] || tile?.implicitTiling;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}