{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// deck.gl, MIT license\n// Attributions:\n// Copyright 2022 Foursquare Labs, Inc.\n/* eslint-disable camelcase */ // Some WMS parameters are not in camel case\n/* global setTimeout, clearTimeout */\nimport { CompositeLayer, COORDINATE_SYSTEM, _deepEqual as deepEqual } from '@deck.gl/core';\nimport { BitmapLayer } from '@deck.gl/layers';\nimport { ImageSource, createImageSource } from '@loaders.gl/wms';\nimport { WGS84ToPseudoMercator } from \"./utils.js\";\nconst defaultProps = {\n  id: 'imagery-layer',\n  data: '',\n  serviceType: 'auto',\n  srs: 'auto',\n  layers: {\n    type: 'array',\n    compare: true,\n    value: []\n  },\n  onMetadataLoad: {\n    type: 'function',\n    value: () => {}\n  },\n  // eslint-disable-next-line\n  onMetadataLoadError: {\n    type: 'function',\n    value: console.error\n  },\n  onImageLoadStart: {\n    type: 'function',\n    value: () => {}\n  },\n  onImageLoad: {\n    type: 'function',\n    value: () => {}\n  },\n  onImageLoadError: {\n    type: 'function',\n    compare: false,\n    // eslint-disable-next-line\n    value: (requestId, error) => console.error(error, requestId)\n  }\n};\n/**\n * The layer is used in Hex Tile layer in order to properly discard invisible elements during animation\n */\nexport class WMSLayer extends CompositeLayer {\n  /** Returns true if all async resources are loaded */\n  get isLoaded() {\n    // Track the explicit loading done by this layer\n    return this.state?.loadCounter === 0 && super.isLoaded;\n  }\n  /** Lets deck.gl know that we want viewport change events */\n  shouldUpdateState() {\n    return true;\n  }\n  initializeState() {\n    // intentionally empty, initialization is done in updateState\n    this.state._nextRequestId = 0;\n    this.state.lastRequestId = -1;\n    this.state.loadCounter = 0;\n  }\n  updateState(_ref) {\n    let {\n      changeFlags,\n      props,\n      oldProps\n    } = _ref;\n    const {\n      viewport\n    } = this.context;\n    // Check if data source has changed\n    if (changeFlags.dataChanged || props.serviceType !== oldProps.serviceType) {\n      this.state.imageSource = this._createImageSource(props);\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._loadMetadata();\n      this.debounce(() => this.loadImage(viewport, 'image source changed'), 0);\n    } else if (!deepEqual(props.layers, oldProps.layers, 1)) {\n      this.debounce(() => this.loadImage(viewport, 'layers changed'), 0);\n    } else if (changeFlags.viewportChanged) {\n      this.debounce(() => this.loadImage(viewport, 'viewport changed'));\n    }\n  }\n  finalizeState() {\n    // TODO - we could cancel outstanding requests\n  }\n  renderLayers() {\n    // TODO - which bitmap layer is rendered should depend on the current viewport\n    // Currently Studio only uses one viewport\n    const {\n      bounds,\n      image,\n      lastRequestParameters\n    } = this.state;\n    return image && new BitmapLayer({\n      ...this.getSubLayerProps({\n        id: 'bitmap'\n      }),\n      _imageCoordinateSystem: lastRequestParameters.srs === 'EPSG:4326' ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN,\n      bounds,\n      image\n    });\n  }\n  async getFeatureInfoText(x, y) {\n    const {\n      lastRequestParameters\n    } = this.state;\n    if (lastRequestParameters) {\n      // @ts-expect-error Undocumented method\n      const featureInfo = await this.state.imageSource.getFeatureInfoText?.({\n        ...lastRequestParameters,\n        query_layers: lastRequestParameters.layers,\n        x,\n        y,\n        info_format: 'application/vnd.ogc.gml'\n      });\n      return featureInfo;\n    }\n    return '';\n  }\n  _createImageSource(props) {\n    if (props.data instanceof ImageSource) {\n      return props.data;\n    }\n    if (typeof props.data === 'string') {\n      return createImageSource({\n        url: props.data,\n        loadOptions: props.loadOptions,\n        type: props.serviceType\n      });\n    }\n    throw new Error('invalid image source in props.data');\n  }\n  /** Run a getMetadata on the image service */\n  async _loadMetadata() {\n    const {\n      imageSource\n    } = this.state;\n    try {\n      this.state.loadCounter++;\n      const metadata = await imageSource.getMetadata();\n      // If a request takes a long time, it may no longer be expected\n      if (this.state.imageSource === imageSource) {\n        this.getCurrentLayer()?.props.onMetadataLoad(metadata);\n      }\n    } catch (error) {\n      this.getCurrentLayer()?.props.onMetadataLoadError(error);\n    } finally {\n      this.state.loadCounter--;\n    }\n  }\n  /** Load an image */\n  async loadImage(viewport, reason) {\n    const {\n      layers,\n      serviceType\n    } = this.props;\n    // TODO - move to ImageSource?\n    if (serviceType === 'wms' && layers.length === 0) {\n      return;\n    }\n    const bounds = viewport.getBounds();\n    const {\n      width,\n      height\n    } = viewport;\n    const requestId = this.getRequestId();\n    let {\n      srs\n    } = this.props;\n    if (srs === 'auto') {\n      // BitmapLayer only supports LNGLAT or CARTESIAN (Web-Mercator)\n      srs = viewport.resolution ? 'EPSG:4326' : 'EPSG:3857';\n    }\n    const requestParams = {\n      width,\n      height,\n      boundingBox: [[bounds[0], bounds[1]], [bounds[2], bounds[3]]],\n      layers,\n      crs: srs\n    };\n    if (srs === 'EPSG:3857') {\n      const min = WGS84ToPseudoMercator([bounds[0], bounds[1]]);\n      const max = WGS84ToPseudoMercator([bounds[2], bounds[3]]);\n      requestParams.boundingBox = [min, max];\n    }\n    try {\n      this.state.loadCounter++;\n      this.props.onImageLoadStart(requestId);\n      const image = await this.state.imageSource.getImage(requestParams);\n      // If a request takes a long time, later requests may have already loaded.\n      if (this.state.lastRequestId < requestId) {\n        this.getCurrentLayer()?.props.onImageLoad(requestId);\n        // Not type safe...\n        this.setState({\n          image,\n          bounds,\n          lastRequestParameters: requestParams,\n          lastRequestId: requestId\n        });\n      }\n    } catch (error) {\n      this.raiseError(error, 'Load image');\n      this.getCurrentLayer()?.props.onImageLoadError(requestId, error);\n    } finally {\n      this.state.loadCounter--;\n    }\n  }\n  // HELPERS\n  /** Global counter for issuing unique request ids */\n  getRequestId() {\n    return this.state._nextRequestId++;\n  }\n  /** Runs an action in the future, cancels it if the new action is issued before it executes */\n  debounce(fn) {\n    let ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;\n    clearTimeout(this.state._timeoutId);\n    this.state._timeoutId = setTimeout(() => fn(), ms);\n  }\n}\nWMSLayer.layerName = 'WMSLayer';\nWMSLayer.defaultProps = defaultProps;\n//# sourceMappingURL=wms-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}