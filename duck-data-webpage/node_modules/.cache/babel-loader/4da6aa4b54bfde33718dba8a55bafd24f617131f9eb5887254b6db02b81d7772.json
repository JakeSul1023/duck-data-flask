{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Vector3 } from '@math.gl/core';\nimport { BoundingSphere, OrientedBoundingBox } from '@math.gl/culling';\nimport { Ellipsoid } from '@math.gl/geospatial';\nconst WGS84_RADIUS_X = 6378137.0;\nconst WGS84_RADIUS_Y = 6378137.0;\nconst WGS84_RADIUS_Z = 6356752.3142451793;\nconst scratchVector = new Vector3();\n/**\n * Calculate appropriate zoom value for a particular boundingVolume\n * @param boundingVolume - the instance of bounding volume\n * @param cartorgraphicCenter - cartographic center of the bounding volume\n * @returns {number} - zoom value\n */\nexport function getZoomFromBoundingVolume(boundingVolume, cartorgraphicCenter) {\n  if (boundingVolume instanceof OrientedBoundingBox) {\n    // OrientedBoundingBox\n    const {\n      halfAxes\n    } = boundingVolume;\n    const obbSize = getObbSize(halfAxes);\n    // Use WGS84_RADIUS_Z to allign with BoundingSphere algorithm\n    // Add the tile elevation value for correct zooming to elevated tiles\n    return Math.log2(WGS84_RADIUS_Z / (obbSize + cartorgraphicCenter[2]));\n  } else if (boundingVolume instanceof BoundingSphere) {\n    // BoundingSphere\n    const {\n      radius\n    } = boundingVolume;\n    // Add the tile elevation value for correct zooming to elevated tiles\n    return Math.log2(WGS84_RADIUS_Z / (radius + cartorgraphicCenter[2]));\n  } else if (boundingVolume.width && boundingVolume.height) {\n    // BoundingRectangle\n    const {\n      width,\n      height\n    } = boundingVolume;\n    const zoomX = Math.log2(WGS84_RADIUS_X / width);\n    const zoomY = Math.log2(WGS84_RADIUS_Y / height);\n    return (zoomX + zoomY) / 2;\n  }\n  return 1;\n}\n/**\n * Calculate initial zoom for the tileset from 3D `fullExtent` defined in\n * the tileset metadata\n * @param fullExtent - 3D extent of the tileset\n * @param fullExtent.xmin - minimal longitude in decimal degrees\n * @param fullExtent.xmax - maximal longitude in decimal degrees\n * @param fullExtent.ymin - minimal latitude in decimal degrees\n * @param fullExtent.ymax - maximal latitude in decimal degrees\n * @param fullExtent.zmin - minimal elevation in meters\n * @param fullExtent.zmax - maximal elevation in meters\n * @param cartorgraphicCenter - tileset center in cartographic coordinate system\n * @param cartesianCenter - tileset center in cartesian coordinate system\n * @returns - initial zoom for the tileset\n */\nexport function getZoomFromFullExtent(fullExtent, cartorgraphicCenter, cartesianCenter) {\n  Ellipsoid.WGS84.cartographicToCartesian([fullExtent.xmax, fullExtent.ymax, fullExtent.zmax], scratchVector);\n  const extentSize = Math.sqrt(Math.pow(scratchVector[0] - cartesianCenter[0], 2) + Math.pow(scratchVector[1] - cartesianCenter[1], 2) + Math.pow(scratchVector[2] - cartesianCenter[2], 2));\n  return Math.log2(WGS84_RADIUS_Z / (extentSize + cartorgraphicCenter[2]));\n}\n/**\n * Calculate initial zoom for the tileset from 2D `extent` defined in\n * the tileset metadata\n * @param extent - 2D extent of the tileset. It is array of 4 elements [xmin, ymin, xmax, ymax]\n * @param extent[0] - minimal longitude in decimal degrees\n * @param extent[1] - minimal latitude in decimal degrees\n * @param extent[2] - maximal longitude in decimal degrees\n * @param extent[3] - maximal latitude in decimal degrees\n * @param cartorgraphicCenter - tileset center in cartographic coordinate system\n * @param cartesianCenter - tileset center in cartesian coordinate system\n * @returns - initial zoom for the tileset\n */\nexport function getZoomFromExtent(extent, cartorgraphicCenter, cartesianCenter) {\n  const [xmin, ymin, xmax, ymax] = extent;\n  return getZoomFromFullExtent({\n    xmin,\n    xmax,\n    ymin,\n    ymax,\n    zmin: 0,\n    zmax: 0\n  }, cartorgraphicCenter, cartesianCenter);\n}\nfunction getObbSize(halfAxes) {\n  halfAxes.getColumn(0, scratchVector);\n  const axeY = halfAxes.getColumn(1);\n  const axeZ = halfAxes.getColumn(2);\n  const farthestVertex = scratchVector.add(axeY).add(axeZ);\n  const size = farthestVertex.len();\n  return size;\n}","map":{"version":3,"names":["Vector3","BoundingSphere","OrientedBoundingBox","Ellipsoid","WGS84_RADIUS_X","WGS84_RADIUS_Y","WGS84_RADIUS_Z","scratchVector","getZoomFromBoundingVolume","boundingVolume","cartorgraphicCenter","halfAxes","obbSize","getObbSize","Math","log2","radius","width","height","zoomX","zoomY","getZoomFromFullExtent","fullExtent","cartesianCenter","WGS84","cartographicToCartesian","xmax","ymax","zmax","extentSize","sqrt","pow","getZoomFromExtent","extent","xmin","ymin","zmin","getColumn","axeY","axeZ","farthestVertex","add","size","len"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/tiles/dist/tileset/helpers/zoom.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Vector3 } from '@math.gl/core';\nimport { BoundingSphere, OrientedBoundingBox } from '@math.gl/culling';\nimport { Ellipsoid } from '@math.gl/geospatial';\nconst WGS84_RADIUS_X = 6378137.0;\nconst WGS84_RADIUS_Y = 6378137.0;\nconst WGS84_RADIUS_Z = 6356752.3142451793;\nconst scratchVector = new Vector3();\n/**\n * Calculate appropriate zoom value for a particular boundingVolume\n * @param boundingVolume - the instance of bounding volume\n * @param cartorgraphicCenter - cartographic center of the bounding volume\n * @returns {number} - zoom value\n */\nexport function getZoomFromBoundingVolume(boundingVolume, cartorgraphicCenter) {\n    if (boundingVolume instanceof OrientedBoundingBox) {\n        // OrientedBoundingBox\n        const { halfAxes } = boundingVolume;\n        const obbSize = getObbSize(halfAxes);\n        // Use WGS84_RADIUS_Z to allign with BoundingSphere algorithm\n        // Add the tile elevation value for correct zooming to elevated tiles\n        return Math.log2(WGS84_RADIUS_Z / (obbSize + cartorgraphicCenter[2]));\n    }\n    else if (boundingVolume instanceof BoundingSphere) {\n        // BoundingSphere\n        const { radius } = boundingVolume;\n        // Add the tile elevation value for correct zooming to elevated tiles\n        return Math.log2(WGS84_RADIUS_Z / (radius + cartorgraphicCenter[2]));\n    }\n    else if (boundingVolume.width && boundingVolume.height) {\n        // BoundingRectangle\n        const { width, height } = boundingVolume;\n        const zoomX = Math.log2(WGS84_RADIUS_X / width);\n        const zoomY = Math.log2(WGS84_RADIUS_Y / height);\n        return (zoomX + zoomY) / 2;\n    }\n    return 1;\n}\n/**\n * Calculate initial zoom for the tileset from 3D `fullExtent` defined in\n * the tileset metadata\n * @param fullExtent - 3D extent of the tileset\n * @param fullExtent.xmin - minimal longitude in decimal degrees\n * @param fullExtent.xmax - maximal longitude in decimal degrees\n * @param fullExtent.ymin - minimal latitude in decimal degrees\n * @param fullExtent.ymax - maximal latitude in decimal degrees\n * @param fullExtent.zmin - minimal elevation in meters\n * @param fullExtent.zmax - maximal elevation in meters\n * @param cartorgraphicCenter - tileset center in cartographic coordinate system\n * @param cartesianCenter - tileset center in cartesian coordinate system\n * @returns - initial zoom for the tileset\n */\nexport function getZoomFromFullExtent(fullExtent, cartorgraphicCenter, cartesianCenter) {\n    Ellipsoid.WGS84.cartographicToCartesian([fullExtent.xmax, fullExtent.ymax, fullExtent.zmax], scratchVector);\n    const extentSize = Math.sqrt(Math.pow(scratchVector[0] - cartesianCenter[0], 2) +\n        Math.pow(scratchVector[1] - cartesianCenter[1], 2) +\n        Math.pow(scratchVector[2] - cartesianCenter[2], 2));\n    return Math.log2(WGS84_RADIUS_Z / (extentSize + cartorgraphicCenter[2]));\n}\n/**\n * Calculate initial zoom for the tileset from 2D `extent` defined in\n * the tileset metadata\n * @param extent - 2D extent of the tileset. It is array of 4 elements [xmin, ymin, xmax, ymax]\n * @param extent[0] - minimal longitude in decimal degrees\n * @param extent[1] - minimal latitude in decimal degrees\n * @param extent[2] - maximal longitude in decimal degrees\n * @param extent[3] - maximal latitude in decimal degrees\n * @param cartorgraphicCenter - tileset center in cartographic coordinate system\n * @param cartesianCenter - tileset center in cartesian coordinate system\n * @returns - initial zoom for the tileset\n */\nexport function getZoomFromExtent(extent, cartorgraphicCenter, cartesianCenter) {\n    const [xmin, ymin, xmax, ymax] = extent;\n    return getZoomFromFullExtent({ xmin, xmax, ymin, ymax, zmin: 0, zmax: 0 }, cartorgraphicCenter, cartesianCenter);\n}\nfunction getObbSize(halfAxes) {\n    halfAxes.getColumn(0, scratchVector);\n    const axeY = halfAxes.getColumn(1);\n    const axeZ = halfAxes.getColumn(2);\n    const farthestVertex = scratchVector.add(axeY).add(axeZ);\n    const size = farthestVertex.len();\n    return size;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}