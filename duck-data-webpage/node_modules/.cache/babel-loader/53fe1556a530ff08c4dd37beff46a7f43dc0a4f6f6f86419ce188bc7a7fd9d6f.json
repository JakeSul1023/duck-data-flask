{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport LayerManager from \"./layer-manager.js\";\nimport ViewManager from \"./view-manager.js\";\nimport MapView from \"../views/map-view.js\";\nimport EffectManager from \"./effect-manager.js\";\nimport DeckRenderer from \"./deck-renderer.js\";\nimport DeckPicker from \"./deck-picker.js\";\nimport { WidgetManager } from \"./widget-manager.js\";\nimport Tooltip from \"./tooltip.js\";\nimport log from \"../utils/log.js\";\nimport { deepEqual } from \"../utils/deep-equal.js\";\nimport typedArrayManager from \"../utils/typed-array-manager.js\";\nimport { VERSION } from \"./init.js\";\nimport { luma } from '@luma.gl/core';\nimport { webgl2Adapter } from '@luma.gl/webgl';\nimport { Timeline } from '@luma.gl/engine';\nimport { AnimationLoop } from '@luma.gl/engine';\nimport { GL } from '@luma.gl/constants';\nimport { Stats } from '@probe.gl/stats';\nimport { EventManager } from 'mjolnir.js';\nimport assert from \"../utils/assert.js\";\nimport { EVENT_HANDLERS, RECOGNIZERS } from \"./constants.js\";\n/* global document */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\nconst getCursor = _ref => {\n  let {\n    isDragging\n  } = _ref;\n  return isDragging ? 'grabbing' : 'grab';\n};\nconst defaultProps = {\n  id: '',\n  width: '100%',\n  height: '100%',\n  style: null,\n  viewState: null,\n  initialViewState: null,\n  pickingRadius: 0,\n  layerFilter: null,\n  parameters: {},\n  parent: null,\n  device: null,\n  deviceProps: {},\n  gl: null,\n  canvas: null,\n  layers: [],\n  effects: [],\n  views: null,\n  controller: null,\n  // Rely on external controller, e.g. react-map-gl\n  useDevicePixels: true,\n  touchAction: 'none',\n  eventRecognizerOptions: {},\n  _framebuffer: null,\n  _animate: false,\n  _pickable: true,\n  _typedArrayManagerProps: {},\n  _customRender: null,\n  widgets: [],\n  onDeviceInitialized: noop,\n  onWebGLInitialized: noop,\n  onResize: noop,\n  onViewStateChange: noop,\n  onInteractionStateChange: noop,\n  onBeforeRender: noop,\n  onAfterRender: noop,\n  onLoad: noop,\n  onError: error => log.error(error.message, error.cause)(),\n  onHover: null,\n  onClick: null,\n  onDragStart: null,\n  onDrag: null,\n  onDragEnd: null,\n  _onMetrics: null,\n  getCursor,\n  getTooltip: null,\n  debug: false,\n  drawPickingColors: false\n};\n/* eslint-disable max-statements */\nclass Deck {\n  constructor(props) {\n    this.width = 0;\n    this.height = 0;\n    // Allows attaching arbitrary data to the instance\n    this.userData = {};\n    this.device = null;\n    this.canvas = null;\n    this.viewManager = null;\n    this.layerManager = null;\n    this.effectManager = null;\n    this.deckRenderer = null;\n    this.deckPicker = null;\n    this.eventManager = null;\n    this.widgetManager = null;\n    this.tooltip = null;\n    this.animationLoop = null;\n    this.cursorState = {\n      isHovering: false,\n      isDragging: false\n    };\n    this.stats = new Stats({\n      id: 'deck.gl'\n    });\n    this.metrics = {\n      fps: 0,\n      setPropsTime: 0,\n      updateAttributesTime: 0,\n      framesRedrawn: 0,\n      pickTime: 0,\n      pickCount: 0,\n      gpuTime: 0,\n      gpuTimePerFrame: 0,\n      cpuTime: 0,\n      cpuTimePerFrame: 0,\n      bufferMemory: 0,\n      textureMemory: 0,\n      renderbufferMemory: 0,\n      gpuMemory: 0\n    };\n    this._metricsCounter = 0;\n    this._needsRedraw = 'Initial render';\n    this._pickRequest = {\n      mode: 'hover',\n      x: -1,\n      y: -1,\n      radius: 0,\n      event: null\n    };\n    /**\n     * Pick and store the object under the pointer on `pointerdown`.\n     * This object is reused for subsequent `onClick` and `onDrag*` callbacks.\n     */\n    this._lastPointerDownInfo = null;\n    // The `pointermove` event may fire multiple times in between two animation frames,\n    // it's a waste of time to run picking without rerender. Instead we save the last pick\n    // request and only do it once on the next animation frame.\n    /** Internal use only: event handler for pointerdown */\n    this._onPointerMove = event => {\n      const {\n        _pickRequest\n      } = this;\n      if (event.type === 'pointerleave') {\n        _pickRequest.x = -1;\n        _pickRequest.y = -1;\n        _pickRequest.radius = 0;\n      } else if (event.leftButton || event.rightButton) {\n        // Do not trigger onHover callbacks if mouse button is down.\n        return;\n      } else {\n        const pos = event.offsetCenter;\n        // Do not trigger callbacks when click/hover position is invalid. Doing so will cause a\n        // assertion error when attempting to unproject the position.\n        if (!pos) {\n          return;\n        }\n        _pickRequest.x = pos.x;\n        _pickRequest.y = pos.y;\n        _pickRequest.radius = this.props.pickingRadius;\n      }\n      if (this.layerManager) {\n        this.layerManager.context.mousePosition = {\n          x: _pickRequest.x,\n          y: _pickRequest.y\n        };\n      }\n      _pickRequest.event = event;\n    };\n    /** Internal use only: event handler for click & drag */\n    this._onEvent = event => {\n      const eventHandlerProp = EVENT_HANDLERS[event.type];\n      const pos = event.offsetCenter;\n      if (!eventHandlerProp || !pos || !this.layerManager) {\n        return;\n      }\n      // Reuse last picked object\n      const layers = this.layerManager.getLayers();\n      const info = this.deckPicker.getLastPickedObject({\n        x: pos.x,\n        y: pos.y,\n        layers,\n        viewports: this.getViewports(pos)\n      }, this._lastPointerDownInfo);\n      const {\n        layer\n      } = info;\n      const layerHandler = layer && (layer[eventHandlerProp] || layer.props[eventHandlerProp]);\n      const rootHandler = this.props[eventHandlerProp];\n      let handled = false;\n      if (layerHandler) {\n        handled = layerHandler.call(layer, info, event);\n      }\n      if (!handled) {\n        rootHandler?.(info, event);\n        this.widgetManager.onEvent(info, event);\n      }\n    };\n    /** Internal use only: evnet handler for pointerdown */\n    this._onPointerDown = event => {\n      // TODO(ibgreen) Picking not yet supported on WebGPU\n      if (this.device?.type === 'webgpu') {\n        return;\n      }\n      const pos = event.offsetCenter;\n      const pickedInfo = this._pick('pickObject', 'pickObject Time', {\n        x: pos.x,\n        y: pos.y,\n        radius: this.props.pickingRadius\n      });\n      this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;\n    };\n    // @ts-ignore views\n    this.props = {\n      ...defaultProps,\n      ...props\n    };\n    props = this.props;\n    if (props.viewState && props.initialViewState) {\n      log.warn('View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.')();\n    }\n    this.viewState = this.props.initialViewState;\n    // See if we already have a device\n    if (props.device) {\n      this.device = props.device;\n    }\n    let deviceOrPromise = this.device;\n    // Attach a new luma.gl device to a WebGL2 context if supplied\n    if (!deviceOrPromise && props.gl) {\n      if (props.gl instanceof WebGLRenderingContext) {\n        log.error('WebGL1 context not supported.')();\n      }\n      deviceOrPromise = webgl2Adapter.attach(props.gl);\n    }\n    // Create a new device\n    if (!deviceOrPromise) {\n      // Create the \"best\" device supported from the registered adapters\n      deviceOrPromise = luma.createDevice({\n        type: 'best-available',\n        // luma by default throws if a device is already attached\n        // asynchronous device creation could happen after finalize() is called\n        // TODO - createDevice should support AbortController?\n        _reuseDevices: true,\n        adapters: [webgl2Adapter],\n        ...props.deviceProps,\n        createCanvasContext: {\n          canvas: this._createCanvas(props),\n          useDevicePixels: this.props.useDevicePixels,\n          // TODO v9.2 - replace AnimationLoop's `autoResizeDrawingBuffer` with CanvasContext's `autoResize`\n          autoResize: false\n        }\n      });\n    }\n    this.animationLoop = this._createAnimationLoop(deviceOrPromise, props);\n    this.setProps(props);\n    // UNSAFE/experimental prop: only set at initialization to avoid performance hit\n    if (props._typedArrayManagerProps) {\n      typedArrayManager.setOptions(props._typedArrayManagerProps);\n    }\n    this.animationLoop.start();\n  }\n  /** Stop rendering and dispose all resources */\n  finalize() {\n    this.animationLoop?.stop();\n    this.animationLoop?.destroy();\n    this.animationLoop = null;\n    this._lastPointerDownInfo = null;\n    this.layerManager?.finalize();\n    this.layerManager = null;\n    this.viewManager?.finalize();\n    this.viewManager = null;\n    this.effectManager?.finalize();\n    this.effectManager = null;\n    this.deckRenderer?.finalize();\n    this.deckRenderer = null;\n    this.deckPicker?.finalize();\n    this.deckPicker = null;\n    this.eventManager?.destroy();\n    this.eventManager = null;\n    this.widgetManager?.finalize();\n    this.widgetManager = null;\n    if (!this.props.canvas && !this.props.device && !this.props.gl && this.canvas) {\n      // remove internally created canvas\n      this.canvas.parentElement?.removeChild(this.canvas);\n      this.canvas = null;\n    }\n  }\n  /** Partially update props */\n  setProps(props) {\n    this.stats.get('setProps Time').timeStart();\n    if ('onLayerHover' in props) {\n      log.removed('onLayerHover', 'onHover')();\n    }\n    if ('onLayerClick' in props) {\n      log.removed('onLayerClick', 'onClick')();\n    }\n    if (props.initialViewState &&\n    // depth = 3 when comparing viewStates: viewId.position.0\n    !deepEqual(this.props.initialViewState, props.initialViewState, 3)) {\n      // Overwrite internal view state\n      this.viewState = props.initialViewState;\n    }\n    // Merge with existing props\n    Object.assign(this.props, props);\n    // Update CSS size of canvas\n    this._setCanvasSize(this.props);\n    // We need to overwrite CSS style width and height with actual, numeric values\n    const resolvedProps = Object.create(this.props);\n    Object.assign(resolvedProps, {\n      views: this._getViews(),\n      width: this.width,\n      height: this.height,\n      viewState: this._getViewState()\n    });\n    // Update the animation loop\n    this.animationLoop?.setProps(resolvedProps);\n    // If initialized, update sub manager props\n    if (this.layerManager) {\n      this.viewManager.setProps(resolvedProps);\n      // Make sure that any new layer gets initialized with the current viewport\n      this.layerManager.activateViewport(this.getViewports()[0]);\n      this.layerManager.setProps(resolvedProps);\n      this.effectManager.setProps(resolvedProps);\n      this.deckRenderer.setProps(resolvedProps);\n      this.deckPicker.setProps(resolvedProps);\n      this.widgetManager.setProps(resolvedProps);\n    }\n    this.stats.get('setProps Time').timeEnd();\n  }\n  // Public API\n  /**\n   * Check if a redraw is needed\n   * @returns `false` or a string summarizing the redraw reason\n   */\n  needsRedraw() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      clearRedrawFlags: false\n    };\n    if (!this.layerManager) {\n      // Not initialized or already finalized\n      return false;\n    }\n    if (this.props._animate) {\n      return 'Deck._animate';\n    }\n    let redraw = this._needsRedraw;\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n    const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);\n    const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);\n    const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);\n    const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);\n    redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;\n    return redraw;\n  }\n  /**\n   * Redraw the GL context\n   * @param reason If not provided, only redraw if deemed necessary. Otherwise redraw regardless of internal states.\n   * @returns\n   */\n  redraw(reason) {\n    if (!this.layerManager) {\n      // Not yet initialized\n      return;\n    }\n    // Check if we need to redraw\n    let redrawReason = this.needsRedraw({\n      clearRedrawFlags: true\n    });\n    // User-supplied should take precedent, however the redraw flags get cleared regardless\n    redrawReason = reason || redrawReason;\n    if (!redrawReason) {\n      return;\n    }\n    this.stats.get('Redraw Count').incrementCount();\n    if (this.props._customRender) {\n      this.props._customRender(redrawReason);\n    } else {\n      this._drawLayers(redrawReason);\n    }\n  }\n  /** Flag indicating that the Deck instance has initialized its resources and it's safe to call public methods. */\n  get isInitialized() {\n    return this.viewManager !== null;\n  }\n  /** Get a list of views that are currently rendered */\n  getViews() {\n    assert(this.viewManager);\n    return this.viewManager.views;\n  }\n  /** Get a list of viewports that are currently rendered.\n   * @param rect If provided, only returns viewports within the given bounding box.\n   */\n  getViewports(rect) {\n    assert(this.viewManager);\n    return this.viewManager.getViewports(rect);\n  }\n  /** Get the current canvas element. */\n  getCanvas() {\n    return this.canvas;\n  }\n  /** Query the object rendered on top at a given point */\n  pickObject(opts) {\n    const infos = this._pick('pickObject', 'pickObject Time', opts).result;\n    return infos.length ? infos[0] : null;\n  }\n  /* Query all rendered objects at a given point */\n  pickMultipleObjects(opts) {\n    opts.depth = opts.depth || 10;\n    return this._pick('pickObject', 'pickMultipleObjects Time', opts).result;\n  }\n  /* Query all objects rendered on top within a bounding box */\n  pickObjects(opts) {\n    return this._pick('pickObjects', 'pickObjects Time', opts);\n  }\n  /** Experimental\n   * Add a global resource for sharing among layers\n   */\n  _addResources(resources) {\n    let forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    for (const id in resources) {\n      this.layerManager.resourceManager.add({\n        resourceId: id,\n        data: resources[id],\n        forceUpdate\n      });\n    }\n  }\n  /** Experimental\n   * Remove a global resource\n   */\n  _removeResources(resourceIds) {\n    for (const id of resourceIds) {\n      this.layerManager.resourceManager.remove(id);\n    }\n  }\n  /** Experimental\n   * Register a default effect. Effects will be sorted by order, those with a low order will be rendered first\n   */\n  _addDefaultEffect(effect) {\n    this.effectManager.addDefaultEffect(effect);\n  }\n  _addDefaultShaderModule(module) {\n    this.layerManager.addDefaultShaderModule(module);\n  }\n  _removeDefaultShaderModule(module) {\n    this.layerManager?.removeDefaultShaderModule(module);\n  }\n  _pick(method, statKey, opts) {\n    assert(this.deckPicker);\n    const {\n      stats\n    } = this;\n    stats.get('Pick Count').incrementCount();\n    stats.get(statKey).timeStart();\n    const infos = this.deckPicker[method]({\n      // layerManager, viewManager and effectManager are always defined if deckPicker is\n      layers: this.layerManager.getLayers(opts),\n      views: this.viewManager.getViews(),\n      viewports: this.getViewports(opts),\n      onViewportActive: this.layerManager.activateViewport,\n      effects: this.effectManager.getEffects(),\n      ...opts\n    });\n    stats.get(statKey).timeEnd();\n    return infos;\n  }\n  /** Resolve props.canvas to element */\n  _createCanvas(props) {\n    let canvas = props.canvas;\n    // TODO EventManager should accept element id\n    if (typeof canvas === 'string') {\n      canvas = document.getElementById(canvas);\n      assert(canvas);\n    }\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      canvas.id = props.id || 'deckgl-overlay';\n      const parent = props.parent || document.body;\n      parent.appendChild(canvas);\n    }\n    Object.assign(canvas.style, props.style);\n    return canvas;\n  }\n  /** Updates canvas width and/or height, if provided as props */\n  _setCanvasSize(props) {\n    if (!this.canvas) {\n      return;\n    }\n    const {\n      width,\n      height\n    } = props;\n    // Set size ONLY if props are being provided, otherwise let canvas be layouted freely\n    if (width || width === 0) {\n      const cssWidth = Number.isFinite(width) ? `${width}px` : width;\n      this.canvas.style.width = cssWidth;\n    }\n    if (height || height === 0) {\n      const cssHeight = Number.isFinite(height) ? `${height}px` : height;\n      // Note: position==='absolute' required for height 100% to work\n      this.canvas.style.position = props.style?.position || 'absolute';\n      this.canvas.style.height = cssHeight;\n    }\n  }\n  /** If canvas size has changed, reads out the new size and update */\n  _updateCanvasSize() {\n    const {\n      canvas\n    } = this;\n    if (!canvas) {\n      return;\n    }\n    // Fallback to width/height when clientWidth/clientHeight are undefined (OffscreenCanvas).\n    const newWidth = canvas.clientWidth ?? canvas.width;\n    const newHeight = canvas.clientHeight ?? canvas.height;\n    if (newWidth !== this.width || newHeight !== this.height) {\n      // @ts-expect-error private assign to read-only property\n      this.width = newWidth;\n      // @ts-expect-error private assign to read-only property\n      this.height = newHeight;\n      this.viewManager?.setProps({\n        width: newWidth,\n        height: newHeight\n      });\n      // Make sure that any new layer gets initialized with the current viewport\n      this.layerManager?.activateViewport(this.getViewports()[0]);\n      this.props.onResize({\n        width: newWidth,\n        height: newHeight\n      });\n    }\n  }\n  _createAnimationLoop(deviceOrPromise, props) {\n    const {\n      // width,\n      // height,\n      gl,\n      // debug,\n      onError,\n      // onBeforeRender,\n      // onAfterRender,\n      useDevicePixels\n    } = props;\n    return new AnimationLoop({\n      device: deviceOrPromise,\n      useDevicePixels,\n      // TODO v9\n      autoResizeDrawingBuffer: !gl,\n      // do not auto resize external context\n      autoResizeViewport: false,\n      // @ts-expect-error luma.gl needs to accept Promise<void> return value\n      onInitialize: context => this._setDevice(context.device),\n      onRender: this._onRenderFrame.bind(this),\n      // @ts-expect-error typing mismatch: AnimationLoop does not accept onError:null\n      onError\n      // onBeforeRender,\n      // onAfterRender,\n    });\n  }\n  // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState\n  // TODO: For backwards compatibility ensure numeric width and height is added to the viewState\n  _getViewState() {\n    return this.props.viewState || this.viewState;\n  }\n  // Get the view descriptor list\n  _getViews() {\n    const {\n      views\n    } = this.props;\n    const normalizedViews = Array.isArray(views) ? views :\n    // If null, default to a full screen map view port\n    views ? [views] : [new MapView({\n      id: 'default-view'\n    })];\n    if (normalizedViews.length && this.props.controller) {\n      // Backward compatibility: support controller prop\n      normalizedViews[0].props.controller = this.props.controller;\n    }\n    return normalizedViews;\n  }\n  _onContextLost() {\n    const {\n      onError\n    } = this.props;\n    if (this.animationLoop && onError) {\n      onError(new Error('WebGL context is lost'));\n    }\n  }\n  /** Actually run picking */\n  _pickAndCallback() {\n    if (this.device?.type === 'webgpu') {\n      return;\n    }\n    const {\n      _pickRequest\n    } = this;\n    if (_pickRequest.event) {\n      // Perform picking\n      const {\n        result,\n        emptyInfo\n      } = this._pick('pickObject', 'pickObject Time', _pickRequest);\n      this.cursorState.isHovering = result.length > 0;\n      // There are 4 possible scenarios:\n      // result is [outInfo, pickedInfo] (moved from one pickable layer to another)\n      // result is [outInfo] (moved outside of a pickable layer)\n      // result is [pickedInfo] (moved into or over a pickable layer)\n      // result is [] (nothing is or was picked)\n      //\n      // `layer.props.onHover` should be called on all affected layers (out/over)\n      // `deck.props.onHover` should be called with the picked info if any, or empty info otherwise\n      // `deck.props.getTooltip` should be called with the picked info if any, or empty info otherwise\n      // Execute callbacks\n      let pickedInfo = emptyInfo;\n      let handled = false;\n      for (const info of result) {\n        pickedInfo = info;\n        handled = info.layer?.onHover(info, _pickRequest.event) || handled;\n      }\n      if (!handled) {\n        this.props.onHover?.(pickedInfo, _pickRequest.event);\n        this.widgetManager.onHover(pickedInfo, _pickRequest.event);\n      }\n      // Clear pending pickRequest\n      _pickRequest.event = null;\n    }\n  }\n  _updateCursor() {\n    const container = this.props.parent || this.canvas;\n    if (container) {\n      container.style.cursor = this.props.getCursor(this.cursorState);\n    }\n  }\n  _setDevice(device) {\n    this.device = device;\n    if (!this.animationLoop) {\n      // finalize() has been called\n      return;\n    }\n    // if external context...\n    if (!this.canvas) {\n      this.canvas = this.device.canvasContext?.canvas;\n      // TODO v9\n      // ts-expect-error - Currently luma.gl v9 does not expose these options\n      // All WebGLDevice contexts are instrumented, but it seems the device\n      // should have a method to start state tracking even if not enabled?\n      // instrumentGLContext(this.device.gl, {enable: true, copyState: true});\n    }\n    if (this.device.type === 'webgl') {\n      this.device.setParametersWebGL({\n        blend: true,\n        blendFunc: [770, 771, 1, 771],\n        polygonOffsetFill: true,\n        depthTest: true,\n        depthFunc: 515\n      });\n    }\n    this.props.onDeviceInitialized(this.device);\n    if (this.device.type === 'webgl') {\n      // Legacy callback - warn?\n      // @ts-expect-error gl is not visible on Device base class\n      this.props.onWebGLInitialized(this.device.gl);\n    }\n    // timeline for transitions\n    const timeline = new Timeline();\n    timeline.play();\n    this.animationLoop.attachTimeline(timeline);\n    this.eventManager = new EventManager(this.props.parent || this.canvas, {\n      touchAction: this.props.touchAction,\n      recognizers: Object.keys(RECOGNIZERS).map(eventName => {\n        // Resolve recognizer settings\n        const [RecognizerConstructor, defaultOptions, recognizeWith, requestFailure] = RECOGNIZERS[eventName];\n        const optionsOverride = this.props.eventRecognizerOptions?.[eventName];\n        const options = {\n          ...defaultOptions,\n          ...optionsOverride,\n          event: eventName\n        };\n        return {\n          recognizer: new RecognizerConstructor(options),\n          recognizeWith,\n          requestFailure\n        };\n      }),\n      events: {\n        pointerdown: this._onPointerDown,\n        pointermove: this._onPointerMove,\n        pointerleave: this._onPointerMove\n      }\n    });\n    for (const eventType in EVENT_HANDLERS) {\n      this.eventManager.on(eventType, this._onEvent);\n    }\n    this.viewManager = new ViewManager({\n      timeline,\n      eventManager: this.eventManager,\n      onViewStateChange: this._onViewStateChange.bind(this),\n      onInteractionStateChange: this._onInteractionStateChange.bind(this),\n      views: this._getViews(),\n      viewState: this._getViewState(),\n      width: this.width,\n      height: this.height\n    });\n    // viewManager must be initialized before layerManager\n    // layerManager depends on viewport created by viewManager.\n    const viewport = this.viewManager.getViewports()[0];\n    // Note: avoid React setState due GL animation loop / setState timing issue\n    this.layerManager = new LayerManager(this.device, {\n      deck: this,\n      stats: this.stats,\n      viewport,\n      timeline\n    });\n    this.effectManager = new EffectManager({\n      deck: this,\n      device: this.device\n    });\n    this.deckRenderer = new DeckRenderer(this.device);\n    this.deckPicker = new DeckPicker(this.device);\n    this.widgetManager = new WidgetManager({\n      deck: this,\n      parentElement: this.canvas?.parentElement\n    });\n    this.widgetManager.addDefault(new Tooltip());\n    this.setProps(this.props);\n    this._updateCanvasSize();\n    this.props.onLoad();\n  }\n  /** Internal only: default render function (redraw all layers and views) */\n  _drawLayers(redrawReason, renderOptions) {\n    const {\n      device,\n      gl\n    } = this.layerManager.context;\n    this.props.onBeforeRender({\n      device,\n      gl\n    });\n    const opts = {\n      target: this.props._framebuffer,\n      layers: this.layerManager.getLayers(),\n      viewports: this.viewManager.getViewports(),\n      onViewportActive: this.layerManager.activateViewport,\n      views: this.viewManager.getViews(),\n      pass: 'screen',\n      effects: this.effectManager.getEffects(),\n      ...renderOptions\n    };\n    this.deckRenderer?.renderLayers(opts);\n    if (opts.pass === 'screen') {\n      // This method could be called when drawing to picking buffer, texture etc.\n      // Only when drawing to screen, update all widgets (UI components)\n      this.widgetManager.onRedraw({\n        viewports: opts.viewports,\n        layers: opts.layers\n      });\n    }\n    this.props.onAfterRender({\n      device,\n      gl\n    });\n  }\n  // Callbacks\n  _onRenderFrame() {\n    this._getFrameStats();\n    // Log perf stats every second\n    if (this._metricsCounter++ % 60 === 0) {\n      this._getMetrics();\n      this.stats.reset();\n      log.table(4, this.metrics)();\n      // Experimental: report metrics\n      if (this.props._onMetrics) {\n        this.props._onMetrics(this.metrics);\n      }\n    }\n    this._updateCanvasSize();\n    this._updateCursor();\n    // Update layers if needed (e.g. some async prop has loaded)\n    // Note: This can trigger a redraw\n    this.layerManager.updateLayers();\n    // Perform picking request if any\n    // TODO(ibgreen): Picking not yet supported on WebGPU\n    if (this.device?.type !== 'webgpu') {\n      this._pickAndCallback();\n    }\n    // Redraw if necessary\n    this.redraw();\n    // Update viewport transition if needed\n    // Note: this can trigger `onViewStateChange`, and affect layers\n    // We want to defer these changes to the next frame\n    if (this.viewManager) {\n      this.viewManager.updateViewStates();\n    }\n  }\n  // Callbacks\n  _onViewStateChange(params) {\n    // Let app know that view state is changing, and give it a chance to change it\n    const viewState = this.props.onViewStateChange(params) || params.viewState;\n    // If initialViewState was set on creation, auto track position\n    if (this.viewState) {\n      this.viewState = {\n        ...this.viewState,\n        [params.viewId]: viewState\n      };\n      if (!this.props.viewState) {\n        // Apply internal view state\n        if (this.viewManager) {\n          this.viewManager.setProps({\n            viewState: this.viewState\n          });\n        }\n      }\n    }\n  }\n  _onInteractionStateChange(interactionState) {\n    this.cursorState.isDragging = interactionState.isDragging || false;\n    this.props.onInteractionStateChange(interactionState);\n  }\n  _getFrameStats() {\n    const {\n      stats\n    } = this;\n    stats.get('frameRate').timeEnd();\n    stats.get('frameRate').timeStart();\n    // Get individual stats from luma.gl so reset works\n    const animationLoopStats = this.animationLoop.stats;\n    stats.get('GPU Time').addTime(animationLoopStats.get('GPU Time').lastTiming);\n    stats.get('CPU Time').addTime(animationLoopStats.get('CPU Time').lastTiming);\n  }\n  _getMetrics() {\n    const {\n      metrics,\n      stats\n    } = this;\n    metrics.fps = stats.get('frameRate').getHz();\n    metrics.setPropsTime = stats.get('setProps Time').time;\n    metrics.updateAttributesTime = stats.get('Update Attributes').time;\n    metrics.framesRedrawn = stats.get('Redraw Count').count;\n    metrics.pickTime = stats.get('pickObject Time').time + stats.get('pickMultipleObjects Time').time + stats.get('pickObjects Time').time;\n    metrics.pickCount = stats.get('Pick Count').count;\n    // Luma stats\n    metrics.gpuTime = stats.get('GPU Time').time;\n    metrics.cpuTime = stats.get('CPU Time').time;\n    metrics.gpuTimePerFrame = stats.get('GPU Time').getAverageTime();\n    metrics.cpuTimePerFrame = stats.get('CPU Time').getAverageTime();\n    const memoryStats = luma.stats.get('Memory Usage');\n    metrics.bufferMemory = memoryStats.get('Buffer Memory').count;\n    metrics.textureMemory = memoryStats.get('Texture Memory').count;\n    metrics.renderbufferMemory = memoryStats.get('Renderbuffer Memory').count;\n    metrics.gpuMemory = memoryStats.get('GPU Memory').count;\n  }\n}\nDeck.defaultProps = defaultProps;\n// This is used to defeat tree shaking of init.js\n// https://github.com/visgl/deck.gl/issues/3213\nDeck.VERSION = VERSION;\nexport default Deck;\n//# sourceMappingURL=deck.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}