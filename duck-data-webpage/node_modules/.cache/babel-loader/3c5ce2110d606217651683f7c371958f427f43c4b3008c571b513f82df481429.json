{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Vector3 } from '@math.gl/core';\nimport { BoundingSphere } from \"../bounding-volumes/bounding-sphere.js\";\n/* eslint-disable */\nconst fromPointsXMin = new Vector3();\nconst fromPointsYMin = new Vector3();\nconst fromPointsZMin = new Vector3();\nconst fromPointsXMax = new Vector3();\nconst fromPointsYMax = new Vector3();\nconst fromPointsZMax = new Vector3();\nconst fromPointsCurrentPos = new Vector3();\nconst fromPointsScratch = new Vector3();\nconst fromPointsRitterCenter = new Vector3();\nconst fromPointsMinBoxPt = new Vector3();\nconst fromPointsMaxBoxPt = new Vector3();\nconst fromPointsNaiveCenterScratch = new Vector3();\n// const volumeConstant = (4.0 / 3.0) * Math.PI;\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.\n *\n * The bounding sphere is computed by running two algorithms, a naive algorithm and\n * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.\n * Bounding sphere computation article http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding\n *\n * @param positions An array of points that the bounding sphere will enclose.\n * @param result Optional object onto which to store the result.\n * @returns The modified result parameter or a new `BoundingSphere` instance if not provided.\n */\nexport function makeBoundingSphereFromPoints(positions, result = new BoundingSphere()) {\n  if (!positions || positions.length === 0) {\n    return result.fromCenterRadius([0, 0, 0], 0);\n  }\n  const currentPos = fromPointsCurrentPos.copy(positions[0]);\n  const xMin = fromPointsXMin.copy(currentPos);\n  const yMin = fromPointsYMin.copy(currentPos);\n  const zMin = fromPointsZMin.copy(currentPos);\n  const xMax = fromPointsXMax.copy(currentPos);\n  const yMax = fromPointsYMax.copy(currentPos);\n  const zMax = fromPointsZMax.copy(currentPos);\n  for (const position of positions) {\n    currentPos.copy(position);\n    const x = currentPos.x;\n    const y = currentPos.y;\n    const z = currentPos.z;\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      xMin.copy(currentPos);\n    }\n    if (x > xMax.x) {\n      xMax.copy(currentPos);\n    }\n    if (y < yMin.y) {\n      yMin.copy(currentPos);\n    }\n    if (y > yMax.y) {\n      yMax.copy(currentPos);\n    }\n    if (z < zMin.z) {\n      zMin.copy(currentPos);\n    }\n    if (z > zMax.z) {\n      zMax.copy(currentPos);\n    }\n  }\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = fromPointsScratch.copy(xMax).subtract(xMin).magnitudeSquared();\n  const ySpan = fromPointsScratch.copy(yMax).subtract(yMin).magnitudeSquared();\n  const zSpan = fromPointsScratch.copy(zMax).subtract(zMin).magnitudeSquared();\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = fromPointsScratch.copy(diameter2).subtract(ritterCenter).magnitudeSquared();\n  let ritterRadius = Math.sqrt(radiusSquared);\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n  const naiveCenter = fromPointsNaiveCenterScratch.copy(minBoxPt).add(maxBoxPt).multiplyByScalar(0.5);\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (const position of positions) {\n    currentPos.copy(position);\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = fromPointsScratch.copy(currentPos).subtract(naiveCenter).magnitude();\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = fromPointsScratch.copy(currentPos).subtract(ritterCenter).magnitudeSquared();\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n    }\n  }\n  if (ritterRadius < naiveRadius) {\n    ritterCenter.to(result.center);\n    result.radius = ritterRadius;\n  } else {\n    naiveCenter.to(result.center);\n    result.radius = naiveRadius;\n  }\n  return result;\n}","map":{"version":3,"names":["Vector3","BoundingSphere","fromPointsXMin","fromPointsYMin","fromPointsZMin","fromPointsXMax","fromPointsYMax","fromPointsZMax","fromPointsCurrentPos","fromPointsScratch","fromPointsRitterCenter","fromPointsMinBoxPt","fromPointsMaxBoxPt","fromPointsNaiveCenterScratch","makeBoundingSphereFromPoints","positions","result","length","fromCenterRadius","currentPos","copy","xMin","yMin","zMin","xMax","yMax","zMax","position","x","y","z","xSpan","subtract","magnitudeSquared","ySpan","zSpan","diameter1","diameter2","maxSpan","ritterCenter","radiusSquared","ritterRadius","Math","sqrt","minBoxPt","maxBoxPt","naiveCenter","add","multiplyByScalar","naiveRadius","r","magnitude","oldCenterToPointSquared","oldCenterToPoint","oldToNew","to","center","radius"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\culling\\src\\lib\\algorithms\\bounding-sphere-from-points.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3} from '@math.gl/core';\nimport {BoundingSphere} from '../bounding-volumes/bounding-sphere';\n\n/* eslint-disable */\nconst fromPointsXMin = new Vector3();\nconst fromPointsYMin = new Vector3();\nconst fromPointsZMin = new Vector3();\nconst fromPointsXMax = new Vector3();\nconst fromPointsYMax = new Vector3();\nconst fromPointsZMax = new Vector3();\nconst fromPointsCurrentPos = new Vector3();\nconst fromPointsScratch = new Vector3();\nconst fromPointsRitterCenter = new Vector3();\nconst fromPointsMinBoxPt = new Vector3();\nconst fromPointsMaxBoxPt = new Vector3();\nconst fromPointsNaiveCenterScratch = new Vector3();\n// const volumeConstant = (4.0 / 3.0) * Math.PI;\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.\n *\n * The bounding sphere is computed by running two algorithms, a naive algorithm and\n * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.\n * Bounding sphere computation article http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding\n *\n * @param positions An array of points that the bounding sphere will enclose.\n * @param result Optional object onto which to store the result.\n * @returns The modified result parameter or a new `BoundingSphere` instance if not provided.\n */\nexport function makeBoundingSphereFromPoints(\n  positions: number[][],\n  result: BoundingSphere = new BoundingSphere()\n): BoundingSphere {\n  if (!positions || positions.length === 0) {\n    return result.fromCenterRadius([0, 0, 0], 0);\n  }\n\n  const currentPos = fromPointsCurrentPos.copy(positions[0]);\n\n  const xMin = fromPointsXMin.copy(currentPos);\n  const yMin = fromPointsYMin.copy(currentPos);\n  const zMin = fromPointsZMin.copy(currentPos);\n\n  const xMax = fromPointsXMax.copy(currentPos);\n  const yMax = fromPointsYMax.copy(currentPos);\n  const zMax = fromPointsZMax.copy(currentPos);\n\n  for (const position of positions) {\n    currentPos.copy(position);\n\n    const x = currentPos.x;\n    const y = currentPos.y;\n    const z = currentPos.z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      xMin.copy(currentPos);\n    }\n\n    if (x > xMax.x) {\n      xMax.copy(currentPos);\n    }\n\n    if (y < yMin.y) {\n      yMin.copy(currentPos);\n    }\n\n    if (y > yMax.y) {\n      yMax.copy(currentPos);\n    }\n\n    if (z < zMin.z) {\n      zMin.copy(currentPos);\n    }\n\n    if (z > zMax.z) {\n      zMax.copy(currentPos);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = fromPointsScratch.copy(xMax).subtract(xMin).magnitudeSquared();\n  const ySpan = fromPointsScratch.copy(yMax).subtract(yMin).magnitudeSquared();\n  const zSpan = fromPointsScratch.copy(zMax).subtract(zMin).magnitudeSquared();\n\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = fromPointsScratch.copy(diameter2).subtract(ritterCenter).magnitudeSquared();\n  let ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  const naiveCenter = fromPointsNaiveCenterScratch\n    .copy(minBoxPt)\n    .add(maxBoxPt)\n    .multiplyByScalar(0.5);\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (const position of positions) {\n    currentPos.copy(position);\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = fromPointsScratch.copy(currentPos).subtract(naiveCenter).magnitude();\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = fromPointsScratch\n      .copy(currentPos)\n      .subtract(ritterCenter)\n      .magnitudeSquared();\n\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    ritterCenter.to(result.center);\n    result.radius = ritterRadius;\n  } else {\n    naiveCenter.to(result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}