{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { LayerExtension, _mergeShaders as mergeShaders } from '@deck.gl/core';\nimport { vec3 } from '@math.gl/core';\nimport { dashShaders, offsetShaders } from \"./shaders.glsl.js\";\nconst defaultProps = {\n  getDashArray: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  getOffset: {\n    type: 'accessor',\n    value: 0\n  },\n  dashJustified: false,\n  dashGapPickable: false\n};\n/** Adds selected features to the `PathLayer` and composite layers that render the `PathLayer`. */\nclass PathStyleExtension extends LayerExtension {\n  constructor({\n    dash = false,\n    offset = false,\n    highPrecisionDash = false\n  } = {}) {\n    super({\n      dash: dash || highPrecisionDash,\n      offset,\n      highPrecisionDash\n    });\n  }\n  isEnabled(layer) {\n    return 'pathTesselator' in layer.state;\n  }\n  getShaders(extension) {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n    // Merge shader injection\n    let result = {};\n    if (extension.opts.dash) {\n      result = mergeShaders(result, dashShaders);\n    }\n    if (extension.opts.offset) {\n      result = mergeShaders(result, offsetShaders);\n    }\n    const {\n      inject\n    } = result;\n    const pathStyle = {\n      name: 'pathStyle',\n      inject,\n      uniformTypes: {\n        dashAlignMode: 'f32',\n        dashGapPickable: 'i32'\n      }\n    };\n    return {\n      modules: [pathStyle]\n    };\n  }\n  initializeState(context, extension) {\n    const attributeManager = this.getAttributeManager();\n    if (!attributeManager || !extension.isEnabled(this)) {\n      // This extension only works with the PathLayer\n      return;\n    }\n    if (extension.opts.dash) {\n      attributeManager.addInstanced({\n        instanceDashArrays: {\n          size: 2,\n          accessor: 'getDashArray'\n        },\n        instanceDashOffsets: extension.opts.highPrecisionDash ? {\n          size: 1,\n          accessor: 'getPath',\n          transform: extension.getDashOffsets.bind(this)\n        } : {\n          size: 1,\n          update: attribute => {\n            attribute.constant = true;\n            attribute.value = [0];\n          }\n        }\n      });\n    }\n    if (extension.opts.offset) {\n      attributeManager.addInstanced({\n        instanceOffsets: {\n          size: 1,\n          accessor: 'getOffset'\n        }\n      });\n    }\n  }\n  updateState(params, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n    if (extension.opts.dash) {\n      const pathStyleProps = {\n        dashAlignMode: this.props.dashJustified ? 1 : 0,\n        dashGapPickable: Boolean(this.props.dashGapPickable)\n      };\n      this.setShaderModuleProps({\n        pathStyle: pathStyleProps\n      });\n    }\n  }\n  getDashOffsets(path) {\n    const result = [0];\n    const positionSize = this.props.positionFormat === 'XY' ? 2 : 3;\n    const isNested = Array.isArray(path[0]);\n    const geometrySize = isNested ? path.length : path.length / positionSize;\n    let p;\n    let prevP;\n    for (let i = 0; i < geometrySize - 1; i++) {\n      p = isNested ? path[i] : path.slice(i * positionSize, i * positionSize + positionSize);\n      p = this.projectPosition(p);\n      if (i > 0) {\n        result[i] = result[i - 1] + vec3.dist(prevP, p);\n      }\n      prevP = p;\n    }\n    result[geometrySize - 1] = 0;\n    return result;\n  }\n}\nPathStyleExtension.defaultProps = defaultProps;\nPathStyleExtension.extensionName = 'PathStyleExtension';\nexport default PathStyleExtension;","map":{"version":3,"names":["LayerExtension","_mergeShaders","mergeShaders","vec3","dashShaders","offsetShaders","defaultProps","getDashArray","type","value","getOffset","dashJustified","dashGapPickable","PathStyleExtension","constructor","dash","offset","highPrecisionDash","isEnabled","layer","state","getShaders","extension","result","opts","inject","pathStyle","name","uniformTypes","dashAlignMode","modules","initializeState","context","attributeManager","getAttributeManager","addInstanced","instanceDashArrays","size","accessor","instanceDashOffsets","transform","getDashOffsets","bind","update","attribute","constant","instanceOffsets","updateState","params","pathStyleProps","props","Boolean","setShaderModuleProps","path","positionSize","positionFormat","isNested","Array","isArray","geometrySize","length","p","prevP","i","slice","projectPosition","dist","extensionName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\extensions\\src\\path-style\\path-style-extension.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {LayerExtension, _mergeShaders as mergeShaders} from '@deck.gl/core';\nimport {vec3} from '@math.gl/core';\nimport {dashShaders, offsetShaders} from './shaders.glsl';\n\nimport type {Layer, LayerContext, Accessor, UpdateParameters} from '@deck.gl/core';\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nconst defaultProps = {\n  getDashArray: {type: 'accessor', value: [0, 0]},\n  getOffset: {type: 'accessor', value: 0},\n  dashJustified: false,\n  dashGapPickable: false\n};\n\ntype PathStyleProps = {\n  dashAlignMode: number;\n  dashGapPickable: boolean;\n};\n\nexport type PathStyleExtensionProps<DataT = any> = {\n  /**\n   * Accessor for the dash array to draw each path with: `[dashSize, gapSize]` relative to the width of the path.\n   * Requires the `dash` option to be on.\n   */\n  getDashArray?: Accessor<DataT, [number, number]>;\n  /**\n   * Accessor for the offset to draw each path with, relative to the width of the path.\n   * Negative offset is to the left hand side, and positive offset is to the right hand side.\n   * @default 0\n   */\n  getOffset?: Accessor<DataT, number>;\n  /**\n   * If `true`, adjust gaps for the dashes to align at both ends.\n   * @default false\n   */\n  dashJustified?: boolean;\n  /**\n   * If `true`, gaps between solid strokes are pickable. If `false`, only the solid strokes are pickable.\n   * @default false\n   */\n  dashGapPickable?: boolean;\n};\n\nexport type PathStyleExtensionOptions = {\n  /**\n   * Add capability to render dashed lines.\n   * @default false\n   */\n  dash: boolean;\n  /**\n   * Add capability to offset lines.\n   * @default false\n   */\n  offset: boolean;\n  /**\n   * Improve dash rendering quality in certain circumstances. Note that this option introduces additional performance overhead.\n   * @default false\n   */\n  highPrecisionDash: boolean;\n};\n\n/** Adds selected features to the `PathLayer` and composite layers that render the `PathLayer`. */\nexport default class PathStyleExtension extends LayerExtension<PathStyleExtensionOptions> {\n  static defaultProps = defaultProps;\n  static extensionName = 'PathStyleExtension';\n\n  constructor({\n    dash = false,\n    offset = false,\n    highPrecisionDash = false\n  }: Partial<PathStyleExtensionOptions> = {}) {\n    super({dash: dash || highPrecisionDash, offset, highPrecisionDash});\n  }\n\n  isEnabled(layer: Layer<PathStyleExtensionProps>): boolean {\n    return 'pathTesselator' in layer.state;\n  }\n\n  getShaders(this: Layer<PathStyleExtensionProps>, extension: this): any {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n\n    // Merge shader injection\n    let result = {} as {inject: Record<string, string>};\n    if (extension.opts.dash) {\n      result = mergeShaders(result, dashShaders);\n    }\n    if (extension.opts.offset) {\n      result = mergeShaders(result, offsetShaders);\n    }\n\n    const {inject} = result;\n    const pathStyle: ShaderModule<PathStyleProps> = {\n      name: 'pathStyle',\n      inject,\n      uniformTypes: {\n        dashAlignMode: 'f32',\n        dashGapPickable: 'i32'\n      }\n    };\n    return {\n      modules: [pathStyle]\n    };\n  }\n\n  initializeState(this: Layer<PathStyleExtensionProps>, context: LayerContext, extension: this) {\n    const attributeManager = this.getAttributeManager();\n    if (!attributeManager || !extension.isEnabled(this)) {\n      // This extension only works with the PathLayer\n      return;\n    }\n\n    if (extension.opts.dash) {\n      attributeManager.addInstanced({\n        instanceDashArrays: {size: 2, accessor: 'getDashArray'},\n        instanceDashOffsets: extension.opts.highPrecisionDash\n          ? {\n              size: 1,\n              accessor: 'getPath',\n              transform: extension.getDashOffsets.bind(this)\n            }\n          : {\n              size: 1,\n              update: attribute => {\n                attribute.constant = true;\n                attribute.value = [0];\n              }\n            }\n      });\n    }\n    if (extension.opts.offset) {\n      attributeManager.addInstanced({\n        instanceOffsets: {size: 1, accessor: 'getOffset'}\n      });\n    }\n  }\n\n  updateState(\n    this: Layer<PathStyleExtensionProps>,\n    params: UpdateParameters<Layer<PathStyleExtensionProps>>,\n    extension: this\n  ) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    if (extension.opts.dash) {\n      const pathStyleProps: PathStyleProps = {\n        dashAlignMode: this.props.dashJustified ? 1 : 0,\n        dashGapPickable: Boolean(this.props.dashGapPickable)\n      };\n      this.setShaderModuleProps({pathStyle: pathStyleProps});\n    }\n  }\n\n  getDashOffsets(this: Layer<PathStyleExtensionProps>, path: number[] | number[][]): number[] {\n    const result = [0];\n    const positionSize = this.props.positionFormat === 'XY' ? 2 : 3;\n    const isNested = Array.isArray(path[0]);\n    const geometrySize = isNested ? path.length : path.length / positionSize;\n\n    let p;\n    let prevP;\n    for (let i = 0; i < geometrySize - 1; i++) {\n      p = isNested ? path[i] : path.slice(i * positionSize, i * positionSize + positionSize);\n      p = this.projectPosition(p);\n\n      if (i > 0) {\n        result[i] = result[i - 1] + vec3.dist(prevP, p);\n      }\n\n      prevP = p;\n    }\n    result[geometrySize - 1] = 0;\n    return result;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}