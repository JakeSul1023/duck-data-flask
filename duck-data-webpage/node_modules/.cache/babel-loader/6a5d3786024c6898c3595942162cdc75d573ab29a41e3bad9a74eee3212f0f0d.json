{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { _deepEqual as deepEqual, LayerExtension, log } from '@deck.gl/core';\nimport { dataFilter, dataFilter64 } from \"./shader-module.js\";\nimport * as aggregator from \"./aggregator.js\";\nconst defaultProps = {\n  getFilterValue: {\n    type: 'accessor',\n    value: 0\n  },\n  getFilterCategory: {\n    type: 'accessor',\n    value: 0\n  },\n  onFilteredItemsChange: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  filterEnabled: true,\n  filterRange: [-1, 1],\n  filterSoftRange: null,\n  filterCategories: [0],\n  filterTransformSize: true,\n  filterTransformColor: true\n};\nconst defaultOptions = {\n  categorySize: 0,\n  filterSize: 1,\n  fp64: false,\n  countItems: false\n};\nconst CATEGORY_TYPE_FROM_SIZE = {\n  1: 'uint',\n  2: 'uvec2',\n  3: 'uvec3',\n  4: 'uvec4'\n};\nconst DATA_TYPE_FROM_SIZE = {\n  1: 'float',\n  2: 'vec2',\n  3: 'vec3',\n  4: 'vec4'\n};\n/** Adds GPU-based data filtering functionalities to layers. It allows the layer to show/hide objects based on user-defined properties. */\nclass DataFilterExtension extends LayerExtension {\n  constructor(opts = {}) {\n    super({\n      ...defaultOptions,\n      ...opts\n    });\n  }\n  getShaders(extension) {\n    const {\n      categorySize,\n      filterSize,\n      fp64\n    } = extension.opts;\n    const defines = {};\n    if (categorySize) {\n      defines.DATACATEGORY_TYPE = CATEGORY_TYPE_FROM_SIZE[categorySize];\n      defines.DATACATEGORY_CHANNELS = categorySize;\n    }\n    if (filterSize) {\n      defines.DATAFILTER_TYPE = DATA_TYPE_FROM_SIZE[filterSize];\n      defines.DATAFILTER_DOUBLE = Boolean(fp64);\n    }\n    const module = fp64 ? dataFilter64 : dataFilter;\n    module.uniformTypes = module.uniformTypesFromOptions(extension.opts);\n    return {\n      modules: [module],\n      defines\n    };\n  }\n  initializeState(context, extension) {\n    const attributeManager = this.getAttributeManager();\n    const {\n      categorySize,\n      filterSize,\n      fp64\n    } = extension.opts;\n    if (attributeManager) {\n      if (filterSize) {\n        attributeManager.add({\n          filterValues: {\n            size: filterSize,\n            type: fp64 ? 'float64' : 'float32',\n            stepMode: 'dynamic',\n            accessor: 'getFilterValue'\n          }\n        });\n      }\n      if (categorySize) {\n        attributeManager.add({\n          filterCategoryValues: {\n            size: categorySize,\n            stepMode: 'dynamic',\n            accessor: 'getFilterCategory',\n            type: 'uint32',\n            transform: categorySize === 1 ? d => extension._getCategoryKey.call(this, d, 0) : d => d.map((x, i) => extension._getCategoryKey.call(this, x, i))\n          }\n        });\n      }\n    }\n    const {\n      device\n    } = this.context;\n    if (attributeManager && extension.opts.countItems) {\n      const useFloatTarget = aggregator.supportsFloatTarget(device);\n      // This attribute is needed for variable-width data, e.g. Path, SolidPolygon, Text\n      // The vertex shader checks if a vertex has the same \"index\" as the previous vertex\n      // so that we only write one count cross multiple vertices of the same object\n      attributeManager.add({\n        filterVertexIndices: {\n          size: useFloatTarget ? 1 : 2,\n          vertexOffset: 1,\n          type: 'unorm8',\n          accessor: (object, {\n            index\n          }) => {\n            const i = object && object.__source ? object.__source.index : index;\n            return useFloatTarget ? (i + 1) % 255 : [(i + 1) % 255, Math.floor(i / 255) % 255];\n          },\n          shaderAttributes: {\n            filterPrevIndices: {\n              vertexOffset: 0\n            },\n            filterIndices: {\n              vertexOffset: 1\n            }\n          }\n        }\n      });\n      const filterFBO = aggregator.getFramebuffer(device, useFloatTarget);\n      const filterModel = aggregator.getModel(device, attributeManager.getBufferLayouts({\n        isInstanced: false\n      }), extension.getShaders.call(this, extension), useFloatTarget);\n      this.setState({\n        filterFBO,\n        filterModel\n      });\n    }\n  }\n  updateState({\n    props,\n    oldProps,\n    changeFlags\n  }, extension) {\n    const attributeManager = this.getAttributeManager();\n    const {\n      categorySize\n    } = extension.opts;\n    if (this.state.filterModel) {\n      const filterNeedsUpdate =\n      // attributeManager must be defined for filterModel to be set\n      attributeManager.attributes.filterValues?.needsUpdate() || attributeManager.attributes.filterCategoryValues?.needsUpdate() || props.filterEnabled !== oldProps.filterEnabled || props.filterRange !== oldProps.filterRange || props.filterSoftRange !== oldProps.filterSoftRange || props.filterCategories !== oldProps.filterCategories;\n      if (filterNeedsUpdate) {\n        this.setState({\n          filterNeedsUpdate\n        });\n      }\n    }\n    if (attributeManager?.attributes.filterCategoryValues) {\n      // Update bitmask if accessor or selected categories has changed\n      const categoryBitMaskNeedsUpdate = attributeManager.attributes.filterCategoryValues.needsUpdate() || !deepEqual(props.filterCategories, oldProps.filterCategories, 2);\n      if (categoryBitMaskNeedsUpdate) {\n        this.setState({\n          categoryBitMask: null\n        });\n      }\n      // Need to recreate category map if categorySize has changed\n      const resetCategories = changeFlags.dataChanged;\n      if (resetCategories) {\n        this.setState({\n          categoryMap: Array(categorySize).fill(0).map(() => ({}))\n        });\n        attributeManager.attributes.filterCategoryValues.setNeedsUpdate('categoryMap');\n      }\n    }\n  }\n  draw(params, extension) {\n    const filterFBO = this.state.filterFBO;\n    const filterModel = this.state.filterModel;\n    const filterNeedsUpdate = this.state.filterNeedsUpdate;\n    if (!this.state.categoryBitMask) {\n      extension._updateCategoryBitMask.call(this, params, extension);\n    }\n    const {\n      onFilteredItemsChange,\n      extensions,\n      filterEnabled,\n      filterRange,\n      filterSoftRange,\n      filterTransformSize,\n      filterTransformColor,\n      filterCategories\n    } = this.props;\n    const dataFilterProps = {\n      extensions,\n      filterEnabled,\n      filterRange,\n      filterSoftRange,\n      filterTransformSize,\n      filterTransformColor,\n      filterCategories\n    };\n    if (this.state.categoryBitMask) {\n      dataFilterProps.categoryBitMask = this.state.categoryBitMask;\n    }\n    this.setShaderModuleProps({\n      dataFilter: dataFilterProps\n    });\n    /* eslint-disable-next-line camelcase */\n    if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {\n      const attributeManager = this.getAttributeManager();\n      const {\n        attributes: {\n          filterValues,\n          filterCategoryValues,\n          filterVertexIndices\n        }\n      } = attributeManager;\n      filterModel.setVertexCount(this.getNumInstances());\n      // @ts-expect-error filterValue and filterVertexIndices should always have buffer value\n      const attributes = {\n        ...filterValues?.getValue(),\n        ...filterCategoryValues?.getValue(),\n        ...filterVertexIndices?.getValue()\n      };\n      filterModel.setAttributes(attributes);\n      filterModel.shaderInputs.setProps({\n        dataFilter: dataFilterProps\n      });\n      const viewport = [0, 0, filterFBO.width, filterFBO.height];\n      const renderPass = filterModel.device.beginRenderPass({\n        id: 'data-filter-aggregation',\n        framebuffer: filterFBO,\n        parameters: {\n          viewport\n        },\n        clearColor: [0, 0, 0, 0]\n      });\n      filterModel.setParameters(aggregator.parameters);\n      filterModel.draw(renderPass);\n      renderPass.end();\n      const color = filterModel.device.readPixelsToArrayWebGL(filterFBO);\n      let count = 0;\n      for (let i = 0; i < color.length; i++) {\n        count += color[i];\n      }\n      onFilteredItemsChange({\n        id: this.id,\n        count\n      });\n      this.state.filterNeedsUpdate = false;\n    }\n  }\n  finalizeState() {\n    const filterFBO = this.state.filterFBO;\n    const filterModel = this.state.filterModel;\n    // filterFBO.color.delete();\n    filterFBO?.destroy();\n    filterModel?.destroy();\n  }\n  /**\n   * Updates the bitmask used on the GPU to perform the filter based on the\n   * `filterCategories` prop. The mapping between categories and bit in the bitmask\n   * is performed by `_getCategoryKey()`\n   */\n  _updateCategoryBitMask(params, extension) {\n    const {\n      categorySize\n    } = extension.opts;\n    if (!categorySize) return;\n    const {\n      filterCategories\n    } = this.props;\n    const categoryBitMask = new Uint32Array([0, 0, 0, 0]);\n    const categoryFilters = categorySize === 1 ? [filterCategories] : filterCategories;\n    const maxCategories = categorySize === 1 ? 128 : categorySize === 2 ? 64 : 32;\n    for (let c = 0; c < categoryFilters.length; c++) {\n      const categoryFilter = categoryFilters[c];\n      for (const category of categoryFilter) {\n        const key = extension._getCategoryKey.call(this, category, c);\n        if (key < maxCategories) {\n          const channel = c * (maxCategories / 32) + Math.floor(key / 32);\n          categoryBitMask[channel] += Math.pow(2, key % 32); // 1 << key fails for key > 30\n        } else {\n          log.warn(`Exceeded maximum number of categories (${maxCategories})`)();\n        }\n      }\n    }\n    this.state.categoryBitMask = categoryBitMask;\n  }\n  /**\n   * Returns an index of bit in the bitmask for a given category. If the category has\n   * not yet been assigned a bit, a new one is assigned.\n   */\n  _getCategoryKey(category, channel) {\n    const categoryMap = this.state.categoryMap[channel];\n    if (!(category in categoryMap)) {\n      categoryMap[category] = Object.keys(categoryMap).length;\n    }\n    return categoryMap[category];\n  }\n}\nDataFilterExtension.defaultProps = defaultProps;\nDataFilterExtension.extensionName = 'DataFilterExtension';\nexport default DataFilterExtension;","map":{"version":3,"names":["_deepEqual","deepEqual","LayerExtension","log","dataFilter","dataFilter64","aggregator","defaultProps","getFilterValue","type","value","getFilterCategory","onFilteredItemsChange","optional","filterEnabled","filterRange","filterSoftRange","filterCategories","filterTransformSize","filterTransformColor","defaultOptions","categorySize","filterSize","fp64","countItems","CATEGORY_TYPE_FROM_SIZE","DATA_TYPE_FROM_SIZE","DataFilterExtension","constructor","opts","getShaders","extension","defines","DATACATEGORY_TYPE","DATACATEGORY_CHANNELS","DATAFILTER_TYPE","DATAFILTER_DOUBLE","Boolean","module","uniformTypes","uniformTypesFromOptions","modules","initializeState","context","attributeManager","getAttributeManager","add","filterValues","size","stepMode","accessor","filterCategoryValues","transform","d","_getCategoryKey","call","map","x","i","device","useFloatTarget","supportsFloatTarget","filterVertexIndices","vertexOffset","object","index","__source","Math","floor","shaderAttributes","filterPrevIndices","filterIndices","filterFBO","getFramebuffer","filterModel","getModel","getBufferLayouts","isInstanced","setState","updateState","props","oldProps","changeFlags","state","filterNeedsUpdate","attributes","needsUpdate","categoryBitMaskNeedsUpdate","categoryBitMask","resetCategories","dataChanged","categoryMap","Array","fill","setNeedsUpdate","draw","params","_updateCategoryBitMask","extensions","dataFilterProps","setShaderModuleProps","setVertexCount","getNumInstances","getValue","setAttributes","shaderInputs","setProps","viewport","width","height","renderPass","beginRenderPass","id","framebuffer","parameters","clearColor","setParameters","end","color","readPixelsToArrayWebGL","count","length","finalizeState","destroy","Uint32Array","categoryFilters","maxCategories","c","categoryFilter","category","key","channel","pow","warn","Object","keys","extensionName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\extensions\\src\\data-filter\\data-filter-extension.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Buffer, Framebuffer} from '@luma.gl/core';\nimport type {Model} from '@luma.gl/engine';\nimport type {Layer, LayerContext, Accessor, UpdateParameters} from '@deck.gl/core';\nimport {_deepEqual as deepEqual, LayerExtension, log} from '@deck.gl/core';\nimport {\n  CategoryBitMask,\n  DataFilterModuleProps,\n  Defines,\n  dataFilter,\n  dataFilter64\n} from './shader-module';\nimport * as aggregator from './aggregator';\nimport {NumberArray4} from '@math.gl/core';\n\nconst defaultProps = {\n  getFilterValue: {type: 'accessor', value: 0},\n  getFilterCategory: {type: 'accessor', value: 0},\n  onFilteredItemsChange: {type: 'function', value: null, optional: true},\n\n  filterEnabled: true,\n  filterRange: [-1, 1],\n  filterSoftRange: null,\n  filterCategories: [0],\n  filterTransformSize: true,\n  filterTransformColor: true\n};\n\ntype FilterCategory = number | string;\n\nexport type DataFilterExtensionProps<DataT = any> = {\n  /**\n   * Accessor to retrieve the value for each object that it will be filtered by.\n   * Returns either a number (if `filterSize: 1`) or an array of numbers.\n   */\n  getFilterValue?: Accessor<DataT, number | number[]>;\n  /**\n   * Accessor to retrieve the category (`number | string`) for each object that it will be filtered by.\n   * Returns either a single category (if `filterSize: 1`) or an array of categories.\n   */\n  getFilterCategory?: Accessor<DataT, FilterCategory | FilterCategory[]>;\n  /**\n   * Enable/disable the data filter. If the data filter is disabled, all objects are rendered.\n   * @default true\n   */\n  filterEnabled?: boolean;\n  /**\n   * The [min, max] bounds which defines whether an object should be rendered.\n   * If an object's filtered value is within the bounds, the object will be rendered; otherwise it will be hidden.\n   * @default [-1, 1]\n   */\n  filterRange?: [number, number] | [number, number][];\n  /**\n   * If specified, objects will be faded in/out instead of abruptly shown/hidden.\n   * When the filtered value is outside of the bounds defined by `filterSoftRange` but still within the bounds defined by `filterRange`, the object will be rendered as \"faded.\"\n   * @default null\n   */\n  filterSoftRange?: [number, number] | [number, number][] | null;\n  /**\n   * When an object is \"faded\", manipulate its size so that it appears smaller or thinner. Only works if `filterSoftRange` is specified.\n   * @default true\n   */\n  filterTransformSize?: boolean;\n  /**\n   * When an object is \"faded\", manipulate its opacity so that it appears more translucent. Only works if `filterSoftRange` is specified.\n   * @default true\n   */\n  filterTransformColor?: boolean;\n  /**\n   * The categories which define whether an object should be rendered.\n   * @default []\n   */\n  filterCategories?: FilterCategory[] | FilterCategory[][];\n  /**\n   * Only called if the `countItems` option is enabled.\n   */\n  onFilteredItemsChange?: (evt: {\n    /** The id of the source layer. */\n    id: string;\n    /** The number of data objects that pass the filter. */\n    count: number;\n  }) => void;\n};\n\nexport type DataFilterExtensionOptions = {\n  /**\n   * The size of the category filter (number of columns to filter by). The category filter can show/hide data based on 1-4 properties of each object. Set to `0` to disable category filtering.\n   * @default 0\n   */\n  categorySize?: 0 | 1 | 2 | 3 | 4;\n  /**\n   * The size of the filter (number of columns to filter by). The data filter can show/hide data based on 1-4 numeric properties of each object. Set to `0` to disable numeric filtering.\n   * @default 1\n   */\n  filterSize?: 0 | 1 | 2 | 3 | 4;\n  /**\n   * Use 64-bit precision instead of 32-bit.\n   * @default false\n   */\n  fp64?: boolean;\n  /**\n   * If `true`, reports the number of filtered objects with the `onFilteredItemsChange` callback.\n   * @default `false`.\n   */\n  countItems?: boolean;\n};\n\nconst defaultOptions: Required<DataFilterExtensionOptions> = {\n  categorySize: 0,\n  filterSize: 1,\n  fp64: false,\n  countItems: false\n};\n\nconst CATEGORY_TYPE_FROM_SIZE = {\n  1: 'uint' as const,\n  2: 'uvec2' as const,\n  3: 'uvec3' as const,\n  4: 'uvec4' as const\n};\nconst DATA_TYPE_FROM_SIZE = {\n  1: 'float' as const,\n  2: 'vec2' as const,\n  3: 'vec3' as const,\n  4: 'vec4' as const\n};\n\n/** Adds GPU-based data filtering functionalities to layers. It allows the layer to show/hide objects based on user-defined properties. */\nexport default class DataFilterExtension extends LayerExtension<\n  Required<DataFilterExtensionOptions>\n> {\n  static defaultProps = defaultProps;\n  static extensionName = 'DataFilterExtension';\n\n  constructor(opts: DataFilterExtensionOptions = {}) {\n    super({...defaultOptions, ...opts});\n  }\n\n  getShaders(this: Layer<DataFilterExtensionProps>, extension: this): any {\n    const {categorySize, filterSize, fp64} = extension.opts;\n    const defines: Defines = {};\n    if (categorySize) {\n      defines.DATACATEGORY_TYPE = CATEGORY_TYPE_FROM_SIZE[categorySize];\n      defines.DATACATEGORY_CHANNELS = categorySize;\n    }\n    if (filterSize) {\n      defines.DATAFILTER_TYPE = DATA_TYPE_FROM_SIZE[filterSize];\n      defines.DATAFILTER_DOUBLE = Boolean(fp64);\n    }\n\n    const module = fp64 ? dataFilter64 : dataFilter;\n    module.uniformTypes = module.uniformTypesFromOptions(extension.opts);\n\n    return {modules: [module], defines};\n  }\n\n  initializeState(this: Layer<DataFilterExtensionProps>, context: LayerContext, extension: this) {\n    const attributeManager = this.getAttributeManager();\n    const {categorySize, filterSize, fp64} = extension.opts;\n\n    if (attributeManager) {\n      if (filterSize) {\n        attributeManager.add({\n          filterValues: {\n            size: filterSize,\n            type: fp64 ? 'float64' : 'float32',\n            stepMode: 'dynamic',\n            accessor: 'getFilterValue'\n          }\n        });\n      }\n\n      if (categorySize) {\n        attributeManager.add({\n          filterCategoryValues: {\n            size: categorySize,\n            stepMode: 'dynamic',\n            accessor: 'getFilterCategory',\n            type: 'uint32',\n            transform:\n              categorySize === 1\n                ? d => extension._getCategoryKey.call(this, d, 0)\n                : d => d.map((x, i) => extension._getCategoryKey.call(this, x, i))\n          }\n        });\n      }\n    }\n\n    const {device} = this.context;\n    if (attributeManager && extension.opts.countItems) {\n      const useFloatTarget = aggregator.supportsFloatTarget(device);\n      // This attribute is needed for variable-width data, e.g. Path, SolidPolygon, Text\n      // The vertex shader checks if a vertex has the same \"index\" as the previous vertex\n      // so that we only write one count cross multiple vertices of the same object\n      attributeManager.add({\n        filterVertexIndices: {\n          size: useFloatTarget ? 1 : 2,\n          vertexOffset: 1,\n          type: 'unorm8',\n          accessor: (object, {index}) => {\n            const i = object && object.__source ? object.__source.index : index;\n            return useFloatTarget ? (i + 1) % 255 : [(i + 1) % 255, Math.floor(i / 255) % 255];\n          },\n          shaderAttributes: {\n            filterPrevIndices: {\n              vertexOffset: 0\n            },\n            filterIndices: {\n              vertexOffset: 1\n            }\n          }\n        }\n      });\n\n      const filterFBO = aggregator.getFramebuffer(device, useFloatTarget);\n      const filterModel = aggregator.getModel(\n        device,\n        attributeManager.getBufferLayouts({isInstanced: false}),\n        extension.getShaders.call(this, extension),\n        useFloatTarget\n      );\n      this.setState({filterFBO, filterModel});\n    }\n  }\n\n  updateState(\n    this: Layer<DataFilterExtensionProps>,\n    {props, oldProps, changeFlags}: UpdateParameters<Layer<DataFilterExtensionProps>>,\n    extension: this\n  ) {\n    const attributeManager = this.getAttributeManager();\n    const {categorySize} = extension.opts;\n    if (this.state.filterModel) {\n      const filterNeedsUpdate =\n        // attributeManager must be defined for filterModel to be set\n        attributeManager!.attributes.filterValues?.needsUpdate() ||\n        attributeManager!.attributes.filterCategoryValues?.needsUpdate() ||\n        props.filterEnabled !== oldProps.filterEnabled ||\n        props.filterRange !== oldProps.filterRange ||\n        props.filterSoftRange !== oldProps.filterSoftRange ||\n        props.filterCategories !== oldProps.filterCategories;\n      if (filterNeedsUpdate) {\n        this.setState({filterNeedsUpdate});\n      }\n    }\n    if (attributeManager?.attributes.filterCategoryValues) {\n      // Update bitmask if accessor or selected categories has changed\n      const categoryBitMaskNeedsUpdate =\n        attributeManager.attributes.filterCategoryValues.needsUpdate() ||\n        !deepEqual(props.filterCategories, oldProps.filterCategories, 2);\n      if (categoryBitMaskNeedsUpdate) {\n        this.setState({categoryBitMask: null});\n      }\n\n      // Need to recreate category map if categorySize has changed\n      const resetCategories = changeFlags.dataChanged;\n      if (resetCategories) {\n        this.setState({\n          categoryMap: Array(categorySize)\n            .fill(0)\n            .map(() => ({}))\n        });\n        attributeManager.attributes.filterCategoryValues.setNeedsUpdate('categoryMap');\n      }\n    }\n  }\n\n  draw(this: Layer<DataFilterExtensionProps>, params: any, extension: this) {\n    const filterFBO = this.state.filterFBO as Framebuffer;\n    const filterModel = this.state.filterModel as Model;\n    const filterNeedsUpdate = this.state.filterNeedsUpdate as boolean;\n\n    if (!this.state.categoryBitMask) {\n      extension._updateCategoryBitMask.call(this, params, extension);\n    }\n\n    const {\n      onFilteredItemsChange,\n      extensions,\n      filterEnabled,\n      filterRange,\n      filterSoftRange,\n      filterTransformSize,\n      filterTransformColor,\n      filterCategories\n    } = this.props;\n    const dataFilterProps: DataFilterModuleProps = {\n      extensions,\n      filterEnabled,\n      filterRange,\n      filterSoftRange,\n      filterTransformSize,\n      filterTransformColor,\n      filterCategories\n    };\n    if (this.state.categoryBitMask) {\n      dataFilterProps.categoryBitMask = this.state.categoryBitMask as CategoryBitMask;\n    }\n    this.setShaderModuleProps({dataFilter: dataFilterProps});\n\n    /* eslint-disable-next-line camelcase */\n    if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {\n      const attributeManager = this.getAttributeManager()!;\n      const {\n        attributes: {filterValues, filterCategoryValues, filterVertexIndices}\n      } = attributeManager;\n      filterModel.setVertexCount(this.getNumInstances());\n\n      // @ts-expect-error filterValue and filterVertexIndices should always have buffer value\n      const attributes: Record<string, Buffer> = {\n        ...filterValues?.getValue(),\n        ...filterCategoryValues?.getValue(),\n        ...filterVertexIndices?.getValue()\n      };\n      filterModel.setAttributes(attributes);\n      filterModel.shaderInputs.setProps({\n        dataFilter: dataFilterProps\n      });\n\n      const viewport = [0, 0, filterFBO.width, filterFBO.height] as NumberArray4;\n\n      const renderPass = filterModel.device.beginRenderPass({\n        id: 'data-filter-aggregation',\n        framebuffer: filterFBO,\n        parameters: {viewport},\n        clearColor: [0, 0, 0, 0]\n      });\n      filterModel.setParameters(aggregator.parameters);\n      filterModel.draw(renderPass);\n      renderPass.end();\n\n      const color = filterModel.device.readPixelsToArrayWebGL(filterFBO);\n      let count = 0;\n      for (let i = 0; i < color.length; i++) {\n        count += color[i];\n      }\n      onFilteredItemsChange({id: this.id, count});\n\n      this.state.filterNeedsUpdate = false;\n    }\n  }\n\n  finalizeState(this: Layer<DataFilterExtensionProps>) {\n    const filterFBO = this.state.filterFBO as Framebuffer;\n    const filterModel = this.state.filterModel as Model;\n\n    // filterFBO.color.delete();\n    filterFBO?.destroy();\n    filterModel?.destroy();\n  }\n\n  /**\n   * Updates the bitmask used on the GPU to perform the filter based on the\n   * `filterCategories` prop. The mapping between categories and bit in the bitmask\n   * is performed by `_getCategoryKey()`\n   */\n  _updateCategoryBitMask(\n    this: Layer<DataFilterExtensionProps>,\n    params: any,\n    extension: this\n  ): void {\n    const {categorySize} = extension.opts;\n    if (!categorySize) return;\n    const {filterCategories} = this.props;\n    const categoryBitMask: CategoryBitMask = new Uint32Array([0, 0, 0, 0]);\n    const categoryFilters = (\n      categorySize === 1 ? [filterCategories] : filterCategories\n    ) as FilterCategory[][];\n    const maxCategories = categorySize === 1 ? 128 : categorySize === 2 ? 64 : 32;\n    for (let c = 0; c < categoryFilters.length; c++) {\n      const categoryFilter = categoryFilters[c];\n      for (const category of categoryFilter) {\n        const key = extension._getCategoryKey.call(this, category, c);\n        if (key < maxCategories) {\n          const channel = c * (maxCategories / 32) + Math.floor(key / 32);\n          categoryBitMask[channel] += Math.pow(2, key % 32); // 1 << key fails for key > 30\n        } else {\n          log.warn(`Exceeded maximum number of categories (${maxCategories})`)();\n        }\n      }\n    }\n    this.state.categoryBitMask = categoryBitMask;\n  }\n\n  /**\n   * Returns an index of bit in the bitmask for a given category. If the category has\n   * not yet been assigned a bit, a new one is assigned.\n   */\n  _getCategoryKey(\n    this: Layer<DataFilterExtensionProps>,\n    category: FilterCategory,\n    channel: number\n  ) {\n    const categoryMap = (this.state.categoryMap as Record<FilterCategory, number>[])[channel];\n    if (!(category in categoryMap)) {\n      categoryMap[category] = Object.keys(categoryMap).length;\n    }\n    return categoryMap[category];\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}