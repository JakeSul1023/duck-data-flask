{"ast":null,"code":"/**\n * loaders.gl, MIT license\n *\n * Shared code for 3DTiles extensions:\n * * EXT_feature_metadata\n * * EXT_mesh_features\n * * EXT_structural_metadata\n */\nimport { getComponentTypeFromArray } from \"../../gltf-utils/gltf-utils.js\";\nimport { getImageData } from '@loaders.gl/images';\nfunction emod(n) {\n  return (n % 1 + 1) % 1;\n}\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16,\n  BOOLEAN: 1,\n  STRING: 1,\n  ENUM: 1\n};\nconst ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  INT8: Int8Array,\n  UINT8: Uint8Array,\n  INT16: Int16Array,\n  UINT16: Uint16Array,\n  INT32: Int32Array,\n  UINT32: Uint32Array,\n  INT64: BigInt64Array,\n  UINT64: BigUint64Array,\n  FLOAT32: Float32Array,\n  FLOAT64: Float64Array\n};\nconst ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {\n  INT8: 1,\n  UINT8: 1,\n  INT16: 2,\n  UINT16: 2,\n  INT32: 4,\n  UINT32: 4,\n  INT64: 8,\n  UINT64: 8,\n  FLOAT32: 4,\n  FLOAT64: 8\n};\nexport function getArrayElementByteSize(attributeType, componentType) {\n  return ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[componentType] * ATTRIBUTE_TYPE_TO_COMPONENTS[attributeType];\n}\n/**\n * Gets offset array from `arrayOffsets` or `stringOffsets`.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param bufferViewIndex - Buffer view index\n * @param offsetType - The type of values in `arrayOffsets` or `stringOffsets`.\n * @param numberOfElements - The number of elements in each property array.\n * @returns Array of values offsets. The number of offsets in the array is equal to `numberOfElements` plus one.\n */\nexport function getOffsetsForProperty(scenegraph, bufferViewIndex, offsetType, numberOfElements) {\n  if (offsetType !== 'UINT8' && offsetType !== 'UINT16' && offsetType !== 'UINT32' && offsetType !== 'UINT64') {\n    return null;\n  }\n  const arrayOffsetsBytes = scenegraph.getTypedArrayForBufferView(bufferViewIndex);\n  const arrayOffsets = convertRawBufferToMetadataArray(arrayOffsetsBytes, 'SCALAR',\n  // offsets consist of ONE component\n  offsetType, numberOfElements + 1 // The number of offsets is equal to the property table `count` plus one.\n  );\n  // We don't support BigInt offsets at the moment. It requires additional logic and potential issues in Safari\n  if (arrayOffsets instanceof BigInt64Array || arrayOffsets instanceof BigUint64Array) {\n    return null;\n  }\n  return arrayOffsets;\n}\n/**\n * Converts raw bytes that are in the buffer to an array of the type defined by the schema.\n * @param data - Raw bytes in the buffer.\n * @param attributeType - SCALAR, VECN, MATN.\n * @param componentType - Type of the component in elements, e.g. 'UINT8' or 'FLOAT32'.\n * @param elementCount - Number of elements in the array. Default value is 1.\n * @returns Data array\n */\nexport function convertRawBufferToMetadataArray(data, attributeType, componentType) {\n  let elementCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  const numberOfComponents = ATTRIBUTE_TYPE_TO_COMPONENTS[attributeType];\n  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[componentType];\n  const size = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[componentType];\n  const length = elementCount * numberOfComponents;\n  const byteLength = length * size;\n  let buffer = data.buffer;\n  let offset = data.byteOffset;\n  if (offset % size !== 0) {\n    const bufferArray = new Uint8Array(buffer);\n    buffer = bufferArray.slice(offset, offset + byteLength).buffer;\n    offset = 0;\n  }\n  return new ArrayType(buffer, offset, length);\n}\n/**\n * Processes data encoded in the texture associated with the primitive.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param textureInfo - Reference to the texture where extension data are stored.\n * @param primitive - Primitive object in the mesh.\n * @returns Array of data taken. Null if data can't be taken from the texture.\n */\nexport function getPrimitiveTextureData(scenegraph, textureInfo, primitive) {\n  /*\n    texture.index is an index for the \"textures\" array.\n    The texture object referenced by this index looks like this:\n    {\n    \"sampler\": 0,\n    \"source\": 0\n    }\n    \"sampler\" is an index for the \"samplers\" array\n    \"source\" is an index for the \"images\" array that contains data stored in rgba channels of the image.\n       texture.texCoord is a number-suffix (like 1) for an attribute like \"TEXCOORD_1\" in meshes.primitives\n    The value of \"TEXCOORD_1\" is an accessor that is used to get coordinates.\n    These coordinates are being used to get data from the image.\n    \n    Default for texture.texCoord is 0\n    @see https://github.com/CesiumGS/glTF/blob/3d-tiles-next/specification/2.0/schema/textureInfo.schema.json\n  */\n  const texCoordAccessorKey = `TEXCOORD_${textureInfo.texCoord || 0}`;\n  const texCoordAccessorIndex = primitive.attributes[texCoordAccessorKey];\n  const textureCoordinates = scenegraph.getTypedArrayForAccessor(texCoordAccessorIndex);\n  const json = scenegraph.gltf.json;\n  const textureIndex = textureInfo.index;\n  const imageIndex = json.textures?.[textureIndex]?.source;\n  if (typeof imageIndex !== 'undefined') {\n    const mimeType = json.images?.[imageIndex]?.mimeType;\n    const parsedImage = scenegraph.gltf.images?.[imageIndex];\n    // Checking for width is to prevent handling Un-processed images (e.g. [analyze] stage, where loadImages option is set to false)\n    if (parsedImage && typeof parsedImage.width !== 'undefined') {\n      const textureData = [];\n      for (let index = 0; index < textureCoordinates.length; index += 2) {\n        const value = getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index, textureInfo.channels);\n        textureData.push(value);\n      }\n      return textureData;\n    }\n  }\n  return [];\n}\n/**\n * Puts property data to attributes.\n * It creates corresponding buffer, bufferView and accessor\n * so the data can be accessed like regular data stored in buffers.\n * @param scenegraph - Scenegraph object.\n * @param attributeName - Name of the attribute.\n * @param propertyData - Property data to store.\n * @param featureTable - Array where unique data from the property data are being stored.\n * @param primitive - Primitive object.\n */\nexport function primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTable, primitive) {\n  // No reason to create an empty buffer if there is no property data to store.\n  if (!propertyData?.length) {\n    return;\n  }\n  /*\n    featureTable will contain unique values, e.g.\n    propertyData = [24, 35, 28, 24]\n    featureTable = [24, 35, 28]\n    featureIndices will contain indices that refer featureTextureTable, e.g.\n    featureIndices = [0, 1, 2, 0]\n  */\n  const featureIndices = [];\n  for (const texelData of propertyData) {\n    let index = featureTable.findIndex(item => item === texelData);\n    if (index === -1) {\n      index = featureTable.push(texelData) - 1;\n    }\n    featureIndices.push(index);\n  }\n  const typedArray = new Uint32Array(featureIndices);\n  const bufferIndex = scenegraph.gltf.buffers.push({\n    arrayBuffer: typedArray.buffer,\n    byteOffset: typedArray.byteOffset,\n    byteLength: typedArray.byteLength\n  }) - 1;\n  const bufferViewIndex = scenegraph.addBufferView(typedArray, bufferIndex, 0);\n  const accessorIndex = scenegraph.addAccessor(bufferViewIndex, {\n    size: 1,\n    componentType: getComponentTypeFromArray(typedArray),\n    count: typedArray.length\n  });\n  primitive.attributes[attributeName] = accessorIndex;\n}\n/**\n * Gets the value from the texture by coordinates provided.\n * @param parsedImage - Image where the data are stored.\n * @param mimeType - MIME type.\n * @param textureCoordinates - uv coordinates to access data in the image.\n * @param index - Index of uv coordinates in the array textureCoordinates.\n * @param channels - Image channels where data are stored.\n *  Channels of an RGBA texture are numbered 0..3 respectively.\n *  For Ext_mesh_features and EXT_strucural_metadata the channels default is [0]\n *  @see https://github.com/CesiumGS/glTF/blob/3d-tiles-next/extensions/2.0/Vendor/EXT_mesh_features/schema/featureIdTexture.schema.json\n *  @see https://github.com/CesiumGS/glTF/blob/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata/schema/propertyTexture.property.schema.json\n * @returns Value taken from the image.\n */\nfunction getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index) {\n  let channels = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0];\n  const CHANNELS_MAP = {\n    r: {\n      offset: 0,\n      shift: 0\n    },\n    g: {\n      offset: 1,\n      shift: 8\n    },\n    b: {\n      offset: 2,\n      shift: 16\n    },\n    a: {\n      offset: 3,\n      shift: 24\n    }\n  };\n  const u = textureCoordinates[index];\n  const v = textureCoordinates[index + 1];\n  let components = 1;\n  if (mimeType && (mimeType.indexOf('image/jpeg') !== -1 || mimeType.indexOf('image/png') !== -1)) components = 4;\n  const offset = coordinatesToOffset(u, v, parsedImage, components);\n  let value = 0;\n  for (const c of channels) {\n    /*\n    According to the EXT_feature_metadata extension specification:\n      Channels are labeled by rgba and are swizzled with a string of 1-4 characters.\n    According to the EXT_mesh_features extension specification:\n      The channels array contains non-negative integer values corresponding to channels of the source texture that the feature ID consists of.\n      Channels of an RGBA texture are numbered 0â€“3 respectively.\n    Function getImageValueByCoordinates is used to process both extensions.\n    So, there should be possible to get the element of CHANNELS_MAP by either index (0, 1, 2, 3) or key (r, g, b, a).\n    */\n    const map = typeof c === 'number' ? Object.values(CHANNELS_MAP)[c] : CHANNELS_MAP[c];\n    const imageOffset = offset + map.offset;\n    const imageData = getImageData(parsedImage);\n    if (imageData.data.length <= imageOffset) {\n      throw new Error(`${imageData.data.length} <= ${imageOffset}`);\n    }\n    const imageValue = imageData.data[imageOffset];\n    value |= imageValue << map.shift;\n  }\n  return value;\n}\n/**\n * Retrieves the offset in the image where the data are stored.\n * @param u - u-coordinate.\n * @param v - v-coordinate.\n * @param parsedImage - Image where the data are stored.\n * @param componentsCount - Number of components the data consists of.\n * @returns Offset in the image where the data are stored.\n */\nfunction coordinatesToOffset(u, v, parsedImage) {\n  let componentsCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  const w = parsedImage.width;\n  const iX = emod(u) * (w - 1);\n  const indX = Math.round(iX);\n  const h = parsedImage.height;\n  const iY = emod(v) * (h - 1);\n  const indY = Math.round(iY);\n  const components = parsedImage.components ? parsedImage.components : componentsCount;\n  // components is a number of channels in the image\n  const offset = (indY * w + indX) * components;\n  return offset;\n}\n/**\n * Parses variable-length array data.\n * In this case every value of the property in the table will be an array\n * of arbitrary length.\n * @param valuesData - Values in a flat typed array.\n * @param numberOfElements - Number of rows in the property table.\n * @param arrayOffsets - Offsets of nested arrays in the flat values array.\n * @param valuesDataBytesLength - Data byte length.\n * @param valueSize - Value size in bytes.\n * @returns Array of typed arrays.\n */\nexport function parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytesLength, valueSize) {\n  const attributeValueArray = [];\n  for (let index = 0; index < numberOfElements; index++) {\n    const arrayOffset = arrayOffsets[index];\n    const arrayByteSize = arrayOffsets[index + 1] - arrayOffsets[index];\n    if (arrayByteSize + arrayOffset > valuesDataBytesLength) {\n      break;\n    }\n    const typedArrayOffset = arrayOffset / valueSize;\n    const elementCount = arrayByteSize / valueSize;\n    attributeValueArray.push(valuesData.slice(typedArrayOffset, typedArrayOffset + elementCount));\n  }\n  return attributeValueArray;\n}\n/**\n * Parses fixed-length array data.\n * In this case every value of the property in the table will be an array\n * of constant length equal to `arrayCount`.\n * @param valuesData - Values in a flat typed array.\n * @param numberOfElements - Number of rows in the property table.\n * @param arrayCount - Nested arrays length.\n * @returns Array of typed arrays.\n */\nexport function parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount) {\n  const attributeValueArray = [];\n  for (let index = 0; index < numberOfElements; index++) {\n    const elementOffset = index * arrayCount;\n    attributeValueArray.push(valuesData.slice(elementOffset, elementOffset + arrayCount));\n  }\n  return attributeValueArray;\n}\n/**\n * Decodes properties of string type from binary source.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param valuesDataBytes - Data taken from values property of the property table property.\n * @param arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @param stringOffsets - Index of the buffer view containing offsets for strings. It should be available for string type.\n * @returns String property values\n */\nexport function getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets) {\n  if (arrayOffsets) {\n    // TODO: implement it as soon as we have the corresponding tileset\n    throw new Error('Not implemented - arrayOffsets for strings is specified');\n  }\n  if (stringOffsets) {\n    const stringsArray = [];\n    const textDecoder = new TextDecoder('utf8');\n    let stringOffset = 0;\n    for (let index = 0; index < numberOfElements; index++) {\n      const stringByteSize = stringOffsets[index + 1] - stringOffsets[index];\n      if (stringByteSize + stringOffset <= valuesDataBytes.length) {\n        const stringData = valuesDataBytes.subarray(stringOffset, stringByteSize + stringOffset);\n        const stringAttribute = textDecoder.decode(stringData);\n        stringsArray.push(stringAttribute);\n        stringOffset += stringByteSize;\n      }\n    }\n    return stringsArray;\n  }\n  return [];\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}