{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\nimport { Vector3 } from '@math.gl/core';\nimport { INTERSECTION } from \"../../constants.js\";\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\n/**\n * An axis aligned bounding box - aligned with coordinate axes\n * @see BoundingVolume\n * @see BoundingRectangle\n * @see OrientedBoundingBox\n */\nexport class AxisAlignedBoundingBox {\n  /**\n   * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n   * @param minimum=[0, 0, 0] The minimum point along the x, y, and z axes.\n   * @param maximum=[0, 0, 0] The maximum point along the x, y, and z axes.\n   * @param center The center of the box; automatically computed if not supplied.\n   */\n  constructor(minimum = [0, 0, 0], maximum = [0, 0, 0], center) {\n    // If center was not defined, compute it.\n    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);\n    this.center = new Vector3(center);\n    this.halfDiagonal = new Vector3(maximum).subtract(this.center);\n    /**\n     * The minimum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.minimum = new Vector3(minimum);\n    /**\n     * The maximum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.maximum = new Vector3(maximum);\n  }\n  /**\n   * Duplicates a AxisAlignedBoundingBox instance.\n   *\n   * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.\n   */\n  clone() {\n    return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n  }\n  /**\n   * Compares the provided AxisAlignedBoundingBox componentwise and returns\n   * <code>true</code> if they are equal, <code>false</code> otherwise.\n   *\n   * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.\n   * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n   */\n  equals(right) {\n    return this === right || Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);\n  }\n  /**\n   * Applies a 4x4 affine transformation matrix to a bounding sphere.\n   * @param transform The transformation matrix to apply to the bounding sphere.\n   * @returns itself, i.e. the modified BoundingVolume.\n   */\n  transform(transform) {\n    this.center.transformAsPoint(transform);\n    // TODO - this.halfDiagonal.transformAsVector(transform);\n    this.halfDiagonal.transform(transform);\n    this.minimum.transform(transform);\n    this.maximum.transform(transform);\n    return this;\n  }\n  /**\n   * Determines which side of a plane a box is located.\n   */\n  intersectPlane(plane) {\n    const {\n      halfDiagonal\n    } = this;\n    const normal = scratchNormal.from(plane.normal);\n    const e = halfDiagonal.x * Math.abs(normal.x) + halfDiagonal.y * Math.abs(normal.y) + halfDiagonal.z * Math.abs(normal.z);\n    const s = this.center.dot(normal) + plane.distance; // signed distance from center\n    if (s - e > 0) {\n      return INTERSECTION.INSIDE;\n    }\n    if (s + e < 0) {\n      // Not in front because normals point inward\n      return INTERSECTION.OUTSIDE;\n    }\n    return INTERSECTION.INTERSECTING;\n  }\n  /** Computes the estimated distance from the closest point on a bounding box to a point. */\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n  /** Computes the estimated distance squared from the closest point on a bounding box to a point. */\n  distanceSquaredTo(point) {\n    const offset = scratchVector.from(point).subtract(this.center);\n    const {\n      halfDiagonal\n    } = this;\n    let distanceSquared = 0.0;\n    let d;\n    d = Math.abs(offset.x) - halfDiagonal.x;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n    d = Math.abs(offset.y) - halfDiagonal.y;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n    d = Math.abs(offset.z) - halfDiagonal.z;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n    return distanceSquared;\n  }\n}","map":{"version":3,"names":["Vector3","INTERSECTION","scratchVector","scratchNormal","AxisAlignedBoundingBox","constructor","minimum","maximum","center","copy","add","scale","halfDiagonal","subtract","clone","equals","right","Boolean","transform","transformAsPoint","intersectPlane","plane","normal","from","e","x","Math","abs","y","z","s","dot","distance","INSIDE","OUTSIDE","INTERSECTING","distanceTo","point","sqrt","distanceSquaredTo","offset","distanceSquared","d"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\culling\\src\\lib\\bounding-volumes\\axis-aligned-bounding-box.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\nimport {BoundingVolume} from './bounding-volume';\nimport {Vector3} from '@math.gl/core';\nimport {Plane} from '../plane';\nimport {INTERSECTION} from '../../constants';\n\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\n\n/**\n * An axis aligned bounding box - aligned with coordinate axes\n * @see BoundingVolume\n * @see BoundingRectangle\n * @see OrientedBoundingBox\n */\nexport class AxisAlignedBoundingBox implements BoundingVolume {\n  /** The center point of the bounding box. */\n  readonly center: Vector3;\n  /** The positive half diagonal of the bounding box. */\n  readonly halfDiagonal: Vector3;\n  /** The minimum point defining the bounding box. [0, 0, 0] for empty box */\n  readonly minimum: Vector3;\n  /** The maximum point defining the bounding box. [0, 0, 0] for empty box */\n  readonly maximum: Vector3;\n\n  /**\n   * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n   * @param minimum=[0, 0, 0] The minimum point along the x, y, and z axes.\n   * @param maximum=[0, 0, 0] The maximum point along the x, y, and z axes.\n   * @param center The center of the box; automatically computed if not supplied.\n   */\n  constructor(\n    minimum: readonly number[] = [0, 0, 0],\n    maximum: readonly number[] = [0, 0, 0],\n    center?: readonly number[]\n  ) {\n    // If center was not defined, compute it.\n    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);\n    this.center = new Vector3(center);\n    this.halfDiagonal = new Vector3(maximum).subtract(this.center);\n\n    /**\n     * The minimum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.minimum = new Vector3(minimum);\n\n    /**\n     * The maximum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.maximum = new Vector3(maximum);\n  }\n\n  /**\n   * Duplicates a AxisAlignedBoundingBox instance.\n   *\n   * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.\n   */\n  clone(): AxisAlignedBoundingBox {\n    return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n  }\n\n  /**\n   * Compares the provided AxisAlignedBoundingBox componentwise and returns\n   * <code>true</code> if they are equal, <code>false</code> otherwise.\n   *\n   * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.\n   * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n   */\n  equals(right: AxisAlignedBoundingBox): boolean {\n    return (\n      this === right ||\n      (Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum))\n    );\n  }\n\n  /**\n   * Applies a 4x4 affine transformation matrix to a bounding sphere.\n   * @param transform The transformation matrix to apply to the bounding sphere.\n   * @returns itself, i.e. the modified BoundingVolume.\n   */\n  transform(transform: readonly number[]): this {\n    this.center.transformAsPoint(transform);\n    // TODO - this.halfDiagonal.transformAsVector(transform);\n    this.halfDiagonal.transform(transform);\n    this.minimum.transform(transform);\n    this.maximum.transform(transform);\n    return this;\n  }\n\n  /**\n   * Determines which side of a plane a box is located.\n   */\n  intersectPlane(plane: Plane): number {\n    const {halfDiagonal} = this;\n    const normal = scratchNormal.from(plane.normal);\n    const e =\n      halfDiagonal.x * Math.abs(normal.x) +\n      halfDiagonal.y * Math.abs(normal.y) +\n      halfDiagonal.z * Math.abs(normal.z);\n    const s = this.center.dot(normal) + plane.distance; // signed distance from center\n\n    if (s - e > 0) {\n      return INTERSECTION.INSIDE;\n    }\n\n    if (s + e < 0) {\n      // Not in front because normals point inward\n      return INTERSECTION.OUTSIDE;\n    }\n\n    return INTERSECTION.INTERSECTING;\n  }\n\n  /** Computes the estimated distance from the closest point on a bounding box to a point. */\n  distanceTo(point: readonly number[]): number {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  /** Computes the estimated distance squared from the closest point on a bounding box to a point. */\n  distanceSquaredTo(point: readonly number[]): number {\n    const offset = scratchVector.from(point).subtract(this.center);\n    const {halfDiagonal} = this;\n\n    let distanceSquared = 0.0;\n    let d;\n\n    d = Math.abs(offset.x) - halfDiagonal.x;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.y) - halfDiagonal.y;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.z) - halfDiagonal.z;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}