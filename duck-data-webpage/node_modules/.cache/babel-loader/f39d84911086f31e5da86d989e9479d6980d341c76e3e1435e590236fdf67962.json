{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getShaderModuleDependencies } from \"../shader-module/shader-module-dependencies.js\";\nimport { getPlatformShaderDefines } from \"./platform-defines.js\";\nimport { injectShader, DECLARATION_INJECT_MARKER } from \"./shader-injections.js\";\nimport { transpileGLSLShader } from \"../shader-transpiler/transpile-glsl-shader.js\";\nimport { checkShaderModuleDeprecations } from \"../shader-module/shader-module.js\";\nimport { normalizeShaderHooks, getShaderHooks } from \"./shader-hooks.js\";\nimport { assert } from \"../utils/assert.js\";\nimport { getShaderInfo } from \"../glsl-utils/get-shader-info.js\";\nconst INJECT_SHADER_DECLARATIONS = `\\n\\n${DECLARATION_INJECT_MARKER}\\n`;\n/**\n * Precision prologue to inject before functions are injected in shader\n * TODO - extract any existing prologue in the fragment source and move it up...\n */\nconst FRAGMENT_SHADER_PROLOGUE = /* glsl */`\\\nprecision highp float;\n`;\n/**\n * Inject a list of shader modules into a single shader source for WGSL\n */\nexport function assembleWGSLShader(options) {\n  const modules = getShaderModuleDependencies(options.modules || []);\n  return {\n    source: assembleShaderWGSL(options.platformInfo, {\n      ...options,\n      source: options.source,\n      stage: 'vertex',\n      modules\n    }),\n    getUniforms: assembleGetUniforms(modules)\n  };\n}\n/**\n * Injects dependent shader module sources into pair of main vertex/fragment shader sources for GLSL\n */\nexport function assembleGLSLShaderPair(options) {\n  const {\n    vs,\n    fs\n  } = options;\n  const modules = getShaderModuleDependencies(options.modules || []);\n  return {\n    vs: assembleShaderGLSL(options.platformInfo, {\n      ...options,\n      source: vs,\n      stage: 'vertex',\n      modules\n    }),\n    fs: assembleShaderGLSL(options.platformInfo, {\n      ...options,\n      // @ts-expect-error\n      source: fs,\n      stage: 'fragment',\n      modules\n    }),\n    getUniforms: assembleGetUniforms(modules)\n  };\n}\n/**\n * Pulls together complete source code for either a vertex or a fragment shader\n * adding prologues, requested module chunks, and any final injections.\n * @param gl\n * @param options\n * @returns\n */\nexport function assembleShaderWGSL(platformInfo, options) {\n  const {\n    // id,\n    source,\n    stage,\n    modules,\n    // defines = {},\n    hookFunctions = [],\n    inject = {},\n    log\n  } = options;\n  assert(typeof source === 'string', 'shader source must be a string');\n  // const isVertex = type === 'vs';\n  // const sourceLines = source.split('\\n');\n  const coreSource = source;\n  // Combine Module and Application Defines\n  // const allDefines = {};\n  // modules.forEach(module => {\n  //   Object.assign(allDefines, module.getDefines());\n  // });\n  // Object.assign(allDefines, defines);\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = '';\n  //   prologue\n  //     ? `\\\n  // ${getShaderNameDefine({id, source, type})}\n  // ${getShaderType(type)}\n  // ${getPlatformShaderDefines(platformInfo)}\n  // ${getApplicationDefines(allDefines)}\n  // ${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n  // `\n  // `;\n  const hookFunctionMap = normalizeShaderHooks(hookFunctions);\n  // Add source of dependent modules in resolved order\n  const hookInjections = {};\n  const declInjections = {};\n  const mainInjections = {};\n  for (const key in inject) {\n    const injection = typeof inject[key] === 'string' ? {\n      injection: inject[key],\n      order: 0\n    } : inject[key];\n    const match = /^(v|f)s:(#)?([\\w-]+)$/.exec(key);\n    if (match) {\n      const hash = match[2];\n      const name = match[3];\n      if (hash) {\n        if (name === 'decl') {\n          declInjections[key] = [injection];\n        } else {\n          mainInjections[key] = [injection];\n        }\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection];\n    }\n  }\n  // TODO - hack until shadertool modules support WebGPU\n  const modulesToInject = modules;\n  for (const module of modulesToInject) {\n    if (log) {\n      checkShaderModuleDeprecations(module, coreSource, log);\n    }\n    const moduleSource = getShaderModuleSource(module, 'wgsl');\n    // Add the module source, and a #define that declares it presence\n    assembledSource += moduleSource;\n    const injections = module.injections?.[stage] || {};\n    for (const key in injections) {\n      const match = /^(v|f)s:#([\\w-]+)$/.exec(key);\n      if (match) {\n        const name = match[2];\n        const injectionType = name === 'decl' ? declInjections : mainInjections;\n        injectionType[key] = injectionType[key] || [];\n        injectionType[key].push(injections[key]);\n      } else {\n        hookInjections[key] = hookInjections[key] || [];\n        hookInjections[key].push(injections[key]);\n      }\n    }\n  }\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n  assembledSource = injectShader(assembledSource, stage, declInjections);\n  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, stage, mainInjections);\n  return assembledSource;\n}\n/**\n * Pulls together complete source code for either a vertex or a fragment shader\n * adding prologues, requested module chunks, and any final injections.\n * @param gl\n * @param options\n * @returns\n */\nfunction assembleShaderGLSL(platformInfo, options) {\n  const {\n    id,\n    source,\n    stage,\n    language = 'glsl',\n    modules,\n    defines = {},\n    hookFunctions = [],\n    inject = {},\n    prologue = true,\n    log\n  } = options;\n  assert(typeof source === 'string', 'shader source must be a string');\n  const sourceVersion = language === 'glsl' ? getShaderInfo(source).version : -1;\n  const targetVersion = platformInfo.shaderLanguageVersion;\n  const sourceVersionDirective = sourceVersion === 100 ? '#version 100' : '#version 300 es';\n  const sourceLines = source.split('\\n');\n  // TODO : keep all pre-processor statements at the beginning of the shader.\n  const coreSource = sourceLines.slice(1).join('\\n');\n  // Combine Module and Application Defines\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.defines);\n  });\n  Object.assign(allDefines, defines);\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = '';\n  switch (language) {\n    case 'wgsl':\n      break;\n    case 'glsl':\n      assembledSource = prologue ? `\\\n${sourceVersionDirective}\n\n// ----- PROLOGUE -------------------------\n${getShaderNameDefine({\n        id,\n        source,\n        stage\n      })}\n${`#define SHADER_TYPE_${stage.toUpperCase()}`}\n\n${getPlatformShaderDefines(platformInfo)}\n${stage === 'fragment' ? FRAGMENT_SHADER_PROLOGUE : ''}\n\n// ----- APPLICATION DEFINES -------------------------\n\n${getApplicationDefines(allDefines)}\n\n` : `${sourceVersionDirective}\n`;\n      break;\n  }\n  const hookFunctionMap = normalizeShaderHooks(hookFunctions);\n  // Add source of dependent modules in resolved order\n  const hookInjections = {};\n  const declInjections = {};\n  const mainInjections = {};\n  for (const key in inject) {\n    const injection = typeof inject[key] === 'string' ? {\n      injection: inject[key],\n      order: 0\n    } : inject[key];\n    const match = /^(v|f)s:(#)?([\\w-]+)$/.exec(key);\n    if (match) {\n      const hash = match[2];\n      const name = match[3];\n      if (hash) {\n        if (name === 'decl') {\n          declInjections[key] = [injection];\n        } else {\n          mainInjections[key] = [injection];\n        }\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection];\n    }\n  }\n  for (const module of modules) {\n    if (log) {\n      checkShaderModuleDeprecations(module, coreSource, log);\n    }\n    const moduleSource = getShaderModuleSource(module, stage);\n    // Add the module source, and a #define that declares it presence\n    assembledSource += moduleSource;\n    const injections = module.instance?.normalizedInjections[stage] || {};\n    for (const key in injections) {\n      const match = /^(v|f)s:#([\\w-]+)$/.exec(key);\n      if (match) {\n        const name = match[2];\n        const injectionType = name === 'decl' ? declInjections : mainInjections;\n        injectionType[key] = injectionType[key] || [];\n        injectionType[key].push(injections[key]);\n      } else {\n        hookInjections[key] = hookInjections[key] || [];\n        hookInjections[key].push(injections[key]);\n      }\n    }\n  }\n  assembledSource += '// ----- MAIN SHADER SOURCE -------------------------';\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n  assembledSource = injectShader(assembledSource, stage, declInjections);\n  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, stage, mainInjections);\n  if (language === 'glsl' && sourceVersion !== targetVersion) {\n    assembledSource = transpileGLSLShader(assembledSource, stage);\n  }\n  return assembledSource.trim();\n}\n/**\n * Returns a combined `getUniforms` covering the options for all the modules,\n * the created function will pass on options to the inidividual `getUniforms`\n * function of each shader module and combine the results into one object that\n * can be passed to setUniforms.\n * @param modules\n * @returns\n */\nexport function assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const module of modules) {\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = module.getUniforms?.(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n}\n/**\n * Generate \"glslify-compatible\" SHADER_NAME defines\n * These are understood by the GLSL error parsing function\n * If id is provided and no SHADER_NAME constant is present in source, create one\n */\nfunction getShaderNameDefine(options) {\n  const {\n    id,\n    source,\n    stage\n  } = options;\n  const injectShaderName = id && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName ? `\n#define SHADER_NAME ${id}_${stage}` : '';\n}\n/** Generates application defines from an object of key value pairs */\nfunction getApplicationDefines(defines = {}) {\n  let sourceText = '';\n  for (const define in defines) {\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n    }\n  }\n  return sourceText;\n}\n/** Extracts the source code chunk for the specified shader type from the named shader module */\nexport function getShaderModuleSource(module, stage) {\n  let moduleSource;\n  switch (stage) {\n    case 'vertex':\n      moduleSource = module.vs || '';\n      break;\n    case 'fragment':\n      moduleSource = module.fs || '';\n      break;\n    case 'wgsl':\n      moduleSource = module.source || '';\n      break;\n    default:\n      assert(false);\n  }\n  if (!module.name) {\n    throw new Error('Shader module must have a name');\n  }\n  const moduleName = module.name.toUpperCase().replace(/[^0-9a-z]/gi, '_');\n  let source = `\\\n// ----- MODULE ${module.name} ---------------\n\n`;\n  if (stage !== 'wgsl') {\n    source += `#define MODULE_${moduleName}\\n`;\n  }\n  source += `${moduleSource}\\n`;\n  return source;\n}\n/*\nfunction getHookFunctions(\n  hookFunctions: Record<string, HookFunction>,\n  hookInjections: Record<string, Injection[]>\n): string {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a: {order: number}, b: {order: number}): number => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\n\nfunction normalizeHookFunctions(hookFunctions: (string | HookFunction)[]): {\n  vs: Record<string, HookFunction>;\n  fs: Record<string, HookFunction>;\n} {\n  const result: {vs: Record<string, any>; fs: Record<string, any>} = {\n    vs: {},\n    fs: {}\n  };\n\n  hookFunctions.forEach((hookFunction: string | HookFunction) => {\n    let opts: HookFunction;\n    let hook: string;\n    if (typeof hookFunction !== 'string') {\n      opts = hookFunction;\n      hook = opts.hook;\n    } else {\n      opts = {} as HookFunction;\n      hook = hookFunction;\n    }\n    hook = hook.trim();\n    const [stage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    if (stage !== 'vs' && stage !== 'fs') {\n      throw new Error(stage);\n    }\n    result[stage][name] = Object.assign(opts, {signature});\n  });\n\n  return result;\n}\n*/","map":{"version":3,"names":["getShaderModuleDependencies","getPlatformShaderDefines","injectShader","DECLARATION_INJECT_MARKER","transpileGLSLShader","checkShaderModuleDeprecations","normalizeShaderHooks","getShaderHooks","assert","getShaderInfo","INJECT_SHADER_DECLARATIONS","FRAGMENT_SHADER_PROLOGUE","assembleWGSLShader","options","modules","source","assembleShaderWGSL","platformInfo","stage","getUniforms","assembleGetUniforms","assembleGLSLShaderPair","vs","fs","assembleShaderGLSL","hookFunctions","inject","log","coreSource","assembledSource","hookFunctionMap","hookInjections","declInjections","mainInjections","key","injection","order","match","exec","hash","name","modulesToInject","module","moduleSource","getShaderModuleSource","injections","injectionType","push","id","language","defines","prologue","sourceVersion","version","targetVersion","shaderLanguageVersion","sourceVersionDirective","sourceLines","split","slice","join","allDefines","forEach","Object","assign","getShaderNameDefine","toUpperCase","getApplicationDefines","instance","normalizedInjections","trim","opts","uniforms","moduleUniforms","injectShaderName","indexOf","sourceText","define","value","Number","isFinite","Error","moduleName","replace"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\shadertools\\src\\lib\\shader-assembly\\assemble-shaders.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {getShaderModuleDependencies} from '../shader-module/shader-module-dependencies';\nimport {PlatformInfo} from './platform-info';\nimport {getPlatformShaderDefines} from './platform-defines';\nimport {injectShader, DECLARATION_INJECT_MARKER} from './shader-injections';\nimport {transpileGLSLShader} from '../shader-transpiler/transpile-glsl-shader';\nimport {checkShaderModuleDeprecations} from '../shader-module/shader-module';\nimport type {ShaderInjection} from './shader-injections';\nimport type {ShaderModule} from '../shader-module/shader-module';\nimport {ShaderHook, normalizeShaderHooks, getShaderHooks} from './shader-hooks';\nimport {assert} from '../utils/assert';\nimport {getShaderInfo} from '../glsl-utils/get-shader-info';\n\n/** Define map */\nexport type ShaderDefine = string | number | boolean;\n\nconst INJECT_SHADER_DECLARATIONS = `\\n\\n${DECLARATION_INJECT_MARKER}\\n`;\n\n/**\n * Precision prologue to inject before functions are injected in shader\n * TODO - extract any existing prologue in the fragment source and move it up...\n */\nconst FRAGMENT_SHADER_PROLOGUE = /* glsl */ `\\\nprecision highp float;\n`;\n\n/**\n * Options for `ShaderAssembler.assembleShaders()`\n */\nexport type AssembleShaderProps = AssembleShaderOptions & {\n  platformInfo: PlatformInfo;\n  /** WGSL: single shader source. */\n  source?: string | null;\n  /** GLSL vertex shader source. */\n  vs?: string | null;\n  /** GLSL fragment shader source. */\n  fs?: string | null;\n};\n\nexport type AssembleShaderOptions = {\n  /** information about the platform (which shader language & version, extensions etc.) */\n  platformInfo: PlatformInfo;\n  /** Inject shader id #defines */\n  id?: string;\n  /** Modules to be injected */\n  modules?: ShaderModule[];\n  /** Defines to be injected */\n  defines?: Record<string, ShaderDefine>;\n  /** Hook functions */\n  hookFunctions?: (ShaderHook | string)[];\n  /** Code injections */\n  inject?: Record<string, string | ShaderInjection>;\n  /** Whether to inject prologue */\n  prologue?: boolean;\n  /** logger object */\n  log?: any;\n};\n\ntype AssembleStageOptions = {\n  /** Inject shader id #defines */\n  id?: string;\n  /** Vertex shader */\n  source: string;\n  stage: 'vertex' | 'fragment';\n  /** Modules to be injected */\n  modules: any[];\n  /** Defines to be injected */\n  defines?: Record<string, ShaderDefine>;\n  /** Hook functions */\n  hookFunctions?: (ShaderHook | string)[];\n  /** Code injections */\n  inject?: Record<string, string | ShaderInjection>;\n  /** Whether to inject prologue */\n  prologue?: boolean;\n  /** logger object */\n  log?: any;\n};\n\nexport type HookFunction = {hook: string; header: string; footer: string; signature?: string};\n\n/**\n * getUniforms function returned from the shader module system\n */\nexport type GetUniformsFunc = (opts: Record<string, any>) => Record<string, any>;\n\n/**\n * Inject a list of shader modules into a single shader source for WGSL\n */\nexport function assembleWGSLShader(\n  options: AssembleShaderOptions & {\n    /** Single WGSL shader */\n    source: string;\n  }\n): {\n  source: string;\n  getUniforms: GetUniformsFunc;\n} {\n  const modules = getShaderModuleDependencies(options.modules || []);\n\n  return {\n    source: assembleShaderWGSL(options.platformInfo, {\n      ...options,\n      source: options.source,\n      stage: 'vertex',\n      modules\n    }),\n    getUniforms: assembleGetUniforms(modules)\n  };\n}\n\n/**\n * Injects dependent shader module sources into pair of main vertex/fragment shader sources for GLSL\n */\nexport function assembleGLSLShaderPair(\n  options: AssembleShaderOptions & {\n    /** Vertex shader */\n    vs: string;\n    /** Fragment shader */\n    fs?: string;\n  }\n): {\n  vs: string;\n  fs: string;\n  getUniforms: GetUniformsFunc;\n} {\n  const {vs, fs} = options;\n  const modules = getShaderModuleDependencies(options.modules || []);\n\n  return {\n    vs: assembleShaderGLSL(options.platformInfo, {\n      ...options,\n      source: vs,\n      stage: 'vertex',\n      modules\n    }),\n    fs: assembleShaderGLSL(options.platformInfo, {\n      ...options,\n      // @ts-expect-error\n      source: fs,\n      stage: 'fragment',\n      modules\n    }),\n    getUniforms: assembleGetUniforms(modules)\n  };\n}\n\n/**\n * Pulls together complete source code for either a vertex or a fragment shader\n * adding prologues, requested module chunks, and any final injections.\n * @param gl\n * @param options\n * @returns\n */\nexport function assembleShaderWGSL(platformInfo: PlatformInfo, options: AssembleStageOptions) {\n  const {\n    // id,\n    source,\n    stage,\n    modules,\n    // defines = {},\n    hookFunctions = [],\n    inject = {},\n    log\n  } = options;\n\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  // const isVertex = type === 'vs';\n  // const sourceLines = source.split('\\n');\n\n  const coreSource = source;\n\n  // Combine Module and Application Defines\n  // const allDefines = {};\n  // modules.forEach(module => {\n  //   Object.assign(allDefines, module.getDefines());\n  // });\n  // Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = '';\n  //   prologue\n  //     ? `\\\n  // ${getShaderNameDefine({id, source, type})}\n  // ${getShaderType(type)}\n  // ${getPlatformShaderDefines(platformInfo)}\n  // ${getApplicationDefines(allDefines)}\n  // ${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n  // `\n  // `;\n\n  const hookFunctionMap = normalizeShaderHooks(hookFunctions);\n\n  // Add source of dependent modules in resolved order\n  const hookInjections: Record<string, ShaderInjection[]> = {};\n  const declInjections: Record<string, ShaderInjection[]> = {};\n  const mainInjections: Record<string, ShaderInjection[]> = {};\n\n  for (const key in inject) {\n    const injection =\n      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];\n    const match = /^(v|f)s:(#)?([\\w-]+)$/.exec(key);\n    if (match) {\n      const hash = match[2];\n      const name = match[3];\n      if (hash) {\n        if (name === 'decl') {\n          declInjections[key] = [injection as any];\n        } else {\n          mainInjections[key] = [injection as any];\n        }\n      } else {\n        hookInjections[key] = [injection as any];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection as any];\n    }\n  }\n\n  // TODO - hack until shadertool modules support WebGPU\n  const modulesToInject = modules;\n\n  for (const module of modulesToInject) {\n    if (log) {\n      checkShaderModuleDeprecations(module, coreSource, log);\n    }\n    const moduleSource = getShaderModuleSource(module, 'wgsl');\n    // Add the module source, and a #define that declares it presence\n    assembledSource += moduleSource;\n\n    const injections = module.injections?.[stage] || {};\n    for (const key in injections) {\n      const match = /^(v|f)s:#([\\w-]+)$/.exec(key);\n      if (match) {\n        const name = match[2];\n        const injectionType = name === 'decl' ? declInjections : mainInjections;\n        injectionType[key] = injectionType[key] || [];\n        injectionType[key].push(injections[key]);\n      } else {\n        hookInjections[key] = hookInjections[key] || [];\n        hookInjections[key].push(injections[key]);\n      }\n    }\n  }\n\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n\n  assembledSource = injectShader(assembledSource, stage, declInjections);\n\n  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, stage, mainInjections);\n\n  return assembledSource;\n}\n\n/**\n * Pulls together complete source code for either a vertex or a fragment shader\n * adding prologues, requested module chunks, and any final injections.\n * @param gl\n * @param options\n * @returns\n */\nfunction assembleShaderGLSL(\n  platformInfo: PlatformInfo,\n  options: {\n    id?: string;\n    source: string;\n    language?: 'glsl' | 'wgsl';\n    stage: 'vertex' | 'fragment';\n    modules: ShaderModule[];\n    defines?: Record<string, ShaderDefine>;\n    hookFunctions?: any[];\n    inject?: Record<string, string | ShaderInjection>;\n    prologue?: boolean;\n    log?: any;\n  }\n) {\n  const {\n    id,\n    source,\n    stage,\n    language = 'glsl',\n    modules,\n    defines = {},\n    hookFunctions = [],\n    inject = {},\n    prologue = true,\n    log\n  } = options;\n\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  const sourceVersion = language === 'glsl' ? getShaderInfo(source).version : -1;\n  const targetVersion = platformInfo.shaderLanguageVersion;\n\n  const sourceVersionDirective = sourceVersion === 100 ? '#version 100' : '#version 300 es';\n\n  const sourceLines = source.split('\\n');\n  // TODO : keep all pre-processor statements at the beginning of the shader.\n  const coreSource = sourceLines.slice(1).join('\\n');\n\n  // Combine Module and Application Defines\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.defines);\n  });\n  Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = '';\n  switch (language) {\n    case 'wgsl':\n      break;\n    case 'glsl':\n      assembledSource = prologue\n        ? `\\\n${sourceVersionDirective}\n\n// ----- PROLOGUE -------------------------\n${getShaderNameDefine({id, source, stage})}\n${`#define SHADER_TYPE_${stage.toUpperCase()}`}\n\n${getPlatformShaderDefines(platformInfo)}\n${stage === 'fragment' ? FRAGMENT_SHADER_PROLOGUE : ''}\n\n// ----- APPLICATION DEFINES -------------------------\n\n${getApplicationDefines(allDefines)}\n\n`\n        : `${sourceVersionDirective}\n`;\n      break;\n  }\n\n  const hookFunctionMap = normalizeShaderHooks(hookFunctions);\n\n  // Add source of dependent modules in resolved order\n  const hookInjections: Record<string, ShaderInjection[]> = {};\n  const declInjections: Record<string, ShaderInjection[]> = {};\n  const mainInjections: Record<string, ShaderInjection[]> = {};\n\n  for (const key in inject) {\n    const injection: ShaderInjection =\n      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];\n    const match = /^(v|f)s:(#)?([\\w-]+)$/.exec(key);\n    if (match) {\n      const hash = match[2];\n      const name = match[3];\n      if (hash) {\n        if (name === 'decl') {\n          declInjections[key] = [injection];\n        } else {\n          mainInjections[key] = [injection];\n        }\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection];\n    }\n  }\n\n  for (const module of modules) {\n    if (log) {\n      checkShaderModuleDeprecations(module, coreSource, log);\n    }\n    const moduleSource = getShaderModuleSource(module, stage);\n    // Add the module source, and a #define that declares it presence\n    assembledSource += moduleSource;\n\n    const injections = module.instance?.normalizedInjections[stage] || {};\n    for (const key in injections) {\n      const match = /^(v|f)s:#([\\w-]+)$/.exec(key);\n      if (match) {\n        const name = match[2];\n        const injectionType = name === 'decl' ? declInjections : mainInjections;\n        injectionType[key] = injectionType[key] || [];\n        injectionType[key].push(injections[key]);\n      } else {\n        hookInjections[key] = hookInjections[key] || [];\n        hookInjections[key].push(injections[key]);\n      }\n    }\n  }\n\n  assembledSource += '// ----- MAIN SHADER SOURCE -------------------------';\n\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n\n  assembledSource = injectShader(assembledSource, stage, declInjections);\n\n  assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, stage, mainInjections);\n\n  if (language === 'glsl' && sourceVersion !== targetVersion) {\n    assembledSource = transpileGLSLShader(assembledSource, stage);\n  }\n\n  return assembledSource.trim();\n}\n\n/**\n * Returns a combined `getUniforms` covering the options for all the modules,\n * the created function will pass on options to the inidividual `getUniforms`\n * function of each shader module and combine the results into one object that\n * can be passed to setUniforms.\n * @param modules\n * @returns\n */\nexport function assembleGetUniforms(modules: ShaderModule[]) {\n  return function getUniforms(opts: Record<string, any>): Record<string, any> {\n    const uniforms = {};\n    for (const module of modules) {\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = module.getUniforms?.(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n}\n\n/**\n * Generate \"glslify-compatible\" SHADER_NAME defines\n * These are understood by the GLSL error parsing function\n * If id is provided and no SHADER_NAME constant is present in source, create one\n */\nfunction getShaderNameDefine(options: {\n  id?: string;\n  source: string;\n  stage: 'vertex' | 'fragment';\n}): string {\n  const {id, source, stage} = options;\n  const injectShaderName = id && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName\n    ? `\n#define SHADER_NAME ${id}_${stage}`\n    : '';\n}\n\n/** Generates application defines from an object of key value pairs */\nfunction getApplicationDefines(defines: Record<string, ShaderDefine> = {}): string {\n  let sourceText = '';\n  for (const define in defines) {\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n    }\n  }\n  return sourceText;\n}\n\n/** Extracts the source code chunk for the specified shader type from the named shader module */\nexport function getShaderModuleSource(\n  module: ShaderModule,\n  stage: 'vertex' | 'fragment' | 'wgsl'\n): string {\n  let moduleSource;\n  switch (stage) {\n    case 'vertex':\n      moduleSource = module.vs || '';\n      break;\n    case 'fragment':\n      moduleSource = module.fs || '';\n      break;\n    case 'wgsl':\n      moduleSource = module.source || '';\n      break;\n    default:\n      assert(false);\n  }\n\n  if (!module.name) {\n    throw new Error('Shader module must have a name');\n  }\n  const moduleName = module.name.toUpperCase().replace(/[^0-9a-z]/gi, '_');\n  let source = `\\\n// ----- MODULE ${module.name} ---------------\n\n`;\n  if (stage !== 'wgsl') {\n    source += `#define MODULE_${moduleName}\\n`;\n  }\n  source += `${moduleSource}\\n`;\n  return source;\n}\n\n/*\nfunction getHookFunctions(\n  hookFunctions: Record<string, HookFunction>,\n  hookInjections: Record<string, Injection[]>\n): string {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a: {order: number}, b: {order: number}): number => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\n\nfunction normalizeHookFunctions(hookFunctions: (string | HookFunction)[]): {\n  vs: Record<string, HookFunction>;\n  fs: Record<string, HookFunction>;\n} {\n  const result: {vs: Record<string, any>; fs: Record<string, any>} = {\n    vs: {},\n    fs: {}\n  };\n\n  hookFunctions.forEach((hookFunction: string | HookFunction) => {\n    let opts: HookFunction;\n    let hook: string;\n    if (typeof hookFunction !== 'string') {\n      opts = hookFunction;\n      hook = opts.hook;\n    } else {\n      opts = {} as HookFunction;\n      hook = hookFunction;\n    }\n    hook = hook.trim();\n    const [stage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    if (stage !== 'vs' && stage !== 'fs') {\n      throw new Error(stage);\n    }\n    result[stage][name] = Object.assign(opts, {signature});\n  });\n\n  return result;\n}\n*/\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}