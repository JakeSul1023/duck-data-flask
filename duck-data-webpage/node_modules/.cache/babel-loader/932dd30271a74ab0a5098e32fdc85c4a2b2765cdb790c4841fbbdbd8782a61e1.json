{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { project } from '@deck.gl/core';\nconst uniformBlock = /* glsl */`\\\nuniform maskUniforms {\n  vec4 bounds;\n  highp int channel;\n  bool enabled;\n  bool inverted;\n  bool maskByInstance;\n} mask;\n`;\nconst vertex = /* glsl */`\nvec2 mask_getCoords(vec4 position) {\n  return (position.xy - mask.bounds.xy) / (mask.bounds.zw - mask.bounds.xy);\n}\n`;\nconst vs = `\n${uniformBlock}\n${vertex}\n`;\nconst fragment = /* glsl */`\nuniform sampler2D mask_texture;\n\nbool mask_isInBounds(vec2 texCoords) {\n  if (!mask.enabled) {\n    return true;\n  }\n  vec4 maskColor = texture(mask_texture, texCoords);\n  float maskValue = 1.0;\n  if (mask.channel == 0) {\n    maskValue = maskColor.r;\n  } else if (mask.channel == 1) {\n    maskValue = maskColor.g;\n  } else if (mask.channel == 2) {\n    maskValue = maskColor.b;\n  } else if (mask.channel == 3) {\n    maskValue = maskColor.a;\n  }\n\n  if (mask.inverted) {\n    return maskValue >= 0.5;\n  } else {\n    return maskValue < 0.5;\n  }\n}\n`;\nconst fs = `\n${uniformBlock}\n${fragment}\n`;\nconst inject = {\n  'vs:#decl': /* glsl */`\nout vec2 mask_texCoords;\n`,\n  'vs:#main-end': /* glsl */`\n   vec4 mask_common_position;\n   if (mask.maskByInstance) {\n     mask_common_position = project_position(vec4(geometry.worldPosition, 1.0));\n   } else {\n     mask_common_position = geometry.position;\n   }\n   mask_texCoords = mask_getCoords(mask_common_position);\n`,\n  'fs:#decl': /* glsl */`\nin vec2 mask_texCoords;\n`,\n  'fs:#main-start': /* glsl */`\n  if (mask.enabled) {\n    bool mask = mask_isInBounds(mask_texCoords);\n\n    // Debug: show extent of render target\n    // fragColor = vec4(mask_texCoords, 0.0, 1.0);\n    // fragColor = texture(mask_texture, mask_texCoords);\n\n    if (!mask) discard;\n  }\n`\n};\n/* eslint-disable camelcase */\nconst getMaskUniforms = opts => {\n  if (opts && 'maskMap' in opts) {\n    return {\n      mask_texture: opts.maskMap\n    };\n  }\n  return opts || {};\n};\nexport default {\n  name: 'mask',\n  dependencies: [project],\n  vs,\n  fs,\n  inject,\n  getUniforms: getMaskUniforms,\n  uniformTypes: {\n    bounds: 'vec4<f32>',\n    channel: 'i32',\n    enabled: 'i32',\n    inverted: 'i32',\n    maskByInstance: 'i32'\n  }\n};","map":{"version":3,"names":["project","uniformBlock","vertex","vs","fragment","fs","inject","getMaskUniforms","opts","mask_texture","maskMap","name","dependencies","getUniforms","uniformTypes","bounds","channel","enabled","inverted","maskByInstance"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\extensions\\src\\mask\\shader-module.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\nimport {project} from '@deck.gl/core';\nimport type {Texture} from '@luma.gl/core';\n\nconst uniformBlock = /* glsl */ `\\\nuniform maskUniforms {\n  vec4 bounds;\n  highp int channel;\n  bool enabled;\n  bool inverted;\n  bool maskByInstance;\n} mask;\n`;\n\nconst vertex = /* glsl */ `\nvec2 mask_getCoords(vec4 position) {\n  return (position.xy - mask.bounds.xy) / (mask.bounds.zw - mask.bounds.xy);\n}\n`;\n\nconst vs = `\n${uniformBlock}\n${vertex}\n`;\n\nconst fragment = /* glsl */ `\nuniform sampler2D mask_texture;\n\nbool mask_isInBounds(vec2 texCoords) {\n  if (!mask.enabled) {\n    return true;\n  }\n  vec4 maskColor = texture(mask_texture, texCoords);\n  float maskValue = 1.0;\n  if (mask.channel == 0) {\n    maskValue = maskColor.r;\n  } else if (mask.channel == 1) {\n    maskValue = maskColor.g;\n  } else if (mask.channel == 2) {\n    maskValue = maskColor.b;\n  } else if (mask.channel == 3) {\n    maskValue = maskColor.a;\n  }\n\n  if (mask.inverted) {\n    return maskValue >= 0.5;\n  } else {\n    return maskValue < 0.5;\n  }\n}\n`;\n\nconst fs = `\n${uniformBlock}\n${fragment}\n`;\n\nconst inject = {\n  'vs:#decl': /* glsl */ `\nout vec2 mask_texCoords;\n`,\n  'vs:#main-end': /* glsl */ `\n   vec4 mask_common_position;\n   if (mask.maskByInstance) {\n     mask_common_position = project_position(vec4(geometry.worldPosition, 1.0));\n   } else {\n     mask_common_position = geometry.position;\n   }\n   mask_texCoords = mask_getCoords(mask_common_position);\n`,\n  'fs:#decl': /* glsl */ `\nin vec2 mask_texCoords;\n`,\n  'fs:#main-start': /* glsl */ `\n  if (mask.enabled) {\n    bool mask = mask_isInBounds(mask_texCoords);\n\n    // Debug: show extent of render target\n    // fragColor = vec4(mask_texCoords, 0.0, 1.0);\n    // fragColor = texture(mask_texture, mask_texCoords);\n\n    if (!mask) discard;\n  }\n`\n};\n\ntype MaskBindingProps = {\n  maskMap?: Texture;\n};\n\ntype MaskUniformProps = {\n  bounds: [number, number, number, number];\n  channel: number;\n  enabled: boolean;\n  inverted: boolean;\n  maskByInstance: boolean;\n};\n\nexport type MaskProps = MaskBindingProps & MaskUniformProps;\n\n/* eslint-disable camelcase */\nconst getMaskUniforms = (opts?: MaskProps | {}): Record<string, any> => {\n  if (opts && 'maskMap' in opts) {\n    return {\n      mask_texture: opts.maskMap\n    };\n  }\n  return opts || {};\n};\n\nexport default {\n  name: 'mask',\n  dependencies: [project],\n  vs,\n  fs,\n  inject,\n  getUniforms: getMaskUniforms,\n  uniformTypes: {\n    bounds: 'vec4<f32>',\n    channel: 'i32',\n    enabled: 'i32',\n    inverted: 'i32',\n    maskByInstance: 'i32'\n  }\n} as const satisfies ShaderModule<MaskProps>;\n"],"mappings":"AAAA;AACA;AACA;AAGA,SAAQA,OAAO,QAAO,eAAe;AAGrC,MAAMC,YAAY,GAAG,UAAW;;;;;;;;CAQ/B;AAED,MAAMC,MAAM,GAAG,UAAW;;;;CAIzB;AAED,MAAMC,EAAE,GAAG;EACTF,YAAY;EACZC,MAAM;CACP;AAED,MAAME,QAAQ,GAAG,UAAW;;;;;;;;;;;;;;;;;;;;;;;;;CAyB3B;AAED,MAAMC,EAAE,GAAG;EACTJ,YAAY;EACZG,QAAQ;CACT;AAED,MAAME,MAAM,GAAG;EACb,UAAU,EAAE,UAAW;;CAExB;EACC,cAAc,EAAE,UAAW;;;;;;;;CAQ5B;EACC,UAAU,EAAE,UAAW;;CAExB;EACC,gBAAgB,EAAE,UAAW;;;;;;;;;;;CAW9B;AAgBD;AACA,MAAMC,eAAe,GAAIC,IAAqB,IAAyB;EACrE,IAAIA,IAAI,IAAI,SAAS,IAAIA,IAAI,EAAE;IAC7B,OAAO;MACLC,YAAY,EAAED,IAAI,CAACE;KACpB;EACH;EACA,OAAOF,IAAI,IAAI,EAAE;AACnB,CAAC;AAED,eAAe;EACbG,IAAI,EAAE,MAAM;EACZC,YAAY,EAAE,CAACZ,OAAO,CAAC;EACvBG,EAAE;EACFE,EAAE;EACFC,MAAM;EACNO,WAAW,EAAEN,eAAe;EAC5BO,YAAY,EAAE;IACZC,MAAM,EAAE,WAAW;IACnBC,OAAO,EAAE,KAAK;IACdC,OAAO,EAAE,KAAK;IACdC,QAAQ,EAAE,KAAK;IACfC,cAAc,EAAE;;CAEwB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}