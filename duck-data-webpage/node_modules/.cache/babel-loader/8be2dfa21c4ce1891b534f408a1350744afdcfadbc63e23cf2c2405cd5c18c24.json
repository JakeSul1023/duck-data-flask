{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { createIterable, getAccessorFromBuffer } from \"./iterable-utils.js\";\nimport defaultTypedArrayManager from \"./typed-array-manager.js\";\nimport assert from \"./assert.js\";\nimport { Buffer } from '@luma.gl/core';\nexport default class Tesselator {\n  constructor(opts) {\n    this.indexStarts = [0];\n    this.vertexStarts = [0];\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    const {\n      attributes = {}\n    } = opts;\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n    this.updateGeometry(opts);\n  }\n  /* Public methods */\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n    // @ts-ignore (2339) when geometryBuffer is a luma Buffer, size falls back to positionFormat\n    geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices); // binary data missing startIndices\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.vertexPositions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.vertexPositions;\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n  updatePartialGeometry(_ref) {\n    let {\n      startRow,\n      endRow\n    } = _ref;\n    this._rebuildGeometry({\n      startRow,\n      endRow\n    });\n  }\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n    if (!ArrayBuffer.isView(value)) {\n      // Cannot read binary geometries\n      return null;\n    }\n    // @ts-ignore (2322) NumericArray not assignable to GeometryT\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n  /* Private utility methods */\n  _allocate(instanceCount, copy) {\n    // allocate attributes\n    const {\n      attributes,\n      buffers,\n      _attributeDefs,\n      typedArrayManager\n    } = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {\n      data,\n      getGeometry\n    } = this;\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;\n      visitor(geometry, objectInfo.index);\n    }\n  }\n  /* eslint-disable complexity,max-statements */\n  _rebuildGeometry(dataRange) {\n    if (!this.data) {\n      return;\n    }\n    let {\n      indexStarts,\n      vertexStarts,\n      instanceCount\n    } = this;\n    const {\n      data,\n      geometryBuffer\n    } = this;\n    const {\n      startRow = 0,\n      endRow = Infinity\n    } = dataRange || {};\n    const normalizedData = {};\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry((geometry, dataIndex) => {\n        const normalizedGeometry = geometry && this.normalizeGeometry(geometry);\n        normalizedData[dataIndex] = normalizedGeometry;\n        vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);\n      }, startRow, endRow);\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else {\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || 0;\n      if (ArrayBuffer.isView(geometryBuffer)) {\n        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;\n      } else if (geometryBuffer instanceof Buffer) {\n        const byteStride = this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;\n      } else if (geometryBuffer.buffer) {\n        const byteStride = geometryBuffer.stride || this.positionSize * 4;\n        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;\n      } else if (geometryBuffer.value) {\n        const bufferValue = geometryBuffer.value;\n        const elementStride =\n        // @ts-ignore (2339) if stride is not specified, will fall through to positionSize\n        geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        instanceCount = instanceCount || bufferValue.length / elementStride;\n      }\n    }\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n    // @ts-ignore (2739) context will be populated in the loop\n    const context = {};\n    this._forEachGeometry((geometry, dataIndex) => {\n      const normalizedGeometry = normalizedData[dataIndex] || geometry;\n      context.vertexStart = vertexStarts[dataIndex];\n      context.indexStart = indexStarts[dataIndex];\n      const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n      context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n      context.geometryIndex = dataIndex;\n      this.updateGeometryAttributes(normalizedGeometry, context);\n    }, startRow, endRow);\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n//# sourceMappingURL=tesselator.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}