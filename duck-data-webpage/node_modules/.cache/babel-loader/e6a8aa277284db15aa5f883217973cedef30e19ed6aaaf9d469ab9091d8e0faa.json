{"ast":null,"code":"import { padToNBytes, assert } from '@loaders.gl/loader-utils';\n/** Binary GLTF is little endian. */\nconst LITTLE_ENDIAN = true;\n/** 'glTF' in Big-Endian ASCII */\nconst MAGIC_glTF = 0x676c5446;\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\nconst GLB_V1_CONTENT_FORMAT_JSON = 0x0;\n/** @deprecated - Backward compatibility for old xviz files */\nconst GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;\n/** @deprecated - Backward compatibility for old xviz files */\nconst GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;\nfunction getMagicString(dataView, byteOffset = 0) {\n  return `\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;\n}\n/** Check if the contents of an array buffer contains GLB byte markers */\nexport function isGLB(arrayBuffer, byteOffset = 0, options = {}) {\n  const dataView = new DataView(arrayBuffer);\n  // Check that GLB Header starts with the magic number\n  const {\n    magic = MAGIC_glTF\n  } = options;\n  const magic1 = dataView.getUint32(byteOffset, false);\n  return magic1 === magic || magic1 === MAGIC_glTF;\n}\n/**\n * Synchronously parse a GLB\n * @param glb - Target, Output is stored there\n * @param arrayBuffer - Input data\n * @param byteOffset - Offset into arrayBuffer to start parsing from (for \"embedded\" GLBs, e.g. in 3D tiles)\n * @param options\n * @returns\n */\nexport function parseGLBSync(glb, arrayBuffer, byteOffset = 0, options = {}) {\n  // Check that GLB Header starts with the magic number\n  const dataView = new DataView(arrayBuffer);\n  // Compare format with GLBLoader documentation\n  const type = getMagicString(dataView, byteOffset + 0);\n  const version = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN); // Version 2 of binary glTF container format\n  const byteLength = dataView.getUint32(byteOffset + 8, LITTLE_ENDIAN); // Total byte length of binary file\n  Object.assign(glb, {\n    // Put less important stuff in a header, to avoid clutter\n    header: {\n      byteOffset,\n      // Byte offset into the initial arrayBuffer\n      byteLength,\n      hasBinChunk: false\n    },\n    type,\n    version,\n    json: {},\n    binChunks: []\n  });\n  byteOffset += GLB_FILE_HEADER_SIZE;\n  switch (glb.version) {\n    case 1:\n      return parseGLBV1(glb, dataView, byteOffset);\n    case 2:\n      return parseGLBV2(glb, dataView, byteOffset, options = {});\n    default:\n      throw new Error(`Invalid GLB version ${glb.version}. Only supports version 1 and 2.`);\n  }\n}\n/**\n * Parse a V1 GLB\n * @param glb - target, output is stored in this object\n * @param dataView - Input, memory to be parsed\n * @param byteOffset - Offset of first byte of GLB data in the data view\n * @returns Number of bytes parsed (there could be additional non-GLB data after the GLB)\n */\nfunction parseGLBV1(glb, dataView, byteOffset) {\n  // Sanity: ensure file is big enough to hold at least the headers\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n  // Explanation of GLB structure:\n  // https://cloud.githubusercontent.com/assets/3479527/22600725/36b87122-ea55-11e6-9d40-6fd42819fcab.png\n  const contentLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN); // Byte length of chunk\n  const contentFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN); // Chunk format as uint32\n  byteOffset += GLB_CHUNK_HEADER_SIZE;\n  // GLB v1 only supports a single chunk type\n  assert(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);\n  parseJSONChunk(glb, dataView, byteOffset, contentLength);\n  // No need to call the function padToBytes() from parseJSONChunk()\n  byteOffset += contentLength;\n  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);\n  return byteOffset;\n}\n/**\n * Parse a V2 GLB\n * @param glb - target, output is stored in this object\n * @param dataView - Input, memory to be parsed\n * @param byteOffset - Offset of first byte of GLB data in the data view\n * @returns Number of bytes parsed (there could be additional non-GLB data after the GLB)\n */\nfunction parseGLBV2(glb, dataView, byteOffset, options) {\n  // Sanity: ensure file is big enough to hold at least the first chunk header\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n  parseGLBChunksSync(glb, dataView, byteOffset, options);\n  return byteOffset + glb.header.byteLength;\n}\n/** Iterate over GLB chunks and parse them */\nfunction parseGLBChunksSync(glb, dataView, byteOffset, options) {\n  // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n  // Iterate as long as there is space left for another chunk header\n  while (byteOffset + 8 <= glb.header.byteLength) {\n    const chunkLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN); // Byte length of chunk\n    const chunkFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN); // Chunk format as uint32\n    byteOffset += GLB_CHUNK_HEADER_SIZE;\n    // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n    switch (chunkFormat) {\n      case GLB_CHUNK_TYPE_JSON:\n        parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n      case GLB_CHUNK_TYPE_BIN:\n        parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n      // Backward compatibility for very old xviz files\n      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n      default:\n        // Ignore, per spec\n        // console.warn(`Unknown GLB chunk type`); // eslint-disable-line\n        break;\n    }\n    byteOffset += padToNBytes(chunkLength, 4);\n  }\n  return byteOffset;\n}\n/* Parse a GLB JSON chunk */\nfunction parseJSONChunk(glb, dataView, byteOffset, chunkLength) {\n  // 1. Create a \"view\" of the binary encoded JSON data inside the GLB\n  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);\n  // 2. Decode the JSON binary array into clear text\n  const textDecoder = new TextDecoder('utf8');\n  const jsonText = textDecoder.decode(jsonChunk);\n  // 3. Parse the JSON text into a JavaScript data structure\n  glb.json = JSON.parse(jsonText);\n  return padToNBytes(chunkLength, 4);\n}\n/** Parse a GLB BIN chunk */\nfunction parseBINChunk(glb, dataView, byteOffset, chunkLength) {\n  // Note: BIN chunk can be optional\n  glb.header.hasBinChunk = true;\n  glb.binChunks.push({\n    byteOffset,\n    byteLength: chunkLength,\n    arrayBuffer: dataView.buffer\n    // TODO - copy, or create typed array view?\n  });\n  return padToNBytes(chunkLength, 4);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}