{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { XMLLoader } from '@loaders.gl/xml';\nimport { deepStrictEqual } from \"./deep-strict-equal.js\";\nimport rewind from '@turf/rewind';\nfunction noTransform(...coords) {\n  return coords;\n}\n/**\n * Parses a typed data structure from raw XML for GML features\n * @note Error handlings is fairly weak\n */\nexport function parseGML(text, options) {\n  // GeoJSON | null {\n  const parsedXML = XMLLoader.parseTextSync?.(text, options);\n  options = {\n    transformCoords: noTransform,\n    stride: 2,\n    ...options\n  };\n  const context = createChildContext(parsedXML, options, {});\n  return parseGMLToGeometry(parsedXML, options, context);\n}\n/** Parse a GeoJSON geometry from GML XML */\nexport function parseGMLToGeometry(inputXML, options, context) {\n  const childContext = createChildContext(inputXML, options, context);\n  let geometry = null;\n  const [name, xml] = getFirstKeyValue(inputXML);\n  switch (name) {\n    // case 'gml:MultiPoint':\n    //   geometry = {\n    //     type: 'MultiPoint',\n    //     coordinates: parseMultiPoint(xml, options, childContext)\n    //   };\n    //   break;\n    case 'gml:LineString':\n      geometry = {\n        type: 'LineString',\n        coordinates: parseLinearRingOrLineString(xml, options, childContext)\n      };\n      break;\n    // case 'gml:MultiLineString':\n    //   geometry = {\n    //     type: 'MultiLineString',\n    //     coordinates: parseMultiLineString(xml, options, childContext)\n    //   };\n    //   break;\n    case 'gml:Polygon':\n    case 'gml:Rectangle':\n      geometry = {\n        type: 'Polygon',\n        coordinates: parsePolygonOrRectangle(xml, options, childContext)\n      };\n      break;\n    case 'gml:Surface':\n      geometry = {\n        type: 'MultiPolygon',\n        coordinates: parseSurface(xml, options, childContext)\n      };\n      break;\n    case 'gml:MultiSurface':\n      geometry = {\n        type: 'MultiPolygon',\n        coordinates: parseMultiSurface(xml, options, childContext)\n      };\n      break;\n    default:\n      return null;\n  }\n  // todo\n  return rewind(geometry, {\n    mutate: true\n  });\n}\n/** Parse a list of coordinates from a string */\nfunction parseCoords(s, options, context) {\n  const stride = context.srsDimension || options.stride || 2;\n  // Handle white space\n  const coords = s.replace(/\\s+/g, ' ').trim().split(' ');\n  if (coords.length === 0 || coords.length % stride !== 0) {\n    throw new Error(`invalid coordinates list (stride ${stride})`);\n  }\n  const points = [];\n  for (let i = 0; i < coords.length - 1; i += stride) {\n    const point = coords.slice(i, i + stride).map(parseFloat);\n    points.push(options.transformCoords?.(...point) || point);\n  }\n  return points;\n}\nexport function parsePosList(xml, options, context) {\n  const childContext = createChildContext(xml, options, context);\n  const coords = textOf(xml);\n  if (!coords) {\n    throw new Error('invalid gml:posList element');\n  }\n  return parseCoords(coords, options, childContext);\n}\nexport function parsePos(xml, options, context) {\n  const childContext = createChildContext(xml, options, context);\n  const coords = textOf(xml);\n  if (!coords) {\n    throw new Error('invalid gml:pos element');\n  }\n  const points = parseCoords(coords, options, childContext);\n  if (points.length !== 1) {\n    throw new Error('gml:pos must have 1 point');\n  }\n  return points[0];\n}\nexport function parsePoint(xml, options, context) {\n  const childContext = createChildContext(xml, options, context);\n  // TODO AV: Parse other gml:Point options\n  const pos = findIn(xml, 'gml:pos');\n  if (!pos) {\n    throw new Error('invalid gml:Point element, expected a gml:pos subelement');\n  }\n  return parsePos(pos, options, childContext);\n}\nexport function parseLinearRingOrLineString(xml, options, context) {\n  // or a LineStringSegment\n  const childContext = createChildContext(xml, options, context);\n  let points = [];\n  const posList = findIn(xml, 'gml:posList');\n  if (posList) {\n    points = parsePosList(posList, options, childContext);\n  } else {\n    for (const [childName, childXML] of Object.entries(xml)) {\n      switch (childName) {\n        case 'gml:Point':\n          points.push(parsePoint(childXML, options, childContext));\n          break;\n        case 'gml:pos':\n          points.push(parsePos(childXML, options, childContext));\n          break;\n        default:\n          continue;\n      }\n    }\n  }\n  if (points.length === 0) {\n    throw new Error(`${xml.name} must have > 0 points`);\n  }\n  return points;\n}\nexport function parseCurveSegments(xml, options, context) {\n  const points = [];\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:LineStringSegment':\n        const points2 = parseLinearRingOrLineString(childXML, options, context);\n        // remove overlapping\n        const end = points[points.length - 1];\n        const start = points2[0];\n        if (end && start && deepStrictEqual(end, start)) {\n          points2.shift();\n        }\n        points.push(...points2);\n        break;\n      default:\n        continue;\n    }\n  }\n  if (points.length === 0) {\n    throw new Error('gml:Curve > gml:segments must have > 0 points');\n  }\n  return points;\n}\nexport function parseRing(xml, options, context) {\n  const childContext = createChildContext(xml, options, context);\n  const points = [];\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:curveMember':\n        let points2;\n        const lineString = findIn(childXML, 'gml:LineString');\n        if (lineString) {\n          points2 = parseLinearRingOrLineString(lineString, options, childContext);\n        } else {\n          const segments = findIn(childXML, 'gml:Curve', 'gml:segments');\n          if (!segments) {\n            throw new Error(`invalid ${childName} element`);\n          }\n          points2 = parseCurveSegments(segments, options, childContext);\n        }\n        // remove overlapping\n        const end = points[points.length - 1];\n        const start = points2[0];\n        if (end && start && deepStrictEqual(end, start)) {\n          points2.shift();\n        }\n        points.push(...points2);\n        break;\n    }\n  }\n  if (points.length < 4) {\n    throw new Error(`${xml.name} must have >= 4 points`);\n  }\n  return points;\n}\nexport function parseExteriorOrInterior(xml, options, context) {\n  const linearRing = findIn(xml, 'gml:LinearRing');\n  if (linearRing) {\n    return parseLinearRingOrLineString(linearRing, options, context);\n  }\n  const ring = findIn(xml, 'gml:Ring');\n  if (!ring) {\n    throw new Error(`invalid ${xml.name} element`);\n  }\n  return parseRing(ring, options, context);\n}\nexport function parsePolygonOrRectangle(xml, options, context) {\n  // or PolygonPatch\n  const childContext = createChildContext(xml, options, context);\n  const exterior = findIn(xml, 'gml:exterior');\n  if (!exterior) {\n    throw new Error(`invalid ${xml.name} element`);\n  }\n  const pointLists = [parseExteriorOrInterior(exterior, options, childContext)];\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:interior':\n        pointLists.push(parseExteriorOrInterior(childXML, options, childContext));\n        break;\n    }\n  }\n  return pointLists;\n}\nexport function parseSurface(xml, options, context) {\n  const childContext = createChildContext(xml, options, context);\n  const patches = findIn(xml, 'gml:patches');\n  if (!patches) {\n    throw new Error(`invalid ${xml.name} element`);\n  }\n  const polygons = [];\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:PolygonPatch':\n      case 'gml:Rectangle':\n        polygons.push(parsePolygonOrRectangle(childXML, options, childContext));\n        break;\n      default:\n        continue;\n    }\n  }\n  if (polygons.length === 0) {\n    throw new Error(`${xml.name} must have > 0 polygons`);\n  }\n  return polygons;\n}\nexport function parseCompositeSurface(xml, options, context) {\n  const childContext = createChildContext(xml, options, context);\n  const polygons = [];\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:surfaceMember':\n      case 'gml:surfaceMembers':\n        const [c2Name, c2Xml] = getFirstKeyValue(childXML);\n        switch (c2Name) {\n          case 'gml:Surface':\n            polygons.push(...parseSurface(c2Xml, options, childContext));\n            break;\n          case 'gml:Polygon':\n            polygons.push(parsePolygonOrRectangle(c2Xml, options, childContext));\n            break;\n        }\n        break;\n    }\n  }\n  if (polygons.length === 0) {\n    throw new Error(`${xml.name} must have > 0 polygons`);\n  }\n  return polygons;\n}\nexport function parseMultiSurface(xml, options, context) {\n  let el = xml;\n  const surfaceMembers = findIn(xml, 'gml:LinearRing');\n  if (surfaceMembers) {\n    el = surfaceMembers;\n  }\n  const polygons = [];\n  for (const [childName, childXML] of Object.entries(el)) {\n    switch (childName) {\n      case 'gml:Surface':\n        const polygons2 = parseSurface(childXML, options, context);\n        polygons.push(...polygons2);\n        break;\n      case 'gml:surfaceMember':\n        const polygons3 = parseSurfaceMember(childXML, options, context);\n        polygons.push(...polygons3);\n        break;\n      case 'gml:surfaceMembers':\n        const polygonXML = findIn(childXML, 'gml:Polygon');\n        for (const surfaceMemberXML of polygonXML) {\n          const polygons3 = parseSurfaceMember(surfaceMemberXML, options, context);\n          polygons.push(...polygons3);\n        }\n        break;\n    }\n  }\n  if (polygons.length === 0) {\n    throw new Error(`${xml.name} must have > 0 polygons`);\n  }\n  return polygons;\n}\nfunction parseSurfaceMember(xml, options, context) {\n  const [childName, childXml] = getFirstKeyValue(xml);\n  switch (childName) {\n    case 'gml:CompositeSurface':\n      return parseCompositeSurface(childXml, options, context);\n    case 'gml:Surface':\n      return parseSurface(childXml, options, context);\n    case 'gml:Polygon':\n      return [parsePolygonOrRectangle(childXml, options, context)];\n  }\n  throw new Error(`${childName} must have polygons`);\n}\n// Helpers\nfunction textOf(el) {\n  if (typeof el !== 'string') {\n    throw new Error('expected string');\n  }\n  return el;\n}\nfunction findIn(root, ...tags) {\n  let el = root;\n  for (const tag of tags) {\n    const child = el[tag];\n    if (!child) {\n      return null;\n    }\n    el = child;\n  }\n  return el;\n}\n/** @returns the first [key, value] pair in an object, or ['', null] if empty object */\nfunction getFirstKeyValue(object) {\n  if (object && typeof object === 'object') {\n    for (const [key, value] of Object.entries(object)) {\n      return [key, value];\n    }\n  }\n  return ['', null];\n}\n/** A bit heavyweight for just tracking dimension? */\nfunction createChildContext(xml, options, context) {\n  const srsDimensionAttribute = xml.attributes && xml.attributes.srsDimension;\n  if (srsDimensionAttribute) {\n    const srsDimension = parseInt(srsDimensionAttribute);\n    if (Number.isNaN(srsDimension) || srsDimension <= 0) {\n      throw new Error(`invalid srsDimension attribute value \"${srsDimensionAttribute}\", expected a positive integer`);\n    }\n    const childContext = Object.create(context);\n    childContext.srsDimension = srsDimension;\n    return childContext;\n  }\n  return context;\n}","map":{"version":3,"names":["XMLLoader","deepStrictEqual","rewind","noTransform","coords","parseGML","text","options","parsedXML","parseTextSync","transformCoords","stride","context","createChildContext","parseGMLToGeometry","inputXML","childContext","geometry","name","xml","getFirstKeyValue","type","coordinates","parseLinearRingOrLineString","parsePolygonOrRectangle","parseSurface","parseMultiSurface","mutate","parseCoords","s","srsDimension","replace","trim","split","length","Error","points","i","point","slice","map","parseFloat","push","parsePosList","textOf","parsePos","parsePoint","pos","findIn","posList","childName","childXML","Object","entries","parseCurveSegments","points2","end","start","shift","parseRing","lineString","segments","parseExteriorOrInterior","linearRing","ring","exterior","pointLists","patches","polygons","parseCompositeSurface","c2Name","c2Xml","el","surfaceMembers","polygons2","polygons3","parseSurfaceMember","polygonXML","surfaceMemberXML","childXml","root","tags","tag","child","object","key","value","srsDimensionAttribute","attributes","parseInt","Number","isNaN","create"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/wms/dist/lib/parsers/gml/parse-gml.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { XMLLoader } from '@loaders.gl/xml';\nimport { deepStrictEqual } from \"./deep-strict-equal.js\";\nimport rewind from '@turf/rewind';\nfunction noTransform(...coords) {\n    return coords;\n}\n/**\n * Parses a typed data structure from raw XML for GML features\n * @note Error handlings is fairly weak\n */\nexport function parseGML(text, options) {\n    // GeoJSON | null {\n    const parsedXML = XMLLoader.parseTextSync?.(text, options);\n    options = { transformCoords: noTransform, stride: 2, ...options };\n    const context = createChildContext(parsedXML, options, {});\n    return parseGMLToGeometry(parsedXML, options, context);\n}\n/** Parse a GeoJSON geometry from GML XML */\nexport function parseGMLToGeometry(inputXML, options, context) {\n    const childContext = createChildContext(inputXML, options, context);\n    let geometry = null;\n    const [name, xml] = getFirstKeyValue(inputXML);\n    switch (name) {\n        // case 'gml:MultiPoint':\n        //   geometry = {\n        //     type: 'MultiPoint',\n        //     coordinates: parseMultiPoint(xml, options, childContext)\n        //   };\n        //   break;\n        case 'gml:LineString':\n            geometry = {\n                type: 'LineString',\n                coordinates: parseLinearRingOrLineString(xml, options, childContext)\n            };\n            break;\n        // case 'gml:MultiLineString':\n        //   geometry = {\n        //     type: 'MultiLineString',\n        //     coordinates: parseMultiLineString(xml, options, childContext)\n        //   };\n        //   break;\n        case 'gml:Polygon':\n        case 'gml:Rectangle':\n            geometry = {\n                type: 'Polygon',\n                coordinates: parsePolygonOrRectangle(xml, options, childContext)\n            };\n            break;\n        case 'gml:Surface':\n            geometry = {\n                type: 'MultiPolygon',\n                coordinates: parseSurface(xml, options, childContext)\n            };\n            break;\n        case 'gml:MultiSurface':\n            geometry = {\n                type: 'MultiPolygon',\n                coordinates: parseMultiSurface(xml, options, childContext)\n            };\n            break;\n        default:\n            return null;\n    }\n    // todo\n    return rewind(geometry, { mutate: true });\n}\n/** Parse a list of coordinates from a string */\nfunction parseCoords(s, options, context) {\n    const stride = context.srsDimension || options.stride || 2;\n    // Handle white space\n    const coords = s.replace(/\\s+/g, ' ').trim().split(' ');\n    if (coords.length === 0 || coords.length % stride !== 0) {\n        throw new Error(`invalid coordinates list (stride ${stride})`);\n    }\n    const points = [];\n    for (let i = 0; i < coords.length - 1; i += stride) {\n        const point = coords.slice(i, i + stride).map(parseFloat);\n        points.push(options.transformCoords?.(...point) || point);\n    }\n    return points;\n}\nexport function parsePosList(xml, options, context) {\n    const childContext = createChildContext(xml, options, context);\n    const coords = textOf(xml);\n    if (!coords) {\n        throw new Error('invalid gml:posList element');\n    }\n    return parseCoords(coords, options, childContext);\n}\nexport function parsePos(xml, options, context) {\n    const childContext = createChildContext(xml, options, context);\n    const coords = textOf(xml);\n    if (!coords) {\n        throw new Error('invalid gml:pos element');\n    }\n    const points = parseCoords(coords, options, childContext);\n    if (points.length !== 1) {\n        throw new Error('gml:pos must have 1 point');\n    }\n    return points[0];\n}\nexport function parsePoint(xml, options, context) {\n    const childContext = createChildContext(xml, options, context);\n    // TODO AV: Parse other gml:Point options\n    const pos = findIn(xml, 'gml:pos');\n    if (!pos) {\n        throw new Error('invalid gml:Point element, expected a gml:pos subelement');\n    }\n    return parsePos(pos, options, childContext);\n}\nexport function parseLinearRingOrLineString(xml, options, context) {\n    // or a LineStringSegment\n    const childContext = createChildContext(xml, options, context);\n    let points = [];\n    const posList = findIn(xml, 'gml:posList');\n    if (posList) {\n        points = parsePosList(posList, options, childContext);\n    }\n    else {\n        for (const [childName, childXML] of Object.entries(xml)) {\n            switch (childName) {\n                case 'gml:Point':\n                    points.push(parsePoint(childXML, options, childContext));\n                    break;\n                case 'gml:pos':\n                    points.push(parsePos(childXML, options, childContext));\n                    break;\n                default:\n                    continue;\n            }\n        }\n    }\n    if (points.length === 0) {\n        throw new Error(`${xml.name} must have > 0 points`);\n    }\n    return points;\n}\nexport function parseCurveSegments(xml, options, context) {\n    const points = [];\n    for (const [childName, childXML] of Object.entries(xml)) {\n        switch (childName) {\n            case 'gml:LineStringSegment':\n                const points2 = parseLinearRingOrLineString(childXML, options, context);\n                // remove overlapping\n                const end = points[points.length - 1];\n                const start = points2[0];\n                if (end && start && deepStrictEqual(end, start)) {\n                    points2.shift();\n                }\n                points.push(...points2);\n                break;\n            default:\n                continue;\n        }\n    }\n    if (points.length === 0) {\n        throw new Error('gml:Curve > gml:segments must have > 0 points');\n    }\n    return points;\n}\nexport function parseRing(xml, options, context) {\n    const childContext = createChildContext(xml, options, context);\n    const points = [];\n    for (const [childName, childXML] of Object.entries(xml)) {\n        switch (childName) {\n            case 'gml:curveMember':\n                let points2;\n                const lineString = findIn(childXML, 'gml:LineString');\n                if (lineString) {\n                    points2 = parseLinearRingOrLineString(lineString, options, childContext);\n                }\n                else {\n                    const segments = findIn(childXML, 'gml:Curve', 'gml:segments');\n                    if (!segments) {\n                        throw new Error(`invalid ${childName} element`);\n                    }\n                    points2 = parseCurveSegments(segments, options, childContext);\n                }\n                // remove overlapping\n                const end = points[points.length - 1];\n                const start = points2[0];\n                if (end && start && deepStrictEqual(end, start)) {\n                    points2.shift();\n                }\n                points.push(...points2);\n                break;\n        }\n    }\n    if (points.length < 4) {\n        throw new Error(`${xml.name} must have >= 4 points`);\n    }\n    return points;\n}\nexport function parseExteriorOrInterior(xml, options, context) {\n    const linearRing = findIn(xml, 'gml:LinearRing');\n    if (linearRing) {\n        return parseLinearRingOrLineString(linearRing, options, context);\n    }\n    const ring = findIn(xml, 'gml:Ring');\n    if (!ring) {\n        throw new Error(`invalid ${xml.name} element`);\n    }\n    return parseRing(ring, options, context);\n}\nexport function parsePolygonOrRectangle(xml, options, context) {\n    // or PolygonPatch\n    const childContext = createChildContext(xml, options, context);\n    const exterior = findIn(xml, 'gml:exterior');\n    if (!exterior) {\n        throw new Error(`invalid ${xml.name} element`);\n    }\n    const pointLists = [parseExteriorOrInterior(exterior, options, childContext)];\n    for (const [childName, childXML] of Object.entries(xml)) {\n        switch (childName) {\n            case 'gml:interior':\n                pointLists.push(parseExteriorOrInterior(childXML, options, childContext));\n                break;\n        }\n    }\n    return pointLists;\n}\nexport function parseSurface(xml, options, context) {\n    const childContext = createChildContext(xml, options, context);\n    const patches = findIn(xml, 'gml:patches');\n    if (!patches) {\n        throw new Error(`invalid ${xml.name} element`);\n    }\n    const polygons = [];\n    for (const [childName, childXML] of Object.entries(xml)) {\n        switch (childName) {\n            case 'gml:PolygonPatch':\n            case 'gml:Rectangle':\n                polygons.push(parsePolygonOrRectangle(childXML, options, childContext));\n                break;\n            default:\n                continue;\n        }\n    }\n    if (polygons.length === 0) {\n        throw new Error(`${xml.name} must have > 0 polygons`);\n    }\n    return polygons;\n}\nexport function parseCompositeSurface(xml, options, context) {\n    const childContext = createChildContext(xml, options, context);\n    const polygons = [];\n    for (const [childName, childXML] of Object.entries(xml)) {\n        switch (childName) {\n            case 'gml:surfaceMember':\n            case 'gml:surfaceMembers':\n                const [c2Name, c2Xml] = getFirstKeyValue(childXML);\n                switch (c2Name) {\n                    case 'gml:Surface':\n                        polygons.push(...parseSurface(c2Xml, options, childContext));\n                        break;\n                    case 'gml:Polygon':\n                        polygons.push(parsePolygonOrRectangle(c2Xml, options, childContext));\n                        break;\n                }\n                break;\n        }\n    }\n    if (polygons.length === 0) {\n        throw new Error(`${xml.name} must have > 0 polygons`);\n    }\n    return polygons;\n}\nexport function parseMultiSurface(xml, options, context) {\n    let el = xml;\n    const surfaceMembers = findIn(xml, 'gml:LinearRing');\n    if (surfaceMembers) {\n        el = surfaceMembers;\n    }\n    const polygons = [];\n    for (const [childName, childXML] of Object.entries(el)) {\n        switch (childName) {\n            case 'gml:Surface':\n                const polygons2 = parseSurface(childXML, options, context);\n                polygons.push(...polygons2);\n                break;\n            case 'gml:surfaceMember':\n                const polygons3 = parseSurfaceMember(childXML, options, context);\n                polygons.push(...polygons3);\n                break;\n            case 'gml:surfaceMembers':\n                const polygonXML = findIn(childXML, 'gml:Polygon');\n                for (const surfaceMemberXML of polygonXML) {\n                    const polygons3 = parseSurfaceMember(surfaceMemberXML, options, context);\n                    polygons.push(...polygons3);\n                }\n                break;\n        }\n    }\n    if (polygons.length === 0) {\n        throw new Error(`${xml.name} must have > 0 polygons`);\n    }\n    return polygons;\n}\nfunction parseSurfaceMember(xml, options, context) {\n    const [childName, childXml] = getFirstKeyValue(xml);\n    switch (childName) {\n        case 'gml:CompositeSurface':\n            return parseCompositeSurface(childXml, options, context);\n        case 'gml:Surface':\n            return parseSurface(childXml, options, context);\n        case 'gml:Polygon':\n            return [parsePolygonOrRectangle(childXml, options, context)];\n    }\n    throw new Error(`${childName} must have polygons`);\n}\n// Helpers\nfunction textOf(el) {\n    if (typeof el !== 'string') {\n        throw new Error('expected string');\n    }\n    return el;\n}\nfunction findIn(root, ...tags) {\n    let el = root;\n    for (const tag of tags) {\n        const child = el[tag];\n        if (!child) {\n            return null;\n        }\n        el = child;\n    }\n    return el;\n}\n/** @returns the first [key, value] pair in an object, or ['', null] if empty object */\nfunction getFirstKeyValue(object) {\n    if (object && typeof object === 'object') {\n        for (const [key, value] of Object.entries(object)) {\n            return [key, value];\n        }\n    }\n    return ['', null];\n}\n/** A bit heavyweight for just tracking dimension? */\nfunction createChildContext(xml, options, context) {\n    const srsDimensionAttribute = xml.attributes && xml.attributes.srsDimension;\n    if (srsDimensionAttribute) {\n        const srsDimension = parseInt(srsDimensionAttribute);\n        if (Number.isNaN(srsDimension) || srsDimension <= 0) {\n            throw new Error(`invalid srsDimension attribute value \"${srsDimensionAttribute}\", expected a positive integer`);\n        }\n        const childContext = Object.create(context);\n        childContext.srsDimension = srsDimension;\n        return childContext;\n    }\n    return context;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}