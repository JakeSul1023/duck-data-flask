{"ast":null,"code":"/* eslint-disable camelcase, max-statements */\nimport { copyPaddedStringToDataView, copyPaddedArrayBufferToDataView } from '@loaders.gl/loader-utils';\n// import type {GLB} from '../types/glb-types';\nconst MAGIC_glTF = 0x46546c67; // glTF in ASCII\nconst MAGIC_JSON = 0x4e4f534a; // JSON in ASCII\nconst MAGIC_BIN = 0x004e4942; // BIN\\0 in ASCII\nconst LE = true; // Binary GLTF is little endian.\n/**\n * Encode the full GLB buffer with header etc\n *\n * @param glb\n * @param dataView - if `null`, does not encode but just calculates length\n * @param byteOffset\n * @param options\n * @returns\n *\n * @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification\n * @todo type GLB argument\n */\nexport function encodeGLBSync(glb, dataView, byteOffset = 0, options = {}) {\n  const {\n    magic = MAGIC_glTF,\n    version = 2,\n    json = {},\n    binary\n  } = glb;\n  const byteOffsetStart = byteOffset;\n  // Write GLB Header\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, magic, LE); // Magic number (the ASCII string 'glTF').\n    dataView.setUint32(byteOffset + 4, version, LE); // Version 2 of binary glTF container format uint32\n    dataView.setUint32(byteOffset + 8, 0, LE); // Total byte length of generated file (uint32), will be set last\n  }\n  const byteOffsetFileLength = byteOffset + 8;\n  byteOffset += 12; // GLB_FILE_HEADER_SIZE\n  // Write the JSON chunk header\n  const byteOffsetJsonHeader = byteOffset;\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, 0, LE); // Byte length of json chunk (will be written later)\n    dataView.setUint32(byteOffset + 4, MAGIC_JSON, LE); // Chunk type\n  }\n  byteOffset += 8; // GLB_CHUNK_HEADER_SIZE\n  // Write the JSON chunk\n  const jsonString = JSON.stringify(json);\n  byteOffset = copyPaddedStringToDataView(dataView, byteOffset, jsonString, 4);\n  // Now we know the JSON chunk length so we can write it.\n  if (dataView) {\n    const jsonByteLength = byteOffset - byteOffsetJsonHeader - 8; // GLB_CHUNK_HEADER_SIZE\n    dataView.setUint32(byteOffsetJsonHeader + 0, jsonByteLength, LE); // Byte length of json chunk (uint32)\n  }\n  // Write the BIN chunk if present. The BIN chunk is optional.\n  if (binary) {\n    const byteOffsetBinHeader = byteOffset;\n    // Write the BIN chunk header\n    if (dataView) {\n      dataView.setUint32(byteOffset + 0, 0, LE); // Byte length BIN (uint32)\n      dataView.setUint32(byteOffset + 4, MAGIC_BIN, LE); // Chunk type\n    }\n    byteOffset += 8; // GLB_CHUNK_HEADER_SIZE\n    byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, binary, 4);\n    // Now we know the BIN chunk length so we can write it.\n    if (dataView) {\n      const binByteLength = byteOffset - byteOffsetBinHeader - 8; // GLB_CHUNK_HEADER_SIZE\n      dataView.setUint32(byteOffsetBinHeader + 0, binByteLength, LE); // Byte length BIN (uint32)\n    }\n  }\n  // Now we know the glb file length so we can write it.\n  if (dataView) {\n    const fileByteLength = byteOffset - byteOffsetStart;\n    dataView.setUint32(byteOffsetFileLength, fileByteLength, LE); // Total byte length of generated file (uint32)\n  }\n  return byteOffset;\n}","map":{"version":3,"names":["copyPaddedStringToDataView","copyPaddedArrayBufferToDataView","MAGIC_glTF","MAGIC_JSON","MAGIC_BIN","LE","encodeGLBSync","glb","dataView","byteOffset","options","magic","version","json","binary","byteOffsetStart","setUint32","byteOffsetFileLength","byteOffsetJsonHeader","jsonString","JSON","stringify","jsonByteLength","byteOffsetBinHeader","binByteLength","fileByteLength"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/gltf/dist/lib/encoders/encode-glb.js"],"sourcesContent":["/* eslint-disable camelcase, max-statements */\nimport { copyPaddedStringToDataView, copyPaddedArrayBufferToDataView } from '@loaders.gl/loader-utils';\n// import type {GLB} from '../types/glb-types';\nconst MAGIC_glTF = 0x46546c67; // glTF in ASCII\nconst MAGIC_JSON = 0x4e4f534a; // JSON in ASCII\nconst MAGIC_BIN = 0x004e4942; // BIN\\0 in ASCII\nconst LE = true; // Binary GLTF is little endian.\n/**\n * Encode the full GLB buffer with header etc\n *\n * @param glb\n * @param dataView - if `null`, does not encode but just calculates length\n * @param byteOffset\n * @param options\n * @returns\n *\n * @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification\n * @todo type GLB argument\n */\nexport function encodeGLBSync(glb, dataView, byteOffset = 0, options = {}) {\n    const { magic = MAGIC_glTF, version = 2, json = {}, binary } = glb;\n    const byteOffsetStart = byteOffset;\n    // Write GLB Header\n    if (dataView) {\n        dataView.setUint32(byteOffset + 0, magic, LE); // Magic number (the ASCII string 'glTF').\n        dataView.setUint32(byteOffset + 4, version, LE); // Version 2 of binary glTF container format uint32\n        dataView.setUint32(byteOffset + 8, 0, LE); // Total byte length of generated file (uint32), will be set last\n    }\n    const byteOffsetFileLength = byteOffset + 8;\n    byteOffset += 12; // GLB_FILE_HEADER_SIZE\n    // Write the JSON chunk header\n    const byteOffsetJsonHeader = byteOffset;\n    if (dataView) {\n        dataView.setUint32(byteOffset + 0, 0, LE); // Byte length of json chunk (will be written later)\n        dataView.setUint32(byteOffset + 4, MAGIC_JSON, LE); // Chunk type\n    }\n    byteOffset += 8; // GLB_CHUNK_HEADER_SIZE\n    // Write the JSON chunk\n    const jsonString = JSON.stringify(json);\n    byteOffset = copyPaddedStringToDataView(dataView, byteOffset, jsonString, 4);\n    // Now we know the JSON chunk length so we can write it.\n    if (dataView) {\n        const jsonByteLength = byteOffset - byteOffsetJsonHeader - 8; // GLB_CHUNK_HEADER_SIZE\n        dataView.setUint32(byteOffsetJsonHeader + 0, jsonByteLength, LE); // Byte length of json chunk (uint32)\n    }\n    // Write the BIN chunk if present. The BIN chunk is optional.\n    if (binary) {\n        const byteOffsetBinHeader = byteOffset;\n        // Write the BIN chunk header\n        if (dataView) {\n            dataView.setUint32(byteOffset + 0, 0, LE); // Byte length BIN (uint32)\n            dataView.setUint32(byteOffset + 4, MAGIC_BIN, LE); // Chunk type\n        }\n        byteOffset += 8; // GLB_CHUNK_HEADER_SIZE\n        byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, binary, 4);\n        // Now we know the BIN chunk length so we can write it.\n        if (dataView) {\n            const binByteLength = byteOffset - byteOffsetBinHeader - 8; // GLB_CHUNK_HEADER_SIZE\n            dataView.setUint32(byteOffsetBinHeader + 0, binByteLength, LE); // Byte length BIN (uint32)\n        }\n    }\n    // Now we know the glb file length so we can write it.\n    if (dataView) {\n        const fileByteLength = byteOffset - byteOffsetStart;\n        dataView.setUint32(byteOffsetFileLength, fileByteLength, LE); // Total byte length of generated file (uint32)\n    }\n    return byteOffset;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}