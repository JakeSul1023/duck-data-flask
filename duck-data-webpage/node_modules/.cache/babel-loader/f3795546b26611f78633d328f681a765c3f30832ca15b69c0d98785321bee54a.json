{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\nimport { createProtoFeature } from \"./proto-feature.js\";\nimport { simplifyPath } from \"./simplify-path.js\";\n/**\n * converts a GeoJSON feature into an intermediate projected JSON vector format\n * with simplification data\n */\nexport function convertFeaturesToProtoFeature(data, options) {\n  const protoFeatures = [];\n  switch (data.type) {\n    case 'FeatureCollection':\n      let i = 0;\n      for (const feature of data.features) {\n        protoFeatures.push(convertFeature(feature, options, i++));\n      }\n      break;\n    case 'Feature':\n      protoFeatures.push(convertFeature(data, options));\n      break;\n    default:\n      // single geometry or a geometry collection\n      protoFeatures.push(convertFeature({\n        geometry: data\n      }, options));\n  }\n  return protoFeatures;\n}\n/**\n * converts a GeoJSON feature into an intermediate projected JSON vector format\n * with simplification data\n */\nfunction convertFeature(geojson, options, index) {\n  // GeoJSON geometries can be null, but no vector tile will include them.\n  if (!geojson.geometry) {\n    return;\n  }\n  const coords = geojson.geometry.coordinates;\n  const type = geojson.geometry.type;\n  const tolerance = Math.pow(options.tolerance / ((1 << options.maxZoom) * options.extent), 2);\n  let geometry = [];\n  let id = geojson.id;\n  if (options.promoteId) {\n    id = geojson.properties[options.promoteId];\n  } else if (options.generateId) {\n    id = index || 0;\n  }\n  switch (type) {\n    case 'Point':\n      convertPoint(coords, geometry);\n      break;\n    case 'MultiPoint':\n      for (const p of coords) {\n        convertPoint(p, geometry);\n      }\n      break;\n    case 'LineString':\n      convertLine(coords, geometry, tolerance, false);\n      break;\n    case 'MultiLineString':\n      if (options.lineMetrics) {\n        // explode into linestrings to be able to track metrics\n        for (const line of coords) {\n          geometry = [];\n          convertLine(line, geometry, tolerance, false);\n          features.push(createProtoFeature(id, 'LineString', geometry, geojson.properties));\n        }\n        return;\n        convertLines(coords, geometry, tolerance, false);\n      }\n      break;\n    case 'Polygon':\n      convertLines(coords, geometry, tolerance, true);\n      break;\n    case 'MultiPolygon':\n      for (const polygon of coords) {\n        const newPolygon = [];\n        convertLines(polygon, newPolygon, tolerance, true);\n        geometry.push(newPolygon);\n      }\n      break;\n    case 'GeometryCollection':\n      for (const singleGeometry of geojson.geometry.geometries) {\n        convertFeature(features, {\n          id,\n          geometry: singleGeometry,\n          properties: geojson.properties\n        }, options, index);\n      }\n      break;\n    default:\n      throw new Error('Input data is not a valid GeoJSON object.');\n  }\n  return createProtoFeature(id, type, geometry, geojson.properties);\n}\nfunction convertPoint(coords, out) {\n  out.push(projectX(coords[0]), projectY(coords[1]), 0);\n}\nfunction convertLine(ring, out, tolerance, isPolygon) {\n  let x0, y0;\n  let size = 0;\n  for (let j = 0; j < ring.length; j++) {\n    const x = projectX(ring[j][0]);\n    const y = projectY(ring[j][1]);\n    out.push(x, y, 0);\n    if (j > 0) {\n      if (isPolygon) {\n        size += (x0 * y - x * y0) / 2; // area\n      } else {\n        size += Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2)); // length\n      }\n    }\n    x0 = x;\n    y0 = y;\n  }\n  const last = out.length - 3;\n  out[2] = 1;\n  simplifyPath(out, 0, last, tolerance);\n  out[last + 2] = 1;\n  out.size = Math.abs(size);\n  out.start = 0;\n  out.end = out.size;\n}\nfunction convertLines(rings, out, tolerance, isPolygon) {\n  for (let i = 0; i < rings.length; i++) {\n    const geom = [];\n    convertLine(rings[i], geom, tolerance, isPolygon);\n    out.push(geom);\n  }\n}\nfunction projectX(x) {\n  return x / 360 + 0.5;\n}\nfunction projectY(y) {\n  const sin = Math.sin(y * Math.PI / 180);\n  const y2 = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n  return y2 < 0 ? 0 : y2 > 1 ? 1 : y2;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}