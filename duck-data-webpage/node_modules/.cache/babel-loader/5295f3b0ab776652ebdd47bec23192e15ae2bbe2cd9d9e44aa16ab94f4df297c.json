{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Buffer, ComputePipeline, UniformStore, log, getTypedArrayFromDataType } from '@luma.gl/core';\nimport { ShaderAssembler, getShaderLayoutFromWGSL } from '@luma.gl/shadertools';\nimport { isNumericArray } from '@math.gl/types';\nimport { ShaderInputs } from \"../shader-inputs.js\";\nimport { PipelineFactory } from \"../factories/pipeline-factory.js\";\nimport { ShaderFactory } from \"../factories/shader-factory.js\";\nimport { uid } from \"../utils/uid.js\";\n// import {getDebugTableForShaderLayout} from '../debug/debug-shader-layout';\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n/**\n * v9 Model API\n * A model\n * - automatically reuses pipelines (programs) when possible\n * - automatically rebuilds pipelines if necessary to accommodate changed settings\n * shadertools integration\n * - accepts modules and performs shader transpilation\n */\nexport class Computation {\n  static defaultProps = (() => ({\n    ...ComputePipeline.defaultProps,\n    id: 'unnamed',\n    handle: undefined,\n    userData: {},\n    source: '',\n    modules: [],\n    defines: {},\n    bindings: undefined,\n    shaderInputs: undefined,\n    pipelineFactory: undefined,\n    shaderFactory: undefined,\n    shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),\n    debugShaders: undefined\n  }))();\n  device;\n  id;\n  pipelineFactory;\n  shaderFactory;\n  userData = {};\n  /** Bindings (textures, samplers, uniform buffers) */\n  bindings = {};\n  /** The underlying GPU pipeline. */\n  pipeline;\n  /** Assembled compute shader source */\n  source;\n  /** the underlying compiled compute shader */\n  // @ts-ignore Set in function called from constructor\n  shader;\n  /** ShaderInputs instance */\n  shaderInputs;\n  // @ts-ignore Set in function called from constructor\n  _uniformStore;\n  _pipelineNeedsUpdate = 'newly created';\n  _getModuleUniforms;\n  props;\n  _destroyed = false;\n  constructor(device, props) {\n    if (device.type !== 'webgpu') {\n      throw new Error('Computation is only supported in WebGPU');\n    }\n    this.props = {\n      ...Computation.defaultProps,\n      ...props\n    };\n    props = this.props;\n    this.id = props.id || uid('model');\n    this.device = device;\n    Object.assign(this.userData, props.userData);\n    // Setup shader module inputs\n    const moduleMap = Object.fromEntries(this.props.modules?.map(module => [module.name, module]) || []);\n    // @ts-ignore TODO - fix up typing?\n    this.shaderInputs = props.shaderInputs || new ShaderInputs(moduleMap);\n    this.setShaderInputs(this.shaderInputs);\n    // Support WGSL shader layout introspection\n    // TODO - Don't modify props!!\n    this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.props.source);\n    // Setup shader assembler\n    const platformInfo = getPlatformInfo(device);\n    // Extract modules from shader inputs if not supplied\n    const modules = (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];\n    this.pipelineFactory = props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);\n    this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);\n    const {\n      source,\n      getUniforms\n    } = this.props.shaderAssembler.assembleWGSLShader({\n      platformInfo,\n      ...this.props,\n      modules\n    });\n    this.source = source;\n    // @ts-ignore\n    this._getModuleUniforms = getUniforms;\n    // Create the pipeline\n    // @note order is important\n    this.pipeline = this._updatePipeline();\n    // Apply any dynamic settings that will not trigger pipeline change\n    if (props.bindings) {\n      this.setBindings(props.bindings);\n    }\n    // Catch any access to non-standard props\n    Object.seal(this);\n  }\n  destroy() {\n    if (this._destroyed) return;\n    this.pipelineFactory.release(this.pipeline);\n    this.shaderFactory.release(this.shader);\n    this._uniformStore.destroy();\n    this._destroyed = true;\n  }\n  // Draw call\n  predraw() {\n    // Update uniform buffers if needed\n    this.updateShaderInputs();\n  }\n  dispatch(computePass, x, y, z) {\n    try {\n      this._logDrawCallStart();\n      // Check if the pipeline is invalidated\n      // TODO - this is likely the worst place to do this from performance perspective. Perhaps add a predraw()?\n      this.pipeline = this._updatePipeline();\n      // Set pipeline state, we may be sharing a pipeline so we need to set all state on every draw\n      // Any caching needs to be done inside the pipeline functions\n      this.pipeline.setBindings(this.bindings);\n      computePass.setPipeline(this.pipeline);\n      // @ts-expect-error\n      computePass.setBindings([]);\n      computePass.dispatch(x, y, z);\n    } finally {\n      this._logDrawCallEnd();\n    }\n  }\n  // Update fixed fields (can trigger pipeline rebuild)\n  // Update dynamic fields\n  /**\n   * Updates the vertex count (used in draw calls)\n   * @note Any attributes with stepMode=vertex need to be at least this big\n   */\n  setVertexCount(vertexCount) {\n    // this.vertexCount = vertexCount;\n  }\n  /**\n   * Updates the instance count (used in draw calls)\n   * @note Any attributes with stepMode=instance need to be at least this big\n   */\n  setInstanceCount(instanceCount) {\n    // this.instanceCount = instanceCount;\n  }\n  setShaderInputs(shaderInputs) {\n    this.shaderInputs = shaderInputs;\n    this._uniformStore = new UniformStore(this.shaderInputs.modules);\n    // Create uniform buffer bindings for all modules\n    for (const moduleName of Object.keys(this.shaderInputs.modules)) {\n      const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);\n      this.bindings[`${moduleName}Uniforms`] = uniformBuffer;\n    }\n  }\n  /**\n   * Updates shader module settings (which results in uniforms being set)\n   */\n  setShaderModuleProps(props) {\n    const uniforms = this._getModuleUniforms(props);\n    // Extract textures & framebuffers set by the modules\n    // TODO better way to extract bindings\n    const keys = Object.keys(uniforms).filter(k => {\n      const uniform = uniforms[k];\n      return !isNumericArray(uniform) && typeof uniform !== 'number' && typeof uniform !== 'boolean';\n    });\n    const bindings = {};\n    for (const k of keys) {\n      bindings[k] = uniforms[k];\n      delete uniforms[k];\n    }\n  }\n  updateShaderInputs() {\n    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());\n  }\n  /**\n   * Sets bindings (textures, samplers, uniform buffers)\n   */\n  setBindings(bindings) {\n    Object.assign(this.bindings, bindings);\n  }\n  _setPipelineNeedsUpdate(reason) {\n    this._pipelineNeedsUpdate = this._pipelineNeedsUpdate || reason;\n  }\n  _updatePipeline() {\n    if (this._pipelineNeedsUpdate) {\n      let prevShader = null;\n      if (this.pipeline) {\n        log.log(1, `Model ${this.id}: Recreating pipeline because \"${this._pipelineNeedsUpdate}\".`)();\n        prevShader = this.shader;\n      }\n      this._pipelineNeedsUpdate = false;\n      this.shader = this.shaderFactory.createShader({\n        id: `${this.id}-fragment`,\n        stage: 'compute',\n        source: this.source,\n        debugShaders: this.props.debugShaders\n      });\n      this.pipeline = this.pipelineFactory.createComputePipeline({\n        ...this.props,\n        shader: this.shader\n      });\n      if (prevShader) {\n        this.shaderFactory.release(prevShader);\n      }\n    }\n    return this.pipeline;\n  }\n  /** Throttle draw call logging */\n  _lastLogTime = 0;\n  _logOpen = false;\n  _logDrawCallStart() {\n    // IF level is 4 or higher, log every frame.\n    const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {\n      return;\n    }\n    this._lastLogTime = Date.now();\n    this._logOpen = true;\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {\n      collapsed: log.level <= 2\n    })();\n  }\n  _logDrawCallEnd() {\n    if (this._logOpen) {\n      // const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.props.shaderLayout, this.id);\n      // log.table(logLevel, attributeTable)();\n      // log.table(logLevel, uniformTable)();\n      // log.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();\n      const uniformTable = this.shaderInputs.getDebugTable();\n      log.table(LOG_DRAW_PRIORITY, uniformTable)();\n      log.groupEnd(LOG_DRAW_PRIORITY)();\n      this._logOpen = false;\n    }\n  }\n  _drawCount = 0;\n  // TODO - fix typing of luma data types\n  _getBufferOrConstantValues(attribute, dataType) {\n    const TypedArrayConstructor = getTypedArrayFromDataType(dataType);\n    const typedArray = attribute instanceof Buffer ? new TypedArrayConstructor(attribute.debugData) : attribute;\n    return typedArray.toString();\n  }\n}\n/** Create a shadertools platform info from the Device */\nexport function getPlatformInfo(device) {\n  return {\n    type: device.type,\n    shaderLanguage: device.info.shadingLanguage,\n    shaderLanguageVersion: device.info.shadingLanguageVersion,\n    gpu: device.info.gpu,\n    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API\n    features: device.features\n  };\n}\n//# sourceMappingURL=computation.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}