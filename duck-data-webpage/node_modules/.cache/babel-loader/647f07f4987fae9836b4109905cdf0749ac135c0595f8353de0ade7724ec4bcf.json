{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Gets fragment shader source for a shader pass sub pass\n * @param options\n * @returns\n */\nexport function getFragmentShaderForRenderPass(options) {\n  const {\n    shaderPass,\n    action,\n    shadingLanguage\n  } = options;\n  switch (action) {\n    case 'filter':\n      const filterFunc = `${shaderPass.name}_filterColor_ext`;\n      return shadingLanguage === 'wgsl' ? getFilterShaderWGSL(filterFunc) : getFilterShaderGLSL(filterFunc);\n    case 'sample':\n      const samplerFunc = `${shaderPass.name}_sampleColor`;\n      return shadingLanguage === 'wgsl' ? getSamplerShaderWGSL(samplerFunc) : getSamplerShaderGLSL(samplerFunc);\n    default:\n      throw new Error(`${shaderPass.name} no fragment shader generated for shader pass`);\n  }\n}\n/** Get a filtering WGSL fragment shader */\nfunction getFilterShaderWGSL(func) {\n  return /* wgsl */`\\\n// Binding 0:1 is reserved for shader passes\n@group(0) @binding(0) var<uniform> brightnessContrast : brightnessContrastUniforms;\n@group(0) @binding(1) var texture: texture_2d<f32>;\n@group(0) @binding(2) var sampler: sampler;\n\nstruct FragmentInputs = {\n  @location(0) fragUV: vec2f,\n  @location(1) fragPosition: vec4f,\n  @location(2) fragCoordinate: vec4f\n};\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4f {\n  let texSize = textureDimensions(texture, 0);\n  var fragColor = textureSample(texture, sampler, fragUV);\n  fragColor = ${func}(gl_FragColor, texSize, texCoord);\n  return fragColor;\n}\n`;\n}\n/** Get a sampling WGSL fragment shader */\nfunction getSamplerShaderWGSL(func) {\n  return /* wgsl */`\\\n// Binding 0:1 is reserved for shader passes\n@group(0) @binding(0) var<uniform> brightnessContrast : brightnessContrastUniforms;\n@group(0) @binding(1) var texture: texture_2d<f32>;\n@group(0) @binding(2) var sampler: sampler;\n\nstruct FragmentInputs = {\n  @location(0) fragUV: vec2f,\n  @location(1) fragPosition: vec4f,\n  @location(2) fragCoordinate: vec4f\n};\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4f {\n  let texSize = textureDimensions(texture, 0);\n  var fragColor = textureSample(texture, sampler, fragUV);\n  fragColor = ${func}(gl_FragColor, texSize, texCoord);\n  return fragColor;\n}\n`;\n}\n/** Get a filtering GLSL fragment shader */\nfunction getFilterShaderGLSL(func) {\n  return /* glsl */`\\\n#version 300 es\n\nuniform sampler2D sourceTexture;\n\nin vec2 position;\nin vec2 coordinate;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n  ivec2 iTexSize = textureSize(sourceTexture, 0);\n  vec2 texSize = vec2(float(iTexSize.x), float(iTexSize.y));\n\n  fragColor = texture(sourceTexture, texCoord);\n  fragColor = ${func}(fragColor, texSize, texCoord);\n}\n`;\n}\n/** Get a sampling GLSL fragment shader */\nfunction getSamplerShaderGLSL(func) {\n  return /* glsl */`\\\n#version 300 es\n\nuniform sampler2D sourceTexture;\n\nin vec2 position;\nin vec2 coordinate;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n  ivec2 iTexSize = textureSize(sourceTexture, 0);\n  vec2 texSize = vec2(float(iTexSize.x), float(iTexSize.y));\n\n  fragColor = ${func}(sourceTexture, texSize, texCoord);\n}\n`;\n}","map":{"version":3,"names":["getFragmentShaderForRenderPass","options","shaderPass","action","shadingLanguage","filterFunc","name","getFilterShaderWGSL","getFilterShaderGLSL","samplerFunc","getSamplerShaderWGSL","getSamplerShaderGLSL","Error","func"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\engine\\src\\passes\\get-fragment-shader.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderPass} from '@luma.gl/shadertools';\n\n/**\n * Gets fragment shader source for a shader pass sub pass\n * @param options\n * @returns\n */\nexport function getFragmentShaderForRenderPass(options: {\n  shaderPass: ShaderPass;\n  action: 'filter' | 'sample';\n  shadingLanguage: 'wgsl' | 'glsl';\n}): string {\n  const {shaderPass, action, shadingLanguage} = options;\n  switch (action) {\n    case 'filter':\n      const filterFunc = `${shaderPass.name}_filterColor_ext`;\n      return shadingLanguage === 'wgsl'\n        ? getFilterShaderWGSL(filterFunc)\n        : getFilterShaderGLSL(filterFunc);\n\n    case 'sample':\n      const samplerFunc = `${shaderPass.name}_sampleColor`;\n      return shadingLanguage === 'wgsl'\n        ? getSamplerShaderWGSL(samplerFunc)\n        : getSamplerShaderGLSL(samplerFunc);\n\n    default:\n      throw new Error(`${shaderPass.name} no fragment shader generated for shader pass`);\n  }\n}\n\n/** Get a filtering WGSL fragment shader */\nfunction getFilterShaderWGSL(func: string) {\n  return /* wgsl */ `\\\n// Binding 0:1 is reserved for shader passes\n@group(0) @binding(0) var<uniform> brightnessContrast : brightnessContrastUniforms;\n@group(0) @binding(1) var texture: texture_2d<f32>;\n@group(0) @binding(2) var sampler: sampler;\n\nstruct FragmentInputs = {\n  @location(0) fragUV: vec2f,\n  @location(1) fragPosition: vec4f,\n  @location(2) fragCoordinate: vec4f\n};\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4f {\n  let texSize = textureDimensions(texture, 0);\n  var fragColor = textureSample(texture, sampler, fragUV);\n  fragColor = ${func}(gl_FragColor, texSize, texCoord);\n  return fragColor;\n}\n`;\n}\n\n/** Get a sampling WGSL fragment shader */\nfunction getSamplerShaderWGSL(func: string) {\n  return /* wgsl */ `\\\n// Binding 0:1 is reserved for shader passes\n@group(0) @binding(0) var<uniform> brightnessContrast : brightnessContrastUniforms;\n@group(0) @binding(1) var texture: texture_2d<f32>;\n@group(0) @binding(2) var sampler: sampler;\n\nstruct FragmentInputs = {\n  @location(0) fragUV: vec2f,\n  @location(1) fragPosition: vec4f,\n  @location(2) fragCoordinate: vec4f\n};\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4f {\n  let texSize = textureDimensions(texture, 0);\n  var fragColor = textureSample(texture, sampler, fragUV);\n  fragColor = ${func}(gl_FragColor, texSize, texCoord);\n  return fragColor;\n}\n`;\n}\n\n/** Get a filtering GLSL fragment shader */\nfunction getFilterShaderGLSL(func: string) {\n  return /* glsl */ `\\\n#version 300 es\n\nuniform sampler2D sourceTexture;\n\nin vec2 position;\nin vec2 coordinate;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n  ivec2 iTexSize = textureSize(sourceTexture, 0);\n  vec2 texSize = vec2(float(iTexSize.x), float(iTexSize.y));\n\n  fragColor = texture(sourceTexture, texCoord);\n  fragColor = ${func}(fragColor, texSize, texCoord);\n}\n`;\n}\n\n/** Get a sampling GLSL fragment shader */\nfunction getSamplerShaderGLSL(func: string) {\n  return /* glsl */ `\\\n#version 300 es\n\nuniform sampler2D sourceTexture;\n\nin vec2 position;\nin vec2 coordinate;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n  ivec2 iTexSize = textureSize(sourceTexture, 0);\n  vec2 texSize = vec2(float(iTexSize.x), float(iTexSize.y));\n\n  fragColor = ${func}(sourceTexture, texSize, texCoord);\n}\n`;\n}\n"],"mappings":"AAAA;AACA;AACA;AAIA;;;;;AAKA,OAAM,SAAUA,8BAA8BA,CAACC,OAI9C;EACC,MAAM;IAACC,UAAU;IAAEC,MAAM;IAAEC;EAAe,CAAC,GAAGH,OAAO;EACrD,QAAQE,MAAM;IACZ,KAAK,QAAQ;MACX,MAAME,UAAU,GAAG,GAAGH,UAAU,CAACI,IAAI,kBAAkB;MACvD,OAAOF,eAAe,KAAK,MAAM,GAC7BG,mBAAmB,CAACF,UAAU,CAAC,GAC/BG,mBAAmB,CAACH,UAAU,CAAC;IAErC,KAAK,QAAQ;MACX,MAAMI,WAAW,GAAG,GAAGP,UAAU,CAACI,IAAI,cAAc;MACpD,OAAOF,eAAe,KAAK,MAAM,GAC7BM,oBAAoB,CAACD,WAAW,CAAC,GACjCE,oBAAoB,CAACF,WAAW,CAAC;IAEvC;MACE,MAAM,IAAIG,KAAK,CAAC,GAAGV,UAAU,CAACI,IAAI,+CAA+C,CAAC;EACtF;AACF;AAEA;AACA,SAASC,mBAAmBA,CAACM,IAAY;EACvC,OAAO,UAAW;;;;;;;;;;;;;;;;gBAgBJA,IAAI;;;CAGnB;AACD;AAEA;AACA,SAASH,oBAAoBA,CAACG,IAAY;EACxC,OAAO,UAAW;;;;;;;;;;;;;;;;gBAgBJA,IAAI;;;CAGnB;AACD;AAEA;AACA,SAASL,mBAAmBA,CAACK,IAAY;EACvC,OAAO,UAAW;;;;;;;;;;;;;;;;;gBAiBJA,IAAI;;CAEnB;AACD;AAEA;AACA,SAASF,oBAAoBA,CAACE,IAAY;EACxC,OAAO,UAAW;;;;;;;;;;;;;;;;gBAgBJA,IAAI;;CAEnB;AACD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}