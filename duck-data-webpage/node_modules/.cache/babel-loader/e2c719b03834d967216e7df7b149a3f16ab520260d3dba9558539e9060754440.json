{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport log from \"../../utils/log.js\";\nconst NO_PICKED_OBJECT = {\n  pickedColor: null,\n  pickedObjectIndex: -1\n};\n/* eslint-disable max-depth, max-statements */\n/**\n * Pick at a specified pixel with a tolerance radius\n * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`\n */\nexport function getClosestObject({\n  pickedColors,\n  decodePickingColor,\n  deviceX,\n  deviceY,\n  deviceRadius,\n  deviceRect\n}) {\n  // Traverse all pixels in picking results and find the one closest to the supplied\n  // [deviceX, deviceY]\n  const {\n    x,\n    y,\n    width,\n    height\n  } = deviceRect;\n  let minSquareDistanceToCenter = deviceRadius * deviceRadius;\n  let closestPixelIndex = -1;\n  let i = 0;\n  for (let row = 0; row < height; row++) {\n    const dy = row + y - deviceY;\n    const dy2 = dy * dy;\n    if (dy2 > minSquareDistanceToCenter) {\n      // skip this row\n      i += 4 * width;\n    } else {\n      for (let col = 0; col < width; col++) {\n        // Decode picked layer from color\n        const pickedLayerIndex = pickedColors[i + 3] - 1;\n        if (pickedLayerIndex >= 0) {\n          const dx = col + x - deviceX;\n          const d2 = dx * dx + dy2;\n          if (d2 <= minSquareDistanceToCenter) {\n            minSquareDistanceToCenter = d2;\n            closestPixelIndex = i;\n          }\n        }\n        i += 4;\n      }\n    }\n  }\n  if (closestPixelIndex >= 0) {\n    // Decode picked object index from color\n    const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);\n    const pickedObject = decodePickingColor(pickedColor);\n    if (pickedObject) {\n      const dy = Math.floor(closestPixelIndex / 4 / width);\n      const dx = closestPixelIndex / 4 - dy * width;\n      return {\n        ...pickedObject,\n        pickedColor,\n        pickedX: x + dx,\n        pickedY: y + dy\n      };\n    }\n    log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n  }\n  return NO_PICKED_OBJECT;\n}\n/**\n * Examines a picking buffer for unique colors\n * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`\n */\nexport function getUniqueObjects({\n  pickedColors,\n  decodePickingColor\n}) {\n  const uniqueColors = new Map();\n  // Traverse all pixels in picking results and get unique colors\n  if (pickedColors) {\n    for (let i = 0; i < pickedColors.length; i += 4) {\n      // Decode picked layer from color\n      const pickedLayerIndex = pickedColors[i + 3] - 1;\n      if (pickedLayerIndex >= 0) {\n        const pickedColor = pickedColors.slice(i, i + 4);\n        const colorKey = pickedColor.join(',');\n        // eslint-disable-next-line\n        if (!uniqueColors.has(colorKey)) {\n          const pickedObject = decodePickingColor(pickedColor);\n          // eslint-disable-next-line\n          if (pickedObject) {\n            uniqueColors.set(colorKey, {\n              ...pickedObject,\n              color: pickedColor\n            });\n          } else {\n            log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n          }\n        }\n      }\n    }\n  }\n  return Array.from(uniqueColors.values());\n}","map":{"version":3,"names":["log","NO_PICKED_OBJECT","pickedColor","pickedObjectIndex","getClosestObject","pickedColors","decodePickingColor","deviceX","deviceY","deviceRadius","deviceRect","x","y","width","height","minSquareDistanceToCenter","closestPixelIndex","i","row","dy","dy2","col","pickedLayerIndex","dx","d2","slice","pickedObject","Math","floor","pickedX","pickedY","error","getUniqueObjects","uniqueColors","Map","length","colorKey","join","has","set","color","Array","from","values"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\lib\\picking\\query-object.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport log from '../../utils/log';\nimport type Layer from '../layer';\nimport type Viewport from '../../viewports/viewport';\nimport type {PickingColorDecoder} from '../../passes/pick-layers-pass';\n\nexport type PickedPixel = {\n  pickedColor: Uint8Array | null;\n  pickedLayer?: Layer;\n  pickedViewports?: Viewport[];\n  pickedX?: number;\n  pickedY?: number;\n  pickedObjectIndex: number;\n};\n\nconst NO_PICKED_OBJECT = {\n  pickedColor: null,\n  pickedObjectIndex: -1\n};\n\n/* eslint-disable max-depth, max-statements */\n/**\n * Pick at a specified pixel with a tolerance radius\n * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`\n */\nexport function getClosestObject({\n  pickedColors,\n  decodePickingColor,\n  deviceX,\n  deviceY,\n  deviceRadius,\n  deviceRect\n}: {\n  pickedColors: Uint8Array;\n  decodePickingColor: PickingColorDecoder;\n  deviceX: number;\n  deviceY: number;\n  deviceRadius: number;\n  deviceRect: {x: number; y: number; width: number; height: number};\n}): PickedPixel {\n  // Traverse all pixels in picking results and find the one closest to the supplied\n  // [deviceX, deviceY]\n  const {x, y, width, height} = deviceRect;\n  let minSquareDistanceToCenter = deviceRadius * deviceRadius;\n  let closestPixelIndex = -1;\n  let i = 0;\n\n  for (let row = 0; row < height; row++) {\n    const dy = row + y - deviceY;\n    const dy2 = dy * dy;\n\n    if (dy2 > minSquareDistanceToCenter) {\n      // skip this row\n      i += 4 * width;\n    } else {\n      for (let col = 0; col < width; col++) {\n        // Decode picked layer from color\n        const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n        if (pickedLayerIndex >= 0) {\n          const dx = col + x - deviceX;\n          const d2 = dx * dx + dy2;\n\n          if (d2 <= minSquareDistanceToCenter) {\n            minSquareDistanceToCenter = d2;\n            closestPixelIndex = i;\n          }\n        }\n        i += 4;\n      }\n    }\n  }\n\n  if (closestPixelIndex >= 0) {\n    // Decode picked object index from color\n    const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);\n    const pickedObject = decodePickingColor(pickedColor);\n    if (pickedObject) {\n      const dy = Math.floor(closestPixelIndex / 4 / width);\n      const dx = closestPixelIndex / 4 - dy * width;\n      return {\n        ...pickedObject,\n        pickedColor,\n        pickedX: x + dx,\n        pickedY: y + dy\n      };\n    }\n    log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n  }\n  return NO_PICKED_OBJECT;\n}\n\n/**\n * Examines a picking buffer for unique colors\n * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`\n */\nexport function getUniqueObjects({\n  pickedColors,\n  decodePickingColor\n}: {\n  pickedColors: Uint8Array;\n  decodePickingColor: PickingColorDecoder;\n}): PickedPixel[] {\n  const uniqueColors = new Map();\n\n  // Traverse all pixels in picking results and get unique colors\n  if (pickedColors) {\n    for (let i = 0; i < pickedColors.length; i += 4) {\n      // Decode picked layer from color\n      const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n      if (pickedLayerIndex >= 0) {\n        const pickedColor = pickedColors.slice(i, i + 4);\n        const colorKey = pickedColor.join(',');\n        // eslint-disable-next-line\n        if (!uniqueColors.has(colorKey)) {\n          const pickedObject = decodePickingColor(pickedColor);\n          // eslint-disable-next-line\n          if (pickedObject) {\n            uniqueColors.set(colorKey, {\n              ...pickedObject,\n              color: pickedColor\n            });\n          } else {\n            log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n          }\n        }\n      }\n    }\n  }\n\n  return Array.from(uniqueColors.values());\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}