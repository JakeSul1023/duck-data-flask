{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** Decodes a vertex type, returning byte length and flags (integer, signed, normalized) */\nexport function decodeShaderAttributeType(attributeType) {\n  const [dataType, components] = TYPE_INFO[attributeType];\n  const integer = dataType === 'i32' || dataType === 'u32';\n  const signed = dataType !== 'u32';\n  const byteLength = TYPE_SIZES[dataType] * components;\n  const defaultVertexFormat = getCompatibleVertexFormat(dataType, components);\n  return {\n    dataType,\n    components,\n    defaultVertexFormat,\n    byteLength,\n    integer,\n    signed\n  };\n}\n/** Get the \"default\" vertex format for a certain shader data type */\nfunction getCompatibleVertexFormat(dataType, components) {\n  let vertexType;\n  switch (dataType) {\n    case 'f32':\n      vertexType = 'float32';\n      break;\n    case 'i32':\n      vertexType = 'sint32';\n      break;\n    case 'u32':\n      vertexType = 'uint32';\n      break;\n    case 'f16':\n      return components <= 2 ? 'float16x2' : 'float16x4';\n  }\n  // TODO logic does not work for float16\n  if (components === 1) {\n    return vertexType;\n  }\n  return `${vertexType}x${components}`;\n}\n/** All valid shader attribute types. A table guarantees exhaustive list and fast execution */\nconst TYPE_INFO = {\n  f32: ['f32', 1],\n  'vec2<f32>': ['f32', 2],\n  'vec3<f32>': ['f32', 3],\n  'vec4<f32>': ['f32', 4],\n  f16: ['f16', 1],\n  'vec2<f16>': ['f16', 2],\n  'vec3<f16>': ['f16', 3],\n  'vec4<f16>': ['f16', 4],\n  i32: ['i32', 1],\n  'vec2<i32>': ['i32', 2],\n  'vec3<i32>': ['i32', 3],\n  'vec4<i32>': ['i32', 4],\n  u32: ['u32', 1],\n  'vec2<u32>': ['u32', 2],\n  'vec3<u32>': ['u32', 3],\n  'vec4<u32>': ['u32', 4]\n};\nconst TYPE_SIZES = {\n  f32: 4,\n  f16: 2,\n  i32: 4,\n  u32: 4\n  // 'bool-webgl': 4,\n};","map":{"version":3,"names":["decodeShaderAttributeType","attributeType","dataType","components","TYPE_INFO","integer","signed","byteLength","TYPE_SIZES","defaultVertexFormat","getCompatibleVertexFormat","vertexType","f32","f16","i32","u32"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\core\\src\\gpu-type-utils\\decode-attribute-type.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderDataType, ShaderAttributeType} from './shader-types';\nimport {VertexFormat, VertexType} from './vertex-formats';\n\n/** Information extracted from a ShaderAttributeInfo constant */\nexport type ShaderAttributeTypeInfo = {\n  /** WGSL-style primitive data type, f32, i32, u32 */\n  dataType: ShaderDataType;\n  /** Whether this is a normalized integer (that must be used as float) */\n  components: 1 | 2 | 3 | 4;\n  /** Length in bytes of the data for one vertex */\n  byteLength?: number;\n  /** Whether this is for integer or float vert */\n  integer: boolean;\n  /** Whether this data type is signed */\n  signed: boolean;\n  /** The simplest vertex format that matches the shader attribute's data type */\n  defaultVertexFormat: VertexFormat;\n};\n\n/** Decodes a vertex type, returning byte length and flags (integer, signed, normalized) */\nexport function decodeShaderAttributeType(\n  attributeType: ShaderAttributeType\n): ShaderAttributeTypeInfo {\n  const [dataType, components] = TYPE_INFO[attributeType];\n  const integer: boolean = dataType === 'i32' || dataType === 'u32';\n  const signed: boolean = dataType !== 'u32';\n\n  const byteLength = TYPE_SIZES[dataType] * components;\n  const defaultVertexFormat = getCompatibleVertexFormat(dataType, components);\n  return {\n    dataType,\n    components,\n    defaultVertexFormat,\n    byteLength,\n    integer,\n    signed\n  };\n}\n\n/** Get the \"default\" vertex format for a certain shader data type */\nfunction getCompatibleVertexFormat(\n  dataType: ShaderDataType,\n  components: 1 | 2 | 3 | 4\n): VertexFormat {\n  let vertexType: VertexType;\n  switch (dataType) {\n    case 'f32':\n      vertexType = 'float32';\n      break;\n    case 'i32':\n      vertexType = 'sint32';\n      break;\n    case 'u32':\n      vertexType = 'uint32';\n      break;\n    case 'f16':\n      return components <= 2 ? 'float16x2' : 'float16x4';\n  }\n  // TODO logic does not work for float16\n  if (components === 1) {\n    return vertexType;\n  }\n  return `${vertexType}x${components}`;\n}\n\n/** All valid shader attribute types. A table guarantees exhaustive list and fast execution */\nconst TYPE_INFO: Record<ShaderAttributeType, [ShaderDataType, 1 | 2 | 3 | 4]> = {\n  f32: ['f32', 1],\n  'vec2<f32>': ['f32', 2],\n  'vec3<f32>': ['f32', 3],\n  'vec4<f32>': ['f32', 4],\n  f16: ['f16', 1],\n  'vec2<f16>': ['f16', 2],\n  'vec3<f16>': ['f16', 3],\n  'vec4<f16>': ['f16', 4],\n  i32: ['i32', 1],\n  'vec2<i32>': ['i32', 2],\n  'vec3<i32>': ['i32', 3],\n  'vec4<i32>': ['i32', 4],\n  u32: ['u32', 1],\n  'vec2<u32>': ['u32', 2],\n  'vec3<u32>': ['u32', 3],\n  'vec4<u32>': ['u32', 4]\n};\n\nconst TYPE_SIZES: Record<ShaderDataType, number> = {\n  f32: 4,\n  f16: 2,\n  i32: 4,\n  u32: 4\n  // 'bool-webgl': 4,\n};\n"],"mappings":"AAAA;AACA;AACA;AAqBA;AACA,OAAM,SAAUA,yBAAyBA,CACvCC,aAAkC;EAElC,MAAM,CAACC,QAAQ,EAAEC,UAAU,CAAC,GAAGC,SAAS,CAACH,aAAa,CAAC;EACvD,MAAMI,OAAO,GAAYH,QAAQ,KAAK,KAAK,IAAIA,QAAQ,KAAK,KAAK;EACjE,MAAMI,MAAM,GAAYJ,QAAQ,KAAK,KAAK;EAE1C,MAAMK,UAAU,GAAGC,UAAU,CAACN,QAAQ,CAAC,GAAGC,UAAU;EACpD,MAAMM,mBAAmB,GAAGC,yBAAyB,CAACR,QAAQ,EAAEC,UAAU,CAAC;EAC3E,OAAO;IACLD,QAAQ;IACRC,UAAU;IACVM,mBAAmB;IACnBF,UAAU;IACVF,OAAO;IACPC;GACD;AACH;AAEA;AACA,SAASI,yBAAyBA,CAChCR,QAAwB,EACxBC,UAAyB;EAEzB,IAAIQ,UAAsB;EAC1B,QAAQT,QAAQ;IACd,KAAK,KAAK;MACRS,UAAU,GAAG,SAAS;MACtB;IACF,KAAK,KAAK;MACRA,UAAU,GAAG,QAAQ;MACrB;IACF,KAAK,KAAK;MACRA,UAAU,GAAG,QAAQ;MACrB;IACF,KAAK,KAAK;MACR,OAAOR,UAAU,IAAI,CAAC,GAAG,WAAW,GAAG,WAAW;EACtD;EACA;EACA,IAAIA,UAAU,KAAK,CAAC,EAAE;IACpB,OAAOQ,UAAU;EACnB;EACA,OAAO,GAAGA,UAAU,IAAIR,UAAU,EAAE;AACtC;AAEA;AACA,MAAMC,SAAS,GAAiE;EAC9EQ,GAAG,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC;EACf,WAAW,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC;EACvB,WAAW,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC;EACvB,WAAW,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC;EACvBC,GAAG,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC;EACf,WAAW,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC;EACvB,WAAW,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC;EACvB,WAAW,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC;EACvBC,GAAG,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC;EACf,WAAW,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC;EACvB,WAAW,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC;EACvB,WAAW,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC;EACvBC,GAAG,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC;EACf,WAAW,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC;EACvB,WAAW,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC;EACvB,WAAW,EAAE,CAAC,KAAK,EAAE,CAAC;CACvB;AAED,MAAMP,UAAU,GAAmC;EACjDI,GAAG,EAAE,CAAC;EACNC,GAAG,EAAE,CAAC;EACNC,GAAG,EAAE,CAAC;EACNC,GAAG,EAAE;EACL;CACD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}