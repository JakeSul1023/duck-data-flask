{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Model } from \"../model/model.js\";\nimport { getPassthroughFS } from '@luma.gl/shadertools';\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n/**\n * Creates a pipeline for textureâ†’texture transforms.\n * @deprecated\n */\nexport class TextureTransform {\n  device;\n  model;\n  sampler;\n  currentIndex = 0;\n  samplerTextureMap = null;\n  bindings = []; // each element is an object : {sourceTextures, targetTexture, framebuffer}\n  resources = {}; // resources to be deleted\n  constructor(device, props) {\n    this.device = device;\n    // For precise picking of element IDs.\n    this.sampler = device.createSampler({\n      addressModeU: 'clamp-to-edge',\n      addressModeV: 'clamp-to-edge',\n      minFilter: 'nearest',\n      magFilter: 'nearest',\n      mipmapFilter: 'nearest'\n    });\n    this.model = new Model(this.device, {\n      id: props.id || 'texture-transform-model',\n      fs: props.fs || getPassthroughFS({\n        input: props.targetTextureVarying,\n        inputChannels: props.targetTextureChannels,\n        output: FS_OUTPUT_VARIABLE\n      }),\n      vertexCount: props.vertexCount,\n      // TODO(donmccurdy): Naming?\n      ...props\n    });\n    this._initialize(props);\n    Object.seal(this);\n  }\n  // Delete owned resources.\n  destroy() {\n    this.model.destroy();\n    for (const binding of this.bindings) {\n      binding.framebuffer?.destroy();\n    }\n  }\n  /** @deprecated Use {@link destroy}. */\n  delete() {\n    this.destroy();\n  }\n  run(options) {\n    const {\n      framebuffer\n    } = this.bindings[this.currentIndex];\n    const renderPass = this.device.beginRenderPass({\n      framebuffer,\n      ...options\n    });\n    this.model.draw(renderPass);\n    renderPass.end();\n  }\n  getTargetTexture() {\n    const {\n      targetTexture\n    } = this.bindings[this.currentIndex];\n    return targetTexture;\n  }\n  getFramebuffer() {\n    const currentResources = this.bindings[this.currentIndex];\n    return currentResources.framebuffer;\n  }\n  // Private\n  _initialize(props) {\n    this._updateBindings(props);\n  }\n  _updateBindings(props) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], props);\n  }\n  _updateBinding(binding, _ref) {\n    let {\n      sourceBuffers,\n      sourceTextures,\n      targetTexture\n    } = _ref;\n    if (!binding) {\n      binding = {\n        sourceBuffers: {},\n        sourceTextures: {},\n        // @ts-expect-error\n        targetTexture: null\n      };\n    }\n    Object.assign(binding.sourceTextures, sourceTextures);\n    Object.assign(binding.sourceBuffers, sourceBuffers);\n    if (targetTexture) {\n      binding.targetTexture = targetTexture;\n      const {\n        width,\n        height\n      } = targetTexture;\n      // TODO(donmccurdy): When is this called, and is this expected?\n      if (binding.framebuffer) {\n        binding.framebuffer.destroy();\n      }\n      binding.framebuffer = this.device.createFramebuffer({\n        id: 'transform-framebuffer',\n        width,\n        height,\n        colorAttachments: [targetTexture]\n      });\n      binding.framebuffer.resize({\n        width,\n        height\n      });\n    }\n    return binding;\n  }\n  // set texture filtering parameters on source textures.\n  _setSourceTextureParameters() {\n    const index = this.currentIndex;\n    const {\n      sourceTextures\n    } = this.bindings[index];\n    for (const name in sourceTextures) {\n      sourceTextures[name].sampler = this.sampler;\n    }\n  }\n}\n//# sourceMappingURL=texture-transform.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}