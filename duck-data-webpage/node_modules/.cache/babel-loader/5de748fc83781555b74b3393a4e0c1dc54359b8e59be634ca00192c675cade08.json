{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst FS_GLES = /* glsl */`\\\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}`;\nconst FS300 = `#version 300 es\\n${FS_GLES}`;\n// Prase given glsl line and return qualifier details or null\nexport function getQualifierDetails(line, qualifiers) {\n  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];\n  const words = line.replace(/^\\s+/, '').split(/\\s+/);\n  // TODO add support for precession qualifiers (highp, mediump and lowp)\n  const [qualifier, type, definition] = words;\n  if (!qualifiers.includes(qualifier) || !type || !definition) {\n    return null;\n  }\n  const name = definition.split(';')[0];\n  return {\n    qualifier,\n    type,\n    name\n  };\n}\n/**\n * Given the shader input and output variable names,\n * builds and return a pass through fragment shader.\n */\nexport function getPassthroughFS(options) {\n  const {\n    input,\n    inputChannels,\n    output\n  } = options || {};\n  if (!input) {\n    // Default shader\n    return FS300;\n  }\n  if (!inputChannels) {\n    throw new Error('inputChannels');\n  }\n  const inputType = channelCountToType(inputChannels);\n  const outputValue = convertToVec4(input, inputChannels);\n  return `\\\n#version 300 es\nin ${inputType} ${input};\nout vec4 ${output};\nvoid main() {\n  ${output} = ${outputValue};\n}`;\n}\n/** convert glsl type to suffix */\nexport function typeToChannelSuffix(type) {\n  // prettier-ignore\n  switch (type) {\n    case 'float':\n      return 'x';\n    case 'vec2':\n      return 'xy';\n    case 'vec3':\n      return 'xyz';\n    case 'vec4':\n      return 'xyzw';\n    default:\n      throw new Error(type);\n  }\n}\n/** convert glsl type to channel count */\nexport function typeToChannelCount(type) {\n  // prettier-ignore\n  switch (type) {\n    case 'float':\n      return 1;\n    case 'vec2':\n      return 2;\n    case 'vec3':\n      return 3;\n    case 'vec4':\n      return 4;\n    default:\n      throw new Error(type);\n  }\n}\nfunction channelCountToType(channels) {\n  // prettier-ignore\n  switch (channels) {\n    case 1:\n      return 'float';\n    case 2:\n      return 'vec2';\n    case 3:\n      return 'vec3';\n    case 4:\n      return 'vec4';\n    default:\n      throw new Error(`invalid channels: ${channels}`);\n  }\n}\n/** Returns glsl instruction for converting to vec4 */\nexport function convertToVec4(variable, channels) {\n  // prettier-ignore\n  switch (channels) {\n    case 1:\n      return `vec4(${variable}, 0.0, 0.0, 1.0)`;\n    case 2:\n      return `vec4(${variable}, 0.0, 1.0)`;\n    case 3:\n      return `vec4(${variable}, 1.0)`;\n    case 4:\n      return variable;\n    default:\n      throw new Error(`invalid channels: ${channels}`);\n  }\n}\n//# sourceMappingURL=shader-utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}