{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport class TypedArrayManager {\n  constructor(options = {}) {\n    this._pool = [];\n    this.opts = {\n      overAlloc: 2,\n      poolSize: 100\n    };\n    this.setOptions(options);\n  }\n  setOptions(options) {\n    Object.assign(this.opts, options);\n  }\n  allocate(typedArray, count, {\n    size = 1,\n    type,\n    padding = 0,\n    copy = false,\n    initialize = false,\n    maxCount\n  }) {\n    const Type = type || typedArray && typedArray.constructor || Float32Array;\n    const newSize = count * size + padding;\n    if (ArrayBuffer.isView(typedArray)) {\n      if (newSize <= typedArray.length) {\n        return typedArray;\n      }\n      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n        return new Type(typedArray.buffer, 0, newSize);\n      }\n    }\n    let maxSize = Infinity;\n    if (maxCount) {\n      maxSize = maxCount * size + padding;\n    }\n    const newArray = this._allocate(Type, newSize, initialize, maxSize);\n    if (typedArray && copy) {\n      newArray.set(typedArray);\n    } else if (!initialize) {\n      // Hack - always initialize the first 4 elements. NaNs crash the Attribute validation\n      newArray.fill(0, 0, 4);\n    }\n    this._release(typedArray);\n    return newArray;\n  }\n  release(typedArray) {\n    this._release(typedArray);\n  }\n  _allocate(Type, size, initialize, maxSize) {\n    // Allocate at least one element to ensure a valid buffer\n    let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);\n    // Don't over allocate after certain specified number of elements\n    if (sizeToAllocate > maxSize) {\n      sizeToAllocate = maxSize;\n    }\n    // Check if available in pool\n    const pool = this._pool;\n    const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i >= 0) {\n      // Create a new array using an existing buffer\n      const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);\n      if (initialize) {\n        // Viewing a buffer with a different type may create NaNs\n        array.fill(0);\n      }\n      return array;\n    }\n    return new Type(sizeToAllocate);\n  }\n  _release(typedArray) {\n    if (!ArrayBuffer.isView(typedArray)) {\n      return;\n    }\n    const pool = this._pool;\n    const {\n      buffer\n    } = typedArray;\n    // Save the buffer of the released array into the pool\n    // Sort buffers by size\n    // TODO - implement binary search?\n    const {\n      byteLength\n    } = buffer;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i < 0) {\n      pool.push(buffer);\n    } else if (i > 0 || pool.length < this.opts.poolSize) {\n      pool.splice(i, 0, buffer);\n    }\n    if (pool.length > this.opts.poolSize) {\n      // Drop the smallest one\n      pool.shift();\n    }\n  }\n}\nexport default new TypedArrayManager();","map":{"version":3,"names":["TypedArrayManager","constructor","options","_pool","opts","overAlloc","poolSize","setOptions","Object","assign","allocate","typedArray","count","size","type","padding","copy","initialize","maxCount","Type","Float32Array","newSize","ArrayBuffer","isView","length","BYTES_PER_ELEMENT","buffer","byteLength","maxSize","Infinity","newArray","_allocate","set","fill","_release","release","sizeToAllocate","Math","max","ceil","pool","i","findIndex","b","array","splice","push","shift"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\utils\\typed-array-manager.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {TypedArray, TypedArrayConstructor} from '../types/types';\n\nexport type TypedArrayManagerOptions = {\n  overAlloc?: number;\n  poolSize?: number;\n};\n\nexport class TypedArrayManager {\n  private _pool: ArrayBuffer[] = [];\n  opts: {\n    overAlloc: number;\n    poolSize: number;\n  } = {overAlloc: 2, poolSize: 100};\n\n  constructor(options: TypedArrayManagerOptions = {}) {\n    this.setOptions(options);\n  }\n\n  setOptions(options: TypedArrayManagerOptions) {\n    Object.assign(this.opts, options);\n  }\n\n  allocate<T extends TypedArray>(\n    typedArray: T | null | undefined,\n    count: number,\n    {\n      size = 1,\n      type,\n      padding = 0,\n      copy = false,\n      initialize = false,\n      maxCount\n    }: {\n      size?: number;\n      type?: TypedArrayConstructor;\n      padding?: number;\n      copy?: boolean;\n      initialize?: boolean;\n      maxCount?: number;\n    }\n  ): T {\n    const Type =\n      type || (typedArray && (typedArray.constructor as TypedArrayConstructor)) || Float32Array;\n\n    const newSize = count * size + padding;\n    if (ArrayBuffer.isView(typedArray)) {\n      if (newSize <= typedArray.length) {\n        return typedArray;\n      }\n      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n        return new Type(typedArray.buffer, 0, newSize) as T;\n      }\n    }\n\n    let maxSize: number = Infinity;\n    if (maxCount) {\n      maxSize = maxCount * size + padding;\n    }\n\n    const newArray = this._allocate(Type, newSize, initialize, maxSize);\n\n    if (typedArray && copy) {\n      newArray.set(typedArray);\n    } else if (!initialize) {\n      // Hack - always initialize the first 4 elements. NaNs crash the Attribute validation\n      newArray.fill(0, 0, 4);\n    }\n\n    this._release(typedArray);\n    return newArray as T;\n  }\n\n  release(typedArray: TypedArray | null | undefined) {\n    this._release(typedArray);\n  }\n\n  private _allocate(\n    Type: TypedArrayConstructor,\n    size: number,\n    initialize: boolean,\n    maxSize: number\n  ): TypedArray {\n    // Allocate at least one element to ensure a valid buffer\n    let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);\n    // Don't over allocate after certain specified number of elements\n    if (sizeToAllocate > maxSize) {\n      sizeToAllocate = maxSize;\n    }\n\n    // Check if available in pool\n    const pool = this._pool;\n    const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i >= 0) {\n      // Create a new array using an existing buffer\n      const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);\n      if (initialize) {\n        // Viewing a buffer with a different type may create NaNs\n        array.fill(0);\n      }\n      return array;\n    }\n    return new Type(sizeToAllocate);\n  }\n\n  private _release(typedArray: TypedArray | null | undefined): void {\n    if (!ArrayBuffer.isView(typedArray)) {\n      return;\n    }\n    const pool = this._pool;\n    const {buffer} = typedArray;\n    // Save the buffer of the released array into the pool\n    // Sort buffers by size\n    // TODO - implement binary search?\n    const {byteLength} = buffer;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i < 0) {\n      pool.push(buffer);\n    } else if (i > 0 || pool.length < this.opts.poolSize) {\n      pool.splice(i, 0, buffer);\n    }\n    if (pool.length > this.opts.poolSize) {\n      // Drop the smallest one\n      pool.shift();\n    }\n  }\n}\n\nexport default new TypedArrayManager();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}