{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@luma.gl/core';\nimport { WgslReflect } from 'wgsl_reflect';\n/**\n * Parse a ShaderLayout from WGSL shader source code.\n * @param source WGSL source code (can contain both @vertex and @fragment entry points)\n * @returns\n */\nexport function getShaderLayoutFromWGSL(source) {\n  const shaderLayout = {\n    attributes: [],\n    bindings: []\n  };\n  let parsedWGSL;\n  try {\n    parsedWGSL = parseWGSL(source);\n  } catch (error) {\n    log.error(error.message)();\n    return shaderLayout;\n  }\n  for (const uniform of parsedWGSL.uniforms) {\n    const members = [];\n    for (const attribute of uniform.type?.members || []) {\n      members.push({\n        name: attribute.name,\n        type: getType(attribute.type)\n      });\n    }\n    shaderLayout.bindings.push({\n      type: 'uniform',\n      name: uniform.name,\n      group: uniform.group,\n      location: uniform.binding,\n      // @ts-expect-error TODO - unused for now but needs fixing\n      members\n    });\n  }\n  for (const texture of parsedWGSL.textures) {\n    shaderLayout.bindings.push({\n      type: 'texture',\n      name: texture.name,\n      group: texture.group,\n      location: texture.binding\n    });\n  }\n  for (const sampler of parsedWGSL.samplers) {\n    shaderLayout.bindings.push({\n      type: 'sampler',\n      name: sampler.name,\n      group: sampler.group,\n      location: sampler.binding\n    });\n  }\n  const vertex = parsedWGSL.entry.vertex[0]; // \"main\"\n  // Vertex shader inputs\n  const attributeCount = vertex?.inputs.length || 0; // inputs to \"main\"\n  for (let i = 0; i < attributeCount; i++) {\n    const wgslAttribute = vertex.inputs[i];\n    // locationType can be \"builtin\"\n    if (wgslAttribute.locationType === 'location') {\n      const type = getType(wgslAttribute.type);\n      shaderLayout.attributes.push({\n        name: wgslAttribute.name,\n        location: Number(wgslAttribute.location),\n        type\n      });\n    }\n  }\n  return shaderLayout;\n}\n/** Get a valid shader attribute type string from a wgsl-reflect type */\nfunction getType(type) {\n  return type.format ? `${type.name}<${type.format.name}>` : type.name;\n}\nfunction parseWGSL(source) {\n  try {\n    return new WgslReflect(source);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw error;\n    }\n    let message = 'WGSL parse error';\n    if (typeof error === 'object' && error?.message) {\n      message += `: ${error.message} `;\n    }\n    if (typeof error === 'object' && error?.token) {\n      message += error.token.line || '';\n    }\n    throw new Error(message, {\n      cause: error\n    });\n  }\n}","map":{"version":3,"names":["log","WgslReflect","getShaderLayoutFromWGSL","source","shaderLayout","attributes","bindings","parsedWGSL","parseWGSL","error","message","uniform","uniforms","members","attribute","type","push","name","getType","group","location","binding","texture","textures","sampler","samplers","vertex","entry","attributeCount","inputs","length","i","wgslAttribute","locationType","Number","format","Error","token","line","cause"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\shadertools\\src\\lib\\wgsl\\get-shader-layout-wgsl.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderAttributeType, ShaderLayout, log} from '@luma.gl/core';\nimport {WgslReflect} from 'wgsl_reflect';\n\n/**\n * Parse a ShaderLayout from WGSL shader source code.\n * @param source WGSL source code (can contain both @vertex and @fragment entry points)\n * @returns\n */\nexport function getShaderLayoutFromWGSL(source: string): ShaderLayout {\n  const shaderLayout: ShaderLayout = {attributes: [], bindings: []};\n\n  let parsedWGSL: WgslReflect;\n  try {\n    parsedWGSL = parseWGSL(source);\n  } catch (error: any) {\n    log.error(error.message)();\n    return shaderLayout;\n  }\n\n  for (const uniform of parsedWGSL.uniforms) {\n    const members = [];\n    for (const attribute of (uniform.type as any)?.members || []) {\n      members.push({\n        name: attribute.name,\n        type: getType(attribute.type)\n      });\n    }\n\n    shaderLayout.bindings.push({\n      type: 'uniform',\n      name: uniform.name,\n      group: uniform.group,\n      location: uniform.binding,\n      // @ts-expect-error TODO - unused for now but needs fixing\n      members\n    });\n  }\n\n  for (const texture of parsedWGSL.textures) {\n    shaderLayout.bindings.push({\n      type: 'texture',\n      name: texture.name,\n      group: texture.group,\n      location: texture.binding\n    });\n  }\n\n  for (const sampler of parsedWGSL.samplers) {\n    shaderLayout.bindings.push({\n      type: 'sampler',\n      name: sampler.name,\n      group: sampler.group,\n      location: sampler.binding\n    });\n  }\n\n  const vertex = parsedWGSL.entry.vertex[0]; // \"main\"\n\n  // Vertex shader inputs\n  const attributeCount = vertex?.inputs.length || 0; // inputs to \"main\"\n  for (let i = 0; i < attributeCount; i++) {\n    const wgslAttribute = vertex.inputs[i];\n\n    // locationType can be \"builtin\"\n    if (wgslAttribute.locationType === 'location') {\n      const type = getType(wgslAttribute.type);\n\n      shaderLayout.attributes.push({\n        name: wgslAttribute.name,\n        location: Number(wgslAttribute.location),\n        type\n      });\n    }\n  }\n  return shaderLayout;\n}\n\n/** Get a valid shader attribute type string from a wgsl-reflect type */\nfunction getType(type: any): ShaderAttributeType {\n  return type.format ? `${type.name}<${type.format.name}>` : type.name;\n}\n\nfunction parseWGSL(source: string): WgslReflect {\n  try {\n    return new WgslReflect(source);\n  } catch (error: any) {\n    if (error instanceof Error) {\n      throw error;\n    }\n    let message = 'WGSL parse error';\n    if (typeof error === 'object' && error?.message) {\n      message += `: ${error.message} `;\n    }\n    if (typeof error === 'object' && error?.token) {\n      message += error.token.line || '';\n    }\n    throw new Error(message, {cause: error});\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}