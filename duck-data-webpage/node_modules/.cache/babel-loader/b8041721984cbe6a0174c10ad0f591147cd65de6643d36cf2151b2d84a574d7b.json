{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { concatenateArrayBuffersAsync } from '@loaders.gl/loader-utils';\nimport { isResponse, isReadableStream, isAsyncIterable, isIterable, isIterator, isBlob, isBuffer } from \"../../javascript-utils/is-type.js\";\nimport { makeIterator } from \"../../iterators/make-iterator/make-iterator.js\";\nimport { checkResponse, makeResponse } from \"../utils/response-utils.js\";\nconst ERR_DATA = 'Cannot convert supplied data type';\n// eslint-disable-next-line complexity\nexport function getArrayBufferOrStringFromDataSync(data, loader, options) {\n  if (loader.text && typeof data === 'string') {\n    return data;\n  }\n  if (isBuffer(data)) {\n    // @ts-ignore\n    data = data.buffer;\n  }\n  if (data instanceof ArrayBuffer) {\n    const arrayBuffer = data;\n    if (loader.text && !loader.binary) {\n      const textDecoder = new TextDecoder('utf8');\n      return textDecoder.decode(arrayBuffer);\n    }\n    return arrayBuffer;\n  }\n  // We may need to handle offsets\n  if (ArrayBuffer.isView(data)) {\n    // TextDecoder is invoked on typed arrays and will handle offsets\n    if (loader.text && !loader.binary) {\n      const textDecoder = new TextDecoder('utf8');\n      return textDecoder.decode(data);\n    }\n    let arrayBuffer = data.buffer;\n    // Since we are returning the underlying arrayBuffer, we must create a new copy\n    // if this typed array / Buffer is a partial view into the ArryayBuffer\n    // TODO - this is a potentially unnecessary copy\n    const byteLength = data.byteLength || data.length;\n    if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {\n      // console.warn(`loaders.gl copying arraybuffer of length ${byteLength}`);\n      arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);\n    }\n    return arrayBuffer;\n  }\n  throw new Error(ERR_DATA);\n}\n// Convert async iterator to a promise\nexport async function getArrayBufferOrStringFromData(data, loader, options) {\n  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);\n  if (typeof data === 'string' || isArrayBuffer) {\n    return getArrayBufferOrStringFromDataSync(data, loader, options);\n  }\n  // Blobs and files are FileReader compatible\n  if (isBlob(data)) {\n    data = await makeResponse(data);\n  }\n  if (isResponse(data)) {\n    const response = data;\n    await checkResponse(response);\n    return loader.binary ? await response.arrayBuffer() : await response.text();\n  }\n  if (isReadableStream(data)) {\n    // @ts-expect-error TS2559 options type\n    data = makeIterator(data, options);\n  }\n  if (isIterable(data) || isAsyncIterable(data)) {\n    // Assume arrayBuffer iterator - attempt to concatenate\n    return concatenateArrayBuffersAsync(data);\n  }\n  throw new Error(ERR_DATA);\n}\nexport async function getAsyncIterableFromData(data, options) {\n  if (isIterator(data)) {\n    return data;\n  }\n  if (isResponse(data)) {\n    const response = data;\n    // Note Since this function is not async, we currently can't load error message, just status\n    await checkResponse(response);\n    // TODO - bug in polyfill, body can be a Promise under Node.js\n    // eslint-disable-next-line @typescript-eslint/await-thenable\n    const body = await response.body;\n    // TODO - body can be null?\n    return makeIterator(body, options);\n  }\n  if (isBlob(data) || isReadableStream(data)) {\n    return makeIterator(data, options);\n  }\n  if (isAsyncIterable(data)) {\n    return data;\n  }\n  return getIterableFromData(data);\n}\nexport async function getReadableStream(data) {\n  if (isReadableStream(data)) {\n    return data;\n  }\n  if (isResponse(data)) {\n    // @ts-ignore\n    return data.body;\n  }\n  const response = await makeResponse(data);\n  // @ts-ignore\n  return response.body;\n}\n// HELPERS\nfunction getIterableFromData(data) {\n  // generate an iterator that emits a single chunk\n  if (ArrayBuffer.isView(data)) {\n    return function* oneChunk() {\n      yield data.buffer;\n    }();\n  }\n  if (data instanceof ArrayBuffer) {\n    return function* oneChunk() {\n      yield data;\n    }();\n  }\n  if (isIterator(data)) {\n    return data;\n  }\n  if (isIterable(data)) {\n    return data[Symbol.iterator]();\n  }\n  throw new Error(ERR_DATA);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}