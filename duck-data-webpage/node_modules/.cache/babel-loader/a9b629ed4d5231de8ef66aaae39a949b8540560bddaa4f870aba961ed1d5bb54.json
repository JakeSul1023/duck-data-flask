{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { lightingShader } from \"./lights-glsl.js\";\nconst INITIAL_MODULE_OPTIONS = {\n  lightSources: {}\n};\n// Take color 0-255 and intensity as input and output 0.0-1.0 range\nfunction convertColor(colorDef = {}) {\n  const {\n    color = [0, 0, 0],\n    intensity = 1.0\n  } = colorDef;\n  return color.map(component => component * intensity / 255.0);\n}\nfunction getLightSourceUniforms({\n  ambientLight,\n  pointLights = [],\n  directionalLights = []\n}) {\n  const lightSourceUniforms = {};\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[`lighting_uPointLight[${index}].color`] = convertColor(pointLight);\n    lightSourceUniforms[`lighting_uPointLight[${index}].position`] = pointLight.position;\n    lightSourceUniforms[`lighting_uPointLight[${index}].attenuation`] = pointLight.attenuation || [1, 0, 0];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].color`] = convertColor(directionalLight);\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].direction`] = directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n  return lightSourceUniforms;\n}\n// eslint-disable-next-line complexity\nfunction getUniforms(opts = INITIAL_MODULE_OPTIONS) {\n  // Specify lights separately\n  if ('lightSources' in opts) {\n    const {\n      ambientLight,\n      pointLights,\n      directionalLights\n    } = opts.lightSources || {};\n    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;\n    if (!hasLights) {\n      return {\n        lighting_uEnabled: false\n      };\n    }\n    return Object.assign({}, getLightSourceUniforms({\n      ambientLight,\n      pointLights,\n      directionalLights\n    }), {\n      lighting_uEnabled: true\n    });\n  }\n  // Support for array of lights. Type of light is detected by type field\n  if ('lights' in opts) {\n    const lightSources = {\n      pointLights: [],\n      directionalLights: []\n    };\n    // @ts-expect-error\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          // Note: Only uses last ambient light\n          // TODO - add ambient light sources on CPU?\n          lightSources.ambientLight = light;\n          break;\n        case 'directional':\n          lightSources.directionalLights?.push(light);\n          break;\n        case 'point':\n          lightSources.pointLights?.push(light);\n          break;\n        default:\n        // eslint-disable-next-line\n        // console.warn(light.type);\n      }\n    }\n    // Call the `opts.lightSources`` version\n    return getUniforms({\n      lightSources\n    });\n  }\n  return {};\n}\n/**\n * An implementation of PBR (Physically-Based Rendering).\n * Physically Based Shading of a microfacet surface defined by a glTF material.\n */\nexport const lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\n//# sourceMappingURL=lights.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}