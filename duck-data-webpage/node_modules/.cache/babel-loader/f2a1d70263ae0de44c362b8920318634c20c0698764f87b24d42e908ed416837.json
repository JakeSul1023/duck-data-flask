{"ast":null,"code":"// Dynamic DRACO module loading inspired by THREE.DRACOLoader\n// https://github.com/mrdoob/three.js/blob/398c4f39ebdb8b23eefd4a7a5ec49ec0c96c7462/examples/jsm/loaders/DRACOLoader.js\n// by Don McCurdy / https://www.donmccurdy.com / MIT license\nimport { loadLibrary } from '@loaders.gl/worker-utils';\nconst DRACO_DECODER_VERSION = '1.5.6';\nconst DRACO_ENCODER_VERSION = '1.4.1';\nconst STATIC_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_DECODER_VERSION}`;\nexport const DRACO_EXTERNAL_LIBRARIES = {\n  /** The primary Draco3D encoder, javascript wrapper part */\n  DECODER: 'draco_wasm_wrapper.js',\n  /** The primary draco decoder, compiled web assembly part */\n  DECODER_WASM: 'draco_decoder.wasm',\n  /** Fallback decoder for non-webassebly environments. Very big bundle, lower performance */\n  FALLBACK_DECODER: 'draco_decoder.js',\n  /** Draco encoder */\n  ENCODER: 'draco_encoder.js'\n};\nexport const DRACO_EXTERNAL_LIBRARY_URLS = {\n  [DRACO_EXTERNAL_LIBRARIES.DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER}`,\n  [DRACO_EXTERNAL_LIBRARIES.DECODER_WASM]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER_WASM}`,\n  [DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER}`,\n  [DRACO_EXTERNAL_LIBRARIES.ENCODER]: `https://raw.githubusercontent.com/google/draco/${DRACO_ENCODER_VERSION}/javascript/${DRACO_EXTERNAL_LIBRARIES.ENCODER}`\n};\nlet loadDecoderPromise;\nlet loadEncoderPromise;\nexport async function loadDracoDecoderModule(options) {\n  const modules = options.modules || {};\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadDecoderPromise ||= modules.draco3d.createDecoderModule({}).then(draco => {\n      return {\n        draco\n      };\n    });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadDecoderPromise ||= loadDracoDecoder(options);\n  }\n  return await loadDecoderPromise;\n}\nexport async function loadDracoEncoderModule(options) {\n  const modules = options.modules || {};\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadEncoderPromise ||= modules.draco3d.createEncoderModule({}).then(draco => {\n      return {\n        draco\n      };\n    });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadEncoderPromise ||= loadDracoEncoder(options);\n  }\n  return await loadEncoderPromise;\n}\n// DRACO DECODER LOADING\nasync function loadDracoDecoder(options) {\n  let DracoDecoderModule;\n  let wasmBinary;\n  switch (options.draco && options.draco.decoderType) {\n    case 'js':\n      DracoDecoderModule = await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER], 'draco', options, DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER);\n      break;\n    case 'wasm':\n    default:\n      [DracoDecoderModule, wasmBinary] = await Promise.all([await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER], 'draco', options, DRACO_EXTERNAL_LIBRARIES.DECODER), await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER_WASM], 'draco', options, DRACO_EXTERNAL_LIBRARIES.DECODER_WASM)]);\n  }\n  // Depends on how import happened...\n  // @ts-ignore\n  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;\n  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);\n}\nfunction initializeDracoDecoder(DracoDecoderModule, wasmBinary) {\n  const options = {};\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n  return new Promise(resolve => {\n    DracoDecoderModule({\n      ...options,\n      onModuleLoaded: draco => resolve({\n        draco\n      }) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n// ENCODER\nasync function loadDracoEncoder(options) {\n  let DracoEncoderModule = await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.ENCODER], 'draco', options, DRACO_EXTERNAL_LIBRARIES.ENCODER);\n  // @ts-ignore\n  DracoEncoderModule = DracoEncoderModule || globalThis.DracoEncoderModule;\n  return new Promise(resolve => {\n    DracoEncoderModule({\n      onModuleLoaded: draco => resolve({\n        draco\n      }) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}