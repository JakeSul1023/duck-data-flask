{"ast":null,"code":"// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Manager as HammerManager } from \"./hammerjs/index.js\";\nimport { WheelInput } from \"./inputs/wheel-input.js\";\nimport { MoveInput } from \"./inputs/move-input.js\";\nimport { KeyInput } from \"./inputs/key-input.js\";\nimport { ContextmenuInput } from \"./inputs/contextmenu-input.js\";\nimport { EventRegistrar } from \"./utils/event-registrar.js\";\nfunction normalizeRecognizer(item) {\n  if ('recognizer' in item) {\n    return item;\n  }\n  let recognizer;\n  const itemArray = Array.isArray(item) ? [...item] : [item];\n  if (typeof itemArray[0] === 'function') {\n    // Backward compatibility: v2 / hammerjs style\n    const RecognizerType = itemArray.shift();\n    const options = itemArray.shift() || {};\n    recognizer = new RecognizerType(options);\n  } else {\n    recognizer = itemArray.shift();\n  }\n  return {\n    recognizer,\n    recognizeWith: typeof itemArray[0] === 'string' ? [itemArray[0]] : itemArray[0],\n    requireFailure: typeof itemArray[1] === 'string' ? [itemArray[1]] : itemArray[1]\n  };\n}\n// Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\nexport class EventManager {\n  constructor(element = null, options = {}) {\n    /**\n     * Handle basic events using the 'hammer.input' Hammer.js API:\n     * Before running Recognizers, Hammer emits a 'hammer.input' event\n     * with the basic event info. This function emits all basic events\n     * aliased to the \"class\" of event received.\n     * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n     */\n    this._onBasicInput = event => {\n      this.manager.emit(event.srcEvent.type, event);\n    };\n    /**\n     * Handle events not supported by Hammer.js,\n     * and pipe back out through same (Hammer) channel used by other events.\n     */\n    this._onOtherEvent = event => {\n      // console.log('onotherevent', event.type, event)\n      this.manager.emit(event.type, event);\n    };\n    this.options = {\n      recognizers: [],\n      events: {},\n      touchAction: 'compute',\n      tabIndex: 0,\n      cssProps: {},\n      ...options\n    };\n    this.events = new Map();\n    this.element = element;\n    if (!element) return;\n    this.manager = new HammerManager(element, this.options);\n    for (const item of this.options.recognizers) {\n      const {\n        recognizer,\n        recognizeWith,\n        requireFailure\n      } = normalizeRecognizer(item);\n      this.manager.add(recognizer);\n      if (recognizeWith) {\n        recognizer.recognizeWith(recognizeWith);\n      }\n      if (requireFailure) {\n        recognizer.requireFailure(requireFailure);\n      }\n    }\n    this.manager.on('hammer.input', this._onBasicInput);\n    // Handle events not handled by Hammer.js:\n    // - mouse wheel\n    // - pointer/touch/mouse move\n    this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.moveInput = new MoveInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.keyInput = new KeyInput(element, this._onOtherEvent, {\n      enable: false,\n      tabIndex: options.tabIndex\n    });\n    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    // Register all passed events.\n    this.on(this.options.events);\n  }\n  getElement() {\n    return this.element;\n  }\n  // Tear down internal event management implementations.\n  destroy() {\n    // manager etc. cannot exist if there is no element\n    if (!this.element) return;\n    this.wheelInput.destroy();\n    this.moveInput.destroy();\n    this.keyInput.destroy();\n    this.contextmenuInput.destroy();\n    this.manager.destroy();\n  }\n  /** Register an event handler function to be called on `event` */\n  on(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false);\n  }\n  once(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, true);\n  }\n  watch(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false, true);\n  }\n  off(event, handler) {\n    this._removeEventHandler(event, handler);\n  }\n  /*\n   * Enable/disable recognizer for the given event\n   */\n  _toggleRecognizer(name, enabled) {\n    const {\n      manager\n    } = this;\n    if (!manager) {\n      return;\n    }\n    const recognizer = manager.get(name);\n    if (recognizer) {\n      recognizer.set({\n        enable: enabled\n      });\n      manager.touchAction.update();\n    }\n    this.wheelInput?.enableEventType(name, enabled);\n    this.moveInput?.enableEventType(name, enabled);\n    this.keyInput?.enableEventType(name, enabled);\n    this.contextmenuInput?.enableEventType(name, enabled);\n  }\n  /**\n   * Process the event registration for a single event + handler.\n   */\n  _addEventHandler(event, handler, opts, once, passive) {\n    if (typeof event !== 'string') {\n      // @ts-ignore\n      opts = handler;\n      // If `event` is a map, call `on()` for each entry.\n      for (const [eventName, eventHandler] of Object.entries(event)) {\n        this._addEventHandler(eventName, eventHandler, opts, once, passive);\n      }\n      return;\n    }\n    const {\n      manager,\n      events\n    } = this;\n    if (!manager) return;\n    let eventRegistrar = events.get(event);\n    if (!eventRegistrar) {\n      // Enable recognizer for this event.\n      const recognizerName = this._getRecognizerName(event) || event;\n      eventRegistrar = new EventRegistrar(this, recognizerName);\n      events.set(event, eventRegistrar);\n      // Listen to the event\n      if (manager) {\n        manager.on(event, eventRegistrar.handleEvent);\n      }\n    }\n    eventRegistrar.add(event, handler, opts, once, passive);\n    if (!eventRegistrar.isEmpty()) {\n      this._toggleRecognizer(eventRegistrar.recognizerName, true);\n    }\n  }\n  /**\n   * Process the event deregistration for a single event + handler.\n   */\n  _removeEventHandler(event, handler) {\n    if (typeof event !== 'string') {\n      // If `event` is a map, call `off()` for each entry.\n      for (const [eventName, eventHandler] of Object.entries(event)) {\n        this._removeEventHandler(eventName, eventHandler);\n      }\n      return;\n    }\n    const {\n      events\n    } = this;\n    const eventRegistrar = events.get(event);\n    if (!eventRegistrar) {\n      return;\n    }\n    eventRegistrar.remove(event, handler);\n    if (eventRegistrar.isEmpty()) {\n      const {\n        recognizerName\n      } = eventRegistrar;\n      // Disable recognizer if no more handlers are attached to its events\n      let isRecognizerUsed = false;\n      for (const eh of events.values()) {\n        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n          isRecognizerUsed = true;\n          break;\n        }\n      }\n      if (!isRecognizerUsed) {\n        this._toggleRecognizer(recognizerName, false);\n      }\n    }\n  }\n  _getRecognizerName(event) {\n    return this.manager.recognizers.find(recognizer => {\n      return recognizer.getEventNames().includes(event);\n    })?.options.event;\n  }\n}","map":{"version":3,"names":["Manager","HammerManager","WheelInput","MoveInput","KeyInput","ContextmenuInput","EventRegistrar","normalizeRecognizer","item","recognizer","itemArray","Array","isArray","RecognizerType","shift","options","recognizeWith","requireFailure","EventManager","constructor","element","_onBasicInput","event","manager","emit","srcEvent","type","_onOtherEvent","recognizers","events","touchAction","tabIndex","cssProps","Map","add","on","wheelInput","enable","moveInput","keyInput","contextmenuInput","getElement","destroy","handler","opts","_addEventHandler","once","watch","off","_removeEventHandler","_toggleRecognizer","name","enabled","get","set","update","enableEventType","passive","eventName","eventHandler","Object","entries","eventRegistrar","recognizerName","_getRecognizerName","handleEvent","isEmpty","remove","isRecognizerUsed","eh","values","find","getEventNames","includes"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\mjolnir.js\\src\\event-manager.ts"],"sourcesContent":["// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Manager as HammerManager, Recognizer} from './hammerjs/index';\nimport type {\n  MjolnirEventRaw,\n  MjolnirEvent,\n  MjolnirEventHandler,\n  MjolnirEventHandlers\n} from './types';\n\nimport {WheelInput} from './inputs/wheel-input';\nimport {MoveInput} from './inputs/move-input';\nimport {KeyInput} from './inputs/key-input';\nimport {ContextmenuInput} from './inputs/contextmenu-input';\n\nimport {EventRegistrar, HandlerOptions} from './utils/event-registrar';\n\ntype RecognizerConstructor = {new (options: any): Recognizer};\n\ntype RecognizerTupleNormalized = {\n  recognizer: Recognizer;\n  /** Allow another gesture to be recognized simultaneously with this one.\n   * For example an interaction can trigger pinch and rotate at the same time. */\n  recognizeWith?: string[];\n  /** Another recognizer is mutually exclusive with this one.\n   * For example an interaction could be singletap or doubletap; pan-horizontal or pan-vertical; but never both. */\n  requireFailure?: string[];\n};\n\nexport type RecognizerTuple =\n  | Recognizer\n  | RecognizerConstructor\n  | RecognizerTupleNormalized\n  /** hammer.js/mjolnir.js@2 style */\n  | [\n      recognizer: RecognizerConstructor,\n      options?: any,\n      /** Allow another gesture to be recognized simultaneously with this one.\n       * For example an interaction can trigger pinch and rotate at the same time. */\n      recognizeWith?: string | string[],\n      /** Another recognizer is mutually exclusive with this one.\n       * For example an interaction could be singletap or doubletap; pan-horizontal or pan-vertical; but never both. */\n      requireFailure?: string | string[]\n    ];\n\nexport type EventManagerOptions = {\n  /** Event listeners */\n  events?: MjolnirEventHandlers;\n  /** Gesture recognizers */\n  recognizers?: RecognizerTuple[];\n  /** Touch action to set on the target element.\n   * Use 'compute' to automatically set as the least restrictive value to support the recognizers.\n   * https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action\n   * @default 'compute'\n   */\n  touchAction?: 'none' | 'compute' | 'manipulation' | 'pan-x' | 'pan-y' | 'pan-x pan-y';\n  /** Tab index of the target element */\n  tabIndex?: number;\n  /**\n   * Optional CSS properties to be applied to the target element.\n   */\n  cssProps?: Partial<CSSStyleDeclaration>;\n};\n\nfunction normalizeRecognizer(item: RecognizerTuple): RecognizerTupleNormalized {\n  if ('recognizer' in item) {\n    return item;\n  }\n  let recognizer: Recognizer;\n  const itemArray = Array.isArray(item) ? [...item] : [item];\n  if (typeof itemArray[0] === 'function') {\n    // Backward compatibility: v2 / hammerjs style\n    const RecognizerType = itemArray.shift();\n    const options = itemArray.shift() || {};\n    recognizer = new RecognizerType(options);\n  } else {\n    recognizer = itemArray.shift();\n  }\n  return {\n    recognizer,\n    recognizeWith: typeof itemArray[0] === 'string' ? [itemArray[0]] : itemArray[0],\n    requireFailure: typeof itemArray[1] === 'string' ? [itemArray[1]] : itemArray[1]\n  };\n}\n\n// Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\nexport class EventManager {\n  private element: HTMLElement | null;\n  private manager: HammerManager;\n  private options: Required<EventManagerOptions>;\n  private events: Map<string, EventRegistrar>;\n\n  // Custom handlers\n  private wheelInput: WheelInput;\n  private moveInput: MoveInput;\n  private contextmenuInput: ContextmenuInput;\n  private keyInput: KeyInput;\n\n  constructor(element: HTMLElement | null = null, options: EventManagerOptions = {}) {\n    this.options = {\n      recognizers: [],\n      events: {},\n      touchAction: 'compute',\n      tabIndex: 0,\n      cssProps: {},\n      ...options\n    };\n    this.events = new Map();\n    this.element = element;\n\n    if (!element) return;\n\n    this.manager = new HammerManager(element, this.options);\n    for (const item of this.options.recognizers) {\n      const {recognizer, recognizeWith, requireFailure} = normalizeRecognizer(item);\n      this.manager.add(recognizer);\n      if (recognizeWith) {\n        recognizer.recognizeWith(recognizeWith);\n      }\n      if (requireFailure) {\n        recognizer.requireFailure(requireFailure);\n      }\n    }\n\n    this.manager.on('hammer.input', this._onBasicInput);\n\n    // Handle events not handled by Hammer.js:\n    // - mouse wheel\n    // - pointer/touch/mouse move\n    this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.moveInput = new MoveInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.keyInput = new KeyInput(element, this._onOtherEvent, {\n      enable: false,\n      tabIndex: options.tabIndex\n    });\n    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n      enable: false\n    });\n\n    // Register all passed events.\n    this.on(this.options.events);\n  }\n\n  getElement(): HTMLElement | null {\n    return this.element;\n  }\n\n  // Tear down internal event management implementations.\n  destroy(): void {\n    // manager etc. cannot exist if there is no element\n    if (!this.element) return;\n\n    this.wheelInput.destroy();\n    this.moveInput.destroy();\n    this.keyInput.destroy();\n    this.contextmenuInput.destroy();\n    this.manager.destroy();\n  }\n\n  /** Register multiple event handlers */\n  on(events: MjolnirEventHandlers, opts?: HandlerOptions): void;\n  on<EventT extends MjolnirEvent>(\n    event: EventT['type'],\n    handler: (ev: EventT) => void,\n    opts?: HandlerOptions\n  ): void;\n\n  /** Register an event handler function to be called on `event` */\n  on(event: any, handler: any, opts?: any) {\n    this._addEventHandler(event, handler, opts, false);\n  }\n\n  /** Register an event handler function to be called on `event`, then remove it */\n  once(events: MjolnirEventHandlers, opts?: HandlerOptions): void;\n  once<EventT extends MjolnirEvent>(\n    event: EventT['type'],\n    handler: (ev: EventT) => void,\n    opts?: HandlerOptions\n  ): void;\n\n  once(event: any, handler: any, opts?: any) {\n    this._addEventHandler(event, handler, opts, true);\n  }\n\n  /** Register an event handler function to be called on `event`\n   * This handler does not ask the event to be recognized at all times.\n   * Instead, it only \"intercepts\" the event if some other handler is getting it.\n   */\n  watch(events: MjolnirEventHandlers, opts?: HandlerOptions): void;\n  watch<EventT extends MjolnirEvent>(\n    event: EventT['type'],\n    handler: (ev: EventT) => void,\n    opts?: HandlerOptions\n  ): void;\n\n  watch(event: any, handler: any, opts?: any) {\n    this._addEventHandler(event, handler, opts, false, true);\n  }\n\n  /**\n   * Deregister a previously-registered event handler.\n   */\n  off(events: MjolnirEventHandlers): void;\n  off<EventT extends MjolnirEvent>(event: EventT['type'], handler: (ev: EventT) => void): void;\n\n  off(event: any, handler?: any) {\n    this._removeEventHandler(event, handler);\n  }\n\n  /*\n   * Enable/disable recognizer for the given event\n   */\n  private _toggleRecognizer(name: string, enabled: boolean): void {\n    const {manager} = this;\n    if (!manager) {\n      return;\n    }\n    const recognizer = manager.get(name);\n    if (recognizer) {\n      recognizer.set({enable: enabled});\n      manager.touchAction.update();\n    }\n    this.wheelInput?.enableEventType(name, enabled);\n    this.moveInput?.enableEventType(name, enabled);\n    this.keyInput?.enableEventType(name, enabled);\n    this.contextmenuInput?.enableEventType(name, enabled);\n  }\n\n  /**\n   * Process the event registration for a single event + handler.\n   */\n  private _addEventHandler(\n    event: string | MjolnirEventHandlers,\n    handler: MjolnirEventHandler,\n    opts?: HandlerOptions,\n    once?: boolean,\n    passive?: boolean\n  ) {\n    if (typeof event !== 'string') {\n      // @ts-ignore\n      opts = handler;\n      // If `event` is a map, call `on()` for each entry.\n      for (const [eventName, eventHandler] of Object.entries(event)) {\n        this._addEventHandler(eventName, eventHandler, opts, once, passive);\n      }\n      return;\n    }\n\n    const {manager, events} = this;\n    if (!manager) return;\n\n    let eventRegistrar = events.get(event);\n    if (!eventRegistrar) {\n      // Enable recognizer for this event.\n      const recognizerName = this._getRecognizerName(event) || event;\n\n      eventRegistrar = new EventRegistrar(this, recognizerName);\n      events.set(event, eventRegistrar);\n      // Listen to the event\n      if (manager) {\n        manager.on(event, eventRegistrar.handleEvent);\n      }\n    }\n    eventRegistrar.add(event, handler, opts, once, passive);\n    if (!eventRegistrar.isEmpty()) {\n      this._toggleRecognizer(eventRegistrar.recognizerName, true);\n    }\n  }\n\n  /**\n   * Process the event deregistration for a single event + handler.\n   */\n  private _removeEventHandler(event: string | MjolnirEventHandlers, handler?: MjolnirEventHandler) {\n    if (typeof event !== 'string') {\n      // If `event` is a map, call `off()` for each entry.\n      for (const [eventName, eventHandler] of Object.entries(event)) {\n        this._removeEventHandler(eventName, eventHandler);\n      }\n      return;\n    }\n\n    const {events} = this;\n\n    const eventRegistrar = events.get(event);\n\n    if (!eventRegistrar) {\n      return;\n    }\n\n    eventRegistrar.remove(event, handler!);\n\n    if (eventRegistrar.isEmpty()) {\n      const {recognizerName} = eventRegistrar;\n      // Disable recognizer if no more handlers are attached to its events\n      let isRecognizerUsed = false;\n      for (const eh of events.values()) {\n        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n          isRecognizerUsed = true;\n          break;\n        }\n      }\n      if (!isRecognizerUsed) {\n        this._toggleRecognizer(recognizerName, false);\n      }\n    }\n  }\n\n  private _getRecognizerName(event: string): string | undefined {\n    return this.manager.recognizers.find((recognizer) => {\n      return recognizer.getEventNames().includes(event);\n    })?.options.event;\n  }\n\n  /**\n   * Handle basic events using the 'hammer.input' Hammer.js API:\n   * Before running Recognizers, Hammer emits a 'hammer.input' event\n   * with the basic event info. This function emits all basic events\n   * aliased to the \"class\" of event received.\n   * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n   */\n  private _onBasicInput = (event: MjolnirEventRaw) => {\n    this.manager.emit(event.srcEvent.type, event as any);\n  };\n\n  /**\n   * Handle events not supported by Hammer.js,\n   * and pipe back out through same (Hammer) channel used by other events.\n   */\n  private _onOtherEvent = (event: MjolnirEventRaw) => {\n    // console.log('onotherevent', event.type, event)\n    this.manager.emit(event.type, event as any);\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}