{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport LayerManager from \"./layer-manager.js\";\nimport ViewManager from \"./view-manager.js\";\nimport MapView from \"../views/map-view.js\";\nimport EffectManager from \"./effect-manager.js\";\nimport DeckRenderer from \"./deck-renderer.js\";\nimport DeckPicker from \"./deck-picker.js\";\nimport { WidgetManager } from \"./widget-manager.js\";\nimport Tooltip from \"./tooltip.js\";\nimport log from \"../utils/log.js\";\nimport { deepEqual } from \"../utils/deep-equal.js\";\nimport typedArrayManager from \"../utils/typed-array-manager.js\";\nimport { VERSION } from \"./init.js\";\nimport { luma } from '@luma.gl/core';\nimport { webgl2Adapter } from '@luma.gl/webgl';\nimport { Timeline } from '@luma.gl/engine';\nimport { AnimationLoop } from '@luma.gl/engine';\nimport { GL } from '@luma.gl/constants';\nimport { Stats } from '@probe.gl/stats';\nimport { EventManager } from 'mjolnir.js';\nimport assert from \"../utils/assert.js\";\nimport { EVENT_HANDLERS, RECOGNIZERS } from \"./constants.js\";\n/* global document */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\nconst getCursor = ({\n  isDragging\n}) => isDragging ? 'grabbing' : 'grab';\nconst defaultProps = {\n  id: '',\n  width: '100%',\n  height: '100%',\n  style: null,\n  viewState: null,\n  initialViewState: null,\n  pickingRadius: 0,\n  layerFilter: null,\n  parameters: {},\n  parent: null,\n  device: null,\n  deviceProps: {},\n  gl: null,\n  canvas: null,\n  layers: [],\n  effects: [],\n  views: null,\n  controller: null,\n  // Rely on external controller, e.g. react-map-gl\n  useDevicePixels: true,\n  touchAction: 'none',\n  eventRecognizerOptions: {},\n  _framebuffer: null,\n  _animate: false,\n  _pickable: true,\n  _typedArrayManagerProps: {},\n  _customRender: null,\n  widgets: [],\n  onDeviceInitialized: noop,\n  onWebGLInitialized: noop,\n  onResize: noop,\n  onViewStateChange: noop,\n  onInteractionStateChange: noop,\n  onBeforeRender: noop,\n  onAfterRender: noop,\n  onLoad: noop,\n  onError: error => log.error(error.message, error.cause)(),\n  onHover: null,\n  onClick: null,\n  onDragStart: null,\n  onDrag: null,\n  onDragEnd: null,\n  _onMetrics: null,\n  getCursor,\n  getTooltip: null,\n  debug: false,\n  drawPickingColors: false\n};\n/* eslint-disable max-statements */\nclass Deck {\n  constructor(props) {\n    this.width = 0;\n    this.height = 0;\n    // Allows attaching arbitrary data to the instance\n    this.userData = {};\n    this.device = null;\n    this.canvas = null;\n    this.viewManager = null;\n    this.layerManager = null;\n    this.effectManager = null;\n    this.deckRenderer = null;\n    this.deckPicker = null;\n    this.eventManager = null;\n    this.widgetManager = null;\n    this.tooltip = null;\n    this.animationLoop = null;\n    this.cursorState = {\n      isHovering: false,\n      isDragging: false\n    };\n    this.stats = new Stats({\n      id: 'deck.gl'\n    });\n    this.metrics = {\n      fps: 0,\n      setPropsTime: 0,\n      updateAttributesTime: 0,\n      framesRedrawn: 0,\n      pickTime: 0,\n      pickCount: 0,\n      gpuTime: 0,\n      gpuTimePerFrame: 0,\n      cpuTime: 0,\n      cpuTimePerFrame: 0,\n      bufferMemory: 0,\n      textureMemory: 0,\n      renderbufferMemory: 0,\n      gpuMemory: 0\n    };\n    this._metricsCounter = 0;\n    this._needsRedraw = 'Initial render';\n    this._pickRequest = {\n      mode: 'hover',\n      x: -1,\n      y: -1,\n      radius: 0,\n      event: null\n    };\n    /**\n     * Pick and store the object under the pointer on `pointerdown`.\n     * This object is reused for subsequent `onClick` and `onDrag*` callbacks.\n     */\n    this._lastPointerDownInfo = null;\n    // The `pointermove` event may fire multiple times in between two animation frames,\n    // it's a waste of time to run picking without rerender. Instead we save the last pick\n    // request and only do it once on the next animation frame.\n    /** Internal use only: event handler for pointerdown */\n    this._onPointerMove = event => {\n      const {\n        _pickRequest\n      } = this;\n      if (event.type === 'pointerleave') {\n        _pickRequest.x = -1;\n        _pickRequest.y = -1;\n        _pickRequest.radius = 0;\n      } else if (event.leftButton || event.rightButton) {\n        // Do not trigger onHover callbacks if mouse button is down.\n        return;\n      } else {\n        const pos = event.offsetCenter;\n        // Do not trigger callbacks when click/hover position is invalid. Doing so will cause a\n        // assertion error when attempting to unproject the position.\n        if (!pos) {\n          return;\n        }\n        _pickRequest.x = pos.x;\n        _pickRequest.y = pos.y;\n        _pickRequest.radius = this.props.pickingRadius;\n      }\n      if (this.layerManager) {\n        this.layerManager.context.mousePosition = {\n          x: _pickRequest.x,\n          y: _pickRequest.y\n        };\n      }\n      _pickRequest.event = event;\n    };\n    /** Internal use only: event handler for click & drag */\n    this._onEvent = event => {\n      const eventHandlerProp = EVENT_HANDLERS[event.type];\n      const pos = event.offsetCenter;\n      if (!eventHandlerProp || !pos || !this.layerManager) {\n        return;\n      }\n      // Reuse last picked object\n      const layers = this.layerManager.getLayers();\n      const info = this.deckPicker.getLastPickedObject({\n        x: pos.x,\n        y: pos.y,\n        layers,\n        viewports: this.getViewports(pos)\n      }, this._lastPointerDownInfo);\n      const {\n        layer\n      } = info;\n      const layerHandler = layer && (layer[eventHandlerProp] || layer.props[eventHandlerProp]);\n      const rootHandler = this.props[eventHandlerProp];\n      let handled = false;\n      if (layerHandler) {\n        handled = layerHandler.call(layer, info, event);\n      }\n      if (!handled) {\n        rootHandler?.(info, event);\n        this.widgetManager.onEvent(info, event);\n      }\n    };\n    /** Internal use only: evnet handler for pointerdown */\n    this._onPointerDown = event => {\n      // TODO(ibgreen) Picking not yet supported on WebGPU\n      if (this.device?.type === 'webgpu') {\n        return;\n      }\n      const pos = event.offsetCenter;\n      const pickedInfo = this._pick('pickObject', 'pickObject Time', {\n        x: pos.x,\n        y: pos.y,\n        radius: this.props.pickingRadius\n      });\n      this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;\n    };\n    // @ts-ignore views\n    this.props = {\n      ...defaultProps,\n      ...props\n    };\n    props = this.props;\n    if (props.viewState && props.initialViewState) {\n      log.warn('View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.')();\n    }\n    this.viewState = this.props.initialViewState;\n    // See if we already have a device\n    if (props.device) {\n      this.device = props.device;\n    }\n    let deviceOrPromise = this.device;\n    // Attach a new luma.gl device to a WebGL2 context if supplied\n    if (!deviceOrPromise && props.gl) {\n      if (props.gl instanceof WebGLRenderingContext) {\n        log.error('WebGL1 context not supported.')();\n      }\n      deviceOrPromise = webgl2Adapter.attach(props.gl);\n    }\n    // Create a new device\n    if (!deviceOrPromise) {\n      // Create the \"best\" device supported from the registered adapters\n      deviceOrPromise = luma.createDevice({\n        type: 'best-available',\n        // luma by default throws if a device is already attached\n        // asynchronous device creation could happen after finalize() is called\n        // TODO - createDevice should support AbortController?\n        _reuseDevices: true,\n        adapters: [webgl2Adapter],\n        ...props.deviceProps,\n        createCanvasContext: {\n          canvas: this._createCanvas(props),\n          useDevicePixels: this.props.useDevicePixels,\n          // TODO v9.2 - replace AnimationLoop's `autoResizeDrawingBuffer` with CanvasContext's `autoResize`\n          autoResize: false\n        }\n      });\n    }\n    this.animationLoop = this._createAnimationLoop(deviceOrPromise, props);\n    this.setProps(props);\n    // UNSAFE/experimental prop: only set at initialization to avoid performance hit\n    if (props._typedArrayManagerProps) {\n      typedArrayManager.setOptions(props._typedArrayManagerProps);\n    }\n    this.animationLoop.start();\n  }\n  /** Stop rendering and dispose all resources */\n  finalize() {\n    this.animationLoop?.stop();\n    this.animationLoop?.destroy();\n    this.animationLoop = null;\n    this._lastPointerDownInfo = null;\n    this.layerManager?.finalize();\n    this.layerManager = null;\n    this.viewManager?.finalize();\n    this.viewManager = null;\n    this.effectManager?.finalize();\n    this.effectManager = null;\n    this.deckRenderer?.finalize();\n    this.deckRenderer = null;\n    this.deckPicker?.finalize();\n    this.deckPicker = null;\n    this.eventManager?.destroy();\n    this.eventManager = null;\n    this.widgetManager?.finalize();\n    this.widgetManager = null;\n    if (!this.props.canvas && !this.props.device && !this.props.gl && this.canvas) {\n      // remove internally created canvas\n      this.canvas.parentElement?.removeChild(this.canvas);\n      this.canvas = null;\n    }\n  }\n  /** Partially update props */\n  setProps(props) {\n    this.stats.get('setProps Time').timeStart();\n    if ('onLayerHover' in props) {\n      log.removed('onLayerHover', 'onHover')();\n    }\n    if ('onLayerClick' in props) {\n      log.removed('onLayerClick', 'onClick')();\n    }\n    if (props.initialViewState &&\n    // depth = 3 when comparing viewStates: viewId.position.0\n    !deepEqual(this.props.initialViewState, props.initialViewState, 3)) {\n      // Overwrite internal view state\n      this.viewState = props.initialViewState;\n    }\n    // Merge with existing props\n    Object.assign(this.props, props);\n    // Update CSS size of canvas\n    this._setCanvasSize(this.props);\n    // We need to overwrite CSS style width and height with actual, numeric values\n    const resolvedProps = Object.create(this.props);\n    Object.assign(resolvedProps, {\n      views: this._getViews(),\n      width: this.width,\n      height: this.height,\n      viewState: this._getViewState()\n    });\n    // Update the animation loop\n    this.animationLoop?.setProps(resolvedProps);\n    // If initialized, update sub manager props\n    if (this.layerManager) {\n      this.viewManager.setProps(resolvedProps);\n      // Make sure that any new layer gets initialized with the current viewport\n      this.layerManager.activateViewport(this.getViewports()[0]);\n      this.layerManager.setProps(resolvedProps);\n      this.effectManager.setProps(resolvedProps);\n      this.deckRenderer.setProps(resolvedProps);\n      this.deckPicker.setProps(resolvedProps);\n      this.widgetManager.setProps(resolvedProps);\n    }\n    this.stats.get('setProps Time').timeEnd();\n  }\n  // Public API\n  /**\n   * Check if a redraw is needed\n   * @returns `false` or a string summarizing the redraw reason\n   */\n  needsRedraw(opts = {\n    clearRedrawFlags: false\n  }) {\n    if (!this.layerManager) {\n      // Not initialized or already finalized\n      return false;\n    }\n    if (this.props._animate) {\n      return 'Deck._animate';\n    }\n    let redraw = this._needsRedraw;\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n    const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);\n    const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);\n    const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);\n    const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);\n    redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;\n    return redraw;\n  }\n  /**\n   * Redraw the GL context\n   * @param reason If not provided, only redraw if deemed necessary. Otherwise redraw regardless of internal states.\n   * @returns\n   */\n  redraw(reason) {\n    if (!this.layerManager) {\n      // Not yet initialized\n      return;\n    }\n    // Check if we need to redraw\n    let redrawReason = this.needsRedraw({\n      clearRedrawFlags: true\n    });\n    // User-supplied should take precedent, however the redraw flags get cleared regardless\n    redrawReason = reason || redrawReason;\n    if (!redrawReason) {\n      return;\n    }\n    this.stats.get('Redraw Count').incrementCount();\n    if (this.props._customRender) {\n      this.props._customRender(redrawReason);\n    } else {\n      this._drawLayers(redrawReason);\n    }\n  }\n  /** Flag indicating that the Deck instance has initialized its resources and it's safe to call public methods. */\n  get isInitialized() {\n    return this.viewManager !== null;\n  }\n  /** Get a list of views that are currently rendered */\n  getViews() {\n    assert(this.viewManager);\n    return this.viewManager.views;\n  }\n  /** Get a list of viewports that are currently rendered.\n   * @param rect If provided, only returns viewports within the given bounding box.\n   */\n  getViewports(rect) {\n    assert(this.viewManager);\n    return this.viewManager.getViewports(rect);\n  }\n  /** Get the current canvas element. */\n  getCanvas() {\n    return this.canvas;\n  }\n  /** Query the object rendered on top at a given point */\n  pickObject(opts) {\n    const infos = this._pick('pickObject', 'pickObject Time', opts).result;\n    return infos.length ? infos[0] : null;\n  }\n  /* Query all rendered objects at a given point */\n  pickMultipleObjects(opts) {\n    opts.depth = opts.depth || 10;\n    return this._pick('pickObject', 'pickMultipleObjects Time', opts).result;\n  }\n  /* Query all objects rendered on top within a bounding box */\n  pickObjects(opts) {\n    return this._pick('pickObjects', 'pickObjects Time', opts);\n  }\n  /** Experimental\n   * Add a global resource for sharing among layers\n   */\n  _addResources(resources, forceUpdate = false) {\n    for (const id in resources) {\n      this.layerManager.resourceManager.add({\n        resourceId: id,\n        data: resources[id],\n        forceUpdate\n      });\n    }\n  }\n  /** Experimental\n   * Remove a global resource\n   */\n  _removeResources(resourceIds) {\n    for (const id of resourceIds) {\n      this.layerManager.resourceManager.remove(id);\n    }\n  }\n  /** Experimental\n   * Register a default effect. Effects will be sorted by order, those with a low order will be rendered first\n   */\n  _addDefaultEffect(effect) {\n    this.effectManager.addDefaultEffect(effect);\n  }\n  _addDefaultShaderModule(module) {\n    this.layerManager.addDefaultShaderModule(module);\n  }\n  _removeDefaultShaderModule(module) {\n    this.layerManager?.removeDefaultShaderModule(module);\n  }\n  _pick(method, statKey, opts) {\n    assert(this.deckPicker);\n    const {\n      stats\n    } = this;\n    stats.get('Pick Count').incrementCount();\n    stats.get(statKey).timeStart();\n    const infos = this.deckPicker[method]({\n      // layerManager, viewManager and effectManager are always defined if deckPicker is\n      layers: this.layerManager.getLayers(opts),\n      views: this.viewManager.getViews(),\n      viewports: this.getViewports(opts),\n      onViewportActive: this.layerManager.activateViewport,\n      effects: this.effectManager.getEffects(),\n      ...opts\n    });\n    stats.get(statKey).timeEnd();\n    return infos;\n  }\n  /** Resolve props.canvas to element */\n  _createCanvas(props) {\n    let canvas = props.canvas;\n    // TODO EventManager should accept element id\n    if (typeof canvas === 'string') {\n      canvas = document.getElementById(canvas);\n      assert(canvas);\n    }\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      canvas.id = props.id || 'deckgl-overlay';\n      const parent = props.parent || document.body;\n      parent.appendChild(canvas);\n    }\n    Object.assign(canvas.style, props.style);\n    return canvas;\n  }\n  /** Updates canvas width and/or height, if provided as props */\n  _setCanvasSize(props) {\n    if (!this.canvas) {\n      return;\n    }\n    const {\n      width,\n      height\n    } = props;\n    // Set size ONLY if props are being provided, otherwise let canvas be layouted freely\n    if (width || width === 0) {\n      const cssWidth = Number.isFinite(width) ? `${width}px` : width;\n      this.canvas.style.width = cssWidth;\n    }\n    if (height || height === 0) {\n      const cssHeight = Number.isFinite(height) ? `${height}px` : height;\n      // Note: position==='absolute' required for height 100% to work\n      this.canvas.style.position = props.style?.position || 'absolute';\n      this.canvas.style.height = cssHeight;\n    }\n  }\n  /** If canvas size has changed, reads out the new size and update */\n  _updateCanvasSize() {\n    const {\n      canvas\n    } = this;\n    if (!canvas) {\n      return;\n    }\n    // Fallback to width/height when clientWidth/clientHeight are undefined (OffscreenCanvas).\n    const newWidth = canvas.clientWidth ?? canvas.width;\n    const newHeight = canvas.clientHeight ?? canvas.height;\n    if (newWidth !== this.width || newHeight !== this.height) {\n      // @ts-expect-error private assign to read-only property\n      this.width = newWidth;\n      // @ts-expect-error private assign to read-only property\n      this.height = newHeight;\n      this.viewManager?.setProps({\n        width: newWidth,\n        height: newHeight\n      });\n      // Make sure that any new layer gets initialized with the current viewport\n      this.layerManager?.activateViewport(this.getViewports()[0]);\n      this.props.onResize({\n        width: newWidth,\n        height: newHeight\n      });\n    }\n  }\n  _createAnimationLoop(deviceOrPromise, props) {\n    const {\n      // width,\n      // height,\n      gl,\n      // debug,\n      onError,\n      // onBeforeRender,\n      // onAfterRender,\n      useDevicePixels\n    } = props;\n    return new AnimationLoop({\n      device: deviceOrPromise,\n      useDevicePixels,\n      // TODO v9\n      autoResizeDrawingBuffer: !gl,\n      // do not auto resize external context\n      autoResizeViewport: false,\n      // @ts-expect-error luma.gl needs to accept Promise<void> return value\n      onInitialize: context => this._setDevice(context.device),\n      onRender: this._onRenderFrame.bind(this),\n      // @ts-expect-error typing mismatch: AnimationLoop does not accept onError:null\n      onError\n      // onBeforeRender,\n      // onAfterRender,\n    });\n  }\n  // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState\n  // TODO: For backwards compatibility ensure numeric width and height is added to the viewState\n  _getViewState() {\n    return this.props.viewState || this.viewState;\n  }\n  // Get the view descriptor list\n  _getViews() {\n    const {\n      views\n    } = this.props;\n    const normalizedViews = Array.isArray(views) ? views :\n    // If null, default to a full screen map view port\n    views ? [views] : [new MapView({\n      id: 'default-view'\n    })];\n    if (normalizedViews.length && this.props.controller) {\n      // Backward compatibility: support controller prop\n      normalizedViews[0].props.controller = this.props.controller;\n    }\n    return normalizedViews;\n  }\n  _onContextLost() {\n    const {\n      onError\n    } = this.props;\n    if (this.animationLoop && onError) {\n      onError(new Error('WebGL context is lost'));\n    }\n  }\n  /** Actually run picking */\n  _pickAndCallback() {\n    if (this.device?.type === 'webgpu') {\n      return;\n    }\n    const {\n      _pickRequest\n    } = this;\n    if (_pickRequest.event) {\n      // Perform picking\n      const {\n        result,\n        emptyInfo\n      } = this._pick('pickObject', 'pickObject Time', _pickRequest);\n      this.cursorState.isHovering = result.length > 0;\n      // There are 4 possible scenarios:\n      // result is [outInfo, pickedInfo] (moved from one pickable layer to another)\n      // result is [outInfo] (moved outside of a pickable layer)\n      // result is [pickedInfo] (moved into or over a pickable layer)\n      // result is [] (nothing is or was picked)\n      //\n      // `layer.props.onHover` should be called on all affected layers (out/over)\n      // `deck.props.onHover` should be called with the picked info if any, or empty info otherwise\n      // `deck.props.getTooltip` should be called with the picked info if any, or empty info otherwise\n      // Execute callbacks\n      let pickedInfo = emptyInfo;\n      let handled = false;\n      for (const info of result) {\n        pickedInfo = info;\n        handled = info.layer?.onHover(info, _pickRequest.event) || handled;\n      }\n      if (!handled) {\n        this.props.onHover?.(pickedInfo, _pickRequest.event);\n        this.widgetManager.onHover(pickedInfo, _pickRequest.event);\n      }\n      // Clear pending pickRequest\n      _pickRequest.event = null;\n    }\n  }\n  _updateCursor() {\n    const container = this.props.parent || this.canvas;\n    if (container) {\n      container.style.cursor = this.props.getCursor(this.cursorState);\n    }\n  }\n  _setDevice(device) {\n    this.device = device;\n    if (!this.animationLoop) {\n      // finalize() has been called\n      return;\n    }\n    // if external context...\n    if (!this.canvas) {\n      this.canvas = this.device.canvasContext?.canvas;\n      // TODO v9\n      // ts-expect-error - Currently luma.gl v9 does not expose these options\n      // All WebGLDevice contexts are instrumented, but it seems the device\n      // should have a method to start state tracking even if not enabled?\n      // instrumentGLContext(this.device.gl, {enable: true, copyState: true});\n    }\n    if (this.device.type === 'webgl') {\n      this.device.setParametersWebGL({\n        blend: true,\n        blendFunc: [770, 771, 1, 771],\n        polygonOffsetFill: true,\n        depthTest: true,\n        depthFunc: 515\n      });\n    }\n    this.props.onDeviceInitialized(this.device);\n    if (this.device.type === 'webgl') {\n      // Legacy callback - warn?\n      // @ts-expect-error gl is not visible on Device base class\n      this.props.onWebGLInitialized(this.device.gl);\n    }\n    // timeline for transitions\n    const timeline = new Timeline();\n    timeline.play();\n    this.animationLoop.attachTimeline(timeline);\n    this.eventManager = new EventManager(this.props.parent || this.canvas, {\n      touchAction: this.props.touchAction,\n      recognizers: Object.keys(RECOGNIZERS).map(eventName => {\n        // Resolve recognizer settings\n        const [RecognizerConstructor, defaultOptions, recognizeWith, requestFailure] = RECOGNIZERS[eventName];\n        const optionsOverride = this.props.eventRecognizerOptions?.[eventName];\n        const options = {\n          ...defaultOptions,\n          ...optionsOverride,\n          event: eventName\n        };\n        return {\n          recognizer: new RecognizerConstructor(options),\n          recognizeWith,\n          requestFailure\n        };\n      }),\n      events: {\n        pointerdown: this._onPointerDown,\n        pointermove: this._onPointerMove,\n        pointerleave: this._onPointerMove\n      }\n    });\n    for (const eventType in EVENT_HANDLERS) {\n      this.eventManager.on(eventType, this._onEvent);\n    }\n    this.viewManager = new ViewManager({\n      timeline,\n      eventManager: this.eventManager,\n      onViewStateChange: this._onViewStateChange.bind(this),\n      onInteractionStateChange: this._onInteractionStateChange.bind(this),\n      views: this._getViews(),\n      viewState: this._getViewState(),\n      width: this.width,\n      height: this.height\n    });\n    // viewManager must be initialized before layerManager\n    // layerManager depends on viewport created by viewManager.\n    const viewport = this.viewManager.getViewports()[0];\n    // Note: avoid React setState due GL animation loop / setState timing issue\n    this.layerManager = new LayerManager(this.device, {\n      deck: this,\n      stats: this.stats,\n      viewport,\n      timeline\n    });\n    this.effectManager = new EffectManager({\n      deck: this,\n      device: this.device\n    });\n    this.deckRenderer = new DeckRenderer(this.device);\n    this.deckPicker = new DeckPicker(this.device);\n    this.widgetManager = new WidgetManager({\n      deck: this,\n      parentElement: this.canvas?.parentElement\n    });\n    this.widgetManager.addDefault(new Tooltip());\n    this.setProps(this.props);\n    this._updateCanvasSize();\n    this.props.onLoad();\n  }\n  /** Internal only: default render function (redraw all layers and views) */\n  _drawLayers(redrawReason, renderOptions) {\n    const {\n      device,\n      gl\n    } = this.layerManager.context;\n    this.props.onBeforeRender({\n      device,\n      gl\n    });\n    const opts = {\n      target: this.props._framebuffer,\n      layers: this.layerManager.getLayers(),\n      viewports: this.viewManager.getViewports(),\n      onViewportActive: this.layerManager.activateViewport,\n      views: this.viewManager.getViews(),\n      pass: 'screen',\n      effects: this.effectManager.getEffects(),\n      ...renderOptions\n    };\n    this.deckRenderer?.renderLayers(opts);\n    if (opts.pass === 'screen') {\n      // This method could be called when drawing to picking buffer, texture etc.\n      // Only when drawing to screen, update all widgets (UI components)\n      this.widgetManager.onRedraw({\n        viewports: opts.viewports,\n        layers: opts.layers\n      });\n    }\n    this.props.onAfterRender({\n      device,\n      gl\n    });\n  }\n  // Callbacks\n  _onRenderFrame() {\n    this._getFrameStats();\n    // Log perf stats every second\n    if (this._metricsCounter++ % 60 === 0) {\n      this._getMetrics();\n      this.stats.reset();\n      log.table(4, this.metrics)();\n      // Experimental: report metrics\n      if (this.props._onMetrics) {\n        this.props._onMetrics(this.metrics);\n      }\n    }\n    this._updateCanvasSize();\n    this._updateCursor();\n    // Update layers if needed (e.g. some async prop has loaded)\n    // Note: This can trigger a redraw\n    this.layerManager.updateLayers();\n    // Perform picking request if any\n    // TODO(ibgreen): Picking not yet supported on WebGPU\n    if (this.device?.type !== 'webgpu') {\n      this._pickAndCallback();\n    }\n    // Redraw if necessary\n    this.redraw();\n    // Update viewport transition if needed\n    // Note: this can trigger `onViewStateChange`, and affect layers\n    // We want to defer these changes to the next frame\n    if (this.viewManager) {\n      this.viewManager.updateViewStates();\n    }\n  }\n  // Callbacks\n  _onViewStateChange(params) {\n    // Let app know that view state is changing, and give it a chance to change it\n    const viewState = this.props.onViewStateChange(params) || params.viewState;\n    // If initialViewState was set on creation, auto track position\n    if (this.viewState) {\n      this.viewState = {\n        ...this.viewState,\n        [params.viewId]: viewState\n      };\n      if (!this.props.viewState) {\n        // Apply internal view state\n        if (this.viewManager) {\n          this.viewManager.setProps({\n            viewState: this.viewState\n          });\n        }\n      }\n    }\n  }\n  _onInteractionStateChange(interactionState) {\n    this.cursorState.isDragging = interactionState.isDragging || false;\n    this.props.onInteractionStateChange(interactionState);\n  }\n  _getFrameStats() {\n    const {\n      stats\n    } = this;\n    stats.get('frameRate').timeEnd();\n    stats.get('frameRate').timeStart();\n    // Get individual stats from luma.gl so reset works\n    const animationLoopStats = this.animationLoop.stats;\n    stats.get('GPU Time').addTime(animationLoopStats.get('GPU Time').lastTiming);\n    stats.get('CPU Time').addTime(animationLoopStats.get('CPU Time').lastTiming);\n  }\n  _getMetrics() {\n    const {\n      metrics,\n      stats\n    } = this;\n    metrics.fps = stats.get('frameRate').getHz();\n    metrics.setPropsTime = stats.get('setProps Time').time;\n    metrics.updateAttributesTime = stats.get('Update Attributes').time;\n    metrics.framesRedrawn = stats.get('Redraw Count').count;\n    metrics.pickTime = stats.get('pickObject Time').time + stats.get('pickMultipleObjects Time').time + stats.get('pickObjects Time').time;\n    metrics.pickCount = stats.get('Pick Count').count;\n    // Luma stats\n    metrics.gpuTime = stats.get('GPU Time').time;\n    metrics.cpuTime = stats.get('CPU Time').time;\n    metrics.gpuTimePerFrame = stats.get('GPU Time').getAverageTime();\n    metrics.cpuTimePerFrame = stats.get('CPU Time').getAverageTime();\n    const memoryStats = luma.stats.get('Memory Usage');\n    metrics.bufferMemory = memoryStats.get('Buffer Memory').count;\n    metrics.textureMemory = memoryStats.get('Texture Memory').count;\n    metrics.renderbufferMemory = memoryStats.get('Renderbuffer Memory').count;\n    metrics.gpuMemory = memoryStats.get('GPU Memory').count;\n  }\n}\nDeck.defaultProps = defaultProps;\n// This is used to defeat tree shaking of init.js\n// https://github.com/visgl/deck.gl/issues/3213\nDeck.VERSION = VERSION;\nexport default Deck;","map":{"version":3,"names":["LayerManager","ViewManager","MapView","EffectManager","DeckRenderer","DeckPicker","WidgetManager","Tooltip","log","deepEqual","typedArrayManager","VERSION","luma","webgl2Adapter","Timeline","AnimationLoop","GL","Stats","EventManager","assert","EVENT_HANDLERS","RECOGNIZERS","noop","getCursor","isDragging","defaultProps","id","width","height","style","viewState","initialViewState","pickingRadius","layerFilter","parameters","parent","device","deviceProps","gl","canvas","layers","effects","views","controller","useDevicePixels","touchAction","eventRecognizerOptions","_framebuffer","_animate","_pickable","_typedArrayManagerProps","_customRender","widgets","onDeviceInitialized","onWebGLInitialized","onResize","onViewStateChange","onInteractionStateChange","onBeforeRender","onAfterRender","onLoad","onError","error","message","cause","onHover","onClick","onDragStart","onDrag","onDragEnd","_onMetrics","getTooltip","debug","drawPickingColors","Deck","constructor","props","userData","viewManager","layerManager","effectManager","deckRenderer","deckPicker","eventManager","widgetManager","tooltip","animationLoop","cursorState","isHovering","stats","metrics","fps","setPropsTime","updateAttributesTime","framesRedrawn","pickTime","pickCount","gpuTime","gpuTimePerFrame","cpuTime","cpuTimePerFrame","bufferMemory","textureMemory","renderbufferMemory","gpuMemory","_metricsCounter","_needsRedraw","_pickRequest","mode","x","y","radius","event","_lastPointerDownInfo","_onPointerMove","type","leftButton","rightButton","pos","offsetCenter","context","mousePosition","_onEvent","eventHandlerProp","getLayers","info","getLastPickedObject","viewports","getViewports","layer","layerHandler","rootHandler","handled","call","onEvent","_onPointerDown","pickedInfo","_pick","result","emptyInfo","warn","deviceOrPromise","WebGLRenderingContext","attach","createDevice","_reuseDevices","adapters","createCanvasContext","_createCanvas","autoResize","_createAnimationLoop","setProps","setOptions","start","finalize","stop","destroy","parentElement","removeChild","get","timeStart","removed","Object","assign","_setCanvasSize","resolvedProps","create","_getViews","_getViewState","activateViewport","timeEnd","needsRedraw","opts","clearRedrawFlags","redraw","viewManagerNeedsRedraw","layerManagerNeedsRedraw","effectManagerNeedsRedraw","deckRendererNeedsRedraw","reason","redrawReason","incrementCount","_drawLayers","isInitialized","getViews","rect","getCanvas","pickObject","infos","length","pickMultipleObjects","depth","pickObjects","_addResources","resources","forceUpdate","resourceManager","add","resourceId","data","_removeResources","resourceIds","remove","_addDefaultEffect","effect","addDefaultEffect","_addDefaultShaderModule","module","addDefaultShaderModule","_removeDefaultShaderModule","removeDefaultShaderModule","method","statKey","onViewportActive","getEffects","document","getElementById","createElement","body","appendChild","cssWidth","Number","isFinite","cssHeight","position","_updateCanvasSize","newWidth","clientWidth","newHeight","clientHeight","autoResizeDrawingBuffer","autoResizeViewport","onInitialize","_setDevice","onRender","_onRenderFrame","bind","normalizedViews","Array","isArray","_onContextLost","Error","_pickAndCallback","_updateCursor","container","cursor","canvasContext","setParametersWebGL","blend","blendFunc","polygonOffsetFill","depthTest","depthFunc","timeline","play","attachTimeline","recognizers","keys","map","eventName","RecognizerConstructor","defaultOptions","recognizeWith","requestFailure","optionsOverride","options","recognizer","events","pointerdown","pointermove","pointerleave","eventType","on","_onViewStateChange","_onInteractionStateChange","viewport","deck","addDefault","renderOptions","target","pass","renderLayers","onRedraw","_getFrameStats","_getMetrics","reset","table","updateLayers","updateViewStates","params","viewId","interactionState","animationLoopStats","addTime","lastTiming","getHz","time","count","getAverageTime","memoryStats"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\lib\\deck.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport LayerManager from './layer-manager';\nimport ViewManager from './view-manager';\nimport MapView from '../views/map-view';\nimport EffectManager from './effect-manager';\nimport DeckRenderer from './deck-renderer';\nimport DeckPicker from './deck-picker';\nimport {WidgetManager, Widget} from './widget-manager';\nimport Tooltip from './tooltip';\nimport log from '../utils/log';\nimport {deepEqual} from '../utils/deep-equal';\nimport typedArrayManager from '../utils/typed-array-manager';\nimport {VERSION} from './init';\n\nimport {luma} from '@luma.gl/core';\nimport {webgl2Adapter} from '@luma.gl/webgl';\nimport {Timeline} from '@luma.gl/engine';\nimport {AnimationLoop} from '@luma.gl/engine';\nimport {GL} from '@luma.gl/constants';\nimport type {Device, DeviceProps, Framebuffer, Parameters} from '@luma.gl/core';\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nimport {Stats} from '@probe.gl/stats';\nimport {EventManager} from 'mjolnir.js';\n\nimport assert from '../utils/assert';\nimport {EVENT_HANDLERS, RECOGNIZERS, RecognizerOptions} from './constants';\n\nimport type {Effect} from './effect';\nimport type {FilterContext} from '../passes/layers-pass';\nimport type Layer from './layer';\nimport type View from '../views/view';\nimport type Viewport from '../viewports/viewport';\nimport type {EventManagerOptions, MjolnirGestureEvent, MjolnirPointerEvent} from 'mjolnir.js';\nimport type {TypedArrayManagerOptions} from '../utils/typed-array-manager';\nimport type {ViewStateChangeParameters, InteractionState} from '../controllers/controller';\nimport type {PickingInfo} from './picking/pick-info';\nimport type {PickByPointOptions, PickByRectOptions} from './deck-picker';\nimport type {LayersList} from './layer-manager';\nimport type {TooltipContent} from './tooltip';\nimport type {ViewStateMap, AnyViewStateOf, ViewOrViews, ViewStateObject} from './view-manager';\nimport {CreateDeviceProps} from '@luma.gl/core';\n\n/* global document */\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n\nconst getCursor = ({isDragging}) => (isDragging ? 'grabbing' : 'grab');\n\nexport type DeckMetrics = {\n  fps: number;\n  setPropsTime: number;\n  updateAttributesTime: number;\n  framesRedrawn: number;\n  pickTime: number;\n  pickCount: number;\n  gpuTime: number;\n  gpuTimePerFrame: number;\n  cpuTime: number;\n  cpuTimePerFrame: number;\n  bufferMemory: number;\n  textureMemory: number;\n  renderbufferMemory: number;\n  gpuMemory: number;\n};\n\ntype CursorState = {\n  /** Whether the cursor is over a pickable object */\n  isHovering: boolean;\n  /** Whether the cursor is down */\n  isDragging: boolean;\n};\n\nexport type DeckProps<ViewsT extends ViewOrViews = null> = {\n  /** Id of this Deck instance */\n  id?: string;\n  /** Width of the canvas, a number in pixels or a valid CSS string.\n   * @default `'100%'`\n   */\n  width?: string | number | null;\n  /** Height of the canvas, a number in pixels or a valid CSS string.\n   * @default `'100%'`\n   */\n  height?: string | number | null;\n  /** Additional CSS styles for the canvas. */\n  style?: Partial<CSSStyleDeclaration> | null;\n\n  /** Controls the resolution of drawing buffer used for rendering.\n   * @default `true` (use browser devicePixelRatio)\n   */\n  useDevicePixels?: boolean | number;\n  /** Extra pixels around the pointer to include while picking.\n   * @default `0`\n   */\n  pickingRadius?: number;\n\n  /** WebGL parameters to be set before each frame is rendered. */\n  parameters?: Parameters;\n  /** If supplied, will be called before a layer is drawn to determine whether it should be rendered. */\n  layerFilter?: ((context: FilterContext) => boolean) | null;\n\n  /** The container to append the auto-created canvas to.\n   * @default `document.body`\n   */\n  parent?: HTMLDivElement | null;\n\n  /** The canvas to render into.\n   * Can be either a HTMLCanvasElement or the element id.\n   * Will be auto-created if not supplied.\n   */\n  canvas?: HTMLCanvasElement | string | null;\n\n  /** Use an existing luma.gl GPU device. @note If not supplied, a new device will be created using props.deviceProps */\n  device?: Device | null;\n\n  /** A new device will be created using these props, assuming that an existing device is not supplied using props.device) */\n  deviceProps?: CreateDeviceProps;\n\n  /** WebGL context @deprecated Use props.deviceProps.webgl. Also note that preserveDrawingBuffers is true by default */\n  gl?: WebGL2RenderingContext | null;\n\n  /**\n   * The array of Layer instances to be rendered.\n   * Nested arrays are accepted, as well as falsy values (`null`, `false`, `undefined`)\n   */\n  layers?: LayersList;\n  /** The array of effects to be rendered. A lighting effect will be added if an empty array is supplied. */\n  effects?: Effect[];\n  /** A single View instance, or an array of `View` instances.\n   * @default `new MapView()`\n   */\n  views?: ViewsT;\n  /** Options for viewport interactivity, e.g. pan, rotate and zoom with mouse, touch and keyboard.\n   * This is a shorthand for defining interaction with the `views` prop if you are using the default view (i.e. a single `MapView`)\n   */\n  controller?: View['props']['controller'];\n  /**\n   * An object that describes the view state for each view in the `views` prop.\n   * Use if the camera state should be managed external to the `Deck` instance.\n   */\n  viewState?: ViewStateMap<ViewsT> | null;\n  /**\n   * If provided, the `Deck` instance will track camera state changes automatically,\n   * with `initialViewState` as its initial settings.\n   */\n  initialViewState?: ViewStateMap<ViewsT> | null;\n\n  /** Allow browser default touch actions.\n   * @default `'none'`\n   */\n  touchAction?: EventManagerOptions['touchAction'];\n  /**\n   * Optional mjolnir.js recognizer options\n   */\n  eventRecognizerOptions?: RecognizerOptions;\n\n  /** (Experimental) Render to a custom frame buffer other than to screen. */\n  _framebuffer?: Framebuffer | null;\n  /** (Experimental) Forces deck.gl to redraw layers every animation frame. */\n  _animate?: boolean;\n  /** (Experimental) If set to `false`, force disables all picking features, disregarding the `pickable` prop set in any layer. */\n  _pickable?: boolean;\n  /** (Experimental) Fine-tune attribute memory usage. See documentation for details. */\n  _typedArrayManagerProps?: TypedArrayManagerOptions;\n  /** An array of Widget instances to be added to the parent element. */\n  widgets?: Widget[];\n\n  /** Called once the GPU Device has been initiated. */\n  onDeviceInitialized?: (device: Device) => void;\n  /** @deprecated Called once the WebGL context has been initiated. */\n  onWebGLInitialized?: (gl: WebGL2RenderingContext) => void;\n  /** Called when the canvas resizes. */\n  onResize?: (dimensions: {width: number; height: number}) => void;\n  /** Called when the user has interacted with the deck.gl canvas, e.g. using mouse, touch or keyboard. */\n  onViewStateChange?: <ViewStateT extends AnyViewStateOf<ViewsT>>(\n    params: ViewStateChangeParameters<ViewStateT>\n  ) => ViewStateT | null | void;\n  /** Called when the user has interacted with the deck.gl canvas, e.g. using mouse, touch or keyboard. */\n  onInteractionStateChange?: (state: InteractionState) => void;\n  /** Called just before the canvas rerenders. */\n  onBeforeRender?: (context: {device: Device; gl: WebGL2RenderingContext}) => void;\n  /** Called right after the canvas rerenders. */\n  onAfterRender?: (context: {device: Device; gl: WebGL2RenderingContext}) => void;\n  /** Called once after gl context and all Deck components are created. */\n  onLoad?: () => void;\n  /** Called if deck.gl encounters an error.\n   * If this callback is set to `null`, errors are silently ignored.\n   * @default `console.error`\n   */\n  onError?: ((error: Error, layer?: Layer) => void) | null;\n  /** Called when the pointer moves over the canvas. */\n  onHover?: ((info: PickingInfo, event: MjolnirPointerEvent) => void) | null;\n  /** Called when clicking on the canvas. */\n  onClick?: ((info: PickingInfo, event: MjolnirGestureEvent) => void) | null;\n  /** Called when the user starts dragging on the canvas. */\n  onDragStart?: ((info: PickingInfo, event: MjolnirGestureEvent) => void) | null;\n  /** Called when dragging the canvas. */\n  onDrag?: ((info: PickingInfo, event: MjolnirGestureEvent) => void) | null;\n  /** Called when the user releases from dragging the canvas. */\n  onDragEnd?: ((info: PickingInfo, event: MjolnirGestureEvent) => void) | null;\n\n  /** (Experimental) Replace the default redraw procedure */\n  _customRender?: ((reason: string) => void) | null;\n  /** (Experimental) Called once every second with performance metrics. */\n  _onMetrics?: ((metrics: DeckMetrics) => void) | null;\n\n  /** A custom callback to retrieve the cursor type. */\n  getCursor?: (state: CursorState) => string;\n  /** Callback that takes a hovered-over point and renders a tooltip. */\n  getTooltip?: ((info: PickingInfo) => TooltipContent) | null;\n\n  /** (Debug) Flag to enable WebGL debug mode. Requires importing `@luma.gl/debug`. */\n  debug?: boolean;\n  /** (Debug) Render the picking buffer to screen. */\n  drawPickingColors?: boolean;\n};\n\nconst defaultProps: DeckProps = {\n  id: '',\n  width: '100%',\n  height: '100%',\n  style: null,\n  viewState: null,\n  initialViewState: null,\n  pickingRadius: 0,\n  layerFilter: null,\n  parameters: {},\n  parent: null,\n  device: null,\n  deviceProps: {} as DeviceProps,\n  gl: null,\n  canvas: null,\n  layers: [],\n  effects: [],\n  views: null,\n  controller: null, // Rely on external controller, e.g. react-map-gl\n  useDevicePixels: true,\n  touchAction: 'none',\n  eventRecognizerOptions: {},\n  _framebuffer: null,\n  _animate: false,\n  _pickable: true,\n  _typedArrayManagerProps: {},\n  _customRender: null,\n  widgets: [],\n\n  onDeviceInitialized: noop,\n  onWebGLInitialized: noop,\n  onResize: noop,\n  onViewStateChange: noop,\n  onInteractionStateChange: noop,\n  onBeforeRender: noop,\n  onAfterRender: noop,\n  onLoad: noop,\n  onError: (error: Error) => log.error(error.message, error.cause)(),\n  onHover: null,\n  onClick: null,\n  onDragStart: null,\n  onDrag: null,\n  onDragEnd: null,\n  _onMetrics: null,\n\n  getCursor,\n  getTooltip: null,\n\n  debug: false,\n  drawPickingColors: false\n};\n\n/* eslint-disable max-statements */\nexport default class Deck<ViewsT extends ViewOrViews = null> {\n  static defaultProps = defaultProps;\n  // This is used to defeat tree shaking of init.js\n  // https://github.com/visgl/deck.gl/issues/3213\n  static VERSION = VERSION;\n\n  readonly props: Required<DeckProps<ViewsT>>;\n  readonly width: number = 0;\n  readonly height: number = 0;\n  // Allows attaching arbitrary data to the instance\n  readonly userData: Record<string, any> = {};\n\n  protected device: Device | null = null;\n\n  protected canvas: HTMLCanvasElement | null = null;\n  protected viewManager: ViewManager<View[]> | null = null;\n  protected layerManager: LayerManager | null = null;\n  protected effectManager: EffectManager | null = null;\n  protected deckRenderer: DeckRenderer | null = null;\n  protected deckPicker: DeckPicker | null = null;\n  protected eventManager: EventManager | null = null;\n  protected widgetManager: WidgetManager | null = null;\n  protected tooltip: Tooltip | null = null;\n  protected animationLoop: AnimationLoop | null = null;\n\n  /** Internal view state if no callback is supplied */\n  protected viewState: ViewStateObject<ViewsT> | null;\n  protected cursorState: CursorState = {\n    isHovering: false,\n    isDragging: false\n  };\n\n  protected stats = new Stats({id: 'deck.gl'});\n  protected metrics: DeckMetrics = {\n    fps: 0,\n    setPropsTime: 0,\n    updateAttributesTime: 0,\n    framesRedrawn: 0,\n    pickTime: 0,\n    pickCount: 0,\n    gpuTime: 0,\n    gpuTimePerFrame: 0,\n    cpuTime: 0,\n    cpuTimePerFrame: 0,\n    bufferMemory: 0,\n    textureMemory: 0,\n    renderbufferMemory: 0,\n    gpuMemory: 0\n  };\n  private _metricsCounter: number = 0;\n\n  private _needsRedraw: false | string = 'Initial render';\n  private _pickRequest: {\n    mode: string;\n    event: MjolnirPointerEvent | null;\n    x: number;\n    y: number;\n    radius: number;\n  } = {\n    mode: 'hover',\n    x: -1,\n    y: -1,\n    radius: 0,\n    event: null\n  };\n\n  /**\n   * Pick and store the object under the pointer on `pointerdown`.\n   * This object is reused for subsequent `onClick` and `onDrag*` callbacks.\n   */\n  private _lastPointerDownInfo: PickingInfo | null = null;\n\n  constructor(props: DeckProps<ViewsT>) {\n    // @ts-ignore views\n    this.props = {...defaultProps, ...props};\n    props = this.props;\n\n    if (props.viewState && props.initialViewState) {\n      log.warn(\n        'View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.'\n      )();\n    }\n    this.viewState = this.props.initialViewState;\n\n    // See if we already have a device\n    if (props.device) {\n      this.device = props.device;\n    }\n\n    let deviceOrPromise: Device | Promise<Device> | null = this.device;\n\n    // Attach a new luma.gl device to a WebGL2 context if supplied\n    if (!deviceOrPromise && props.gl) {\n      if (props.gl instanceof WebGLRenderingContext) {\n        log.error('WebGL1 context not supported.')();\n      }\n      deviceOrPromise = webgl2Adapter.attach(props.gl);\n    }\n\n    // Create a new device\n    if (!deviceOrPromise) {\n      // Create the \"best\" device supported from the registered adapters\n      deviceOrPromise = luma.createDevice({\n        type: 'best-available',\n        // luma by default throws if a device is already attached\n        // asynchronous device creation could happen after finalize() is called\n        // TODO - createDevice should support AbortController?\n        _reuseDevices: true,\n        adapters: [webgl2Adapter],\n        ...props.deviceProps,\n        createCanvasContext: {\n          canvas: this._createCanvas(props),\n          useDevicePixels: this.props.useDevicePixels,\n          // TODO v9.2 - replace AnimationLoop's `autoResizeDrawingBuffer` with CanvasContext's `autoResize`\n          autoResize: false\n        }\n      });\n    }\n\n    this.animationLoop = this._createAnimationLoop(deviceOrPromise, props);\n\n    this.setProps(props);\n\n    // UNSAFE/experimental prop: only set at initialization to avoid performance hit\n    if (props._typedArrayManagerProps) {\n      typedArrayManager.setOptions(props._typedArrayManagerProps);\n    }\n\n    this.animationLoop.start();\n  }\n\n  /** Stop rendering and dispose all resources */\n  finalize() {\n    this.animationLoop?.stop();\n    this.animationLoop?.destroy();\n    this.animationLoop = null;\n    this._lastPointerDownInfo = null;\n\n    this.layerManager?.finalize();\n    this.layerManager = null;\n\n    this.viewManager?.finalize();\n    this.viewManager = null;\n\n    this.effectManager?.finalize();\n    this.effectManager = null;\n\n    this.deckRenderer?.finalize();\n    this.deckRenderer = null;\n\n    this.deckPicker?.finalize();\n    this.deckPicker = null;\n\n    this.eventManager?.destroy();\n    this.eventManager = null;\n\n    this.widgetManager?.finalize();\n    this.widgetManager = null;\n\n    if (!this.props.canvas && !this.props.device && !this.props.gl && this.canvas) {\n      // remove internally created canvas\n      this.canvas.parentElement?.removeChild(this.canvas);\n      this.canvas = null;\n    }\n  }\n\n  /** Partially update props */\n  setProps(props: DeckProps<ViewsT>): void {\n    this.stats.get('setProps Time').timeStart();\n\n    if ('onLayerHover' in props) {\n      log.removed('onLayerHover', 'onHover')();\n    }\n    if ('onLayerClick' in props) {\n      log.removed('onLayerClick', 'onClick')();\n    }\n    if (\n      props.initialViewState &&\n      // depth = 3 when comparing viewStates: viewId.position.0\n      !deepEqual(this.props.initialViewState, props.initialViewState, 3)\n    ) {\n      // Overwrite internal view state\n      this.viewState = props.initialViewState;\n    }\n\n    // Merge with existing props\n    Object.assign(this.props, props);\n\n    // Update CSS size of canvas\n    this._setCanvasSize(this.props);\n\n    // We need to overwrite CSS style width and height with actual, numeric values\n    const resolvedProps: Required<DeckProps> & {\n      width: number;\n      height: number;\n      views: View[];\n      viewState: ViewStateObject<ViewsT> | null;\n    } = Object.create(this.props);\n    Object.assign(resolvedProps, {\n      views: this._getViews(),\n      width: this.width,\n      height: this.height,\n      viewState: this._getViewState()\n    });\n\n    // Update the animation loop\n    this.animationLoop?.setProps(resolvedProps);\n\n    // If initialized, update sub manager props\n    if (this.layerManager) {\n      this.viewManager!.setProps(resolvedProps);\n      // Make sure that any new layer gets initialized with the current viewport\n      this.layerManager.activateViewport(this.getViewports()[0]);\n      this.layerManager.setProps(resolvedProps);\n      this.effectManager!.setProps(resolvedProps);\n      this.deckRenderer!.setProps(resolvedProps);\n      this.deckPicker!.setProps(resolvedProps);\n      this.widgetManager!.setProps(resolvedProps);\n    }\n\n    this.stats.get('setProps Time').timeEnd();\n  }\n\n  // Public API\n\n  /**\n   * Check if a redraw is needed\n   * @returns `false` or a string summarizing the redraw reason\n   */\n  needsRedraw(\n    opts: {\n      /** Reset the redraw flag afterwards. Default `true` */\n      clearRedrawFlags: boolean;\n    } = {clearRedrawFlags: false}\n  ): false | string {\n    if (!this.layerManager) {\n      // Not initialized or already finalized\n      return false;\n    }\n    if (this.props._animate) {\n      return 'Deck._animate';\n    }\n\n    let redraw: false | string = this._needsRedraw;\n\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n\n    const viewManagerNeedsRedraw = this.viewManager!.needsRedraw(opts);\n    const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);\n    const effectManagerNeedsRedraw = this.effectManager!.needsRedraw(opts);\n    const deckRendererNeedsRedraw = this.deckRenderer!.needsRedraw(opts);\n\n    redraw =\n      redraw ||\n      viewManagerNeedsRedraw ||\n      layerManagerNeedsRedraw ||\n      effectManagerNeedsRedraw ||\n      deckRendererNeedsRedraw;\n    return redraw;\n  }\n\n  /**\n   * Redraw the GL context\n   * @param reason If not provided, only redraw if deemed necessary. Otherwise redraw regardless of internal states.\n   * @returns\n   */\n  redraw(reason?: string): void {\n    if (!this.layerManager) {\n      // Not yet initialized\n      return;\n    }\n    // Check if we need to redraw\n    let redrawReason = this.needsRedraw({clearRedrawFlags: true});\n    // User-supplied should take precedent, however the redraw flags get cleared regardless\n    redrawReason = reason || redrawReason;\n\n    if (!redrawReason) {\n      return;\n    }\n\n    this.stats.get('Redraw Count').incrementCount();\n    if (this.props._customRender) {\n      this.props._customRender(redrawReason);\n    } else {\n      this._drawLayers(redrawReason);\n    }\n  }\n\n  /** Flag indicating that the Deck instance has initialized its resources and it's safe to call public methods. */\n  get isInitialized(): boolean {\n    return this.viewManager !== null;\n  }\n\n  /** Get a list of views that are currently rendered */\n  getViews(): View[] {\n    assert(this.viewManager);\n    return this.viewManager.views;\n  }\n\n  /** Get a list of viewports that are currently rendered.\n   * @param rect If provided, only returns viewports within the given bounding box.\n   */\n  getViewports(rect?: {x: number; y: number; width?: number; height?: number}): Viewport[] {\n    assert(this.viewManager);\n    return this.viewManager.getViewports(rect);\n  }\n\n  /** Get the current canvas element. */\n  getCanvas(): HTMLCanvasElement | null {\n    return this.canvas;\n  }\n\n  /** Query the object rendered on top at a given point */\n  pickObject(opts: {\n    /** x position in pixels */\n    x: number;\n    /** y position in pixels */\n    y: number;\n    /** Radius of tolerance in pixels. Default `0`. */\n    radius?: number;\n    /** A list of layer ids to query from. If not specified, then all pickable and visible layers are queried. */\n    layerIds?: string[];\n    /** If `true`, `info.coordinate` will be a 3D point by unprojecting the `x, y` screen coordinates onto the picked geometry. Default `false`. */\n    unproject3D?: boolean;\n  }): PickingInfo | null {\n    const infos = this._pick('pickObject', 'pickObject Time', opts).result;\n    return infos.length ? infos[0] : null;\n  }\n\n  /* Query all rendered objects at a given point */\n  pickMultipleObjects(opts: {\n    /** x position in pixels */\n    x: number;\n    /** y position in pixels */\n    y: number;\n    /** Radius of tolerance in pixels. Default `0`. */\n    radius?: number;\n    /** Specifies the max number of objects to return. Default `10`. */\n    depth?: number;\n    /** A list of layer ids to query from. If not specified, then all pickable and visible layers are queried. */\n    layerIds?: string[];\n    /** If `true`, `info.coordinate` will be a 3D point by unprojecting the `x, y` screen coordinates onto the picked geometry. Default `false`. */\n    unproject3D?: boolean;\n  }): PickingInfo[] {\n    opts.depth = opts.depth || 10;\n    return this._pick('pickObject', 'pickMultipleObjects Time', opts).result;\n  }\n\n  /* Query all objects rendered on top within a bounding box */\n  pickObjects(opts: {\n    /** Left of the bounding box in pixels */\n    x: number;\n    /** Top of the bounding box in pixels */\n    y: number;\n    /** Width of the bounding box in pixels. Default `1` */\n    width?: number;\n    /** Height of the bounding box in pixels. Default `1` */\n    height?: number;\n    /** A list of layer ids to query from. If not specified, then all pickable and visible layers are queried. */\n    layerIds?: string[];\n    /** If specified, limits the number of objects that can be returned. */\n    maxObjects?: number | null;\n  }): PickingInfo[] {\n    return this._pick('pickObjects', 'pickObjects Time', opts);\n  }\n\n  /** Experimental\n   * Add a global resource for sharing among layers\n   */\n  _addResources(\n    resources: {\n      [id: string]: any;\n    },\n    forceUpdate = false\n  ) {\n    for (const id in resources) {\n      this.layerManager!.resourceManager.add({resourceId: id, data: resources[id], forceUpdate});\n    }\n  }\n\n  /** Experimental\n   * Remove a global resource\n   */\n  _removeResources(resourceIds: string[]) {\n    for (const id of resourceIds) {\n      this.layerManager!.resourceManager.remove(id);\n    }\n  }\n\n  /** Experimental\n   * Register a default effect. Effects will be sorted by order, those with a low order will be rendered first\n   */\n  _addDefaultEffect(effect: Effect) {\n    this.effectManager!.addDefaultEffect(effect);\n  }\n\n  _addDefaultShaderModule(module: ShaderModule<Record<string, unknown>>) {\n    this.layerManager!.addDefaultShaderModule(module);\n  }\n\n  _removeDefaultShaderModule(module: ShaderModule<Record<string, unknown>>) {\n    this.layerManager?.removeDefaultShaderModule(module);\n  }\n\n  // Private Methods\n\n  private _pick(\n    method: 'pickObject',\n    statKey: string,\n    opts: PickByPointOptions & {layerIds?: string[]}\n  ): {\n    result: PickingInfo[];\n    emptyInfo: PickingInfo;\n  };\n  private _pick(\n    method: 'pickObjects',\n    statKey: string,\n    opts: PickByRectOptions & {layerIds?: string[]}\n  ): PickingInfo[];\n\n  private _pick(\n    method: 'pickObject' | 'pickObjects',\n    statKey: string,\n    opts: (PickByPointOptions | PickByRectOptions) & {layerIds?: string[]}\n  ) {\n    assert(this.deckPicker);\n\n    const {stats} = this;\n\n    stats.get('Pick Count').incrementCount();\n    stats.get(statKey).timeStart();\n\n    const infos = this.deckPicker[method]({\n      // layerManager, viewManager and effectManager are always defined if deckPicker is\n      layers: this.layerManager!.getLayers(opts),\n      views: this.viewManager!.getViews(),\n      viewports: this.getViewports(opts),\n      onViewportActive: this.layerManager!.activateViewport,\n      effects: this.effectManager!.getEffects(),\n      ...opts\n    });\n\n    stats.get(statKey).timeEnd();\n\n    return infos;\n  }\n\n  /** Resolve props.canvas to element */\n  private _createCanvas(props: DeckProps<ViewsT>): HTMLCanvasElement {\n    let canvas = props.canvas;\n\n    // TODO EventManager should accept element id\n    if (typeof canvas === 'string') {\n      canvas = document.getElementById(canvas) as HTMLCanvasElement;\n      assert(canvas);\n    }\n\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      canvas.id = props.id || 'deckgl-overlay';\n      const parent = props.parent || document.body;\n      parent.appendChild(canvas);\n    }\n\n    Object.assign(canvas.style, props.style);\n\n    return canvas;\n  }\n\n  /** Updates canvas width and/or height, if provided as props */\n  private _setCanvasSize(props: Required<DeckProps<ViewsT>>): void {\n    if (!this.canvas) {\n      return;\n    }\n\n    const {width, height} = props;\n    // Set size ONLY if props are being provided, otherwise let canvas be layouted freely\n    if (width || width === 0) {\n      const cssWidth = Number.isFinite(width) ? `${width}px` : (width as string);\n      this.canvas.style.width = cssWidth;\n    }\n    if (height || height === 0) {\n      const cssHeight = Number.isFinite(height) ? `${height}px` : (height as string);\n      // Note: position==='absolute' required for height 100% to work\n      this.canvas.style.position = props.style?.position || 'absolute';\n      this.canvas.style.height = cssHeight;\n    }\n  }\n\n  /** If canvas size has changed, reads out the new size and update */\n  private _updateCanvasSize(): void {\n    const {canvas} = this;\n    if (!canvas) {\n      return;\n    }\n    // Fallback to width/height when clientWidth/clientHeight are undefined (OffscreenCanvas).\n    const newWidth = canvas.clientWidth ?? canvas.width;\n    const newHeight = canvas.clientHeight ?? canvas.height;\n    if (newWidth !== this.width || newHeight !== this.height) {\n      // @ts-expect-error private assign to read-only property\n      this.width = newWidth;\n      // @ts-expect-error private assign to read-only property\n      this.height = newHeight;\n      this.viewManager?.setProps({width: newWidth, height: newHeight});\n      // Make sure that any new layer gets initialized with the current viewport\n      this.layerManager?.activateViewport(this.getViewports()[0]);\n      this.props.onResize({width: newWidth, height: newHeight});\n    }\n  }\n\n  private _createAnimationLoop(\n    deviceOrPromise: Device | Promise<Device>,\n    props: DeckProps<ViewsT>\n  ): AnimationLoop {\n    const {\n      // width,\n      // height,\n      gl,\n      // debug,\n      onError,\n      // onBeforeRender,\n      // onAfterRender,\n      useDevicePixels\n    } = props;\n\n    return new AnimationLoop({\n      device: deviceOrPromise,\n      useDevicePixels,\n      // TODO v9\n      autoResizeDrawingBuffer: !gl, // do not auto resize external context\n      autoResizeViewport: false,\n      // @ts-expect-error luma.gl needs to accept Promise<void> return value\n      onInitialize: context => this._setDevice(context.device),\n\n      onRender: this._onRenderFrame.bind(this),\n      // @ts-expect-error typing mismatch: AnimationLoop does not accept onError:null\n      onError\n\n      // onBeforeRender,\n      // onAfterRender,\n    });\n  }\n\n  // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState\n  // TODO: For backwards compatibility ensure numeric width and height is added to the viewState\n  private _getViewState(): ViewStateObject<ViewsT> | null {\n    return this.props.viewState || this.viewState;\n  }\n\n  // Get the view descriptor list\n  private _getViews(): View[] {\n    const {views} = this.props;\n    const normalizedViews: View[] = Array.isArray(views)\n      ? views\n      : // If null, default to a full screen map view port\n        views\n        ? [views]\n        : [new MapView({id: 'default-view'})];\n    if (normalizedViews.length && this.props.controller) {\n      // Backward compatibility: support controller prop\n      normalizedViews[0].props.controller = this.props.controller;\n    }\n    return normalizedViews;\n  }\n\n  private _onContextLost() {\n    const {onError} = this.props;\n    if (this.animationLoop && onError) {\n      onError(new Error('WebGL context is lost'));\n    }\n  }\n\n  // The `pointermove` event may fire multiple times in between two animation frames,\n  // it's a waste of time to run picking without rerender. Instead we save the last pick\n  // request and only do it once on the next animation frame.\n  /** Internal use only: event handler for pointerdown */\n  _onPointerMove = (event: MjolnirPointerEvent) => {\n    const {_pickRequest} = this;\n    if (event.type === 'pointerleave') {\n      _pickRequest.x = -1;\n      _pickRequest.y = -1;\n      _pickRequest.radius = 0;\n    } else if (event.leftButton || event.rightButton) {\n      // Do not trigger onHover callbacks if mouse button is down.\n      return;\n    } else {\n      const pos = event.offsetCenter;\n      // Do not trigger callbacks when click/hover position is invalid. Doing so will cause a\n      // assertion error when attempting to unproject the position.\n      if (!pos) {\n        return;\n      }\n      _pickRequest.x = pos.x;\n      _pickRequest.y = pos.y;\n      _pickRequest.radius = this.props.pickingRadius;\n    }\n\n    if (this.layerManager) {\n      this.layerManager.context.mousePosition = {x: _pickRequest.x, y: _pickRequest.y};\n    }\n\n    _pickRequest.event = event;\n  };\n\n  /** Actually run picking */\n  private _pickAndCallback() {\n    if (this.device?.type === 'webgpu') {\n      return;\n    }\n\n    const {_pickRequest} = this;\n\n    if (_pickRequest.event) {\n      // Perform picking\n      const {result, emptyInfo} = this._pick('pickObject', 'pickObject Time', _pickRequest);\n      this.cursorState.isHovering = result.length > 0;\n\n      // There are 4 possible scenarios:\n      // result is [outInfo, pickedInfo] (moved from one pickable layer to another)\n      // result is [outInfo] (moved outside of a pickable layer)\n      // result is [pickedInfo] (moved into or over a pickable layer)\n      // result is [] (nothing is or was picked)\n      //\n      // `layer.props.onHover` should be called on all affected layers (out/over)\n      // `deck.props.onHover` should be called with the picked info if any, or empty info otherwise\n      // `deck.props.getTooltip` should be called with the picked info if any, or empty info otherwise\n\n      // Execute callbacks\n      let pickedInfo = emptyInfo;\n      let handled = false;\n      for (const info of result) {\n        pickedInfo = info;\n        handled = info.layer?.onHover(info, _pickRequest.event) || handled;\n      }\n      if (!handled) {\n        this.props.onHover?.(pickedInfo, _pickRequest.event);\n        this.widgetManager!.onHover(pickedInfo, _pickRequest.event);\n      }\n\n      // Clear pending pickRequest\n      _pickRequest.event = null;\n    }\n  }\n\n  private _updateCursor(): void {\n    const container = this.props.parent || this.canvas;\n    if (container) {\n      container.style.cursor = this.props.getCursor(this.cursorState);\n    }\n  }\n\n  private _setDevice(device: Device) {\n    this.device = device;\n\n    if (!this.animationLoop) {\n      // finalize() has been called\n      return;\n    }\n\n    // if external context...\n    if (!this.canvas) {\n      this.canvas = this.device.canvasContext?.canvas as HTMLCanvasElement;\n      // TODO v9\n      // ts-expect-error - Currently luma.gl v9 does not expose these options\n      // All WebGLDevice contexts are instrumented, but it seems the device\n      // should have a method to start state tracking even if not enabled?\n      // instrumentGLContext(this.device.gl, {enable: true, copyState: true});\n    }\n\n    if (this.device.type === 'webgl') {\n      this.device.setParametersWebGL({\n        blend: true,\n        blendFunc: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA, GL.ONE, GL.ONE_MINUS_SRC_ALPHA],\n        polygonOffsetFill: true,\n        depthTest: true,\n        depthFunc: GL.LEQUAL\n      });\n    }\n\n    this.props.onDeviceInitialized(this.device);\n    if (this.device.type === 'webgl') {\n      // Legacy callback - warn?\n      // @ts-expect-error gl is not visible on Device base class\n      this.props.onWebGLInitialized(this.device.gl);\n    }\n\n    // timeline for transitions\n    const timeline = new Timeline();\n    timeline.play();\n    this.animationLoop.attachTimeline(timeline);\n\n    this.eventManager = new EventManager(this.props.parent || this.canvas, {\n      touchAction: this.props.touchAction,\n      recognizers: Object.keys(RECOGNIZERS).map((eventName: string) => {\n        // Resolve recognizer settings\n        const [RecognizerConstructor, defaultOptions, recognizeWith, requestFailure] =\n          RECOGNIZERS[eventName];\n        const optionsOverride = this.props.eventRecognizerOptions?.[eventName];\n        const options = {...defaultOptions, ...optionsOverride, event: eventName};\n        return {\n          recognizer: new RecognizerConstructor(options),\n          recognizeWith,\n          requestFailure\n        };\n      }),\n      events: {\n        pointerdown: this._onPointerDown,\n        pointermove: this._onPointerMove,\n        pointerleave: this._onPointerMove\n      }\n    });\n    for (const eventType in EVENT_HANDLERS) {\n      this.eventManager.on(eventType, this._onEvent);\n    }\n\n    this.viewManager = new ViewManager({\n      timeline,\n      eventManager: this.eventManager,\n      onViewStateChange: this._onViewStateChange.bind(this),\n      onInteractionStateChange: this._onInteractionStateChange.bind(this),\n      views: this._getViews(),\n      viewState: this._getViewState(),\n      width: this.width,\n      height: this.height\n    });\n\n    // viewManager must be initialized before layerManager\n    // layerManager depends on viewport created by viewManager.\n    const viewport = this.viewManager.getViewports()[0];\n\n    // Note: avoid React setState due GL animation loop / setState timing issue\n    this.layerManager = new LayerManager(this.device, {\n      deck: this,\n      stats: this.stats,\n      viewport,\n      timeline\n    });\n\n    this.effectManager = new EffectManager({\n      deck: this,\n      device: this.device\n    });\n\n    this.deckRenderer = new DeckRenderer(this.device);\n\n    this.deckPicker = new DeckPicker(this.device);\n\n    this.widgetManager = new WidgetManager({\n      deck: this,\n      parentElement: this.canvas?.parentElement\n    });\n    this.widgetManager.addDefault(new Tooltip());\n\n    this.setProps(this.props);\n\n    this._updateCanvasSize();\n    this.props.onLoad();\n  }\n\n  /** Internal only: default render function (redraw all layers and views) */\n  _drawLayers(\n    redrawReason: string,\n    renderOptions?: {\n      target?: Framebuffer;\n      layerFilter?: (context: FilterContext) => boolean;\n      layers?: Layer[];\n      viewports?: Viewport[];\n      views?: {[viewId: string]: View};\n      pass?: string;\n      effects?: Effect[];\n      clearStack?: boolean;\n      clearCanvas?: boolean;\n    }\n  ) {\n    const {device, gl} = this.layerManager!.context;\n\n    this.props.onBeforeRender({device, gl});\n\n    const opts = {\n      target: this.props._framebuffer,\n      layers: this.layerManager!.getLayers(),\n      viewports: this.viewManager!.getViewports(),\n      onViewportActive: this.layerManager!.activateViewport,\n      views: this.viewManager!.getViews(),\n      pass: 'screen',\n      effects: this.effectManager!.getEffects(),\n      ...renderOptions\n    };\n    this.deckRenderer?.renderLayers(opts);\n\n    if (opts.pass === 'screen') {\n      // This method could be called when drawing to picking buffer, texture etc.\n      // Only when drawing to screen, update all widgets (UI components)\n      this.widgetManager!.onRedraw({\n        viewports: opts.viewports,\n        layers: opts.layers\n      });\n    }\n\n    this.props.onAfterRender({device, gl});\n  }\n\n  // Callbacks\n\n  private _onRenderFrame() {\n    this._getFrameStats();\n\n    // Log perf stats every second\n    if (this._metricsCounter++ % 60 === 0) {\n      this._getMetrics();\n      this.stats.reset();\n      log.table(4, this.metrics)();\n\n      // Experimental: report metrics\n      if (this.props._onMetrics) {\n        this.props._onMetrics(this.metrics);\n      }\n    }\n\n    this._updateCanvasSize();\n\n    this._updateCursor();\n\n    // Update layers if needed (e.g. some async prop has loaded)\n    // Note: This can trigger a redraw\n    this.layerManager!.updateLayers();\n\n    // Perform picking request if any\n    // TODO(ibgreen): Picking not yet supported on WebGPU\n    if (this.device?.type !== 'webgpu') {\n      this._pickAndCallback();\n    }\n\n    // Redraw if necessary\n    this.redraw();\n\n    // Update viewport transition if needed\n    // Note: this can trigger `onViewStateChange`, and affect layers\n    // We want to defer these changes to the next frame\n    if (this.viewManager) {\n      this.viewManager.updateViewStates();\n    }\n  }\n\n  // Callbacks\n\n  private _onViewStateChange(params: ViewStateChangeParameters & {viewId: string}) {\n    // Let app know that view state is changing, and give it a chance to change it\n    const viewState = this.props.onViewStateChange(params) || params.viewState;\n\n    // If initialViewState was set on creation, auto track position\n    if (this.viewState) {\n      this.viewState = {...this.viewState, [params.viewId]: viewState};\n      if (!this.props.viewState) {\n        // Apply internal view state\n        if (this.viewManager) {\n          this.viewManager.setProps({viewState: this.viewState});\n        }\n      }\n    }\n  }\n\n  private _onInteractionStateChange(interactionState: InteractionState) {\n    this.cursorState.isDragging = interactionState.isDragging || false;\n    this.props.onInteractionStateChange(interactionState);\n  }\n\n  /** Internal use only: event handler for click & drag */\n  _onEvent = (event: MjolnirGestureEvent) => {\n    const eventHandlerProp = EVENT_HANDLERS[event.type];\n    const pos = event.offsetCenter;\n\n    if (!eventHandlerProp || !pos || !this.layerManager) {\n      return;\n    }\n\n    // Reuse last picked object\n    const layers = this.layerManager.getLayers();\n    const info = this.deckPicker!.getLastPickedObject(\n      {\n        x: pos.x,\n        y: pos.y,\n        layers,\n        viewports: this.getViewports(pos)\n      },\n      this._lastPointerDownInfo\n    ) as PickingInfo;\n\n    const {layer} = info;\n    const layerHandler = layer && (layer[eventHandlerProp] || layer.props[eventHandlerProp]);\n    const rootHandler = this.props[eventHandlerProp];\n    let handled = false;\n\n    if (layerHandler) {\n      handled = layerHandler.call(layer, info, event);\n    }\n    if (!handled) {\n      rootHandler?.(info, event);\n      this.widgetManager!.onEvent(info, event);\n    }\n  };\n\n  /** Internal use only: evnet handler for pointerdown */\n  _onPointerDown = (event: MjolnirPointerEvent) => {\n    // TODO(ibgreen) Picking not yet supported on WebGPU\n    if (this.device?.type === 'webgpu') {\n      return;\n    }\n    const pos = event.offsetCenter;\n    const pickedInfo = this._pick('pickObject', 'pickObject Time', {\n      x: pos.x,\n      y: pos.y,\n      radius: this.props.pickingRadius\n    });\n    this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;\n  };\n\n  private _getFrameStats(): void {\n    const {stats} = this;\n    stats.get('frameRate').timeEnd();\n    stats.get('frameRate').timeStart();\n\n    // Get individual stats from luma.gl so reset works\n    const animationLoopStats = this.animationLoop!.stats;\n    stats.get('GPU Time').addTime(animationLoopStats.get('GPU Time').lastTiming);\n    stats.get('CPU Time').addTime(animationLoopStats.get('CPU Time').lastTiming);\n  }\n\n  private _getMetrics(): void {\n    const {metrics, stats} = this;\n    metrics.fps = stats.get('frameRate').getHz();\n    metrics.setPropsTime = stats.get('setProps Time').time;\n    metrics.updateAttributesTime = stats.get('Update Attributes').time;\n    metrics.framesRedrawn = stats.get('Redraw Count').count;\n    metrics.pickTime =\n      stats.get('pickObject Time').time +\n      stats.get('pickMultipleObjects Time').time +\n      stats.get('pickObjects Time').time;\n    metrics.pickCount = stats.get('Pick Count').count;\n\n    // Luma stats\n    metrics.gpuTime = stats.get('GPU Time').time;\n    metrics.cpuTime = stats.get('CPU Time').time;\n    metrics.gpuTimePerFrame = stats.get('GPU Time').getAverageTime();\n    metrics.cpuTimePerFrame = stats.get('CPU Time').getAverageTime();\n\n    const memoryStats = luma.stats.get('Memory Usage');\n    metrics.bufferMemory = memoryStats.get('Buffer Memory').count;\n    metrics.textureMemory = memoryStats.get('Texture Memory').count;\n    metrics.renderbufferMemory = memoryStats.get('Renderbuffer Memory').count;\n    metrics.gpuMemory = memoryStats.get('GPU Memory').count;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}