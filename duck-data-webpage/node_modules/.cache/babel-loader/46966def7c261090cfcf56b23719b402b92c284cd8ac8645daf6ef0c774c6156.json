{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { RequestScheduler } from '@loaders.gl/loader-utils';\nimport { Matrix4, equals } from '@math.gl/core';\nimport { Tile2DHeader } from \"./tile-2d-header.js\";\nimport { getTileIndices, tileToBoundingBox, getCullBounds } from \"./utils.js\";\nimport { memoize } from \"./memoize.js\";\n// bit masks\nconst TILE_STATE_VISITED = 1;\nconst TILE_STATE_VISIBLE = 2;\n/*\n   show cached parent tile if children are loading\n   +-----------+       +-----+            +-----+-----+\n   |           |       |     |            |     |     |\n   |           |       |     |            |     |     |\n   |           |  -->  +-----+-----+  ->  +-----+-----+\n   |           |             |     |      |     |     |\n   |           |             |     |      |     |     |\n   +-----------+             +-----+      +-----+-----+\n\n   show cached children tiles when parent is loading\n   +-------+----       +------------\n   |       |           |\n   |       |           |\n   |       |           |\n   +-------+----  -->  |\n   |       |           |\n */\nexport const STRATEGY_NEVER = 'never';\nexport const STRATEGY_REPLACE = 'no-overlap';\nexport const STRATEGY_DEFAULT = 'best-available';\nconst DEFAULT_CACHE_SCALE = 5;\nconst STRATEGIES = {\n  [STRATEGY_DEFAULT]: updateTileStateDefault,\n  [STRATEGY_REPLACE]: updateTileStateReplace,\n  [STRATEGY_NEVER]: () => {}\n};\nexport const DEFAULT_TILESET2D_PROPS = {\n  extent: null,\n  tileSize: 512,\n  maxZoom: null,\n  minZoom: null,\n  maxCacheSize: null,\n  maxCacheByteSize: null,\n  refinementStrategy: 'best-available',\n  zRange: null,\n  maxRequests: 6,\n  debounceTime: 0,\n  zoomOffset: 0,\n  // onTileLoad: (tile: Tile2DHeader) => void,  // onTileUnload: (tile: Tile2DHeader) => void,  // onTileError: (error: any, tile: Tile2DHeader) => void,  /** Called when all tiles in the current viewport are loaded. */\n  // onViewportLoad: ((tiles: Tile2DHeader<DataT>[]) => void) | null,\n  onTileLoad: () => {},\n  onTileUnload: () => {},\n  onTileError: () => {}\n};\n/**\n * Manages loading and purging of tile data. This class caches recently visited tiles\n * and only creates new tiles if they are present.\n */\nexport class Tileset2D {\n  /**\n   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.\n   * Cache size defaults to 5 * number of tiles in the current viewport\n   */\n  constructor(opts) {\n    /* Private methods */\n    this._getCullBounds = memoize(getCullBounds);\n    this.opts = {\n      ...DEFAULT_TILESET2D_PROPS,\n      ...opts\n    };\n    this.setOptions(this.opts);\n    this.onTileLoad = tile => {\n      this.opts.onTileLoad?.(tile);\n      if (this.opts.maxCacheByteSize !== null) {\n        this._cacheByteSize += tile.byteLength;\n        this._resizeCache();\n      }\n    };\n    this._requestScheduler = new RequestScheduler({\n      throttleRequests: this.opts.maxRequests > 0 || this.opts.debounceTime > 0,\n      maxRequests: this.opts.maxRequests,\n      debounceTime: this.opts.debounceTime\n    });\n    // Maps tile id in string {z}-{x}-{y} to a Tile object\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n    // Cache the last processed viewport\n    this._viewport = null;\n    this._zRange = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n    this._modelMatrix = new Matrix4();\n    this._modelMatrixInverse = new Matrix4();\n  }\n  /* Public API */\n  get tiles() {\n    return this._tiles;\n  }\n  get selectedTiles() {\n    return this._selectedTiles;\n  }\n  get isLoaded() {\n    return this._selectedTiles !== null && this._selectedTiles.every(tile => tile.isLoaded);\n  }\n  get needsReload() {\n    return this._selectedTiles !== null && this._selectedTiles.some(tile => tile.needsReload);\n  }\n  setOptions(opts) {\n    Object.assign(this.opts, opts);\n    if (Number.isFinite(opts.maxZoom)) {\n      this._maxZoom = Math.floor(opts.maxZoom);\n    }\n    if (Number.isFinite(opts.minZoom)) {\n      this._minZoom = Math.ceil(opts.minZoom);\n    }\n  }\n  // Clean up any outstanding tile requests.\n  finalize() {\n    for (const tile of this._cache.values()) {\n      if (tile.isLoading) {\n        tile.abort();\n      }\n    }\n    this._cache.clear();\n    this._tiles = [];\n    this._selectedTiles = null;\n  }\n  reloadAll() {\n    for (const id of this._cache.keys()) {\n      const tile = this._cache.get(id);\n      if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {\n        this._cache.delete(id);\n      } else {\n        tile.setNeedsReload();\n      }\n    }\n  }\n  /**\n   * Update the cache with the given viewport and model matrix and triggers callback onUpdate.\n   */\n  update(viewport, {\n    zRange,\n    modelMatrix\n  } = {\n    zRange: null,\n    modelMatrix: null\n  }) {\n    const modelMatrixAsMatrix4 = modelMatrix ? new Matrix4(modelMatrix) : new Matrix4();\n    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);\n    if (!this._viewport || !viewport.equals(this._viewport) || !equals(this._zRange, zRange) || isModelMatrixNew) {\n      if (isModelMatrixNew) {\n        this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();\n        this._modelMatrix = modelMatrixAsMatrix4;\n      }\n      this._viewport = viewport;\n      this._zRange = zRange;\n      const tileIndices = this.getTileIndices({\n        viewport,\n        maxZoom: this._maxZoom,\n        minZoom: this._minZoom,\n        zRange,\n        modelMatrix: this._modelMatrix,\n        modelMatrixInverse: this._modelMatrixInverse\n      });\n      this._selectedTiles = tileIndices.map(index => this._getTile(index, true));\n      if (this._dirty) {\n        // Some new tiles are added\n        this._rebuildTree();\n      }\n      // Check for needed reloads explicitly even if the view/matrix has not changed.\n    } else if (this.needsReload) {\n      this._selectedTiles = this._selectedTiles.map(tile => this._getTile(tile.index, true));\n    }\n    // Update tile states\n    const changed = this.updateTileStates();\n    this._pruneRequests();\n    if (this._dirty) {\n      // cache size is either the user defined maxSize or 5 * number of current tiles in the viewport.\n      this._resizeCache();\n    }\n    if (changed) {\n      this._frameNumber++;\n    }\n    return this._frameNumber;\n  }\n  // eslint-disable-next-line complexity\n  isTileVisible(tile, cullRect) {\n    if (!tile.isVisible) {\n      return false;\n    }\n    if (cullRect && this._viewport) {\n      const boundsArr = this._getCullBounds({\n        viewport: this._viewport,\n        z: this._zRange,\n        cullRect\n      });\n      const {\n        bbox\n      } = tile;\n      for (const [minX, minY, maxX, maxY] of boundsArr) {\n        let overlaps;\n        if ('west' in bbox) {\n          overlaps = bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;\n        } else {\n          // top/bottom could be swapped depending on the indexing system\n          const y0 = Math.min(bbox.top, bbox.bottom);\n          const y1 = Math.max(bbox.top, bbox.bottom);\n          overlaps = bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;\n        }\n        if (overlaps) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return true;\n  }\n  /* Public interface for subclassing */\n  /** Returns array of tile indices in the current viewport */\n  getTileIndices({\n    viewport,\n    maxZoom,\n    minZoom,\n    zRange,\n    modelMatrix,\n    modelMatrixInverse\n  }) {\n    const {\n      tileSize,\n      extent,\n      zoomOffset\n    } = this.opts;\n    return getTileIndices({\n      viewport,\n      maxZoom,\n      minZoom,\n      zRange,\n      tileSize,\n      extent: extent,\n      modelMatrix,\n      modelMatrixInverse,\n      zoomOffset\n    });\n  }\n  /** Returns unique string key for a tile index */\n  getTileId(index) {\n    return `${index.x}-${index.y}-${index.z}`;\n  }\n  /** Returns a zoom level for a tile index */\n  getTileZoom(index) {\n    return index.z;\n  }\n  /** Returns additional metadata to add to tile, bbox by default */\n  getTileMetadata(index) {\n    const {\n      tileSize\n    } = this.opts;\n    return {\n      bbox: tileToBoundingBox(this._viewport, index.x, index.y, index.z, tileSize)\n    };\n  }\n  /** Returns index of the parent tile */\n  getParentIndex(index) {\n    const x = Math.floor(index.x / 2);\n    const y = Math.floor(index.y / 2);\n    const z = index.z - 1;\n    return {\n      x,\n      y,\n      z\n    };\n  }\n  // Returns true if any tile's visibility changed\n  updateTileStates() {\n    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n    const visibilities = new Array(this._cache.size);\n    let i = 0;\n    // Reset state\n    for (const tile of this._cache.values()) {\n      // save previous state\n      visibilities[i++] = tile.isVisible;\n      tile.isSelected = false;\n      tile.isVisible = false;\n    }\n    // @ts-expect-error called only when _selectedTiles is already defined\n    for (const tile of this._selectedTiles) {\n      tile.isSelected = true;\n      tile.isVisible = true;\n    }\n    // Strategy-specific state logic\n    (typeof refinementStrategy === 'function' ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));\n    i = 0;\n    // Check if any visibility has changed\n    for (const tile of this._cache.values()) {\n      if (visibilities[i++] !== tile.isVisible) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _pruneRequests() {\n    const {\n      maxRequests = 0\n    } = this.opts;\n    const abortCandidates = [];\n    let ongoingRequestCount = 0;\n    for (const tile of this._cache.values()) {\n      // Keep track of all the ongoing requests\n      if (tile.isLoading) {\n        ongoingRequestCount++;\n        if (!tile.isSelected && !tile.isVisible) {\n          abortCandidates.push(tile);\n        }\n      }\n    }\n    while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {\n      // There are too many ongoing requests, so abort some that are unselected\n      const tile = abortCandidates.shift();\n      tile.abort();\n      ongoingRequestCount--;\n    }\n  }\n  // This needs to be called every time some tiles have been added/removed from cache\n  _rebuildTree() {\n    const {\n      _cache\n    } = this;\n    // Reset states\n    for (const tile of _cache.values()) {\n      tile.parent = null;\n      if (tile.children) {\n        tile.children.length = 0;\n      }\n    }\n    // Rebuild tree\n    for (const tile of _cache.values()) {\n      const parent = this._getNearestAncestor(tile);\n      tile.parent = parent;\n      if (parent?.children) {\n        parent.children.push(tile);\n      }\n    }\n  }\n  /**\n   * Clear tiles that are not visible when the cache is full\n   */\n  /* eslint-disable complexity */\n  _resizeCache() {\n    const {\n      _cache,\n      opts\n    } = this;\n    const maxCacheSize = opts.maxCacheSize ?? (\n    // @ts-expect-error called only when selectedTiles is initialized\n    opts.maxCacheByteSize !== null ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n    const maxCacheByteSize = opts.maxCacheByteSize ?? Infinity;\n    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n    if (overflown) {\n      for (const [id, tile] of _cache) {\n        if (!tile.isVisible && !tile.isSelected) {\n          // delete tile\n          this._cacheByteSize -= opts.maxCacheByteSize !== null ? tile.byteLength : 0;\n          _cache.delete(id);\n          this.opts.onTileUnload?.(tile);\n        }\n        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n          break;\n        }\n      }\n      this._rebuildTree();\n      this._dirty = true;\n    }\n    if (this._dirty) {\n      // sort by zoom level so that smaller tiles are displayed on top\n      this._tiles = Array.from(this._cache.values()).sort((t1, t2) => t1.zoom - t2.zoom);\n      this._dirty = false;\n    }\n  }\n  _getTile(index, create) {\n    const id = this.getTileId(index);\n    let tile = this._cache.get(id);\n    let needsReload = false;\n    if (!tile && create) {\n      tile = new Tile2DHeader(index);\n      Object.assign(tile, this.getTileMetadata(tile.index));\n      Object.assign(tile, {\n        id,\n        zoom: this.getTileZoom(tile.index)\n      });\n      needsReload = true;\n      this._cache.set(id, tile);\n      this._dirty = true;\n    } else if (tile && tile.needsReload) {\n      needsReload = true;\n    }\n    if (tile && needsReload) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      tile.loadData({\n        getData: this.opts.getTileData,\n        requestScheduler: this._requestScheduler,\n        onLoad: this.onTileLoad,\n        onError: this.opts.onTileError\n      });\n    }\n    return tile;\n  }\n  _getNearestAncestor(tile) {\n    const {\n      _minZoom = 0\n    } = this;\n    let index = tile.index;\n    while (this.getTileZoom(index) > _minZoom) {\n      index = this.getParentIndex(index);\n      const parent = this._getTile(index);\n      if (parent) {\n        return parent;\n      }\n    }\n    return null;\n  }\n}\n/* -- Refinement strategies --*/\n/* eslint-disable max-depth */\n// For all the selected && pending tiles:\n// - pick the closest ancestor as placeholder\n// - if no ancestor is visible, pick the closest children as placeholder\nfunction updateTileStateDefault(allTiles) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n  for (const tile of allTiles) {\n    if (tile.isSelected && !getPlaceholderInAncestors(tile)) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n  for (const tile of allTiles) {\n    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n  }\n}\n// Until a selected tile and all its selected siblings are loaded, use the closest ancestor as placeholder\nfunction updateTileStateReplace(allTiles) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n  for (const tile of allTiles) {\n    if (tile.isSelected) {\n      getPlaceholderInAncestors(tile);\n    }\n  }\n  // Always process parents first\n  const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.zoom - t2.zoom);\n  for (const tile of sortedTiles) {\n    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n    if (tile.children && (tile.isVisible || tile.state & TILE_STATE_VISITED)) {\n      // If the tile is rendered, or if the tile has been explicitly hidden, hide all of its children\n      for (const child of tile.children) {\n        child.state = TILE_STATE_VISITED;\n      }\n    } else if (tile.isSelected) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n}\n// Walk up the tree until we find one ancestor that is loaded. Returns true if successful.\nfunction getPlaceholderInAncestors(startTile) {\n  let tile = startTile;\n  while (tile) {\n    if (tile.isLoaded || tile.content) {\n      tile.state |= TILE_STATE_VISIBLE;\n      return true;\n    }\n    tile = tile.parent;\n  }\n  return false;\n}\n// Recursively set children as placeholder\nfunction getPlaceholderInChildren(tile) {\n  for (const child of tile.children) {\n    if (child.isLoaded || child.content) {\n      child.state |= TILE_STATE_VISIBLE;\n    } else {\n      getPlaceholderInChildren(child);\n    }\n  }\n}","map":{"version":3,"names":["RequestScheduler","Matrix4","equals","Tile2DHeader","getTileIndices","tileToBoundingBox","getCullBounds","memoize","TILE_STATE_VISITED","TILE_STATE_VISIBLE","STRATEGY_NEVER","STRATEGY_REPLACE","STRATEGY_DEFAULT","DEFAULT_CACHE_SCALE","STRATEGIES","updateTileStateDefault","updateTileStateReplace","DEFAULT_TILESET2D_PROPS","extent","tileSize","maxZoom","minZoom","maxCacheSize","maxCacheByteSize","refinementStrategy","zRange","maxRequests","debounceTime","zoomOffset","onTileLoad","onTileUnload","onTileError","Tileset2D","constructor","opts","_getCullBounds","setOptions","tile","_cacheByteSize","byteLength","_resizeCache","_requestScheduler","throttleRequests","_cache","Map","_tiles","_dirty","_viewport","_zRange","_selectedTiles","_frameNumber","_modelMatrix","_modelMatrixInverse","tiles","selectedTiles","isLoaded","every","needsReload","some","Object","assign","Number","isFinite","_maxZoom","Math","floor","_minZoom","ceil","finalize","values","isLoading","abort","clear","reloadAll","id","keys","get","includes","delete","setNeedsReload","update","viewport","modelMatrix","modelMatrixAsMatrix4","isModelMatrixNew","clone","invert","tileIndices","modelMatrixInverse","map","index","_getTile","_rebuildTree","changed","updateTileStates","_pruneRequests","isTileVisible","cullRect","isVisible","boundsArr","z","bbox","minX","minY","maxX","maxY","overlaps","west","east","south","north","y0","min","top","bottom","y1","max","left","right","getTileId","x","y","getTileZoom","getTileMetadata","getParentIndex","visibilities","Array","size","i","isSelected","from","abortCandidates","ongoingRequestCount","push","length","shift","parent","children","_getNearestAncestor","Infinity","overflown","sort","t1","t2","zoom","create","set","loadData","getData","getTileData","requestScheduler","onLoad","onError","allTiles","state","getPlaceholderInAncestors","getPlaceholderInChildren","Boolean","sortedTiles","child","startTile","content"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\geo-layers\\src\\tileset-2d\\tileset-2d.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Viewport} from '@deck.gl/core';\n\nimport {RequestScheduler} from '@loaders.gl/loader-utils';\nimport {Matrix4, equals, NumericArray} from '@math.gl/core';\n\nimport {Tile2DHeader} from './tile-2d-header';\n\nimport {getTileIndices, tileToBoundingBox, getCullBounds} from './utils';\nimport {Bounds, TileIndex, ZRange} from './types';\nimport {TileLoadProps} from './types';\nimport {memoize} from './memoize';\n\n// bit masks\nconst TILE_STATE_VISITED = 1;\nconst TILE_STATE_VISIBLE = 2;\n/*\n   show cached parent tile if children are loading\n   +-----------+       +-----+            +-----+-----+\n   |           |       |     |            |     |     |\n   |           |       |     |            |     |     |\n   |           |  -->  +-----+-----+  ->  +-----+-----+\n   |           |             |     |      |     |     |\n   |           |             |     |      |     |     |\n   +-----------+             +-----+      +-----+-----+\n\n   show cached children tiles when parent is loading\n   +-------+----       +------------\n   |       |           |\n   |       |           |\n   |       |           |\n   +-------+----  -->  |\n   |       |           |\n */\n\nexport const STRATEGY_NEVER = 'never';\nexport const STRATEGY_REPLACE = 'no-overlap';\nexport const STRATEGY_DEFAULT = 'best-available';\n\nexport type RefinementStrategyFunction = (tiles: Tile2DHeader[]) => void;\nexport type RefinementStrategy =\n  | 'never'\n  | 'no-overlap'\n  | 'best-available'\n  | RefinementStrategyFunction;\n\nconst DEFAULT_CACHE_SCALE = 5;\n\nconst STRATEGIES = {\n  [STRATEGY_DEFAULT]: updateTileStateDefault,\n  [STRATEGY_REPLACE]: updateTileStateReplace,\n  [STRATEGY_NEVER]: () => {}\n};\n\nexport type Tileset2DProps<DataT = any> = {\n  /** `getTileData` is called to retrieve the data of each tile. */\n  getTileData: (props: TileLoadProps) => Promise<DataT> | DataT;\n\n  /** The bounding box of the layer's data. */\n  extent?: number[] | null;\n  /** The pixel dimension of the tiles, usually a power of 2. */\n  tileSize?: number;\n  /** The max zoom level of the layer's data. @default null */\n  maxZoom?: number | null;\n  /** The min zoom level of the layer's data. @default 0 */\n  minZoom?: number | null;\n  /** The maximum number of tiles that can be cached. */\n  maxCacheSize?: number | null;\n  /** The maximum memory used for caching tiles. @default null */\n  maxCacheByteSize?: number | null;\n  /** How the tile layer refines the visibility of tiles. @default 'best-available' */\n  refinementStrategy?: RefinementStrategy;\n  /** Range of minimum and maximum heights in the tile. */\n  zRange?: ZRange | null;\n  /** The maximum number of concurrent getTileData calls. @default 6 */\n  maxRequests?: number;\n  /** Queue tile requests until no new tiles have been requested for at least `debounceTime` milliseconds. @default 0 */\n  debounceTime?: number;\n  /** Changes the zoom level at which the tiles are fetched. Needs to be an integer. @default 0 */\n  zoomOffset?: number;\n\n  /** Called when a tile successfully loads. */\n  onTileLoad?: (tile: Tile2DHeader<DataT>) => void;\n  /** Called when a tile is cleared from cache. */\n  onTileUnload?: (tile: Tile2DHeader<DataT>) => void;\n  /** Called when a tile failed to load. */\n  onTileError?: (err: any, tile: Tile2DHeader<DataT>) => void;\n\n  // onTileLoad: (tile: Tile2DHeader) => void;\n  // onTileUnload: (tile: Tile2DHeader) => void;\n  // onTileError: (error: any, tile: Tile2DHeader) => void;\n  /** Called when all tiles in the current viewport are loaded. */\n  // sonViewportLoad?: ((tiles: Tile2DHeader<DataT>[]) => void) | null;\n};\n\nexport const DEFAULT_TILESET2D_PROPS: Omit<Required<Tileset2DProps>, 'getTileData'> = {\n  extent: null,\n  tileSize: 512,\n\n  maxZoom: null,\n  minZoom: null,\n  maxCacheSize: null,\n  maxCacheByteSize: null,\n  refinementStrategy: 'best-available',\n  zRange: null,\n  maxRequests: 6,\n  debounceTime: 0,\n  zoomOffset: 0,\n\n  // onTileLoad: (tile: Tile2DHeader) => void,  // onTileUnload: (tile: Tile2DHeader) => void,  // onTileError: (error: any, tile: Tile2DHeader) => void,  /** Called when all tiles in the current viewport are loaded. */\n  // onViewportLoad: ((tiles: Tile2DHeader<DataT>[]) => void) | null,\n  onTileLoad: () => {},\n  onTileUnload: () => {},\n  onTileError: () => {}\n};\n\n/**\n * Manages loading and purging of tile data. This class caches recently visited tiles\n * and only creates new tiles if they are present.\n */\nexport class Tileset2D {\n  protected opts: Required<Tileset2DProps>;\n  private _requestScheduler: RequestScheduler;\n  private _cache: Map<string, Tile2DHeader>;\n  private _dirty: boolean;\n  private _tiles: Tile2DHeader[];\n\n  private _cacheByteSize: number;\n  private _viewport: Viewport | null;\n  private _zRange: ZRange | null;\n  private _selectedTiles: Tile2DHeader[] | null;\n  private _frameNumber: number;\n  private _modelMatrix: Matrix4;\n  private _modelMatrixInverse: Matrix4;\n\n  private _maxZoom?: number;\n  private _minZoom?: number;\n\n  private onTileLoad: (tile: Tile2DHeader) => void;\n\n  /**\n   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.\n   * Cache size defaults to 5 * number of tiles in the current viewport\n   */\n  constructor(opts: Tileset2DProps) {\n    this.opts = {...DEFAULT_TILESET2D_PROPS, ...opts};\n    this.setOptions(this.opts);\n\n    this.onTileLoad = tile => {\n      this.opts.onTileLoad?.(tile);\n      if (this.opts.maxCacheByteSize !== null) {\n        this._cacheByteSize += tile.byteLength;\n        this._resizeCache();\n      }\n    };\n\n    this._requestScheduler = new RequestScheduler({\n      throttleRequests: this.opts.maxRequests > 0 || this.opts.debounceTime > 0,\n      maxRequests: this.opts.maxRequests,\n      debounceTime: this.opts.debounceTime\n    });\n\n    // Maps tile id in string {z}-{x}-{y} to a Tile object\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n\n    // Cache the last processed viewport\n    this._viewport = null;\n    this._zRange = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n\n    this._modelMatrix = new Matrix4();\n    this._modelMatrixInverse = new Matrix4();\n  }\n\n  /* Public API */\n  get tiles() {\n    return this._tiles;\n  }\n\n  get selectedTiles(): Tile2DHeader[] | null {\n    return this._selectedTiles;\n  }\n\n  get isLoaded(): boolean {\n    return this._selectedTiles !== null && this._selectedTiles.every(tile => tile.isLoaded);\n  }\n\n  get needsReload(): boolean {\n    return this._selectedTiles !== null && this._selectedTiles.some(tile => tile.needsReload);\n  }\n\n  setOptions(opts: Tileset2DProps): void {\n    Object.assign(this.opts, opts);\n    if (Number.isFinite(opts.maxZoom)) {\n      this._maxZoom = Math.floor(opts.maxZoom as number);\n    }\n    if (Number.isFinite(opts.minZoom)) {\n      this._minZoom = Math.ceil(opts.minZoom as number);\n    }\n  }\n\n  // Clean up any outstanding tile requests.\n  finalize(): void {\n    for (const tile of this._cache.values()) {\n      if (tile.isLoading) {\n        tile.abort();\n      }\n    }\n    this._cache.clear();\n    this._tiles = [];\n    this._selectedTiles = null;\n  }\n\n  reloadAll(): void {\n    for (const id of this._cache.keys()) {\n      const tile = this._cache.get(id) as Tile2DHeader;\n      if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {\n        this._cache.delete(id);\n      } else {\n        tile.setNeedsReload();\n      }\n    }\n  }\n\n  /**\n   * Update the cache with the given viewport and model matrix and triggers callback onUpdate.\n   */\n  update(\n    viewport: Viewport,\n    {zRange, modelMatrix}: {zRange: ZRange | null; modelMatrix: NumericArray | null} = {\n      zRange: null,\n      modelMatrix: null\n    }\n  ): number {\n    const modelMatrixAsMatrix4 = modelMatrix ? new Matrix4(modelMatrix) : new Matrix4();\n    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);\n    if (\n      !this._viewport ||\n      !viewport.equals(this._viewport) ||\n      !equals(this._zRange, zRange) ||\n      isModelMatrixNew\n    ) {\n      if (isModelMatrixNew) {\n        this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();\n        this._modelMatrix = modelMatrixAsMatrix4;\n      }\n      this._viewport = viewport;\n      this._zRange = zRange;\n      const tileIndices = this.getTileIndices({\n        viewport,\n        maxZoom: this._maxZoom,\n        minZoom: this._minZoom,\n        zRange,\n        modelMatrix: this._modelMatrix,\n        modelMatrixInverse: this._modelMatrixInverse\n      });\n      this._selectedTiles = tileIndices.map(index => this._getTile(index, true));\n\n      if (this._dirty) {\n        // Some new tiles are added\n        this._rebuildTree();\n      }\n      // Check for needed reloads explicitly even if the view/matrix has not changed.\n    } else if (this.needsReload) {\n      this._selectedTiles = this._selectedTiles!.map(tile => this._getTile(tile.index, true));\n    }\n\n    // Update tile states\n    const changed = this.updateTileStates();\n    this._pruneRequests();\n\n    if (this._dirty) {\n      // cache size is either the user defined maxSize or 5 * number of current tiles in the viewport.\n      this._resizeCache();\n    }\n\n    if (changed) {\n      this._frameNumber++;\n    }\n\n    return this._frameNumber;\n  }\n\n  // eslint-disable-next-line complexity\n  isTileVisible(\n    tile: Tile2DHeader,\n    cullRect?: {x: number; y: number; width: number; height: number}\n  ): boolean {\n    if (!tile.isVisible) {\n      return false;\n    }\n\n    if (cullRect && this._viewport) {\n      const boundsArr = this._getCullBounds({\n        viewport: this._viewport,\n        z: this._zRange,\n        cullRect\n      });\n      const {bbox} = tile;\n      for (const [minX, minY, maxX, maxY] of boundsArr) {\n        let overlaps;\n        if ('west' in bbox) {\n          overlaps = bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;\n        } else {\n          // top/bottom could be swapped depending on the indexing system\n          const y0 = Math.min(bbox.top, bbox.bottom);\n          const y1 = Math.max(bbox.top, bbox.bottom);\n          overlaps = bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;\n        }\n        if (overlaps) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return true;\n  }\n\n  /* Public interface for subclassing */\n\n  /** Returns array of tile indices in the current viewport */\n  getTileIndices({\n    viewport,\n    maxZoom,\n    minZoom,\n    zRange,\n    modelMatrix,\n    modelMatrixInverse\n  }: {\n    viewport: Viewport;\n    maxZoom?: number;\n    minZoom?: number;\n    zRange: ZRange | null;\n    tileSize?: number;\n    modelMatrix?: Matrix4;\n    modelMatrixInverse?: Matrix4;\n    zoomOffset?: number;\n  }): TileIndex[] {\n    const {tileSize, extent, zoomOffset} = this.opts;\n    return getTileIndices({\n      viewport,\n      maxZoom,\n      minZoom,\n      zRange,\n      tileSize,\n      extent: extent as Bounds | undefined,\n      modelMatrix,\n      modelMatrixInverse,\n      zoomOffset\n    });\n  }\n\n  /** Returns unique string key for a tile index */\n  getTileId(index: TileIndex) {\n    return `${index.x}-${index.y}-${index.z}`;\n  }\n\n  /** Returns a zoom level for a tile index */\n  getTileZoom(index: TileIndex) {\n    return index.z;\n  }\n\n  /** Returns additional metadata to add to tile, bbox by default */\n  getTileMetadata(index: TileIndex): Record<string, any> {\n    const {tileSize} = this.opts;\n    return {bbox: tileToBoundingBox(this._viewport!, index.x, index.y, index.z, tileSize)};\n  }\n\n  /** Returns index of the parent tile */\n  getParentIndex(index: TileIndex) {\n    const x = Math.floor(index.x / 2);\n    const y = Math.floor(index.y / 2);\n    const z = index.z - 1;\n    return {x, y, z};\n  }\n\n  // Returns true if any tile's visibility changed\n  private updateTileStates() {\n    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n\n    const visibilities = new Array(this._cache.size);\n    let i = 0;\n    // Reset state\n    for (const tile of this._cache.values()) {\n      // save previous state\n      visibilities[i++] = tile.isVisible;\n      tile.isSelected = false;\n      tile.isVisible = false;\n    }\n    // @ts-expect-error called only when _selectedTiles is already defined\n    for (const tile of this._selectedTiles) {\n      tile.isSelected = true;\n      tile.isVisible = true;\n    }\n\n    // Strategy-specific state logic\n    (typeof refinementStrategy === 'function'\n      ? refinementStrategy\n      : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));\n\n    i = 0;\n    // Check if any visibility has changed\n    for (const tile of this._cache.values()) {\n      if (visibilities[i++] !== tile.isVisible) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /* Private methods */\n\n  private _getCullBounds = memoize(getCullBounds);\n\n  private _pruneRequests(): void {\n    const {maxRequests = 0} = this.opts;\n\n    const abortCandidates: Tile2DHeader[] = [];\n    let ongoingRequestCount = 0;\n    for (const tile of this._cache.values()) {\n      // Keep track of all the ongoing requests\n      if (tile.isLoading) {\n        ongoingRequestCount++;\n        if (!tile.isSelected && !tile.isVisible) {\n          abortCandidates.push(tile);\n        }\n      }\n    }\n\n    while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {\n      // There are too many ongoing requests, so abort some that are unselected\n      const tile = abortCandidates.shift()!;\n      tile.abort();\n      ongoingRequestCount--;\n    }\n  }\n\n  // This needs to be called every time some tiles have been added/removed from cache\n  private _rebuildTree() {\n    const {_cache} = this;\n\n    // Reset states\n    for (const tile of _cache.values()) {\n      tile.parent = null;\n      if (tile.children) {\n        tile.children.length = 0;\n      }\n    }\n\n    // Rebuild tree\n    for (const tile of _cache.values()) {\n      const parent = this._getNearestAncestor(tile);\n      tile.parent = parent;\n      if (parent?.children) {\n        parent.children.push(tile);\n      }\n    }\n  }\n\n  /**\n   * Clear tiles that are not visible when the cache is full\n   */\n  /* eslint-disable complexity */\n  private _resizeCache() {\n    const {_cache, opts} = this;\n\n    const maxCacheSize =\n      opts.maxCacheSize ??\n      // @ts-expect-error called only when selectedTiles is initialized\n      (opts.maxCacheByteSize !== null ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n    const maxCacheByteSize = opts.maxCacheByteSize ?? Infinity;\n\n    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n\n    if (overflown) {\n      for (const [id, tile] of _cache) {\n        if (!tile.isVisible && !tile.isSelected) {\n          // delete tile\n          this._cacheByteSize -= opts.maxCacheByteSize !== null ? tile.byteLength : 0;\n          _cache.delete(id);\n          this.opts.onTileUnload?.(tile);\n        }\n        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n          break;\n        }\n      }\n      this._rebuildTree();\n      this._dirty = true;\n    }\n    if (this._dirty) {\n      // sort by zoom level so that smaller tiles are displayed on top\n      this._tiles = Array.from(this._cache.values()).sort((t1, t2) => t1.zoom - t2.zoom);\n\n      this._dirty = false;\n    }\n  }\n  /* eslint-enable complexity */\n\n  private _getTile(index: TileIndex, create: true): Tile2DHeader;\n  private _getTile(index: TileIndex, create?: false): Tile2DHeader | undefined;\n  private _getTile(index: TileIndex, create?: boolean): Tile2DHeader | undefined {\n    const id = this.getTileId(index);\n    let tile = this._cache.get(id);\n    let needsReload = false;\n\n    if (!tile && create) {\n      tile = new Tile2DHeader(index);\n      Object.assign(tile, this.getTileMetadata(tile.index));\n      Object.assign(tile, {id, zoom: this.getTileZoom(tile.index)});\n      needsReload = true;\n      this._cache.set(id, tile);\n      this._dirty = true;\n    } else if (tile && tile.needsReload) {\n      needsReload = true;\n    }\n    if (tile && needsReload) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      tile.loadData({\n        getData: this.opts.getTileData,\n        requestScheduler: this._requestScheduler,\n        onLoad: this.onTileLoad,\n        onError: this.opts.onTileError\n      });\n    }\n\n    return tile;\n  }\n\n  _getNearestAncestor(tile: Tile2DHeader): Tile2DHeader | null {\n    const {_minZoom = 0} = this;\n\n    let index = tile.index;\n    while (this.getTileZoom(index) > _minZoom) {\n      index = this.getParentIndex(index);\n      const parent = this._getTile(index);\n      if (parent) {\n        return parent;\n      }\n    }\n    return null;\n  }\n}\n\n/* -- Refinement strategies --*/\n/* eslint-disable max-depth */\n\n// For all the selected && pending tiles:\n// - pick the closest ancestor as placeholder\n// - if no ancestor is visible, pick the closest children as placeholder\nfunction updateTileStateDefault(allTiles: Tile2DHeader[]) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n  for (const tile of allTiles) {\n    if (tile.isSelected && !getPlaceholderInAncestors(tile)) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n  for (const tile of allTiles) {\n    tile.isVisible = Boolean(tile.state! & TILE_STATE_VISIBLE);\n  }\n}\n\n// Until a selected tile and all its selected siblings are loaded, use the closest ancestor as placeholder\nfunction updateTileStateReplace(allTiles: Tile2DHeader[]) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n  for (const tile of allTiles) {\n    if (tile.isSelected) {\n      getPlaceholderInAncestors(tile);\n    }\n  }\n  // Always process parents first\n  const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.zoom - t2.zoom);\n  for (const tile of sortedTiles) {\n    tile.isVisible = Boolean(tile.state! & TILE_STATE_VISIBLE);\n\n    if (tile.children && (tile.isVisible || tile.state! & TILE_STATE_VISITED)) {\n      // If the tile is rendered, or if the tile has been explicitly hidden, hide all of its children\n      for (const child of tile.children) {\n        child.state = TILE_STATE_VISITED;\n      }\n    } else if (tile.isSelected) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n}\n\n// Walk up the tree until we find one ancestor that is loaded. Returns true if successful.\nfunction getPlaceholderInAncestors(startTile: Tile2DHeader) {\n  let tile: Tile2DHeader | null = startTile;\n  while (tile) {\n    if (tile.isLoaded || tile.content) {\n      tile.state! |= TILE_STATE_VISIBLE;\n      return true;\n    }\n    tile = tile.parent;\n  }\n  return false;\n}\n\n// Recursively set children as placeholder\nfunction getPlaceholderInChildren(tile) {\n  for (const child of tile.children) {\n    if (child.isLoaded || child.content) {\n      child.state |= TILE_STATE_VISIBLE;\n    } else {\n      getPlaceholderInChildren(child);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}