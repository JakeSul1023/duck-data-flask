{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// TRANSPILATION TABLES\n/**\n * Transpiles GLSL 3.00 shader source code to target GLSL version (3.00 or 1.00)\n *\n * @note We always run transpiler even if same version e.g. 3.00 => 3.00\n * @note For texture sampling transpilation, apps need to use non-standard texture* calls in GLSL 3.00 source\n * RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md\n */\nexport function transpileGLSLShader(source, stage) {\n  const sourceGLSLVersion = Number(source.match(/^#version[ \\t]+(\\d+)/m)?.[1] || 100);\n  if (sourceGLSLVersion !== 300) {\n    // TODO - we splurge on a longer error message to help deck.gl custom layer developers\n    throw new Error('luma.gl v9 only supports GLSL 3.00 shader sources');\n  }\n  switch (stage) {\n    case 'vertex':\n      source = convertShader(source, ES300_VERTEX_REPLACEMENTS);\n      return source;\n    case 'fragment':\n      source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);\n      return source;\n    default:\n      // Unknown shader stage\n      throw new Error(stage);\n  }\n}\n/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */\nconst ES300_REPLACEMENTS = [\n// Fix poorly formatted version directive\n[/^(#version[ \\t]+(100|300[ \\t]+es))?[ \\t]*\\n/, '#version 300 es\\n'],\n// The individual `texture...()` functions were replaced with `texture()` overloads\n[/\\btexture(2D|2DProj|Cube)Lod(EXT)?\\(/g, 'textureLod('], [/\\btexture(2D|2DProj|Cube)(EXT)?\\(/g, 'texture(']];\nconst ES300_VERTEX_REPLACEMENTS = [...ES300_REPLACEMENTS,\n// `attribute` keyword replaced with `in`\n[makeVariableTextRegExp('attribute'), 'in $1'],\n// `varying` keyword replaced with `out`\n[makeVariableTextRegExp('varying'), 'out $1']];\n/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */\nconst ES300_FRAGMENT_REPLACEMENTS = [...ES300_REPLACEMENTS,\n// `varying` keyword replaced with `in`\n[makeVariableTextRegExp('varying'), 'in $1']];\nfunction convertShader(source, replacements) {\n  for (const [pattern, replacement] of replacements) {\n    source = source.replace(pattern, replacement);\n  }\n  return source;\n}\n/**\n * Creates a regexp that tests for a specific variable type\n * @example\n *   should match:\n *     in float weight;\n *     out vec4 positions[2];\n *   should not match:\n *     void f(out float a, in float b) {}\n */\nfunction makeVariableTextRegExp(qualifier) {\n  return new RegExp(`\\\\b${qualifier}[ \\\\t]+(\\\\w+[ \\\\t]+\\\\w+(\\\\[\\\\w+\\\\])?;)`, 'g');\n}\n//# sourceMappingURL=transpile-glsl-shader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}