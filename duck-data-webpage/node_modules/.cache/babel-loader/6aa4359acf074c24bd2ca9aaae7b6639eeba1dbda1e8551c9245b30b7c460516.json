{"ast":null,"code":"// Note: This file will either be moved back to deck.gl or reformatted to web-monorepo standards\n// Disabling lint temporarily to facilitate copying code in and out of this repo\n/* eslint-disable */\n// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Layer, project32, picking, log } from '@deck.gl/core';\nimport { Texture } from '@luma.gl/core';\nimport { Model, Geometry } from '@luma.gl/engine';\nimport { phongMaterial } from '@luma.gl/shadertools';\nimport { MATRIX_ATTRIBUTES, shouldComposeModelMatrix } from \"../utils/matrix.js\";\nimport { simpleMeshUniforms } from \"./simple-mesh-layer-uniforms.js\";\nimport vs from \"./simple-mesh-layer-vertex.glsl.js\";\nimport fs from \"./simple-mesh-layer-fragment.glsl.js\";\nimport { getMeshBoundingBox } from '@loaders.gl/schema';\nfunction normalizeGeometryAttributes(attributes) {\n  const positionAttribute = attributes.positions || attributes.POSITION;\n  log.assert(positionAttribute, 'no \"postions\" or \"POSITION\" attribute in mesh');\n  const vertexCount = positionAttribute.value.length / positionAttribute.size;\n  let colorAttribute = attributes.COLOR_0 || attributes.colors;\n  if (!colorAttribute) {\n    colorAttribute = {\n      size: 3,\n      value: new Float32Array(vertexCount * 3).fill(1)\n    };\n  }\n  let normalAttribute = attributes.NORMAL || attributes.normals;\n  if (!normalAttribute) {\n    normalAttribute = {\n      size: 3,\n      value: new Float32Array(vertexCount * 3).fill(0)\n    };\n  }\n  let texCoordAttribute = attributes.TEXCOORD_0 || attributes.texCoords;\n  if (!texCoordAttribute) {\n    texCoordAttribute = {\n      size: 2,\n      value: new Float32Array(vertexCount * 2).fill(0)\n    };\n  }\n  return {\n    positions: positionAttribute,\n    colors: colorAttribute,\n    normals: normalAttribute,\n    texCoords: texCoordAttribute\n  };\n}\n/*\n * Convert mesh data into geometry\n * @returns {Geometry} geometry\n */\nfunction getGeometry(data) {\n  if (data instanceof Geometry) {\n    // @ts-expect-error data.attributes is readonly\n    data.attributes = normalizeGeometryAttributes(data.attributes);\n    return data;\n  } else if (data.attributes) {\n    return new Geometry({\n      ...data,\n      topology: 'triangle-list',\n      attributes: normalizeGeometryAttributes(data.attributes)\n    });\n  } else {\n    return new Geometry({\n      topology: 'triangle-list',\n      attributes: normalizeGeometryAttributes(data)\n    });\n  }\n}\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  mesh: {\n    type: 'object',\n    value: null,\n    async: true\n  },\n  texture: {\n    type: 'image',\n    value: null,\n    async: true\n  },\n  sizeScale: {\n    type: 'number',\n    value: 1,\n    min: 0\n  },\n  // _instanced is a hack to use world position instead of meter offsets in mesh\n  // TODO - formalize API\n  _instanced: true,\n  // NOTE(Tarek): Quick and dirty wireframe. Just draws\n  // the same mesh with LINE_STRIPS. Won't follow edges\n  // of the original mesh.\n  wireframe: false,\n  // Optional material for 'lighting' shader module\n  material: true,\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  // yaw, pitch and roll are in degrees\n  // https://en.wikipedia.org/wiki/Euler_angles\n  // [pitch, yaw, roll]\n  getOrientation: {\n    type: 'accessor',\n    value: [0, 0, 0]\n  },\n  getScale: {\n    type: 'accessor',\n    value: [1, 1, 1]\n  },\n  getTranslation: {\n    type: 'accessor',\n    value: [0, 0, 0]\n  },\n  // 4x4 matrix\n  getTransformMatrix: {\n    type: 'accessor',\n    value: []\n  },\n  textureParameters: {\n    type: 'object',\n    ignore: true,\n    value: null\n  }\n};\n/** Render a number of instances of an arbitrary 3D geometry. */\nclass SimpleMeshLayer extends Layer {\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, phongMaterial, picking, simpleMeshUniforms]\n    });\n  }\n  getBounds() {\n    if (this.props._instanced) {\n      return super.getBounds();\n    }\n    let result = this.state.positionBounds;\n    if (result) {\n      return result;\n    }\n    const {\n      mesh\n    } = this.props;\n    if (!mesh) {\n      return null;\n    }\n    // @ts-ignore Detect if mesh is generated by loaders.gl\n    result = mesh.header?.boundingBox;\n    if (!result) {\n      // Otherwise, calculate bounding box from positions\n      const {\n        attributes\n      } = getGeometry(mesh);\n      attributes.POSITION = attributes.POSITION || attributes.positions;\n      //@ts-expect-error\n      result = getMeshBoundingBox(attributes);\n    }\n    this.state.positionBounds = result;\n    return result;\n  }\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    // attributeManager is always defined in a primitive layer\n    attributeManager.addInstanced({\n      instancePositions: {\n        transition: true,\n        type: 'float64',\n        fp64: this.use64bitPositions(),\n        size: 3,\n        accessor: 'getPosition'\n      },\n      instanceColors: {\n        type: 'unorm8',\n        transition: true,\n        size: this.props.colorFormat.length,\n        accessor: 'getColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceModelMatrix: MATRIX_ATTRIBUTES\n    });\n    this.setState({\n      // Avoid luma.gl's missing uniform warning\n      // TODO - add feature to luma.gl to specify ignored uniforms?\n      emptyTexture: this.context.device.createTexture({\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {\n      this.state.positionBounds = null;\n      this.state.model?.destroy();\n      if (props.mesh) {\n        this.state.model = this.getModel(props.mesh);\n        const attributes = props.mesh.attributes || props.mesh;\n        this.setState({\n          hasNormals: Boolean(attributes.NORMAL || attributes.normals)\n        });\n      }\n      // attributeManager is always defined in a primitive layer\n      this.getAttributeManager().invalidateAll();\n    }\n    if (props.texture !== oldProps.texture && props.texture instanceof Texture) {\n      this.setTexture(props.texture);\n    }\n    if (this.state.model) {\n      this.state.model.setTopology(this.props.wireframe ? 'line-strip' : 'triangle-list');\n    }\n  }\n  finalizeState(context) {\n    super.finalizeState(context);\n    this.state.emptyTexture.delete();\n  }\n  draw(_ref) {\n    let {\n      uniforms\n    } = _ref;\n    const {\n      model\n    } = this.state;\n    if (!model) {\n      return;\n    }\n    const {\n      viewport,\n      renderPass\n    } = this.context;\n    const {\n      sizeScale,\n      coordinateSystem,\n      _instanced\n    } = this.props;\n    const simpleMeshProps = {\n      sizeScale,\n      composeModelMatrix: !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),\n      flatShading: !this.state.hasNormals\n    };\n    model.shaderInputs.setProps({\n      simpleMesh: simpleMeshProps\n    });\n    model.draw(renderPass);\n  }\n  get isLoaded() {\n    return Boolean(this.state?.model && super.isLoaded);\n  }\n  getModel(mesh) {\n    const model = new Model(this.context.device, {\n      ...this.getShaders(),\n      id: this.props.id,\n      bufferLayout: this.getAttributeManager().getBufferLayouts(),\n      geometry: getGeometry(mesh),\n      isInstanced: true\n    });\n    const {\n      texture\n    } = this.props;\n    const {\n      emptyTexture\n    } = this.state;\n    const simpleMeshProps = {\n      sampler: texture || emptyTexture,\n      hasTexture: Boolean(texture)\n    };\n    model.shaderInputs.setProps({\n      simpleMesh: simpleMeshProps\n    });\n    return model;\n  }\n  setTexture(texture) {\n    const {\n      emptyTexture,\n      model\n    } = this.state;\n    // props.mesh may not be ready at this time.\n    // The sampler will be set when `getModel` is called\n    if (model) {\n      const simpleMeshProps = {\n        sampler: texture || emptyTexture,\n        hasTexture: Boolean(texture)\n      };\n      model.shaderInputs.setProps({\n        simpleMesh: simpleMeshProps\n      });\n    }\n  }\n}\nSimpleMeshLayer.defaultProps = defaultProps;\nSimpleMeshLayer.layerName = 'SimpleMeshLayer';\nexport default SimpleMeshLayer;\n//# sourceMappingURL=simple-mesh-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}