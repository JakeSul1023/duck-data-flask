{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Resource } from \"./resource.js\";\n/** Abstract GPU buffer */\nexport class Buffer extends Resource {\n  static defaultProps = {\n    ...Resource.defaultProps,\n    usage: 0,\n    // Buffer.COPY_DST | Buffer.COPY_SRC\n    byteLength: 0,\n    byteOffset: 0,\n    data: null,\n    indexType: 'uint16',\n    mappedAtCreation: false\n  };\n  // Usage Flags\n  static MAP_READ = 0x01;\n  static MAP_WRITE = 0x02;\n  static COPY_SRC = 0x0004;\n  static COPY_DST = 0x0008;\n  /** Index buffer */\n  static INDEX = 0x0010;\n  /** Vertex buffer */\n  static VERTEX = 0x0020;\n  /** Uniform buffer */\n  static UNIFORM = 0x0040;\n  /** Storage buffer */\n  static STORAGE = 0x0080;\n  static INDIRECT = 0x0100;\n  static QUERY_RESOLVE = 0x0200;\n  get [Symbol.toStringTag]() {\n    return 'Buffer';\n  }\n  /** The usage with which this buffer was created */\n  usage;\n  /** For index buffers, whether indices are 16 or 32 bit */\n  indexType;\n  /** \"Time\" of last update, can be used to check if redraw is needed */\n  updateTimestamp;\n  constructor(device, props) {\n    const deducedProps = {\n      ...props\n    };\n    // Deduce indexType\n    if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {\n      if (props.data instanceof Uint32Array) {\n        deducedProps.indexType = 'uint32';\n      } else if (props.data instanceof Uint16Array) {\n        deducedProps.indexType = 'uint16';\n      }\n    }\n    // Remove data from props before storing, we don't want to hold on to a big chunk of memory\n    delete deducedProps.data;\n    super(device, deducedProps, Buffer.defaultProps);\n    this.usage = deducedProps.usage || 0;\n    this.indexType = deducedProps.indexType;\n    // TODO - perhaps this should be set on async write completion?\n    this.updateTimestamp = device.incrementTimestamp();\n  }\n  /**\n   * Create a copy of this Buffer with new byteLength, with same props but of the specified size.\n   * @note Does not copy contents of the cloned Buffer.\n   */\n  clone(props) {\n    return this.device.createBuffer({\n      ...this.props,\n      ...props\n    });\n  }\n  /** Read data synchronously. @note WebGL2 only */\n  readSyncWebGL(byteOffset, byteLength) {\n    throw new Error('not implemented');\n  }\n  // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)\n  /** Max amount of debug data saved. Two vec4's */\n  static DEBUG_DATA_MAX_LENGTH = 32;\n  /** A partial CPU-side copy of the data in this buffer, for debugging purposes */\n  debugData = new ArrayBuffer(0);\n  /** This doesn't handle partial non-zero offset updates correctly */\n  _setDebugData(data, byteOffset, byteLength) {\n    const arrayBuffer = ArrayBuffer.isView(data) ? data.buffer : data;\n    const debugDataLength = Math.min(data ? data.byteLength : byteLength, Buffer.DEBUG_DATA_MAX_LENGTH);\n    if (arrayBuffer === null) {\n      this.debugData = new ArrayBuffer(debugDataLength);\n    } else if (byteOffset === 0 && byteLength === arrayBuffer.byteLength) {\n      this.debugData = arrayBuffer.slice(0, debugDataLength);\n    } else {\n      this.debugData = arrayBuffer.slice(byteOffset, byteOffset + debugDataLength);\n    }\n  }\n}\n//# sourceMappingURL=buffer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}