{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@deck.gl/core';\n/**\n * \"Normalizes\" complete or partial GeoJSON data into iterable list of features\n * Can accept GeoJSON geometry or \"Feature\", \"FeatureCollection\" in addition\n * to plain arrays and iterables.\n * Works by extracting the feature array or wrapping single objects in an array,\n * so that subsequent code can simply iterate over features.\n *\n * @param {object} geojson - geojson data\n * @param {Object|Array} data - geojson object (FeatureCollection, Feature or\n *  Geometry) or array of features\n * @return {Array|\"iteratable\"} - iterable list of features\n */\nexport function getGeojsonFeatures(geojson) {\n  // If array, assume this is a list of features\n  if (Array.isArray(geojson)) {\n    return geojson;\n  }\n  log.assert(geojson.type, 'GeoJSON does not have type');\n  switch (geojson.type) {\n    case 'Feature':\n      // Wrap the feature in a 'Features' array\n      return [geojson];\n    case 'FeatureCollection':\n      // Just return the 'Features' array from the collection\n      log.assert(Array.isArray(geojson.features), 'GeoJSON does not have features array');\n      return geojson.features;\n    default:\n      // Assume it's a geometry, we'll check type in separateGeojsonFeatures\n      // Wrap the geometry object in a 'Feature' object and wrap in an array\n      return [{\n        geometry: geojson\n      }];\n  }\n}\n// Linearize\nexport function separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {\n  const separated = {\n    pointFeatures: [],\n    lineFeatures: [],\n    polygonFeatures: [],\n    polygonOutlineFeatures: []\n  };\n  const {\n    startRow = 0,\n    endRow = features.length\n  } = dataRange;\n  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {\n    const feature = features[featureIndex];\n    const {\n      geometry\n    } = feature;\n    if (!geometry) {\n      // geometry can be null per specification\n      continue; // eslint-disable-line no-continue\n    }\n    if (geometry.type === 'GeometryCollection') {\n      log.assert(Array.isArray(geometry.geometries), 'GeoJSON does not have geometries array');\n      const {\n        geometries\n      } = geometry;\n      for (let i = 0; i < geometries.length; i++) {\n        const subGeometry = geometries[i];\n        separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);\n      }\n    } else {\n      separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);\n    }\n  }\n  return separated;\n}\nfunction separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {\n  const {\n    type,\n    coordinates\n  } = geometry;\n  const {\n    pointFeatures,\n    lineFeatures,\n    polygonFeatures,\n    polygonOutlineFeatures\n  } = separated;\n  if (!validateGeometry(type, coordinates)) {\n    // Avoid hard failure if some features are malformed\n    log.warn(`${type} coordinates are malformed`)();\n    return;\n  }\n  // Split each feature, but keep track of the source feature and index (for Multi* geometries)\n  switch (type) {\n    case 'Point':\n      pointFeatures.push(wrapFeature({\n        geometry\n      }, sourceFeature, sourceFeatureIndex));\n      break;\n    case 'MultiPoint':\n      coordinates.forEach(point => {\n        pointFeatures.push(wrapFeature({\n          geometry: {\n            type: 'Point',\n            coordinates: point\n          }\n        }, sourceFeature, sourceFeatureIndex));\n      });\n      break;\n    case 'LineString':\n      lineFeatures.push(wrapFeature({\n        geometry\n      }, sourceFeature, sourceFeatureIndex));\n      break;\n    case 'MultiLineString':\n      // Break multilinestrings into multiple lines\n      coordinates.forEach(path => {\n        lineFeatures.push(wrapFeature({\n          geometry: {\n            type: 'LineString',\n            coordinates: path\n          }\n        }, sourceFeature, sourceFeatureIndex));\n      });\n      break;\n    case 'Polygon':\n      polygonFeatures.push(wrapFeature({\n        geometry\n      }, sourceFeature, sourceFeatureIndex));\n      // Break polygon into multiple lines\n      coordinates.forEach(path => {\n        polygonOutlineFeatures.push(wrapFeature({\n          geometry: {\n            type: 'LineString',\n            coordinates: path\n          }\n        }, sourceFeature, sourceFeatureIndex));\n      });\n      break;\n    case 'MultiPolygon':\n      // Break multipolygons into multiple polygons\n      coordinates.forEach(polygon => {\n        polygonFeatures.push(wrapFeature({\n          geometry: {\n            type: 'Polygon',\n            coordinates: polygon\n          }\n        }, sourceFeature, sourceFeatureIndex));\n        // Break polygon into multiple lines\n        polygon.forEach(path => {\n          polygonOutlineFeatures.push(wrapFeature({\n            geometry: {\n              type: 'LineString',\n              coordinates: path\n            }\n          }, sourceFeature, sourceFeatureIndex));\n        });\n      });\n      break;\n    default:\n  }\n}\n/**\n * Simple GeoJSON validation util. For perf reasons we do not validate against the full spec,\n * only the following:\n   - geometry.type is supported\n   - geometry.coordinate has correct nesting level\n */\nconst COORDINATE_NEST_LEVEL = {\n  Point: 1,\n  MultiPoint: 2,\n  LineString: 2,\n  MultiLineString: 3,\n  Polygon: 3,\n  MultiPolygon: 4\n};\nexport function validateGeometry(type, coordinates) {\n  let nestLevel = COORDINATE_NEST_LEVEL[type];\n  log.assert(nestLevel, `Unknown GeoJSON type ${type}`);\n  while (coordinates && --nestLevel > 0) {\n    coordinates = coordinates[0];\n  }\n  return coordinates && Number.isFinite(coordinates[0]);\n}","map":{"version":3,"names":["log","getGeojsonFeatures","geojson","Array","isArray","assert","type","features","geometry","separateGeojsonFeatures","wrapFeature","dataRange","separated","pointFeatures","lineFeatures","polygonFeatures","polygonOutlineFeatures","startRow","endRow","length","featureIndex","feature","geometries","i","subGeometry","separateGeometry","sourceFeature","sourceFeatureIndex","coordinates","validateGeometry","warn","push","forEach","point","path","polygon","COORDINATE_NEST_LEVEL","Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon","nestLevel","Number","isFinite"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\layers\\src\\geojson-layer\\geojson.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {log} from '@deck.gl/core';\nimport type {\n  Feature,\n  GeoJSON,\n  GeoJsonGeometryTypes,\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon\n} from 'geojson';\n\ntype SupportedGeometry = Point | MultiPoint | LineString | MultiLineString | Polygon | MultiPolygon;\n\nexport type SeparatedGeometries = {\n  pointFeatures: {geometry: Point}[];\n  lineFeatures: {geometry: LineString}[];\n  polygonFeatures: {geometry: Polygon}[];\n  polygonOutlineFeatures: {geometry: LineString}[];\n};\n\n/**\n * \"Normalizes\" complete or partial GeoJSON data into iterable list of features\n * Can accept GeoJSON geometry or \"Feature\", \"FeatureCollection\" in addition\n * to plain arrays and iterables.\n * Works by extracting the feature array or wrapping single objects in an array,\n * so that subsequent code can simply iterate over features.\n *\n * @param {object} geojson - geojson data\n * @param {Object|Array} data - geojson object (FeatureCollection, Feature or\n *  Geometry) or array of features\n * @return {Array|\"iteratable\"} - iterable list of features\n */\nexport function getGeojsonFeatures(geojson: GeoJSON): Feature[] {\n  // If array, assume this is a list of features\n  if (Array.isArray(geojson)) {\n    return geojson;\n  }\n\n  log.assert(geojson.type, 'GeoJSON does not have type');\n\n  switch (geojson.type) {\n    case 'Feature':\n      // Wrap the feature in a 'Features' array\n      return [geojson];\n    case 'FeatureCollection':\n      // Just return the 'Features' array from the collection\n      log.assert(Array.isArray(geojson.features), 'GeoJSON does not have features array');\n      return geojson.features;\n    default:\n      // Assume it's a geometry, we'll check type in separateGeojsonFeatures\n      // Wrap the geometry object in a 'Feature' object and wrap in an array\n      return [{geometry: geojson}] as Feature[];\n  }\n}\n\n// Linearize\nexport function separateGeojsonFeatures(\n  features: Feature[],\n  wrapFeature: <T>(row: T, sourceObject: any, sourceObjectIndex: number) => T,\n  dataRange: {startRow?: number; endRow?: number} = {}\n): SeparatedGeometries {\n  const separated: SeparatedGeometries = {\n    pointFeatures: [],\n    lineFeatures: [],\n    polygonFeatures: [],\n    polygonOutlineFeatures: []\n  };\n  const {startRow = 0, endRow = features.length} = dataRange;\n\n  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {\n    const feature = features[featureIndex];\n    const {geometry} = feature;\n\n    if (!geometry) {\n      // geometry can be null per specification\n      continue; // eslint-disable-line no-continue\n    }\n\n    if (geometry.type === 'GeometryCollection') {\n      log.assert(Array.isArray(geometry.geometries), 'GeoJSON does not have geometries array');\n      const {geometries} = geometry;\n      for (let i = 0; i < geometries.length; i++) {\n        const subGeometry = geometries[i];\n        separateGeometry(\n          subGeometry as SupportedGeometry,\n          separated,\n          wrapFeature,\n          feature,\n          featureIndex\n        );\n      }\n    } else {\n      separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);\n    }\n  }\n\n  return separated;\n}\n\nfunction separateGeometry(\n  geometry: SupportedGeometry,\n  separated: SeparatedGeometries,\n  wrapFeature: <T>(row: T, sourceObject: any, sourceObjectIndex: number) => T,\n  sourceFeature: Feature,\n  sourceFeatureIndex: number\n) {\n  const {type, coordinates} = geometry;\n  const {pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures} = separated;\n\n  if (!validateGeometry(type, coordinates)) {\n    // Avoid hard failure if some features are malformed\n    log.warn(`${type} coordinates are malformed`)();\n    return;\n  }\n\n  // Split each feature, but keep track of the source feature and index (for Multi* geometries)\n  switch (type) {\n    case 'Point':\n      pointFeatures.push(\n        wrapFeature(\n          {\n            geometry\n          },\n          sourceFeature,\n          sourceFeatureIndex\n        )\n      );\n      break;\n    case 'MultiPoint':\n      coordinates.forEach(point => {\n        pointFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'Point', coordinates: point}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n      });\n      break;\n    case 'LineString':\n      lineFeatures.push(\n        wrapFeature(\n          {\n            geometry\n          },\n          sourceFeature,\n          sourceFeatureIndex\n        )\n      );\n      break;\n    case 'MultiLineString':\n      // Break multilinestrings into multiple lines\n      coordinates.forEach(path => {\n        lineFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'LineString', coordinates: path}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n      });\n      break;\n    case 'Polygon':\n      polygonFeatures.push(\n        wrapFeature(\n          {\n            geometry\n          },\n          sourceFeature,\n          sourceFeatureIndex\n        )\n      );\n      // Break polygon into multiple lines\n      coordinates.forEach(path => {\n        polygonOutlineFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'LineString', coordinates: path}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n      });\n      break;\n    case 'MultiPolygon':\n      // Break multipolygons into multiple polygons\n      coordinates.forEach(polygon => {\n        polygonFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'Polygon', coordinates: polygon}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n        // Break polygon into multiple lines\n        polygon.forEach(path => {\n          polygonOutlineFeatures.push(\n            wrapFeature(\n              {\n                geometry: {type: 'LineString', coordinates: path}\n              },\n              sourceFeature,\n              sourceFeatureIndex\n            )\n          );\n        });\n      });\n      break;\n    default:\n  }\n}\n\n/**\n * Simple GeoJSON validation util. For perf reasons we do not validate against the full spec,\n * only the following:\n   - geometry.type is supported\n   - geometry.coordinate has correct nesting level\n */\nconst COORDINATE_NEST_LEVEL: Record<SupportedGeometry['type'], number> = {\n  Point: 1,\n  MultiPoint: 2,\n  LineString: 2,\n  MultiLineString: 3,\n  Polygon: 3,\n  MultiPolygon: 4\n};\n\nexport function validateGeometry(type: GeoJsonGeometryTypes, coordinates: any): boolean {\n  let nestLevel = COORDINATE_NEST_LEVEL[type] as number;\n\n  log.assert(nestLevel, `Unknown GeoJSON type ${type}`);\n\n  while (coordinates && --nestLevel > 0) {\n    coordinates = coordinates[0];\n  }\n\n  return coordinates && Number.isFinite(coordinates[0]);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}