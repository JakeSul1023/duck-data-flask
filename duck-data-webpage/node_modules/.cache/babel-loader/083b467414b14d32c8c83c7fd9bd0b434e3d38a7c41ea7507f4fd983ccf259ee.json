{"ast":null,"code":"import { WorkerBody } from '@loaders.gl/worker-utils';\n// import {validateLoaderVersion} from './validate-loader-version';\nlet requestId = 0;\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n * @param loader\n */\nexport async function createLoaderWorker(loader) {\n  // Check that we are actually in a worker thread\n  if (!(await WorkerBody.inWorkerThread())) {\n    return;\n  }\n  WorkerBody.onmessage = async (type, payload) => {\n    switch (type) {\n      case 'process':\n        try {\n          // validateLoaderVersion(loader, data.source.split('@')[1]);\n          const {\n            input,\n            options = {},\n            context = {}\n          } = payload;\n          const result = await parseData({\n            loader,\n            arrayBuffer: input,\n            options,\n            // @ts-expect-error fetch missing\n            context: {\n              ...context,\n              _parse: parseOnMainThread\n            }\n          });\n          WorkerBody.postMessage('done', {\n            result\n          });\n        } catch (error) {\n          const message = error instanceof Error ? error.message : '';\n          WorkerBody.postMessage('error', {\n            error: message\n          });\n        }\n        break;\n      default:\n    }\n  };\n}\nfunction parseOnMainThread(arrayBuffer, loader, options, context) {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n    /**\n     */\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n        default:\n        // ignore\n      }\n    };\n    WorkerBody.addEventListener(onMessage);\n    // Ask the main thread to decode data\n    const payload = {\n      id,\n      input: arrayBuffer,\n      options\n    };\n    WorkerBody.postMessage('process', payload);\n  });\n}\n// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)\n// TODO - Why not support async loader.parse* funcs here?\n// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?\n// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse\nasync function parseData({\n  loader,\n  arrayBuffer,\n  options,\n  context\n}) {\n  let data;\n  let parser;\n  if (loader.parseSync || loader.parse) {\n    data = arrayBuffer;\n    parser = loader.parseSync || loader.parse;\n  } else if (loader.parseTextSync) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(arrayBuffer);\n    parser = loader.parseTextSync;\n  } else {\n    throw new Error(`Could not load data with ${loader.name} loader`);\n  }\n  // TODO - proper merge in of loader options...\n  options = {\n    ...options,\n    modules: loader && loader.options && loader.options.modules || {},\n    worker: false\n  };\n  return await parser(data, {\n    ...options\n  }, context, loader);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}