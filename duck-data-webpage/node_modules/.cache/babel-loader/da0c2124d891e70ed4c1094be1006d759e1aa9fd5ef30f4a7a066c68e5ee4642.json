{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { DataViewFile, compareArrayBuffers, concatenateArrayBuffers } from '@loaders.gl/loader-utils';\nimport { parseEoCDRecord } from \"./end-of-central-directory.js\";\nimport { createZip64Info, setFieldToNumber } from \"./zip64-info-generation.js\";\n// offsets accroding to https://en.wikipedia.org/wiki/ZIP_(file_format)\nconst CD_COMPRESSED_SIZE_OFFSET = 20;\nconst CD_UNCOMPRESSED_SIZE_OFFSET = 24;\nconst CD_FILE_NAME_LENGTH_OFFSET = 28;\nconst CD_EXTRA_FIELD_LENGTH_OFFSET = 30;\nconst CD_START_DISK_OFFSET = 32;\nconst CD_LOCAL_HEADER_OFFSET_OFFSET = 42;\nconst CD_FILE_NAME_OFFSET = 46n;\nexport const signature = new Uint8Array([0x50, 0x4b, 0x01, 0x02]);\n/**\n * Parses central directory file header of zip file\n * @param headerOffset - offset in the archive where header starts\n * @param buffer - buffer containing whole array\n * @returns Info from the header\n */\nexport const parseZipCDFileHeader = async (headerOffset, file) => {\n  if (headerOffset >= file.length) {\n    return null;\n  }\n  const mainHeader = new DataView(await file.slice(headerOffset, headerOffset + CD_FILE_NAME_OFFSET));\n  const magicBytes = mainHeader.buffer.slice(0, 4);\n  if (!compareArrayBuffers(magicBytes, signature.buffer)) {\n    return null;\n  }\n  const compressedSize = BigInt(mainHeader.getUint32(CD_COMPRESSED_SIZE_OFFSET, true));\n  const uncompressedSize = BigInt(mainHeader.getUint32(CD_UNCOMPRESSED_SIZE_OFFSET, true));\n  const extraFieldLength = mainHeader.getUint16(CD_EXTRA_FIELD_LENGTH_OFFSET, true);\n  const startDisk = BigInt(mainHeader.getUint16(CD_START_DISK_OFFSET, true));\n  const fileNameLength = mainHeader.getUint16(CD_FILE_NAME_LENGTH_OFFSET, true);\n  const additionalHeader = await file.slice(headerOffset + CD_FILE_NAME_OFFSET, headerOffset + CD_FILE_NAME_OFFSET + BigInt(fileNameLength + extraFieldLength));\n  const filenameBytes = additionalHeader.slice(0, fileNameLength);\n  const fileName = new TextDecoder().decode(filenameBytes);\n  const extraOffset = headerOffset + CD_FILE_NAME_OFFSET + BigInt(fileNameLength);\n  const oldFormatOffset = mainHeader.getUint32(CD_LOCAL_HEADER_OFFSET_OFFSET, true);\n  const localHeaderOffset = BigInt(oldFormatOffset);\n  const extraField = new DataView(additionalHeader.slice(fileNameLength, additionalHeader.byteLength));\n  // looking for info that might be also be in zip64 extra field\n  const zip64data = {\n    uncompressedSize,\n    compressedSize,\n    localHeaderOffset,\n    startDisk\n  };\n  const res = findZip64DataInExtra(zip64data, extraField);\n  return {\n    ...zip64data,\n    ...res,\n    extraFieldLength,\n    fileNameLength,\n    fileName,\n    extraOffset\n  };\n};\n/**\n * Create iterator over files of zip archive\n * @param fileProvider - file provider that provider random access to the file\n */\nexport async function* makeZipCDHeaderIterator(fileProvider) {\n  const {\n    cdStartOffset,\n    cdByteSize\n  } = await parseEoCDRecord(fileProvider);\n  const centralDirectory = new DataViewFile(new DataView(await fileProvider.slice(cdStartOffset, cdStartOffset + cdByteSize)));\n  let cdHeader = await parseZipCDFileHeader(0n, centralDirectory);\n  while (cdHeader) {\n    yield cdHeader;\n    cdHeader = await parseZipCDFileHeader(cdHeader.extraOffset + BigInt(cdHeader.extraFieldLength), centralDirectory);\n  }\n}\n/**\n * returns the number written in the provided bytes\n * @param bytes two bytes containing the number\n * @returns the number written in the provided bytes\n */\nconst getUint16 = function () {\n  return (arguments.length <= 0 ? undefined : arguments[0]) + (arguments.length <= 1 ? undefined : arguments[1]) * 16;\n};\n/**\n * reads all nesessary data from zip64 record in the extra data\n * @param zip64data values that might be in zip64 record\n * @param extraField full extra data\n * @returns data read from zip64\n */\nconst findZip64DataInExtra = (zip64data, extraField) => {\n  const zip64dataList = findExpectedData(zip64data);\n  const zip64DataRes = {};\n  if (zip64dataList.length > 0) {\n    // total length of data in zip64 notation in bytes\n    const zip64chunkSize = zip64dataList.reduce((sum, curr) => sum + curr.length, 0);\n    // we're looking for the zip64 nontation header (0x0001)\n    // and a size field with a correct value next to it\n    const offsetInExtraData = new Uint8Array(extraField.buffer).findIndex((_val, i, arr) => getUint16(arr[i], arr[i + 1]) === 0x0001 && getUint16(arr[i + 2], arr[i + 3]) === zip64chunkSize);\n    // then we read all the nesessary fields from the zip64 data\n    let bytesRead = 0;\n    for (const note of zip64dataList) {\n      const offset = bytesRead;\n      zip64DataRes[note.name] = extraField.getBigUint64(offsetInExtraData + 4 + offset, true);\n      bytesRead = offset + note.length;\n    }\n  }\n  return zip64DataRes;\n};\n/**\n * frind data that's expected to be in zip64\n * @param zip64data values that might be in zip64 record\n * @returns zip64 data description\n */\nconst findExpectedData = zip64data => {\n  // We define fields that should be in zip64 data\n  const zip64dataList = [];\n  if (zip64data.uncompressedSize === BigInt(0xffffffff)) {\n    zip64dataList.push({\n      name: 'uncompressedSize',\n      length: 8\n    });\n  }\n  if (zip64data.compressedSize === BigInt(0xffffffff)) {\n    zip64dataList.push({\n      name: 'compressedSize',\n      length: 8\n    });\n  }\n  if (zip64data.localHeaderOffset === BigInt(0xffffffff)) {\n    zip64dataList.push({\n      name: 'localHeaderOffset',\n      length: 8\n    });\n  }\n  if (zip64data.startDisk === BigInt(0xffffffff)) {\n    zip64dataList.push({\n      name: 'startDisk',\n      length: 4\n    });\n  }\n  return zip64dataList;\n};\n/**\n * generates cd header for the file\n * @param options info that can be placed into cd header\n * @returns buffer with header\n */\nexport function generateCDHeader(options) {\n  const optionsToUse = {\n    ...options,\n    fnlength: options.fileName.length,\n    extraLength: 0\n  };\n  let zip64header = new ArrayBuffer(0);\n  const optionsToZip64 = {};\n  if (optionsToUse.offset >= 0xffffffff) {\n    optionsToZip64.offset = optionsToUse.offset;\n    optionsToUse.offset = BigInt(0xffffffff);\n  }\n  if (optionsToUse.length >= 0xffffffff) {\n    optionsToZip64.size = optionsToUse.length;\n    optionsToUse.length = 0xffffffff;\n  }\n  if (Object.keys(optionsToZip64).length) {\n    zip64header = createZip64Info(optionsToZip64);\n    optionsToUse.extraLength = zip64header.byteLength;\n  }\n  const header = new DataView(new ArrayBuffer(Number(CD_FILE_NAME_OFFSET)));\n  for (const field of ZIP_HEADER_FIELDS) {\n    setFieldToNumber(header, field.size, field.offset, optionsToUse[field.name ?? ''] ?? field.default ?? 0);\n  }\n  const encodedName = new TextEncoder().encode(optionsToUse.fileName);\n  const resHeader = concatenateArrayBuffers(header.buffer, encodedName, zip64header);\n  return resHeader;\n}\n/** Fields map */\nconst ZIP_HEADER_FIELDS = [\n// Central directory file header signature = 0x02014b50\n{\n  offset: 0,\n  size: 4,\n  default: new DataView(signature.buffer).getUint32(0, true)\n},\n// Version made by\n{\n  offset: 4,\n  size: 2,\n  default: 45\n},\n// Version needed to extract (minimum)\n{\n  offset: 6,\n  size: 2,\n  default: 45\n},\n// General purpose bit flag\n{\n  offset: 8,\n  size: 2,\n  default: 0\n},\n// Compression method\n{\n  offset: 10,\n  size: 2,\n  default: 0\n},\n// File last modification time\n{\n  offset: 12,\n  size: 2,\n  default: 0\n},\n// File last modification date\n{\n  offset: 14,\n  size: 2,\n  default: 0\n},\n// CRC-32 of uncompressed data\n{\n  offset: 16,\n  size: 4,\n  name: 'crc32'\n},\n// Compressed size (or 0xffffffff for ZIP64)\n{\n  offset: 20,\n  size: 4,\n  name: 'length'\n},\n// Uncompressed size (or 0xffffffff for ZIP64)\n{\n  offset: 24,\n  size: 4,\n  name: 'length'\n},\n// File name length (n)\n{\n  offset: 28,\n  size: 2,\n  name: 'fnlength'\n},\n// Extra field length (m)\n{\n  offset: 30,\n  size: 2,\n  default: 0,\n  name: 'extraLength'\n},\n// File comment length (k)\n{\n  offset: 32,\n  size: 2,\n  default: 0\n},\n// Disk number where file starts (or 0xffff for ZIP64)\n{\n  offset: 34,\n  size: 2,\n  default: 0\n},\n// Internal file attributes\n{\n  offset: 36,\n  size: 2,\n  default: 0\n},\n// External file attributes\n{\n  offset: 38,\n  size: 4,\n  default: 0\n},\n// Relative offset of local file header\n{\n  offset: 42,\n  size: 4,\n  name: 'offset'\n}];","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}