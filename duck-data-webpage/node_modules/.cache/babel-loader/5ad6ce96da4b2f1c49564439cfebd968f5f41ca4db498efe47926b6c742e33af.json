{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Matrix3, _MathUtils } from '@math.gl/core';\nconst scratchMatrix = new Matrix3();\nconst scratchUnitary = new Matrix3();\nconst scratchDiagonal = new Matrix3();\nconst jMatrix = new Matrix3();\nconst jMatrixTranspose = new Matrix3();\n/**\n * Computes the eigenvectors and eigenvalues of a symmetric matrix.\n *\n * - Returns a diagonal matrix and unitary matrix such that:\n * `matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)`\n * - The values along the diagonal of the diagonal matrix are the eigenvalues. The columns\n * of the unitary matrix are the corresponding eigenvectors.\n * - This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n * section 8.4.3 The Classical Jacobi Algorithm\n *\n * @param matrix The 3x3 matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.\n * @param result Optional object with unitary and diagonal properties which are matrices onto which to store the result.\n * @returns An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.\n *\n * @example\n * const a = //... symmetric matrix\n * const result = {\n *   unitary : new Matrix3(),\n *   diagonal : new Matrix3()\n * };\n * computeEigenDecomposition(a, result);\n *\n * const unitaryTranspose = Matrix3.transpose(result.unitary, new Matrix3());\n * const b = Matrix3.multiply(result.unitary, result.diagonal, new Matrix3());\n * Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n *\n * const lambda = result.diagonal.getColumn(0, new Vector3()).x;  // first eigenvalue\n * const v = result.unitary.getColumn(0, new Vector3());          // first eigenvector\n * const c = v.multiplyByScalar(lambda);                          // equal to v.transformByMatrix3(a)\n */\nexport function computeEigenDecomposition(matrix) {\n  let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const EIGEN_TOLERANCE = _MathUtils.EPSILON20;\n  const EIGEN_MAX_SWEEPS = 10;\n  let count = 0;\n  let sweep = 0;\n  const unitaryMatrix = scratchUnitary;\n  const diagonalMatrix = scratchDiagonal;\n  unitaryMatrix.identity();\n  diagonalMatrix.copy(matrix);\n  const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);\n  while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {\n    shurDecomposition(diagonalMatrix, jMatrix);\n    jMatrixTranspose.copy(jMatrix).transpose();\n    diagonalMatrix.multiplyRight(jMatrix);\n    diagonalMatrix.multiplyLeft(jMatrixTranspose);\n    unitaryMatrix.multiplyRight(jMatrix);\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n  result.unitary = unitaryMatrix.toTarget(result.unitary);\n  result.diagonal = diagonalMatrix.toTarget(result.diagonal);\n  return result;\n}\nfunction computeFrobeniusNorm(matrix) {\n  let norm = 0.0;\n  for (let i = 0; i < 9; ++i) {\n    const temp = matrix[i];\n    norm += temp * temp;\n  }\n  return Math.sqrt(norm);\n}\nconst rowVal = [1, 0, 0];\nconst colVal = [2, 2, 1];\n// Computes the \"off-diagonal\" Frobenius norm.\n// Assumes matrix is symmetric.\nfunction offDiagonalFrobeniusNorm(matrix) {\n  let norm = 0.0;\n  for (let i = 0; i < 3; ++i) {\n    const temp = matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n  return Math.sqrt(norm);\n}\n// The routine takes a matrix, which is assumed to be symmetric, and\n// finds the largest off-diagonal term, and then creates\n// a matrix (result) which can be used to help reduce it\n//\n// This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n// section 8.4.2 The 2by2 Symmetric Schur Decomposition.\n//\n// eslint-disable-next-line max-statements\nfunction shurDecomposition(matrix, result) {\n  const tolerance = _MathUtils.EPSILON15;\n  let maxDiagonal = 0.0;\n  let rotAxis = 1;\n  // find pivot (rotAxis) based on max diagonal of matrix\n  for (let i = 0; i < 3; ++i) {\n    const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])]);\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n  const p = rowVal[rotAxis];\n  const q = colVal[rotAxis];\n  let c = 1.0;\n  let s = 0.0;\n  if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p)]) > tolerance) {\n    const qq = matrix[scratchMatrix.getElementIndex(q, q)];\n    const pp = matrix[scratchMatrix.getElementIndex(p, p)];\n    const qp = matrix[scratchMatrix.getElementIndex(q, p)];\n    const tau = (qq - pp) / 2.0 / qp;\n    let t;\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n  // Copy into result\n  Matrix3.IDENTITY.to(result);\n  result[scratchMatrix.getElementIndex(p, p)] = result[scratchMatrix.getElementIndex(q, q)] = c;\n  result[scratchMatrix.getElementIndex(q, p)] = s;\n  result[scratchMatrix.getElementIndex(p, q)] = -s;\n  return result;\n}\n//# sourceMappingURL=compute-eigen-decomposition.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}