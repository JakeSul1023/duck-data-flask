{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Buffer } from '@luma.gl/core';\nimport { typedArrayFromDataType, getBufferAttributeLayout, getStride, dataTypeFromTypedArray } from \"./gl-utils.js\";\nimport typedArrayManager from \"../../utils/typed-array-manager.js\";\nimport { toDoublePrecisionArray } from \"../../utils/math-utils.js\";\nimport log from \"../../utils/log.js\";\nfunction resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {\n  if (shaderAttributeOptions.offset) {\n    log.removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();\n  }\n  // All shader attributes share the parent's stride\n  const stride = getStride(baseAccessor);\n  // `vertexOffset` is used to access the neighboring vertex's value\n  // e.g. `nextPositions` in polygon\n  const vertexOffset = shaderAttributeOptions.vertexOffset !== undefined ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;\n  // `elementOffset` is defined when shader attribute's size is smaller than the parent's\n  // e.g. `translations` in transform matrix\n  const elementOffset = shaderAttributeOptions.elementOffset || 0;\n  const offset =\n  // offsets defined by the attribute\n  vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (\n  // offsets defined by external buffers if any\n  baseAccessor.offset || 0);\n  return {\n    ...shaderAttributeOptions,\n    offset,\n    stride\n  };\n}\nfunction resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {\n  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);\n  return {\n    high: resolvedOptions,\n    low: {\n      ...resolvedOptions,\n      offset: resolvedOptions.offset + baseAccessor.size * 4\n    }\n  };\n}\nexport default class DataColumn {\n  /* eslint-disable max-statements */\n  constructor(device, opts, state) {\n    this._buffer = null;\n    this.device = device;\n    this.id = opts.id || '';\n    this.size = opts.size || 1;\n    const logicalType = opts.logicalType || opts.type;\n    const doublePrecision = logicalType === 'float64';\n    let {\n      defaultValue\n    } = opts;\n    defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);\n    let bufferType;\n    if (doublePrecision) {\n      bufferType = 'float32';\n    } else if (!logicalType && opts.isIndexed) {\n      bufferType = 'uint32';\n    } else {\n      bufferType = logicalType || 'float32';\n    }\n    // This is the attribute type defined by the layer\n    // If an external buffer is provided, this.type may be overwritten\n    // But we always want to use defaultType for allocation\n    let defaultType = typedArrayFromDataType(logicalType || bufferType);\n    this.doublePrecision = doublePrecision;\n    // `fp64: false` tells a double-precision attribute to allocate Float32Arrays\n    // by default when using auto-packing. This is more efficient in use cases where\n    // high precision is unnecessary, but the `64Low` attribute is still required\n    // by the shader.\n    if (doublePrecision && opts.fp64 === false) {\n      defaultType = Float32Array;\n    }\n    this.value = null;\n    this.settings = {\n      ...opts,\n      defaultType,\n      defaultValue: defaultValue,\n      logicalType,\n      type: bufferType,\n      normalized: bufferType.includes('norm'),\n      size: this.size,\n      bytesPerElement: defaultType.BYTES_PER_ELEMENT\n    };\n    this.state = {\n      ...state,\n      externalBuffer: null,\n      bufferAccessor: this.settings,\n      allocatedValue: null,\n      numInstances: 0,\n      bounds: null,\n      constant: false\n    };\n  }\n  /* eslint-enable max-statements */\n  get isConstant() {\n    return this.state.constant;\n  }\n  get buffer() {\n    return this._buffer;\n  }\n  get byteOffset() {\n    const accessor = this.getAccessor();\n    if (accessor.vertexOffset) {\n      return accessor.vertexOffset * getStride(accessor);\n    }\n    return 0;\n  }\n  get numInstances() {\n    return this.state.numInstances;\n  }\n  set numInstances(n) {\n    this.state.numInstances = n;\n  }\n  delete() {\n    if (this._buffer) {\n      this._buffer.delete();\n      this._buffer = null;\n    }\n    typedArrayManager.release(this.state.allocatedValue);\n  }\n  getBuffer() {\n    if (this.state.constant) {\n      return null;\n    }\n    return this.state.externalBuffer || this._buffer;\n  }\n  getValue(attributeName = this.id, options = null) {\n    const result = {};\n    if (this.state.constant) {\n      const value = this.value;\n      if (options) {\n        const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);\n        const offset = shaderAttributeDef.offset / value.BYTES_PER_ELEMENT;\n        const size = shaderAttributeDef.size || this.size;\n        result[attributeName] = value.subarray(offset, offset + size);\n      } else {\n        result[attributeName] = value;\n      }\n    } else {\n      result[attributeName] = this.getBuffer();\n    }\n    if (this.doublePrecision) {\n      if (this.value instanceof Float64Array) {\n        result[`${attributeName}64Low`] = result[attributeName];\n      } else {\n        // Disable fp64 low part\n        result[`${attributeName}64Low`] = new Float32Array(this.size);\n      }\n    }\n    return result;\n  }\n  _getBufferLayout(attributeName = this.id, options = null) {\n    const accessor = this.getAccessor();\n    const attributes = [];\n    const result = {\n      name: this.id,\n      byteStride: getStride(accessor),\n      attributes\n    };\n    if (this.doublePrecision) {\n      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(accessor, options || {});\n      attributes.push(getBufferAttributeLayout(attributeName, {\n        ...accessor,\n        ...doubleShaderAttributeDefs.high\n      }, this.device.type), getBufferAttributeLayout(`${attributeName}64Low`, {\n        ...accessor,\n        ...doubleShaderAttributeDefs.low\n      }, this.device.type));\n    } else if (options) {\n      const shaderAttributeDef = resolveShaderAttribute(accessor, options);\n      attributes.push(getBufferAttributeLayout(attributeName, {\n        ...accessor,\n        ...shaderAttributeDef\n      }, this.device.type));\n    } else {\n      attributes.push(getBufferAttributeLayout(attributeName, accessor, this.device.type));\n    }\n    return result;\n  }\n  setAccessor(accessor) {\n    this.state.bufferAccessor = accessor;\n  }\n  getAccessor() {\n    return this.state.bufferAccessor;\n  }\n  // Returns [min: Array(size), max: Array(size)]\n  /* eslint-disable max-depth */\n  getBounds() {\n    if (this.state.bounds) {\n      return this.state.bounds;\n    }\n    let result = null;\n    if (this.state.constant && this.value) {\n      const min = Array.from(this.value);\n      result = [min, min];\n    } else {\n      const {\n        value,\n        numInstances,\n        size\n      } = this;\n      const len = numInstances * size;\n      if (value && len && value.length >= len) {\n        const min = new Array(size).fill(Infinity);\n        const max = new Array(size).fill(-Infinity);\n        for (let i = 0; i < len;) {\n          for (let j = 0; j < size; j++) {\n            const v = value[i++];\n            if (v < min[j]) min[j] = v;\n            if (v > max[j]) max[j] = v;\n          }\n        }\n        result = [min, max];\n      }\n    }\n    this.state.bounds = result;\n    return result;\n  }\n  // returns true if success\n  // eslint-disable-next-line max-statements\n  setData(data) {\n    const {\n      state\n    } = this;\n    let opts;\n    if (ArrayBuffer.isView(data)) {\n      opts = {\n        value: data\n      };\n    } else if (data instanceof Buffer) {\n      opts = {\n        buffer: data\n      };\n    } else {\n      opts = data;\n    }\n    const accessor = {\n      ...this.settings,\n      ...opts\n    };\n    if (ArrayBuffer.isView(opts.value)) {\n      if (!opts.type) {\n        // Deduce data type\n        const is64Bit = this.doublePrecision && opts.value instanceof Float64Array;\n        if (is64Bit) {\n          accessor.type = 'float32';\n        } else {\n          const type = dataTypeFromTypedArray(opts.value);\n          accessor.type = accessor.normalized ? type.replace('int', 'norm') : type;\n        }\n      }\n      accessor.bytesPerElement = opts.value.BYTES_PER_ELEMENT;\n      accessor.stride = getStride(accessor);\n    }\n    state.bounds = null; // clear cached bounds\n    if (opts.constant) {\n      // set constant\n      let value = opts.value;\n      value = this._normalizeValue(value, [], 0);\n      if (this.settings.normalized) {\n        value = this.normalizeConstant(value);\n      }\n      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);\n      if (!hasChanged) {\n        return false;\n      }\n      state.externalBuffer = null;\n      state.constant = true;\n      this.value = ArrayBuffer.isView(value) ? value : new Float32Array(value);\n    } else if (opts.buffer) {\n      const buffer = opts.buffer;\n      state.externalBuffer = buffer;\n      state.constant = false;\n      this.value = opts.value || null;\n    } else if (opts.value) {\n      this._checkExternalBuffer(opts);\n      let value = opts.value;\n      state.externalBuffer = null;\n      state.constant = false;\n      this.value = value;\n      let {\n        buffer\n      } = this;\n      const stride = getStride(accessor);\n      const byteOffset = (accessor.vertexOffset || 0) * stride;\n      if (this.doublePrecision && value instanceof Float64Array) {\n        value = toDoublePrecisionArray(value, accessor);\n      }\n      if (this.settings.isIndexed) {\n        const ArrayType = this.settings.defaultType;\n        if (value.constructor !== ArrayType) {\n          // Cast the index buffer to expected type\n          value = new ArrayType(value);\n        }\n      }\n      // A small over allocation is used as safety margin\n      // Shader attributes may try to access this buffer with bigger offsets\n      const requiredBufferSize = value.byteLength + byteOffset + stride * 2;\n      if (!buffer || buffer.byteLength < requiredBufferSize) {\n        buffer = this._createBuffer(requiredBufferSize);\n      }\n      buffer.write(value, byteOffset);\n    }\n    this.setAccessor(accessor);\n    return true;\n  }\n  updateSubBuffer(opts = {}) {\n    this.state.bounds = null; // clear cached bounds\n    const value = this.value;\n    const {\n      startOffset = 0,\n      endOffset\n    } = opts;\n    this.buffer.write(this.doublePrecision && value instanceof Float64Array ? toDoublePrecisionArray(value, {\n      size: this.size,\n      startIndex: startOffset,\n      endIndex: endOffset\n    }) : value.subarray(startOffset, endOffset), startOffset * value.BYTES_PER_ELEMENT + this.byteOffset);\n  }\n  allocate(numInstances, copy = false) {\n    const {\n      state\n    } = this;\n    const oldValue = state.allocatedValue;\n    // Allocate at least one element to ensure a valid buffer\n    const value = typedArrayManager.allocate(oldValue, numInstances + 1, {\n      size: this.size,\n      type: this.settings.defaultType,\n      copy\n    });\n    this.value = value;\n    const {\n      byteOffset\n    } = this;\n    let {\n      buffer\n    } = this;\n    if (!buffer || buffer.byteLength < value.byteLength + byteOffset) {\n      buffer = this._createBuffer(value.byteLength + byteOffset);\n      if (copy && oldValue) {\n        // Upload the full existing attribute value to the GPU, so that updateBuffer\n        // can choose to only update a partial range.\n        // TODO - copy old buffer to new buffer on the GPU\n        buffer.write(oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue, byteOffset);\n      }\n    }\n    state.allocatedValue = value;\n    state.constant = false;\n    state.externalBuffer = null;\n    this.setAccessor(this.settings);\n    return true;\n  }\n  // PRIVATE HELPER METHODS\n  _checkExternalBuffer(opts) {\n    const {\n      value\n    } = opts;\n    if (!ArrayBuffer.isView(value)) {\n      throw new Error(`Attribute ${this.id} value is not TypedArray`);\n    }\n    const ArrayType = this.settings.defaultType;\n    let illegalArrayType = false;\n    if (this.doublePrecision) {\n      // not 32bit or 64bit\n      illegalArrayType = value.BYTES_PER_ELEMENT < 4;\n    }\n    if (illegalArrayType) {\n      throw new Error(`Attribute ${this.id} does not support ${value.constructor.name}`);\n    }\n    if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {\n      log.warn(`Attribute ${this.id} is normalized`)();\n    }\n  }\n  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n  normalizeConstant(value) {\n    /* eslint-disable complexity */\n    switch (this.settings.type) {\n      case 'snorm8':\n        // normalize [-128, 127] to [-1, 1]\n        return new Float32Array(value).map(x => (x + 128) / 255 * 2 - 1);\n      case 'snorm16':\n        // normalize [-32768, 32767] to [-1, 1]\n        return new Float32Array(value).map(x => (x + 32768) / 65535 * 2 - 1);\n      case 'unorm8':\n        // normalize [0, 255] to [0, 1]\n        return new Float32Array(value).map(x => x / 255);\n      case 'unorm16':\n        // normalize [0, 65535] to [0, 1]\n        return new Float32Array(value).map(x => x / 65535);\n      default:\n        // No normalization for gl.FLOAT and gl.HALF_FLOAT\n        return value;\n    }\n  }\n  /* check user supplied values and apply fallback */\n  _normalizeValue(value, out, start) {\n    const {\n      defaultValue,\n      size\n    } = this.settings;\n    if (Number.isFinite(value)) {\n      out[start] = value;\n      return out;\n    }\n    if (!value) {\n      let i = size;\n      while (--i >= 0) {\n        out[start + i] = defaultValue[i];\n      }\n      return out;\n    }\n    // Important - switch cases are 5x more performant than a for loop!\n    /* eslint-disable no-fallthrough, default-case */\n    switch (size) {\n      case 4:\n        out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];\n      case 3:\n        out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];\n      case 2:\n        out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];\n      case 1:\n        out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];\n        break;\n      default:\n        // In the rare case where the attribute size > 4, do it the slow way\n        // This is used for e.g. transform matrices\n        let i = size;\n        while (--i >= 0) {\n          out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];\n        }\n    }\n    return out;\n  }\n  _areValuesEqual(value1, value2) {\n    if (!value1 || !value2) {\n      return false;\n    }\n    const {\n      size\n    } = this;\n    for (let i = 0; i < size; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _createBuffer(byteLength) {\n    if (this._buffer) {\n      this._buffer.destroy();\n    }\n    const {\n      isIndexed,\n      type\n    } = this.settings;\n    this._buffer = this.device.createBuffer({\n      ...this._buffer?.props,\n      id: this.id,\n      // TODO(ibgreen) - WebGPU requires COPY_DST and COPY_SRC to allow write / read\n      usage: (isIndexed ? Buffer.INDEX : Buffer.VERTEX) | Buffer.COPY_DST,\n      indexType: isIndexed ? type : undefined,\n      byteLength\n    });\n    return this._buffer;\n  }\n}","map":{"version":3,"names":["Buffer","typedArrayFromDataType","getBufferAttributeLayout","getStride","dataTypeFromTypedArray","typedArrayManager","toDoublePrecisionArray","log","resolveShaderAttribute","baseAccessor","shaderAttributeOptions","offset","removed","stride","vertexOffset","undefined","elementOffset","bytesPerElement","resolveDoublePrecisionShaderAttributes","resolvedOptions","high","low","size","DataColumn","constructor","device","opts","state","_buffer","id","logicalType","type","doublePrecision","defaultValue","Number","isFinite","Array","fill","bufferType","isIndexed","defaultType","fp64","Float32Array","value","settings","normalized","includes","BYTES_PER_ELEMENT","externalBuffer","bufferAccessor","allocatedValue","numInstances","bounds","constant","isConstant","buffer","byteOffset","accessor","getAccessor","n","delete","release","getBuffer","getValue","attributeName","options","result","shaderAttributeDef","subarray","Float64Array","_getBufferLayout","attributes","name","byteStride","doubleShaderAttributeDefs","push","setAccessor","getBounds","min","from","len","length","Infinity","max","i","j","v","setData","data","ArrayBuffer","isView","is64Bit","replace","_normalizeValue","normalizeConstant","hasChanged","_areValuesEqual","_checkExternalBuffer","ArrayType","requiredBufferSize","byteLength","_createBuffer","write","updateSubBuffer","startOffset","endOffset","startIndex","endIndex","allocate","copy","oldValue","Error","illegalArrayType","warn","map","x","out","start","value1","value2","destroy","createBuffer","props","usage","INDEX","VERTEX","COPY_DST","indexType"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\lib\\attribute\\data-column.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable complexity */\nimport type {Device} from '@luma.gl/core';\nimport {Buffer, BufferLayout, BufferAttributeLayout, VertexType} from '@luma.gl/core';\n\nimport {\n  typedArrayFromDataType,\n  getBufferAttributeLayout,\n  getStride,\n  dataTypeFromTypedArray\n} from './gl-utils';\nimport typedArrayManager from '../../utils/typed-array-manager';\nimport {toDoublePrecisionArray} from '../../utils/math-utils';\nimport log from '../../utils/log';\n\nimport type {TypedArray, NumericArray, TypedArrayConstructor} from '../../types/types';\n\nexport type DataType = Exclude<VertexType, 'float16'>;\nexport type LogicalDataType = DataType | 'float64';\n\nexport type BufferAccessor = {\n  /** Vertex data type. */\n  type?: DataType;\n  /** The number of elements per vertex attribute. */\n  size?: number;\n  /** Offset of the first vertex attribute into the buffer, in bytes. */\n  offset?: number;\n  /** The offset between the beginning of consecutive vertex attributes, in bytes. */\n  stride?: number;\n};\n\nexport type ShaderAttributeOptions = Partial<BufferAccessor> & {\n  offset: number;\n  stride: number;\n  vertexOffset?: number;\n  elementOffset?: number;\n};\n\nfunction resolveShaderAttribute(\n  baseAccessor: DataColumnSettings<any>,\n  shaderAttributeOptions: Partial<ShaderAttributeOptions>\n): ShaderAttributeOptions {\n  if (shaderAttributeOptions.offset) {\n    log.removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();\n  }\n\n  // All shader attributes share the parent's stride\n  const stride = getStride(baseAccessor);\n  // `vertexOffset` is used to access the neighboring vertex's value\n  // e.g. `nextPositions` in polygon\n  const vertexOffset =\n    shaderAttributeOptions.vertexOffset !== undefined\n      ? shaderAttributeOptions.vertexOffset\n      : baseAccessor.vertexOffset || 0;\n  // `elementOffset` is defined when shader attribute's size is smaller than the parent's\n  // e.g. `translations` in transform matrix\n  const elementOffset = shaderAttributeOptions.elementOffset || 0;\n  const offset =\n    // offsets defined by the attribute\n    vertexOffset * stride +\n    elementOffset * baseAccessor.bytesPerElement +\n    // offsets defined by external buffers if any\n    (baseAccessor.offset || 0);\n\n  return {\n    ...shaderAttributeOptions,\n    offset,\n    stride\n  };\n}\n\nfunction resolveDoublePrecisionShaderAttributes(\n  baseAccessor: DataColumnSettings<any>,\n  shaderAttributeOptions: Partial<ShaderAttributeOptions>\n): {\n  high: ShaderAttributeOptions;\n  low: ShaderAttributeOptions;\n} {\n  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);\n\n  return {\n    high: resolvedOptions,\n    low: {\n      ...resolvedOptions,\n      offset: resolvedOptions.offset + baseAccessor.size * 4\n    }\n  };\n}\n\nexport type DataColumnOptions<Options> = Options &\n  Omit<BufferAccessor, 'type'> & {\n    id?: string;\n    vertexOffset?: number;\n    fp64?: boolean;\n    /** Vertex data type.\n     * @default 'float32'\n     */\n    type?: LogicalDataType;\n    /** Internal API, use `type` instead */\n    logicalType?: LogicalDataType;\n    isIndexed?: boolean;\n    defaultValue?: number | number[];\n  };\n\nexport type DataColumnSettings<Options> = DataColumnOptions<Options> & {\n  type: DataType;\n  size: number;\n  logicalType?: LogicalDataType;\n  normalized: boolean;\n  bytesPerElement: number;\n  defaultValue: number[];\n  defaultType: TypedArrayConstructor;\n};\n\ntype DataColumnInternalState<Options, State> = State & {\n  externalBuffer: Buffer | null;\n  bufferAccessor: DataColumnSettings<Options>;\n  allocatedValue: TypedArray | null;\n  numInstances: number;\n  bounds: [number[], number[]] | null;\n  constant: boolean;\n};\n\nexport default class DataColumn<Options, State> {\n  device: Device;\n  id: string;\n  size: number;\n  settings: DataColumnSettings<Options>;\n  value: NumericArray | null;\n  doublePrecision: boolean;\n\n  protected _buffer: Buffer | null = null;\n  protected state: DataColumnInternalState<Options, State>;\n\n  /* eslint-disable max-statements */\n  constructor(device: Device, opts: DataColumnOptions<Options>, state: State) {\n    this.device = device;\n    this.id = opts.id || '';\n    this.size = opts.size || 1;\n\n    const logicalType = opts.logicalType || opts.type;\n    const doublePrecision = logicalType === 'float64';\n\n    let {defaultValue} = opts;\n    defaultValue = Number.isFinite(defaultValue)\n      ? [defaultValue]\n      : defaultValue || new Array(this.size).fill(0);\n\n    let bufferType: DataType;\n    if (doublePrecision) {\n      bufferType = 'float32';\n    } else if (!logicalType && opts.isIndexed) {\n      bufferType = 'uint32';\n    } else {\n      bufferType = logicalType || 'float32';\n    }\n\n    // This is the attribute type defined by the layer\n    // If an external buffer is provided, this.type may be overwritten\n    // But we always want to use defaultType for allocation\n    let defaultType = typedArrayFromDataType(logicalType || bufferType);\n    this.doublePrecision = doublePrecision;\n\n    // `fp64: false` tells a double-precision attribute to allocate Float32Arrays\n    // by default when using auto-packing. This is more efficient in use cases where\n    // high precision is unnecessary, but the `64Low` attribute is still required\n    // by the shader.\n    if (doublePrecision && opts.fp64 === false) {\n      defaultType = Float32Array;\n    }\n\n    this.value = null;\n    this.settings = {\n      ...opts,\n      defaultType,\n      defaultValue: defaultValue as number[],\n      logicalType,\n      type: bufferType,\n      normalized: bufferType.includes('norm'),\n      size: this.size,\n      bytesPerElement: defaultType.BYTES_PER_ELEMENT\n    };\n    this.state = {\n      ...state,\n      externalBuffer: null,\n      bufferAccessor: this.settings,\n      allocatedValue: null,\n      numInstances: 0,\n      bounds: null,\n      constant: false\n    };\n  }\n  /* eslint-enable max-statements */\n\n  get isConstant(): boolean {\n    return this.state.constant;\n  }\n\n  get buffer(): Buffer {\n    return this._buffer!;\n  }\n\n  get byteOffset(): number {\n    const accessor = this.getAccessor();\n    if (accessor.vertexOffset) {\n      return accessor.vertexOffset * getStride(accessor);\n    }\n    return 0;\n  }\n\n  get numInstances(): number {\n    return this.state.numInstances;\n  }\n\n  set numInstances(n: number) {\n    this.state.numInstances = n;\n  }\n\n  delete(): void {\n    if (this._buffer) {\n      this._buffer.delete();\n      this._buffer = null;\n    }\n    typedArrayManager.release(this.state.allocatedValue);\n  }\n\n  getBuffer(): Buffer | null {\n    if (this.state.constant) {\n      return null;\n    }\n    return this.state.externalBuffer || this._buffer;\n  }\n\n  getValue(\n    attributeName: string = this.id,\n    options: Partial<ShaderAttributeOptions> | null = null\n  ): Record<string, Buffer | TypedArray | null> {\n    const result: Record<string, Buffer | TypedArray | null> = {};\n    if (this.state.constant) {\n      const value = this.value as TypedArray;\n      if (options) {\n        const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);\n        const offset = shaderAttributeDef.offset / value.BYTES_PER_ELEMENT;\n        const size = shaderAttributeDef.size || this.size;\n        result[attributeName] = value.subarray(offset, offset + size);\n      } else {\n        result[attributeName] = value;\n      }\n    } else {\n      result[attributeName] = this.getBuffer();\n    }\n    if (this.doublePrecision) {\n      if (this.value instanceof Float64Array) {\n        result[`${attributeName}64Low`] = result[attributeName];\n      } else {\n        // Disable fp64 low part\n        result[`${attributeName}64Low`] = new Float32Array(this.size);\n      }\n    }\n    return result;\n  }\n\n  protected _getBufferLayout(\n    attributeName: string = this.id,\n    options: Partial<ShaderAttributeOptions> | null = null\n  ): BufferLayout {\n    const accessor = this.getAccessor();\n    const attributes: BufferAttributeLayout[] = [];\n    const result: BufferLayout = {\n      name: this.id,\n      byteStride: getStride(accessor),\n      attributes\n    };\n\n    if (this.doublePrecision) {\n      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(\n        accessor,\n        options || {}\n      );\n      attributes.push(\n        getBufferAttributeLayout(\n          attributeName,\n          {...accessor, ...doubleShaderAttributeDefs.high},\n          this.device.type\n        ),\n        getBufferAttributeLayout(\n          `${attributeName}64Low`,\n          {\n            ...accessor,\n            ...doubleShaderAttributeDefs.low\n          },\n          this.device.type\n        )\n      );\n    } else if (options) {\n      const shaderAttributeDef = resolveShaderAttribute(accessor, options);\n      attributes.push(\n        getBufferAttributeLayout(\n          attributeName,\n          {...accessor, ...shaderAttributeDef},\n          this.device.type\n        )\n      );\n    } else {\n      attributes.push(getBufferAttributeLayout(attributeName, accessor, this.device.type));\n    }\n    return result;\n  }\n\n  setAccessor(accessor: DataColumnSettings<Options>) {\n    this.state.bufferAccessor = accessor;\n  }\n\n  getAccessor(): DataColumnSettings<Options> {\n    return this.state.bufferAccessor;\n  }\n\n  // Returns [min: Array(size), max: Array(size)]\n  /* eslint-disable max-depth */\n  getBounds(): [number[], number[]] | null {\n    if (this.state.bounds) {\n      return this.state.bounds;\n    }\n    let result: [number[], number[]] | null = null;\n    if (this.state.constant && this.value) {\n      const min = Array.from(this.value);\n      result = [min, min];\n    } else {\n      const {value, numInstances, size} = this;\n      const len = numInstances * size;\n      if (value && len && value.length >= len) {\n        const min = new Array(size).fill(Infinity);\n        const max = new Array(size).fill(-Infinity);\n        for (let i = 0; i < len; ) {\n          for (let j = 0; j < size; j++) {\n            const v = value[i++];\n            if (v < min[j]) min[j] = v;\n            if (v > max[j]) max[j] = v;\n          }\n        }\n        result = [min, max];\n      }\n    }\n    this.state.bounds = result;\n    return result;\n  }\n\n  // returns true if success\n  // eslint-disable-next-line max-statements\n  setData(\n    data:\n      | TypedArray\n      | Buffer\n      | ({\n          constant?: boolean;\n          value?: NumericArray;\n          buffer?: Buffer;\n          /** Set to `true` if supplying float values to a unorm attribute */\n          normalized?: boolean;\n        } & Partial<BufferAccessor>)\n  ): boolean {\n    const {state} = this;\n\n    let opts: {\n      constant?: boolean;\n      value?: NumericArray;\n      buffer?: Buffer;\n    } & Partial<BufferAccessor>;\n    if (ArrayBuffer.isView(data)) {\n      opts = {value: data};\n    } else if (data instanceof Buffer) {\n      opts = {buffer: data};\n    } else {\n      opts = data;\n    }\n\n    const accessor: DataColumnSettings<Options> = {...this.settings, ...opts};\n\n    if (ArrayBuffer.isView(opts.value)) {\n      if (!opts.type) {\n        // Deduce data type\n        const is64Bit = this.doublePrecision && opts.value instanceof Float64Array;\n        if (is64Bit) {\n          accessor.type = 'float32';\n        } else {\n          const type = dataTypeFromTypedArray(opts.value);\n          accessor.type = accessor.normalized ? (type.replace('int', 'norm') as DataType) : type;\n        }\n      }\n      accessor.bytesPerElement = opts.value.BYTES_PER_ELEMENT;\n      accessor.stride = getStride(accessor);\n    }\n\n    state.bounds = null; // clear cached bounds\n\n    if (opts.constant) {\n      // set constant\n      let value = opts.value;\n      value = this._normalizeValue(value, [], 0);\n      if (this.settings.normalized) {\n        value = this.normalizeConstant(value);\n      }\n      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);\n\n      if (!hasChanged) {\n        return false;\n      }\n      state.externalBuffer = null;\n      state.constant = true;\n      this.value = ArrayBuffer.isView(value) ? value : new Float32Array(value);\n    } else if (opts.buffer) {\n      const buffer = opts.buffer;\n      state.externalBuffer = buffer;\n      state.constant = false;\n      this.value = opts.value || null;\n    } else if (opts.value) {\n      this._checkExternalBuffer(opts);\n\n      let value = opts.value as TypedArray;\n      state.externalBuffer = null;\n      state.constant = false;\n      this.value = value;\n\n      let {buffer} = this;\n      const stride = getStride(accessor);\n      const byteOffset = (accessor.vertexOffset || 0) * stride;\n\n      if (this.doublePrecision && value instanceof Float64Array) {\n        value = toDoublePrecisionArray(value, accessor);\n      }\n      if (this.settings.isIndexed) {\n        const ArrayType = this.settings.defaultType;\n        if (value.constructor !== ArrayType) {\n          // Cast the index buffer to expected type\n          value = new ArrayType(value);\n        }\n      }\n\n      // A small over allocation is used as safety margin\n      // Shader attributes may try to access this buffer with bigger offsets\n      const requiredBufferSize = value.byteLength + byteOffset + stride * 2;\n      if (!buffer || buffer.byteLength < requiredBufferSize) {\n        buffer = this._createBuffer(requiredBufferSize);\n      }\n\n      buffer.write(value, byteOffset);\n    }\n\n    this.setAccessor(accessor);\n\n    return true;\n  }\n\n  updateSubBuffer(\n    opts: {\n      startOffset?: number;\n      endOffset?: number;\n    } = {}\n  ): void {\n    this.state.bounds = null; // clear cached bounds\n\n    const value = this.value as TypedArray;\n    const {startOffset = 0, endOffset} = opts;\n    this.buffer.write(\n      this.doublePrecision && value instanceof Float64Array\n        ? toDoublePrecisionArray(value, {\n            size: this.size,\n            startIndex: startOffset,\n            endIndex: endOffset\n          })\n        : value.subarray(startOffset, endOffset),\n      startOffset * value.BYTES_PER_ELEMENT + this.byteOffset\n    );\n  }\n\n  allocate(numInstances: number, copy: boolean = false): boolean {\n    const {state} = this;\n    const oldValue = state.allocatedValue;\n\n    // Allocate at least one element to ensure a valid buffer\n    const value = typedArrayManager.allocate(oldValue, numInstances + 1, {\n      size: this.size,\n      type: this.settings.defaultType,\n      copy\n    });\n\n    this.value = value;\n\n    const {byteOffset} = this;\n    let {buffer} = this;\n\n    if (!buffer || buffer.byteLength < value.byteLength + byteOffset) {\n      buffer = this._createBuffer(value.byteLength + byteOffset);\n      if (copy && oldValue) {\n        // Upload the full existing attribute value to the GPU, so that updateBuffer\n        // can choose to only update a partial range.\n        // TODO - copy old buffer to new buffer on the GPU\n        buffer.write(\n          oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,\n          byteOffset\n        );\n      }\n    }\n\n    state.allocatedValue = value;\n    state.constant = false;\n    state.externalBuffer = null;\n    this.setAccessor(this.settings);\n    return true;\n  }\n\n  // PRIVATE HELPER METHODS\n  protected _checkExternalBuffer(opts: {value?: NumericArray; normalized?: boolean}): void {\n    const {value} = opts;\n    if (!ArrayBuffer.isView(value)) {\n      throw new Error(`Attribute ${this.id} value is not TypedArray`);\n    }\n    const ArrayType = this.settings.defaultType;\n\n    let illegalArrayType = false;\n    if (this.doublePrecision) {\n      // not 32bit or 64bit\n      illegalArrayType = value.BYTES_PER_ELEMENT < 4;\n    }\n    if (illegalArrayType) {\n      throw new Error(`Attribute ${this.id} does not support ${value.constructor.name}`);\n    }\n    if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {\n      log.warn(`Attribute ${this.id} is normalized`)();\n    }\n  }\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n  normalizeConstant(value: NumericArray): NumericArray {\n    /* eslint-disable complexity */\n    switch (this.settings.type) {\n      case 'snorm8':\n        // normalize [-128, 127] to [-1, 1]\n        return new Float32Array(value).map(x => ((x + 128) / 255) * 2 - 1);\n\n      case 'snorm16':\n        // normalize [-32768, 32767] to [-1, 1]\n        return new Float32Array(value).map(x => ((x + 32768) / 65535) * 2 - 1);\n\n      case 'unorm8':\n        // normalize [0, 255] to [0, 1]\n        return new Float32Array(value).map(x => x / 255);\n\n      case 'unorm16':\n        // normalize [0, 65535] to [0, 1]\n        return new Float32Array(value).map(x => x / 65535);\n\n      default:\n        // No normalization for gl.FLOAT and gl.HALF_FLOAT\n        return value;\n    }\n  }\n\n  /* check user supplied values and apply fallback */\n  protected _normalizeValue(value: any, out: NumericArray, start: number): NumericArray {\n    const {defaultValue, size} = this.settings;\n\n    if (Number.isFinite(value)) {\n      out[start] = value;\n      return out;\n    }\n    if (!value) {\n      let i = size;\n      while (--i >= 0) {\n        out[start + i] = defaultValue[i];\n      }\n      return out;\n    }\n\n    // Important - switch cases are 5x more performant than a for loop!\n    /* eslint-disable no-fallthrough, default-case */\n    switch (size) {\n      case 4:\n        out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];\n      case 3:\n        out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];\n      case 2:\n        out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];\n      case 1:\n        out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];\n        break;\n\n      default:\n        // In the rare case where the attribute size > 4, do it the slow way\n        // This is used for e.g. transform matrices\n        let i = size;\n        while (--i >= 0) {\n          out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];\n        }\n    }\n\n    return out;\n  }\n\n  protected _areValuesEqual(value1: any, value2: any): boolean {\n    if (!value1 || !value2) {\n      return false;\n    }\n    const {size} = this;\n    for (let i = 0; i < size; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  protected _createBuffer(byteLength: number): Buffer {\n    if (this._buffer) {\n      this._buffer.destroy();\n    }\n\n    const {isIndexed, type} = this.settings;\n    this._buffer = this.device.createBuffer({\n      ...this._buffer?.props,\n      id: this.id,\n      // TODO(ibgreen) - WebGPU requires COPY_DST and COPY_SRC to allow write / read\n      usage: (isIndexed ? Buffer.INDEX : Buffer.VERTEX) | Buffer.COPY_DST,\n      indexType: isIndexed ? (type as 'uint16' | 'uint32') : undefined,\n      byteLength\n    });\n\n    return this._buffer;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}