{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { GeoJsonLayer } from '@deck.gl/layers';\nimport { ClipExtension } from '@deck.gl/extensions';\nimport { Matrix4 } from '@math.gl/core';\nimport { MVTWorkerLoader } from '@loaders.gl/mvt';\nimport { binaryToGeojson } from '@loaders.gl/gis';\nimport { transform } from \"./coordinate-transform.js\";\nimport findIndexBinary from \"./find-index-binary.js\";\nimport TileLayer from \"../tile-layer/tile-layer.js\";\nimport { urlType, getURLFromTemplate, isGeoBoundingBox, isURLTemplate } from \"../tileset-2d/index.js\";\nconst WORLD_SIZE = 512;\nconst defaultProps = {\n  ...GeoJsonLayer.defaultProps,\n  data: urlType,\n  onDataLoad: {\n    type: 'function',\n    value: null,\n    optional: true,\n    compare: false\n  },\n  uniqueIdProperty: '',\n  highlightedFeatureId: null,\n  loaders: [MVTWorkerLoader],\n  binary: true\n};\n/** Render data formatted as [Mapbox Vector Tiles](https://docs.mapbox.com/vector-tiles/specification/). */\nclass MVTLayer extends TileLayer {\n  initializeState() {\n    super.initializeState();\n    // GlobeView doesn't work well with binary data\n    const binary = this.context.viewport.resolution !== undefined ? false : this.props.binary;\n    this.setState({\n      binary,\n      data: null,\n      tileJSON: null,\n      hoveredFeatureId: null,\n      hoveredFeatureLayerName: null\n    });\n  }\n  get isLoaded() {\n    return Boolean(this.state?.data && super.isLoaded);\n  }\n  updateState(_ref) {\n    let {\n      props,\n      oldProps,\n      context,\n      changeFlags\n    } = _ref;\n    if (changeFlags.dataChanged) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._updateTileData();\n    }\n    if (this.state?.data) {\n      super.updateState({\n        props,\n        oldProps,\n        context,\n        changeFlags\n      });\n      this._setWGS84PropertyForTiles();\n    }\n    const {\n      highlightColor\n    } = props;\n    if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {\n      this.setState({\n        highlightColor\n      });\n    }\n  }\n  /* eslint-disable complexity */\n  async _updateTileData() {\n    let data = this.props.data;\n    let tileJSON = null;\n    if (typeof data === 'string' && !isURLTemplate(data)) {\n      const {\n        onDataLoad,\n        fetch\n      } = this.props;\n      this.setState({\n        data: null,\n        tileJSON: null\n      });\n      try {\n        tileJSON = await fetch(data, {\n          propName: 'data',\n          layer: this,\n          loaders: []\n        });\n      } catch (error) {\n        this.raiseError(error, 'loading TileJSON');\n        data = null;\n      }\n      if (onDataLoad) {\n        onDataLoad(tileJSON, {\n          propName: 'data',\n          layer: this\n        });\n      }\n    } else if (data && typeof data === 'object' && 'tilejson' in data) {\n      tileJSON = data;\n    }\n    if (tileJSON) {\n      data = tileJSON.tiles;\n    }\n    this.setState({\n      data,\n      tileJSON\n    });\n  }\n  _getTilesetOptions() {\n    const opts = super._getTilesetOptions();\n    const tileJSON = this.state.tileJSON;\n    const {\n      minZoom,\n      maxZoom\n    } = this.props;\n    if (tileJSON) {\n      if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > minZoom) {\n        opts.minZoom = tileJSON.minzoom;\n      }\n      if (Number.isFinite(tileJSON.maxzoom) && (!Number.isFinite(maxZoom) || tileJSON.maxzoom < maxZoom)) {\n        opts.maxZoom = tileJSON.maxzoom;\n      }\n    }\n    return opts;\n  }\n  /* eslint-disable complexity */\n  renderLayers() {\n    if (!this.state?.data) return null;\n    return super.renderLayers();\n  }\n  getTileData(loadProps) {\n    const {\n      data,\n      binary\n    } = this.state;\n    const {\n      index,\n      signal\n    } = loadProps;\n    const url = getURLFromTemplate(data, loadProps);\n    if (!url) {\n      return Promise.reject('Invalid URL');\n    }\n    let loadOptions = this.getLoadOptions();\n    const {\n      fetch\n    } = this.props;\n    loadOptions = {\n      ...loadOptions,\n      mimeType: 'application/x-protobuf',\n      mvt: {\n        ...loadOptions?.mvt,\n        coordinates: this.context.viewport.resolution ? 'wgs84' : 'local',\n        tileIndex: index\n        // Local worker debug\n        // workerUrl: `modules/mvt/dist/mvt-loader.worker.js`\n        // Set worker to null to skip web workers\n        // workerUrl: null\n      },\n      gis: binary ? {\n        format: 'binary'\n      } : {}\n    };\n    return fetch(url, {\n      propName: 'data',\n      layer: this,\n      loadOptions,\n      signal\n    });\n  }\n  renderSubLayers(props) {\n    const {\n      x,\n      y,\n      z\n    } = props.tile.index;\n    const worldScale = Math.pow(2, z);\n    const xScale = WORLD_SIZE / worldScale;\n    const yScale = -xScale;\n    const xOffset = WORLD_SIZE * x / worldScale;\n    const yOffset = WORLD_SIZE * (1 - y / worldScale);\n    const modelMatrix = new Matrix4().scale([xScale, yScale, 1]);\n    props.autoHighlight = false;\n    if (!this.context.viewport.resolution) {\n      props.modelMatrix = modelMatrix;\n      props.coordinateOrigin = [xOffset, yOffset, 0];\n      props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;\n      props.extensions = [...(props.extensions || []), new ClipExtension()];\n    }\n    const subLayers = super.renderSubLayers(props);\n    if (this.state.binary && !(subLayers instanceof GeoJsonLayer)) {\n      log.warn('renderSubLayers() must return GeoJsonLayer when using binary:true')();\n    }\n    return subLayers;\n  }\n  _updateAutoHighlight(info) {\n    const {\n      uniqueIdProperty\n    } = this.props;\n    const {\n      hoveredFeatureId,\n      hoveredFeatureLayerName\n    } = this.state;\n    const hoveredFeature = info.object;\n    let newHoveredFeatureId = null;\n    let newHoveredFeatureLayerName = null;\n    if (hoveredFeature) {\n      newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);\n      newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);\n    }\n    let {\n      highlightColor\n    } = this.props;\n    if (typeof highlightColor === 'function') {\n      highlightColor = highlightColor(info);\n    }\n    if (hoveredFeatureId !== newHoveredFeatureId || hoveredFeatureLayerName !== newHoveredFeatureLayerName) {\n      this.setState({\n        highlightColor,\n        hoveredFeatureId: newHoveredFeatureId,\n        hoveredFeatureLayerName: newHoveredFeatureLayerName\n      });\n    }\n  }\n  _isWGS84() {\n    return Boolean(this.context.viewport.resolution);\n  }\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    if (this.state.binary && info.index !== -1) {\n      const {\n        data\n      } = params.sourceLayer.props;\n      info.object = binaryToGeojson(data, {\n        globalFeatureId: info.index\n      });\n    }\n    if (info.object && !this._isWGS84()) {\n      info.object = transformTileCoordsToWGS84(info.object, info.tile.bbox,\n      // eslint-disable-line\n      this.context.viewport);\n    }\n    return info;\n  }\n  getSubLayerPropsByTile(tile) {\n    return {\n      highlightedObjectIndex: this.getHighlightedObjectIndex(tile),\n      highlightColor: this.state.highlightColor\n    };\n  }\n  getHighlightedObjectIndex(tile) {\n    const {\n      hoveredFeatureId,\n      hoveredFeatureLayerName,\n      binary\n    } = this.state;\n    const {\n      uniqueIdProperty,\n      highlightedFeatureId\n    } = this.props;\n    const data = tile.content;\n    const isHighlighted = isFeatureIdDefined(highlightedFeatureId);\n    const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;\n    if (!isFeatureIdPresent) {\n      return -1;\n    }\n    const featureIdToHighlight = isHighlighted ? highlightedFeatureId : hoveredFeatureId;\n    // Iterable data\n    if (Array.isArray(data)) {\n      return data.findIndex(feature => {\n        const isMatchingId = getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;\n        const isMatchingLayer = isHighlighted || getFeatureLayerName(feature) === hoveredFeatureLayerName;\n        return isMatchingId && isMatchingLayer;\n      });\n      // Non-iterable data\n    } else if (data && binary) {\n      // Get the feature index of the selected item to highlight\n      return findIndexBinary(data, uniqueIdProperty, featureIdToHighlight, isHighlighted ? '' : hoveredFeatureLayerName);\n    }\n    return -1;\n  }\n  _pickObjects(maxObjects) {\n    const {\n      deck,\n      viewport\n    } = this.context;\n    const width = viewport.width;\n    const height = viewport.height;\n    const x = viewport.x;\n    const y = viewport.y;\n    const layerIds = [this.id];\n    return deck.pickObjects({\n      x,\n      y,\n      width,\n      height,\n      layerIds,\n      maxObjects\n    });\n  }\n  /** Get the rendered features in the current viewport. */\n  getRenderedFeatures() {\n    let maxFeatures = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const features = this._pickObjects(maxFeatures);\n    const featureCache = new Set();\n    const renderedFeatures = [];\n    for (const f of features) {\n      const featureId = getFeatureUniqueId(f.object, this.props.uniqueIdProperty);\n      if (featureId === undefined) {\n        // we have no id for the feature, we just add to the list\n        renderedFeatures.push(f.object);\n      } else if (!featureCache.has(featureId)) {\n        // Add removing duplicates\n        featureCache.add(featureId);\n        renderedFeatures.push(f.object);\n      }\n    }\n    return renderedFeatures;\n  }\n  _setWGS84PropertyForTiles() {\n    const propName = 'dataInWGS84';\n    const tileset = this.state.tileset;\n    // @ts-expect-error selectedTiles are always initialized when tile is being processed\n    tileset.selectedTiles.forEach(tile => {\n      if (!tile.hasOwnProperty(propName)) {\n        // eslint-disable-next-line accessor-pairs\n        Object.defineProperty(tile, propName, {\n          get: () => {\n            // Still loading or encountered an error\n            if (!tile.content) {\n              return null;\n            }\n            if (this.state.binary && Array.isArray(tile.content) && !tile.content.length) {\n              // TODO: @loaders.gl/mvt returns [] when no content. It should return a valid empty binary.\n              // https://github.com/visgl/loaders.gl/pull/1137\n              return [];\n            }\n            const {\n              bbox\n            } = tile;\n            if (tile._contentWGS84 === undefined && isGeoBoundingBox(bbox)) {\n              // Create a cache to transform only once\n              const content = this.state.binary ? binaryToGeojson(tile.content) : tile.content;\n              tile._contentWGS84 = content.map(feature => transformTileCoordsToWGS84(feature, bbox, this.context.viewport));\n            }\n            return tile._contentWGS84;\n          }\n        });\n      }\n    });\n  }\n}\nMVTLayer.layerName = 'MVTLayer';\nMVTLayer.defaultProps = defaultProps;\nexport default MVTLayer;\nfunction getFeatureUniqueId(feature, uniqueIdProperty) {\n  if (feature.properties && uniqueIdProperty) {\n    return feature.properties[uniqueIdProperty];\n  }\n  if ('id' in feature) {\n    return feature.id;\n  }\n  return undefined;\n}\nfunction getFeatureLayerName(feature) {\n  return feature.properties?.layerName || null;\n}\nfunction isFeatureIdDefined(value) {\n  return value !== undefined && value !== null && value !== '';\n}\nfunction transformTileCoordsToWGS84(object, bbox, viewport) {\n  const feature = {\n    ...object,\n    geometry: {\n      type: object.geometry.type\n    }\n  };\n  // eslint-disable-next-line accessor-pairs\n  Object.defineProperty(feature.geometry, 'coordinates', {\n    get: () => {\n      const wgs84Geom = transform(object.geometry, bbox, viewport);\n      return wgs84Geom.coordinates;\n    }\n  });\n  return feature;\n}\n//# sourceMappingURL=mvt-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}