{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isResponse } from \"../../javascript-utils/is-type.js\";\nimport { FetchError } from \"../fetch/fetch-error.js\";\nimport { getResourceContentLength, getResourceUrl, getResourceMIMEType } from \"./resource-utils.js\";\nimport { shortenUrlForDisplay } from \"./url-utils.js\";\n/**\n * Returns a Response object\n * Adds content-length header when possible\n *\n * @param resource\n */\nexport async function makeResponse(resource) {\n  if (isResponse(resource)) {\n    return resource;\n  }\n  // Add content-length header if possible\n  const headers = {};\n  const contentLength = getResourceContentLength(resource);\n  if (contentLength >= 0) {\n    headers['content-length'] = String(contentLength);\n  }\n  // `new Response(File)` does not preserve content-type and URL\n  // so we add them here\n  const url = getResourceUrl(resource);\n  const type = getResourceMIMEType(resource);\n  if (type) {\n    headers['content-type'] = type;\n  }\n  // Add a custom header with initial bytes if available\n  const initialDataUrl = await getInitialDataUrl(resource);\n  if (initialDataUrl) {\n    headers['x-first-bytes'] = initialDataUrl;\n  }\n  // TODO - is this the best way of handling strings?\n  // Maybe package as data URL instead?\n  if (typeof resource === 'string') {\n    // Convert to ArrayBuffer to avoid Response treating it as a URL\n    resource = new TextEncoder().encode(resource);\n  }\n  // Attempt to create a Response from the resource, adding headers and setting url\n  const response = new Response(resource, {\n    headers\n  });\n  // We can't control `Response.url` via constructor, use a property override to record URL.\n  Object.defineProperty(response, 'url', {\n    value: url\n  });\n  return response;\n}\n/**\n * Checks response status (async) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport async function checkResponse(response) {\n  if (!response.ok) {\n    const error = await getResponseError(response);\n    throw error;\n  }\n}\n/**\n * Checks response status (sync) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport function checkResponseSync(response) {\n  if (!response.ok) {\n    let message = `${response.status} ${response.statusText}`;\n    message = message.length > 60 ? `${message.slice(0, 60)}...` : message;\n    throw new Error(message);\n  }\n}\n// HELPERS\nasync function getResponseError(response) {\n  const shortUrl = shortenUrlForDisplay(response.url);\n  let message = `Failed to fetch resource (${response.status}) ${response.statusText}: ${shortUrl}`;\n  message = message.length > 100 ? `${message.slice(0, 100)}...` : message;\n  const info = {\n    reason: response.statusText,\n    url: response.url,\n    response\n  };\n  // See if we got an error message in the body\n  try {\n    const contentType = response.headers.get('Content-Type');\n    info.reason = !response.bodyUsed && contentType?.includes('application/json') ? await response.json() : await response.text();\n  } catch (error) {\n    // eslint forbids return in a finally statement, so we just catch here\n  }\n  return new FetchError(message, info);\n}\nasync function getInitialDataUrl(resource) {\n  const INITIAL_DATA_LENGTH = 5;\n  if (typeof resource === 'string') {\n    return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;\n  }\n  if (resource instanceof Blob) {\n    const blobSlice = resource.slice(0, 5);\n    return await new Promise(resolve => {\n      const reader = new FileReader();\n      reader.onload = event => resolve(event?.target?.result);\n      reader.readAsDataURL(blobSlice);\n    });\n  }\n  if (resource instanceof ArrayBuffer) {\n    const slice = resource.slice(0, INITIAL_DATA_LENGTH);\n    const base64 = arrayBufferToBase64(slice);\n    return `data:base64,${base64}`;\n  }\n  return null;\n}\n// https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string\nfunction arrayBufferToBase64(buffer) {\n  let binary = '';\n  const bytes = new Uint8Array(buffer);\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}