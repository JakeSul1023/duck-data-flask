{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@deck.gl/core';\nimport { Geometry } from '@luma.gl/engine';\nimport { modifyPolygonWindingDirection, WINDING } from '@math.gl/polygon';\nexport default class ColumnGeometry extends Geometry {\n  constructor(props) {\n    const {\n      indices,\n      attributes\n    } = tesselateColumn(props);\n    super({\n      ...props,\n      indices,\n      // @ts-expect-error\n      attributes\n    });\n  }\n}\n/* eslint-disable max-statements, complexity */\nfunction tesselateColumn(props) {\n  const {\n    radius,\n    height = 1,\n    nradial = 10\n  } = props;\n  let {\n    vertices\n  } = props;\n  if (vertices) {\n    log.assert(vertices.length >= nradial); // `vertices` must contain at least `diskResolution` points\n    vertices = vertices.flatMap(v => [v[0], v[1]]);\n    modifyPolygonWindingDirection(vertices, WINDING.COUNTER_CLOCKWISE);\n  }\n  const isExtruded = height > 0;\n  const vertsAroundEdge = nradial + 1; // loop\n  const numVertices = isExtruded ? vertsAroundEdge * 3 + 1 // top, side top edge, side bottom edge, one additional degenerage vertex\n  : nradial; // top\n  const stepAngle = Math.PI * 2 / nradial;\n  // Used for wireframe\n  const indices = new Uint16Array(isExtruded ? nradial * 3 * 2 : 0); // top loop, side vertical, bottom loop\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n  let i = 0;\n  // side tesselation: 0, 1, 2, 3, 4, 5, ...\n  //\n  // 0 - 2 - 4  ... top\n  // | / | / |\n  // 1 - 3 - 5  ... bottom\n  //\n  if (isExtruded) {\n    for (let j = 0; j < vertsAroundEdge; j++) {\n      const a = j * stepAngle;\n      const vertexIndex = j % nradial;\n      const sin = Math.sin(a);\n      const cos = Math.cos(a);\n      for (let k = 0; k < 2; k++) {\n        positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;\n        positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;\n        positions[i + 2] = (1 / 2 - k) * height;\n        normals[i + 0] = vertices ? vertices[vertexIndex * 2] : cos;\n        normals[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin;\n        i += 3;\n      }\n    }\n    // duplicate the last vertex to create proper degenerate triangle.\n    positions[i + 0] = positions[i - 3];\n    positions[i + 1] = positions[i - 2];\n    positions[i + 2] = positions[i - 1];\n    i += 3;\n  }\n  // The column geometry is rendered as a triangle strip, so\n  // in order to render sides and top in one go we need to use degenerate triangles.\n  // Duplicate last vertex of side trinagles and first vertex of the top cap to preserve winding order.\n  // top tesselation: 0, -1, 1, -2, 2, -3, 3, ...\n  //\n  //    0 -- 1\n  //   /      \\\n  // -1        2\n  //  |        |\n  // -2        3\n  //   \\      /\n  //   -3 -- 4\n  //\n  for (let j = isExtruded ? 0 : 1; j < vertsAroundEdge; j++) {\n    const v = Math.floor(j / 2) * Math.sign(0.5 - j % 2);\n    const a = v * stepAngle;\n    const vertexIndex = (v + nradial) % nradial;\n    const sin = Math.sin(a);\n    const cos = Math.cos(a);\n    positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;\n    positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;\n    positions[i + 2] = height / 2;\n    normals[i + 2] = 1;\n    i += 3;\n  }\n  if (isExtruded) {\n    let index = 0;\n    for (let j = 0; j < nradial; j++) {\n      // top loop\n      indices[index++] = j * 2 + 0;\n      indices[index++] = j * 2 + 2;\n      // side vertical\n      indices[index++] = j * 2 + 0;\n      indices[index++] = j * 2 + 1;\n      // bottom loop\n      indices[index++] = j * 2 + 1;\n      indices[index++] = j * 2 + 3;\n    }\n  }\n  return {\n    indices,\n    attributes: {\n      POSITION: {\n        size: 3,\n        value: positions\n      },\n      NORMAL: {\n        size: 3,\n        value: normals\n      }\n    }\n  };\n}","map":{"version":3,"names":["log","Geometry","modifyPolygonWindingDirection","WINDING","ColumnGeometry","constructor","props","indices","attributes","tesselateColumn","radius","height","nradial","vertices","assert","length","flatMap","v","COUNTER_CLOCKWISE","isExtruded","vertsAroundEdge","numVertices","stepAngle","Math","PI","Uint16Array","positions","Float32Array","normals","i","j","a","vertexIndex","sin","cos","k","floor","sign","index","POSITION","size","value","NORMAL"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\layers\\src\\column-layer\\column-geometry.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {log, BinaryAttribute} from '@deck.gl/core';\nimport {Geometry} from '@luma.gl/engine';\n\nimport {modifyPolygonWindingDirection, WINDING} from '@math.gl/polygon';\n\ntype ColumnGeometryProps = {\n  id?: string;\n  radius: number;\n  height?: number;\n  nradial?: number;\n  vertices?: number[];\n};\n\nexport default class ColumnGeometry extends Geometry {\n  constructor(props: ColumnGeometryProps) {\n    const {indices, attributes} = tesselateColumn(props);\n    super({\n      ...props,\n      indices,\n      // @ts-expect-error\n      attributes\n    });\n  }\n}\n\n/* eslint-disable max-statements, complexity */\nfunction tesselateColumn(props: ColumnGeometryProps): {\n  indices: Uint16Array;\n  attributes: Record<string, BinaryAttribute>;\n} {\n  const {radius, height = 1, nradial = 10} = props;\n  let {vertices} = props;\n\n  if (vertices) {\n    log.assert(vertices.length >= nradial); // `vertices` must contain at least `diskResolution` points\n    vertices = vertices.flatMap(v => [v[0], v[1]]);\n    modifyPolygonWindingDirection(vertices, WINDING.COUNTER_CLOCKWISE);\n  }\n\n  const isExtruded = height > 0;\n  const vertsAroundEdge = nradial + 1; // loop\n  const numVertices = isExtruded\n    ? vertsAroundEdge * 3 + 1 // top, side top edge, side bottom edge, one additional degenerage vertex\n    : nradial; // top\n\n  const stepAngle = (Math.PI * 2) / nradial;\n\n  // Used for wireframe\n  const indices = new Uint16Array(isExtruded ? nradial * 3 * 2 : 0); // top loop, side vertical, bottom loop\n\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n\n  let i = 0;\n\n  // side tesselation: 0, 1, 2, 3, 4, 5, ...\n  //\n  // 0 - 2 - 4  ... top\n  // | / | / |\n  // 1 - 3 - 5  ... bottom\n  //\n  if (isExtruded) {\n    for (let j = 0; j < vertsAroundEdge; j++) {\n      const a = j * stepAngle;\n      const vertexIndex = j % nradial;\n      const sin = Math.sin(a);\n      const cos = Math.cos(a);\n\n      for (let k = 0; k < 2; k++) {\n        positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;\n        positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;\n        positions[i + 2] = (1 / 2 - k) * height;\n\n        normals[i + 0] = vertices ? vertices[vertexIndex * 2] : cos;\n        normals[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin;\n\n        i += 3;\n      }\n    }\n\n    // duplicate the last vertex to create proper degenerate triangle.\n    positions[i + 0] = positions[i - 3];\n    positions[i + 1] = positions[i - 2];\n    positions[i + 2] = positions[i - 1];\n    i += 3;\n  }\n\n  // The column geometry is rendered as a triangle strip, so\n  // in order to render sides and top in one go we need to use degenerate triangles.\n  // Duplicate last vertex of side trinagles and first vertex of the top cap to preserve winding order.\n\n  // top tesselation: 0, -1, 1, -2, 2, -3, 3, ...\n  //\n  //    0 -- 1\n  //   /      \\\n  // -1        2\n  //  |        |\n  // -2        3\n  //   \\      /\n  //   -3 -- 4\n  //\n  for (let j = isExtruded ? 0 : 1; j < vertsAroundEdge; j++) {\n    const v = Math.floor(j / 2) * Math.sign(0.5 - (j % 2));\n    const a = v * stepAngle;\n    const vertexIndex = (v + nradial) % nradial;\n    const sin = Math.sin(a);\n    const cos = Math.cos(a);\n\n    positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;\n    positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;\n    positions[i + 2] = height / 2;\n\n    normals[i + 2] = 1;\n\n    i += 3;\n  }\n\n  if (isExtruded) {\n    let index = 0;\n    for (let j = 0; j < nradial; j++) {\n      // top loop\n      indices[index++] = j * 2 + 0;\n      indices[index++] = j * 2 + 2;\n      // side vertical\n      indices[index++] = j * 2 + 0;\n      indices[index++] = j * 2 + 1;\n      // bottom loop\n      indices[index++] = j * 2 + 1;\n      indices[index++] = j * 2 + 3;\n    }\n  }\n\n  return {\n    indices,\n    attributes: {\n      POSITION: {size: 3, value: positions},\n      NORMAL: {size: 3, value: normals}\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}