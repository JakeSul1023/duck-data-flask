{"ast":null,"code":"import { AttrRecognizer } from \"./attribute.js\";\nimport { InputDirection, InputEvent } from \"../input/input-consts.js\";\nimport { PanRecognizer } from \"./pan.js\";\nconst EVENT_NAMES = ['', 'up', 'down', 'left', 'right'];\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n */\nexport class SwipeRecognizer extends AttrRecognizer {\n  constructor(options = {}) {\n    super({\n      enable: true,\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: InputDirection.All,\n      pointers: 1,\n      ...options\n    });\n  }\n  getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  }\n  getEventNames() {\n    return EVENT_NAMES.map(suffix => this.options.event + suffix);\n  }\n  attrTest(input) {\n    const {\n      direction\n    } = this.options;\n    let velocity = 0;\n    if (direction & InputDirection.All) {\n      velocity = input.overallVelocity;\n    } else if (direction & InputDirection.Horizontal) {\n      velocity = input.overallVelocityX;\n    } else if (direction & InputDirection.Vertical) {\n      velocity = input.overallVelocityY;\n    }\n    return super.attrTest(input) && Boolean(direction & input.offsetDirection) && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && Math.abs(velocity) > this.options.velocity && Boolean(input.eventType & InputEvent.End);\n  }\n  emit(input) {\n    const direction = InputDirection[input.offsetDirection].toLowerCase();\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n    this.manager.emit(this.options.event, input);\n  }\n}","map":{"version":3,"names":["AttrRecognizer","InputDirection","InputEvent","PanRecognizer","EVENT_NAMES","SwipeRecognizer","constructor","options","enable","event","threshold","velocity","direction","All","pointers","getTouchAction","prototype","call","getEventNames","map","suffix","attrTest","input","overallVelocity","Horizontal","overallVelocityX","Vertical","overallVelocityY","Boolean","offsetDirection","distance","maxPointers","Math","abs","eventType","End","emit","toLowerCase","manager"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\mjolnir.js\\src\\hammerjs\\recognizers\\swipe.ts"],"sourcesContent":["import {AttrRecognizer} from './attribute';\nimport {InputDirection, InputEvent} from '../input/input-consts';\nimport {PanRecognizer} from './pan';\nimport type {HammerInput} from '../input/types';\n\nexport type SwipeRecognizerOptions = {\n  /** Name of the event.\n   * @default 'swipe'\n   */\n  event?: string;\n  /** Enable this event.\n   * @default true\n   */\n  enable?: boolean;\n  /** Required number of pointers.\n   * @default 1\n   */\n  pointers?: number;\n  /** Direction of the panning.\n   * @default InputDirection.All\n   */\n  direction?: InputDirection;\n  /** Minimal distance required before recognizing.\n   * @default 10\n   */\n  threshold?: number;\n  /** Minimal velocity required before recognizing, in px/ms\n   * @default 0.3\n   */\n  velocity?: number;\n};\n\nconst EVENT_NAMES = ['', 'up', 'down', 'left', 'right'] as const;\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n */\nexport class SwipeRecognizer extends AttrRecognizer<Required<SwipeRecognizerOptions>> {\n  constructor(options: SwipeRecognizerOptions = {}) {\n    super({\n      enable: true,\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: InputDirection.All,\n      pointers: 1,\n      ...options\n    });\n  }\n\n  getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  }\n\n  getEventNames(): string[] {\n    return EVENT_NAMES.map((suffix) => this.options.event + suffix);\n  }\n\n  attrTest(input: HammerInput): boolean {\n    const {direction} = this.options;\n    let velocity = 0;\n\n    if (direction & InputDirection.All) {\n      velocity = input.overallVelocity;\n    } else if (direction & InputDirection.Horizontal) {\n      velocity = input.overallVelocityX;\n    } else if (direction & InputDirection.Vertical) {\n      velocity = input.overallVelocityY;\n    }\n\n    return (\n      super.attrTest(input) &&\n      Boolean(direction & input.offsetDirection) &&\n      input.distance > this.options.threshold &&\n      input.maxPointers === this.options.pointers &&\n      Math.abs(velocity) > this.options.velocity &&\n      Boolean(input.eventType & InputEvent.End)\n    );\n  }\n\n  emit(input: HammerInput) {\n    const direction = InputDirection[input.offsetDirection].toLowerCase();\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n\n    this.manager.emit(this.options.event, input);\n  }\n}\n"],"mappings":"AAAA,SAAQA,cAAc,QAAC;AACvB,SAAQC,cAAc,EAAEC,UAAU,QAAC;AACnC,SAAQC,aAAa,QAAC;AA8BtB,MAAMC,WAAW,GAAG,CAAC,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,CAAU;AAEhE;;;;AAIA,OAAM,MAAOC,eAAgB,SAAQL,cAAgD;EACnFM,YAAYC,OAAA,GAAkC,EAAE;IAC9C,KAAK,CAAC;MACJC,MAAM,EAAE,IAAI;MACZC,KAAK,EAAE,OAAO;MACdC,SAAS,EAAE,EAAE;MACbC,QAAQ,EAAE,GAAG;MACbC,SAAS,EAAEX,cAAc,CAACY,GAAG;MAC7BC,QAAQ,EAAE,CAAC;MACX,GAAGP;KACJ,CAAC;EACJ;EAEAQ,cAAcA,CAAA;IACZ,OAAOZ,aAAa,CAACa,SAAS,CAACD,cAAc,CAACE,IAAI,CAAC,IAAI,CAAC;EAC1D;EAEAC,aAAaA,CAAA;IACX,OAAOd,WAAW,CAACe,GAAG,CAAEC,MAAM,IAAK,IAAI,CAACb,OAAO,CAACE,KAAK,GAAGW,MAAM,CAAC;EACjE;EAEAC,QAAQA,CAACC,KAAkB;IACzB,MAAM;MAACV;IAAS,CAAC,GAAG,IAAI,CAACL,OAAO;IAChC,IAAII,QAAQ,GAAG,CAAC;IAEhB,IAAIC,SAAS,GAAGX,cAAc,CAACY,GAAG,EAAE;MAClCF,QAAQ,GAAGW,KAAK,CAACC,eAAe;IAClC,CAAC,MAAM,IAAIX,SAAS,GAAGX,cAAc,CAACuB,UAAU,EAAE;MAChDb,QAAQ,GAAGW,KAAK,CAACG,gBAAgB;IACnC,CAAC,MAAM,IAAIb,SAAS,GAAGX,cAAc,CAACyB,QAAQ,EAAE;MAC9Cf,QAAQ,GAAGW,KAAK,CAACK,gBAAgB;IACnC;IAEA,OACE,KAAK,CAACN,QAAQ,CAACC,KAAK,CAAC,IACrBM,OAAO,CAAChB,SAAS,GAAGU,KAAK,CAACO,eAAe,CAAC,IAC1CP,KAAK,CAACQ,QAAQ,GAAG,IAAI,CAACvB,OAAO,CAACG,SAAS,IACvCY,KAAK,CAACS,WAAW,KAAK,IAAI,CAACxB,OAAO,CAACO,QAAQ,IAC3CkB,IAAI,CAACC,GAAG,CAACtB,QAAQ,CAAC,GAAG,IAAI,CAACJ,OAAO,CAACI,QAAQ,IAC1CiB,OAAO,CAACN,KAAK,CAACY,SAAS,GAAGhC,UAAU,CAACiC,GAAG,CAAC;EAE7C;EAEAC,IAAIA,CAACd,KAAkB;IACrB,MAAMV,SAAS,GAAGX,cAAc,CAACqB,KAAK,CAACO,eAAe,CAAC,CAACQ,WAAW,EAAE;IACrE,IAAIzB,SAAS,EAAE;MACb,IAAI,CAAC0B,OAAO,CAACF,IAAI,CAAC,IAAI,CAAC7B,OAAO,CAACE,KAAK,GAAGG,SAAS,EAAEU,KAAK,CAAC;IAC1D;IAEA,IAAI,CAACgB,OAAO,CAACF,IAAI,CAAC,IAAI,CAAC7B,OAAO,CAACE,KAAK,EAAEa,KAAK,CAAC;EAC9C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}