{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Model, Geometry } from '@luma.gl/engine';\nimport { Layer, picking } from '@deck.gl/core';\nimport { createColorRangeTexture, updateColorRangeTexture } from \"../common/utils/color-utils.js\";\nimport vs from \"./screen-grid-layer-vertex.glsl.js\";\nimport fs from \"./screen-grid-layer-fragment.glsl.js\";\nimport { screenGridUniforms } from \"./screen-grid-layer-uniforms.js\";\nclass ScreenGridCellLayer extends Layer {\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [picking, screenGridUniforms]\n    });\n  }\n  initializeState() {\n    this.getAttributeManager().addInstanced({\n      instancePositions: {\n        size: 2,\n        type: 'float32',\n        accessor: 'getBin'\n      },\n      instanceWeights: {\n        size: 1,\n        type: 'float32',\n        accessor: 'getWeight'\n      }\n    });\n    this.state.model = this._getModel();\n  }\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const model = this.state.model;\n    if (oldProps.colorRange !== props.colorRange) {\n      this.state.colorTexture?.destroy();\n      this.state.colorTexture = createColorRangeTexture(this.context.device, props.colorRange, props.colorScaleType);\n      const screenGridProps = {\n        colorRange: this.state.colorTexture\n      };\n      model.shaderInputs.setProps({\n        screenGrid: screenGridProps\n      });\n    } else if (oldProps.colorScaleType !== props.colorScaleType) {\n      updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);\n    }\n    if (oldProps.cellMarginPixels !== props.cellMarginPixels || oldProps.cellSizePixels !== props.cellSizePixels || changeFlags.viewportChanged) {\n      const {\n        width,\n        height\n      } = this.context.viewport;\n      const {\n        cellSizePixels: gridSize,\n        cellMarginPixels\n      } = this.props;\n      const cellSize = Math.max(gridSize - cellMarginPixels, 0);\n      const screenGridProps = {\n        gridSizeClipspace: [gridSize / width * 2, gridSize / height * 2],\n        cellSizeClipspace: [cellSize / width * 2, cellSize / height * 2]\n      };\n      model.shaderInputs.setProps({\n        screenGrid: screenGridProps\n      });\n    }\n  }\n  finalizeState(context) {\n    super.finalizeState(context);\n    this.state.colorTexture?.destroy();\n  }\n  draw({\n    uniforms\n  }) {\n    const colorDomain = this.props.colorDomain();\n    const model = this.state.model;\n    const screenGridProps = {\n      colorDomain\n    };\n    model.shaderInputs.setProps({\n      screenGrid: screenGridProps\n    });\n    model.draw(this.context.renderPass);\n  }\n  // Private Methods\n  _getModel() {\n    return new Model(this.context.device, {\n      ...this.getShaders(),\n      id: this.props.id,\n      bufferLayout: this.getAttributeManager().getBufferLayouts(),\n      geometry: new Geometry({\n        topology: 'triangle-strip',\n        attributes: {\n          positions: {\n            value: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),\n            size: 2\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n}\nScreenGridCellLayer.layerName = 'ScreenGridCellLayer';\nexport default ScreenGridCellLayer;","map":{"version":3,"names":["Model","Geometry","Layer","picking","createColorRangeTexture","updateColorRangeTexture","vs","fs","screenGridUniforms","ScreenGridCellLayer","getShaders","modules","initializeState","getAttributeManager","addInstanced","instancePositions","size","type","accessor","instanceWeights","state","model","_getModel","updateState","params","props","oldProps","changeFlags","colorRange","colorTexture","destroy","context","device","colorScaleType","screenGridProps","shaderInputs","setProps","screenGrid","cellMarginPixels","cellSizePixels","viewportChanged","width","height","viewport","gridSize","cellSize","Math","max","gridSizeClipspace","cellSizeClipspace","finalizeState","draw","uniforms","colorDomain","renderPass","id","bufferLayout","getBufferLayouts","geometry","topology","attributes","positions","value","Float32Array","isInstanced","layerName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\aggregation-layers\\src\\screen-grid-layer\\screen-grid-cell-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Texture} from '@luma.gl/core';\nimport {Model, Geometry} from '@luma.gl/engine';\nimport {Layer, picking, UpdateParameters, DefaultProps, Color} from '@deck.gl/core';\nimport {createColorRangeTexture, updateColorRangeTexture} from '../common/utils/color-utils';\nimport vs from './screen-grid-layer-vertex.glsl';\nimport fs from './screen-grid-layer-fragment.glsl';\nimport {ScreenGridProps, screenGridUniforms} from './screen-grid-layer-uniforms';\nimport {ShaderModule} from '@luma.gl/shadertools';\nimport type {ScaleType} from '../common/types';\n\n/** Proprties added by ScreenGridCellLayer. */\nexport type _ScreenGridCellLayerProps = {\n  cellSizePixels: number;\n  cellMarginPixels: number;\n  colorScaleType: ScaleType;\n  colorDomain: () => [number, number];\n  colorRange?: Color[];\n};\n\nexport default class ScreenGridCellLayer<ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_ScreenGridCellLayerProps>\n> {\n  static layerName = 'ScreenGridCellLayer';\n\n  state!: {\n    model?: Model;\n    colorTexture: Texture;\n  };\n\n  getShaders(): {vs: string; fs: string; modules: ShaderModule[]} {\n    return super.getShaders({vs, fs, modules: [picking, screenGridUniforms]});\n  }\n\n  initializeState() {\n    this.getAttributeManager()!.addInstanced({\n      instancePositions: {\n        size: 2,\n        type: 'float32',\n        accessor: 'getBin'\n      },\n      instanceWeights: {\n        size: 1,\n        type: 'float32',\n        accessor: 'getWeight'\n      }\n    });\n\n    this.state.model = this._getModel();\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n\n    const {props, oldProps, changeFlags} = params;\n    const model = this.state.model!;\n\n    if (oldProps.colorRange !== props.colorRange) {\n      this.state.colorTexture?.destroy();\n      this.state.colorTexture = createColorRangeTexture(\n        this.context.device,\n        props.colorRange,\n        props.colorScaleType\n      );\n      const screenGridProps: Partial<ScreenGridProps> = {colorRange: this.state.colorTexture};\n      model.shaderInputs.setProps({screenGrid: screenGridProps});\n    } else if (oldProps.colorScaleType !== props.colorScaleType) {\n      updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);\n    }\n\n    if (\n      oldProps.cellMarginPixels !== props.cellMarginPixels ||\n      oldProps.cellSizePixels !== props.cellSizePixels ||\n      changeFlags.viewportChanged\n    ) {\n      const {width, height} = this.context.viewport;\n      const {cellSizePixels: gridSize, cellMarginPixels} = this.props;\n      const cellSize = Math.max(gridSize - cellMarginPixels, 0);\n\n      const screenGridProps: Partial<ScreenGridProps> = {\n        gridSizeClipspace: [(gridSize / width) * 2, (gridSize / height) * 2],\n        cellSizeClipspace: [(cellSize / width) * 2, (cellSize / height) * 2]\n      };\n      model.shaderInputs.setProps({screenGrid: screenGridProps});\n    }\n  }\n\n  finalizeState(context) {\n    super.finalizeState(context);\n\n    this.state.colorTexture?.destroy();\n  }\n\n  draw({uniforms}) {\n    const colorDomain = this.props.colorDomain();\n    const model = this.state.model!;\n\n    const screenGridProps: Partial<ScreenGridProps> = {colorDomain};\n    model.shaderInputs.setProps({screenGrid: screenGridProps});\n    model.draw(this.context.renderPass);\n  }\n\n  // Private Methods\n\n  _getModel(): Model {\n    return new Model(this.context.device, {\n      ...this.getShaders(),\n      id: this.props.id,\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts(),\n      geometry: new Geometry({\n        topology: 'triangle-strip',\n        attributes: {\n          positions: {\n            value: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),\n            size: 2\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}