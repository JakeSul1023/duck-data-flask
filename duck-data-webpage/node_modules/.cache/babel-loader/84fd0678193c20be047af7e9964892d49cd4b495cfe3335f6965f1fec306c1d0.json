{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { initializeShaderModules } from \"./shader-module.js\";\n/**\n * Takes a list of shader module names and returns a new list of\n * shader module names that includes all dependencies, sorted so\n * that modules that are dependencies of other modules come first.\n *\n * If the shader glsl code from the returned modules is concatenated\n * in the reverse order, it is guaranteed that all functions be resolved and\n * that all function and variable definitions come before use.\n *\n * @param modules - Array of modules (inline modules or module names)\n * @return - Array of modules\n */\nexport function getShaderModuleDependencies(modules) {\n  initializeShaderModules(modules);\n  const moduleMap = {};\n  const moduleDepth = {};\n  getDependencyGraph({\n    modules,\n    level: 0,\n    moduleMap,\n    moduleDepth\n  });\n  // Return a reverse sort so that dependencies come before the modules that use them\n  const dependencies = Object.keys(moduleDepth).sort((a, b) => moduleDepth[b] - moduleDepth[a]).map(name => moduleMap[name]);\n  initializeShaderModules(dependencies);\n  return dependencies;\n}\n/**\n * Recursively checks module dependencies to calculate dependency level of each module.\n *\n * @param options.modules - Array of modules\n * @param options.level - Current level\n * @param options.moduleMap -\n * @param options.moduleDepth - Current level\n * @return - Map of module name to its level\n */\n// Adds another level of dependencies to the result map\nexport function getDependencyGraph(options) {\n  const {\n    modules,\n    level,\n    moduleMap,\n    moduleDepth\n  } = options;\n  if (level >= 5) {\n    throw new Error('Possible loop in shader dependency graph');\n  }\n  // Update level on all current modules\n  for (const module of modules) {\n    moduleMap[module.name] = module;\n    if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {\n      moduleDepth[module.name] = level;\n    }\n  }\n  // Recurse\n  for (const module of modules) {\n    if (module.dependencies) {\n      getDependencyGraph({\n        modules: module.dependencies,\n        level: level + 1,\n        moduleMap,\n        moduleDepth\n      });\n    }\n  }\n}\n/**\n * Takes a list of shader module names and returns a new list of\n * shader module names that includes all dependencies, sorted so\n * that modules that are dependencies of other modules come first.\n *\n * If the shader glsl code from the returned modules is concatenated\n * in the reverse order, it is guaranteed that all functions be resolved and\n * that all function and variable definitions come before use.\n *\n * @param modules - Array of modules (inline modules or module names)\n * @return - Array of modules\n */\nexport function getShaderDependencies(modules) {\n  initializeShaderModules(modules);\n  const moduleMap = {};\n  const moduleDepth = {};\n  getDependencyGraph({\n    modules,\n    level: 0,\n    moduleMap,\n    moduleDepth\n  });\n  // Return a reverse sort so that dependencies come before the modules that use them\n  modules = Object.keys(moduleDepth).sort((a, b) => moduleDepth[b] - moduleDepth[a]).map(name => moduleMap[name]);\n  initializeShaderModules(modules);\n  return modules;\n}\n// DEPRECATED\n/**\n * Instantiate shader modules and resolve any dependencies\n * @deprecated Use getShaderDpendencies\n */\nexport function resolveModules(modules) {\n  return getShaderDependencies(modules);\n}\n//# sourceMappingURL=shader-module-dependencies.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}