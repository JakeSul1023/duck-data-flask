{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { clamp } from '@math.gl/core';\nimport Controller from \"./controller.js\";\nimport ViewState from \"./view-state.js\";\nimport { mod } from \"../utils/math-utils.js\";\nimport LinearInterpolator from \"../transitions/linear-interpolator.js\";\nexport class OrbitState extends ViewState {\n  constructor(options) {\n    const {\n      /* Viewport arguments */\n      width,\n      // Width of viewport\n      height,\n      // Height of viewport\n      rotationX = 0,\n      // Rotation around x axis\n      rotationOrbit = 0,\n      // Rotation around orbit axis\n      target = [0, 0, 0],\n      zoom = 0,\n      /* Viewport constraints */\n      minRotationX = -90,\n      maxRotationX = 90,\n      minZoom = -Infinity,\n      maxZoom = Infinity,\n      /** Interaction states, required to calculate change during transform */\n      // Model state when the pan operation first started\n      startPanPosition,\n      // Model state when the rotate operation first started\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit,\n      // Model state when the zoom operation first started\n      startZoomPosition,\n      startZoom\n    } = options;\n    super({\n      width,\n      height,\n      rotationX,\n      rotationOrbit,\n      target,\n      zoom,\n      minRotationX,\n      maxRotationX,\n      minZoom,\n      maxZoom\n    }, {\n      startPanPosition,\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit,\n      startZoomPosition,\n      startZoom\n    });\n    this.makeViewport = options.makeViewport;\n  }\n  /**\n   * Start panning\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  panStart({\n    pos\n  }) {\n    return this._getUpdatedState({\n      startPanPosition: this._unproject(pos)\n    });\n  }\n  /**\n   * Pan\n   * @param {[Number, Number]} pos - position on screen where the pointer is\n   */\n  pan({\n    pos,\n    startPosition\n  }) {\n    const startPanPosition = this.getState().startPanPosition || startPosition;\n    if (!startPanPosition) {\n      return this;\n    }\n    const viewport = this.makeViewport(this.getViewportProps());\n    const newProps = viewport.panByPosition(startPanPosition, pos);\n    return this._getUpdatedState(newProps);\n  }\n  /**\n   * End panning\n   * Must call if `panStart()` was called\n   */\n  panEnd() {\n    return this._getUpdatedState({\n      startPanPosition: null\n    });\n  }\n  /**\n   * Start rotating\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  rotateStart({\n    pos\n  }) {\n    return this._getUpdatedState({\n      startRotatePos: pos,\n      startRotationX: this.getViewportProps().rotationX,\n      startRotationOrbit: this.getViewportProps().rotationOrbit\n    });\n  }\n  /**\n   * Rotate\n   * @param {[Number, Number]} pos - position on screen where the pointer is\n   */\n  rotate({\n    pos,\n    deltaAngleX = 0,\n    deltaAngleY = 0\n  }) {\n    const {\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit\n    } = this.getState();\n    const {\n      width,\n      height\n    } = this.getViewportProps();\n    if (!startRotatePos || startRotationX === undefined || startRotationOrbit === undefined) {\n      return this;\n    }\n    let newRotation;\n    if (pos) {\n      let deltaScaleX = (pos[0] - startRotatePos[0]) / width;\n      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;\n      if (startRotationX < -90 || startRotationX > 90) {\n        // When looking at the \"back\" side of the scene, invert horizontal drag\n        // so that the camera movement follows user input\n        deltaScaleX *= -1;\n      }\n      newRotation = {\n        rotationX: startRotationX + deltaScaleY * 180,\n        rotationOrbit: startRotationOrbit + deltaScaleX * 180\n      };\n    } else {\n      newRotation = {\n        rotationX: startRotationX + deltaAngleY,\n        rotationOrbit: startRotationOrbit + deltaAngleX\n      };\n    }\n    return this._getUpdatedState(newRotation);\n  }\n  /**\n   * End rotating\n   * Must call if `rotateStart()` was called\n   */\n  rotateEnd() {\n    return this._getUpdatedState({\n      startRotationX: null,\n      startRotationOrbit: null\n    });\n  }\n  // shortest path between two view states\n  shortestPathFrom(viewState) {\n    const fromProps = viewState.getViewportProps();\n    const props = {\n      ...this.getViewportProps()\n    };\n    const {\n      rotationOrbit\n    } = props;\n    if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {\n      props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;\n    }\n    return props;\n  }\n  /**\n   * Start zooming\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  zoomStart({\n    pos\n  }) {\n    return this._getUpdatedState({\n      startZoomPosition: this._unproject(pos),\n      startZoom: this.getViewportProps().zoom\n    });\n  }\n  /**\n   * Zoom\n   * @param {[Number, Number]} pos - position on screen where the current target is\n   * @param {[Number, Number]} startPos - the target position at\n   *   the start of the operation. Must be supplied of `zoomStart()` was not called\n   * @param {Number} scale - a number between [0, 1] specifying the accumulated\n   *   relative scale.\n   */\n  zoom({\n    pos,\n    startPos,\n    scale\n  }) {\n    let {\n      startZoom,\n      startZoomPosition\n    } = this.getState();\n    if (!startZoomPosition) {\n      // We have two modes of zoom:\n      // scroll zoom that are discrete events (transform from the current zoom level),\n      // and pinch zoom that are continuous events (transform from the zoom level when\n      // pinch started).\n      // If startZoom state is defined, then use the startZoom state;\n      // otherwise assume discrete zooming\n      startZoom = this.getViewportProps().zoom;\n      startZoomPosition = this._unproject(startPos) || this._unproject(pos);\n    }\n    if (!startZoomPosition) {\n      return this;\n    }\n    const newZoom = this._calculateNewZoom({\n      scale,\n      startZoom\n    });\n    const zoomedViewport = this.makeViewport({\n      ...this.getViewportProps(),\n      zoom: newZoom\n    });\n    return this._getUpdatedState({\n      zoom: newZoom,\n      ...zoomedViewport.panByPosition(startZoomPosition, pos)\n    });\n  }\n  /**\n   * End zooming\n   * Must call if `zoomStart()` was called\n   */\n  zoomEnd() {\n    return this._getUpdatedState({\n      startZoomPosition: null,\n      startZoom: null\n    });\n  }\n  zoomIn(speed = 2) {\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({\n        scale: speed\n      })\n    });\n  }\n  zoomOut(speed = 2) {\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({\n        scale: 1 / speed\n      })\n    });\n  }\n  moveLeft(speed = 50) {\n    return this._panFromCenter([-speed, 0]);\n  }\n  moveRight(speed = 50) {\n    return this._panFromCenter([speed, 0]);\n  }\n  moveUp(speed = 50) {\n    return this._panFromCenter([0, -speed]);\n  }\n  moveDown(speed = 50) {\n    return this._panFromCenter([0, speed]);\n  }\n  rotateLeft(speed = 15) {\n    return this._getUpdatedState({\n      rotationOrbit: this.getViewportProps().rotationOrbit - speed\n    });\n  }\n  rotateRight(speed = 15) {\n    return this._getUpdatedState({\n      rotationOrbit: this.getViewportProps().rotationOrbit + speed\n    });\n  }\n  rotateUp(speed = 10) {\n    return this._getUpdatedState({\n      rotationX: this.getViewportProps().rotationX - speed\n    });\n  }\n  rotateDown(speed = 10) {\n    return this._getUpdatedState({\n      rotationX: this.getViewportProps().rotationX + speed\n    });\n  }\n  /* Private methods */\n  _unproject(pos) {\n    const viewport = this.makeViewport(this.getViewportProps());\n    // @ts-ignore\n    return pos && viewport.unproject(pos);\n  }\n  // Calculates new zoom\n  _calculateNewZoom({\n    scale,\n    startZoom\n  }) {\n    const {\n      maxZoom,\n      minZoom\n    } = this.getViewportProps();\n    if (startZoom === undefined) {\n      startZoom = this.getViewportProps().zoom;\n    }\n    const zoom = startZoom + Math.log2(scale);\n    return clamp(zoom, minZoom, maxZoom);\n  }\n  _panFromCenter(offset) {\n    const {\n      width,\n      height,\n      target\n    } = this.getViewportProps();\n    return this.pan({\n      startPosition: target,\n      pos: [width / 2 + offset[0], height / 2 + offset[1]]\n    });\n  }\n  _getUpdatedState(newProps) {\n    // @ts-ignore\n    return new this.constructor({\n      makeViewport: this.makeViewport,\n      ...this.getViewportProps(),\n      ...this.getState(),\n      ...newProps\n    });\n  }\n  // Apply any constraints (mathematical or defined by _viewportProps) to map state\n  applyConstraints(props) {\n    // Ensure zoom is within specified range\n    const {\n      maxZoom,\n      minZoom,\n      zoom,\n      maxRotationX,\n      minRotationX,\n      rotationOrbit\n    } = props;\n    props.zoom = Array.isArray(zoom) ? [clamp(zoom[0], minZoom, maxZoom), clamp(zoom[1], minZoom, maxZoom)] : clamp(zoom, minZoom, maxZoom);\n    props.rotationX = clamp(props.rotationX, minRotationX, maxRotationX);\n    if (rotationOrbit < -180 || rotationOrbit > 180) {\n      props.rotationOrbit = mod(rotationOrbit + 180, 360) - 180;\n    }\n    return props;\n  }\n}\nexport default class OrbitController extends Controller {\n  constructor() {\n    super(...arguments);\n    this.ControllerState = OrbitState;\n    this.transition = {\n      transitionDuration: 300,\n      transitionInterpolator: new LinearInterpolator({\n        transitionProps: {\n          compare: ['target', 'zoom', 'rotationX', 'rotationOrbit'],\n          required: ['target', 'zoom']\n        }\n      })\n    };\n  }\n}","map":{"version":3,"names":["clamp","Controller","ViewState","mod","LinearInterpolator","OrbitState","constructor","options","width","height","rotationX","rotationOrbit","target","zoom","minRotationX","maxRotationX","minZoom","Infinity","maxZoom","startPanPosition","startRotatePos","startRotationX","startRotationOrbit","startZoomPosition","startZoom","makeViewport","panStart","pos","_getUpdatedState","_unproject","pan","startPosition","getState","viewport","getViewportProps","newProps","panByPosition","panEnd","rotateStart","rotate","deltaAngleX","deltaAngleY","undefined","newRotation","deltaScaleX","deltaScaleY","rotateEnd","shortestPathFrom","viewState","fromProps","props","Math","abs","zoomStart","startPos","scale","newZoom","_calculateNewZoom","zoomedViewport","zoomEnd","zoomIn","speed","zoomOut","moveLeft","_panFromCenter","moveRight","moveUp","moveDown","rotateLeft","rotateRight","rotateUp","rotateDown","unproject","log2","offset","applyConstraints","Array","isArray","OrbitController","ControllerState","transition","transitionDuration","transitionInterpolator","transitionProps","compare","required"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\controllers\\orbit-controller.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {clamp} from '@math.gl/core';\nimport Controller from './controller';\nimport ViewState from './view-state';\nimport {mod} from '../utils/math-utils';\n\nimport type Viewport from '../viewports/viewport';\nimport LinearInterpolator from '../transitions/linear-interpolator';\n\nexport type OrbitStateProps = {\n  width: number;\n  height: number;\n  target?: number[];\n  zoom?: number | number[];\n  rotationX?: number;\n  rotationOrbit?: number;\n\n  /** Viewport constraints */\n  maxZoom?: number;\n  minZoom?: number;\n  minRotationX?: number;\n  maxRotationX?: number;\n};\n\ntype OrbitStateInternal = {\n  startPanPosition?: number[];\n  startRotatePos?: number[];\n  startRotationX?: number;\n  startRotationOrbit?: number;\n  startZoomPosition?: number[];\n  startZoom?: number | number[];\n};\n\nexport class OrbitState extends ViewState<OrbitState, OrbitStateProps, OrbitStateInternal> {\n  makeViewport: (props: Record<string, any>) => Viewport;\n\n  constructor(\n    options: OrbitStateProps &\n      OrbitStateInternal & {\n        makeViewport: (props: Record<string, any>) => Viewport;\n      }\n  ) {\n    const {\n      /* Viewport arguments */\n      width, // Width of viewport\n      height, // Height of viewport\n      rotationX = 0, // Rotation around x axis\n      rotationOrbit = 0, // Rotation around orbit axis\n      target = [0, 0, 0],\n      zoom = 0,\n\n      /* Viewport constraints */\n      minRotationX = -90,\n      maxRotationX = 90,\n      minZoom = -Infinity,\n      maxZoom = Infinity,\n\n      /** Interaction states, required to calculate change during transform */\n      // Model state when the pan operation first started\n      startPanPosition,\n      // Model state when the rotate operation first started\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit,\n      // Model state when the zoom operation first started\n      startZoomPosition,\n      startZoom\n    } = options;\n\n    super(\n      {\n        width,\n        height,\n        rotationX,\n        rotationOrbit,\n        target,\n        zoom,\n        minRotationX,\n        maxRotationX,\n        minZoom,\n        maxZoom\n      },\n      {\n        startPanPosition,\n        startRotatePos,\n        startRotationX,\n        startRotationOrbit,\n        startZoomPosition,\n        startZoom\n      }\n    );\n\n    this.makeViewport = options.makeViewport;\n  }\n\n  /**\n   * Start panning\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  panStart({pos}: {pos: [number, number]}): OrbitState {\n    return this._getUpdatedState({\n      startPanPosition: this._unproject(pos)\n    });\n  }\n\n  /**\n   * Pan\n   * @param {[Number, Number]} pos - position on screen where the pointer is\n   */\n  pan({pos, startPosition}: {pos: [number, number]; startPosition?: number[]}): OrbitState {\n    const startPanPosition = this.getState().startPanPosition || startPosition;\n\n    if (!startPanPosition) {\n      return this;\n    }\n\n    const viewport = this.makeViewport(this.getViewportProps());\n    const newProps = viewport.panByPosition(startPanPosition, pos);\n\n    return this._getUpdatedState(newProps);\n  }\n\n  /**\n   * End panning\n   * Must call if `panStart()` was called\n   */\n  panEnd(): OrbitState {\n    return this._getUpdatedState({\n      startPanPosition: null\n    });\n  }\n\n  /**\n   * Start rotating\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  rotateStart({pos}: {pos: [number, number]}): OrbitState {\n    return this._getUpdatedState({\n      startRotatePos: pos,\n      startRotationX: this.getViewportProps().rotationX,\n      startRotationOrbit: this.getViewportProps().rotationOrbit\n    });\n  }\n\n  /**\n   * Rotate\n   * @param {[Number, Number]} pos - position on screen where the pointer is\n   */\n  rotate({\n    pos,\n    deltaAngleX = 0,\n    deltaAngleY = 0\n  }: {\n    pos?: [number, number];\n    deltaAngleX?: number;\n    deltaAngleY?: number;\n  }): OrbitState {\n    const {startRotatePos, startRotationX, startRotationOrbit} = this.getState();\n    const {width, height} = this.getViewportProps();\n\n    if (!startRotatePos || startRotationX === undefined || startRotationOrbit === undefined) {\n      return this;\n    }\n\n    let newRotation;\n    if (pos) {\n      let deltaScaleX = (pos[0] - startRotatePos[0]) / width;\n      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;\n\n      if (startRotationX < -90 || startRotationX > 90) {\n        // When looking at the \"back\" side of the scene, invert horizontal drag\n        // so that the camera movement follows user input\n        deltaScaleX *= -1;\n      }\n      newRotation = {\n        rotationX: startRotationX + deltaScaleY * 180,\n        rotationOrbit: startRotationOrbit + deltaScaleX * 180\n      };\n    } else {\n      newRotation = {\n        rotationX: startRotationX + deltaAngleY,\n        rotationOrbit: startRotationOrbit + deltaAngleX\n      };\n    }\n\n    return this._getUpdatedState(newRotation);\n  }\n\n  /**\n   * End rotating\n   * Must call if `rotateStart()` was called\n   */\n  rotateEnd(): OrbitState {\n    return this._getUpdatedState({\n      startRotationX: null,\n      startRotationOrbit: null\n    });\n  }\n\n  // shortest path between two view states\n  shortestPathFrom(viewState: OrbitState): OrbitStateProps {\n    const fromProps = viewState.getViewportProps();\n    const props = {...this.getViewportProps()};\n    const {rotationOrbit} = props;\n\n    if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {\n      props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;\n    }\n\n    return props;\n  }\n\n  /**\n   * Start zooming\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  zoomStart({pos}: {pos: [number, number]}): OrbitState {\n    return this._getUpdatedState({\n      startZoomPosition: this._unproject(pos),\n      startZoom: this.getViewportProps().zoom\n    });\n  }\n\n  /**\n   * Zoom\n   * @param {[Number, Number]} pos - position on screen where the current target is\n   * @param {[Number, Number]} startPos - the target position at\n   *   the start of the operation. Must be supplied of `zoomStart()` was not called\n   * @param {Number} scale - a number between [0, 1] specifying the accumulated\n   *   relative scale.\n   */\n  zoom({\n    pos,\n    startPos,\n    scale\n  }: {\n    pos: [number, number];\n    startPos?: [number, number];\n    scale: number;\n  }): OrbitState {\n    let {startZoom, startZoomPosition} = this.getState();\n    if (!startZoomPosition) {\n      // We have two modes of zoom:\n      // scroll zoom that are discrete events (transform from the current zoom level),\n      // and pinch zoom that are continuous events (transform from the zoom level when\n      // pinch started).\n      // If startZoom state is defined, then use the startZoom state;\n      // otherwise assume discrete zooming\n      startZoom = this.getViewportProps().zoom;\n      startZoomPosition = this._unproject(startPos) || this._unproject(pos);\n    }\n    if (!startZoomPosition) {\n      return this;\n    }\n    const newZoom = this._calculateNewZoom({scale, startZoom});\n    const zoomedViewport = this.makeViewport({...this.getViewportProps(), zoom: newZoom});\n\n    return this._getUpdatedState({\n      zoom: newZoom,\n      ...zoomedViewport.panByPosition(startZoomPosition, pos)\n    });\n  }\n\n  /**\n   * End zooming\n   * Must call if `zoomStart()` was called\n   */\n  zoomEnd(): OrbitState {\n    return this._getUpdatedState({\n      startZoomPosition: null,\n      startZoom: null\n    });\n  }\n\n  zoomIn(speed: number = 2): OrbitState {\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({scale: speed})\n    });\n  }\n\n  zoomOut(speed: number = 2): OrbitState {\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({scale: 1 / speed})\n    });\n  }\n\n  moveLeft(speed: number = 50): OrbitState {\n    return this._panFromCenter([-speed, 0]);\n  }\n\n  moveRight(speed: number = 50): OrbitState {\n    return this._panFromCenter([speed, 0]);\n  }\n\n  moveUp(speed: number = 50): OrbitState {\n    return this._panFromCenter([0, -speed]);\n  }\n\n  moveDown(speed: number = 50): OrbitState {\n    return this._panFromCenter([0, speed]);\n  }\n\n  rotateLeft(speed: number = 15): OrbitState {\n    return this._getUpdatedState({\n      rotationOrbit: this.getViewportProps().rotationOrbit - speed\n    });\n  }\n\n  rotateRight(speed: number = 15): OrbitState {\n    return this._getUpdatedState({\n      rotationOrbit: this.getViewportProps().rotationOrbit + speed\n    });\n  }\n\n  rotateUp(speed: number = 10): OrbitState {\n    return this._getUpdatedState({\n      rotationX: this.getViewportProps().rotationX - speed\n    });\n  }\n\n  rotateDown(speed: number = 10): OrbitState {\n    return this._getUpdatedState({\n      rotationX: this.getViewportProps().rotationX + speed\n    });\n  }\n\n  /* Private methods */\n\n  _unproject(pos?: number[]): number[] | undefined {\n    const viewport = this.makeViewport(this.getViewportProps());\n    // @ts-ignore\n    return pos && viewport.unproject(pos);\n  }\n\n  // Calculates new zoom\n  _calculateNewZoom({\n    scale,\n    startZoom\n  }: {\n    scale: number;\n    startZoom?: number | number[];\n  }): number | number[] {\n    const {maxZoom, minZoom} = this.getViewportProps();\n    if (startZoom === undefined) {\n      startZoom = this.getViewportProps().zoom;\n    }\n    const zoom = (startZoom as number) + Math.log2(scale);\n    return clamp(zoom, minZoom, maxZoom);\n  }\n\n  _panFromCenter(offset) {\n    const {width, height, target} = this.getViewportProps();\n    return this.pan({\n      startPosition: target,\n      pos: [width / 2 + offset[0], height / 2 + offset[1]]\n    });\n  }\n\n  _getUpdatedState(newProps): OrbitState {\n    // @ts-ignore\n    return new this.constructor({\n      makeViewport: this.makeViewport,\n      ...this.getViewportProps(),\n      ...this.getState(),\n      ...newProps\n    });\n  }\n\n  // Apply any constraints (mathematical or defined by _viewportProps) to map state\n  applyConstraints(props: Required<OrbitStateProps>): Required<OrbitStateProps> {\n    // Ensure zoom is within specified range\n    const {maxZoom, minZoom, zoom, maxRotationX, minRotationX, rotationOrbit} = props;\n\n    props.zoom = Array.isArray(zoom)\n      ? [clamp(zoom[0], minZoom, maxZoom), clamp(zoom[1], minZoom, maxZoom)]\n      : clamp(zoom, minZoom, maxZoom);\n\n    props.rotationX = clamp(props.rotationX, minRotationX, maxRotationX);\n    if (rotationOrbit < -180 || rotationOrbit > 180) {\n      props.rotationOrbit = mod(rotationOrbit + 180, 360) - 180;\n    }\n\n    return props;\n  }\n}\n\nexport default class OrbitController extends Controller<OrbitState> {\n  ControllerState = OrbitState;\n\n  transition = {\n    transitionDuration: 300,\n    transitionInterpolator: new LinearInterpolator({\n      transitionProps: {\n        compare: ['target', 'zoom', 'rotationX', 'rotationOrbit'],\n        required: ['target', 'zoom']\n      }\n    })\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}