{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { LayerExtension } from '@deck.gl/core';\nimport { patternShaders } from \"./shader-module.js\";\nconst defaultProps = {\n  fillPatternEnabled: true,\n  fillPatternAtlas: {\n    type: 'image',\n    value: null,\n    async: true,\n    parameters: {\n      lodMaxClamp: 0\n    }\n  },\n  fillPatternMapping: {\n    type: 'object',\n    value: {},\n    async: true\n  },\n  fillPatternMask: true,\n  getFillPattern: {\n    type: 'accessor',\n    value: d => d.pattern\n  },\n  getFillPatternScale: {\n    type: 'accessor',\n    value: 1\n  },\n  getFillPatternOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  }\n};\n/** Adds selected features to layers that render a \"fill\", such as the `PolygonLayer` and `ScatterplotLayer`. */\nclass FillStyleExtension extends LayerExtension {\n  constructor({\n    pattern = false\n  } = {}) {\n    super({\n      pattern\n    });\n  }\n  isEnabled(layer) {\n    return layer.getAttributeManager() !== null && !('pathTesselator' in layer.state);\n  }\n  getShaders(extension) {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n    return {\n      modules: [extension.opts.pattern && patternShaders].filter(Boolean)\n    };\n  }\n  initializeState(context, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n    const attributeManager = this.getAttributeManager();\n    if (extension.opts.pattern) {\n      attributeManager.add({\n        fillPatternFrames: {\n          size: 4,\n          stepMode: 'dynamic',\n          accessor: 'getFillPattern',\n          transform: extension.getPatternFrame.bind(this)\n        },\n        fillPatternScales: {\n          size: 1,\n          stepMode: 'dynamic',\n          accessor: 'getFillPatternScale',\n          defaultValue: 1\n        },\n        fillPatternOffsets: {\n          size: 2,\n          stepMode: 'dynamic',\n          accessor: 'getFillPatternOffset'\n        }\n      });\n    }\n    this.setState({\n      emptyTexture: this.context.device.createTexture({\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n  updateState({\n    props,\n    oldProps\n  }, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n    if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {\n      this.getAttributeManager().invalidate('getFillPattern');\n    }\n  }\n  draw(params, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n    const {\n      fillPatternAtlas,\n      fillPatternEnabled,\n      fillPatternMask\n    } = this.props;\n    const fillProps = {\n      project: params.shaderModuleProps.project,\n      fillPatternEnabled,\n      fillPatternMask,\n      fillPatternTexture: fillPatternAtlas || this.state.emptyTexture\n    };\n    this.setShaderModuleProps({\n      fill: fillProps\n    });\n  }\n  finalizeState() {\n    const emptyTexture = this.state.emptyTexture;\n    emptyTexture?.delete();\n  }\n  getPatternFrame(name) {\n    const {\n      fillPatternMapping\n    } = this.getCurrentLayer().props;\n    const def = fillPatternMapping && fillPatternMapping[name];\n    return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];\n  }\n}\nFillStyleExtension.defaultProps = defaultProps;\nFillStyleExtension.extensionName = 'FillStyleExtension';\nexport default FillStyleExtension;","map":{"version":3,"names":["LayerExtension","patternShaders","defaultProps","fillPatternEnabled","fillPatternAtlas","type","value","async","parameters","lodMaxClamp","fillPatternMapping","fillPatternMask","getFillPattern","d","pattern","getFillPatternScale","getFillPatternOffset","FillStyleExtension","constructor","isEnabled","layer","getAttributeManager","state","getShaders","extension","modules","opts","filter","Boolean","initializeState","context","attributeManager","add","fillPatternFrames","size","stepMode","accessor","transform","getPatternFrame","bind","fillPatternScales","defaultValue","fillPatternOffsets","setState","emptyTexture","device","createTexture","data","Uint8Array","width","height","updateState","props","oldProps","invalidate","draw","params","fillProps","project","shaderModuleProps","fillPatternTexture","setShaderModuleProps","fill","finalizeState","delete","name","getCurrentLayer","def","x","y","extensionName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\extensions\\src\\fill-style\\fill-style-extension.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {LayerExtension} from '@deck.gl/core';\n\nimport {FillStyleModuleProps, patternShaders} from './shader-module';\n\nimport type {\n  Layer,\n  LayerContext,\n  DefaultProps,\n  Accessor,\n  AccessorFunction,\n  TextureSource,\n  UpdateParameters\n} from '@deck.gl/core';\nimport type {Texture} from '@luma.gl/core';\n\nconst defaultProps: DefaultProps<FillStyleExtensionProps> = {\n  fillPatternEnabled: true,\n  fillPatternAtlas: {\n    type: 'image',\n    value: null,\n    async: true,\n    parameters: {lodMaxClamp: 0}\n  },\n  fillPatternMapping: {type: 'object', value: {}, async: true},\n  fillPatternMask: true,\n  getFillPattern: {type: 'accessor', value: d => d.pattern},\n  getFillPatternScale: {type: 'accessor', value: 1},\n  getFillPatternOffset: {type: 'accessor', value: [0, 0]}\n};\n\nexport type FillStyleExtensionProps<DataT = any> = {\n  /** Cheap toggle to enable/disable pattern fill. Requires the `pattern` option to be on.\n   * @default true\n   */\n  fillPatternEnabled?: boolean;\n  /** Sprite image url or texture that packs all your patterns into one layout. */\n  fillPatternAtlas?: string | TextureSource;\n  /** Pattern names mapped to pattern definitions, or a url that points to a JSON file. */\n  fillPatternMapping?:\n    | string\n    | Record<\n        string,\n        {\n          /** Left position of the pattern on the atlas */\n          x: number;\n          /** Top position of the pattern on the atlas */\n          y: number;\n          /** Width of the pattern */\n          width: number;\n          /** Height of the pattern */\n          height: number;\n        }\n      >;\n  /**\n   * Whether to treat the patterns as transparency masks.\n   * @default true\n   */\n  fillPatternMask?: boolean;\n  /** Accessor for the name of the pattern. */\n  getFillPattern?: AccessorFunction<DataT, string>;\n  /** Accessor for the scale of the pattern, relative to the original size. If the pattern is 24 x 24 pixels, scale `1` roughly yields 24 meters.\n   * @default 1\n   */\n  getFillPatternScale?: Accessor<DataT, number>;\n  /**\n   * Accessor for the offset of the pattern, relative to the original size. Offset `[0.5, 0.5]` shifts the pattern alignment by half.\n   * @default [0, 0]\n   */\n  getFillPatternOffset?: Accessor<DataT, [number, number]>;\n};\n\nexport type FillStyleExtensionOptions = {\n  /** If `true`, adds the ability to tile the filled area with a pattern.\n   * @default false\n   */\n  pattern: boolean;\n};\n\n/** Adds selected features to layers that render a \"fill\", such as the `PolygonLayer` and `ScatterplotLayer`. */\nexport default class FillStyleExtension extends LayerExtension<FillStyleExtensionOptions> {\n  static defaultProps = defaultProps;\n  static extensionName = 'FillStyleExtension';\n\n  constructor({pattern = false}: Partial<FillStyleExtensionOptions> = {}) {\n    super({pattern});\n  }\n\n  isEnabled(layer: Layer<FillStyleExtensionProps>): boolean {\n    return layer.getAttributeManager() !== null && !('pathTesselator' in layer.state);\n  }\n\n  getShaders(this: Layer<FillStyleExtensionProps>, extension: this): any {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n\n    return {\n      modules: [extension.opts.pattern && patternShaders].filter(Boolean)\n    };\n  }\n\n  initializeState(this: Layer<FillStyleExtensionProps>, context: LayerContext, extension: this) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const attributeManager = this.getAttributeManager();\n\n    if (extension.opts.pattern) {\n      attributeManager!.add({\n        fillPatternFrames: {\n          size: 4,\n          stepMode: 'dynamic',\n          accessor: 'getFillPattern',\n          transform: extension.getPatternFrame.bind(this)\n        },\n        fillPatternScales: {\n          size: 1,\n          stepMode: 'dynamic',\n          accessor: 'getFillPatternScale',\n          defaultValue: 1\n        },\n        fillPatternOffsets: {\n          size: 2,\n          stepMode: 'dynamic',\n          accessor: 'getFillPatternOffset'\n        }\n      });\n    }\n    this.setState({\n      emptyTexture: this.context.device.createTexture({\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n\n  updateState(\n    this: Layer<FillStyleExtensionProps>,\n    {props, oldProps}: UpdateParameters<Layer<FillStyleExtensionProps>>,\n    extension: this\n  ) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {\n      this.getAttributeManager()!.invalidate('getFillPattern');\n    }\n  }\n\n  draw(this: Layer<FillStyleExtensionProps>, params: any, extension: this) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const {fillPatternAtlas, fillPatternEnabled, fillPatternMask} = this.props;\n    const fillProps: FillStyleModuleProps = {\n      project: params.shaderModuleProps.project,\n      fillPatternEnabled,\n      fillPatternMask,\n      fillPatternTexture: (fillPatternAtlas || this.state.emptyTexture) as Texture\n    };\n    this.setShaderModuleProps({fill: fillProps});\n  }\n\n  finalizeState(this: Layer<FillStyleExtensionProps>) {\n    const emptyTexture = this.state.emptyTexture as Texture;\n    emptyTexture?.delete();\n  }\n\n  getPatternFrame(this: Layer<FillStyleExtensionProps>, name: string) {\n    const {fillPatternMapping} = this.getCurrentLayer()!.props;\n    const def = fillPatternMapping && fillPatternMapping[name];\n    return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}