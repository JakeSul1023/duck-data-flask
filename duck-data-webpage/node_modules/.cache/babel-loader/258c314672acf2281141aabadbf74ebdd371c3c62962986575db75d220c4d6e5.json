{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* eslint-disable react/no-direct-mutation-state */\nimport { Buffer } from '@luma.gl/core';\nimport { WebGLDevice } from '@luma.gl/webgl';\nimport { COORDINATE_SYSTEM } from \"./constants.js\";\nimport AttributeManager from \"./attribute/attribute-manager.js\";\nimport UniformTransitionManager from \"./uniform-transition-manager.js\";\nimport { diffProps, validateProps } from \"../lifecycle/props.js\";\nimport { LIFECYCLE } from \"../lifecycle/constants.js\";\nimport { count } from \"../utils/count.js\";\nimport log from \"../utils/log.js\";\nimport debug from \"../debug/index.js\";\nimport assert from \"../utils/assert.js\";\nimport memoize from \"../utils/memoize.js\";\nimport { mergeShaders } from \"../utils/shader.js\";\nimport { projectPosition, getWorldPosition } from \"../shaderlib/project/project-functions.js\";\nimport typedArrayManager from \"../utils/typed-array-manager.js\";\nimport Component from \"../lifecycle/component.js\";\nimport LayerState from \"./layer-state.js\";\nimport { worldToPixels } from '@math.gl/web-mercator';\nimport { load } from '@loaders.gl/core';\nconst TRACE_CHANGE_FLAG = 'layer.changeFlag';\nconst TRACE_INITIALIZE = 'layer.initialize';\nconst TRACE_UPDATE = 'layer.update';\nconst TRACE_FINALIZE = 'layer.finalize';\nconst TRACE_MATCHED = 'layer.matched';\nconst MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;\nconst EMPTY_ARRAY = Object.freeze([]);\n// Only compare the same two viewports once\nconst areViewportsEqual = memoize(_ref => {\n  let {\n    oldViewport,\n    viewport\n  } = _ref;\n  return oldViewport.equals(viewport);\n});\nlet pickingColorCache = new Uint8ClampedArray(0);\nconst defaultProps = {\n  // data: Special handling for null, see below\n  data: {\n    type: 'data',\n    value: EMPTY_ARRAY,\n    async: true\n  },\n  dataComparator: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  _dataDiff: {\n    type: 'function',\n    // @ts-ignore __diff is not defined on data\n    value: data => data && data.__diff,\n    optional: true\n  },\n  dataTransform: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  onDataLoad: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  onError: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  fetch: {\n    type: 'function',\n    value: (url, _ref2) => {\n      let {\n        propName,\n        layer,\n        loaders,\n        loadOptions,\n        signal\n      } = _ref2;\n      const {\n        resourceManager\n      } = layer.context;\n      loadOptions = loadOptions || layer.getLoadOptions();\n      loaders = loaders || layer.props.loaders;\n      if (signal) {\n        loadOptions = {\n          ...loadOptions,\n          fetch: {\n            ...loadOptions?.fetch,\n            signal\n          }\n        };\n      }\n      let inResourceManager = resourceManager.contains(url);\n      if (!inResourceManager && !loadOptions) {\n        // If there is no layer-specific load options, then attempt to cache this resource in the data manager\n        resourceManager.add({\n          resourceId: url,\n          data: load(url, loaders),\n          persistent: false\n        });\n        inResourceManager = true;\n      }\n      if (inResourceManager) {\n        return resourceManager.subscribe({\n          resourceId: url,\n          onChange: data => layer.internalState?.reloadAsyncProp(propName, data),\n          consumerId: layer.id,\n          requestId: propName\n        });\n      }\n      return load(url, loaders, loadOptions);\n    }\n  },\n  updateTriggers: {},\n  // Update triggers: a core change detection mechanism in deck.gl\n  visible: true,\n  pickable: false,\n  opacity: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  operation: 'draw',\n  onHover: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  onClick: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  onDragStart: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  onDrag: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  onDragEnd: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  coordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n  coordinateOrigin: {\n    type: 'array',\n    value: [0, 0, 0],\n    compare: true\n  },\n  modelMatrix: {\n    type: 'array',\n    value: null,\n    compare: true,\n    optional: true\n  },\n  wrapLongitude: false,\n  positionFormat: 'XYZ',\n  colorFormat: 'RGBA',\n  parameters: {\n    type: 'object',\n    value: {},\n    optional: true,\n    compare: 2\n  },\n  loadOptions: {\n    type: 'object',\n    value: null,\n    optional: true,\n    ignore: true\n  },\n  transitions: null,\n  extensions: [],\n  loaders: {\n    type: 'array',\n    value: [],\n    optional: true,\n    ignore: true\n  },\n  // Offset depth based on layer index to avoid z-fighting.\n  // Negative values pull layer towards the camera\n  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm\n  getPolygonOffset: {\n    type: 'function',\n    value: _ref3 => {\n      let {\n        layerIndex\n      } = _ref3;\n      return [0, -layerIndex * 100];\n    }\n  },\n  // Selection/Highlighting\n  highlightedObjectIndex: null,\n  autoHighlight: false,\n  highlightColor: {\n    type: 'accessor',\n    value: [0, 0, 128, 128]\n  }\n};\nclass Layer extends Component {\n  constructor() {\n    super(...arguments);\n    this.internalState = null;\n    this.lifecycle = LIFECYCLE.NO_STATE; // Helps track and debug the life cycle of the layers\n    this.parent = null;\n  }\n  static get componentName() {\n    return Object.prototype.hasOwnProperty.call(this, 'layerName') ? this.layerName : '';\n  }\n  get root() {\n    // eslint-disable-next-line\n    let layer = this;\n    while (layer.parent) {\n      layer = layer.parent;\n    }\n    return layer;\n  }\n  toString() {\n    const className = this.constructor.layerName || this.constructor.name;\n    return `${className}({id: '${this.props.id}'})`;\n  }\n  // Public API for users\n  /** Projects a point with current view state from the current layer's coordinate system to screen */\n  project(xyz) {\n    assert(this.internalState);\n    const viewport = this.internalState.viewport || this.context.viewport;\n    const worldPosition = getWorldPosition(xyz, {\n      viewport,\n      modelMatrix: this.props.modelMatrix,\n      coordinateOrigin: this.props.coordinateOrigin,\n      coordinateSystem: this.props.coordinateSystem\n    });\n    const [x, y, z] = worldToPixels(worldPosition, viewport.pixelProjectionMatrix);\n    return xyz.length === 2 ? [x, y] : [x, y, z];\n  }\n  /** Unprojects a screen pixel to the current view's default coordinate system\n      Note: this does not reverse `project`. */\n  unproject(xy) {\n    assert(this.internalState);\n    const viewport = this.internalState.viewport || this.context.viewport;\n    return viewport.unproject(xy);\n  }\n  /** Projects a point with current view state from the current layer's coordinate system to the world space */\n  projectPosition(xyz, params) {\n    assert(this.internalState);\n    const viewport = this.internalState.viewport || this.context.viewport;\n    return projectPosition(xyz, {\n      viewport,\n      modelMatrix: this.props.modelMatrix,\n      coordinateOrigin: this.props.coordinateOrigin,\n      coordinateSystem: this.props.coordinateSystem,\n      ...params\n    });\n  }\n  // Public API for custom layer implementation\n  /** `true` if this layer renders other layers */\n  get isComposite() {\n    return false;\n  }\n  /** `true` if the layer renders to screen */\n  get isDrawable() {\n    return true;\n  }\n  /** Updates selected state members and marks the layer for redraw */\n  setState(partialState) {\n    this.setChangeFlags({\n      stateChanged: true\n    });\n    Object.assign(this.state, partialState);\n    this.setNeedsRedraw();\n  }\n  /** Sets the redraw flag for this layer, will trigger a redraw next animation frame */\n  setNeedsRedraw() {\n    if (this.internalState) {\n      this.internalState.needsRedraw = true;\n    }\n  }\n  /** Mark this layer as needs a deep update */\n  setNeedsUpdate() {\n    if (this.internalState) {\n      this.context.layerManager.setNeedsUpdate(String(this));\n      this.internalState.needsUpdate = true;\n    }\n  }\n  /** Returns true if all async resources are loaded */\n  get isLoaded() {\n    return this.internalState ? !this.internalState.isAsyncPropLoading() : false;\n  }\n  /** Returns true if using shader-based WGS84 longitude wrapping */\n  get wrapLongitude() {\n    return this.props.wrapLongitude;\n  }\n  /** @deprecated Returns true if the layer is visible in the picking pass */\n  isPickable() {\n    return this.props.pickable && this.props.visible;\n  }\n  /** Returns an array of models used by this layer, can be overriden by layer subclass */\n  getModels() {\n    const state = this.state;\n    return state && (state.models || state.model && [state.model]) || [];\n  }\n  /** Update shader input parameters */\n  setShaderModuleProps() {\n    for (const model of this.getModels()) {\n      model.shaderInputs.setProps(...arguments);\n    }\n  }\n  /** Returns the attribute manager of this layer */\n  getAttributeManager() {\n    return this.internalState && this.internalState.attributeManager;\n  }\n  /** Returns the most recent layer that matched to this state\n    (When reacting to an async event, this layer may no longer be the latest) */\n  getCurrentLayer() {\n    return this.internalState && this.internalState.layer;\n  }\n  /** Returns the default parse options for async props */\n  getLoadOptions() {\n    return this.props.loadOptions;\n  }\n  use64bitPositions() {\n    const {\n      coordinateSystem\n    } = this.props;\n    return coordinateSystem === COORDINATE_SYSTEM.DEFAULT || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN;\n  }\n  // Event handling\n  onHover(info, pickingEvent) {\n    if (this.props.onHover) {\n      return this.props.onHover(info, pickingEvent) || false;\n    }\n    return false;\n  }\n  onClick(info, pickingEvent) {\n    if (this.props.onClick) {\n      return this.props.onClick(info, pickingEvent) || false;\n    }\n    return false;\n  }\n  // Returns the picking color that doesn't match any subfeature\n  // Use if some graphics do not belong to any pickable subfeature\n  // @return {Array} - a black color\n  nullPickingColor() {\n    return [0, 0, 0];\n  }\n  // Returns the picking color that doesn't match any subfeature\n  // Use if some graphics do not belong to any pickable subfeature\n  encodePickingColor(i) {\n    let target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    target[0] = i + 1 & 255;\n    target[1] = i + 1 >> 8 & 255;\n    target[2] = i + 1 >> 8 >> 8 & 255;\n    return target;\n  }\n  // Returns the index corresponding to a picking color that doesn't match any subfeature\n  // @param {Uint8Array} color - color array to be decoded\n  // @return {Array} - the decoded picking color\n  decodePickingColor(color) {\n    assert(color instanceof Uint8Array);\n    const [i1, i2, i3] = color;\n    // 1 was added to seperate from no selection\n    const index = i1 + i2 * 256 + i3 * 65536 - 1;\n    return index;\n  }\n  /** Deduces number of instances. Intention is to support:\n    - Explicit setting of numInstances\n    - Auto-deduction for ES6 containers that define a size member\n    - Auto-deduction for Classic Arrays via the built-in length attribute\n    - Auto-deduction via arrays */\n  getNumInstances() {\n    // First Check if app has provided an explicit value\n    if (Number.isFinite(this.props.numInstances)) {\n      return this.props.numInstances;\n    }\n    // Second check if the layer has set its own value\n    if (this.state && this.state.numInstances !== undefined) {\n      return this.state.numInstances;\n    }\n    // Use container library to get a count for any ES6 container or object\n    return count(this.props.data);\n  }\n  /** Buffer layout describes how many attribute values are packed for each data object\n      The default (null) is one value each object.\n      Some data formats (e.g. paths, polygons) have various length. Their buffer layout\n      is in the form of [L0, L1, L2, ...] */\n  getStartIndices() {\n    // First Check if startIndices is provided as an explicit value\n    if (this.props.startIndices) {\n      return this.props.startIndices;\n    }\n    // Second check if the layer has set its own value\n    if (this.state && this.state.startIndices) {\n      return this.state.startIndices;\n    }\n    return null;\n  }\n  // Default implementation\n  getBounds() {\n    return this.getAttributeManager()?.getBounds(['positions', 'instancePositions']);\n  }\n  getShaders(shaders) {\n    shaders = mergeShaders(shaders, {\n      disableWarnings: true,\n      modules: this.context.defaultShaderModules\n    });\n    for (const extension of this.props.extensions) {\n      shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));\n    }\n    return shaders;\n  }\n  /** Controls if updateState should be called. By default returns true if any prop has changed */\n  shouldUpdateState(params) {\n    return params.changeFlags.propsOrDataChanged;\n  }\n  /** Default implementation, all attributes will be invalidated and updated when data changes */\n  // eslint-disable-next-line complexity\n  updateState(params) {\n    const attributeManager = this.getAttributeManager();\n    const {\n      dataChanged\n    } = params.changeFlags;\n    if (dataChanged && attributeManager) {\n      if (Array.isArray(dataChanged)) {\n        // is partial update\n        for (const dataRange of dataChanged) {\n          attributeManager.invalidateAll(dataRange);\n        }\n      } else {\n        attributeManager.invalidateAll();\n      }\n    }\n    // Enable/disable picking buffer\n    if (attributeManager) {\n      const {\n        props\n      } = params;\n      const hasPickingBuffer = this.internalState.hasPickingBuffer;\n      const needsPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable || props.extensions.some(extension => extension.getNeedsPickingBuffer.call(this, extension));\n      // Only generate picking buffer if needed\n      if (hasPickingBuffer !== needsPickingBuffer) {\n        this.internalState.hasPickingBuffer = needsPickingBuffer;\n        const {\n          pickingColors,\n          instancePickingColors\n        } = attributeManager.attributes;\n        const pickingColorsAttribute = pickingColors || instancePickingColors;\n        if (pickingColorsAttribute) {\n          if (needsPickingBuffer && pickingColorsAttribute.constant) {\n            pickingColorsAttribute.constant = false;\n            attributeManager.invalidate(pickingColorsAttribute.id);\n          }\n          if (!pickingColorsAttribute.value && !needsPickingBuffer) {\n            pickingColorsAttribute.constant = true;\n            pickingColorsAttribute.value = [0, 0, 0];\n          }\n        }\n      }\n    }\n  }\n  /** Called once when layer is no longer matched and state will be discarded. Layers can destroy WebGL resources here. */\n  finalizeState(context) {\n    for (const model of this.getModels()) {\n      model.destroy();\n    }\n    const attributeManager = this.getAttributeManager();\n    if (attributeManager) {\n      attributeManager.finalize();\n    }\n    if (this.context) {\n      this.context.resourceManager.unsubscribe({\n        consumerId: this.id\n      });\n    }\n    if (this.internalState) {\n      this.internalState.uniformTransitions.clear();\n      this.internalState.finalize();\n    }\n  }\n  // If state has a model, draw it with supplied uniforms\n  draw(opts) {\n    for (const model of this.getModels()) {\n      model.draw(opts.renderPass);\n    }\n  }\n  // called to populate the info object that is passed to the event handler\n  // @return null to cancel event\n  getPickingInfo(_ref4) {\n    let {\n      info,\n      mode,\n      sourceLayer\n    } = _ref4;\n    const {\n      index\n    } = info;\n    if (index >= 0) {\n      // If props.data is an indexable array, get the object\n      if (Array.isArray(this.props.data)) {\n        info.object = this.props.data[index];\n      }\n    }\n    return info;\n  }\n  // END LIFECYCLE METHODS\n  // / INTERNAL METHODS - called by LayerManager, DeckRenderer and DeckPicker\n  /** (Internal) Propagate an error event through the system */\n  raiseError(error, message) {\n    if (message) {\n      // Duplicating error message for backward compatibility, see #7986\n      // TODO - revisit in v9\n      error = new Error(`${message}: ${error.message}`, {\n        cause: error\n      });\n    }\n    if (!this.props.onError?.(error)) {\n      this.context?.onError?.(error, this);\n    }\n  }\n  /** (Internal) Checks if this layer needs redraw */\n  getNeedsRedraw() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      clearRedrawFlags: false\n    };\n    return this._getNeedsRedraw(opts);\n  }\n  /** (Internal) Checks if this layer needs a deep update */\n  needsUpdate() {\n    if (!this.internalState) {\n      return false;\n    }\n    // Call subclass lifecycle method\n    return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());\n    // End lifecycle method\n  }\n  /** Checks if this layer has ongoing uniform transition */\n  hasUniformTransition() {\n    return this.internalState?.uniformTransitions.active || false;\n  }\n  /** Called when this layer is rendered into the given viewport */\n  activateViewport(viewport) {\n    if (!this.internalState) {\n      return;\n    }\n    const oldViewport = this.internalState.viewport;\n    this.internalState.viewport = viewport;\n    if (!oldViewport || !areViewportsEqual({\n      oldViewport,\n      viewport\n    })) {\n      this.setChangeFlags({\n        viewportChanged: true\n      });\n      if (this.isComposite) {\n        if (this.needsUpdate()) {\n          // Composite layers may add/remove sublayers on viewport change\n          // Because we cannot change the layers list during a draw cycle, we don't want to update sublayers right away\n          // This will not call update immediately, but mark the layerManager as needs update on the next frame\n          this.setNeedsUpdate();\n        }\n      } else {\n        this._update();\n      }\n    }\n  }\n  /** Default implementation of attribute invalidation, can be redefined */\n  invalidateAttribute() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';\n    const attributeManager = this.getAttributeManager();\n    if (!attributeManager) {\n      return;\n    }\n    if (name === 'all') {\n      attributeManager.invalidateAll();\n    } else {\n      attributeManager.invalidate(name);\n    }\n  }\n  /** Send updated attributes to the WebGL model */\n  updateAttributes(changedAttributes) {\n    // If some buffer layout changed\n    let bufferLayoutChanged = false;\n    for (const id in changedAttributes) {\n      if (changedAttributes[id].layoutChanged()) {\n        bufferLayoutChanged = true;\n      }\n    }\n    for (const model of this.getModels()) {\n      this._setModelAttributes(model, changedAttributes, bufferLayoutChanged);\n    }\n  }\n  /** Recalculate any attributes if needed */\n  _updateAttributes() {\n    const attributeManager = this.getAttributeManager();\n    if (!attributeManager) {\n      return;\n    }\n    const props = this.props;\n    // Figure out data length\n    const numInstances = this.getNumInstances();\n    const startIndices = this.getStartIndices();\n    attributeManager.update({\n      data: props.data,\n      numInstances,\n      startIndices,\n      props,\n      transitions: props.transitions,\n      // @ts-ignore (TS2339) property attribute is not present on some acceptable data types\n      buffers: props.data.attributes,\n      context: this\n    });\n    const changedAttributes = attributeManager.getChangedAttributes({\n      clearChangedFlags: true\n    });\n    this.updateAttributes(changedAttributes);\n  }\n  /** Update attribute transitions. This is called in drawLayer, no model updates required. */\n  _updateAttributeTransition() {\n    const attributeManager = this.getAttributeManager();\n    if (attributeManager) {\n      attributeManager.updateTransition();\n    }\n  }\n  /** Update uniform (prop) transitions. This is called in updateState, may result in model updates. */\n  _updateUniformTransition() {\n    // @ts-ignore (TS2339) internalState is alwasy defined when this method is called\n    const {\n      uniformTransitions\n    } = this.internalState;\n    if (uniformTransitions.active) {\n      // clone props\n      const propsInTransition = uniformTransitions.update();\n      const props = Object.create(this.props);\n      for (const key in propsInTransition) {\n        Object.defineProperty(props, key, {\n          value: propsInTransition[key]\n        });\n      }\n      return props;\n    }\n    return this.props;\n  }\n  /** Updater for the automatically populated instancePickingColors attribute */\n  calculateInstancePickingColors(attribute, _ref5) {\n    let {\n      numInstances\n    } = _ref5;\n    if (attribute.constant) {\n      return;\n    }\n    // calculateInstancePickingColors always generates the same sequence.\n    // pickingColorCache saves the largest generated sequence for reuse\n    const cacheSize = Math.floor(pickingColorCache.length / 4);\n    // Record when using the picking buffer cache, so that layers can always point at the most recently allocated cache\n    // @ts-ignore (TS2531) internalState is always defined when this method is called\n    this.internalState.usesPickingColorCache = true;\n    if (cacheSize < numInstances) {\n      if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {\n        log.warn('Layer has too many data objects. Picking might not be able to distinguish all objects.')();\n      }\n      pickingColorCache = typedArrayManager.allocate(pickingColorCache, numInstances, {\n        size: 4,\n        copy: true,\n        maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)\n      });\n      // If the attribute is larger than the cache, resize the cache and populate the missing chunk\n      const newCacheSize = Math.floor(pickingColorCache.length / 4);\n      const pickingColor = [0, 0, 0];\n      for (let i = cacheSize; i < newCacheSize; i++) {\n        this.encodePickingColor(i, pickingColor);\n        pickingColorCache[i * 4 + 0] = pickingColor[0];\n        pickingColorCache[i * 4 + 1] = pickingColor[1];\n        pickingColorCache[i * 4 + 2] = pickingColor[2];\n        pickingColorCache[i * 4 + 3] = 0;\n      }\n    }\n    attribute.value = pickingColorCache.subarray(0, numInstances * 4);\n  }\n  /** Apply changed attributes to model */\n  _setModelAttributes(model, changedAttributes) {\n    let bufferLayoutChanged = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!Object.keys(changedAttributes).length) {\n      return;\n    }\n    if (bufferLayoutChanged) {\n      // AttributeManager is always defined when this method is called\n      const attributeManager = this.getAttributeManager();\n      model.setBufferLayout(attributeManager.getBufferLayouts(model));\n      // All attributes must be reset after buffer layout change\n      changedAttributes = attributeManager.getAttributes();\n    }\n    // @ts-ignore luma.gl type issue\n    const excludeAttributes = model.userData?.excludeAttributes || {};\n    const attributeBuffers = {};\n    const constantAttributes = {};\n    for (const name in changedAttributes) {\n      if (excludeAttributes[name]) {\n        continue;\n      }\n      const values = changedAttributes[name].getValue();\n      for (const attributeName in values) {\n        const value = values[attributeName];\n        if (value instanceof Buffer) {\n          if (changedAttributes[name].settings.isIndexed) {\n            model.setIndexBuffer(value);\n          } else {\n            attributeBuffers[attributeName] = value;\n          }\n        } else if (value) {\n          constantAttributes[attributeName] = value;\n        }\n      }\n    }\n    // TODO - update buffer map?\n    model.setAttributes(attributeBuffers);\n    model.setConstantAttributes(constantAttributes);\n  }\n  /** (Internal) Sets the picking color at the specified index to null picking color. Used for multi-depth picking.\n     This method may be overriden by layer implementations */\n  disablePickingIndex(objectIndex) {\n    const data = this.props.data;\n    if (!('attributes' in data)) {\n      this._disablePickingIndex(objectIndex);\n      return;\n    }\n    // @ts-ignore (TS2531) this method is only called internally with attributeManager defined\n    const {\n      pickingColors,\n      instancePickingColors\n    } = this.getAttributeManager().attributes;\n    const colors = pickingColors || instancePickingColors;\n    const externalColorAttribute = colors && data.attributes && data.attributes[colors.id];\n    if (externalColorAttribute && externalColorAttribute.value) {\n      const values = externalColorAttribute.value;\n      const objectColor = this.encodePickingColor(objectIndex);\n      for (let index = 0; index < data.length; index++) {\n        const i = colors.getVertexOffset(index);\n        if (values[i] === objectColor[0] && values[i + 1] === objectColor[1] && values[i + 2] === objectColor[2]) {\n          this._disablePickingIndex(index);\n        }\n      }\n    } else {\n      this._disablePickingIndex(objectIndex);\n    }\n  }\n  // TODO - simplify subclassing interface\n  _disablePickingIndex(objectIndex) {\n    // @ts-ignore (TS2531) this method is only called internally with attributeManager defined\n    const {\n      pickingColors,\n      instancePickingColors\n    } = this.getAttributeManager().attributes;\n    const colors = pickingColors || instancePickingColors;\n    if (!colors) {\n      return;\n    }\n    const start = colors.getVertexOffset(objectIndex);\n    const end = colors.getVertexOffset(objectIndex + 1);\n    // Fill the sub buffer with 0s, 1 byte per element\n    colors.buffer.write(new Uint8Array(end - start), start);\n  }\n  /** (Internal) Re-enable all picking indices after multi-depth picking */\n  restorePickingColors() {\n    // @ts-ignore (TS2531) this method is only called internally with attributeManager defined\n    const {\n      pickingColors,\n      instancePickingColors\n    } = this.getAttributeManager().attributes;\n    const colors = pickingColors || instancePickingColors;\n    if (!colors) {\n      return;\n    }\n    // The picking color cache may have been freed and then reallocated. This ensures we read from the currently allocated cache.\n    if (\n    // @ts-ignore (TS2531) this method is only called internally with internalState defined\n    this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer) {\n      colors.value = pickingColorCache.subarray(0, colors.value.length);\n    }\n    colors.updateSubBuffer({\n      startOffset: 0\n    });\n  }\n  /* eslint-disable max-statements */\n  /* (Internal) Called by layer manager when a new layer is found */\n  _initialize() {\n    assert(!this.internalState); // finalized layer cannot be reused\n    assert(Number.isFinite(this.props.coordinateSystem)); // invalid coordinateSystem\n    debug(TRACE_INITIALIZE, this);\n    const attributeManager = this._getAttributeManager();\n    if (attributeManager) {\n      // All instanced layers get instancePickingColors attribute by default\n      // Their shaders can use it to render a picking scene\n      // TODO - this slightly slows down non instanced layers\n      attributeManager.addInstanced({\n        instancePickingColors: {\n          type: 'uint8',\n          size: 4,\n          noAlloc: true,\n          // Updaters are always called with `this` pointing to the layer\n          // eslint-disable-next-line @typescript-eslint/unbound-method\n          update: this.calculateInstancePickingColors\n        }\n      });\n    }\n    this.internalState = new LayerState({\n      attributeManager,\n      layer: this\n    });\n    this._clearChangeFlags(); // populate this.internalState.changeFlags\n    this.state = {};\n    // for backwards compatibility with older layers\n    // TODO - remove in next release\n    /* eslint-disable accessor-pairs */\n    Object.defineProperty(this.state, 'attributeManager', {\n      get: () => {\n        log.deprecated('layer.state.attributeManager', 'layer.getAttributeManager()')();\n        return attributeManager;\n      }\n    });\n    /* eslint-enable accessor-pairs */\n    this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);\n    this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);\n    // Ensure any async props are updated\n    this.internalState.setAsyncProps(this.props);\n    // Call subclass lifecycle methods\n    this.initializeState(this.context);\n    // Initialize extensions\n    for (const extension of this.props.extensions) {\n      extension.initializeState.call(this, this.context, extension);\n    }\n    // End subclass lifecycle methods\n    // initializeState callback tends to clear state\n    this.setChangeFlags({\n      dataChanged: 'init',\n      propsChanged: 'init',\n      viewportChanged: true,\n      extensionsChanged: true\n    });\n    this._update();\n  }\n  /** (Internal) Called by layer manager to transfer state from an old layer */\n  _transferState(oldLayer) {\n    debug(TRACE_MATCHED, this, this === oldLayer);\n    const {\n      state,\n      internalState\n    } = oldLayer;\n    if (this === oldLayer) {\n      return;\n    }\n    // Move internalState\n    this.internalState = internalState;\n    // Move state\n    this.state = state;\n    // We keep the state ref on old layers to support async actions\n    // oldLayer.state = null;\n    // Ensure any async props are updated\n    this.internalState.setAsyncProps(this.props);\n    this._diffProps(this.props, this.internalState.getOldProps());\n  }\n  /** (Internal) Called by layer manager when a new layer is added or an existing layer is matched with a new instance */\n  _update() {\n    // Call subclass lifecycle method\n    const stateNeedsUpdate = this.needsUpdate();\n    // End lifecycle method\n    debug(TRACE_UPDATE, this, stateNeedsUpdate);\n    if (!stateNeedsUpdate) {\n      return;\n    }\n    const currentProps = this.props;\n    const context = this.context;\n    const internalState = this.internalState;\n    const currentViewport = context.viewport;\n    const propsInTransition = this._updateUniformTransition();\n    internalState.propsInTransition = propsInTransition;\n    // Overwrite this.context.viewport during update to use the last activated viewport on this layer\n    // In multi-view applications, a layer may only be drawn in one of the views\n    // Which would make the \"active\" viewport different from the shared context\n    context.viewport = internalState.viewport || currentViewport;\n    // Overwrite this.props during update to use in-transition prop values\n    this.props = propsInTransition;\n    try {\n      const updateParams = this._getUpdateParams();\n      const oldModels = this.getModels();\n      // Safely call subclass lifecycle methods\n      if (context.device) {\n        this.updateState(updateParams);\n      } else {\n        try {\n          this.updateState(updateParams);\n        } catch (error) {\n          // ignore error if gl context is missing\n        }\n      }\n      // Execute extension updates\n      for (const extension of this.props.extensions) {\n        extension.updateState.call(this, updateParams, extension);\n      }\n      this.setNeedsRedraw();\n      // Check if attributes need recalculation\n      this._updateAttributes();\n      const modelChanged = this.getModels()[0] !== oldModels[0];\n      this._postUpdate(updateParams, modelChanged);\n      // End subclass lifecycle methods\n    } finally {\n      // Restore shared context\n      context.viewport = currentViewport;\n      this.props = currentProps;\n      this._clearChangeFlags();\n      internalState.needsUpdate = false;\n      internalState.resetOldProps();\n    }\n  }\n  /* eslint-enable max-statements */\n  /** (Internal) Called by manager when layer is about to be disposed\n      Note: not guaranteed to be called on application shutdown */\n  _finalize() {\n    debug(TRACE_FINALIZE, this);\n    // Call subclass lifecycle method\n    this.finalizeState(this.context);\n    // Finalize extensions\n    for (const extension of this.props.extensions) {\n      extension.finalizeState.call(this, this.context, extension);\n    }\n  }\n  // Calculates uniforms\n  _drawLayer(_ref6) {\n    let {\n      renderPass,\n      shaderModuleProps = null,\n      uniforms = {},\n      parameters = {}\n    } = _ref6;\n    this._updateAttributeTransition();\n    const currentProps = this.props;\n    const context = this.context;\n    // Overwrite this.props during redraw to use in-transition prop values\n    // `internalState.propsInTransition` could be missing if `updateState` failed\n    // @ts-ignore (TS2339) internalState is alwasy defined when this method is called\n    this.props = this.internalState.propsInTransition || currentProps;\n    try {\n      // TODO/ib - hack move to luma Model.draw\n      if (shaderModuleProps) {\n        this.setShaderModuleProps(shaderModuleProps);\n      }\n      // Apply polygon offset to avoid z-fighting\n      // TODO - move to draw-layers\n      const {\n        getPolygonOffset\n      } = this.props;\n      const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];\n      if (context.device instanceof WebGLDevice) {\n        context.device.setParametersWebGL({\n          polygonOffset: offsets\n        });\n      }\n      for (const model of this.getModels()) {\n        if (model.device.type === 'webgpu') {\n          // TODO(ibgreen): model.setParameters currently wipes parameters. Semantics TBD.\n          model.setParameters({\n            ...model.parameters,\n            ...parameters\n          });\n        } else {\n          model.setParameters(parameters);\n        }\n      }\n      // Call subclass lifecycle method\n      if (context.device instanceof WebGLDevice) {\n        context.device.withParametersWebGL(parameters, () => {\n          const opts = {\n            renderPass,\n            shaderModuleProps,\n            uniforms,\n            parameters,\n            context\n          };\n          // extensions\n          for (const extension of this.props.extensions) {\n            extension.draw.call(this, opts, extension);\n          }\n          this.draw(opts);\n        });\n      } else {\n        const opts = {\n          renderPass,\n          shaderModuleProps,\n          uniforms,\n          parameters,\n          context\n        };\n        // extensions\n        for (const extension of this.props.extensions) {\n          extension.draw.call(this, opts, extension);\n        }\n        this.draw(opts);\n      }\n    } finally {\n      this.props = currentProps;\n    }\n    // End lifecycle method\n  }\n  // Helper methods\n  /** Returns the current change flags */\n  getChangeFlags() {\n    return this.internalState?.changeFlags;\n  }\n  /* eslint-disable complexity */\n  /** Dirty some change flags, will be handled by updateLayer */\n  setChangeFlags(flags) {\n    if (!this.internalState) {\n      return;\n    }\n    const {\n      changeFlags\n    } = this.internalState;\n    /* eslint-disable no-fallthrough, max-depth */\n    for (const key in flags) {\n      if (flags[key]) {\n        let flagChanged = false;\n        switch (key) {\n          case 'dataChanged':\n            // changeFlags.dataChanged may be `false`, a string (reason) or an array of ranges\n            const dataChangedReason = flags[key];\n            const prevDataChangedReason = changeFlags[key];\n            if (dataChangedReason && Array.isArray(prevDataChangedReason)) {\n              // Merge partial updates\n              changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;\n              flagChanged = true;\n            }\n          default:\n            if (!changeFlags[key]) {\n              changeFlags[key] = flags[key];\n              flagChanged = true;\n            }\n        }\n        if (flagChanged) {\n          debug(TRACE_CHANGE_FLAG, this, key, flags);\n        }\n      }\n    }\n    /* eslint-enable no-fallthrough, max-depth */\n    // Update composite flags\n    const propsOrDataChanged = Boolean(changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged);\n    changeFlags.propsOrDataChanged = propsOrDataChanged;\n    changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;\n  }\n  /* eslint-enable complexity */\n  /** Clear all changeFlags, typically after an update */\n  _clearChangeFlags() {\n    // @ts-ignore TS2531 this method can only be called internally with internalState assigned\n    this.internalState.changeFlags = {\n      dataChanged: false,\n      propsChanged: false,\n      updateTriggersChanged: false,\n      viewportChanged: false,\n      stateChanged: false,\n      extensionsChanged: false,\n      propsOrDataChanged: false,\n      somethingChanged: false\n    };\n  }\n  /** Compares the layers props with old props from a matched older layer\n      and extracts change flags that describe what has change so that state\n      can be update correctly with minimal effort */\n  _diffProps(newProps, oldProps) {\n    const changeFlags = diffProps(newProps, oldProps);\n    // iterate over changedTriggers\n    if (changeFlags.updateTriggersChanged) {\n      for (const key in changeFlags.updateTriggersChanged) {\n        if (changeFlags.updateTriggersChanged[key]) {\n          this.invalidateAttribute(key);\n        }\n      }\n    }\n    // trigger uniform transitions\n    if (changeFlags.transitionsChanged) {\n      for (const key in changeFlags.transitionsChanged) {\n        // prop changed and transition is enabled\n        // @ts-ignore (TS2531) internalState is always defined when this method is called\n        this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], newProps.transitions?.[key]);\n      }\n    }\n    return this.setChangeFlags(changeFlags);\n  }\n  /** (Internal) called by layer manager to perform extra props validation (in development only) */\n  validateProps() {\n    validateProps(this.props);\n  }\n  /** (Internal) Called by deck picker when the hovered object changes to update the auto highlight */\n  updateAutoHighlight(info) {\n    if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) {\n      this._updateAutoHighlight(info);\n    }\n  }\n  // May be overriden by subclasses\n  // TODO - simplify subclassing interface\n  /** Update picking module parameters to highlight the hovered object */\n  _updateAutoHighlight(info) {\n    const picking = {\n      // @ts-ignore\n      highlightedObjectColor: info.picked ? info.color : null\n    };\n    const {\n      highlightColor\n    } = this.props;\n    if (info.picked && typeof highlightColor === 'function') {\n      // @ts-ignore\n      picking.highlightColor = highlightColor(info);\n    }\n    this.setShaderModuleProps({\n      picking\n    });\n    // setShaderModuleProps does not trigger redraw\n    this.setNeedsRedraw();\n  }\n  /** Create new attribute manager */\n  _getAttributeManager() {\n    const context = this.context;\n    return new AttributeManager(context.device, {\n      id: this.props.id,\n      stats: context.stats,\n      timeline: context.timeline\n    });\n  }\n  // Private methods\n  /** Called after updateState to perform common tasks */\n  _postUpdate(updateParams, forceUpdate) {\n    const {\n      props,\n      oldProps\n    } = updateParams;\n    // Note: Automatic instance count update only works for single layers\n    const model = this.state.model;\n    if (model?.isInstanced) {\n      model.setInstanceCount(this.getNumInstances());\n    }\n    // Set picking module parameters to match props\n    const {\n      autoHighlight,\n      highlightedObjectIndex,\n      highlightColor\n    } = props;\n    if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {\n      const picking = {};\n      if (Array.isArray(highlightColor)) {\n        picking.highlightColor = highlightColor;\n      }\n      // highlightedObjectIndex will overwrite any settings from auto highlighting.\n      // Do not reset unless the value has changed.\n      if (forceUpdate || oldProps.autoHighlight !== autoHighlight || highlightedObjectIndex !== oldProps.highlightedObjectIndex) {\n        picking.highlightedObjectColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;\n      }\n      this.setShaderModuleProps({\n        picking\n      });\n    }\n  }\n  _getUpdateParams() {\n    return {\n      props: this.props,\n      // @ts-ignore TS2531 this method can only be called internally with internalState assigned\n      oldProps: this.internalState.getOldProps(),\n      context: this.context,\n      // @ts-ignore TS2531 this method can only be called internally with internalState assigned\n      changeFlags: this.internalState.changeFlags\n    };\n  }\n  /** Checks state of attributes and model */\n  _getNeedsRedraw(opts) {\n    // this method may be called by the render loop as soon a the layer\n    // has been created, so guard against uninitialized state\n    if (!this.internalState) {\n      return false;\n    }\n    let redraw = false;\n    redraw = redraw || this.internalState.needsRedraw && this.id;\n    // TODO - is attribute manager needed? - Model should be enough.\n    const attributeManager = this.getAttributeManager();\n    const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;\n    redraw = redraw || attributeManagerNeedsRedraw;\n    if (redraw) {\n      for (const extension of this.props.extensions) {\n        extension.onNeedsRedraw.call(this, extension);\n      }\n    }\n    this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;\n    return redraw;\n  }\n  /** Callback when asyn prop is loaded */\n  _onAsyncPropUpdated() {\n    // @ts-ignore TS2531 this method can only be called internally with internalState assigned\n    this._diffProps(this.props, this.internalState.getOldProps());\n    this.setNeedsUpdate();\n  }\n}\nLayer.defaultProps = defaultProps;\nLayer.layerName = 'Layer';\nexport default Layer;\n//# sourceMappingURL=layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}