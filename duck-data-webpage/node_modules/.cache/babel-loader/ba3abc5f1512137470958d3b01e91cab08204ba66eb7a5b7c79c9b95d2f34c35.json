{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n// Note: This class is still an experimental export, mainly used by other test cases\n// - It has not been fully adapted to math.gl conventions\n// - Documentation has not been ported\nimport { Vector3, Matrix4, assert } from '@math.gl/core';\nimport { CullingVolume } from \"./culling-volume.js\";\nimport { Plane } from \"./plane.js\";\nconst scratchPlaneUpVector = new Vector3();\nconst scratchPlaneRightVector = new Vector3();\nconst scratchPlaneNearCenter = new Vector3();\nconst scratchPlaneFarCenter = new Vector3();\nconst scratchPlaneNormal = new Vector3();\nexport class PerspectiveOffCenterFrustum {\n  /**\n   * The viewing frustum is defined by 6 planes.\n   * Each plane is represented by a {@link Vector4} object, where the x, y, and z components\n   * define the unit vector normal to the plane, and the w component is the distance of the\n   * plane from the origin/camera position.\n   *\n   * @alias PerspectiveOffCenterFrustum\n   *\n   * @example\n   * const frustum = new PerspectiveOffCenterFrustum({\n   *     left : -1.0,\n   *     right : 1.0,\n   *     top : 1.0,\n   *     bottom : -1.0,\n   *     near : 1.0,\n   *     far : 100.0\n   * });\n   *\n   * @see PerspectiveFrustum\n   */\n  constructor(options = {}) {\n    this._cullingVolume = new CullingVolume([new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()]);\n    this._perspectiveMatrix = new Matrix4();\n    this._infinitePerspective = new Matrix4();\n    const {\n      near = 1.0,\n      far = 500000000.0\n    } = options;\n    this.left = options.left;\n    this._left = undefined;\n    this.right = options.right;\n    this._right = undefined;\n    this.top = options.top;\n    this._top = undefined;\n    this.bottom = options.bottom;\n    this._bottom = undefined;\n    this.near = near;\n    this._near = near;\n    this.far = far;\n    this._far = far;\n  }\n  /**\n   * Returns a duplicate of a PerspectiveOffCenterFrustum instance.\n   * @returns {PerspectiveOffCenterFrustum} A new PerspectiveFrustum instance.\n   * */\n  clone() {\n    return new PerspectiveOffCenterFrustum({\n      right: this.right,\n      left: this.left,\n      top: this.top,\n      bottom: this.bottom,\n      near: this.near,\n      far: this.far\n    });\n  }\n  /**\n   * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n   * <code>true</code> if they are equal, <code>false</code> otherwise.\n   *\n   * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n   */\n  equals(other) {\n    return other && other instanceof PerspectiveOffCenterFrustum && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far;\n  }\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   *\n   * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix\n   */\n  get projectionMatrix() {\n    this._update();\n    return this._perspectiveMatrix;\n  }\n  /**\n   * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   *\n   * @see PerspectiveOffCenterFrustum#projectionMatrix\n   */\n  get infiniteProjectionMatrix() {\n    this._update();\n    return this._infinitePerspective;\n  }\n  /**\n   * Creates a culling volume for this frustum.\n   * @returns {CullingVolume} A culling volume at the given position and orientation.\n   *\n   * @example\n   * // Check if a bounding volume intersects the frustum.\n   * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n   * const intersect = cullingVolume.computeVisibility(boundingVolume);\n   */\n  // eslint-disable-next-line complexity, max-statements\n  computeCullingVolume(/** A Vector3 defines the eye position. */\n  position, /** A Vector3 defines the view direction. */\n  direction, /** A Vector3 defines the up direction. */\n  up) {\n    assert(position, 'position is required.');\n    assert(direction, 'direction is required.');\n    assert(up, 'up is required.');\n    const planes = this._cullingVolume.planes;\n    up = scratchPlaneUpVector.copy(up).normalize();\n    const right = scratchPlaneRightVector.copy(direction).cross(up).normalize();\n    const nearCenter = scratchPlaneNearCenter.copy(direction).multiplyByScalar(this.near).add(position);\n    const farCenter = scratchPlaneFarCenter.copy(direction).multiplyByScalar(this.far).add(position);\n    let normal = scratchPlaneNormal;\n    // Left plane computation\n    normal.copy(right).multiplyByScalar(this.left).add(nearCenter).subtract(position).cross(up);\n    planes[0].fromPointNormal(position, normal);\n    // Right plane computation\n    normal.copy(right).multiplyByScalar(this.right).add(nearCenter).subtract(position).cross(up).negate();\n    planes[1].fromPointNormal(position, normal);\n    // Bottom plane computation\n    normal.copy(up).multiplyByScalar(this.bottom).add(nearCenter).subtract(position).cross(right).negate();\n    planes[2].fromPointNormal(position, normal);\n    // Top plane computation\n    normal.copy(up).multiplyByScalar(this.top).add(nearCenter).subtract(position).cross(right);\n    planes[3].fromPointNormal(position, normal);\n    normal = new Vector3().copy(direction);\n    // Near plane computation\n    planes[4].fromPointNormal(nearCenter, normal);\n    // Far plane computation\n    normal.negate();\n    planes[5].fromPointNormal(farCenter, normal);\n    return this._cullingVolume;\n  }\n  /**\n   * Returns the pixel's width and height in meters.\n   *\n   * @returns {Vector2} The modified result parameter or a new instance of {@link Vector2} with the pixel's width and height in the x and y properties, respectively.\n   *\n   * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n   * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n   *\n   * @example\n   * // Example 1\n   * // Get the width and height of a pixel.\n   * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, new Vector2());\n   *\n   * @example\n   * // Example 2\n   * // Get the width and height of a pixel if the near plane was set to 'distance'.\n   * // For example, get the size of a pixel of an image on a billboard.\n   * const position = camera.position;\n   * const direction = camera.direction;\n   * const toCenter = Vector3.subtract(primitive.boundingVolume.center, position, new Vector3());      // vector from camera to a primitive\n   * const toCenterProj = Vector3.multiplyByScalar(direction, Vector3.dot(direction, toCenter), new Vector3()); // project vector onto camera direction vector\n   * const distance = Vector3.magnitude(toCenterProj);\n   * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, new Vector2());\n   */\n  getPixelDimensions(/** The width of the drawing buffer. */\n  drawingBufferWidth, /** The height of the drawing buffer. */\n  drawingBufferHeight, /** The distance to the near plane in meters. */\n  distance, /** The object onto which to store the result. */\n  result) {\n    this._update();\n    assert(Number.isFinite(drawingBufferWidth) && Number.isFinite(drawingBufferHeight));\n    // 'Both drawingBufferWidth and drawingBufferHeight are required.'\n    assert(drawingBufferWidth > 0);\n    // 'drawingBufferWidth must be greater than zero.'\n    assert(drawingBufferHeight > 0);\n    // 'drawingBufferHeight must be greater than zero.'\n    assert(distance > 0);\n    // 'distance is required.');\n    assert(result);\n    // 'A result object is required.');\n    const inverseNear = 1.0 / this.near;\n    let tanTheta = this.top * inverseNear;\n    const pixelHeight = 2.0 * distance * tanTheta / drawingBufferHeight;\n    tanTheta = this.right * inverseNear;\n    const pixelWidth = 2.0 * distance * tanTheta / drawingBufferWidth;\n    result.x = pixelWidth;\n    result.y = pixelHeight;\n    return result;\n  }\n  // eslint-disable-next-line complexity, max-statements\n  _update() {\n    assert(Number.isFinite(this.right) && Number.isFinite(this.left) && Number.isFinite(this.top) && Number.isFinite(this.bottom) && Number.isFinite(this.near) && Number.isFinite(this.far));\n    // throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');\n    const {\n      top,\n      bottom,\n      right,\n      left,\n      near,\n      far\n    } = this;\n    if (top !== this._top || bottom !== this._bottom || left !== this._left || right !== this._right || near !== this._near || far !== this._far) {\n      assert(this.near > 0 && this.near < this.far, 'near must be greater than zero and less than far.');\n      this._left = left;\n      this._right = right;\n      this._top = top;\n      this._bottom = bottom;\n      this._near = near;\n      this._far = far;\n      this._perspectiveMatrix = new Matrix4().frustum({\n        left,\n        right,\n        bottom,\n        top,\n        near,\n        far\n      });\n      this._infinitePerspective = new Matrix4().frustum({\n        left,\n        right,\n        bottom,\n        top,\n        near,\n        far: Infinity\n      });\n    }\n  }\n}","map":{"version":3,"names":["Vector3","Matrix4","assert","CullingVolume","Plane","scratchPlaneUpVector","scratchPlaneRightVector","scratchPlaneNearCenter","scratchPlaneFarCenter","scratchPlaneNormal","PerspectiveOffCenterFrustum","constructor","options","_cullingVolume","_perspectiveMatrix","_infinitePerspective","near","far","left","_left","undefined","right","_right","top","_top","bottom","_bottom","_near","_far","clone","equals","other","projectionMatrix","_update","infiniteProjectionMatrix","computeCullingVolume","position","direction","up","planes","copy","normalize","cross","nearCenter","multiplyByScalar","add","farCenter","normal","subtract","fromPointNormal","negate","getPixelDimensions","drawingBufferWidth","drawingBufferHeight","distance","result","Number","isFinite","inverseNear","tanTheta","pixelHeight","pixelWidth","x","y","frustum","Infinity"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\culling\\src\\lib\\perspective-off-center-frustum.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n// Note: This class is still an experimental export, mainly used by other test cases\n// - It has not been fully adapted to math.gl conventions\n// - Documentation has not been ported\n\nimport {Vector3, Vector2, Matrix4, assert, NumericArray} from '@math.gl/core';\nimport {CullingVolume} from './culling-volume';\nimport {Plane} from './plane';\n\nconst scratchPlaneUpVector = new Vector3();\nconst scratchPlaneRightVector = new Vector3();\nconst scratchPlaneNearCenter = new Vector3();\nconst scratchPlaneFarCenter = new Vector3();\nconst scratchPlaneNormal = new Vector3();\n\ntype PerspectiveOffCenterFrustumOptions = {\n  left?: number;\n  right?: number;\n  top?: number;\n  bottom?: number;\n  near?: number;\n  far?: number;\n};\n\nexport class PerspectiveOffCenterFrustum {\n  /**\n   * Defines the left clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  left?: number;\n  private _left?: number;\n  /**\n   * Defines the right clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  right?: number;\n  private _right?: number;\n  /**\n   * Defines the top clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  top?: number;\n  private _top?: number;\n  /**\n   * Defines the bottom clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  bottom?: number;\n  private _bottom?: number;\n  /**\n   * The distance of the near plane.\n   * @type {Number}\n   * @default 1.0\n   */\n  near: number;\n  private _near: number;\n  /**\n   * The distance of the far plane.\n   * @type {Number}\n   * @default 500000000.0\n   */\n  far: number;\n  private _far: number;\n\n  private _cullingVolume = new CullingVolume([\n    new Plane(),\n    new Plane(),\n    new Plane(),\n    new Plane(),\n    new Plane(),\n    new Plane()\n  ]);\n  private _perspectiveMatrix = new Matrix4();\n  private _infinitePerspective = new Matrix4();\n\n  /**\n   * The viewing frustum is defined by 6 planes.\n   * Each plane is represented by a {@link Vector4} object, where the x, y, and z components\n   * define the unit vector normal to the plane, and the w component is the distance of the\n   * plane from the origin/camera position.\n   *\n   * @alias PerspectiveOffCenterFrustum\n   *\n   * @example\n   * const frustum = new PerspectiveOffCenterFrustum({\n   *     left : -1.0,\n   *     right : 1.0,\n   *     top : 1.0,\n   *     bottom : -1.0,\n   *     near : 1.0,\n   *     far : 100.0\n   * });\n   *\n   * @see PerspectiveFrustum\n   */\n  constructor(options: PerspectiveOffCenterFrustumOptions = {}) {\n    const {near = 1.0, far = 500000000.0} = options;\n\n    this.left = options.left;\n    this._left = undefined;\n\n    this.right = options.right;\n    this._right = undefined;\n\n    this.top = options.top;\n    this._top = undefined;\n\n    this.bottom = options.bottom;\n    this._bottom = undefined;\n\n    this.near = near;\n    this._near = near;\n\n    this.far = far;\n    this._far = far;\n  }\n\n  /**\n   * Returns a duplicate of a PerspectiveOffCenterFrustum instance.\n   * @returns {PerspectiveOffCenterFrustum} A new PerspectiveFrustum instance.\n   * */\n  clone(): PerspectiveOffCenterFrustum {\n    return new PerspectiveOffCenterFrustum({\n      right: this.right,\n      left: this.left,\n      top: this.top,\n      bottom: this.bottom,\n      near: this.near,\n      far: this.far\n    });\n  }\n\n  /**\n   * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n   * <code>true</code> if they are equal, <code>false</code> otherwise.\n   *\n   * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n   */\n  equals(other: PerspectiveOffCenterFrustum): boolean {\n    return (\n      other &&\n      other instanceof PerspectiveOffCenterFrustum &&\n      this.right === other.right &&\n      this.left === other.left &&\n      this.top === other.top &&\n      this.bottom === other.bottom &&\n      this.near === other.near &&\n      this.far === other.far\n    );\n  }\n\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   *\n   * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix\n   */\n  get projectionMatrix(): Matrix4 {\n    this._update();\n    return this._perspectiveMatrix;\n  }\n\n  /**\n   * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   *\n   * @see PerspectiveOffCenterFrustum#projectionMatrix\n   */\n  get infiniteProjectionMatrix(): Matrix4 {\n    this._update();\n    return this._infinitePerspective;\n  }\n\n  /**\n   * Creates a culling volume for this frustum.\n   * @returns {CullingVolume} A culling volume at the given position and orientation.\n   *\n   * @example\n   * // Check if a bounding volume intersects the frustum.\n   * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n   * const intersect = cullingVolume.computeVisibility(boundingVolume);\n   */\n  // eslint-disable-next-line complexity, max-statements\n  computeCullingVolume(\n    /** A Vector3 defines the eye position. */\n    position: Readonly<NumericArray>,\n    /** A Vector3 defines the view direction. */\n    direction: Readonly<NumericArray>,\n    /** A Vector3 defines the up direction. */\n    up: Readonly<NumericArray>\n  ): CullingVolume {\n    assert(position, 'position is required.');\n    assert(direction, 'direction is required.');\n    assert(up, 'up is required.');\n\n    const planes = this._cullingVolume.planes;\n\n    up = scratchPlaneUpVector.copy(up).normalize();\n    const right = scratchPlaneRightVector.copy(direction).cross(up).normalize();\n\n    const nearCenter = scratchPlaneNearCenter\n      .copy(direction)\n      .multiplyByScalar(this.near)\n      .add(position);\n\n    const farCenter = scratchPlaneFarCenter\n      .copy(direction)\n      .multiplyByScalar(this.far)\n      .add(position);\n\n    let normal = scratchPlaneNormal;\n\n    // Left plane computation\n    normal.copy(right).multiplyByScalar(this.left).add(nearCenter).subtract(position).cross(up);\n\n    planes[0].fromPointNormal(position, normal);\n\n    // Right plane computation\n    normal\n      .copy(right)\n      .multiplyByScalar(this.right)\n      .add(nearCenter)\n      .subtract(position)\n      .cross(up)\n      .negate();\n\n    planes[1].fromPointNormal(position, normal);\n\n    // Bottom plane computation\n    normal\n      .copy(up)\n      .multiplyByScalar(this.bottom)\n      .add(nearCenter)\n      .subtract(position)\n      .cross(right)\n      .negate();\n\n    planes[2].fromPointNormal(position, normal);\n\n    // Top plane computation\n    normal.copy(up).multiplyByScalar(this.top).add(nearCenter).subtract(position).cross(right);\n\n    planes[3].fromPointNormal(position, normal);\n\n    normal = new Vector3().copy(direction);\n\n    // Near plane computation\n    planes[4].fromPointNormal(nearCenter, normal);\n\n    // Far plane computation\n    normal.negate();\n\n    planes[5].fromPointNormal(farCenter, normal);\n\n    return this._cullingVolume;\n  }\n\n  /**\n   * Returns the pixel's width and height in meters.\n   *\n   * @returns {Vector2} The modified result parameter or a new instance of {@link Vector2} with the pixel's width and height in the x and y properties, respectively.\n   *\n   * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n   * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n   *\n   * @example\n   * // Example 1\n   * // Get the width and height of a pixel.\n   * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, new Vector2());\n   *\n   * @example\n   * // Example 2\n   * // Get the width and height of a pixel if the near plane was set to 'distance'.\n   * // For example, get the size of a pixel of an image on a billboard.\n   * const position = camera.position;\n   * const direction = camera.direction;\n   * const toCenter = Vector3.subtract(primitive.boundingVolume.center, position, new Vector3());      // vector from camera to a primitive\n   * const toCenterProj = Vector3.multiplyByScalar(direction, Vector3.dot(direction, toCenter), new Vector3()); // project vector onto camera direction vector\n   * const distance = Vector3.magnitude(toCenterProj);\n   * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, new Vector2());\n   */\n  getPixelDimensions(\n    /** The width of the drawing buffer. */\n    drawingBufferWidth: number,\n    /** The height of the drawing buffer. */\n    drawingBufferHeight: number,\n    /** The distance to the near plane in meters. */\n    distance: number,\n    /** The object onto which to store the result. */\n    result: Vector2\n  ): Vector2 {\n    this._update();\n\n    assert(Number.isFinite(drawingBufferWidth) && Number.isFinite(drawingBufferHeight));\n    // 'Both drawingBufferWidth and drawingBufferHeight are required.'\n    assert(drawingBufferWidth > 0);\n    // 'drawingBufferWidth must be greater than zero.'\n    assert(drawingBufferHeight > 0);\n    // 'drawingBufferHeight must be greater than zero.'\n    assert(distance > 0);\n    // 'distance is required.');\n    assert(result);\n    // 'A result object is required.');\n\n    const inverseNear = 1.0 / this.near;\n    let tanTheta = this.top * inverseNear;\n    const pixelHeight = (2.0 * distance * tanTheta) / drawingBufferHeight;\n    tanTheta = this.right * inverseNear;\n    const pixelWidth = (2.0 * distance * tanTheta) / drawingBufferWidth;\n\n    result.x = pixelWidth;\n    result.y = pixelHeight;\n    return result;\n  }\n\n  // eslint-disable-next-line complexity, max-statements\n  private _update() {\n    assert(\n      Number.isFinite(this.right) &&\n        Number.isFinite(this.left) &&\n        Number.isFinite(this.top) &&\n        Number.isFinite(this.bottom) &&\n        Number.isFinite(this.near) &&\n        Number.isFinite(this.far)\n    );\n    // throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');\n\n    const {top, bottom, right, left, near, far} = this;\n\n    if (\n      top !== this._top ||\n      bottom !== this._bottom ||\n      left !== this._left ||\n      right !== this._right ||\n      near !== this._near ||\n      far !== this._far\n    ) {\n      assert(\n        this.near > 0 && this.near < this.far,\n        'near must be greater than zero and less than far.'\n      );\n\n      this._left = left;\n      this._right = right;\n      this._top = top;\n      this._bottom = bottom;\n      this._near = near;\n      this._far = far;\n      this._perspectiveMatrix = new Matrix4().frustum({\n        left,\n        right,\n        bottom,\n        top,\n        near,\n        far\n      });\n      this._infinitePerspective = new Matrix4().frustum({\n        left,\n        right,\n        bottom,\n        top,\n        near,\n        far: Infinity\n      });\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}