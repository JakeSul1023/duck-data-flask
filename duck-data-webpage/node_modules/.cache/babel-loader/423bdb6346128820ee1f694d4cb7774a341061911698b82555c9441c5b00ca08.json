{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { decodeVertexType } from \"./decode-data-type.js\";\nimport { getTextureFormatDefinition } from \"./texture-format-table.js\";\n// prettier-ignore\nconst COMPRESSED_TEXTURE_FORMAT_PREFIXES = ['bc1', 'bc2', 'bc3', 'bc4', 'bc5', 'bc6', 'bc7', 'etc1', 'etc2', 'eac', 'atc', 'astc', 'pvrtc'];\nconst RGB_FORMAT_REGEX = /^(r|rg|rgb|rgba|bgra)([0-9]*)([a-z]*)(-srgb)?(-webgl)?$/;\n/**\n * Returns true if a texture format is GPU compressed\n */\nexport function isTextureFormatCompressed(format) {\n  return COMPRESSED_TEXTURE_FORMAT_PREFIXES.some(prefix => format.startsWith(prefix));\n}\n/**\n * Decodes a texture format, returning e.g. attatchment type, components, byte length and flags (integer, signed, normalized)\n */\nexport function decodeTextureFormat(format) {\n  let formatInfo = decodeTextureFormatUsingTable(format);\n  if (isTextureFormatCompressed(format)) {\n    formatInfo.channels = 'rgb';\n    formatInfo.components = 3;\n    formatInfo.bytesPerPixel = 1;\n    formatInfo.srgb = false;\n    formatInfo.compressed = true;\n    const blockSize = getCompressedTextureBlockSize(format);\n    if (blockSize) {\n      formatInfo.blockWidth = blockSize.blockWidth;\n      formatInfo.blockHeight = blockSize.blockHeight;\n    }\n  }\n  // Fill in missing information that can be derived from the format string\n  const matches = RGB_FORMAT_REGEX.exec(format);\n  if (matches) {\n    const [, channels, length, type, srgb, suffix] = matches;\n    const dataType = `${type}${length}`;\n    const decodedType = decodeVertexType(dataType);\n    const bits = decodedType.byteLength * 8;\n    const components = channels.length;\n    const bitsPerChannel = [bits, components >= 2 ? bits : 0, components >= 3 ? bits : 0, components >= 4 ? bits : 0];\n    formatInfo = {\n      format,\n      attachment: formatInfo.attachment,\n      dataType: decodedType.dataType,\n      components,\n      channels: channels,\n      integer: decodedType.integer,\n      signed: decodedType.signed,\n      normalized: decodedType.normalized,\n      bitsPerChannel,\n      bytesPerPixel: decodedType.byteLength * channels.length,\n      packed: formatInfo.packed,\n      srgb: formatInfo.srgb\n    };\n    if (suffix === '-webgl') {\n      formatInfo.webgl = true;\n    }\n    // dataType - overwritten by decodedType\n    if (srgb === '-srgb') {\n      formatInfo.srgb = true;\n    }\n  }\n  if (format.endsWith('-webgl')) {\n    formatInfo.webgl = true;\n  }\n  if (format.endsWith('-srgb')) {\n    formatInfo.srgb = true;\n  }\n  return formatInfo;\n}\n/** Decode texture format info from the table */\nfunction decodeTextureFormatUsingTable(format) {\n  const info = getTextureFormatDefinition(format);\n  const bytesPerPixel = info.bytesPerPixel || 1;\n  const bitsPerChannel = info.bitsPerChannel || [8, 8, 8, 8];\n  delete info.bitsPerChannel;\n  delete info.bytesPerPixel;\n  delete info.f;\n  delete info.render;\n  delete info.filter;\n  delete info.blend;\n  delete info.store;\n  const formatInfo = {\n    ...info,\n    format,\n    attachment: info.attachment || 'color',\n    channels: info.channels || 'r',\n    components: info.components || info.channels?.length || 1,\n    bytesPerPixel,\n    bitsPerChannel,\n    dataType: info.dataType || 'uint8',\n    srgb: info.srgb ?? false,\n    packed: info.packed ?? false,\n    webgl: info.webgl ?? false,\n    integer: info.integer ?? false,\n    signed: info.signed ?? false,\n    normalized: info.normalized ?? false,\n    compressed: info.compressed ?? false\n  };\n  return formatInfo;\n}\n/** Parses ASTC block widths from format string */\nfunction getCompressedTextureBlockSize(format) {\n  const REGEX = /.*-(\\d+)x(\\d+)-.*/;\n  const matches = REGEX.exec(format);\n  if (matches) {\n    const [, blockWidth, blockHeight] = matches;\n    return {\n      blockWidth: Number(blockWidth),\n      blockHeight: Number(blockHeight)\n    };\n  }\n  return null;\n}\n/*\n'r8unorm':\t{s: \"float\"}, // \t✓\t✓\t✓\t},\n'r8snorm':\t{s: \"float\"}, // \t\t✓\t\t},\n'r8uint':\t{s: \"uint\"}, // \t✓\t✓\t\t},\n'r8sint':\t{s: \"sint\"}, // \t✓\t✓\t\t},\n'rg8unorm':\t{s: \"float\"}, // \t✓\t✓\t✓\t},\n'rg8snorm':\t{s: \"float\"}, // \t\t✓\t\t},\n'rg8uint':\t{s: \"uint\"}, // \t✓\t✓\t\t},\n'rg8sint':\t{s: \"sint\"}, // \t✓\t✓\t\t},\n'rgba8unorm':\t{s: \"float\"}, // \t✓\t✓\t✓\t✓},\n'rgba8unorm-srgb': {s: \"float\"}, // \t✓\t✓\t✓\t},\n'rgba8snorm':\t{s: \"float\"}, // \t\t✓\t\t✓},\n'rgba8uint':\t{s: \"uint\"}, // \t✓\t✓\t\t✓},\n'rgba8sint':\t{s: \"sint\"}, // \t✓\t✓\t\t✓},\n'bgra8unorm':\t{s: \"float\"}, // \t✓\t✓\t✓\t},\n'bgra8unorm-srgb': {s: \"float\"}, // \t✓\t✓\t✓\t},\n// 16-bit per component\n'r16uint': {s: \"uint\"}, // \t✓\t✓\t\t},\n'r16sint': {s: \"sint\"}, // \t✓\t✓\t\t},\n'r16float': {s: \"float\"}, // \t✓\t✓\t✓\t},\n'rg16uint': {s: \"uint\"}, // \t✓\t✓\t\t},\n'rg16sint': {s: \"sint\"}, // \t✓\t✓\t\t},\n'rg16float': {s: \"float\"}, // \t✓\t✓\t✓\t},\n'rgba16uint': {s: \"uint\"}, // \t✓\t✓\t\t✓},\n'rgba16sint': {s: \"sint\"}, // \t✓\t✓\t\t✓},\n'rgba16float': {s: \"float\"}, // \t✓\t✓\t✓\t✓},\n// 32-bit per component\n'r32uint': {s: \"uint\"}, // \t✓\t\t\t✓},\n'r32sint': {s: \"sint\"}, // \t✓\t\t\t✓},\n'r32float': {\"unfilterable-float\"\t✓\t✓\t\t✓},\n'rg32uint': {s: \"uint\"}, // \t✓\t\t\t✓},\n'rg32sint': {s: \"sint\"}, // \t✓\t\t\t✓},\n'rg32float': {\"unfilterable-float\"\t✓\t\t\t✓},\n'rgba32uint': {s: \"uint\"}, // \t✓\t\t\t✓},\n'rgba32sint': {s: \"sint\"}, // \t✓\t\t\t✓},\n'rgba32float': {\"unfilterable-float\"\t✓\t\t\t✓},\n// mixed component width\n'rgb10a2unorm': {s: \"float\"}, // \t✓\t✓\t✓\t}\n'rg11b10ufloat': {s: \"float\"}, // \t\t✓\t\t}\n// Format\tBytes per texel\tAspect\tGPUTextureSampleType\tValid image copy source\tValid image copy destination\n'stencil8': {1 − 4\tstencil\t\"uint\"\t✓}\n'depth16unorm': {2\tdepth\t\"depth\"\t✓}\n'depth24plus': {4\tdepth\t\"depth\"\t✗}\n'depth24plus': {stencil8\t4 − 8\tdepth\t\"depth\"\t✗}\n'stencil': {s: \"uint\"}, // \t✓}\n'depth32float': {4\tdepth\t\"depth\"\t✓\t✗}\n'depth24unorm': {stencil8\t4\tdepth\t\"depth\"\t✗}\n'stencil': {s: \"uint\"}, // \t✓}\n'depth32float': {stencil8}\n\n// Format\tBytes per block\tGPUTextureSampleType\tBlock Size\tFeature\n'rgb9e5ufloat': {c: 4, s: \"float\",\tbpp: 4/(1*1)},\n\n'bc1-rgba-unorm': {c: 4. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc1-rgba-unorm-srgb': {c: 4. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc2-rgba-unorm': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc2-rgba-unorm-srgb': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc3-rgba-unorm': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc3-rgba-unorm-srgb': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc4-r-unorm': {c: 1. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc4-r-snorm': {c: 1. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc5-rg-unorm': {c: 2. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc5-rg-snorm': { },\n'bc6h-rgb-ufloat': {\t16 },\n'bc6h-rgb-float': { },\n'bc7-rgba-unorm': {\t16 },\n'bc7-rgba-unorm-srgb': { },\n\n'etc2-rgb8unorm': {\t8\t\"float\"\t4 × 4\ttexture-compression-etc2 },\n'etc2-rgb8unorm-srgb': { },\n'etc2-rgb8a1unorm': {\t8 },\n'etc2-rgb8a1unorm-srgb': { },\n'etc2-rgba8unorm': {\t16 },\n'etc2-rgba8unorm-srgb': { },\n\n'eac-r11unorm': {\t8 },\n'eac-r11snorm': { },\n'eac-rg11unorm': {\t16 },\n'eac-rg11snorm': { },\n\n'astc-4x4-unorm': {\t16\t\"float\"\t4 × 4\ttexture-compression-astc },\n'astc-4x4-unorm-srgb': { },\n'astc-5x4-unorm': {\t16\t5 × 4 },\n'astc-5x4-unorm-srgb': { },\n'astc-5x5-unorm': {\t16\t5 × 5 },\n'astc-5x5-unorm-srgb': { },\n'astc-6x5-unorm': {\t16\t6 × 5 },\n'astc-6x5-unorm-srgb': { },\n'astc-6x6-unorm': {\t16\t6 × 6 },\n'astc-6x6-unorm-srgb': { },\n'astc-8x5-unorm': {\t16\t8 × 5 },\n'astc-8x5-unorm-srgb': { },\n'astc-8x6-unorm': {\t16\t8 × 6 },\n'astc-8x6-unorm-srgb': { },\n'astc-8x8-unorm': {\t16\t8 × 8 },\n'astc-8x8-unorm-srgb': { },\n'astc-10x5-unorm': {\t16\t10 × 5 },\n'astc-10x5-unorm-srgb': { },\n'astc-10x6-unorm': {\t16\t10 × 6 },\n'astc-10x6-unorm-srgb': { },\n'astc-10x8-unorm': {\t16\t10 × 8 },\n'astc-10x8-unorm-srgb': { },\n'astc-10x10-unorm': {\t16\t10 × 10 },\n'astc-10x10-unorm-srgb': { },\n'astc-12x10-unorm': {\t16\t12 × 10 },\n'astc-12x10-unorm-srgb': { },\n'astc-12x12-unorm': {\t16 },\n*/","map":{"version":3,"names":["decodeVertexType","getTextureFormatDefinition","COMPRESSED_TEXTURE_FORMAT_PREFIXES","RGB_FORMAT_REGEX","isTextureFormatCompressed","format","some","prefix","startsWith","decodeTextureFormat","formatInfo","decodeTextureFormatUsingTable","channels","components","bytesPerPixel","srgb","compressed","blockSize","getCompressedTextureBlockSize","blockWidth","blockHeight","matches","exec","length","type","suffix","dataType","decodedType","bits","byteLength","bitsPerChannel","attachment","integer","signed","normalized","packed","webgl","endsWith","info","f","render","filter","blend","store","REGEX","Number"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\core\\src\\gpu-type-utils\\decode-texture-format.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {TextureFormat, CompressedTextureFormat} from './texture-formats';\nimport {VertexType} from './vertex-formats';\nimport {decodeVertexType} from './decode-data-type';\nimport {TextureFormatInfo} from './texture-format-info';\n\nimport {getTextureFormatDefinition} from './texture-format-table';\n\n// prettier-ignore\nconst COMPRESSED_TEXTURE_FORMAT_PREFIXES = [\n  'bc1', 'bc2', 'bc3', 'bc4', 'bc5', 'bc6', 'bc7', 'etc1', 'etc2', 'eac', 'atc', 'astc', 'pvrtc'\n];\n\nconst RGB_FORMAT_REGEX = /^(r|rg|rgb|rgba|bgra)([0-9]*)([a-z]*)(-srgb)?(-webgl)?$/;\n\n/**\n * Returns true if a texture format is GPU compressed\n */\nexport function isTextureFormatCompressed(\n  format: TextureFormat\n): format is CompressedTextureFormat {\n  return COMPRESSED_TEXTURE_FORMAT_PREFIXES.some(prefix => (format as string).startsWith(prefix));\n}\n\n/**\n * Decodes a texture format, returning e.g. attatchment type, components, byte length and flags (integer, signed, normalized)\n */\nexport function decodeTextureFormat(format: TextureFormat): TextureFormatInfo {\n  let formatInfo: TextureFormatInfo = decodeTextureFormatUsingTable(format);\n\n  if (isTextureFormatCompressed(format)) {\n    formatInfo.channels = 'rgb';\n    formatInfo.components = 3;\n    formatInfo.bytesPerPixel = 1;\n    formatInfo.srgb = false;\n    formatInfo.compressed = true;\n\n    const blockSize = getCompressedTextureBlockSize(format);\n    if (blockSize) {\n      formatInfo.blockWidth = blockSize.blockWidth;\n      formatInfo.blockHeight = blockSize.blockHeight;\n    }\n  }\n\n  // Fill in missing information that can be derived from the format string\n  const matches = RGB_FORMAT_REGEX.exec(format as string);\n  if (matches) {\n    const [, channels, length, type, srgb, suffix] = matches;\n    const dataType = `${type}${length}` as VertexType;\n    const decodedType = decodeVertexType(dataType);\n    const bits = decodedType.byteLength * 8;\n    const components = channels.length as 1 | 2 | 3 | 4;\n    const bitsPerChannel: [number, number, number, number] = [\n      bits,\n      components >= 2 ? bits : 0,\n      components >= 3 ? bits : 0,\n      components >= 4 ? bits : 0\n    ];\n\n    formatInfo = {\n      format,\n      attachment: formatInfo.attachment,\n      dataType: decodedType.dataType,\n      components,\n      channels: channels as 'r' | 'rg' | 'rgb' | 'rgba',\n      integer: decodedType.integer,\n      signed: decodedType.signed,\n      normalized: decodedType.normalized,\n      bitsPerChannel,\n      bytesPerPixel: decodedType.byteLength * channels.length,\n      packed: formatInfo.packed,\n      srgb: formatInfo.srgb\n    };\n\n    if (suffix === '-webgl') {\n      formatInfo.webgl = true;\n    }\n    // dataType - overwritten by decodedType\n    if (srgb === '-srgb') {\n      formatInfo.srgb = true;\n    }\n  }\n\n  if (format.endsWith('-webgl')) {\n    formatInfo.webgl = true;\n  }\n  if (format.endsWith('-srgb')) {\n    formatInfo.srgb = true;\n  }\n\n  return formatInfo;\n}\n\n/** Decode texture format info from the table */\nfunction decodeTextureFormatUsingTable(format: TextureFormat): TextureFormatInfo {\n  const info = getTextureFormatDefinition(format);\n\n  const bytesPerPixel = info.bytesPerPixel || 1;\n  const bitsPerChannel = info.bitsPerChannel || [8, 8, 8, 8];\n  delete info.bitsPerChannel;\n  delete info.bytesPerPixel;\n  delete info.f;\n  delete info.render;\n  delete info.filter;\n  delete info.blend;\n  delete info.store;\n\n  const formatInfo: TextureFormatInfo = {\n    ...info,\n    format,\n    attachment: info.attachment || 'color',\n    channels: info.channels || 'r',\n    components: (info.components || info.channels?.length || 1) as 1 | 2 | 3 | 4,\n    bytesPerPixel,\n    bitsPerChannel,\n    dataType: info.dataType || 'uint8',\n    srgb: info.srgb ?? false,\n    packed: info.packed ?? false,\n    webgl: info.webgl ?? false,\n    integer: info.integer ?? false,\n    signed: info.signed ?? false,\n    normalized: info.normalized ?? false,\n    compressed: info.compressed ?? false\n  };\n\n  return formatInfo;\n}\n\n/** Parses ASTC block widths from format string */\nfunction getCompressedTextureBlockSize(\n  format: CompressedTextureFormat\n): {blockWidth: number; blockHeight: number} | null {\n  const REGEX = /.*-(\\d+)x(\\d+)-.*/;\n  const matches = REGEX.exec(format as string);\n  if (matches) {\n    const [, blockWidth, blockHeight] = matches;\n    return {blockWidth: Number(blockWidth), blockHeight: Number(blockHeight)};\n  }\n  return null;\n}\n\n/*\n'r8unorm':\t{s: \"float\"}, // \t✓\t✓\t✓\t},\n'r8snorm':\t{s: \"float\"}, // \t\t✓\t\t},\n'r8uint':\t{s: \"uint\"}, // \t✓\t✓\t\t},\n'r8sint':\t{s: \"sint\"}, // \t✓\t✓\t\t},\n'rg8unorm':\t{s: \"float\"}, // \t✓\t✓\t✓\t},\n'rg8snorm':\t{s: \"float\"}, // \t\t✓\t\t},\n'rg8uint':\t{s: \"uint\"}, // \t✓\t✓\t\t},\n'rg8sint':\t{s: \"sint\"}, // \t✓\t✓\t\t},\n'rgba8unorm':\t{s: \"float\"}, // \t✓\t✓\t✓\t✓},\n'rgba8unorm-srgb': {s: \"float\"}, // \t✓\t✓\t✓\t},\n'rgba8snorm':\t{s: \"float\"}, // \t\t✓\t\t✓},\n'rgba8uint':\t{s: \"uint\"}, // \t✓\t✓\t\t✓},\n'rgba8sint':\t{s: \"sint\"}, // \t✓\t✓\t\t✓},\n'bgra8unorm':\t{s: \"float\"}, // \t✓\t✓\t✓\t},\n'bgra8unorm-srgb': {s: \"float\"}, // \t✓\t✓\t✓\t},\n// 16-bit per component\t\t\t\t\t\n'r16uint': {s: \"uint\"}, // \t✓\t✓\t\t},\n'r16sint': {s: \"sint\"}, // \t✓\t✓\t\t},\n'r16float': {s: \"float\"}, // \t✓\t✓\t✓\t},\n'rg16uint': {s: \"uint\"}, // \t✓\t✓\t\t},\n'rg16sint': {s: \"sint\"}, // \t✓\t✓\t\t},\n'rg16float': {s: \"float\"}, // \t✓\t✓\t✓\t},\n'rgba16uint': {s: \"uint\"}, // \t✓\t✓\t\t✓},\n'rgba16sint': {s: \"sint\"}, // \t✓\t✓\t\t✓},\n'rgba16float': {s: \"float\"}, // \t✓\t✓\t✓\t✓},\n// 32-bit per component\t\t\t\t\t\n'r32uint': {s: \"uint\"}, // \t✓\t\t\t✓},\n'r32sint': {s: \"sint\"}, // \t✓\t\t\t✓},\n'r32float': {\"unfilterable-float\"\t✓\t✓\t\t✓},\n'rg32uint': {s: \"uint\"}, // \t✓\t\t\t✓},\n'rg32sint': {s: \"sint\"}, // \t✓\t\t\t✓},\n'rg32float': {\"unfilterable-float\"\t✓\t\t\t✓},\n'rgba32uint': {s: \"uint\"}, // \t✓\t\t\t✓},\n'rgba32sint': {s: \"sint\"}, // \t✓\t\t\t✓},\n'rgba32float': {\"unfilterable-float\"\t✓\t\t\t✓},\n// mixed component width\t\t\t\t\t\n'rgb10a2unorm': {s: \"float\"}, // \t✓\t✓\t✓\t}\n'rg11b10ufloat': {s: \"float\"}, // \t\t✓\t\t}\n// Format\tBytes per texel\tAspect\tGPUTextureSampleType\tValid image copy source\tValid image copy destination\n'stencil8': {1 − 4\tstencil\t\"uint\"\t✓}\n'depth16unorm': {2\tdepth\t\"depth\"\t✓}\n'depth24plus': {4\tdepth\t\"depth\"\t✗}\n'depth24plus': {stencil8\t4 − 8\tdepth\t\"depth\"\t✗}\n'stencil': {s: \"uint\"}, // \t✓}\n'depth32float': {4\tdepth\t\"depth\"\t✓\t✗}\n'depth24unorm': {stencil8\t4\tdepth\t\"depth\"\t✗}\n'stencil': {s: \"uint\"}, // \t✓}\n'depth32float': {stencil8}\n\n// Format\tBytes per block\tGPUTextureSampleType\tBlock Size\tFeature\n'rgb9e5ufloat': {c: 4, s: \"float\",\tbpp: 4/(1*1)},\n\n'bc1-rgba-unorm': {c: 4. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc1-rgba-unorm-srgb': {c: 4. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc2-rgba-unorm': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc2-rgba-unorm-srgb': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc3-rgba-unorm': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc3-rgba-unorm-srgb': {c: 4. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc4-r-unorm': {c: 1. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc4-r-snorm': {c: 1. s: \"float\", bpp: 8/(4 * 4) f: 'texture-compression-bc'},\n'bc5-rg-unorm': {c: 2. s: \"float\", bpp: 16/(4 * 4) f: 'texture-compression-bc'},\n'bc5-rg-snorm': { },\n'bc6h-rgb-ufloat': {\t16 },\n'bc6h-rgb-float': { },\n'bc7-rgba-unorm': {\t16 },\n'bc7-rgba-unorm-srgb': { },\n\n'etc2-rgb8unorm': {\t8\t\"float\"\t4 × 4\ttexture-compression-etc2 },\n'etc2-rgb8unorm-srgb': { },\n'etc2-rgb8a1unorm': {\t8 },\n'etc2-rgb8a1unorm-srgb': { },\n'etc2-rgba8unorm': {\t16 },\n'etc2-rgba8unorm-srgb': { },\n\n'eac-r11unorm': {\t8 },\n'eac-r11snorm': { },\n'eac-rg11unorm': {\t16 },\n'eac-rg11snorm': { },\n\n'astc-4x4-unorm': {\t16\t\"float\"\t4 × 4\ttexture-compression-astc },\n'astc-4x4-unorm-srgb': { },\n'astc-5x4-unorm': {\t16\t5 × 4 },\n'astc-5x4-unorm-srgb': { },\n'astc-5x5-unorm': {\t16\t5 × 5 },\n'astc-5x5-unorm-srgb': { },\n'astc-6x5-unorm': {\t16\t6 × 5 },\n'astc-6x5-unorm-srgb': { },\n'astc-6x6-unorm': {\t16\t6 × 6 },\n'astc-6x6-unorm-srgb': { },\n'astc-8x5-unorm': {\t16\t8 × 5 },\n'astc-8x5-unorm-srgb': { },\n'astc-8x6-unorm': {\t16\t8 × 6 },\n'astc-8x6-unorm-srgb': { },\n'astc-8x8-unorm': {\t16\t8 × 8 },\n'astc-8x8-unorm-srgb': { },\n'astc-10x5-unorm': {\t16\t10 × 5 },\n'astc-10x5-unorm-srgb': { },\n'astc-10x6-unorm': {\t16\t10 × 6 },\n'astc-10x6-unorm-srgb': { },\n'astc-10x8-unorm': {\t16\t10 × 8 },\n'astc-10x8-unorm-srgb': { },\n'astc-10x10-unorm': {\t16\t10 × 10 },\n'astc-10x10-unorm-srgb': { },\n'astc-12x10-unorm': {\t16\t12 × 10 },\n'astc-12x10-unorm-srgb': { },\n'astc-12x12-unorm': {\t16 },\n*/\n"],"mappings":"AAAA;AACA;AACA;AAIA,SAAQA,gBAAgB,QAAC;AAGzB,SAAQC,0BAA0B,QAAC;AAEnC;AACA,MAAMC,kCAAkC,GAAG,CACzC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,CAC/F;AAED,MAAMC,gBAAgB,GAAG,yDAAyD;AAElF;;;AAGA,OAAM,SAAUC,yBAAyBA,CACvCC,MAAqB;EAErB,OAAOH,kCAAkC,CAACI,IAAI,CAACC,MAAM,IAAKF,MAAiB,CAACG,UAAU,CAACD,MAAM,CAAC,CAAC;AACjG;AAEA;;;AAGA,OAAM,SAAUE,mBAAmBA,CAACJ,MAAqB;EACvD,IAAIK,UAAU,GAAsBC,6BAA6B,CAACN,MAAM,CAAC;EAEzE,IAAID,yBAAyB,CAACC,MAAM,CAAC,EAAE;IACrCK,UAAU,CAACE,QAAQ,GAAG,KAAK;IAC3BF,UAAU,CAACG,UAAU,GAAG,CAAC;IACzBH,UAAU,CAACI,aAAa,GAAG,CAAC;IAC5BJ,UAAU,CAACK,IAAI,GAAG,KAAK;IACvBL,UAAU,CAACM,UAAU,GAAG,IAAI;IAE5B,MAAMC,SAAS,GAAGC,6BAA6B,CAACb,MAAM,CAAC;IACvD,IAAIY,SAAS,EAAE;MACbP,UAAU,CAACS,UAAU,GAAGF,SAAS,CAACE,UAAU;MAC5CT,UAAU,CAACU,WAAW,GAAGH,SAAS,CAACG,WAAW;IAChD;EACF;EAEA;EACA,MAAMC,OAAO,GAAGlB,gBAAgB,CAACmB,IAAI,CAACjB,MAAgB,CAAC;EACvD,IAAIgB,OAAO,EAAE;IACX,MAAM,GAAGT,QAAQ,EAAEW,MAAM,EAAEC,IAAI,EAAET,IAAI,EAAEU,MAAM,CAAC,GAAGJ,OAAO;IACxD,MAAMK,QAAQ,GAAG,GAAGF,IAAI,GAAGD,MAAM,EAAgB;IACjD,MAAMI,WAAW,GAAG3B,gBAAgB,CAAC0B,QAAQ,CAAC;IAC9C,MAAME,IAAI,GAAGD,WAAW,CAACE,UAAU,GAAG,CAAC;IACvC,MAAMhB,UAAU,GAAGD,QAAQ,CAACW,MAAuB;IACnD,MAAMO,cAAc,GAAqC,CACvDF,IAAI,EACJf,UAAU,IAAI,CAAC,GAAGe,IAAI,GAAG,CAAC,EAC1Bf,UAAU,IAAI,CAAC,GAAGe,IAAI,GAAG,CAAC,EAC1Bf,UAAU,IAAI,CAAC,GAAGe,IAAI,GAAG,CAAC,CAC3B;IAEDlB,UAAU,GAAG;MACXL,MAAM;MACN0B,UAAU,EAAErB,UAAU,CAACqB,UAAU;MACjCL,QAAQ,EAAEC,WAAW,CAACD,QAAQ;MAC9Bb,UAAU;MACVD,QAAQ,EAAEA,QAAuC;MACjDoB,OAAO,EAAEL,WAAW,CAACK,OAAO;MAC5BC,MAAM,EAAEN,WAAW,CAACM,MAAM;MAC1BC,UAAU,EAAEP,WAAW,CAACO,UAAU;MAClCJ,cAAc;MACdhB,aAAa,EAAEa,WAAW,CAACE,UAAU,GAAGjB,QAAQ,CAACW,MAAM;MACvDY,MAAM,EAAEzB,UAAU,CAACyB,MAAM;MACzBpB,IAAI,EAAEL,UAAU,CAACK;KAClB;IAED,IAAIU,MAAM,KAAK,QAAQ,EAAE;MACvBf,UAAU,CAAC0B,KAAK,GAAG,IAAI;IACzB;IACA;IACA,IAAIrB,IAAI,KAAK,OAAO,EAAE;MACpBL,UAAU,CAACK,IAAI,GAAG,IAAI;IACxB;EACF;EAEA,IAAIV,MAAM,CAACgC,QAAQ,CAAC,QAAQ,CAAC,EAAE;IAC7B3B,UAAU,CAAC0B,KAAK,GAAG,IAAI;EACzB;EACA,IAAI/B,MAAM,CAACgC,QAAQ,CAAC,OAAO,CAAC,EAAE;IAC5B3B,UAAU,CAACK,IAAI,GAAG,IAAI;EACxB;EAEA,OAAOL,UAAU;AACnB;AAEA;AACA,SAASC,6BAA6BA,CAACN,MAAqB;EAC1D,MAAMiC,IAAI,GAAGrC,0BAA0B,CAACI,MAAM,CAAC;EAE/C,MAAMS,aAAa,GAAGwB,IAAI,CAACxB,aAAa,IAAI,CAAC;EAC7C,MAAMgB,cAAc,GAAGQ,IAAI,CAACR,cAAc,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAC1D,OAAOQ,IAAI,CAACR,cAAc;EAC1B,OAAOQ,IAAI,CAACxB,aAAa;EACzB,OAAOwB,IAAI,CAACC,CAAC;EACb,OAAOD,IAAI,CAACE,MAAM;EAClB,OAAOF,IAAI,CAACG,MAAM;EAClB,OAAOH,IAAI,CAACI,KAAK;EACjB,OAAOJ,IAAI,CAACK,KAAK;EAEjB,MAAMjC,UAAU,GAAsB;IACpC,GAAG4B,IAAI;IACPjC,MAAM;IACN0B,UAAU,EAAEO,IAAI,CAACP,UAAU,IAAI,OAAO;IACtCnB,QAAQ,EAAE0B,IAAI,CAAC1B,QAAQ,IAAI,GAAG;IAC9BC,UAAU,EAAGyB,IAAI,CAACzB,UAAU,IAAIyB,IAAI,CAAC1B,QAAQ,EAAEW,MAAM,IAAI,CAAmB;IAC5ET,aAAa;IACbgB,cAAc;IACdJ,QAAQ,EAAEY,IAAI,CAACZ,QAAQ,IAAI,OAAO;IAClCX,IAAI,EAAEuB,IAAI,CAACvB,IAAI,IAAI,KAAK;IACxBoB,MAAM,EAAEG,IAAI,CAACH,MAAM,IAAI,KAAK;IAC5BC,KAAK,EAAEE,IAAI,CAACF,KAAK,IAAI,KAAK;IAC1BJ,OAAO,EAAEM,IAAI,CAACN,OAAO,IAAI,KAAK;IAC9BC,MAAM,EAAEK,IAAI,CAACL,MAAM,IAAI,KAAK;IAC5BC,UAAU,EAAEI,IAAI,CAACJ,UAAU,IAAI,KAAK;IACpClB,UAAU,EAAEsB,IAAI,CAACtB,UAAU,IAAI;GAChC;EAED,OAAON,UAAU;AACnB;AAEA;AACA,SAASQ,6BAA6BA,CACpCb,MAA+B;EAE/B,MAAMuC,KAAK,GAAG,mBAAmB;EACjC,MAAMvB,OAAO,GAAGuB,KAAK,CAACtB,IAAI,CAACjB,MAAgB,CAAC;EAC5C,IAAIgB,OAAO,EAAE;IACX,MAAM,GAAGF,UAAU,EAAEC,WAAW,CAAC,GAAGC,OAAO;IAC3C,OAAO;MAACF,UAAU,EAAE0B,MAAM,CAAC1B,UAAU,CAAC;MAAEC,WAAW,EAAEyB,MAAM,CAACzB,WAAW;IAAC,CAAC;EAC3E;EACA,OAAO,IAAI;AACb;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}