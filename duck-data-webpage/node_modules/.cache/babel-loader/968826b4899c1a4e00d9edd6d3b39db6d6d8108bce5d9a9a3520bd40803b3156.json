{"ast":null,"code":"import hasParent from \"../utils/has-parent.js\";\nimport { simpleCloneInputData } from \"./simple-clone-input-data.js\";\nimport { getCenter } from \"./get-center.js\";\nimport { getPointDistance } from \"./get-distance.js\";\nimport { getPointAngle } from \"./get-angle.js\";\nimport { getDirection } from \"./get-direction.js\";\nimport { computeDeltaXY } from \"./get-delta-xy.js\";\nimport { getVelocity } from \"./get-velocity.js\";\nimport { getScale } from \"./get-scale.js\";\nimport { getRotation } from \"./get-rotation.js\";\nimport { computeIntervalInputData } from \"./compute-interval-input-data.js\";\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n */\nexport function computeInputData(manager, input) {\n  const {\n    session\n  } = manager;\n  const {\n    pointers\n  } = input;\n  const {\n    length: pointersLength\n  } = pointers;\n  // store the first input to calculate the distance and direction\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  }\n  // to compute scale and rotation we need to store the multiple touches\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n  const {\n    firstInput,\n    firstMultiple\n  } = session;\n  const offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n  const center = input.center = getCenter(pointers);\n  input.timeStamp = Date.now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n  input.angle = getPointAngle(offsetCenter, center);\n  input.distance = getPointDistance(offsetCenter, center);\n  const {\n    deltaX,\n    deltaY\n  } = computeDeltaXY(session, input);\n  input.deltaX = deltaX;\n  input.deltaY = deltaY;\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n  const overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = Math.abs(overallVelocity.x) > Math.abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n  // find the correct target\n  let target = manager.element;\n  if (hasParent(input.srcEvent.target, target)) {\n    target = input.srcEvent.target;\n  }\n  input.target = target;\n  computeIntervalInputData(session, input);\n  // All the optional fields have been populated\n  return input;\n}","map":{"version":3,"names":["hasParent","simpleCloneInputData","getCenter","getPointDistance","getPointAngle","getDirection","computeDeltaXY","getVelocity","getScale","getRotation","computeIntervalInputData","computeInputData","manager","input","session","pointers","length","pointersLength","firstInput","firstMultiple","offsetCenter","center","timeStamp","Date","now","deltaTime","angle","distance","deltaX","deltaY","offsetDirection","overallVelocity","overallVelocityX","x","overallVelocityY","y","Math","abs","scale","rotation","maxPointers","prevInput","target","element","srcEvent"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\mjolnir.js\\src\\hammerjs\\input\\compute-input-data.ts"],"sourcesContent":["import hasParent from '../utils/has-parent';\nimport {simpleCloneInputData} from './simple-clone-input-data';\nimport {getCenter} from './get-center';\nimport {getPointDistance} from './get-distance';\nimport {getPointAngle} from './get-angle';\nimport {getDirection} from './get-direction';\nimport {computeDeltaXY} from './get-delta-xy';\nimport {getVelocity} from './get-velocity';\nimport {getScale} from './get-scale';\nimport {getRotation} from './get-rotation';\nimport {computeIntervalInputData} from './compute-interval-input-data';\n\nimport type {Manager} from '../manager';\nimport type {RawInput, HammerInput} from './types';\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n */\nexport function computeInputData(manager: Manager, input: RawInput): HammerInput {\n  const {session} = manager;\n  const {pointers} = input;\n  const {length: pointersLength} = pointers;\n\n  // store the first input to calculate the distance and direction\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  }\n\n  // to compute scale and rotation we need to store the multiple touches\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n\n  const {firstInput, firstMultiple} = session;\n  const offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n  const center = (input.center = getCenter(pointers));\n  input.timeStamp = Date.now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n  input.angle = getPointAngle(offsetCenter, center);\n  input.distance = getPointDistance(offsetCenter, center);\n\n  const {deltaX, deltaY} = computeDeltaXY(session, input);\n  input.deltaX = deltaX;\n  input.deltaY = deltaY;\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n  const overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity =\n    Math.abs(overallVelocity.x) > Math.abs(overallVelocity.y)\n      ? overallVelocity.x\n      : overallVelocity.y;\n\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n  input.maxPointers = !session.prevInput\n    ? input.pointers.length\n    : input.pointers.length > session.prevInput.maxPointers\n      ? input.pointers.length\n      : session.prevInput.maxPointers;\n\n  // find the correct target\n  let target = manager.element!;\n  if (hasParent(input.srcEvent.target as HTMLElement, target)) {\n    target = input.srcEvent.target as HTMLElement;\n  }\n  input.target = target;\n\n  computeIntervalInputData(session, input as HammerInput);\n\n  // All the optional fields have been populated\n  return input as HammerInput;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}