{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBlob } from \"../../javascript-utils/is-type.js\";\nimport { isLoaderObject } from \"../loader-utils/normalize-loader.js\";\nimport { getFetchFunction } from \"../loader-utils/get-fetch-function.js\";\nimport { parse } from \"./parse.js\";\n// export async function load(url: string | DataType, loaders: LoaderOptions): Promise<any>;\n// implementation signature\nexport async function load(url, loaders, options, context) {\n  let resolvedLoaders;\n  let resolvedOptions;\n  // Signature: load(url, options)\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    resolvedLoaders = [];\n    resolvedOptions = loaders;\n    context = undefined; // context not supported in short signature\n  } else {\n    resolvedLoaders = loaders;\n    resolvedOptions = options;\n  }\n  // Select fetch function\n  const fetch = getFetchFunction(resolvedOptions);\n  // at this point, `url` could be already loaded binary data\n  let data = url;\n  // url is a string, fetch the url\n  if (typeof url === 'string') {\n    data = await fetch(url);\n    // URL is Blob or File, fetchFile handles it (alt: we could generate ObjectURL here)\n  }\n  if (isBlob(url)) {\n    // The fetch response object will contain blob.name\n    // @ts-expect-error TODO - This may not work for overridden fetch functions\n    data = await fetch(url);\n  }\n  // Data is loaded (at least we have a `Response` object) so time to hand over to `parse`\n  // return await parse(data, loaders as Loader[], options);\n  return Array.isArray(resolvedLoaders) ? await parse(data, resolvedLoaders, resolvedOptions) // loader array overload\n  : await parse(data, resolvedLoaders, resolvedOptions); // single loader overload\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}