{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { Tile3DSubtreeLoader } from \"../../../tile-3d-subtree-loader.js\";\nimport { load } from '@loaders.gl/core';\nimport { default as log } from '@probe.gl/log';\nimport { getS2CellIdFromToken, getS2ChildCellId, getS2TokenFromCellId } from \"../../utils/s2/index.js\";\nimport { convertS2BoundingVolumetoOBB } from \"../../utils/obb/s2-corners-to-obb.js\";\nconst QUADTREE_DIVISION_COUNT = 4;\nconst OCTREE_DIVISION_COUNT = 8;\nconst SUBDIVISION_COUNT_MAP = {\n  QUADTREE: QUADTREE_DIVISION_COUNT,\n  OCTREE: OCTREE_DIVISION_COUNT\n};\nfunction getChildS2VolumeBox(s2VolumeBox, index, subdivisionScheme) {\n  if (s2VolumeBox?.box) {\n    // Check if the BoundingVolume is of type \"box\"\n    const cellId = getS2CellIdFromToken(s2VolumeBox.s2VolumeInfo.token);\n    const childCellId = getS2ChildCellId(cellId, index);\n    const childToken = getS2TokenFromCellId(childCellId);\n    // Clone object. Note, s2VolumeInfo is a plain object that doesn't contain any nested object.\n    // So, we can use the Spread Operator to make a shallow copy of the object.\n    const s2ChildVolumeInfo = {\n      ...s2VolumeBox.s2VolumeInfo\n    };\n    s2ChildVolumeInfo.token = childToken; // replace the token with the child's one\n    // In case of QUADTREE the sizeZ should NOT be changed!\n    // https://portal.ogc.org/files/102132\n    // A quadtree divides space only on the x and y dimensions.\n    // It divides each tile into 4 smaller tiles where the x and y dimensions are halved.\n    // The quadtree z minimum and maximum remain unchanged.\n    switch (subdivisionScheme) {\n      case 'OCTREE':\n        const s2VolumeInfo = s2VolumeBox.s2VolumeInfo;\n        const delta = s2VolumeInfo.maximumHeight - s2VolumeInfo.minimumHeight;\n        const sizeZ = delta / 2.0; // It's a next level (a child)\n        const midZ = s2VolumeInfo.minimumHeight + delta / 2.0;\n        s2VolumeInfo.minimumHeight = midZ - sizeZ;\n        s2VolumeInfo.maximumHeight = midZ + sizeZ;\n        break;\n      default:\n        break;\n    }\n    const box = convertS2BoundingVolumetoOBB(s2ChildVolumeInfo);\n    const childS2VolumeBox = {\n      box,\n      s2VolumeInfo: s2ChildVolumeInfo\n    };\n    return childS2VolumeBox;\n  }\n  return undefined;\n}\n/**\n * Recursively parse implicit tiles tree\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling\n * TODO Check out do we able to use Tile3D class as return type here.\n *\n * @param subtree - the current subtree. Subtrees contain availability data for <implicitOptions.subtreeLevels>.\n *     Once we go deeper than that many levels, we will need load a child subtree to get further availability data.\n * @param subtreeData - the coordinates of the current subtree, relative to the root of this implicit tiles tree.\n * @param parentData - the coordinates of the parent tile, relative to the current subtree.\n *     The overall coordinates of the current tile can be found by combining the coordinates of the current subtree, the parent tile,\n *     and tje single-bit coordinates that can be calculated from the childIndex.\n * @param childIndex - which child the current tile is of its parent. In the range 0-7 for OCTREE, 0-3 for QUADTREE.\n * @param implicitOptions - options specified at the root of this implicit tile tree - numbers of levels, URL templates.\n * @param loaderOptions - see Tiles3DLoaderOptions.\n */\n// eslint-disable-next-line max-statements, complexity\nexport async function parseImplicitTiles(params) {\n  const {\n    subtree,\n    subtreeData = {\n      level: 0,\n      x: 0,\n      y: 0,\n      z: 0\n    },\n    parentData = {\n      mortonIndex: 0,\n      localLevel: -1,\n      localX: 0,\n      localY: 0,\n      localZ: 0\n    },\n    childIndex = 0,\n    implicitOptions,\n    loaderOptions,\n    s2VolumeBox\n  } = params;\n  const {\n    subdivisionScheme,\n    subtreeLevels,\n    maximumLevel,\n    contentUrlTemplate,\n    subtreesUriTemplate,\n    basePath\n  } = implicitOptions;\n  const tile = {\n    children: [],\n    lodMetricValue: 0,\n    contentUrl: ''\n  };\n  if (!maximumLevel) {\n    log.once(`Missing 'maximumLevel' or 'availableLevels' property. The subtree ${contentUrlTemplate} won't be loaded...`);\n    return tile;\n  }\n  // Local tile level - relative to the current subtree.\n  const localLevel = parentData.localLevel + 1;\n  // Global tile level - relative to the root tile of this implicit subdivision scheme.\n  const level = subtreeData.level + localLevel;\n  if (level > maximumLevel) {\n    return tile;\n  }\n  const childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];\n  const bitsPerTile = Math.log2(childrenPerTile);\n  // childIndex is in range 0...3 for quadtrees and 0...7 for octrees\n  const lastBitX = childIndex & 0b01; // Get first bit for X\n  const lastBitY = childIndex >> 1 & 0b01; // Get second bit for Y\n  const lastBitZ = childIndex >> 2 & 0b01; // Get third bit for Z\n  // Local tile coordinates - relative to the current subtree root.\n  const localX = concatBits(parentData.localX, lastBitX, 1);\n  const localY = concatBits(parentData.localY, lastBitY, 1);\n  const localZ = concatBits(parentData.localZ, lastBitZ, 1);\n  // Global tile coordinates - relative to the implicit-tile-tree root.\n  // Found by combining the local coordinates which are relative to the current subtree, with the subtree coordinates.\n  const x = concatBits(subtreeData.x, localX, localLevel);\n  const y = concatBits(subtreeData.y, localY, localLevel);\n  const z = concatBits(subtreeData.z, localZ, localLevel);\n  const mortonIndex = concatBits(parentData.mortonIndex, childIndex, bitsPerTile);\n  const isChildSubtreeAvailable = localLevel === subtreeLevels && getAvailabilityResult(subtree.childSubtreeAvailability, mortonIndex);\n  // Context to provide the next recursive call.\n  // This context is set up differently depending on whether its time to start a new subtree or not.\n  let nextSubtree;\n  let nextSubtreeData;\n  let nextParentData;\n  let tileAvailabilityIndex;\n  if (isChildSubtreeAvailable) {\n    const subtreePath = `${basePath}/${subtreesUriTemplate}`;\n    const childSubtreeUrl = replaceContentUrlTemplate(subtreePath, level, x, y, z);\n    const childSubtree = await load(childSubtreeUrl, Tile3DSubtreeLoader, loaderOptions);\n    // The next subtree is the newly-loaded child subtree.\n    nextSubtree = childSubtree;\n    // The current tile is actually the root tile in the next subtree, so it has a tileAvailabilityIndex of 0.\n    tileAvailabilityIndex = 0;\n    // The next subtree starts HERE - at the current tile.\n    nextSubtreeData = {\n      level,\n      x,\n      y,\n      z\n    };\n    // The next parent is also the current tile - so it has local coordinates of 0 relative to the next subtree.\n    nextParentData = {\n      mortonIndex: 0,\n      localLevel: 0,\n      localX: 0,\n      localY: 0,\n      localZ: 0\n    };\n  } else {\n    // Continue on with the same subtree as we're using currently.\n    nextSubtree = subtree;\n    // Calculate a tileAvailabilityIndex for the current tile within the current subtree.\n    const levelOffset = (childrenPerTile ** localLevel - 1) / (childrenPerTile - 1);\n    tileAvailabilityIndex = levelOffset + mortonIndex;\n    // The next subtree is the same as the current subtree.\n    nextSubtreeData = subtreeData;\n    // The next parent is the current tile: it has the local coordinates we already calculated.\n    nextParentData = {\n      mortonIndex,\n      localLevel,\n      localX,\n      localY,\n      localZ\n    };\n  }\n  const isTileAvailable = getAvailabilityResult(nextSubtree.tileAvailability, tileAvailabilityIndex);\n  if (!isTileAvailable) {\n    return tile;\n  }\n  const isContentAvailable = getAvailabilityResult(nextSubtree.contentAvailability, tileAvailabilityIndex);\n  if (isContentAvailable) {\n    tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, level, x, y, z);\n  }\n  for (let index = 0; index < childrenPerTile; index++) {\n    const childS2VolumeBox = getChildS2VolumeBox(s2VolumeBox, index, subdivisionScheme);\n    // Recursive calling...\n    const childTile = await parseImplicitTiles({\n      subtree: nextSubtree,\n      subtreeData: nextSubtreeData,\n      parentData: nextParentData,\n      childIndex: index,\n      implicitOptions,\n      loaderOptions,\n      s2VolumeBox: childS2VolumeBox\n    });\n    if (childTile.contentUrl || childTile.children.length) {\n      // @ts-ignore\n      tile.children.push(childTile);\n    }\n  }\n  if (tile.contentUrl || tile.children.length) {\n    const coordinates = {\n      level,\n      x,\n      y,\n      z\n    };\n    const formattedTile = formatTileData(tile, coordinates, implicitOptions, s2VolumeBox);\n    return formattedTile;\n  }\n  return tile;\n}\n/**\n * Check tile availability in the bitstream array\n * @param availabilityData - tileAvailability / contentAvailability / childSubtreeAvailability object\n * @param index - index in the bitstream array\n * @returns\n */\nfunction getAvailabilityResult(availabilityData, index) {\n  let availabilityObject;\n  if (Array.isArray(availabilityData)) {\n    /** TODO: we don't support `3DTILES_multiple_contents` extension at the moment.\n     * https://github.com/CesiumGS/3d-tiles/blob/main/extensions/3DTILES_implicit_tiling/README.md#multiple-contents\n     * Take first item in the array\n     */\n    availabilityObject = availabilityData[0];\n    if (availabilityData.length > 1) {\n      // eslint-disable-next-line no-console\n      log.once('Not supported extension \"3DTILES_multiple_contents\" has been detected');\n    }\n  } else {\n    availabilityObject = availabilityData;\n  }\n  if ('constant' in availabilityObject) {\n    return Boolean(availabilityObject.constant);\n  }\n  if (availabilityObject.explicitBitstream) {\n    return getBooleanValueFromBitstream(index, availabilityObject.explicitBitstream);\n  }\n  return false;\n}\n/**\n * Do formatting of implicit tile data.\n * TODO Check out do we able to use Tile3D class as type here.\n *\n * @param tile - tile data to format.\n * @param coordinates - global tile coordinates (relative to the root of the implicit tile tree).\n * @param options - options specified at the root of this implicit tile tree - numbers of levels, URL templates.\n * @param s2VolumeBox - the S2VolumeBox for this particular child, if available.\n * @returns\n */\nfunction formatTileData(tile, coordinates, options, s2VolumeBox) {\n  const {\n    basePath,\n    refine,\n    getRefine,\n    lodMetricType,\n    getTileType,\n    rootLodMetricValue,\n    rootBoundingVolume\n  } = options;\n  const uri = tile.contentUrl && tile.contentUrl.replace(`${basePath}/`, '');\n  const lodMetricValue = rootLodMetricValue / 2 ** coordinates.level;\n  const boundingVolume = s2VolumeBox?.box ? {\n    box: s2VolumeBox.box\n  } : rootBoundingVolume;\n  const boundingVolumeForChildTile = calculateBoundingVolumeForChildTile(boundingVolume, coordinates, options.subdivisionScheme);\n  return {\n    children: tile.children,\n    contentUrl: tile.contentUrl,\n    content: {\n      uri\n    },\n    id: tile.contentUrl,\n    refine: getRefine(refine),\n    type: getTileType(tile),\n    lodMetricType,\n    lodMetricValue,\n    geometricError: lodMetricValue,\n    transform: tile.transform,\n    boundingVolume: boundingVolumeForChildTile\n  };\n}\n/**\n * Calculate child bounding volume.\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling#subdivision-rules\n * @param rootBoundingVolume\n * @param coordinates\n * @param subdivisionScheme\n */\nfunction calculateBoundingVolumeForChildTile(rootBoundingVolume, coordinates, subdivisionScheme) {\n  if (rootBoundingVolume.region) {\n    const {\n      level,\n      x,\n      y,\n      z\n    } = coordinates;\n    const [west, south, east, north, minimumHeight, maximumHeight] = rootBoundingVolume.region;\n    const boundingVolumesCount = 2 ** level;\n    const sizeX = (east - west) / boundingVolumesCount;\n    const [childWest, childEast] = [west + sizeX * x, west + sizeX * (x + 1)];\n    const sizeY = (north - south) / boundingVolumesCount;\n    const [childSouth, childNorth] = [south + sizeY * y, south + sizeY * (y + 1)];\n    // In case of QUADTREE the sizeZ should NOT be changed!\n    // https://portal.ogc.org/files/102132\n    // A quadtree divides space only on the x and y dimensions.\n    // It divides each tile into 4 smaller tiles where the x and y dimensions are halved.\n    // The quadtree z minimum and maximum remain unchanged.\n    let childMinimumHeight;\n    let childMaximumHeight;\n    if (subdivisionScheme === 'OCTREE') {\n      const sizeZ = (maximumHeight - minimumHeight) / boundingVolumesCount;\n      [childMinimumHeight, childMaximumHeight] = [minimumHeight + sizeZ * z, minimumHeight + sizeZ * (z + 1)];\n    } else {\n      [childMinimumHeight, childMaximumHeight] = [minimumHeight, maximumHeight];\n    }\n    return {\n      region: [childWest, childSouth, childEast, childNorth, childMinimumHeight, childMaximumHeight]\n    };\n  }\n  if (rootBoundingVolume.box) {\n    return rootBoundingVolume;\n  }\n  throw new Error(`Unsupported bounding volume type ${JSON.stringify(rootBoundingVolume)}`);\n}\n/**\n * Do binary concatenation\n * @param higher - number to put to higher part of result\n * @param lower - number to put to lower part of result\n * @param shift - number of bits to shift lower number\n */\nfunction concatBits(higher, lower, shift) {\n  return (higher << shift) + lower;\n}\n/**\n * Replace implicit tile content url with real coordinates.\n * @param templateUrl\n * @param level\n * @param x\n * @param y\n * @param z\n */\nexport function replaceContentUrlTemplate(templateUrl, level, x, y, z) {\n  const mapUrl = generateMapUrl({\n    level,\n    x,\n    y,\n    z\n  });\n  return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, matched => mapUrl[matched]);\n}\n/**\n * Get Map object for content url generation\n * @param items\n */\nfunction generateMapUrl(items) {\n  const mapUrl = {};\n  for (const key in items) {\n    mapUrl[`{${key}}`] = items[key];\n  }\n  return mapUrl;\n}\n/**\n * Get boolean value from bistream by index\n * A boolean value is encoded as a single bit, either 0 (false) or 1 (true).\n * Multiple boolean values are packed tightly in the same buffer.\n * These buffers of tightly-packed bits are sometimes referred to as bitstreams.\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/implicit-revisions/specification/Metadata#booleans\n * @param availabilitiIndex\n */\nfunction getBooleanValueFromBitstream(availabilityIndex, availabilityBuffer) {\n  const byteIndex = Math.floor(availabilityIndex / 8);\n  const bitIndex = availabilityIndex % 8;\n  const bitValue = availabilityBuffer[byteIndex] >> bitIndex & 1;\n  return bitValue === 1;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}