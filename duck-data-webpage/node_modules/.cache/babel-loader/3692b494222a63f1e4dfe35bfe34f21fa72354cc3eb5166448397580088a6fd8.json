{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Resource } from \"./resource.js\";\n/**\n * Abstract Texture interface\n * Texture Object\n * https://gpuweb.github.io/gpuweb/#gputexture\n */\nexport class Texture extends Resource {\n  static COPY_SRC = 0x01;\n  static COPY_DST = 0x02;\n  static TEXTURE = 0x04;\n  static STORAGE = 0x08;\n  static RENDER_ATTACHMENT = 0x10;\n  static CubeFaces = ['+X', '-X', '+Y', '-Y', '+Z', '-Z'];\n  static defaultProps = {\n    ...Resource.defaultProps,\n    data: null,\n    dimension: '2d',\n    format: 'rgba8unorm',\n    width: undefined,\n    height: undefined,\n    depth: 1,\n    mipmaps: false,\n    compressed: false,\n    usage: 0,\n    mipLevels: undefined,\n    samples: undefined,\n    sampler: {},\n    view: undefined,\n    flipY: undefined\n  };\n  get [Symbol.toStringTag]() {\n    return 'Texture';\n  }\n  toString() {\n    return `Texture(${this.id},${this.format},${this.width}x${this.height})`;\n  }\n  /** dimension of this texture */\n  dimension;\n  /** format of this texture */\n  format;\n  /** width in pixels of this texture */\n  width;\n  /** height in pixels of this texture */\n  height;\n  /** depth of this texture */\n  depth;\n  /** mip levels in this texture */\n  mipLevels;\n  /** \"Time\" of last update. Monotonically increasing timestamp. TODO move to AsyncTexture? */\n  updateTimestamp;\n  /** Do not use directly. Create with device.createTexture() */\n  constructor(device, props) {\n    props = Texture.normalizeProps(device, props);\n    super(device, props, Texture.defaultProps);\n    this.dimension = this.props.dimension;\n    this.format = this.props.format;\n    // Size\n    this.width = this.props.width;\n    this.height = this.props.height;\n    this.depth = this.props.depth;\n    // Calculate size, if not provided\n    if (this.props.width === undefined || this.props.height === undefined) {\n      // @ts-ignore\n      const size = Texture.getTextureDataSize(this.props.data);\n      this.width = size?.width || 1;\n      this.height = size?.height || 1;\n    }\n    // mipLevels\n    // If mipmap generation is requested and mipLevels is not provided, initialize a full pyramid\n    if (this.props.mipmaps && this.props.mipLevels === undefined) {\n      this.props.mipLevels = 'pyramid';\n    }\n    // Auto-calculate the number of mip levels as a convenience\n    // TODO - Should we clamp to 1-getMipLevelCount?\n    this.mipLevels = this.props.mipLevels === 'pyramid' ? Texture.getMipLevelCount(this.width, this.height) : this.props.mipLevels || 1;\n    // TODO - perhaps this should be set on async write completion?\n    this.updateTimestamp = device.incrementTimestamp();\n  }\n  /**\n   * Create a new texture with the same parameters and optionally, a different size\n   * @note Textures are immutable and cannot be resized after creation, but we can create a similar texture with the same parameters but a new size.\n   * @note Does not copy contents of the texture\n   */\n  clone(size) {\n    return this.device.createTexture({\n      ...this.props,\n      ...size\n    });\n  }\n  /** Check if data is an external image */\n  static isExternalImage(data) {\n    return typeof ImageData !== 'undefined' && data instanceof ImageData || typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap || typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement || typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement || typeof VideoFrame !== 'undefined' && data instanceof VideoFrame || typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas;\n  }\n  /** Determine size (width and height) of provided image data */\n  static getExternalImageSize(data) {\n    if (typeof ImageData !== 'undefined' && data instanceof ImageData || typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap || typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas) {\n      return {\n        width: data.width,\n        height: data.height\n      };\n    }\n    if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {\n      return {\n        width: data.naturalWidth,\n        height: data.naturalHeight\n      };\n    }\n    if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {\n      return {\n        width: data.videoWidth,\n        height: data.videoHeight\n      };\n    }\n    if (typeof VideoFrame !== 'undefined' && data instanceof VideoFrame) {\n      // TODO: is this the right choice for width and height?\n      return {\n        width: data.displayWidth,\n        height: data.displayHeight\n      };\n    }\n    throw new Error('Unknown image type');\n  }\n  /** Check if texture data is a typed array */\n  static isTextureLevelData(data) {\n    const typedArray = data?.data;\n    return ArrayBuffer.isView(typedArray);\n  }\n  /** Get the size of the texture described by the provided TextureData */\n  static getTextureDataSize(data) {\n    if (!data) {\n      return null;\n    }\n    if (ArrayBuffer.isView(data)) {\n      return null;\n    }\n    // Recurse into arrays (array of miplevels)\n    if (Array.isArray(data)) {\n      return Texture.getTextureDataSize(data[0]);\n    }\n    if (Texture.isExternalImage(data)) {\n      return Texture.getExternalImageSize(data);\n    }\n    if (data && typeof data === 'object' && data.constructor === Object) {\n      const textureDataArray = Object.values(data);\n      const untypedData = textureDataArray[0];\n      return {\n        width: untypedData.width,\n        height: untypedData.height\n      };\n    }\n    throw new Error('texture size deduction failed');\n  }\n  /**\n   * Normalize TextureData to an array of TextureLevelData / ExternalImages\n   * @param data\n   * @param options\n   * @returns array of TextureLevelData / ExternalImages\n   */\n  static normalizeTextureData(data, options) {\n    let lodArray;\n    if (ArrayBuffer.isView(data)) {\n      lodArray = [{\n        // ts-expect-error does data really need to be Uint8ClampedArray?\n        data,\n        width: options.width,\n        height: options.height\n        // depth: options.depth\n      }];\n    } else if (!Array.isArray(data)) {\n      lodArray = [data];\n    } else {\n      lodArray = data;\n    }\n    return lodArray;\n  }\n  /** Calculate the number of mip levels for a texture of width and height */\n  static getMipLevelCount(width, height) {\n    return Math.floor(Math.log2(Math.max(width, height))) + 1;\n  }\n  /** Convert luma.gl cubemap face constants to depth index */\n  static getCubeFaceDepth(face) {\n    // prettier-ignore\n    switch (face) {\n      case '+X':\n        return 0;\n      case '-X':\n        return 1;\n      case '+Y':\n        return 2;\n      case '-Y':\n        return 3;\n      case '+Z':\n        return 4;\n      case '-Z':\n        return 5;\n      default:\n        throw new Error(face);\n    }\n  }\n  /** Default options */\n  static defaultCopyExternalImageOptions = {\n    image: undefined,\n    sourceX: 0,\n    sourceY: 0,\n    width: undefined,\n    height: undefined,\n    depth: 1,\n    mipLevel: 0,\n    x: 0,\n    y: 0,\n    z: 0,\n    aspect: 'all',\n    colorSpace: 'srgb',\n    premultipliedAlpha: false,\n    flipY: false\n  };\n  /** Ensure we have integer coordinates */\n  static normalizeProps(device, props) {\n    const newProps = {\n      ...props\n    };\n    // Allow device to override props (e.g. props.mipmaps)\n    const overriddenDefaultProps = device?.props?._resourceDefaults?.texture || {};\n    // TODO - Type issue with props.data circumvented with Object.assign\n    Object.assign(newProps, overriddenDefaultProps);\n    // Ensure we have integer coordinates\n    const {\n      width,\n      height\n    } = newProps;\n    if (typeof width === 'number') {\n      newProps.width = Math.max(1, Math.ceil(width));\n    }\n    if (typeof height === 'number') {\n      newProps.height = Math.max(1, Math.ceil(height));\n    }\n    return newProps;\n  }\n}","map":{"version":3,"names":["Resource","Texture","COPY_SRC","COPY_DST","TEXTURE","STORAGE","RENDER_ATTACHMENT","CubeFaces","defaultProps","data","dimension","format","width","undefined","height","depth","mipmaps","compressed","usage","mipLevels","samples","sampler","view","flipY","Symbol","toStringTag","toString","id","updateTimestamp","constructor","device","props","normalizeProps","size","getTextureDataSize","getMipLevelCount","incrementTimestamp","clone","createTexture","isExternalImage","ImageData","ImageBitmap","HTMLImageElement","HTMLVideoElement","VideoFrame","HTMLCanvasElement","OffscreenCanvas","getExternalImageSize","naturalWidth","naturalHeight","videoWidth","videoHeight","displayWidth","displayHeight","Error","isTextureLevelData","typedArray","ArrayBuffer","isView","Array","isArray","Object","textureDataArray","values","untypedData","normalizeTextureData","options","lodArray","Math","floor","log2","max","getCubeFaceDepth","face","defaultCopyExternalImageOptions","image","sourceX","sourceY","mipLevel","x","y","z","aspect","colorSpace","premultipliedAlpha","newProps","overriddenDefaultProps","_resourceDefaults","texture","assign","ceil"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\core\\src\\adapter\\resources\\texture.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport type {TypedArray} from '../../types';\nimport type {TextureFormat} from '../../gpu-type-utils/texture-formats';\nimport type {TextureView, TextureViewProps} from './texture-view';\nimport {Resource, ResourceProps} from './resource';\nimport {Sampler, SamplerProps} from './sampler';\n\n/**\n * These represent the main compressed texture formats\n * Each format typically has a number of more specific subformats\n */\nexport type TextureCompressionFormat =\n  | 'dxt'\n  | 'dxt-srgb'\n  | 'etc1'\n  | 'etc2'\n  | 'pvrtc'\n  | 'atc'\n  | 'astc'\n  | 'rgtc';\n\n/** Names of cube texture faces */\nexport type TextureCubeFace = '+X' | '-X' | '+Y' | '-Y' | '+Z' | '-Z';\n\n/**\n * One mip level\n * Basic data structure is similar to `ImageData`\n * additional optional fields can describe compressed texture data.\n */\nexport type TextureLevelData = {\n  /** WebGPU style format string. Defaults to 'rgba8unorm' */\n  format?: TextureFormat;\n  data: TypedArray;\n  width: number;\n  height: number;\n\n  compressed?: boolean;\n  byteLength?: number;\n  hasAlpha?: boolean;\n};\n\n/**\n * Built-in data types that can be used to initialize textures\n * @note ImageData can be used for 8 bit data via Uint8ClampedArray\n */\nexport type ExternalImage =\n  | ImageBitmap\n  | ImageData\n  | HTMLImageElement\n  | HTMLVideoElement\n  | VideoFrame\n  | HTMLCanvasElement\n  | OffscreenCanvas;\n\nexport type TextureLevelSource = TextureLevelData | ExternalImage;\n\n/** Texture data can be one or more mip levels */\nexport type TextureData = TextureLevelData | ExternalImage | (TextureLevelData | ExternalImage)[];\n\n/** @todo - define what data type is supported for 1D textures */\nexport type Texture1DData = TypedArray | TextureLevelData;\n\n/** Texture data can be one or more mip levels */\nexport type Texture2DData =\n  | TypedArray\n  | TextureLevelData\n  | ExternalImage\n  | (TextureLevelData | ExternalImage)[];\n\n/** Array of textures */\nexport type Texture3DData = TypedArray | TextureData[];\n\n/** 6 face textures */\nexport type TextureCubeData = Record<TextureCubeFace, Texture2DData>;\n\n/** Array of textures */\nexport type TextureArrayData = TextureData[];\n\n/** Array of 6 face textures */\nexport type TextureCubeArrayData = Record<TextureCubeFace, TextureData>[];\n\nexport type TextureDataProps =\n  | Texture1DProps\n  | Texture2DProps\n  | Texture3DProps\n  | TextureArrayProps\n  | TextureCubeProps\n  | TextureCubeArrayProps;\n\nexport type Texture1DProps = {dimension: '1d'; data?: Texture1DData | null};\nexport type Texture2DProps = {dimension?: '2d'; data?: Texture2DData | null};\nexport type Texture3DProps = {dimension: '3d'; data?: Texture3DData | null};\nexport type TextureArrayProps = {dimension: '2d-array'; data?: TextureArrayData | null};\nexport type TextureCubeProps = {dimension: 'cube'; data?: TextureCubeData | null};\nexport type TextureCubeArrayProps = {dimension: 'cube-array'; data: TextureCubeArrayData | null};\n\n/** Texture properties */\nexport type TextureProps = ResourceProps &\n  TextureDataProps & {\n    format?: TextureFormat;\n    width?: number | undefined;\n    height?: number | undefined;\n    depth?: number;\n    usage?: number;\n\n    /** How many mip levels */\n    mipLevels?: number | 'pyramid';\n    /** Multi sampling */\n    samples?: number;\n\n    /** Specifying mipmaps will default mipLevels to 'pyramid' and attempt to generate mipmaps */\n    mipmaps?: boolean;\n\n    /** Sampler (or SamplerProps) for the default sampler for this texture. Used if no sampler provided. Note that other samplers can still be used. */\n    sampler?: Sampler | SamplerProps;\n    /** Props for the default TextureView for this texture. Note that other views can still be created and used. */\n    view?: TextureViewProps;\n\n    /** Whether to flip the image vertically. Used if texture is initialized with an image. */\n    flipY?: boolean;\n\n    /** @deprecated - this is implicit from format */\n    compressed?: boolean;\n  };\n\n/** Options for Texture.copyExternalImage */\nexport type CopyExternalImageOptions = {\n  /** Image */\n  image: ExternalImage;\n  /** Copy from image x offset (default 0) */\n  sourceX?: number;\n  /** Copy from image y offset (default 0) */\n  sourceY?: number;\n  /** Copy area width (default 1) */\n  width?: number;\n  /** Copy area height (default 1) */\n  height?: number;\n  /** Copy depth (default 1) */\n  depth?: number;\n  /** Which mip-level to copy into (default 0) */\n  mipLevel?: number;\n  /** Start copying into offset x (default 0) */\n  x?: number;\n  /** Start copying into offset y (default 0) */\n  y?: number;\n  /** Start copying from depth layer z (default 0) */\n  z?: number;\n  /** When copying into depth stencil textures (default 'all') */\n  aspect?: 'all' | 'stencil-only' | 'depth-only';\n  /** Specific color space of image data */\n  colorSpace?: 'srgb';\n  /** load as premultiplied alpha  */\n  premultipliedAlpha?: boolean;\n  /** Whether to flip the image vertically */\n  flipY?: boolean;\n};\n\n/**\n * Abstract Texture interface\n * Texture Object\n * https://gpuweb.github.io/gpuweb/#gputexture\n */\nexport abstract class Texture extends Resource<TextureProps> {\n  static COPY_SRC = 0x01;\n  static COPY_DST = 0x02;\n  static TEXTURE = 0x04;\n  static STORAGE = 0x08;\n  static RENDER_ATTACHMENT = 0x10;\n\n  static CubeFaces: TextureCubeFace[] = ['+X', '-X', '+Y', '-Y', '+Z', '-Z'];\n\n  static override defaultProps: Required<TextureProps> = {\n    ...Resource.defaultProps,\n    data: null,\n    dimension: '2d',\n    format: 'rgba8unorm',\n    width: undefined!,\n    height: undefined!,\n    depth: 1,\n    mipmaps: false,\n    compressed: false,\n    usage: 0,\n    mipLevels: undefined!,\n    samples: undefined!,\n    sampler: {},\n    view: undefined!,\n    flipY: undefined!\n  };\n\n  override get [Symbol.toStringTag](): string {\n    return 'Texture';\n  }\n\n  override toString(): string {\n    return `Texture(${this.id},${this.format},${this.width}x${this.height})`;\n  }\n\n  /** dimension of this texture */\n  readonly dimension: '1d' | '2d' | '2d-array' | 'cube' | 'cube-array' | '3d';\n  /** format of this texture */\n  readonly format: TextureFormat;\n  /** width in pixels of this texture */\n  width: number;\n  /** height in pixels of this texture */\n  height: number;\n  /** depth of this texture */\n  depth: number;\n  /** mip levels in this texture */\n  mipLevels: number;\n\n  /** Default sampler for this texture */\n  abstract sampler: Sampler;\n  /** Default view for this texture */\n  abstract view: TextureView;\n\n  /** \"Time\" of last update. Monotonically increasing timestamp. TODO move to AsyncTexture? */\n  updateTimestamp: number;\n\n  /** Do not use directly. Create with device.createTexture() */\n  constructor(device: Device, props: TextureProps) {\n    props = Texture.normalizeProps(device, props);\n    super(device, props, Texture.defaultProps);\n    this.dimension = this.props.dimension;\n    this.format = this.props.format;\n\n    // Size\n    this.width = this.props.width;\n    this.height = this.props.height;\n    this.depth = this.props.depth;\n\n    // Calculate size, if not provided\n    if (this.props.width === undefined || this.props.height === undefined) {\n      // @ts-ignore\n      const size = Texture.getTextureDataSize(this.props.data);\n      this.width = size?.width || 1;\n      this.height = size?.height || 1;\n    }\n\n    // mipLevels\n\n    // If mipmap generation is requested and mipLevels is not provided, initialize a full pyramid\n    if (this.props.mipmaps && this.props.mipLevels === undefined) {\n      this.props.mipLevels = 'pyramid';\n    }\n\n    // Auto-calculate the number of mip levels as a convenience\n    // TODO - Should we clamp to 1-getMipLevelCount?\n    this.mipLevels =\n      this.props.mipLevels === 'pyramid'\n        ? Texture.getMipLevelCount(this.width, this.height)\n        : this.props.mipLevels || 1;\n\n    // TODO - perhaps this should be set on async write completion?\n    this.updateTimestamp = device.incrementTimestamp();\n  }\n\n  /** Create a texture view for this texture */\n  abstract createView(props: TextureViewProps): TextureView;\n\n  /** Set sampler props associated with this texture */\n  abstract setSampler(sampler?: Sampler | SamplerProps): void;\n\n  /** Copy external image data into the texture */\n  abstract copyExternalImage(options: CopyExternalImageOptions): {width: number; height: number};\n\n  /**\n   * Create a new texture with the same parameters and optionally, a different size\n   * @note Textures are immutable and cannot be resized after creation, but we can create a similar texture with the same parameters but a new size.\n   * @note Does not copy contents of the texture\n   */\n  clone(size?: {width: number; height: number}): Texture {\n    return this.device.createTexture({...this.props, ...size});\n  }\n\n  /** Check if data is an external image */\n  static isExternalImage(data: unknown): data is ExternalImage {\n    return (\n      (typeof ImageData !== 'undefined' && data instanceof ImageData) ||\n      (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) ||\n      (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) ||\n      (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) ||\n      (typeof VideoFrame !== 'undefined' && data instanceof VideoFrame) ||\n      (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) ||\n      (typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas)\n    );\n  }\n\n  /** Determine size (width and height) of provided image data */\n  static getExternalImageSize(data: ExternalImage): {width: number; height: number} {\n    if (\n      (typeof ImageData !== 'undefined' && data instanceof ImageData) ||\n      (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) ||\n      (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) ||\n      (typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas)\n    ) {\n      return {width: data.width, height: data.height};\n    }\n    if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {\n      return {width: data.naturalWidth, height: data.naturalHeight};\n    }\n    if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {\n      return {width: data.videoWidth, height: data.videoHeight};\n    }\n    if (typeof VideoFrame !== 'undefined' && data instanceof VideoFrame) {\n      // TODO: is this the right choice for width and height?\n      return {width: data.displayWidth, height: data.displayHeight};\n    }\n    throw new Error('Unknown image type');\n  }\n\n  /** Check if texture data is a typed array */\n  static isTextureLevelData(data: TextureData): data is TextureLevelData {\n    const typedArray = (data as TextureLevelData)?.data;\n    return ArrayBuffer.isView(typedArray);\n  }\n\n  /** Get the size of the texture described by the provided TextureData */\n  static getTextureDataSize(\n    data: TextureData | TextureCubeData | TextureArrayData | TextureCubeArrayData | TypedArray\n  ): {width: number; height: number} | null {\n    if (!data) {\n      return null;\n    }\n    if (ArrayBuffer.isView(data)) {\n      return null;\n    }\n    // Recurse into arrays (array of miplevels)\n    if (Array.isArray(data)) {\n      return Texture.getTextureDataSize(data[0]);\n    }\n    if (Texture.isExternalImage(data)) {\n      return Texture.getExternalImageSize(data);\n    }\n    if (data && typeof data === 'object' && data.constructor === Object) {\n      const textureDataArray = Object.values(data) as Texture2DData[];\n      const untypedData = textureDataArray[0] as any;\n      return {width: untypedData.width, height: untypedData.height};\n    }\n    throw new Error('texture size deduction failed');\n  }\n\n  /**\n   * Normalize TextureData to an array of TextureLevelData / ExternalImages\n   * @param data\n   * @param options\n   * @returns array of TextureLevelData / ExternalImages\n   */\n  static normalizeTextureData(\n    data: Texture2DData,\n    options: {width: number; height: number; depth: number}\n  ): (TextureLevelData | ExternalImage)[] {\n    let lodArray: (TextureLevelData | ExternalImage)[];\n    if (ArrayBuffer.isView(data)) {\n      lodArray = [\n        {\n          // ts-expect-error does data really need to be Uint8ClampedArray?\n          data,\n          width: options.width,\n          height: options.height\n          // depth: options.depth\n        }\n      ];\n    } else if (!Array.isArray(data)) {\n      lodArray = [data];\n    } else {\n      lodArray = data;\n    }\n    return lodArray;\n  }\n\n  /** Calculate the number of mip levels for a texture of width and height */\n  static getMipLevelCount(width: number, height: number): number {\n    return Math.floor(Math.log2(Math.max(width, height))) + 1;\n  }\n\n  /** Convert luma.gl cubemap face constants to depth index */\n  static getCubeFaceDepth(face: TextureCubeFace): number {\n    // prettier-ignore\n    switch (face) {\n        case '+X': return  0;\n        case '-X': return  1;\n        case '+Y': return  2;\n        case '-Y': return  3;\n        case '+Z': return  4;\n        case '-Z': return  5;\n        default: throw new Error(face);\n      }\n  }\n\n  /** Default options */\n  protected static defaultCopyExternalImageOptions: Required<CopyExternalImageOptions> = {\n    image: undefined!,\n    sourceX: 0,\n    sourceY: 0,\n    width: undefined!,\n    height: undefined!,\n    depth: 1,\n    mipLevel: 0,\n    x: 0,\n    y: 0,\n    z: 0,\n    aspect: 'all',\n    colorSpace: 'srgb',\n    premultipliedAlpha: false,\n    flipY: false\n  };\n\n  /** Ensure we have integer coordinates */\n  protected static normalizeProps(device: Device, props: TextureProps): TextureProps {\n    const newProps = {...props};\n\n    // Allow device to override props (e.g. props.mipmaps)\n    const overriddenDefaultProps: Partial<TextureProps> =\n      device?.props?._resourceDefaults?.texture || {};\n    // TODO - Type issue with props.data circumvented with Object.assign\n    Object.assign(newProps, overriddenDefaultProps);\n\n    // Ensure we have integer coordinates\n    const {width, height} = newProps;\n    if (typeof width === 'number') {\n      newProps.width = Math.max(1, Math.ceil(width));\n    }\n    if (typeof height === 'number') {\n      newProps.height = Math.max(1, Math.ceil(height));\n    }\n    return newProps;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}