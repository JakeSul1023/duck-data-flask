{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { luma } from '@luma.gl/core';\nimport { requestAnimationFramePolyfill, cancelAnimationFramePolyfill } from \"./request-animation-frame.js\";\nimport { Stats } from '@probe.gl/stats';\nlet statIdCounter = 0;\nconst DEFAULT_ANIMATION_LOOP_PROPS = {\n  device: null,\n  onAddHTML: () => '',\n  onInitialize: async () => {\n    return null;\n  },\n  onRender: () => {},\n  onFinalize: () => {},\n  onError: error => console.error(error),\n  // eslint-disable-line no-console\n  stats: luma.stats.get(`animation-loop-${statIdCounter++}`),\n  // view parameters\n  useDevicePixels: true,\n  autoResizeViewport: false,\n  autoResizeDrawingBuffer: false\n};\n/** Convenient animation loop */\nexport class AnimationLoop {\n  device = null;\n  canvas = null;\n  props;\n  animationProps = null;\n  timeline = null;\n  stats;\n  cpuTime;\n  gpuTime;\n  frameRate;\n  display;\n  needsRedraw = 'initialized';\n  _initialized = false;\n  _running = false;\n  _animationFrameId = null;\n  _nextFramePromise = null;\n  _resolveNextFrame = null;\n  _cpuStartTime = 0;\n  _error = null;\n  // _gpuTimeQuery: Query | null = null;\n  /*\n   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context\n   */\n  constructor(props) {\n    this.props = {\n      ...DEFAULT_ANIMATION_LOOP_PROPS,\n      ...props\n    };\n    props = this.props;\n    if (!props.device) {\n      throw new Error('No device provided');\n    }\n    const {\n      useDevicePixels = true\n    } = this.props;\n    // state\n    this.stats = props.stats || new Stats({\n      id: 'animation-loop-stats'\n    });\n    this.cpuTime = this.stats.get('CPU Time');\n    this.gpuTime = this.stats.get('GPU Time');\n    this.frameRate = this.stats.get('Frame Rate');\n    this.setProps({\n      autoResizeViewport: props.autoResizeViewport,\n      autoResizeDrawingBuffer: props.autoResizeDrawingBuffer,\n      useDevicePixels\n    });\n    // Bind methods\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n    this._onMousemove = this._onMousemove.bind(this);\n    this._onMouseleave = this._onMouseleave.bind(this);\n  }\n  destroy() {\n    this.stop();\n    this._setDisplay(null);\n  }\n  /** @deprecated Use .destroy() */\n  delete() {\n    this.destroy();\n  }\n  setError(error) {\n    this.props.onError(error);\n    this._error = Error();\n    const canvas = this.device?.canvasContext?.canvas;\n    if (canvas instanceof HTMLCanvasElement) {\n      const errorDiv = document.createElement('h1');\n      errorDiv.innerHTML = error.message;\n      errorDiv.style.position = 'absolute';\n      errorDiv.style.top = '20%'; // left: 50%; transform: translate(-50%, -50%);';\n      errorDiv.style.left = '10px';\n      errorDiv.style.color = 'black';\n      errorDiv.style.backgroundColor = 'red';\n      document.body.appendChild(errorDiv);\n      // canvas.style.position = 'absolute';\n    }\n  }\n  /** Flags this animation loop as needing redraw */\n  setNeedsRedraw(reason) {\n    this.needsRedraw = this.needsRedraw || reason;\n    return this;\n  }\n  /** TODO - move these props to CanvasContext? */\n  setProps(props) {\n    if ('autoResizeViewport' in props) {\n      this.props.autoResizeViewport = props.autoResizeViewport || false;\n    }\n    if ('autoResizeDrawingBuffer' in props) {\n      this.props.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer || false;\n    }\n    if ('useDevicePixels' in props) {\n      this.props.useDevicePixels = props.useDevicePixels || false;\n    }\n    return this;\n  }\n  /** Starts a render loop if not already running */\n  async start() {\n    if (this._running) {\n      return this;\n    }\n    this._running = true;\n    try {\n      let appContext;\n      if (!this._initialized) {\n        this._initialized = true;\n        // Create the WebGL context\n        await this._initDevice();\n        this._initialize();\n        // Note: onIntialize can return a promise (e.g. in case app needs to load resources)\n        await this.props.onInitialize(this._getAnimationProps());\n      }\n      // check that we haven't been stopped\n      if (!this._running) {\n        return null;\n      }\n      // Start the loop\n      if (appContext !== false) {\n        // cancel any pending renders to ensure only one loop can ever run\n        this._cancelAnimationFrame();\n        this._requestAnimationFrame();\n      }\n      return this;\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.props.onError(error);\n      // this._running = false; // TODO\n      throw error;\n    }\n  }\n  /** Stops a render loop if already running, finalizing */\n  stop() {\n    // console.debug(`Stopping ${this.constructor.name}`);\n    if (this._running) {\n      // call callback\n      // If stop is called immediately, we can end up in a state where props haven't been initialized...\n      if (this.animationProps && !this._error) {\n        this.props.onFinalize(this.animationProps);\n      }\n      this._cancelAnimationFrame();\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n      this._running = false;\n    }\n    return this;\n  }\n  /** Explicitly draw a frame */\n  redraw() {\n    if (this.device?.isLost || this._error) {\n      return this;\n    }\n    this._beginFrameTimers();\n    this._setupFrame();\n    this._updateAnimationProps();\n    this._renderFrame(this._getAnimationProps());\n    // clear needsRedraw flag\n    this._clearNeedsRedraw();\n    if (this._resolveNextFrame) {\n      this._resolveNextFrame(this);\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n    }\n    this._endFrameTimers();\n    return this;\n  }\n  /** Add a timeline, it will be automatically updated by the animation loop. */\n  attachTimeline(timeline) {\n    this.timeline = timeline;\n    return this.timeline;\n  }\n  /** Remove a timeline */\n  detachTimeline() {\n    this.timeline = null;\n  }\n  /** Wait until a render completes */\n  waitForRender() {\n    this.setNeedsRedraw('waitForRender');\n    if (!this._nextFramePromise) {\n      this._nextFramePromise = new Promise(resolve => {\n        this._resolveNextFrame = resolve;\n      });\n    }\n    return this._nextFramePromise;\n  }\n  /** TODO - should use device.deviceContext */\n  async toDataURL() {\n    this.setNeedsRedraw('toDataURL');\n    await this.waitForRender();\n    if (this.canvas instanceof HTMLCanvasElement) {\n      return this.canvas.toDataURL();\n    }\n    throw new Error('OffscreenCanvas');\n  }\n  // PRIVATE METHODS\n  _initialize() {\n    this._startEventHandling();\n    // Initialize the callback data\n    this._initializeAnimationProps();\n    this._updateAnimationProps();\n    // Default viewport setup, in case onInitialize wants to render\n    this._resizeCanvasDrawingBuffer();\n    this._resizeViewport();\n    // this._gpuTimeQuery = Query.isSupported(this.gl, ['timers']) ? new Query(this.gl) : null;\n  }\n  _setDisplay(display) {\n    if (this.display) {\n      this.display.destroy();\n      this.display.animationLoop = null;\n    }\n    // store animation loop on the display\n    if (display) {\n      display.animationLoop = this;\n    }\n    this.display = display;\n  }\n  _requestAnimationFrame() {\n    if (!this._running) {\n      return;\n    }\n    // VR display has a separate animation frame to sync with headset\n    // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/\n    // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame\n    // if (this.display && this.display.requestAnimationFrame) {\n    //   this._animationFrameId = this.display.requestAnimationFrame(this._animationFrame.bind(this));\n    // }\n    this._animationFrameId = requestAnimationFramePolyfill(this._animationFrame.bind(this));\n  }\n  _cancelAnimationFrame() {\n    if (this._animationFrameId === null) {\n      return;\n    }\n    // VR display has a separate animation frame to sync with headset\n    // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/\n    // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame\n    // if (this.display && this.display.cancelAnimationFramePolyfill) {\n    //   this.display.cancelAnimationFrame(this._animationFrameId);\n    // }\n    cancelAnimationFramePolyfill(this._animationFrameId);\n    this._animationFrameId = null;\n  }\n  _animationFrame() {\n    if (!this._running) {\n      return;\n    }\n    this.redraw();\n    this._requestAnimationFrame();\n  }\n  // Called on each frame, can be overridden to call onRender multiple times\n  // to support e.g. stereoscopic rendering\n  _renderFrame(animationProps) {\n    // Allow e.g. VR display to render multiple frames.\n    if (this.display) {\n      this.display._renderFrame(animationProps);\n      return;\n    }\n    // call callback\n    this.props.onRender(this._getAnimationProps());\n    // end callback\n    // Submit commands (necessary on WebGPU)\n    this.device?.submit();\n  }\n  _clearNeedsRedraw() {\n    this.needsRedraw = false;\n  }\n  _setupFrame() {\n    this._resizeCanvasDrawingBuffer();\n    this._resizeViewport();\n  }\n  // Initialize the  object that will be passed to app callbacks\n  _initializeAnimationProps() {\n    const canvas = this.device?.canvasContext?.canvas;\n    if (!this.device || !canvas) {\n      throw new Error('loop');\n    }\n    this.animationProps = {\n      animationLoop: this,\n      device: this.device,\n      canvas,\n      timeline: this.timeline,\n      // Initial values\n      useDevicePixels: this.props.useDevicePixels,\n      needsRedraw: false,\n      // Placeholders\n      width: 1,\n      height: 1,\n      aspect: 1,\n      // Animation props\n      time: 0,\n      startTime: Date.now(),\n      engineTime: 0,\n      tick: 0,\n      tock: 0,\n      // Experimental\n      _mousePosition: null // Event props\n    };\n  }\n  _getAnimationProps() {\n    if (!this.animationProps) {\n      throw new Error('animationProps');\n    }\n    return this.animationProps;\n  }\n  // Update the context object that will be passed to app callbacks\n  _updateAnimationProps() {\n    if (!this.animationProps) {\n      return;\n    }\n    // Can this be replaced with canvas context?\n    const {\n      width,\n      height,\n      aspect\n    } = this._getSizeAndAspect();\n    if (width !== this.animationProps.width || height !== this.animationProps.height) {\n      this.setNeedsRedraw('drawing buffer resized');\n    }\n    if (aspect !== this.animationProps.aspect) {\n      this.setNeedsRedraw('drawing buffer aspect changed');\n    }\n    this.animationProps.width = width;\n    this.animationProps.height = height;\n    this.animationProps.aspect = aspect;\n    this.animationProps.needsRedraw = this.needsRedraw;\n    // Update time properties\n    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;\n    if (this.timeline) {\n      this.timeline.update(this.animationProps.engineTime);\n    }\n    this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);\n    this.animationProps.tock++;\n    // For back compatibility\n    this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;\n  }\n  /** Wait for supplied device */\n  async _initDevice() {\n    this.device = await this.props.device;\n    if (!this.device) {\n      throw new Error('No device provided');\n    }\n    this.canvas = this.device.canvasContext?.canvas || null;\n    // this._createInfoDiv();\n  }\n  _createInfoDiv() {\n    if (this.canvas && this.props.onAddHTML) {\n      const wrapperDiv = document.createElement('div');\n      document.body.appendChild(wrapperDiv);\n      wrapperDiv.style.position = 'relative';\n      const div = document.createElement('div');\n      div.style.position = 'absolute';\n      div.style.left = '10px';\n      div.style.bottom = '10px';\n      div.style.width = '300px';\n      div.style.background = 'white';\n      if (this.canvas instanceof HTMLCanvasElement) {\n        wrapperDiv.appendChild(this.canvas);\n      }\n      wrapperDiv.appendChild(div);\n      const html = this.props.onAddHTML(div);\n      if (html) {\n        div.innerHTML = html;\n      }\n    }\n  }\n  _getSizeAndAspect() {\n    if (!this.device) {\n      return {\n        width: 1,\n        height: 1,\n        aspect: 1\n      };\n    }\n    // https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n    const [width, height] = this.device?.canvasContext?.getPixelSize() || [1, 1];\n    // https://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html\n    let aspect = 1;\n    const canvas = this.device?.canvasContext?.canvas;\n    // @ts-expect-error\n    if (canvas && canvas.clientHeight) {\n      // @ts-expect-error\n      aspect = canvas.clientWidth / canvas.clientHeight;\n    } else if (width > 0 && height > 0) {\n      aspect = width / height;\n    }\n    return {\n      width,\n      height,\n      aspect\n    };\n  }\n  /** Default viewport setup */\n  _resizeViewport() {\n    // TODO can we use canvas context to code this in a portable way?\n    // @ts-expect-error Expose on canvasContext\n    if (this.props.autoResizeViewport && this.device.gl) {\n      // @ts-expect-error Expose canvasContext\n      this.device.gl.viewport(0, 0,\n      // @ts-expect-error Expose canvasContext\n      this.device.gl.drawingBufferWidth,\n      // @ts-expect-error Expose canvasContext\n      this.device.gl.drawingBufferHeight);\n    }\n  }\n  /**\n   * Resize the render buffer of the canvas to match canvas client size\n   * Optionally multiplying with devicePixel ratio\n   */\n  _resizeCanvasDrawingBuffer() {\n    if (this.props.autoResizeDrawingBuffer) {\n      this.device?.canvasContext?.resize({\n        useDevicePixels: this.props.useDevicePixels\n      });\n    }\n  }\n  _beginFrameTimers() {\n    this.frameRate.timeEnd();\n    this.frameRate.timeStart();\n    // Check if timer for last frame has completed.\n    // GPU timer results are never available in the same\n    // frame they are captured.\n    // if (\n    //   this._gpuTimeQuery &&\n    //   this._gpuTimeQuery.isResultAvailable() &&\n    //   !this._gpuTimeQuery.isTimerDisjoint()\n    // ) {\n    //   this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());\n    // }\n    // if (this._gpuTimeQuery) {\n    //   // GPU time query start\n    //   this._gpuTimeQuery.beginTimeElapsedQuery();\n    // }\n    this.cpuTime.timeStart();\n  }\n  _endFrameTimers() {\n    this.cpuTime.timeEnd();\n    // if (this._gpuTimeQuery) {\n    //   // GPU time query end. Results will be available on next frame.\n    //   this._gpuTimeQuery.end();\n    // }\n  }\n  // Event handling\n  _startEventHandling() {\n    if (this.canvas) {\n      this.canvas.addEventListener('mousemove', this._onMousemove.bind(this));\n      this.canvas.addEventListener('mouseleave', this._onMouseleave.bind(this));\n    }\n  }\n  _onMousemove(event) {\n    if (event instanceof MouseEvent) {\n      this._getAnimationProps()._mousePosition = [event.offsetX, event.offsetY];\n    }\n  }\n  _onMouseleave(event) {\n    this._getAnimationProps()._mousePosition = null;\n  }\n}\n//# sourceMappingURL=animation-loop.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}