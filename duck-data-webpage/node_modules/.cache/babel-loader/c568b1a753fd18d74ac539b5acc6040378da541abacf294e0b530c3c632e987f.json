{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ColumnLayer } from '@deck.gl/layers';\nimport { createColorRangeTexture, updateColorRangeTexture } from \"../common/utils/color-utils.js\";\nimport vs from \"./hexagon-cell-layer-vertex.glsl.js\";\nimport { hexagonUniforms } from \"./hexagon-layer-uniforms.js\";\nclass HexagonCellLayer extends ColumnLayer {\n  getShaders() {\n    const shaders = super.getShaders();\n    shaders.modules.push(hexagonUniforms);\n    return {\n      ...shaders,\n      vs\n    };\n  }\n  initializeState() {\n    super.initializeState();\n    const attributeManager = this.getAttributeManager();\n    attributeManager.remove(['instanceElevations', 'instanceFillColors', 'instanceLineColors', 'instanceStrokeWidths']);\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 2,\n        type: 'float32',\n        accessor: 'getBin'\n      },\n      instanceColorValues: {\n        size: 1,\n        type: 'float32',\n        accessor: 'getColorValue'\n      },\n      instanceElevationValues: {\n        size: 1,\n        type: 'float32',\n        accessor: 'getElevationValue'\n      }\n    });\n  }\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps\n    } = params;\n    const model = this.state.fillModel;\n    if (oldProps.colorRange !== props.colorRange) {\n      this.state.colorTexture?.destroy();\n      this.state.colorTexture = createColorRangeTexture(this.context.device, props.colorRange, props.colorScaleType);\n      const hexagonProps = {\n        colorRange: this.state.colorTexture\n      };\n      model.shaderInputs.setProps({\n        hexagon: hexagonProps\n      });\n    } else if (oldProps.colorScaleType !== props.colorScaleType) {\n      updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);\n    }\n  }\n  finalizeState(context) {\n    super.finalizeState(context);\n    this.state.colorTexture?.destroy();\n  }\n  draw({\n    uniforms\n  }) {\n    const {\n      radius,\n      hexOriginCommon,\n      elevationRange,\n      elevationScale,\n      extruded,\n      coverage,\n      colorDomain,\n      elevationDomain\n    } = this.props;\n    const colorCutoff = this.props.colorCutoff || [-Infinity, Infinity];\n    const elevationCutoff = this.props.elevationCutoff || [-Infinity, Infinity];\n    const fillModel = this.state.fillModel;\n    if (fillModel.vertexArray.indexBuffer) {\n      // indices are for drawing wireframe, disable them\n      // TODO - this should be handled in ColumnLayer?\n      fillModel.setIndexBuffer(null);\n    }\n    fillModel.setVertexCount(this.state.fillVertexCount);\n    const hexagonProps = {\n      colorDomain: [Math.max(colorDomain[0], colorCutoff[0]),\n      // instanceColorValue that maps to colorRange[0]\n      Math.min(colorDomain[1], colorCutoff[1]),\n      // instanceColorValue that maps to colorRange[colorRange.length - 1]\n      Math.max(colorDomain[0] - 1, colorCutoff[0]),\n      // hide cell if instanceColorValue is less than this\n      Math.min(colorDomain[1] + 1, colorCutoff[1]) // hide cell if instanceColorValue is greater than this\n      ],\n      elevationDomain: [Math.max(elevationDomain[0], elevationCutoff[0]),\n      // instanceElevationValue that maps to elevationRange[0]\n      Math.min(elevationDomain[1], elevationCutoff[1]),\n      // instanceElevationValue that maps to elevationRange[elevationRange.length - 1]\n      Math.max(elevationDomain[0] - 1, elevationCutoff[0]),\n      // hide cell if instanceElevationValue is less than this\n      Math.min(elevationDomain[1] + 1, elevationCutoff[1]) // hide cell if instanceElevationValue is greater than this\n      ],\n      elevationRange: [elevationRange[0] * elevationScale, elevationRange[1] * elevationScale],\n      originCommon: hexOriginCommon\n    };\n    fillModel.shaderInputs.setProps({\n      column: {\n        extruded,\n        coverage,\n        radius\n      },\n      hexagon: hexagonProps\n    });\n    fillModel.draw(this.context.renderPass);\n  }\n}\nHexagonCellLayer.layerName = 'HexagonCellLayer';\nexport default HexagonCellLayer;","map":{"version":3,"names":["ColumnLayer","createColorRangeTexture","updateColorRangeTexture","vs","hexagonUniforms","HexagonCellLayer","getShaders","shaders","modules","push","initializeState","attributeManager","getAttributeManager","remove","addInstanced","instancePositions","size","type","accessor","instanceColorValues","instanceElevationValues","updateState","params","props","oldProps","model","state","fillModel","colorRange","colorTexture","destroy","context","device","colorScaleType","hexagonProps","shaderInputs","setProps","hexagon","finalizeState","draw","uniforms","radius","hexOriginCommon","elevationRange","elevationScale","extruded","coverage","colorDomain","elevationDomain","colorCutoff","Infinity","elevationCutoff","vertexArray","indexBuffer","setIndexBuffer","setVertexCount","fillVertexCount","Math","max","min","originCommon","column","renderPass","layerName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\aggregation-layers\\src\\hexagon-layer\\hexagon-cell-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Texture} from '@luma.gl/core';\nimport {UpdateParameters, Color} from '@deck.gl/core';\nimport {ColumnLayer} from '@deck.gl/layers';\nimport {createColorRangeTexture, updateColorRangeTexture} from '../common/utils/color-utils';\nimport vs from './hexagon-cell-layer-vertex.glsl';\nimport {HexagonProps, hexagonUniforms} from './hexagon-layer-uniforms';\nimport type {ScaleType} from '../common/types';\n\n/** Proprties added by HexagonCellLayer. */\nexport type _HexagonCellLayerProps = {\n  hexOriginCommon: [number, number];\n  colorDomain: [number, number];\n  colorCutoff: [number, number] | null;\n  colorRange: Color[];\n  colorScaleType: ScaleType;\n  elevationDomain: [number, number];\n  elevationCutoff: [number, number] | null;\n  elevationRange: [number, number];\n};\n\nexport default class HexagonCellLayer<ExtraPropsT extends {} = {}> extends ColumnLayer<\n  null,\n  ExtraPropsT & Required<_HexagonCellLayerProps>\n> {\n  static layerName = 'HexagonCellLayer';\n\n  state!: ColumnLayer['state'] & {\n    colorTexture: Texture;\n  };\n\n  getShaders() {\n    const shaders = super.getShaders();\n    shaders.modules.push(hexagonUniforms);\n    return {...shaders, vs};\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.remove([\n      'instanceElevations',\n      'instanceFillColors',\n      'instanceLineColors',\n      'instanceStrokeWidths'\n    ]);\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 2,\n        type: 'float32',\n        accessor: 'getBin'\n      },\n      instanceColorValues: {\n        size: 1,\n        type: 'float32',\n        accessor: 'getColorValue'\n      },\n      instanceElevationValues: {\n        size: 1,\n        type: 'float32',\n        accessor: 'getElevationValue'\n      }\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n\n    const {props, oldProps} = params;\n    const model = this.state.fillModel!;\n\n    if (oldProps.colorRange !== props.colorRange) {\n      this.state.colorTexture?.destroy();\n      this.state.colorTexture = createColorRangeTexture(\n        this.context.device,\n        props.colorRange,\n        props.colorScaleType\n      );\n      const hexagonProps: Partial<HexagonProps> = {colorRange: this.state.colorTexture};\n      model.shaderInputs.setProps({hexagon: hexagonProps});\n    } else if (oldProps.colorScaleType !== props.colorScaleType) {\n      updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);\n    }\n  }\n\n  finalizeState(context) {\n    super.finalizeState(context);\n\n    this.state.colorTexture?.destroy();\n  }\n\n  draw({uniforms}) {\n    const {\n      radius,\n      hexOriginCommon,\n      elevationRange,\n      elevationScale,\n      extruded,\n      coverage,\n      colorDomain,\n      elevationDomain\n    } = this.props;\n    const colorCutoff = this.props.colorCutoff || [-Infinity, Infinity];\n    const elevationCutoff = this.props.elevationCutoff || [-Infinity, Infinity];\n    const fillModel = this.state.fillModel!;\n\n    if (fillModel.vertexArray.indexBuffer) {\n      // indices are for drawing wireframe, disable them\n      // TODO - this should be handled in ColumnLayer?\n      fillModel.setIndexBuffer(null);\n    }\n    fillModel.setVertexCount(this.state.fillVertexCount);\n\n    const hexagonProps: Omit<HexagonProps, 'colorRange'> = {\n      colorDomain: [\n        Math.max(colorDomain[0], colorCutoff[0]), // instanceColorValue that maps to colorRange[0]\n        Math.min(colorDomain[1], colorCutoff[1]), // instanceColorValue that maps to colorRange[colorRange.length - 1]\n        Math.max(colorDomain[0] - 1, colorCutoff[0]), // hide cell if instanceColorValue is less than this\n        Math.min(colorDomain[1] + 1, colorCutoff[1]) // hide cell if instanceColorValue is greater than this\n      ],\n      elevationDomain: [\n        Math.max(elevationDomain[0], elevationCutoff[0]), // instanceElevationValue that maps to elevationRange[0]\n        Math.min(elevationDomain[1], elevationCutoff[1]), // instanceElevationValue that maps to elevationRange[elevationRange.length - 1]\n        Math.max(elevationDomain[0] - 1, elevationCutoff[0]), // hide cell if instanceElevationValue is less than this\n        Math.min(elevationDomain[1] + 1, elevationCutoff[1]) // hide cell if instanceElevationValue is greater than this\n      ],\n      elevationRange: [elevationRange[0] * elevationScale, elevationRange[1] * elevationScale],\n      originCommon: hexOriginCommon\n    };\n\n    fillModel.shaderInputs.setProps({\n      column: {extruded, coverage, radius},\n      hexagon: hexagonProps\n    });\n    fillModel.draw(this.context.renderPass);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}