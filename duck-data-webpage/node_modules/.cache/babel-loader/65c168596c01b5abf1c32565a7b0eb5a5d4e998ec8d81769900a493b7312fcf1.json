{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBrowser } from '@probe.gl/env';\nimport { Device } from \"./device.js\";\nimport { lumaStats } from \"../utils/stats-manager.js\";\nimport { log } from \"../utils/log.js\";\nconst isPage = isBrowser() && typeof document !== 'undefined';\nconst isPageLoaded = () => isPage && document.readyState === 'complete';\nconst STARTUP_MESSAGE = 'set luma.log.level=1 (or higher) to trace rendering';\nconst ERROR_MESSAGE = 'No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.';\n/**\n * Entry point to the luma.gl GPU abstraction\n * Register WebGPU and/or WebGL adapters (controls application bundle size)\n * Run-time selection of the first available Device\n */\nexport class Luma {\n  static defaultProps = {\n    ...Device.defaultProps,\n    type: 'best-available',\n    adapters: undefined,\n    waitForPageLoad: true\n  };\n  /**\n   * Page load promise\n   * Get a 'lazy' promise that resolves when the DOM is loaded.\n   * @note Since there may be limitations on number of `load` event listeners,\n   * it is recommended avoid calling this function until actually needed.\n   * I.e. don't call it until you know that you will be looking up a string in the DOM.\n   */\n  static pageLoaded = getPageLoadPromise().then(() => {\n    log.probe(2, 'DOM is loaded')();\n  });\n  /** Global stats for all devices */\n  stats = lumaStats;\n  /**\n   * Global log\n   *\n   * Assign luma.log.level in console to control logging: \\\n   * 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs\n   * luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;\n   */\n  log = log;\n  /** Version of luma.gl */\n  VERSION =\n  // Version detection using build plugin\n  // @ts-expect-error no-undef\n  typeof \"9.1.7\" !== 'undefined' ? \"9.1.7\" : 'running from source';\n  spector;\n  preregisteredAdapters = new Map();\n  constructor() {\n    if (globalThis.luma) {\n      if (globalThis.luma.VERSION !== this.VERSION) {\n        log.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)();\n        log.error(`'yarn why @luma.gl/core' can help identify the source of the conflict`)();\n        throw new Error(`luma.gl - multiple versions detected: see console log`);\n      }\n      log.error('This version of luma.gl has already been initialized')();\n    }\n    log.log(1, `${this.VERSION} - ${STARTUP_MESSAGE}`)();\n    globalThis.luma = this;\n  }\n  registerAdapters(adapters) {\n    for (const deviceClass of adapters) {\n      this.preregisteredAdapters.set(deviceClass.type, deviceClass);\n    }\n  }\n  /** Get type strings for supported Devices */\n  getSupportedAdapters(adapters = []) {\n    const adapterMap = this.getAdapterMap(adapters);\n    return Array.from(adapterMap).map(([, adapter]) => adapter).filter(adapter => adapter.isSupported?.()).map(adapter => adapter.type);\n  }\n  /** Get type strings for best available Device */\n  getBestAvailableAdapter(adapters = []) {\n    const adapterMap = this.getAdapterMap(adapters);\n    if (adapterMap.get('webgpu')?.isSupported?.()) {\n      return 'webgpu';\n    }\n    if (adapterMap.get('webgl')?.isSupported?.()) {\n      return 'webgl';\n    }\n    return null;\n  }\n  setDefaultDeviceProps(props) {\n    Object.assign(Luma.defaultProps, props);\n  }\n  /** Creates a device. Asynchronously. */\n  async createDevice(props = {}) {\n    props = {\n      ...Luma.defaultProps,\n      ...props\n    };\n    if (props.waitForPageLoad) {\n      // || props.createCanvasContext) {\n      await Luma.pageLoaded;\n    }\n    const adapterMap = this.getAdapterMap(props.adapters);\n    let type = props.type || '';\n    if (type === 'best-available') {\n      type = this.getBestAvailableAdapter(props.adapters) || type;\n    }\n    const adapters = this.getAdapterMap(props.adapters) || adapterMap;\n    const adapter = adapters.get(type);\n    const device = await adapter?.create?.(props);\n    if (device) {\n      return device;\n    }\n    throw new Error(ERROR_MESSAGE);\n  }\n  /** Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice). */\n  async attachDevice(props) {\n    const adapters = this.getAdapterMap(props.adapters);\n    // WebGL\n    let type = '';\n    if (props.handle instanceof WebGL2RenderingContext) {\n      type = 'webgl';\n    }\n    if (props.createCanvasContext) {\n      await Luma.pageLoaded;\n    }\n    // TODO - WebGPU does not yet have a stable API\n    // if (props.handle instanceof GPUDevice) {\n    //   const WebGPUDevice = adapters.get('webgpu') as any;\n    //   if (WebGPUDevice) {\n    //     return (await WebGPUDevice.attach(props.handle)) as Device;\n    //   }\n    // }\n    // null\n    if (props.handle === null) {\n      type = 'unknown';\n    }\n    const adapter = adapters.get(type);\n    const device = await adapter?.attach?.(null);\n    if (device) {\n      return device;\n    }\n    throw new Error(ERROR_MESSAGE);\n  }\n  /**\n   * Override `HTMLCanvasContext.getCanvas()` to always create WebGL2 contexts with additional WebGL1 compatibility.\n   * Useful when attaching luma to a context from an external library does not support creating WebGL2 contexts.\n   */\n  enforceWebGL2(enforce = true, adapters = []) {\n    const adapterMap = this.getAdapterMap(adapters);\n    const webgl2Adapter = adapterMap.get('webgl');\n    if (!webgl2Adapter) {\n      log.warn('enforceWebGL2: webgl adapter not found')();\n    }\n    webgl2Adapter?.enforceWebGL2?.(enforce);\n  }\n  /** Convert a list of adapters to a map */\n  getAdapterMap(adapters = []) {\n    const map = new Map(this.preregisteredAdapters);\n    for (const adapter of adapters) {\n      map.set(adapter.type, adapter);\n    }\n    return map;\n  }\n  // DEPRECATED\n  /** @deprecated Use registerAdapters */\n  registerDevices(deviceClasses) {\n    log.warn('luma.registerDevices() is deprecated, use luma.registerAdapters() instead');\n    for (const deviceClass of deviceClasses) {\n      const adapter = deviceClass.adapter;\n      if (adapter) {\n        this.preregisteredAdapters.set(adapter.type, adapter);\n      }\n    }\n  }\n}\n/**\n * Entry point to the luma.gl GPU abstraction\n * Register WebGPU and/or WebGL adapters (controls application bundle size)\n * Run-time selection of the first available Device\n */\nexport const luma = new Luma();\n// HELPER FUNCTIONS\n/** Returns a promise that resolves when the page is loaded */\nfunction getPageLoadPromise() {\n  if (isPageLoaded() || typeof window === 'undefined') {\n    return Promise.resolve();\n  }\n  return new Promise(resolve => {\n    window.addEventListener('load', () => resolve());\n  });\n}","map":{"version":3,"names":["isBrowser","Device","lumaStats","log","isPage","document","isPageLoaded","readyState","STARTUP_MESSAGE","ERROR_MESSAGE","Luma","defaultProps","type","adapters","undefined","waitForPageLoad","pageLoaded","getPageLoadPromise","then","probe","stats","VERSION","spector","preregisteredAdapters","Map","constructor","globalThis","luma","error","Error","registerAdapters","deviceClass","set","getSupportedAdapters","adapterMap","getAdapterMap","Array","from","map","adapter","filter","isSupported","getBestAvailableAdapter","get","setDefaultDeviceProps","props","Object","assign","createDevice","device","create","attachDevice","handle","WebGL2RenderingContext","createCanvasContext","attach","enforceWebGL2","enforce","webgl2Adapter","warn","registerDevices","deviceClasses","window","Promise","resolve","addEventListener"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\core\\src\\adapter\\luma.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Log} from '@probe.gl/log';\nimport {isBrowser} from '@probe.gl/env';\nimport type {DeviceProps} from './device';\nimport {Device} from './device';\nimport {Adapter} from './adapter';\nimport {StatsManager, lumaStats} from '../utils/stats-manager';\nimport {log} from '../utils/log';\n\nconst isPage: boolean = isBrowser() && typeof document !== 'undefined';\nconst isPageLoaded: () => boolean = () => isPage && document.readyState === 'complete';\n\ndeclare global {\n  // eslint-disable-next-line no-var\n  var luma: Luma;\n}\n\nconst STARTUP_MESSAGE = 'set luma.log.level=1 (or higher) to trace rendering';\n\nconst ERROR_MESSAGE =\n  'No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.';\n\n/** Properties for creating a new device */\nexport type CreateDeviceProps = {\n  /** Selects the type of device. `best-available` uses webgpu if available, then webgl. */\n  type?: 'webgl' | 'webgpu' | 'unknown' | 'best-available';\n  /** List of adapters. Will also search any pre-registered adapters */\n  adapters?: Adapter[];\n  /** Whether to wait for page to be loaded */\n  waitForPageLoad?: boolean;\n} & DeviceProps;\n\n/** Properties for attaching an existing WebGL context or WebGPU device to a new luma Device */\nexport type AttachDeviceProps = {\n  type?: 'webgl' | 'webgpu' | 'unknown' | 'best-available';\n  /** Externally created WebGL context or WebGPU device */\n  handle: unknown; // WebGL2RenderingContext | GPUDevice | null;\n  /** List of adapters. Will also search any pre-registered adapters */\n  adapters?: Adapter[];\n} & DeviceProps;\n\n/**\n * Entry point to the luma.gl GPU abstraction\n * Register WebGPU and/or WebGL adapters (controls application bundle size)\n * Run-time selection of the first available Device\n */\nexport class Luma {\n  static defaultProps: Required<CreateDeviceProps> = {\n    ...Device.defaultProps,\n    type: 'best-available',\n    adapters: undefined!,\n    waitForPageLoad: true\n  };\n\n  /**\n   * Page load promise\n   * Get a 'lazy' promise that resolves when the DOM is loaded.\n   * @note Since there may be limitations on number of `load` event listeners,\n   * it is recommended avoid calling this function until actually needed.\n   * I.e. don't call it until you know that you will be looking up a string in the DOM.\n   */\n  static pageLoaded: Promise<void> = getPageLoadPromise().then(() => {\n    log.probe(2, 'DOM is loaded')();\n  });\n\n  /** Global stats for all devices */\n  readonly stats: StatsManager = lumaStats;\n\n  /**\n   * Global log\n   *\n   * Assign luma.log.level in console to control logging: \\\n   * 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs\n   * luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;\n   */\n  readonly log: Log = log;\n\n  /** Version of luma.gl */\n  readonly VERSION: string =\n    // Version detection using build plugin\n    // @ts-expect-error no-undef\n    typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'running from source';\n\n  spector: unknown;\n\n  protected preregisteredAdapters = new Map<string, Adapter>();\n\n  constructor() {\n    if (globalThis.luma) {\n      if (globalThis.luma.VERSION !== this.VERSION) {\n        log.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)();\n        log.error(`'yarn why @luma.gl/core' can help identify the source of the conflict`)();\n        throw new Error(`luma.gl - multiple versions detected: see console log`);\n      }\n\n      log.error('This version of luma.gl has already been initialized')();\n    }\n\n    log.log(1, `${this.VERSION} - ${STARTUP_MESSAGE}`)();\n\n    globalThis.luma = this;\n  }\n\n  registerAdapters(adapters: Adapter[]): void {\n    for (const deviceClass of adapters) {\n      this.preregisteredAdapters.set(deviceClass.type, deviceClass);\n    }\n  }\n\n  /** Get type strings for supported Devices */\n  getSupportedAdapters(adapters: Adapter[] = []): string[] {\n    const adapterMap = this.getAdapterMap(adapters);\n    return Array.from(adapterMap)\n      .map(([, adapter]) => adapter)\n      .filter(adapter => adapter.isSupported?.())\n      .map(adapter => adapter.type);\n  }\n\n  /** Get type strings for best available Device */\n  getBestAvailableAdapter(adapters: Adapter[] = []): 'webgpu' | 'webgl' | null {\n    const adapterMap = this.getAdapterMap(adapters);\n    if (adapterMap.get('webgpu')?.isSupported?.()) {\n      return 'webgpu';\n    }\n    if (adapterMap.get('webgl')?.isSupported?.()) {\n      return 'webgl';\n    }\n    return null;\n  }\n\n  setDefaultDeviceProps(props: CreateDeviceProps): void {\n    Object.assign(Luma.defaultProps, props);\n  }\n\n  /** Creates a device. Asynchronously. */\n  async createDevice(props: CreateDeviceProps = {}): Promise<Device> {\n    props = {...Luma.defaultProps, ...props};\n\n    if (props.waitForPageLoad) {\n      // || props.createCanvasContext) {\n      await Luma.pageLoaded;\n    }\n\n    const adapterMap = this.getAdapterMap(props.adapters);\n\n    let type: string = props.type || '';\n    if (type === 'best-available') {\n      type = this.getBestAvailableAdapter(props.adapters) || type;\n    }\n\n    const adapters = this.getAdapterMap(props.adapters) || adapterMap;\n\n    const adapter = adapters.get(type);\n    const device = await adapter?.create?.(props);\n    if (device) {\n      return device;\n    }\n\n    throw new Error(ERROR_MESSAGE);\n  }\n\n  /** Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice). */\n  async attachDevice(props: AttachDeviceProps): Promise<Device> {\n    const adapters = this.getAdapterMap(props.adapters);\n\n    // WebGL\n    let type = '';\n    if (props.handle instanceof WebGL2RenderingContext) {\n      type = 'webgl';\n    }\n\n    if (props.createCanvasContext) {\n      await Luma.pageLoaded;\n    }\n\n    // TODO - WebGPU does not yet have a stable API\n    // if (props.handle instanceof GPUDevice) {\n    //   const WebGPUDevice = adapters.get('webgpu') as any;\n    //   if (WebGPUDevice) {\n    //     return (await WebGPUDevice.attach(props.handle)) as Device;\n    //   }\n    // }\n\n    // null\n    if (props.handle === null) {\n      type = 'unknown';\n    }\n\n    const adapter = adapters.get(type);\n    const device = await adapter?.attach?.(null);\n    if (device) {\n      return device;\n    }\n\n    throw new Error(ERROR_MESSAGE);\n  }\n\n  /**\n   * Override `HTMLCanvasContext.getCanvas()` to always create WebGL2 contexts with additional WebGL1 compatibility.\n   * Useful when attaching luma to a context from an external library does not support creating WebGL2 contexts.\n   */\n  enforceWebGL2(enforce: boolean = true, adapters: Adapter[] = []): void {\n    const adapterMap = this.getAdapterMap(adapters);\n    const webgl2Adapter = adapterMap.get('webgl');\n    if (!webgl2Adapter) {\n      log.warn('enforceWebGL2: webgl adapter not found')();\n    }\n    (webgl2Adapter as any)?.enforceWebGL2?.(enforce);\n  }\n\n  /** Convert a list of adapters to a map */\n  protected getAdapterMap(adapters: Adapter[] = []): Map<string, Adapter> {\n    const map = new Map(this.preregisteredAdapters);\n    for (const adapter of adapters) {\n      map.set(adapter.type, adapter);\n    }\n    return map;\n  }\n\n  // DEPRECATED\n\n  /** @deprecated Use registerAdapters */\n  registerDevices(deviceClasses: any[]): void {\n    log.warn('luma.registerDevices() is deprecated, use luma.registerAdapters() instead');\n    for (const deviceClass of deviceClasses) {\n      const adapter = deviceClass.adapter as Adapter;\n      if (adapter) {\n        this.preregisteredAdapters.set(adapter.type, adapter);\n      }\n    }\n  }\n}\n\n/**\n * Entry point to the luma.gl GPU abstraction\n * Register WebGPU and/or WebGL adapters (controls application bundle size)\n * Run-time selection of the first available Device\n */\nexport const luma = new Luma();\n\n// HELPER FUNCTIONS\n\n/** Returns a promise that resolves when the page is loaded */\nfunction getPageLoadPromise(): Promise<void> {\n  if (isPageLoaded() || typeof window === 'undefined') {\n    return Promise.resolve();\n  }\n  return new Promise(resolve => {\n    window.addEventListener('load', () => resolve());\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}