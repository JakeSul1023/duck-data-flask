{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT AND ISC\n// Copyright (c) vis.gl contributors\n// Based on https://github.com/mapbox/geojson-vt under compatible ISC license\nimport { log } from '@loaders.gl/loader-utils';\nimport { deduceTableSchema } from '@loaders.gl/schema';\nimport { Stats, Stat } from '@probe.gl/stats';\nimport { createProtoTile } from \"./lib/vector-tiler/proto-tile.js\";\nimport { transformTile } from \"./lib/vector-tiler/transform-tile.js\"; // coordinate transformation\nimport { convertTileToGeoJSON } from \"./lib/vector-tiler/tile-to-geojson.js\"; // tile clipping and wrapping\nimport { convertFeaturesToProtoFeature } from \"./lib/vector-tiler/features/convert-feature.js\";\nimport { clipFeatures } from \"./lib/vector-tiler/features/clip-features.js\"; // stripe clipping algorithm\nimport { wrapFeatures } from \"./lib/vector-tiler/features/wrap-features.js\"; // date line processing\n/** Options to configure tiling */\nexport const TableTileSource = {\n  name: 'TableTiler',\n  id: 'table-tiler',\n  version: '0.0.0',\n  extensions: ['mvt'],\n  mimeTypes: ['application/octet-stream'],\n  options: {\n    table: {\n      coordinates: 'local',\n      promoteId: undefined,\n      maxZoom: 14,\n      indexMaxZoom: 5,\n      maxPointsPerTile: 10000,\n      tolerance: 3,\n      extent: 4096,\n      buffer: 64,\n      generateId: undefined\n    }\n  },\n  type: 'table',\n  testURL: url => url.endsWith('.geojson'),\n  createDataSource(url, options) {\n    const needsLoading = typeof url === 'string' || url instanceof Blob;\n    const loader = options?.table?.loaders?.[0];\n    const tablePromise = needsLoading ? loadTable(url, loader) : url;\n    return new DynamicVectorTileSource(tablePromise, options);\n  }\n  // @ts-expect-error\n};\nasync function loadTable(url, loader) {\n  if (typeof url === 'string') {\n    const response = await fetch(url);\n    const data = await response.arrayBuffer();\n    return await loader.parse(data);\n  }\n  const data = await url.arrayBuffer();\n  return await loader.parse(data); //  options.loaders, options.loadOptions)\n}\n/**\n * Dynamically vector tiles a table (the table needs a geometry column)\n * - Tiles are generated when requested.\n * - Each tile contains a tables of clipped features.\n *\n * @note - Currently only accepts `GeoJSONTable` tables\n * @note - Currently only outputs `GeoJSONTable`\n * @note - (can be initialized with a promise that resolves to GeoJSONTable).\n *\n * @todo - metadata should scan all rows to determine schema\n * @todo - metadata scan all rows to determine tilestats (field values[] etc).\n * @todo - handle binary input tables\n * @todo - generate binary output tables\n * @todo - how does TileSourceLayer specify coordinates / decided which layer to render with\n */\nexport class DynamicVectorTileSource {\n  /** Global stats for all DynamicVectorTileSources */\n  static stats = new Stats({\n    id: 'table-tile-source-all',\n    stats: [new Stat('count', 'tiles'), new Stat('count', 'features')]\n  });\n  /** Stats for this DynamicVectorTileSource */\n  stats = new Stats({\n    id: 'table-tile-source',\n    stats: [new Stat('tiles', 'count'), new Stat('features', 'count')]\n  });\n  /** MIME type of the tiles emitted by this tile source */\n  mimeType = 'application/vnd.mapbox-vector-tile';\n  localCoordinates = true;\n  /** The props that this tile source was created with */\n  // @ts-expect-error\n  props;\n  /* Schema of the data */\n  schema = null;\n  /** Map of generated tiles, indexed by stringified tile coordinates */\n  tiles = {};\n  /** Array of tile coordinates */\n  tileCoords = [];\n  /** Input data has loaded, initial top-level tiling is done, sync methods can now be called */\n  ready;\n  /** Metadata for the tile source (generated TileJSON/tilestats */\n  metadata;\n  constructor(table, props) {\n    // @ts-expect-error\n    this.props = {\n      ...TableTileSource.options.table,\n      ...props?.table\n    };\n    this.getTileData = this.getTileData.bind(this);\n    this.ready = this.initializeTilesAsync(table);\n    this.metadata = this.getMetadata();\n  }\n  async initializeTilesAsync(tablePromise) {\n    const table = await tablePromise;\n    this.schema = deduceTableSchema(table);\n    this.createRootTiles(table);\n  }\n  async getMetadata() {\n    await this.ready;\n    return {\n      schema: this.schema,\n      minZoom: 0,\n      maxZoom: this.props.maxZoom\n    };\n  }\n  async getSchema() {\n    await this.ready;\n    return this.schema;\n  }\n  /**\n   * Get a tile at the specified index\n   * @param tileIndex z, x, y of tile\n   * @returns\n   */\n  async getVectorTile(tileIndex) {\n    await this.ready;\n    const table = this.getTileSync(tileIndex);\n    log.info(2, 'getVectorTile', tileIndex, table)();\n    return table;\n  }\n  async getTile(tileIndex) {\n    await this.ready;\n    return this.getTileSync(tileIndex);\n  }\n  async getTileData(tileParams) {\n    const {\n      x,\n      y,\n      z\n    } = tileParams.index;\n    const tile = await this.getVectorTile({\n      x,\n      y,\n      z\n    });\n    return tile?.features || [];\n  }\n  // Implementation\n  /**\n   * Synchronously request a tile\n   * @note Application must await `source.ready` before calling sync methods.\n   */\n  getTileSync(tileIndex) {\n    const protoTile = this.getProtoTile(tileIndex);\n    if (!protoTile) {\n      return null;\n    }\n    return convertTileToGeoJSON(protoTile, {\n      coordinates: this.props.coordinates,\n      tileIndex,\n      extent: this.props.extent\n    });\n  }\n  /**\n   * Create the initial tiles\n   * @note the tiles stores all the features together with additional data\n   */\n  createRootTiles(table) {\n    if (this.props.maxZoom < 0 || this.props.maxZoom > 24) {\n      throw new Error('maxZoom should be in the 0-24 range');\n    }\n    if (this.props.promoteId && this.props.generateId) {\n      throw new Error('promoteId and generateId cannot be used together.');\n    }\n    log.log(1, 'DynamicVectorTileSource creating root tiles', this.props)();\n    // projects and adds simplification info\n    log.time(1, 'preprocess table')();\n    let features = convertFeaturesToProtoFeature(table, this.props);\n    log.timeEnd(1, 'preprocess table')();\n    // wraps features (ie extreme west and extreme east)\n    log.time(1, 'generate tiles')();\n    features = wrapFeatures(features, this.props);\n    // start slicing from the top tile down\n    if (features.length === 0) {\n      log.log(1, 'DynamicVectorTileSource: no features generated')();\n      return;\n    }\n    this.splitTile(features, 0, 0, 0);\n    const rootTile = this.tiles[0];\n    log.log(1, `root tile features: ${rootTile.numFeatures}, points: ${rootTile.numPoints}`)();\n    log.timeEnd(1, 'generate tiles')();\n    log.log(1, `DynamicVectorTileSource: tiles generated: ${this.stats.get('total').count}`, this.stats)();\n  }\n  /**\n   * Return geojsonvt-style \"half formed\" vector tile\n   * @note Application must await `source.ready` before calling sync methods.\n   */\n  // eslint-disable-next-line complexity, max-statements\n  getProtoTile(tileIndex) {\n    const {\n      z,\n      y\n    } = tileIndex;\n    let {\n      x\n    } = tileIndex;\n    // z = +z;\n    // x = +x;\n    // y = +y;\n    const {\n      extent\n    } = this.props;\n    if (z < 0 || z > 24) {\n      return null;\n    }\n    const z2 = 1 << z;\n    x = x + z2 & z2 - 1; // wrapFeatures tile x coordinate\n    const id = toID(z, x, y);\n    if (this.tiles[id]) {\n      return transformTile(this.tiles[id], extent);\n    }\n    log.log(log, 'drilling down to z%d-%d-%d', z, x, y)();\n    let z0 = z;\n    let x0 = x;\n    let y0 = y;\n    let parent;\n    while (!parent && z0 > 0) {\n      z0--;\n      x0 = x0 >> 1;\n      y0 = y0 >> 1;\n      parent = this.tiles[toID(z0, x0, y0)];\n    }\n    if (!parent || !parent.sourceFeatures) {\n      return null;\n    }\n    // if we found a parent tile containing the original geometry, we can drill down from it\n    log.log(1, 'found parent tile z%d-%d-%d', z0, x0, y0)();\n    log.time(1, 'drilling down')();\n    this.splitTile(parent.sourceFeatures, z0, x0, y0, z, x, y);\n    log.timeEnd(1, 'drilling down')();\n    return this.tiles[id] ? transformTile(this.tiles[id], extent) : null;\n  }\n  /**\n   * splits features from a parent tile to sub-tiles.\n   * @param z, x, and y are the coordinates of the parent tile\n   * @param cz, cx, and cy are the coordinates of the target tile\n   *\n   * If no target tile is specified, splitting stops when we reach the maximum\n   * zoom or the number of points is low as specified in the props.\n   */\n  // eslint-disable-next-line max-params, max-statements, complexity\n  splitTile(features, z, x, y, cz, cx, cy) {\n    const stack = [features, z, x, y];\n    // avoid recursion by using a processing queue\n    while (stack.length) {\n      y = stack.pop();\n      x = stack.pop();\n      z = stack.pop();\n      features = stack.pop();\n      const z2 = 1 << z;\n      const id = toID(z, x, y);\n      let tile = this.tiles[id];\n      if (!tile) {\n        log.time(2, 'tile creation')();\n        tile = this.tiles[id] = createProtoTile(features, z, x, y, this.props);\n        this.tileCoords.push({\n          z,\n          x,\n          y\n        });\n        const key = `z${z}`;\n        let stat = this.stats.get(key, 'count');\n        stat.incrementCount();\n        stat = this.stats.get('total');\n        stat.incrementCount();\n        stat = DynamicVectorTileSource.stats.get(key, 'count');\n        stat.incrementCount();\n        stat = DynamicVectorTileSource.stats.get('total');\n        stat.incrementCount();\n        log.log(2, 'tile z%d-%d-%d (features: %d, points: %d, simplified: %d)', z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified)();\n        log.timeEnd(2, 'tile creation')();\n      }\n      // save reference to original geometry in tile so that we can drill down later if we stop now\n      tile.sourceFeatures = features;\n      /* eslint-disable no-continue */\n      // if it's the first-pass tiling\n      if (cz === undefined) {\n        // stop tiling if we reached max zoom, or if the tile is too simple\n        if (z === this.props.indexMaxZoom || tile.numPoints <= this.props.maxPointsPerTile) {\n          continue;\n        }\n        // if a drilldown to a specific tile\n      } else if (z === this.props.maxZoom || z === cz) {\n        // stop tiling if we reached base zoom or our target tile zoom\n        continue;\n      } else if (cz !== undefined) {\n        // stop tiling if it's not an ancestor of the target tile\n        const zoomSteps = cz - z;\n        // @ts-expect-error TODO fix the types of cx cy\n        if (x !== cx >> zoomSteps || y !== cy >> zoomSteps) {\n          continue;\n        }\n      }\n      // if we slice further down, no need to keep source geometry\n      tile.sourceFeatures = null;\n      if (features.length === 0) continue;\n      log.time(2, 'clipping tile')();\n      // values we'll use for clipping\n      const k1 = 0.5 * this.props.buffer / this.props.extent;\n      const k2 = 0.5 - k1;\n      const k3 = 0.5 + k1;\n      const k4 = 1 + k1;\n      let tl = null;\n      let bl = null;\n      let tr = null;\n      let br = null;\n      let left = clipFeatures(features, z2, x - k1, x + k3, 0, tile.minX, tile.maxX, this.props);\n      let right = clipFeatures(features, z2, x + k2, x + k4, 0, tile.minX, tile.maxX, this.props);\n      // @ts-expect-error - unclear why this is needed?\n      features = null;\n      if (left) {\n        tl = clipFeatures(left, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, this.props);\n        bl = clipFeatures(left, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, this.props);\n        left = null;\n      }\n      if (right) {\n        tr = clipFeatures(right, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, this.props);\n        br = clipFeatures(right, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, this.props);\n        right = null;\n      }\n      log.timeEnd(2, 'clipping tile')();\n      stack.push(tl || [], z + 1, x * 2, y * 2);\n      stack.push(bl || [], z + 1, x * 2, y * 2 + 1);\n      stack.push(tr || [], z + 1, x * 2 + 1, y * 2);\n      stack.push(br || [], z + 1, x * 2 + 1, y * 2 + 1);\n    }\n  }\n}\nfunction toID(z, x, y) {\n  return ((1 << z) * y + x) * 32 + z;\n}\n/*\n\n// eslint-disable-next-line max-statements, complexity\nfunction convertToGeoJSONTable(\n  vtTile: ProtoTile,\n  props: {\n    coordinates: 'local' | 'wgs84' | 'EPSG:4326';\n    tileIndex: {x: number; y: number; z: number};\n    extent: number;\n  }\n): GeoJSONTable | null {\n  const features: Feature[] = [];\n  for (const rawFeature of vtTile.features) {\n    if (!rawFeature || !rawFeature.geometry) {\n      continue;\n    }\n\n    let type:\n      | 'Point'\n      | 'MultiPoint'\n      | 'LineString'\n      | 'MultiLineString'\n      | 'Polygon'\n      | 'MultiPolygon';\n\n    let coordinates: any;\n\n    // raw geometry\n    switch (rawFeature.type) {\n      case 1:\n        if (rawFeature.geometry.length === 1) {\n          type = 'Point';\n          coordinates = rawFeature.geometry[0];\n        } else {\n          type = 'MultiPoint';\n          coordinates = rawFeature.geometry;\n        }\n        break;\n      case 2:\n        if (rawFeature.geometry.length === 1) {\n          type = 'LineString';\n          coordinates = rawFeature.geometry[0];\n        } else {\n          type = 'MultiLineString';\n          coordinates = rawFeature.geometry;\n        }\n        break;\n      case 3:\n        if (rawFeature.geometry.length > 1) {\n          type = 'MultiPolygon';\n          coordinates = [rawFeature.geometry];\n        } else {\n          type = 'Polygon';\n          coordinates = rawFeature.geometry;\n        }\n        break;\n      default:\n        continue;\n    }\n\n    switch (props.coordinates) {\n      case 'EPSG:4326':\n      case 'wgs84':\n        projectToLngLat(coordinates, props.tileIndex, props.extent);\n        break;\n\n      case 'local':\n        convertToLocalCoordinates(coordinates, props.extent);\n        break;\n\n      default:\n        throw new Error(`Unsupported CRS ${props.coordinates}`);\n    }\n\n    const feature: Feature = {\n      type: 'Feature',\n      geometry: {\n        type,\n        coordinates\n      },\n      properties: rawFeature.tags || {},\n      id: rawFeature.id\n    };\n\n    features.push(feature);\n  }\n\n  if (features.length === 0) {\n    return null;\n  }\n\n  const table: GeoJSONTable = {\n    shape: 'geojson-table',\n    type: 'FeatureCollection',\n    features\n  };\n\n  return table;\n}\n*/","map":{"version":3,"names":["log","deduceTableSchema","Stats","Stat","createProtoTile","transformTile","convertTileToGeoJSON","convertFeaturesToProtoFeature","clipFeatures","wrapFeatures","TableTileSource","name","id","version","extensions","mimeTypes","options","table","coordinates","promoteId","undefined","maxZoom","indexMaxZoom","maxPointsPerTile","tolerance","extent","buffer","generateId","type","testURL","url","endsWith","createDataSource","needsLoading","Blob","loader","loaders","tablePromise","loadTable","DynamicVectorTileSource","response","fetch","data","arrayBuffer","parse","stats","mimeType","localCoordinates","props","schema","tiles","tileCoords","ready","metadata","constructor","getTileData","bind","initializeTilesAsync","getMetadata","createRootTiles","minZoom","getSchema","getVectorTile","tileIndex","getTileSync","info","getTile","tileParams","x","y","z","index","tile","features","protoTile","getProtoTile","Error","time","timeEnd","length","splitTile","rootTile","numFeatures","numPoints","get","count","z2","toID","z0","x0","y0","parent","sourceFeatures","cz","cx","cy","stack","pop","push","key","stat","incrementCount","numSimplified","zoomSteps","k1","k2","k3","k4","tl","bl","tr","br","left","minX","maxX","right","minY","maxY"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/mvt/dist/table-tile-source.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT AND ISC\n// Copyright (c) vis.gl contributors\n// Based on https://github.com/mapbox/geojson-vt under compatible ISC license\nimport { log } from '@loaders.gl/loader-utils';\nimport { deduceTableSchema } from '@loaders.gl/schema';\nimport { Stats, Stat } from '@probe.gl/stats';\nimport { createProtoTile } from \"./lib/vector-tiler/proto-tile.js\";\nimport { transformTile } from \"./lib/vector-tiler/transform-tile.js\"; // coordinate transformation\nimport { convertTileToGeoJSON } from \"./lib/vector-tiler/tile-to-geojson.js\"; // tile clipping and wrapping\nimport { convertFeaturesToProtoFeature } from \"./lib/vector-tiler/features/convert-feature.js\";\nimport { clipFeatures } from \"./lib/vector-tiler/features/clip-features.js\"; // stripe clipping algorithm\nimport { wrapFeatures } from \"./lib/vector-tiler/features/wrap-features.js\"; // date line processing\n/** Options to configure tiling */\nexport const TableTileSource = {\n    name: 'TableTiler',\n    id: 'table-tiler',\n    version: '0.0.0',\n    extensions: ['mvt'],\n    mimeTypes: ['application/octet-stream'],\n    options: {\n        table: {\n            coordinates: 'local',\n            promoteId: undefined,\n            maxZoom: 14,\n            indexMaxZoom: 5,\n            maxPointsPerTile: 10000,\n            tolerance: 3,\n            extent: 4096,\n            buffer: 64,\n            generateId: undefined\n        }\n    },\n    type: 'table',\n    testURL: (url) => url.endsWith('.geojson'),\n    createDataSource(url, options) {\n        const needsLoading = typeof url === 'string' || url instanceof Blob;\n        const loader = options?.table?.loaders?.[0];\n        const tablePromise = needsLoading ? loadTable(url, loader) : url;\n        return new DynamicVectorTileSource(tablePromise, options);\n    }\n    // @ts-expect-error\n};\nasync function loadTable(url, loader) {\n    if (typeof url === 'string') {\n        const response = await fetch(url);\n        const data = await response.arrayBuffer();\n        return (await loader.parse(data));\n    }\n    const data = await url.arrayBuffer();\n    return (await loader.parse(data)); //  options.loaders, options.loadOptions)\n}\n/**\n * Dynamically vector tiles a table (the table needs a geometry column)\n * - Tiles are generated when requested.\n * - Each tile contains a tables of clipped features.\n *\n * @note - Currently only accepts `GeoJSONTable` tables\n * @note - Currently only outputs `GeoJSONTable`\n * @note - (can be initialized with a promise that resolves to GeoJSONTable).\n *\n * @todo - metadata should scan all rows to determine schema\n * @todo - metadata scan all rows to determine tilestats (field values[] etc).\n * @todo - handle binary input tables\n * @todo - generate binary output tables\n * @todo - how does TileSourceLayer specify coordinates / decided which layer to render with\n */\nexport class DynamicVectorTileSource {\n    /** Global stats for all DynamicVectorTileSources */\n    static stats = new Stats({\n        id: 'table-tile-source-all',\n        stats: [new Stat('count', 'tiles'), new Stat('count', 'features')]\n    });\n    /** Stats for this DynamicVectorTileSource */\n    stats = new Stats({\n        id: 'table-tile-source',\n        stats: [new Stat('tiles', 'count'), new Stat('features', 'count')]\n    });\n    /** MIME type of the tiles emitted by this tile source */\n    mimeType = 'application/vnd.mapbox-vector-tile';\n    localCoordinates = true;\n    /** The props that this tile source was created with */\n    // @ts-expect-error\n    props;\n    /* Schema of the data */\n    schema = null;\n    /** Map of generated tiles, indexed by stringified tile coordinates */\n    tiles = {};\n    /** Array of tile coordinates */\n    tileCoords = [];\n    /** Input data has loaded, initial top-level tiling is done, sync methods can now be called */\n    ready;\n    /** Metadata for the tile source (generated TileJSON/tilestats */\n    metadata;\n    constructor(table, props) {\n        // @ts-expect-error\n        this.props = { ...TableTileSource.options.table, ...props?.table };\n        this.getTileData = this.getTileData.bind(this);\n        this.ready = this.initializeTilesAsync(table);\n        this.metadata = this.getMetadata();\n    }\n    async initializeTilesAsync(tablePromise) {\n        const table = await tablePromise;\n        this.schema = deduceTableSchema(table);\n        this.createRootTiles(table);\n    }\n    async getMetadata() {\n        await this.ready;\n        return { schema: this.schema, minZoom: 0, maxZoom: this.props.maxZoom };\n    }\n    async getSchema() {\n        await this.ready;\n        return this.schema;\n    }\n    /**\n     * Get a tile at the specified index\n     * @param tileIndex z, x, y of tile\n     * @returns\n     */\n    async getVectorTile(tileIndex) {\n        await this.ready;\n        const table = this.getTileSync(tileIndex);\n        log.info(2, 'getVectorTile', tileIndex, table)();\n        return table;\n    }\n    async getTile(tileIndex) {\n        await this.ready;\n        return this.getTileSync(tileIndex);\n    }\n    async getTileData(tileParams) {\n        const { x, y, z } = tileParams.index;\n        const tile = await this.getVectorTile({ x, y, z });\n        return tile?.features || [];\n    }\n    // Implementation\n    /**\n     * Synchronously request a tile\n     * @note Application must await `source.ready` before calling sync methods.\n     */\n    getTileSync(tileIndex) {\n        const protoTile = this.getProtoTile(tileIndex);\n        if (!protoTile) {\n            return null;\n        }\n        return convertTileToGeoJSON(protoTile, {\n            coordinates: this.props.coordinates,\n            tileIndex,\n            extent: this.props.extent\n        });\n    }\n    /**\n     * Create the initial tiles\n     * @note the tiles stores all the features together with additional data\n     */\n    createRootTiles(table) {\n        if (this.props.maxZoom < 0 || this.props.maxZoom > 24) {\n            throw new Error('maxZoom should be in the 0-24 range');\n        }\n        if (this.props.promoteId && this.props.generateId) {\n            throw new Error('promoteId and generateId cannot be used together.');\n        }\n        log.log(1, 'DynamicVectorTileSource creating root tiles', this.props)();\n        // projects and adds simplification info\n        log.time(1, 'preprocess table')();\n        let features = convertFeaturesToProtoFeature(table, this.props);\n        log.timeEnd(1, 'preprocess table')();\n        // wraps features (ie extreme west and extreme east)\n        log.time(1, 'generate tiles')();\n        features = wrapFeatures(features, this.props);\n        // start slicing from the top tile down\n        if (features.length === 0) {\n            log.log(1, 'DynamicVectorTileSource: no features generated')();\n            return;\n        }\n        this.splitTile(features, 0, 0, 0);\n        const rootTile = this.tiles[0];\n        log.log(1, `root tile features: ${rootTile.numFeatures}, points: ${rootTile.numPoints}`)();\n        log.timeEnd(1, 'generate tiles')();\n        log.log(1, `DynamicVectorTileSource: tiles generated: ${this.stats.get('total').count}`, this.stats)();\n    }\n    /**\n     * Return geojsonvt-style \"half formed\" vector tile\n     * @note Application must await `source.ready` before calling sync methods.\n     */\n    // eslint-disable-next-line complexity, max-statements\n    getProtoTile(tileIndex) {\n        const { z, y } = tileIndex;\n        let { x } = tileIndex;\n        // z = +z;\n        // x = +x;\n        // y = +y;\n        const { extent } = this.props;\n        if (z < 0 || z > 24) {\n            return null;\n        }\n        const z2 = 1 << z;\n        x = (x + z2) & (z2 - 1); // wrapFeatures tile x coordinate\n        const id = toID(z, x, y);\n        if (this.tiles[id]) {\n            return transformTile(this.tiles[id], extent);\n        }\n        log.log(log, 'drilling down to z%d-%d-%d', z, x, y)();\n        let z0 = z;\n        let x0 = x;\n        let y0 = y;\n        let parent;\n        while (!parent && z0 > 0) {\n            z0--;\n            x0 = x0 >> 1;\n            y0 = y0 >> 1;\n            parent = this.tiles[toID(z0, x0, y0)];\n        }\n        if (!parent || !parent.sourceFeatures) {\n            return null;\n        }\n        // if we found a parent tile containing the original geometry, we can drill down from it\n        log.log(1, 'found parent tile z%d-%d-%d', z0, x0, y0)();\n        log.time(1, 'drilling down')();\n        this.splitTile(parent.sourceFeatures, z0, x0, y0, z, x, y);\n        log.timeEnd(1, 'drilling down')();\n        return this.tiles[id] ? transformTile(this.tiles[id], extent) : null;\n    }\n    /**\n     * splits features from a parent tile to sub-tiles.\n     * @param z, x, and y are the coordinates of the parent tile\n     * @param cz, cx, and cy are the coordinates of the target tile\n     *\n     * If no target tile is specified, splitting stops when we reach the maximum\n     * zoom or the number of points is low as specified in the props.\n     */\n    // eslint-disable-next-line max-params, max-statements, complexity\n    splitTile(features, z, x, y, cz, cx, cy) {\n        const stack = [features, z, x, y];\n        // avoid recursion by using a processing queue\n        while (stack.length) {\n            y = stack.pop();\n            x = stack.pop();\n            z = stack.pop();\n            features = stack.pop();\n            const z2 = 1 << z;\n            const id = toID(z, x, y);\n            let tile = this.tiles[id];\n            if (!tile) {\n                log.time(2, 'tile creation')();\n                tile = this.tiles[id] = createProtoTile(features, z, x, y, this.props);\n                this.tileCoords.push({ z, x, y });\n                const key = `z${z}`;\n                let stat = this.stats.get(key, 'count');\n                stat.incrementCount();\n                stat = this.stats.get('total');\n                stat.incrementCount();\n                stat = DynamicVectorTileSource.stats.get(key, 'count');\n                stat.incrementCount();\n                stat = DynamicVectorTileSource.stats.get('total');\n                stat.incrementCount();\n                log.log(2, 'tile z%d-%d-%d (features: %d, points: %d, simplified: %d)', z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified)();\n                log.timeEnd(2, 'tile creation')();\n            }\n            // save reference to original geometry in tile so that we can drill down later if we stop now\n            tile.sourceFeatures = features;\n            /* eslint-disable no-continue */\n            // if it's the first-pass tiling\n            if (cz === undefined) {\n                // stop tiling if we reached max zoom, or if the tile is too simple\n                if (z === this.props.indexMaxZoom || tile.numPoints <= this.props.maxPointsPerTile) {\n                    continue;\n                }\n                // if a drilldown to a specific tile\n            }\n            else if (z === this.props.maxZoom || z === cz) {\n                // stop tiling if we reached base zoom or our target tile zoom\n                continue;\n            }\n            else if (cz !== undefined) {\n                // stop tiling if it's not an ancestor of the target tile\n                const zoomSteps = cz - z;\n                // @ts-expect-error TODO fix the types of cx cy\n                if (x !== cx >> zoomSteps || y !== cy >> zoomSteps) {\n                    continue;\n                }\n            }\n            // if we slice further down, no need to keep source geometry\n            tile.sourceFeatures = null;\n            if (features.length === 0)\n                continue;\n            log.time(2, 'clipping tile')();\n            // values we'll use for clipping\n            const k1 = (0.5 * this.props.buffer) / this.props.extent;\n            const k2 = 0.5 - k1;\n            const k3 = 0.5 + k1;\n            const k4 = 1 + k1;\n            let tl = null;\n            let bl = null;\n            let tr = null;\n            let br = null;\n            let left = clipFeatures(features, z2, x - k1, x + k3, 0, tile.minX, tile.maxX, this.props);\n            let right = clipFeatures(features, z2, x + k2, x + k4, 0, tile.minX, tile.maxX, this.props);\n            // @ts-expect-error - unclear why this is needed?\n            features = null;\n            if (left) {\n                tl = clipFeatures(left, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, this.props);\n                bl = clipFeatures(left, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, this.props);\n                left = null;\n            }\n            if (right) {\n                tr = clipFeatures(right, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, this.props);\n                br = clipFeatures(right, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, this.props);\n                right = null;\n            }\n            log.timeEnd(2, 'clipping tile')();\n            stack.push(tl || [], z + 1, x * 2, y * 2);\n            stack.push(bl || [], z + 1, x * 2, y * 2 + 1);\n            stack.push(tr || [], z + 1, x * 2 + 1, y * 2);\n            stack.push(br || [], z + 1, x * 2 + 1, y * 2 + 1);\n        }\n    }\n}\nfunction toID(z, x, y) {\n    return ((1 << z) * y + x) * 32 + z;\n}\n/*\n\n// eslint-disable-next-line max-statements, complexity\nfunction convertToGeoJSONTable(\n  vtTile: ProtoTile,\n  props: {\n    coordinates: 'local' | 'wgs84' | 'EPSG:4326';\n    tileIndex: {x: number; y: number; z: number};\n    extent: number;\n  }\n): GeoJSONTable | null {\n  const features: Feature[] = [];\n  for (const rawFeature of vtTile.features) {\n    if (!rawFeature || !rawFeature.geometry) {\n      continue;\n    }\n\n    let type:\n      | 'Point'\n      | 'MultiPoint'\n      | 'LineString'\n      | 'MultiLineString'\n      | 'Polygon'\n      | 'MultiPolygon';\n\n    let coordinates: any;\n\n    // raw geometry\n    switch (rawFeature.type) {\n      case 1:\n        if (rawFeature.geometry.length === 1) {\n          type = 'Point';\n          coordinates = rawFeature.geometry[0];\n        } else {\n          type = 'MultiPoint';\n          coordinates = rawFeature.geometry;\n        }\n        break;\n      case 2:\n        if (rawFeature.geometry.length === 1) {\n          type = 'LineString';\n          coordinates = rawFeature.geometry[0];\n        } else {\n          type = 'MultiLineString';\n          coordinates = rawFeature.geometry;\n        }\n        break;\n      case 3:\n        if (rawFeature.geometry.length > 1) {\n          type = 'MultiPolygon';\n          coordinates = [rawFeature.geometry];\n        } else {\n          type = 'Polygon';\n          coordinates = rawFeature.geometry;\n        }\n        break;\n      default:\n        continue;\n    }\n\n    switch (props.coordinates) {\n      case 'EPSG:4326':\n      case 'wgs84':\n        projectToLngLat(coordinates, props.tileIndex, props.extent);\n        break;\n\n      case 'local':\n        convertToLocalCoordinates(coordinates, props.extent);\n        break;\n\n      default:\n        throw new Error(`Unsupported CRS ${props.coordinates}`);\n    }\n\n    const feature: Feature = {\n      type: 'Feature',\n      geometry: {\n        type,\n        coordinates\n      },\n      properties: rawFeature.tags || {},\n      id: rawFeature.id\n    };\n\n    features.push(feature);\n  }\n\n  if (features.length === 0) {\n    return null;\n  }\n\n  const table: GeoJSONTable = {\n    shape: 'geojson-table',\n    type: 'FeatureCollection',\n    features\n  };\n\n  return table;\n}\n*/\n"],"mappings":"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AAC,GAAG,CAAC,EAAEF,CAAC,GAAG,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,CAAC;MAC7C2B,KAAK,CAACE,IAAI,CAACa,EAAE,IAAI,EAAE,EAAEzC,CAAC,GAAG,CAAC,EAAEF,CAAC,GAAG,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IACrD;EACJ;AACJ;AACA,SAASkB,IAAIA,CAACjB,CAAC,EAAEF,CAAC,EAAEC,CAAC,EAAE;EACnB,OAAO,CAAC,CAAC,CAAC,IAAIC,CAAC,IAAID,CAAC,GAAGD,CAAC,IAAI,EAAE,GAAGE,CAAC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}