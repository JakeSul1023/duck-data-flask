{"ast":null,"code":"import { getJSModule, registerJSModules } from '@loaders.gl/loader-utils';\nimport { Hash } from \"./hash.js\";\n/**\n * A transform that calculates Cryptographic Hash using Crypto JS library\n * @deprecated Warning, experimental class\n */\nexport class CryptoHash extends Hash {\n  name;\n  options;\n  /** Name of digest algorithm */\n  _algorithm;\n  /** CryptoJS algorithm */\n  _algo;\n  constructor(options) {\n    super();\n    this.options = options;\n    registerJSModules(options?.modules);\n    this._algorithm = this.options?.crypto?.algorithm;\n    if (!this._algorithm) {\n      throw new Error(this.name);\n    }\n    this.name = this._algorithm.toLowerCase();\n  }\n  async preload() {\n    const CryptoJS = getJSModule('CryptoJS', this.name);\n    this._algo = CryptoJS.algo[this._algorithm];\n  }\n  /**\n   * Atomic hash calculation\n   * @returns base64 encoded hash\n   */\n  async hash(input, encoding) {\n    await this.preload();\n    const hash = this._algo.create();\n    if (!hash) {\n      throw new Error(this.name);\n    }\n    const CryptoJS = getJSModule('CryptoJS', this.name);\n    // arrayBuffer is accepted, even though types and docs say no\n    // https://stackoverflow.com/questions/25567468/how-to-decrypt-an-arraybuffer\n    const typedWordArray = CryptoJS.lib.WordArray.create(input);\n    // Map our encoding constant to Crypto library\n    const enc = encoding === 'base64' ? CryptoJS.enc.Base64 : CryptoJS.enc.Hex;\n    return hash.update(typedWordArray).finalize().toString(enc);\n  }\n  async *hashBatches(asyncIterator, encoding = 'base64') {\n    await this.preload();\n    const CryptoJS = getJSModule('CryptoJS', this.name);\n    const hash = this._algo.create();\n    if (!hash) {\n      throw new Error(this.name);\n    }\n    for await (const chunk of asyncIterator) {\n      // arrayBuffer is accepted, even though types and docs say no\n      // https://stackoverflow.com/questions/25567468/how-to-decrypt-an-arraybuffer\n      const typedWordArray = CryptoJS.lib.WordArray.create(chunk);\n      hash.update(typedWordArray);\n      yield chunk;\n    }\n    // Map our encoding constant to Crypto library\n    const enc = encoding === 'base64' ? CryptoJS.enc.Base64 : CryptoJS.enc.Hex;\n    const digest = hash.finalize().toString(enc);\n    this.options?.crypto?.onEnd?.({\n      hash: digest\n    });\n  }\n}","map":{"version":3,"names":["getJSModule","registerJSModules","Hash","CryptoHash","name","options","_algorithm","_algo","constructor","modules","crypto","algorithm","Error","toLowerCase","preload","CryptoJS","algo","hash","input","encoding","create","typedWordArray","lib","WordArray","enc","Base64","Hex","update","finalize","toString","hashBatches","asyncIterator","chunk","digest","onEnd"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/crypto/dist/lib/crypto-hash.js"],"sourcesContent":["import { getJSModule, registerJSModules } from '@loaders.gl/loader-utils';\nimport { Hash } from \"./hash.js\";\n/**\n * A transform that calculates Cryptographic Hash using Crypto JS library\n * @deprecated Warning, experimental class\n */\nexport class CryptoHash extends Hash {\n    name;\n    options;\n    /** Name of digest algorithm */\n    _algorithm;\n    /** CryptoJS algorithm */\n    _algo;\n    constructor(options) {\n        super();\n        this.options = options;\n        registerJSModules(options?.modules);\n        this._algorithm = this.options?.crypto?.algorithm;\n        if (!this._algorithm) {\n            throw new Error(this.name);\n        }\n        this.name = this._algorithm.toLowerCase();\n    }\n    async preload() {\n        const CryptoJS = getJSModule('CryptoJS', this.name);\n        this._algo = CryptoJS.algo[this._algorithm];\n    }\n    /**\n     * Atomic hash calculation\n     * @returns base64 encoded hash\n     */\n    async hash(input, encoding) {\n        await this.preload();\n        const hash = this._algo.create();\n        if (!hash) {\n            throw new Error(this.name);\n        }\n        const CryptoJS = getJSModule('CryptoJS', this.name);\n        // arrayBuffer is accepted, even though types and docs say no\n        // https://stackoverflow.com/questions/25567468/how-to-decrypt-an-arraybuffer\n        const typedWordArray = CryptoJS.lib.WordArray.create(input);\n        // Map our encoding constant to Crypto library\n        const enc = encoding === 'base64' ? CryptoJS.enc.Base64 : CryptoJS.enc.Hex;\n        return hash.update(typedWordArray).finalize().toString(enc);\n    }\n    async *hashBatches(asyncIterator, encoding = 'base64') {\n        await this.preload();\n        const CryptoJS = getJSModule('CryptoJS', this.name);\n        const hash = this._algo.create();\n        if (!hash) {\n            throw new Error(this.name);\n        }\n        for await (const chunk of asyncIterator) {\n            // arrayBuffer is accepted, even though types and docs say no\n            // https://stackoverflow.com/questions/25567468/how-to-decrypt-an-arraybuffer\n            const typedWordArray = CryptoJS.lib.WordArray.create(chunk);\n            hash.update(typedWordArray);\n            yield chunk;\n        }\n        // Map our encoding constant to Crypto library\n        const enc = encoding === 'base64' ? CryptoJS.enc.Base64 : CryptoJS.enc.Hex;\n        const digest = hash.finalize().toString(enc);\n        this.options?.crypto?.onEnd?.({ hash: digest });\n    }\n}\n"],"mappings":"AAAA,SAASA,WAAW,EAAEC,iBAAiB,QAAQ,0BAA0B;AACzE,SAASC,IAAI,QAAQ,WAAW;AAChC;AACA;AACA;AACA;AACA,OAAO,MAAMC,UAAU,SAASD,IAAI,CAAC;EACjCE,IAAI;EACJC,OAAO;EACP;EACAC,UAAU;EACV;EACAC,KAAK;EACLC,WAAWA,CAACH,OAAO,EAAE;IACjB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,OAAO,GAAGA,OAAO;IACtBJ,iBAAiB,CAACI,OAAO,EAAEI,OAAO,CAAC;IACnC,IAAI,CAACH,UAAU,GAAG,IAAI,CAACD,OAAO,EAAEK,MAAM,EAAEC,SAAS;IACjD,IAAI,CAAC,IAAI,CAACL,UAAU,EAAE;MAClB,MAAM,IAAIM,KAAK,CAAC,IAAI,CAACR,IAAI,CAAC;IAC9B;IACA,IAAI,CAACA,IAAI,GAAG,IAAI,CAACE,UAAU,CAACO,WAAW,CAAC,CAAC;EAC7C;EACA,MAAMC,OAAOA,CAAA,EAAG;IACZ,MAAMC,QAAQ,GAAGf,WAAW,CAAC,UAAU,EAAE,IAAI,CAACI,IAAI,CAAC;IACnD,IAAI,CAACG,KAAK,GAAGQ,QAAQ,CAACC,IAAI,CAAC,IAAI,CAACV,UAAU,CAAC;EAC/C;EACA;AACJ;AACA;AACA;EACI,MAAMW,IAAIA,CAACC,KAAK,EAAEC,QAAQ,EAAE;IACxB,MAAM,IAAI,CAACL,OAAO,CAAC,CAAC;IACpB,MAAMG,IAAI,GAAG,IAAI,CAACV,KAAK,CAACa,MAAM,CAAC,CAAC;IAChC,IAAI,CAACH,IAAI,EAAE;MACP,MAAM,IAAIL,KAAK,CAAC,IAAI,CAACR,IAAI,CAAC;IAC9B;IACA,MAAMW,QAAQ,GAAGf,WAAW,CAAC,UAAU,EAAE,IAAI,CAACI,IAAI,CAAC;IACnD;IACA;IACA,MAAMiB,cAAc,GAAGN,QAAQ,CAACO,GAAG,CAACC,SAAS,CAACH,MAAM,CAACF,KAAK,CAAC;IAC3D;IACA,MAAMM,GAAG,GAAGL,QAAQ,KAAK,QAAQ,GAAGJ,QAAQ,CAACS,GAAG,CAACC,MAAM,GAAGV,QAAQ,CAACS,GAAG,CAACE,GAAG;IAC1E,OAAOT,IAAI,CAACU,MAAM,CAACN,cAAc,CAAC,CAACO,QAAQ,CAAC,CAAC,CAACC,QAAQ,CAACL,GAAG,CAAC;EAC/D;EACA,OAAOM,WAAWA,CAACC,aAAa,EAAEZ,QAAQ,GAAG,QAAQ,EAAE;IACnD,MAAM,IAAI,CAACL,OAAO,CAAC,CAAC;IACpB,MAAMC,QAAQ,GAAGf,WAAW,CAAC,UAAU,EAAE,IAAI,CAACI,IAAI,CAAC;IACnD,MAAMa,IAAI,GAAG,IAAI,CAACV,KAAK,CAACa,MAAM,CAAC,CAAC;IAChC,IAAI,CAACH,IAAI,EAAE;MACP,MAAM,IAAIL,KAAK,CAAC,IAAI,CAACR,IAAI,CAAC;IAC9B;IACA,WAAW,MAAM4B,KAAK,IAAID,aAAa,EAAE;MACrC;MACA;MACA,MAAMV,cAAc,GAAGN,QAAQ,CAACO,GAAG,CAACC,SAAS,CAACH,MAAM,CAACY,KAAK,CAAC;MAC3Df,IAAI,CAACU,MAAM,CAACN,cAAc,CAAC;MAC3B,MAAMW,KAAK;IACf;IACA;IACA,MAAMR,GAAG,GAAGL,QAAQ,KAAK,QAAQ,GAAGJ,QAAQ,CAACS,GAAG,CAACC,MAAM,GAAGV,QAAQ,CAACS,GAAG,CAACE,GAAG;IAC1E,MAAMO,MAAM,GAAGhB,IAAI,CAACW,QAAQ,CAAC,CAAC,CAACC,QAAQ,CAACL,GAAG,CAAC;IAC5C,IAAI,CAACnB,OAAO,EAAEK,MAAM,EAAEwB,KAAK,GAAG;MAAEjB,IAAI,EAAEgB;IAAO,CAAC,CAAC;EACnD;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}