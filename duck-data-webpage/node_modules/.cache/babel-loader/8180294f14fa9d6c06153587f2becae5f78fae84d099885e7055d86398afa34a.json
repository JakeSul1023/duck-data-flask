{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nlet channelHandles = 1;\nlet animationHandles = 1;\nexport class Timeline {\n  time = 0;\n  channels = new Map();\n  animations = new Map();\n  playing = false;\n  lastEngineTime = -1;\n  constructor() {}\n  addChannel(props) {\n    const {\n      delay = 0,\n      duration = Number.POSITIVE_INFINITY,\n      rate = 1,\n      repeat = 1\n    } = props;\n    const channelId = channelHandles++;\n    const channel = {\n      time: 0,\n      delay,\n      duration,\n      rate,\n      repeat\n    };\n    this._setChannelTime(channel, this.time);\n    this.channels.set(channelId, channel);\n    return channelId;\n  }\n  removeChannel(channelId) {\n    this.channels.delete(channelId);\n    for (const [animationHandle, animation] of this.animations) {\n      if (animation.channel === channelId) {\n        this.detachAnimation(animationHandle);\n      }\n    }\n  }\n  isFinished(channelId) {\n    const channel = this.channels.get(channelId);\n    if (channel === undefined) {\n      return false;\n    }\n    return this.time >= channel.delay + channel.duration * channel.repeat;\n  }\n  getTime(channelId) {\n    if (channelId === undefined) {\n      return this.time;\n    }\n    const channel = this.channels.get(channelId);\n    if (channel === undefined) {\n      return -1;\n    }\n    return channel.time;\n  }\n  setTime(time) {\n    this.time = Math.max(0, time);\n    const channels = this.channels.values();\n    for (const channel of channels) {\n      this._setChannelTime(channel, this.time);\n    }\n    const animations = this.animations.values();\n    for (const animationData of animations) {\n      const {\n        animation,\n        channel\n      } = animationData;\n      animation.setTime(this.getTime(channel));\n    }\n  }\n  play() {\n    this.playing = true;\n  }\n  pause() {\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n  reset() {\n    this.setTime(0);\n  }\n  attachAnimation(animation, channelHandle) {\n    const animationHandle = animationHandles++;\n    this.animations.set(animationHandle, {\n      animation,\n      channel: channelHandle\n    });\n    animation.setTime(this.getTime(channelHandle));\n    return animationHandle;\n  }\n  detachAnimation(channelId) {\n    this.animations.delete(channelId);\n  }\n  update(engineTime) {\n    if (this.playing) {\n      if (this.lastEngineTime === -1) {\n        this.lastEngineTime = engineTime;\n      }\n      this.setTime(this.time + (engineTime - this.lastEngineTime));\n      this.lastEngineTime = engineTime;\n    }\n  }\n  _setChannelTime(channel, time) {\n    const offsetTime = time - channel.delay;\n    const totalDuration = channel.duration * channel.repeat;\n    // Note(Tarek): Don't loop on final repeat.\n    if (offsetTime >= totalDuration) {\n      channel.time = channel.duration * channel.rate;\n    } else {\n      channel.time = Math.max(0, offsetTime) % channel.duration;\n      channel.time *= channel.rate;\n    }\n  }\n}\n//# sourceMappingURL=timeline.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}