{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport PickLayersPass from \"../passes/pick-layers-pass.js\";\nimport { getClosestObject, getUniqueObjects } from \"./picking/query-object.js\";\nimport { processPickInfo, getLayerPickingInfo, getEmptyPickingInfo } from \"./picking/pick-info.js\";\n/** Manages picking in a Deck context */\nexport default class DeckPicker {\n  constructor(device) {\n    this._pickable = true;\n    this.device = device;\n    this.pickLayersPass = new PickLayersPass(device);\n    this.lastPickedInfo = {\n      index: -1,\n      layerId: null,\n      info: null\n    };\n  }\n  setProps(props) {\n    if ('layerFilter' in props) {\n      this.layerFilter = props.layerFilter;\n    }\n    if ('_pickable' in props) {\n      this._pickable = props._pickable;\n    }\n  }\n  finalize() {\n    if (this.pickingFBO) {\n      this.pickingFBO.destroy();\n    }\n    if (this.depthFBO) {\n      this.depthFBO.destroy();\n    }\n  }\n  /** Pick the closest info at given coordinate */\n  pickObject(opts) {\n    return this._pickClosestObject(opts);\n  }\n  /** Get all unique infos within a bounding box */\n  pickObjects(opts) {\n    return this._pickVisibleObjects(opts);\n  }\n  // Returns a new picking info object by assuming the last picked object is still picked\n  getLastPickedObject({\n    x,\n    y,\n    layers,\n    viewports\n  }, lastPickedInfo = this.lastPickedInfo.info) {\n    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n    const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;\n    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;\n    const viewport = lastPickedViewportId && viewports.find(v => v.id === lastPickedViewportId) || viewports[0];\n    const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);\n    const info = {\n      x,\n      y,\n      viewport,\n      coordinate,\n      layer\n    };\n    return {\n      ...lastPickedInfo,\n      ...info\n    };\n  }\n  // Private\n  /** Ensures that picking framebuffer exists and matches the canvas size */\n  _resizeBuffer() {\n    // Create a frame buffer if not already available\n    if (!this.pickingFBO) {\n      this.pickingFBO = this.device.createFramebuffer({\n        colorAttachments: ['rgba8unorm'],\n        depthStencilAttachment: 'depth16unorm'\n      });\n      if (this.device.isTextureFormatRenderable('rgba32float')) {\n        const depthFBO = this.device.createFramebuffer({\n          colorAttachments: ['rgba32float'],\n          depthStencilAttachment: 'depth16unorm'\n        });\n        this.depthFBO = depthFBO;\n      }\n    }\n    // Resize it to current canvas size (this is a noop if size hasn't changed)\n    const {\n      canvas\n    } = this.device.getDefaultCanvasContext();\n    this.pickingFBO?.resize({\n      width: canvas.width,\n      height: canvas.height\n    });\n    this.depthFBO?.resize({\n      width: canvas.width,\n      height: canvas.height\n    });\n  }\n  /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */\n  _getPickable(layers) {\n    if (this._pickable === false) {\n      return null;\n    }\n    const pickableLayers = layers.filter(layer => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite);\n    return pickableLayers.length ? pickableLayers : null;\n  }\n  /** Pick the closest object at the given coordinate */\n  // eslint-disable-next-line max-statements,complexity\n  _pickClosestObject({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    radius = 0,\n    depth = 1,\n    mode = 'query',\n    unproject3D,\n    onViewportActive,\n    effects\n  }) {\n    // @ts-expect-error TODO - assuming WebGL context\n    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();\n    const pickableLayers = this._getPickable(layers);\n    if (!pickableLayers || viewports.length === 0) {\n      return {\n        result: [],\n        emptyInfo: getEmptyPickingInfo({\n          viewports,\n          x,\n          y,\n          pixelRatio\n        })\n      };\n    }\n    this._resizeBuffer();\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // Top-left coordinates [x, y] to bottom-left coordinates [deviceX, deviceY]\n    // And compensate for pixelRatio\n    // @ts-expect-error TODO - assuming WebGL context\n    const devicePixelRange = this.device.canvasContext.cssToDevicePixels([x, y], true);\n    const devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];\n    const deviceRadius = Math.round(radius * pixelRatio);\n    const {\n      width,\n      height\n    } = this.pickingFBO;\n    const deviceRect = this._getPickingRect({\n      deviceX: devicePixel[0],\n      deviceY: devicePixel[1],\n      deviceRadius,\n      deviceWidth: width,\n      deviceHeight: height\n    });\n    const cullRect = {\n      x: x - radius,\n      y: y - radius,\n      width: radius * 2 + 1,\n      height: radius * 2 + 1\n    };\n    let infos;\n    const result = [];\n    const affectedLayers = new Set();\n    for (let i = 0; i < depth; i++) {\n      let pickInfo;\n      if (deviceRect) {\n        const pickedResult = this._drawAndSample({\n          layers: pickableLayers,\n          views,\n          viewports,\n          onViewportActive,\n          deviceRect,\n          cullRect,\n          effects,\n          pass: `picking:${mode}`\n        });\n        pickInfo = getClosestObject({\n          ...pickedResult,\n          deviceX: devicePixel[0],\n          deviceY: devicePixel[1],\n          deviceRadius,\n          deviceRect\n        });\n      } else {\n        pickInfo = {\n          pickedColor: null,\n          pickedObjectIndex: -1\n        };\n      }\n      let z;\n      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n        const {\n          pickedColors: pickedColors2\n        } = this._drawAndSample({\n          layers: [pickInfo.pickedLayer],\n          views,\n          viewports,\n          onViewportActive,\n          deviceRect: {\n            x: pickInfo.pickedX,\n            y: pickInfo.pickedY,\n            width: 1,\n            height: 1\n          },\n          cullRect,\n          effects,\n          pass: `picking:${mode}:z`\n        }, true);\n        // picked value is in common space (pixels) from the camera target (viewport.position)\n        // convert it to meters from the ground\n        if (pickedColors2[3]) {\n          z = pickedColors2[0];\n        }\n      }\n      // Only exclude if we need to run picking again.\n      // We need to run picking again if an object is detected AND\n      // we have not exhausted the requested depth.\n      if (pickInfo.pickedLayer && i + 1 < depth) {\n        affectedLayers.add(pickInfo.pickedLayer);\n        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);\n      }\n      // This logic needs to run even if no object is picked.\n      infos = processPickInfo({\n        pickInfo,\n        lastPickedInfo: this.lastPickedInfo,\n        mode,\n        layers: pickableLayers,\n        viewports,\n        x,\n        y,\n        z,\n        pixelRatio\n      });\n      for (const info of infos.values()) {\n        if (info.layer) {\n          result.push(info);\n        }\n      }\n      // If no object is picked stop.\n      if (!pickInfo.pickedColor) {\n        break;\n      }\n    }\n    // reset only affected buffers\n    for (const layer of affectedLayers) {\n      layer.restorePickingColors();\n    }\n    return {\n      result,\n      emptyInfo: infos.get(null)\n    };\n  }\n  /** Pick all objects within the given bounding box */\n  _pickVisibleObjects({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    width = 1,\n    height = 1,\n    mode = 'query',\n    maxObjects = null,\n    onViewportActive,\n    effects\n  }) {\n    const pickableLayers = this._getPickable(layers);\n    if (!pickableLayers || viewports.length === 0) {\n      return [];\n    }\n    this._resizeBuffer();\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // And compensate for pixelRatio\n    // @ts-expect-error TODO - assuming WebGL context\n    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();\n    // @ts-expect-error TODO - assuming WebGL context\n    const leftTop = this.device.canvasContext.cssToDevicePixels([x, y], true);\n    // take left and top (y inverted in device pixels) from start location\n    const deviceLeft = leftTop.x;\n    const deviceTop = leftTop.y + leftTop.height;\n    // take right and bottom (y inverted in device pixels) from end location\n    // @ts-expect-error TODO - assuming WebGL context\n    const rightBottom = this.device.canvasContext.cssToDevicePixels([x + width, y + height], true);\n    const deviceRight = rightBottom.x + rightBottom.width;\n    const deviceBottom = rightBottom.y;\n    const deviceRect = {\n      x: deviceLeft,\n      y: deviceBottom,\n      // deviceTop and deviceRight represent the first pixel outside the desired rect\n      width: deviceRight - deviceLeft,\n      height: deviceTop - deviceBottom\n    };\n    const pickedResult = this._drawAndSample({\n      layers: pickableLayers,\n      views,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      cullRect: {\n        x,\n        y,\n        width,\n        height\n      },\n      effects,\n      pass: `picking:${mode}`\n    });\n    const pickInfos = getUniqueObjects(pickedResult);\n    // `getUniqueObjects` dedup by picked color\n    // However different picked color may be linked to the same picked object, e.g. stroke and fill of the same polygon\n    // picked from different sub layers of a GeoJsonLayer\n    // Here after resolving the picked index with `layer.getPickingInfo`, we need to dedup again by unique picked objects\n    const uniquePickedObjects = new Map();\n    const uniqueInfos = [];\n    const limitMaxObjects = Number.isFinite(maxObjects);\n    for (let i = 0; i < pickInfos.length; i++) {\n      if (limitMaxObjects && uniqueInfos.length >= maxObjects) {\n        break;\n      }\n      const pickInfo = pickInfos[i];\n      let info = {\n        color: pickInfo.pickedColor,\n        layer: null,\n        index: pickInfo.pickedObjectIndex,\n        picked: true,\n        x,\n        y,\n        pixelRatio\n      };\n      info = getLayerPickingInfo({\n        layer: pickInfo.pickedLayer,\n        info,\n        mode\n      });\n      // info.layer is always populated because it's a picked pixel\n      const pickedLayerId = info.layer.id;\n      if (!uniquePickedObjects.has(pickedLayerId)) {\n        uniquePickedObjects.set(pickedLayerId, new Set());\n      }\n      const uniqueObjectsInLayer = uniquePickedObjects.get(pickedLayerId);\n      // info.object may be null if the layer is using non-iterable data.\n      // Fall back to using index as identifier.\n      const pickedObjectKey = info.object ?? info.index;\n      if (!uniqueObjectsInLayer.has(pickedObjectKey)) {\n        uniqueObjectsInLayer.add(pickedObjectKey);\n        uniqueInfos.push(info);\n      }\n    }\n    return uniqueInfos;\n  }\n  _drawAndSample({\n    layers,\n    views,\n    viewports,\n    onViewportActive,\n    deviceRect,\n    cullRect,\n    effects,\n    pass\n  }, pickZ = false) {\n    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n    const opts = {\n      layers,\n      layerFilter: this.layerFilter,\n      views,\n      viewports,\n      onViewportActive,\n      pickingFBO,\n      deviceRect,\n      cullRect,\n      effects,\n      pass,\n      pickZ,\n      preRenderStats: {},\n      isPicking: true\n    };\n    for (const effect of effects) {\n      if (effect.useInPicking) {\n        opts.preRenderStats[effect.id] = effect.preRender(opts);\n      }\n    }\n    const {\n      decodePickingColor\n    } = this.pickLayersPass.render(opts);\n    // Read from an already rendered picking buffer\n    // Returns an Uint8ClampedArray of picked pixels\n    const {\n      x,\n      y,\n      width,\n      height\n    } = deviceRect;\n    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n    this.device.readPixelsToArrayWebGL(pickingFBO, {\n      sourceX: x,\n      sourceY: y,\n      sourceWidth: width,\n      sourceHeight: height,\n      target: pickedColors\n    });\n    return {\n      pickedColors,\n      decodePickingColor\n    };\n  }\n  // Calculate a picking rect centered on deviceX and deviceY and clipped to device\n  // Returns null if pixel is outside of device\n  _getPickingRect({\n    deviceX,\n    deviceY,\n    deviceRadius,\n    deviceWidth,\n    deviceHeight\n  }) {\n    // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]\n    const x = Math.max(0, deviceX - deviceRadius);\n    const y = Math.max(0, deviceY - deviceRadius);\n    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n    // x, y out of bounds.\n    if (width <= 0 || height <= 0) {\n      return null;\n    }\n    return {\n      x,\n      y,\n      width,\n      height\n    };\n  }\n}","map":{"version":3,"names":["PickLayersPass","getClosestObject","getUniqueObjects","processPickInfo","getLayerPickingInfo","getEmptyPickingInfo","DeckPicker","constructor","device","_pickable","pickLayersPass","lastPickedInfo","index","layerId","info","setProps","props","layerFilter","finalize","pickingFBO","destroy","depthFBO","pickObject","opts","_pickClosestObject","pickObjects","_pickVisibleObjects","getLastPickedObject","x","y","layers","viewports","lastPickedLayerId","layer","id","lastPickedViewportId","viewport","find","l","v","coordinate","unproject","_resizeBuffer","createFramebuffer","colorAttachments","depthStencilAttachment","isTextureFormatRenderable","canvas","getDefaultCanvasContext","resize","width","height","_getPickable","pickableLayers","filter","shouldDrawLayer","isComposite","length","views","radius","depth","mode","unproject3D","onViewportActive","effects","pixelRatio","canvasContext","cssToDeviceRatio","result","emptyInfo","devicePixelRange","cssToDevicePixels","devicePixel","Math","floor","deviceRadius","round","deviceRect","_getPickingRect","deviceX","deviceY","deviceWidth","deviceHeight","cullRect","infos","affectedLayers","Set","i","pickInfo","pickedResult","_drawAndSample","pass","pickedColor","pickedObjectIndex","z","pickedLayer","pickedColors","pickedColors2","pickedX","pickedY","add","disablePickingIndex","values","push","restorePickingColors","get","maxObjects","leftTop","deviceLeft","deviceTop","rightBottom","deviceRight","deviceBottom","pickInfos","uniquePickedObjects","Map","uniqueInfos","limitMaxObjects","Number","isFinite","color","picked","pickedLayerId","has","set","uniqueObjectsInLayer","pickedObjectKey","object","pickZ","preRenderStats","isPicking","effect","useInPicking","preRender","decodePickingColor","render","Float32Array","Uint8Array","readPixelsToArrayWebGL","sourceX","sourceY","sourceWidth","sourceHeight","target","max","min"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\lib\\deck-picker.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '@luma.gl/core';\nimport PickLayersPass, {PickingColorDecoder} from '../passes/pick-layers-pass';\nimport {getClosestObject, getUniqueObjects, PickedPixel} from './picking/query-object';\nimport {\n  processPickInfo,\n  getLayerPickingInfo,\n  getEmptyPickingInfo,\n  PickingInfo\n} from './picking/pick-info';\n\nimport type {Framebuffer} from '@luma.gl/core';\nimport type {FilterContext, Rect} from '../passes/layers-pass';\nimport type Layer from './layer';\nimport type {Effect} from './effect';\nimport type View from '../views/view';\nimport type Viewport from '../viewports/viewport';\n\nexport type PickByPointOptions = {\n  x: number;\n  y: number;\n  radius?: number;\n  depth?: number;\n  mode?: string;\n  unproject3D?: boolean;\n};\n\nexport type PickByRectOptions = {\n  x: number;\n  y: number;\n  width?: number;\n  height?: number;\n  mode?: string;\n  maxObjects?: number | null;\n};\n\ntype PickOperationContext = {\n  layers: Layer[];\n  views: Record<string, View>;\n  viewports: Viewport[];\n  onViewportActive: (viewport: Viewport) => void;\n  effects: Effect[];\n};\n\n/** Manages picking in a Deck context */\nexport default class DeckPicker {\n  device: Device;\n  pickingFBO?: Framebuffer;\n  depthFBO?: Framebuffer;\n  pickLayersPass: PickLayersPass;\n  layerFilter?: (context: FilterContext) => boolean;\n\n  /** Identifiers of the previously picked object, for callback tracking and auto highlight */\n  lastPickedInfo: {\n    index: number;\n    layerId: string | null;\n    info: PickingInfo | null;\n  };\n\n  _pickable: boolean = true;\n\n  constructor(device: Device) {\n    this.device = device;\n    this.pickLayersPass = new PickLayersPass(device);\n    this.lastPickedInfo = {\n      index: -1,\n      layerId: null,\n      info: null\n    };\n  }\n\n  setProps(props: any): void {\n    if ('layerFilter' in props) {\n      this.layerFilter = props.layerFilter;\n    }\n\n    if ('_pickable' in props) {\n      this._pickable = props._pickable;\n    }\n  }\n\n  finalize() {\n    if (this.pickingFBO) {\n      this.pickingFBO.destroy();\n    }\n    if (this.depthFBO) {\n      this.depthFBO.destroy();\n    }\n  }\n\n  /** Pick the closest info at given coordinate */\n  pickObject(opts: PickByPointOptions & PickOperationContext) {\n    return this._pickClosestObject(opts);\n  }\n\n  /** Get all unique infos within a bounding box */\n  pickObjects(opts: PickByRectOptions & PickOperationContext) {\n    return this._pickVisibleObjects(opts);\n  }\n\n  // Returns a new picking info object by assuming the last picked object is still picked\n  getLastPickedObject({x, y, layers, viewports}, lastPickedInfo = this.lastPickedInfo.info) {\n    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n    const lastPickedViewportId =\n      lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;\n    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;\n    const viewport =\n      (lastPickedViewportId && viewports.find(v => v.id === lastPickedViewportId)) || viewports[0];\n    const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);\n\n    const info = {\n      x,\n      y,\n      viewport,\n      coordinate,\n      layer\n    };\n\n    return {...lastPickedInfo, ...info};\n  }\n\n  // Private\n\n  /** Ensures that picking framebuffer exists and matches the canvas size */\n  _resizeBuffer() {\n    // Create a frame buffer if not already available\n    if (!this.pickingFBO) {\n      this.pickingFBO = this.device.createFramebuffer({\n        colorAttachments: ['rgba8unorm'],\n        depthStencilAttachment: 'depth16unorm'\n      });\n\n      if (this.device.isTextureFormatRenderable('rgba32float')) {\n        const depthFBO = this.device.createFramebuffer({\n          colorAttachments: ['rgba32float'],\n          depthStencilAttachment: 'depth16unorm'\n        });\n        this.depthFBO = depthFBO;\n      }\n    }\n\n    // Resize it to current canvas size (this is a noop if size hasn't changed)\n    const {canvas} = this.device.getDefaultCanvasContext();\n    this.pickingFBO?.resize({width: canvas.width, height: canvas.height});\n    this.depthFBO?.resize({width: canvas.width, height: canvas.height});\n  }\n\n  /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */\n  _getPickable(layers: Layer[]): Layer[] | null {\n    if (this._pickable === false) {\n      return null;\n    }\n    const pickableLayers = layers.filter(\n      layer => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite\n    );\n    return pickableLayers.length ? pickableLayers : null;\n  }\n\n  /** Pick the closest object at the given coordinate */\n  // eslint-disable-next-line max-statements,complexity\n  _pickClosestObject({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    radius = 0,\n    depth = 1,\n    mode = 'query',\n    unproject3D,\n    onViewportActive,\n    effects\n  }: PickByPointOptions & PickOperationContext): {\n    result: PickingInfo[];\n    emptyInfo: PickingInfo;\n  } {\n    // @ts-expect-error TODO - assuming WebGL context\n    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();\n\n    const pickableLayers = this._getPickable(layers);\n\n    if (!pickableLayers || viewports.length === 0) {\n      return {\n        result: [],\n        emptyInfo: getEmptyPickingInfo({viewports, x, y, pixelRatio})\n      };\n    }\n\n    this._resizeBuffer();\n\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // Top-left coordinates [x, y] to bottom-left coordinates [deviceX, deviceY]\n    // And compensate for pixelRatio\n    // @ts-expect-error TODO - assuming WebGL context\n    const devicePixelRange = this.device.canvasContext.cssToDevicePixels([x, y], true);\n    const devicePixel = [\n      devicePixelRange.x + Math.floor(devicePixelRange.width / 2),\n      devicePixelRange.y + Math.floor(devicePixelRange.height / 2)\n    ];\n\n    const deviceRadius = Math.round(radius * pixelRatio);\n    const {width, height} = this.pickingFBO as Framebuffer;\n    const deviceRect = this._getPickingRect({\n      deviceX: devicePixel[0],\n      deviceY: devicePixel[1],\n      deviceRadius,\n      deviceWidth: width,\n      deviceHeight: height\n    });\n\n    const cullRect: Rect = {\n      x: x - radius,\n      y: y - radius,\n      width: radius * 2 + 1,\n      height: radius * 2 + 1\n    };\n\n    let infos: Map<string | null, PickingInfo>;\n    const result: PickingInfo[] = [];\n    const affectedLayers = new Set<Layer>();\n\n    for (let i = 0; i < depth; i++) {\n      let pickInfo: PickedPixel;\n\n      if (deviceRect) {\n        const pickedResult = this._drawAndSample({\n          layers: pickableLayers,\n          views,\n          viewports,\n          onViewportActive,\n          deviceRect,\n          cullRect,\n          effects,\n          pass: `picking:${mode}`\n        });\n\n        pickInfo = getClosestObject({\n          ...pickedResult,\n          deviceX: devicePixel[0],\n          deviceY: devicePixel[1],\n          deviceRadius,\n          deviceRect\n        });\n      } else {\n        pickInfo = {\n          pickedColor: null,\n          pickedObjectIndex: -1\n        };\n      }\n\n      let z;\n      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n        const {pickedColors: pickedColors2} = this._drawAndSample(\n          {\n            layers: [pickInfo.pickedLayer],\n            views,\n            viewports,\n            onViewportActive,\n            deviceRect: {\n              x: pickInfo.pickedX as number,\n              y: pickInfo.pickedY as number,\n              width: 1,\n              height: 1\n            },\n            cullRect,\n            effects,\n            pass: `picking:${mode}:z`\n          },\n          true\n        );\n        // picked value is in common space (pixels) from the camera target (viewport.position)\n        // convert it to meters from the ground\n        if (pickedColors2[3]) {\n          z = pickedColors2[0];\n        }\n      }\n\n      // Only exclude if we need to run picking again.\n      // We need to run picking again if an object is detected AND\n      // we have not exhausted the requested depth.\n      if (pickInfo.pickedLayer && i + 1 < depth) {\n        affectedLayers.add(pickInfo.pickedLayer);\n        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);\n      }\n\n      // This logic needs to run even if no object is picked.\n      infos = processPickInfo({\n        pickInfo,\n        lastPickedInfo: this.lastPickedInfo,\n        mode,\n        layers: pickableLayers,\n        viewports,\n        x,\n        y,\n        z,\n        pixelRatio\n      });\n\n      for (const info of infos.values()) {\n        if (info.layer) {\n          result.push(info);\n        }\n      }\n\n      // If no object is picked stop.\n      if (!pickInfo.pickedColor) {\n        break;\n      }\n    }\n\n    // reset only affected buffers\n    for (const layer of affectedLayers) {\n      layer.restorePickingColors();\n    }\n\n    return {result, emptyInfo: infos!.get(null) as PickingInfo};\n  }\n\n  /** Pick all objects within the given bounding box */\n  _pickVisibleObjects({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    width = 1,\n    height = 1,\n    mode = 'query',\n    maxObjects = null,\n    onViewportActive,\n    effects\n  }: PickByRectOptions & PickOperationContext): PickingInfo[] {\n    const pickableLayers = this._getPickable(layers);\n\n    if (!pickableLayers || viewports.length === 0) {\n      return [];\n    }\n\n    this._resizeBuffer();\n\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // And compensate for pixelRatio\n    // @ts-expect-error TODO - assuming WebGL context\n    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();\n    // @ts-expect-error TODO - assuming WebGL context\n    const leftTop = this.device.canvasContext.cssToDevicePixels([x, y], true);\n\n    // take left and top (y inverted in device pixels) from start location\n    const deviceLeft = leftTop.x;\n    const deviceTop = leftTop.y + leftTop.height;\n\n    // take right and bottom (y inverted in device pixels) from end location\n    // @ts-expect-error TODO - assuming WebGL context\n    const rightBottom = this.device.canvasContext.cssToDevicePixels([x + width, y + height], true);\n    const deviceRight = rightBottom.x + rightBottom.width;\n    const deviceBottom = rightBottom.y;\n\n    const deviceRect = {\n      x: deviceLeft,\n      y: deviceBottom,\n      // deviceTop and deviceRight represent the first pixel outside the desired rect\n      width: deviceRight - deviceLeft,\n      height: deviceTop - deviceBottom\n    };\n\n    const pickedResult = this._drawAndSample({\n      layers: pickableLayers,\n      views,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      cullRect: {x, y, width, height},\n      effects,\n      pass: `picking:${mode}`\n    });\n\n    const pickInfos = getUniqueObjects(pickedResult);\n\n    // `getUniqueObjects` dedup by picked color\n    // However different picked color may be linked to the same picked object, e.g. stroke and fill of the same polygon\n    // picked from different sub layers of a GeoJsonLayer\n    // Here after resolving the picked index with `layer.getPickingInfo`, we need to dedup again by unique picked objects\n    const uniquePickedObjects = new Map<string, Set<unknown>>();\n    const uniqueInfos: PickingInfo[] = [];\n\n    const limitMaxObjects = Number.isFinite(maxObjects);\n\n    for (let i = 0; i < pickInfos.length; i++) {\n      if (limitMaxObjects && uniqueInfos.length >= maxObjects!) {\n        break;\n      }\n      const pickInfo = pickInfos[i];\n      let info: PickingInfo = {\n        color: pickInfo.pickedColor,\n        layer: null,\n        index: pickInfo.pickedObjectIndex,\n        picked: true,\n        x,\n        y,\n        pixelRatio\n      };\n\n      info = getLayerPickingInfo({layer: pickInfo.pickedLayer as Layer, info, mode});\n      // info.layer is always populated because it's a picked pixel\n      const pickedLayerId = info.layer!.id;\n      if (!uniquePickedObjects.has(pickedLayerId)) {\n        uniquePickedObjects.set(pickedLayerId, new Set<unknown>());\n      }\n      const uniqueObjectsInLayer = uniquePickedObjects.get(pickedLayerId) as Set<unknown>;\n      // info.object may be null if the layer is using non-iterable data.\n      // Fall back to using index as identifier.\n      const pickedObjectKey = info.object ?? info.index;\n      if (!uniqueObjectsInLayer.has(pickedObjectKey)) {\n        uniqueObjectsInLayer.add(pickedObjectKey);\n        uniqueInfos.push(info);\n      }\n    }\n\n    return uniqueInfos;\n  }\n\n  /** Renders layers into the picking buffer with picking colors and read the pixels. */\n  _drawAndSample(params: {\n    deviceRect: Rect;\n    pass: string;\n    layers: Layer[];\n    views: Record<string, View>;\n    viewports: Viewport[];\n    onViewportActive: (viewport: Viewport) => void;\n    cullRect?: Rect;\n    effects: Effect[];\n  }): {\n    pickedColors: Uint8Array;\n    decodePickingColor: PickingColorDecoder;\n  };\n\n  /** Renders layers into the picking buffer with encoded z values and read the pixels. */\n  _drawAndSample(\n    params: {\n      deviceRect: Rect;\n      pass: string;\n      layers: Layer[];\n      views: Record<string, View>;\n      viewports: Viewport[];\n      onViewportActive: (viewport: Viewport) => void;\n      cullRect?: Rect;\n      effects: Effect[];\n    },\n    pickZ: true\n  ): {\n    pickedColors: Float32Array;\n    decodePickingColor: null;\n  };\n\n  _drawAndSample(\n    {\n      layers,\n      views,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      cullRect,\n      effects,\n      pass\n    }: {\n      deviceRect: Rect;\n      pass: string;\n      layers: Layer[];\n      views: Record<string, View>;\n      viewports: Viewport[];\n      onViewportActive: (viewport: Viewport) => void;\n      cullRect?: Rect;\n      effects: Effect[];\n    },\n    pickZ: boolean = false\n  ): {\n    pickedColors: Uint8Array | Float32Array;\n    decodePickingColor: PickingColorDecoder | null;\n  } {\n    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n    const opts = {\n      layers,\n      layerFilter: this.layerFilter,\n      views,\n      viewports,\n      onViewportActive,\n      pickingFBO,\n      deviceRect,\n      cullRect,\n      effects,\n      pass,\n      pickZ,\n      preRenderStats: {},\n      isPicking: true\n    };\n\n    for (const effect of effects) {\n      if (effect.useInPicking) {\n        opts.preRenderStats[effect.id] = effect.preRender(opts);\n      }\n    }\n\n    const {decodePickingColor} = this.pickLayersPass.render(opts);\n\n    // Read from an already rendered picking buffer\n    // Returns an Uint8ClampedArray of picked pixels\n    const {x, y, width, height} = deviceRect;\n    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n    this.device.readPixelsToArrayWebGL(pickingFBO as Framebuffer, {\n      sourceX: x,\n      sourceY: y,\n      sourceWidth: width,\n      sourceHeight: height,\n      target: pickedColors\n    });\n\n    return {pickedColors, decodePickingColor};\n  }\n\n  // Calculate a picking rect centered on deviceX and deviceY and clipped to device\n  // Returns null if pixel is outside of device\n  _getPickingRect({\n    deviceX,\n    deviceY,\n    deviceRadius,\n    deviceWidth,\n    deviceHeight\n  }: {\n    deviceX: number;\n    deviceY: number;\n    deviceRadius: number;\n    deviceWidth: number;\n    deviceHeight: number;\n  }): Rect | null {\n    // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]\n    const x = Math.max(0, deviceX - deviceRadius);\n    const y = Math.max(0, deviceY - deviceRadius);\n    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n\n    // x, y out of bounds.\n    if (width <= 0 || height <= 0) {\n      return null;\n    }\n\n    return {x, y, width, height};\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}