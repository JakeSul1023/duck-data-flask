{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getBinaryImageMetadata } from '@loaders.gl/images';\nimport { padToNBytes, copyToArray } from '@loaders.gl/loader-utils';\nimport { assert } from \"../utils/assert.js\";\nimport { getAccessorTypeFromSize, getComponentTypeFromArray } from \"../gltf-utils/gltf-utils.js\";\nimport { getTypedArrayForAccessor as _getTypedArrayForAccessor } from \"../gltf-utils/get-typed-array.js\";\nfunction makeDefaultGLTFJson() {\n  return {\n    asset: {\n      version: '2.0',\n      generator: 'loaders.gl'\n    },\n    buffers: [],\n    extensions: {},\n    extensionsRequired: [],\n    extensionsUsed: []\n  };\n}\n/**\n * Class for structured access to GLTF data\n */\nexport class GLTFScenegraph {\n  // internal\n  gltf;\n  sourceBuffers;\n  byteLength;\n  // TODO - why is this not GLTFWithBuffers - what happens to images?\n  constructor(gltf) {\n    // Declare locally so\n    this.gltf = {\n      json: gltf?.json || makeDefaultGLTFJson(),\n      buffers: gltf?.buffers || [],\n      images: gltf?.images || []\n    };\n    this.sourceBuffers = [];\n    this.byteLength = 0;\n    // Initialize buffers\n    if (this.gltf.buffers && this.gltf.buffers[0]) {\n      this.byteLength = this.gltf.buffers[0].byteLength;\n      this.sourceBuffers = [this.gltf.buffers[0]];\n    }\n  }\n  // Accessors\n  get json() {\n    return this.gltf.json;\n  }\n  getApplicationData(key) {\n    // TODO - Data is already unpacked by GLBParser\n    const data = this.json[key];\n    return data;\n  }\n  getExtraData(key) {\n    // TODO - Data is already unpacked by GLBParser\n    const extras = this.json.extras || {};\n    return extras[key];\n  }\n  hasExtension(extensionName) {\n    const isUsedExtension = this.getUsedExtensions().find(name => name === extensionName);\n    const isRequiredExtension = this.getRequiredExtensions().find(name => name === extensionName);\n    return typeof isUsedExtension === 'string' || typeof isRequiredExtension === 'string';\n  }\n  getExtension(extensionName) {\n    const isExtension = this.getUsedExtensions().find(name => name === extensionName);\n    const extensions = this.json.extensions || {};\n    return isExtension ? extensions[extensionName] : null;\n  }\n  getRequiredExtension(extensionName) {\n    const isRequired = this.getRequiredExtensions().find(name => name === extensionName);\n    return isRequired ? this.getExtension(extensionName) : null;\n  }\n  getRequiredExtensions() {\n    return this.json.extensionsRequired || [];\n  }\n  getUsedExtensions() {\n    return this.json.extensionsUsed || [];\n  }\n  getRemovedExtensions() {\n    return this.json.extensionsRemoved || [];\n  }\n  getObjectExtension(object, extensionName) {\n    const extensions = object.extensions || {};\n    return extensions[extensionName];\n  }\n  getScene(index) {\n    return this.getObject('scenes', index);\n  }\n  getNode(index) {\n    return this.getObject('nodes', index);\n  }\n  getSkin(index) {\n    return this.getObject('skins', index);\n  }\n  getMesh(index) {\n    return this.getObject('meshes', index);\n  }\n  getMaterial(index) {\n    return this.getObject('materials', index);\n  }\n  getAccessor(index) {\n    return this.getObject('accessors', index);\n  }\n  // getCamera(index: number): object | null {\n  //   return null; // TODO: fix thi: object  as null;\n  // }\n  getTexture(index) {\n    return this.getObject('textures', index);\n  }\n  getSampler(index) {\n    return this.getObject('samplers', index);\n  }\n  getImage(index) {\n    return this.getObject('images', index);\n  }\n  getBufferView(index) {\n    return this.getObject('bufferViews', index);\n  }\n  getBuffer(index) {\n    return this.getObject('buffers', index);\n  }\n  getObject(array, index) {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      throw new Error(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n  /**\n   * Accepts buffer view index or buffer view object\n   * @returns a `Uint8Array`\n   */\n  getTypedArrayForBufferView(bufferView) {\n    bufferView = this.getBufferView(bufferView);\n    // @ts-ignore\n    const bufferIndex = bufferView.buffer;\n    // Get hold of the arrayBuffer\n    // const buffer = this.getBuffer(bufferIndex);\n    const binChunk = this.gltf.buffers[bufferIndex];\n    assert(binChunk);\n    // @ts-ignore\n    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n    // @ts-ignore\n    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n  /** Accepts accessor index or accessor object\n   * @returns a typed array with type that matches the types\n   */\n  getTypedArrayForAccessor(accessor) {\n    // @ts-ignore\n    const gltfAccessor = this.getAccessor(accessor);\n    return _getTypedArrayForAccessor(this.gltf.json, this.gltf.buffers, gltfAccessor);\n  }\n  /** accepts accessor index or accessor object\n   * returns a `Uint8Array`\n   */\n  getTypedArrayForImageData(image) {\n    // @ts-ignore\n    image = this.getAccessor(image);\n    // @ts-ignore\n    const bufferView = this.getBufferView(image.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    // @ts-ignore\n    const arrayBuffer = buffer.data;\n    const byteOffset = bufferView.byteOffset || 0;\n    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n  // MODIFERS\n  /**\n   * Add an extra application-defined key to the top-level data structure\n   */\n  addApplicationData(key, data) {\n    this.json[key] = data;\n    return this;\n  }\n  /**\n   * `extras` - Standard GLTF field for storing application specific data\n   */\n  addExtraData(key, data) {\n    this.json.extras = this.json.extras || {};\n    this.json.extras[key] = data;\n    return this;\n  }\n  addObjectExtension(object, extensionName, data) {\n    // @ts-ignore\n    object.extensions = object.extensions || {};\n    // TODO - clobber or merge?\n    // @ts-ignore\n    object.extensions[extensionName] = data;\n    this.registerUsedExtension(extensionName);\n    return this;\n  }\n  setObjectExtension(object, extensionName, data) {\n    const extensions = object.extensions || {};\n    extensions[extensionName] = data;\n    // TODO - add to usedExtensions...\n  }\n  removeObjectExtension(object, extensionName) {\n    const extensions = object?.extensions || {};\n    if (extensions[extensionName]) {\n      this.json.extensionsRemoved = this.json.extensionsRemoved || [];\n      const extensionsRemoved = this.json.extensionsRemoved;\n      if (!extensionsRemoved.includes(extensionName)) {\n        extensionsRemoved.push(extensionName);\n      }\n    }\n    delete extensions[extensionName];\n  }\n  /**\n   * Add to standard GLTF top level extension object, mark as used\n   */\n  addExtension(extensionName, extensionData = {}) {\n    assert(extensionData);\n    this.json.extensions = this.json.extensions || {};\n    this.json.extensions[extensionName] = extensionData;\n    this.registerUsedExtension(extensionName);\n    return extensionData;\n  }\n  /**\n   * Standard GLTF top level extension object, mark as used and required\n   */\n  addRequiredExtension(extensionName, extensionData = {}) {\n    assert(extensionData);\n    this.addExtension(extensionName, extensionData);\n    this.registerRequiredExtension(extensionName);\n    return extensionData;\n  }\n  /**\n   * Add extensionName to list of used extensions\n   */\n  registerUsedExtension(extensionName) {\n    this.json.extensionsUsed = this.json.extensionsUsed || [];\n    if (!this.json.extensionsUsed.find(ext => ext === extensionName)) {\n      this.json.extensionsUsed.push(extensionName);\n    }\n  }\n  /**\n   * Add extensionName to list of required extensions\n   */\n  registerRequiredExtension(extensionName) {\n    this.registerUsedExtension(extensionName);\n    this.json.extensionsRequired = this.json.extensionsRequired || [];\n    if (!this.json.extensionsRequired.find(ext => ext === extensionName)) {\n      this.json.extensionsRequired.push(extensionName);\n    }\n  }\n  /**\n   * Removes an extension from the top-level list\n   */\n  removeExtension(extensionName) {\n    if (this.json.extensions?.[extensionName]) {\n      this.json.extensionsRemoved = this.json.extensionsRemoved || [];\n      const extensionsRemoved = this.json.extensionsRemoved;\n      if (!extensionsRemoved.includes(extensionName)) {\n        extensionsRemoved.push(extensionName);\n      }\n    }\n    if (this.json.extensions) {\n      delete this.json.extensions[extensionName];\n    }\n    if (this.json.extensionsRequired) {\n      this._removeStringFromArray(this.json.extensionsRequired, extensionName);\n    }\n    if (this.json.extensionsUsed) {\n      this._removeStringFromArray(this.json.extensionsUsed, extensionName);\n    }\n  }\n  /**\n   *  Set default scene which is to be displayed at load time\n   */\n  setDefaultScene(sceneIndex) {\n    this.json.scene = sceneIndex;\n  }\n  /**\n   * @todo: add more properties for scene initialization:\n   *   name`, `extensions`, `extras`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene\n   */\n  addScene(scene) {\n    const {\n      nodeIndices\n    } = scene;\n    this.json.scenes = this.json.scenes || [];\n    this.json.scenes.push({\n      nodes: nodeIndices\n    });\n    return this.json.scenes.length - 1;\n  }\n  /**\n   * @todo: add more properties for node initialization:\n   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node\n   */\n  addNode(node) {\n    const {\n      meshIndex,\n      matrix\n    } = node;\n    this.json.nodes = this.json.nodes || [];\n    const nodeData = {\n      mesh: meshIndex\n    };\n    if (matrix) {\n      // @ts-ignore\n      nodeData.matrix = matrix;\n    }\n    this.json.nodes.push(nodeData);\n    return this.json.nodes.length - 1;\n  }\n  /** Adds a mesh to the json part */\n  addMesh(mesh) {\n    const {\n      attributes,\n      indices,\n      material,\n      mode = 4\n    } = mesh;\n    const accessors = this._addAttributes(attributes);\n    const glTFMesh = {\n      primitives: [{\n        attributes: accessors,\n        mode\n      }]\n    };\n    if (indices) {\n      const indicesAccessor = this._addIndices(indices);\n      // @ts-ignore\n      glTFMesh.primitives[0].indices = indicesAccessor;\n    }\n    if (Number.isFinite(material)) {\n      // @ts-ignore\n      glTFMesh.primitives[0].material = material;\n    }\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n  addPointCloud(attributes) {\n    // @ts-ignore\n    const accessorIndices = this._addAttributes(attributes);\n    const glTFMesh = {\n      primitives: [{\n        attributes: accessorIndices,\n        mode: 0 // GL.POINTS\n      }]\n    };\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n  /**\n   * Adds a binary image. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes as glTF image\n   * @param imageData\n   * @param mimeType\n   */\n  addImage(imageData, mimeTypeOpt) {\n    // If image is referencing a bufferView instead of URI, mimeType must be defined:\n    //   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#images\n    //   \"a reference to a bufferView; in that case mimeType must be defined.\"\n    const metadata = getBinaryImageMetadata(imageData);\n    const mimeType = mimeTypeOpt || metadata?.mimeType;\n    const bufferViewIndex = this.addBufferView(imageData);\n    const glTFImage = {\n      bufferView: bufferViewIndex,\n      mimeType\n    };\n    this.json.images = this.json.images || [];\n    this.json.images.push(glTFImage);\n    return this.json.images.length - 1;\n  }\n  /**\n   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index\n   * @param buffer\n   */\n  addBufferView(buffer, bufferIndex = 0, byteOffset = this.byteLength) {\n    const byteLength = buffer.byteLength;\n    assert(Number.isFinite(byteLength));\n    // Add this buffer to the list of buffers to be written to the body.\n    this.sourceBuffers = this.sourceBuffers || [];\n    this.sourceBuffers.push(buffer);\n    const glTFBufferView = {\n      buffer: bufferIndex,\n      // Write offset from the start of the binary body\n      byteOffset,\n      byteLength\n    };\n    // We've now added the contents to the body, so update the total length\n    // Every sub-chunk needs to be 4-byte align ed\n    this.byteLength += padToNBytes(byteLength, 4);\n    // Add a bufferView indicating start and length of this binary sub-chunk\n    this.json.bufferViews = this.json.bufferViews || [];\n    this.json.bufferViews.push(glTFBufferView);\n    return this.json.bufferViews.length - 1;\n  }\n  /**\n   * Adds an accessor to a bufferView\n   * @param bufferViewIndex\n   * @param accessor\n   */\n  addAccessor(bufferViewIndex, accessor) {\n    const glTFAccessor = {\n      bufferView: bufferViewIndex,\n      // @ts-ignore\n      type: getAccessorTypeFromSize(accessor.size),\n      // @ts-ignore\n      componentType: accessor.componentType,\n      // @ts-ignore\n      count: accessor.count,\n      // @ts-ignore\n      max: accessor.max,\n      // @ts-ignore\n      min: accessor.min\n    };\n    this.json.accessors = this.json.accessors || [];\n    this.json.accessors.push(glTFAccessor);\n    return this.json.accessors.length - 1;\n  }\n  /**\n   * Add a binary buffer. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes buffers as glTF accessors, but this could be optimized\n   * @param sourceBuffer\n   * @param accessor\n   */\n  addBinaryBuffer(sourceBuffer, accessor = {\n    size: 3\n  }) {\n    const bufferViewIndex = this.addBufferView(sourceBuffer);\n    // @ts-ignore\n    let minMax = {\n      min: accessor.min,\n      max: accessor.max\n    };\n    if (!minMax.min || !minMax.max) {\n      // @ts-ignore\n      minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);\n    }\n    const accessorDefaults = {\n      // @ts-ignore\n      size: accessor.size,\n      componentType: getComponentTypeFromArray(sourceBuffer),\n      // @ts-ignore\n      count: Math.round(sourceBuffer.length / accessor.size),\n      min: minMax.min,\n      max: minMax.max\n    };\n    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));\n  }\n  /**\n   * Adds a texture to the json part\n   * @todo: add more properties for texture initialization\n   * `sampler`, `name`, `extensions`, `extras`\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\n   */\n  addTexture(texture) {\n    const {\n      imageIndex\n    } = texture;\n    const glTFTexture = {\n      source: imageIndex\n    };\n    this.json.textures = this.json.textures || [];\n    this.json.textures.push(glTFTexture);\n    return this.json.textures.length - 1;\n  }\n  /** Adds a material to the json part */\n  addMaterial(pbrMaterialInfo) {\n    this.json.materials = this.json.materials || [];\n    this.json.materials.push(pbrMaterialInfo);\n    return this.json.materials.length - 1;\n  }\n  /** Pack the binary chunk */\n  createBinaryChunk() {\n    // Allocate total array\n    const totalByteLength = this.byteLength;\n    const arrayBuffer = new ArrayBuffer(totalByteLength);\n    const targetArray = new Uint8Array(arrayBuffer);\n    // Copy each array into\n    let dstByteOffset = 0;\n    for (const sourceBuffer of this.sourceBuffers || []) {\n      dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);\n    }\n    // Update the glTF BIN CHUNK byte length\n    if (this.json?.buffers?.[0]) {\n      this.json.buffers[0].byteLength = totalByteLength;\n    } else {\n      this.json.buffers = [{\n        byteLength: totalByteLength\n      }];\n    }\n    // Save generated arrayBuffer\n    this.gltf.binary = arrayBuffer;\n    // Put arrayBuffer to sourceBuffers for possible additional writing data in the chunk\n    this.sourceBuffers = [arrayBuffer];\n    this.gltf.buffers = [{\n      arrayBuffer,\n      byteOffset: 0,\n      byteLength: arrayBuffer.byteLength\n    }];\n  }\n  // PRIVATE\n  _removeStringFromArray(array, string) {\n    let found = true;\n    while (found) {\n      const index = array.indexOf(string);\n      if (index > -1) {\n        array.splice(index, 1);\n      } else {\n        found = false;\n      }\n    }\n  }\n  /**\n   * Add attributes to buffers and create `attributes` object which is part of `mesh`\n   */\n  _addAttributes(attributes = {}) {\n    const result = {};\n    for (const attributeKey in attributes) {\n      const attributeData = attributes[attributeKey];\n      const attrName = this._getGltfAttributeName(attributeKey);\n      const accessor = this.addBinaryBuffer(attributeData.value, attributeData);\n      result[attrName] = accessor;\n    }\n    return result;\n  }\n  /**\n   * Add indices to buffers\n   */\n  _addIndices(indices) {\n    return this.addBinaryBuffer(indices, {\n      size: 1\n    });\n  }\n  /**\n   * Deduce gltf specific attribue name from input attribute name\n   */\n  _getGltfAttributeName(attributeName) {\n    switch (attributeName.toLowerCase()) {\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return 'POSITION';\n      case 'normal':\n      case 'normals':\n        return 'NORMAL';\n      case 'color':\n      case 'colors':\n        return 'COLOR_0';\n      case 'texcoord':\n      case 'texcoords':\n        return 'TEXCOORD_0';\n      default:\n        return attributeName;\n    }\n  }\n  /**\n   * Calculate `min` and `max` arrays of accessor according to spec:\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor\n   */\n  _getAccessorMinMax(buffer, size) {\n    const result = {\n      min: null,\n      max: null\n    };\n    if (buffer.length < size) {\n      return result;\n    }\n    // @ts-ignore\n    result.min = [];\n    // @ts-ignore\n    result.max = [];\n    const initValues = buffer.subarray(0, size);\n    for (const value of initValues) {\n      // @ts-ignore\n      result.min.push(value);\n      // @ts-ignore\n      result.max.push(value);\n    }\n    for (let index = size; index < buffer.length; index += size) {\n      for (let componentIndex = 0; componentIndex < size; componentIndex++) {\n        // @ts-ignore\n        result.min[0 + componentIndex] = Math.min(\n        // @ts-ignore\n        result.min[0 + componentIndex], buffer[index + componentIndex]);\n        // @ts-ignore\n        result.max[0 + componentIndex] = Math.max(\n        // @ts-ignore\n        result.max[0 + componentIndex], buffer[index + componentIndex]);\n      }\n    }\n    return result;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}