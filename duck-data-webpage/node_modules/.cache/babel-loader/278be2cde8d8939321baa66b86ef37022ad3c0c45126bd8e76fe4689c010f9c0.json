{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { decodeShaderUniformType, alignTo } from \"../gpu-type-utils/decode-shader-types.js\";\nimport { getScratchArrayBuffer } from \"../utils/array-utils-flat.js\";\nimport { isNumberArray } from \"../utils/is-array.js\";\nimport { log } from \"../utils/log.js\";\n/**\n * Smallest buffer size that can be used for uniform buffers.\n * TODO - does this depend on device?\n */\nconst minBufferSize = 1024;\n/**\n * Std140 layout for uniform buffers\n * Supports manual listing of uniforms\n */\nexport class UniformBufferLayout {\n  layout = {};\n  /** number of bytes needed for buffer allocation */\n  byteLength;\n  /** Create a new UniformBufferLayout given a map of attributes. */\n  constructor(uniformTypes) {\n    /** number of 4 byte slots taken */\n    let size = 0;\n    // Add layout (type, size and offset) definitions for each uniform in the layout\n    for (const [key, uniformType] of Object.entries(uniformTypes)) {\n      const typeAndComponents = decodeShaderUniformType(uniformType);\n      const {\n        type,\n        components: count\n      } = typeAndComponents;\n      // First, align (bump) current offset to an even multiple of current object (1, 2, 4)\n      size = alignTo(size, count);\n      // Use the aligned size as the offset of the current uniform.\n      const offset = size;\n      // Then, add our object's padded size ((1, 2, multiple of 4) to the current offset\n      size += count;\n      this.layout[key] = {\n        type,\n        size: count,\n        offset\n      };\n    }\n    size += (4 - size % 4) % 4;\n    const actualByteLength = size * 4;\n    this.byteLength = Math.max(actualByteLength, minBufferSize);\n  }\n  /** Get the data for the complete buffer */\n  getData(uniformValues) {\n    const bufferSize = Math.max(this.byteLength, minBufferSize);\n    // Allocate three typed arrays pointing at same memory\n    const arrayBuffer = getScratchArrayBuffer(bufferSize);\n    const typedArrays = {\n      i32: new Int32Array(arrayBuffer),\n      u32: new Uint32Array(arrayBuffer),\n      f32: new Float32Array(arrayBuffer),\n      // TODO not implemented\n      f16: new Uint16Array(arrayBuffer)\n    };\n    // TODO is this needed?\n    // typedArrays.i32.fill(0);\n    for (const [name, value] of Object.entries(uniformValues)) {\n      const uniformLayout = this.layout[name];\n      if (!uniformLayout) {\n        log.warn(`Supplied uniform value ${name} not present in uniform block layout`)();\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      const {\n        type,\n        size,\n        offset\n      } = uniformLayout;\n      const typedArray = typedArrays[type];\n      if (size === 1) {\n        if (typeof value !== 'number' && typeof value !== 'boolean') {\n          log.warn(`Supplied value for single component uniform ${name} is not a number: ${value}`)();\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        // single value -> just set it\n        typedArray[offset] = Number(value);\n      } else {\n        if (!isNumberArray(value)) {\n          log.warn(`Supplied value for multi component / array uniform ${name} is not a numeric array: ${value}`)();\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        // vector/matrix -> copy the supplied (typed) array, starting from offset\n        // TODO: we should limit or check size in case the supplied data overflows\n        typedArray.set(value, offset);\n      }\n    }\n    return new Uint8Array(arrayBuffer);\n  }\n  /** Does this layout have a field with specified name */\n  has(name) {\n    return Boolean(this.layout[name]);\n  }\n  /** Get offset and size for a field with specified name */\n  get(name) {\n    const layout = this.layout[name];\n    return layout;\n  }\n}","map":{"version":3,"names":["decodeShaderUniformType","alignTo","getScratchArrayBuffer","isNumberArray","log","minBufferSize","UniformBufferLayout","layout","byteLength","constructor","uniformTypes","size","key","uniformType","Object","entries","typeAndComponents","type","components","count","offset","actualByteLength","Math","max","getData","uniformValues","bufferSize","arrayBuffer","typedArrays","i32","Int32Array","u32","Uint32Array","f32","Float32Array","f16","Uint16Array","name","value","uniformLayout","warn","typedArray","Number","set","Uint8Array","has","Boolean","get"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\core\\src\\portable\\uniform-buffer-layout.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderUniformType, ShaderDataType} from '../gpu-type-utils/shader-types';\nimport {decodeShaderUniformType, alignTo} from '../gpu-type-utils/decode-shader-types';\n\nimport type {UniformValue} from '../adapter/types/uniforms';\nimport {getScratchArrayBuffer} from '../utils/array-utils-flat';\nimport {isNumberArray} from '../utils/is-array';\nimport {log} from '../utils/log';\n\n/**\n * Smallest buffer size that can be used for uniform buffers.\n * TODO - does this depend on device?\n */\nconst minBufferSize: number = 1024;\n\n/**\n * Std140 layout for uniform buffers\n * Supports manual listing of uniforms\n */\nexport class UniformBufferLayout {\n  readonly layout: Record<string, {offset: number; size: number; type: ShaderDataType}> = {};\n\n  /** number of bytes needed for buffer allocation */\n  readonly byteLength: number;\n\n  /** Create a new UniformBufferLayout given a map of attributes. */\n  constructor(uniformTypes: Record<string, ShaderUniformType>) {\n    /** number of 4 byte slots taken */\n    let size: number = 0;\n\n    // Add layout (type, size and offset) definitions for each uniform in the layout\n    for (const [key, uniformType] of Object.entries(uniformTypes)) {\n      const typeAndComponents = decodeShaderUniformType(uniformType);\n      const {type, components: count} = typeAndComponents;\n      // First, align (bump) current offset to an even multiple of current object (1, 2, 4)\n      size = alignTo(size, count);\n      // Use the aligned size as the offset of the current uniform.\n      const offset = size;\n      // Then, add our object's padded size ((1, 2, multiple of 4) to the current offset\n      size += count;\n      this.layout[key] = {type, size: count, offset};\n    }\n    size += (4 - (size % 4)) % 4;\n\n    const actualByteLength = size * 4;\n    this.byteLength = Math.max(actualByteLength, minBufferSize);\n  }\n\n  /** Get the data for the complete buffer */\n  getData(uniformValues: Record<string, UniformValue>): Uint8Array {\n    const bufferSize = Math.max(this.byteLength, minBufferSize);\n\n    // Allocate three typed arrays pointing at same memory\n    const arrayBuffer = getScratchArrayBuffer(bufferSize);\n    const typedArrays = {\n      i32: new Int32Array(arrayBuffer),\n      u32: new Uint32Array(arrayBuffer),\n      f32: new Float32Array(arrayBuffer),\n      // TODO not implemented\n      f16: new Uint16Array(arrayBuffer)\n    };\n    // TODO is this needed?\n    // typedArrays.i32.fill(0);\n\n    for (const [name, value] of Object.entries(uniformValues)) {\n      const uniformLayout = this.layout[name];\n      if (!uniformLayout) {\n        log.warn(`Supplied uniform value ${name} not present in uniform block layout`)();\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      const {type, size, offset} = uniformLayout;\n      const typedArray = typedArrays[type];\n      if (size === 1) {\n        if (typeof value !== 'number' && typeof value !== 'boolean') {\n          log.warn(\n            `Supplied value for single component uniform ${name} is not a number: ${value}`\n          )();\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        // single value -> just set it\n        typedArray[offset] = Number(value);\n      } else {\n        if (!isNumberArray(value)) {\n          log.warn(\n            `Supplied value for multi component / array uniform ${name} is not a numeric array: ${value}`\n          )();\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        // vector/matrix -> copy the supplied (typed) array, starting from offset\n        // TODO: we should limit or check size in case the supplied data overflows\n        typedArray.set(value, offset);\n      }\n    }\n\n    return new Uint8Array(arrayBuffer);\n  }\n\n  /** Does this layout have a field with specified name */\n  has(name: string) {\n    return Boolean(this.layout[name]);\n  }\n\n  /** Get offset and size for a field with specified name */\n  get(name: string): {offset: number; size: number} | undefined {\n    const layout = this.layout[name];\n    return layout;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}