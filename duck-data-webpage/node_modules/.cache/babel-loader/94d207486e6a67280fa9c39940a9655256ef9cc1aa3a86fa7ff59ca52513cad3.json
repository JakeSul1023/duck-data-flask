{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { COORDINATE_SYSTEM, PROJECTION_MODE } from \"../../lib/constants.js\";\nimport project from \"../project/project.js\";\nimport { Vector3, Matrix4 } from '@math.gl/core';\nimport memoize from \"../../utils/memoize.js\";\nimport { pixelsToWorld } from '@math.gl/web-mercator';\nconst uniformBlock = /* glsl */`\nuniform shadowUniforms {\n  bool drawShadowMap;\n  bool useShadowMap;\n  vec4 color;\n  highp int lightId;\n  float lightCount;\n  mat4 viewProjectionMatrix0;\n  mat4 viewProjectionMatrix1;\n  vec4 projectCenter0;\n  vec4 projectCenter1;\n} shadow;\n`;\nconst vertex = /* glsl */`\nconst int max_lights = 2;\n\nout vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  mat4 viewProjectionMatrices[max_lights];\n  viewProjectionMatrices[0] = shadow.viewProjectionMatrix0;\n  viewProjectionMatrices[1] = shadow.viewProjectionMatrix1;\n  vec4 projectCenters[max_lights];\n  projectCenters[0] = shadow.projectCenter0;\n  projectCenters[1] = shadow.projectCenter1;\n\n  if (shadow.drawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[shadow.lightId], projectCenters[shadow.lightId]);\n  }\n  if (shadow.useShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow.lightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[i], projectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n`;\nconst vs = `\n${uniformBlock}\n${vertex}\n`;\nconst fragment = /* glsl */`\nconst int max_lights = 2;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\n\nin vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow.drawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow.useShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow.lightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow.color.a / shadow.lightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow.color.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n`;\nconst fs = `\n${uniformBlock}\n${fragment}\n`;\nconst getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);\nconst getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);\nconst DEFAULT_SHADOW_COLOR = [0, 0, 0, 1.0];\nconst VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\nfunction screenToCommonSpace(xyz, pixelUnprojectionMatrix) {\n  const [x, y, z] = xyz;\n  const coord = pixelsToWorld([x, y, z], pixelUnprojectionMatrix);\n  if (Number.isFinite(z)) {\n    return coord;\n  }\n  return [coord[0], coord[1], 0];\n}\nfunction getViewportCenterPosition({\n  viewport,\n  center\n}) {\n  return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);\n}\nfunction getViewProjectionMatrices({\n  viewport,\n  shadowMatrices\n}) {\n  const projectionMatrices = [];\n  const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;\n  const farZ = viewport.isGeospatial ? undefined : 1;\n  const corners = [[0, 0, farZ],\n  // top left ground\n  [viewport.width, 0, farZ],\n  // top right ground\n  [0, viewport.height, farZ],\n  // bottom left ground\n  [viewport.width, viewport.height, farZ],\n  // bottom right ground\n  [0, 0, -1],\n  // top left near\n  [viewport.width, 0, -1],\n  // top right near\n  [0, viewport.height, -1],\n  // bottom left near\n  [viewport.width, viewport.height, -1] // bottom right near\n  ].map(pixel =>\n  // @ts-expect-error z may be undefined\n  screenToCommonSpace(pixel, pixelUnprojectionMatrix));\n  for (const shadowMatrix of shadowMatrices) {\n    const viewMatrix = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());\n    const positions = corners.map(corner => viewMatrix.transform(corner));\n    const projectionMatrix = new Matrix4().ortho({\n      left: Math.min(...positions.map(position => position[0])),\n      right: Math.max(...positions.map(position => position[0])),\n      bottom: Math.min(...positions.map(position => position[1])),\n      top: Math.max(...positions.map(position => position[1])),\n      near: Math.min(...positions.map(position => -position[2])),\n      far: Math.max(...positions.map(position => -position[2]))\n    });\n    projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));\n  }\n  return projectionMatrices;\n}\n/* eslint-disable camelcase */\n// eslint-disable-next-line complexity\nfunction createShadowUniforms(opts) {\n  const {\n    shadowEnabled = true,\n    project: projectProps\n  } = opts;\n  if (!shadowEnabled || !projectProps || !opts.shadowMatrices || !opts.shadowMatrices.length) {\n    return {\n      drawShadowMap: false,\n      useShadowMap: false,\n      shadow_uShadowMap0: opts.dummyShadowMap,\n      shadow_uShadowMap1: opts.dummyShadowMap\n    };\n  }\n  const projectUniforms = project.getUniforms(projectProps);\n  const center = getMemoizedViewportCenterPosition({\n    viewport: projectProps.viewport,\n    center: projectUniforms.center\n  });\n  const projectCenters = [];\n  const viewProjectionMatrices = getMemoizedViewProjectionMatrices({\n    shadowMatrices: opts.shadowMatrices,\n    viewport: projectProps.viewport\n  }).slice();\n  for (let i = 0; i < opts.shadowMatrices.length; i++) {\n    const viewProjectionMatrix = viewProjectionMatrices[i];\n    const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new Vector3(projectProps.viewport.center).negate());\n    if (projectUniforms.coordinateSystem === COORDINATE_SYSTEM.LNGLAT && projectUniforms.projectionMode === PROJECTION_MODE.WEB_MERCATOR) {\n      viewProjectionMatrices[i] = viewProjectionMatrixCentered;\n      projectCenters[i] = center;\n    } else {\n      viewProjectionMatrices[i] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX);\n      projectCenters[i] = viewProjectionMatrixCentered.transform(center);\n    }\n  }\n  const uniforms = {\n    drawShadowMap: Boolean(opts.drawToShadowMap),\n    useShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,\n    color: opts.shadowColor || DEFAULT_SHADOW_COLOR,\n    lightId: opts.shadowLightId || 0,\n    lightCount: opts.shadowMatrices.length,\n    shadow_uShadowMap0: opts.dummyShadowMap,\n    shadow_uShadowMap1: opts.dummyShadowMap\n  };\n  for (let i = 0; i < viewProjectionMatrices.length; i++) {\n    uniforms[`viewProjectionMatrix${i}`] = viewProjectionMatrices[i];\n    uniforms[`projectCenter${i}`] = projectCenters[i];\n  }\n  for (let i = 0; i < 2; i++) {\n    uniforms[`shadow_uShadowMap${i}`] = opts.shadowMaps && opts.shadowMaps[i] || opts.dummyShadowMap;\n  }\n  return uniforms;\n}\nexport default {\n  name: 'shadow',\n  dependencies: [project],\n  vs,\n  fs,\n  inject: {\n    'vs:DECKGL_FILTER_GL_POSITION': `\n    position = shadow_setVertexPosition(geometry.position);\n    `,\n    'fs:DECKGL_FILTER_COLOR': `\n    color = shadow_filterShadowColor(color);\n    `\n  },\n  getUniforms: createShadowUniforms,\n  uniformTypes: {\n    drawShadowMap: 'f32',\n    useShadowMap: 'f32',\n    color: 'vec4<f32>',\n    lightId: 'i32',\n    lightCount: 'f32',\n    viewProjectionMatrix0: 'mat4x4<f32>',\n    viewProjectionMatrix1: 'mat4x4<f32>',\n    projectCenter0: 'vec4<f32>',\n    projectCenter1: 'vec4<f32>'\n  }\n};","map":{"version":3,"names":["COORDINATE_SYSTEM","PROJECTION_MODE","project","Vector3","Matrix4","memoize","pixelsToWorld","uniformBlock","vertex","vs","fragment","fs","getMemoizedViewportCenterPosition","getViewportCenterPosition","getMemoizedViewProjectionMatrices","getViewProjectionMatrices","DEFAULT_SHADOW_COLOR","VECTOR_TO_POINT_MATRIX","screenToCommonSpace","xyz","pixelUnprojectionMatrix","x","y","z","coord","Number","isFinite","viewport","center","viewProjectionMatrix","invert","transform","shadowMatrices","projectionMatrices","farZ","isGeospatial","undefined","corners","width","height","map","pixel","shadowMatrix","viewMatrix","clone","translate","negate","positions","corner","projectionMatrix","ortho","left","Math","min","position","right","max","bottom","top","near","far","push","multiplyRight","createShadowUniforms","opts","shadowEnabled","projectProps","length","drawShadowMap","useShadowMap","shadow_uShadowMap0","dummyShadowMap","shadow_uShadowMap1","projectUniforms","getUniforms","projectCenters","viewProjectionMatrices","slice","i","viewProjectionMatrixCentered","coordinateSystem","LNGLAT","projectionMode","WEB_MERCATOR","uniforms","Boolean","drawToShadowMap","shadowMaps","color","shadowColor","lightId","shadowLightId","lightCount","name","dependencies","inject","uniformTypes","viewProjectionMatrix0","viewProjectionMatrix1","projectCenter0","projectCenter1"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\shaderlib\\shadow\\shadow.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {COORDINATE_SYSTEM, PROJECTION_MODE} from '../../lib/constants';\nimport project from '../project/project';\nimport {Vector3, Matrix4} from '@math.gl/core';\nimport type {NumericArray} from '@math.gl/core';\nimport memoize from '../../utils/memoize';\nimport {pixelsToWorld} from '@math.gl/web-mercator';\n\nimport type {Texture} from '@luma.gl/core';\nimport {ShaderModule} from '@luma.gl/shadertools';\nimport type Viewport from '../../viewports/viewport';\nimport type {ProjectProps, ProjectUniforms} from '../project/viewport-uniforms';\n\nconst uniformBlock = /* glsl */ `\nuniform shadowUniforms {\n  bool drawShadowMap;\n  bool useShadowMap;\n  vec4 color;\n  highp int lightId;\n  float lightCount;\n  mat4 viewProjectionMatrix0;\n  mat4 viewProjectionMatrix1;\n  vec4 projectCenter0;\n  vec4 projectCenter1;\n} shadow;\n`;\n\nconst vertex = /* glsl */ `\nconst int max_lights = 2;\n\nout vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  mat4 viewProjectionMatrices[max_lights];\n  viewProjectionMatrices[0] = shadow.viewProjectionMatrix0;\n  viewProjectionMatrices[1] = shadow.viewProjectionMatrix1;\n  vec4 projectCenters[max_lights];\n  projectCenters[0] = shadow.projectCenter0;\n  projectCenters[1] = shadow.projectCenter1;\n\n  if (shadow.drawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[shadow.lightId], projectCenters[shadow.lightId]);\n  }\n  if (shadow.useShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow.lightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[i], projectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n`;\n\nconst vs = `\n${uniformBlock}\n${vertex}\n`;\n\nconst fragment = /* glsl */ `\nconst int max_lights = 2;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\n\nin vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow.drawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow.useShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow.lightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow.color.a / shadow.lightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow.color.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n`;\n\nconst fs = `\n${uniformBlock}\n${fragment}\n`;\n\nconst getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);\nconst getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);\n\nconst DEFAULT_SHADOW_COLOR: NumberArray4 = [0, 0, 0, 1.0];\nconst VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\n\nexport type ShadowModuleProps = {\n  project: ProjectProps;\n  shadowEnabled?: boolean;\n  drawToShadowMap?: boolean;\n  shadowMaps?: Texture[];\n  dummyShadowMap: Texture;\n  shadowColor?: NumberArray4;\n  shadowMatrices?: Matrix4[];\n  shadowLightId?: number;\n};\n\ntype ShadowModuleUniforms = {\n  drawShadowMap: boolean;\n  useShadowMap: boolean;\n  color?: NumberArray4;\n  lightId?: number;\n  lightCount?: number;\n  viewProjectionMatrix0?: NumberArray16;\n  viewProjectionMatrix1?: NumberArray16;\n  projectCenter0?: NumberArray4;\n  projectCenter1?: NumberArray4;\n};\n\ntype ShadowModuleBindings = {\n  shadow_uShadowMap0: Texture;\n  shadow_uShadowMap1: Texture;\n};\n\nfunction screenToCommonSpace(xyz: number[], pixelUnprojectionMatrix: number[]): number[] {\n  const [x, y, z] = xyz;\n  const coord = pixelsToWorld([x, y, z], pixelUnprojectionMatrix);\n\n  if (Number.isFinite(z)) {\n    return coord;\n  }\n  return [coord[0], coord[1], 0];\n}\n\nfunction getViewportCenterPosition({\n  viewport,\n  center\n}: {\n  viewport: Viewport;\n  center: NumericArray;\n}): NumericArray {\n  return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);\n}\n\nfunction getViewProjectionMatrices({\n  viewport,\n  shadowMatrices\n}: {\n  viewport: Viewport;\n  shadowMatrices: Matrix4[];\n}): Matrix4[] {\n  const projectionMatrices: Matrix4[] = [];\n  const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;\n  const farZ = viewport.isGeospatial ? undefined : 1;\n  const corners = [\n    [0, 0, farZ], // top left ground\n    [viewport.width, 0, farZ], // top right ground\n    [0, viewport.height, farZ], // bottom left ground\n    [viewport.width, viewport.height, farZ], // bottom right ground\n    [0, 0, -1], // top left near\n    [viewport.width, 0, -1], // top right near\n    [0, viewport.height, -1], // bottom left near\n    [viewport.width, viewport.height, -1] // bottom right near\n  ].map(pixel =>\n    // @ts-expect-error z may be undefined\n    screenToCommonSpace(pixel, pixelUnprojectionMatrix)\n  );\n\n  for (const shadowMatrix of shadowMatrices) {\n    const viewMatrix = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());\n    const positions = corners.map(corner => viewMatrix.transform(corner));\n    const projectionMatrix = new Matrix4().ortho({\n      left: Math.min(...positions.map(position => position[0])),\n      right: Math.max(...positions.map(position => position[0])),\n      bottom: Math.min(...positions.map(position => position[1])),\n      top: Math.max(...positions.map(position => position[1])),\n      near: Math.min(...positions.map(position => -position[2])),\n      far: Math.max(...positions.map(position => -position[2]))\n    });\n    projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));\n  }\n  return projectionMatrices;\n}\n\n/* eslint-disable camelcase */\n\n// eslint-disable-next-line complexity\nfunction createShadowUniforms(\n  opts: Partial<ShadowModuleProps>\n): ShadowModuleBindings & ShadowModuleUniforms {\n  const {shadowEnabled = true, project: projectProps} = opts;\n  if (!shadowEnabled || !projectProps || !opts.shadowMatrices || !opts.shadowMatrices.length) {\n    return {\n      drawShadowMap: false,\n      useShadowMap: false,\n      shadow_uShadowMap0: opts.dummyShadowMap!,\n      shadow_uShadowMap1: opts.dummyShadowMap!\n    };\n  }\n  const projectUniforms = project.getUniforms(projectProps) as ProjectUniforms;\n  const center = getMemoizedViewportCenterPosition({\n    viewport: projectProps.viewport,\n    center: projectUniforms.center\n  });\n\n  const projectCenters: NumericArray[] = [];\n  const viewProjectionMatrices = getMemoizedViewProjectionMatrices({\n    shadowMatrices: opts.shadowMatrices,\n    viewport: projectProps.viewport\n  }).slice();\n\n  for (let i = 0; i < opts.shadowMatrices.length; i++) {\n    const viewProjectionMatrix = viewProjectionMatrices[i];\n    const viewProjectionMatrixCentered = viewProjectionMatrix\n      .clone()\n      .translate(new Vector3(projectProps.viewport.center).negate());\n\n    if (\n      projectUniforms.coordinateSystem === COORDINATE_SYSTEM.LNGLAT &&\n      projectUniforms.projectionMode === PROJECTION_MODE.WEB_MERCATOR\n    ) {\n      viewProjectionMatrices[i] = viewProjectionMatrixCentered;\n      projectCenters[i] = center;\n    } else {\n      viewProjectionMatrices[i] = viewProjectionMatrix\n        .clone()\n        .multiplyRight(VECTOR_TO_POINT_MATRIX);\n      projectCenters[i] = viewProjectionMatrixCentered.transform(center);\n    }\n  }\n\n  const uniforms: ShadowModuleUniforms & ShadowModuleBindings = {\n    drawShadowMap: Boolean(opts.drawToShadowMap),\n    useShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,\n    color: opts.shadowColor || DEFAULT_SHADOW_COLOR,\n    lightId: opts.shadowLightId || 0,\n    lightCount: opts.shadowMatrices.length,\n    shadow_uShadowMap0: opts.dummyShadowMap!,\n    shadow_uShadowMap1: opts.dummyShadowMap!\n  };\n\n  for (let i = 0; i < viewProjectionMatrices.length; i++) {\n    uniforms[`viewProjectionMatrix${i}`] = viewProjectionMatrices[i];\n    uniforms[`projectCenter${i}`] = projectCenters[i];\n  }\n\n  for (let i = 0; i < 2; i++) {\n    uniforms[`shadow_uShadowMap${i}`] =\n      (opts.shadowMaps && opts.shadowMaps[i]) || opts.dummyShadowMap;\n  }\n  return uniforms;\n}\n\nexport default {\n  name: 'shadow',\n  dependencies: [project],\n  vs,\n  fs,\n  inject: {\n    'vs:DECKGL_FILTER_GL_POSITION': `\n    position = shadow_setVertexPosition(geometry.position);\n    `,\n    'fs:DECKGL_FILTER_COLOR': `\n    color = shadow_filterShadowColor(color);\n    `\n  },\n  getUniforms: createShadowUniforms,\n  uniformTypes: {\n    drawShadowMap: 'f32',\n    useShadowMap: 'f32',\n    color: 'vec4<f32>',\n    lightId: 'i32',\n    lightCount: 'f32',\n    viewProjectionMatrix0: 'mat4x4<f32>',\n    viewProjectionMatrix1: 'mat4x4<f32>',\n    projectCenter0: 'vec4<f32>',\n    projectCenter1: 'vec4<f32>'\n  }\n} as const satisfies ShaderModule<ShadowModuleProps, ShadowModuleUniforms, ShadowModuleBindings>;\n\n// TODO replace with type from math.gl\ntype NumberArray4 = [number, number, number, number];\ntype NumberArray16 = [\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number\n];\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}