{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Layer, project32, picking, log, UNIT } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/engine';\nimport { iconUniforms } from \"./icon-layer-uniforms.js\";\nimport vs from \"./icon-layer-vertex.glsl.js\";\nimport fs from \"./icon-layer-fragment.glsl.js\";\nimport IconManager from \"./icon-manager.js\";\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  iconAtlas: {\n    type: 'image',\n    value: null,\n    async: true\n  },\n  iconMapping: {\n    type: 'object',\n    value: {},\n    async: true\n  },\n  sizeScale: {\n    type: 'number',\n    value: 1,\n    min: 0\n  },\n  billboard: true,\n  sizeUnits: 'pixels',\n  sizeMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  //  min point radius in pixels\n  sizeMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  // max point radius in pixels\n  alphaCutoff: {\n    type: 'number',\n    value: 0.05,\n    min: 0,\n    max: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getIcon: {\n    type: 'accessor',\n    value: x => x.icon\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getSize: {\n    type: 'accessor',\n    value: 1\n  },\n  getAngle: {\n    type: 'accessor',\n    value: 0\n  },\n  getPixelOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  onIconError: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  textureParameters: {\n    type: 'object',\n    ignore: true,\n    value: null\n  }\n};\n/** Render raster icons at given coordinates. */\nclass IconLayer extends Layer {\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, picking, iconUniforms]\n    });\n  }\n  initializeState() {\n    this.state = {\n      iconManager: new IconManager(this.context.device, {\n        onUpdate: this._onUpdate.bind(this),\n        onError: this._onError.bind(this)\n      })\n    };\n    const attributeManager = this.getAttributeManager();\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 'float64',\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceSizes: {\n        size: 1,\n        transition: true,\n        accessor: 'getSize',\n        defaultValue: 1\n      },\n      instanceOffsets: {\n        size: 2,\n        accessor: 'getIcon',\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        transform: this.getInstanceOffset\n      },\n      instanceIconFrames: {\n        size: 4,\n        accessor: 'getIcon',\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        transform: this.getInstanceIconFrame\n      },\n      instanceColorModes: {\n        size: 1,\n        type: 'uint8',\n        accessor: 'getIcon',\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        transform: this.getInstanceColorMode\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: 'unorm8',\n        transition: true,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceAngles: {\n        size: 1,\n        transition: true,\n        accessor: 'getAngle'\n      },\n      instancePixelOffset: {\n        size: 2,\n        transition: true,\n        accessor: 'getPixelOffset'\n      }\n    });\n    /* eslint-enable max-len */\n  }\n  /* eslint-disable max-statements, complexity */\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const attributeManager = this.getAttributeManager();\n    const {\n      iconAtlas,\n      iconMapping,\n      data,\n      getIcon,\n      textureParameters\n    } = props;\n    const {\n      iconManager\n    } = this.state;\n    if (typeof iconAtlas === 'string') {\n      return;\n    }\n    // internalState is always defined during updateState\n    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading('iconAtlas');\n    iconManager.setProps({\n      loadOptions: props.loadOptions,\n      autoPacking: !prePacked,\n      iconAtlas,\n      iconMapping: prePacked ? iconMapping : null,\n      textureParameters\n    });\n    // prepacked iconAtlas from user\n    if (prePacked) {\n      if (oldProps.iconMapping !== props.iconMapping) {\n        attributeManager.invalidate('getIcon');\n      }\n    } else if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {\n      // Auto packing - getIcon is expected to return an object\n      iconManager.packIcons(data, getIcon);\n    }\n    if (changeFlags.extensionsChanged) {\n      this.state.model?.destroy();\n      this.state.model = this._getModel();\n      attributeManager.invalidateAll();\n    }\n  }\n  /* eslint-enable max-statements, complexity */\n  get isLoaded() {\n    return super.isLoaded && this.state.iconManager.isLoaded;\n  }\n  finalizeState(context) {\n    super.finalizeState(context);\n    // Release resources held by the icon manager\n    this.state.iconManager.finalize();\n  }\n  draw(_ref) {\n    let {\n      uniforms\n    } = _ref;\n    const {\n      sizeScale,\n      sizeMinPixels,\n      sizeMaxPixels,\n      sizeUnits,\n      billboard,\n      alphaCutoff\n    } = this.props;\n    const {\n      iconManager\n    } = this.state;\n    const iconsTexture = iconManager.getTexture();\n    if (iconsTexture) {\n      const model = this.state.model;\n      const iconProps = {\n        iconsTexture,\n        iconsTextureDim: [iconsTexture.width, iconsTexture.height],\n        sizeUnits: UNIT[sizeUnits],\n        sizeScale,\n        sizeMinPixels,\n        sizeMaxPixels,\n        billboard,\n        alphaCutoff\n      };\n      model.shaderInputs.setProps({\n        icon: iconProps\n      });\n      model.draw(this.context.renderPass);\n    }\n  }\n  _getModel() {\n    // The icon-layer vertex shader uses 2d positions\n    // specifed via: in vec2 positions;\n    const positions = [-1, -1, 1, -1, -1, 1, 1, 1];\n    return new Model(this.context.device, {\n      ...this.getShaders(),\n      id: this.props.id,\n      bufferLayout: this.getAttributeManager().getBufferLayouts(),\n      geometry: new Geometry({\n        topology: 'triangle-strip',\n        attributes: {\n          // The size must be explicitly passed here otherwise luma.gl\n          // will default to assuming that positions are 3D (x,y,z)\n          positions: {\n            size: 2,\n            value: new Float32Array(positions)\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n  _onUpdate() {\n    this.setNeedsRedraw();\n  }\n  _onError(evt) {\n    const onIconError = this.getCurrentLayer()?.props.onIconError;\n    if (onIconError) {\n      onIconError(evt);\n    } else {\n      log.error(evt.error.message)();\n    }\n  }\n  getInstanceOffset(icon) {\n    const {\n      width,\n      height,\n      anchorX = width / 2,\n      anchorY = height / 2\n    } = this.state.iconManager.getIconMapping(icon);\n    return [width / 2 - anchorX, height / 2 - anchorY];\n  }\n  getInstanceColorMode(icon) {\n    const mapping = this.state.iconManager.getIconMapping(icon);\n    return mapping.mask ? 1 : 0;\n  }\n  getInstanceIconFrame(icon) {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.state.iconManager.getIconMapping(icon);\n    return [x, y, width, height];\n  }\n}\nIconLayer.defaultProps = defaultProps;\nIconLayer.layerName = 'IconLayer';\nexport default IconLayer;\n//# sourceMappingURL=icon-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}