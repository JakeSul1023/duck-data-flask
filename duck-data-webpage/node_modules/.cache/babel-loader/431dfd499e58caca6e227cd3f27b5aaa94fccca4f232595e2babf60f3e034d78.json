{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { assert } from \"../utils/assert.js\";\nimport { getAccessorArrayTypeAndLength } from \"../gltf-utils/gltf-utils.js\";\n// This is a post processor for loaded glTF files\n// The goal is to make the loaded data easier to use in WebGL applications\n//\n// Functions:\n// * Resolve indexed arrays structure of glTF into a linked tree.\n// * Translate stringified enum keys and values into WebGL constants.\n// * Load images (optional)\n// ENUM LOOKUP\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst BYTES = {\n  5120: 1,\n  // BYTE\n  5121: 1,\n  // UNSIGNED_BYTE\n  5122: 2,\n  // SHORT\n  5123: 2,\n  // UNSIGNED_SHORT\n  5125: 4,\n  // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\nconst GL_SAMPLER = {\n  // Sampler parameters\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n  // Sampler default values\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\nconst SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\n// When undefined, a sampler with repeat wrapping and auto filtering should be used.\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\nconst DEFAULT_SAMPLER_PARAMETERS = {\n  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,\n  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,\n  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,\n  [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT\n};\nfunction makeDefaultSampler() {\n  return {\n    id: 'default-sampler',\n    parameters: DEFAULT_SAMPLER_PARAMETERS\n  };\n}\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\nclass GLTFPostProcessor {\n  baseUri = '';\n  // @ts-expect-error\n  jsonUnprocessed;\n  // @ts-expect-error\n  json;\n  buffers = [];\n  images = [];\n  postProcess(gltf, options = {}) {\n    const {\n      json,\n      buffers = [],\n      images = []\n    } = gltf;\n    // @ts-expect-error\n    const {\n      baseUri = ''\n    } = gltf;\n    assert(json);\n    this.baseUri = baseUri;\n    this.buffers = buffers;\n    this.images = images;\n    this.jsonUnprocessed = json;\n    this.json = this._resolveTree(gltf.json, options);\n    return this.json;\n  }\n  // Convert indexed glTF structure into tree structure\n  // cross-link index resolution, enum lookup, convenience calculations\n  // eslint-disable-next-line complexity, max-statements\n  _resolveTree(gltf, options = {}) {\n    // @ts-expect-error\n    const json = {\n      ...gltf\n    };\n    this.json = json;\n    if (gltf.bufferViews) {\n      json.bufferViews = gltf.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));\n    }\n    if (gltf.images) {\n      json.images = gltf.images.map((image, i) => this._resolveImage(image, i));\n    }\n    if (gltf.samplers) {\n      json.samplers = gltf.samplers.map((sampler, i) => this._resolveSampler(sampler, i));\n    }\n    if (gltf.textures) {\n      json.textures = gltf.textures.map((texture, i) => this._resolveTexture(texture, i));\n    }\n    if (gltf.accessors) {\n      json.accessors = gltf.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));\n    }\n    if (gltf.materials) {\n      json.materials = gltf.materials.map((material, i) => this._resolveMaterial(material, i));\n    }\n    if (gltf.meshes) {\n      json.meshes = gltf.meshes.map((mesh, i) => this._resolveMesh(mesh, i));\n    }\n    if (gltf.nodes) {\n      json.nodes = gltf.nodes.map((node, i) => this._resolveNode(node, i));\n      json.nodes = json.nodes.map((node, i) => this._resolveNodeChildren(node));\n    }\n    if (gltf.skins) {\n      json.skins = gltf.skins.map((skin, i) => this._resolveSkin(skin, i));\n    }\n    if (gltf.scenes) {\n      json.scenes = gltf.scenes.map((scene, i) => this._resolveScene(scene, i));\n    }\n    if (typeof this.json.scene === 'number' && json.scenes) {\n      json.scene = json.scenes[this.json.scene];\n    }\n    return json;\n  }\n  getScene(index) {\n    return this._get(this.json.scenes, index);\n  }\n  getNode(index) {\n    return this._get(this.json.nodes, index);\n  }\n  getSkin(index) {\n    return this._get(this.json.skins, index);\n  }\n  getMesh(index) {\n    return this._get(this.json.meshes, index);\n  }\n  getMaterial(index) {\n    return this._get(this.json.materials, index);\n  }\n  getAccessor(index) {\n    return this._get(this.json.accessors, index);\n  }\n  getCamera(index) {\n    return this._get(this.json.cameras, index);\n  }\n  getTexture(index) {\n    return this._get(this.json.textures, index);\n  }\n  getSampler(index) {\n    return this._get(this.json.samplers, index);\n  }\n  getImage(index) {\n    return this._get(this.json.images, index);\n  }\n  getBufferView(index) {\n    return this._get(this.json.bufferViews, index);\n  }\n  getBuffer(index) {\n    return this._get(this.json.buffers, index);\n  }\n  _get(array, index) {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = array && array[index];\n    if (!object) {\n      console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n  // PARSING HELPERS\n  _resolveScene(scene, index) {\n    return {\n      ...scene,\n      // @ts-ignore\n      id: scene.id || `scene-${index}`,\n      nodes: (scene.nodes || []).map(node => this.getNode(node))\n    };\n  }\n  _resolveNode(gltfNode, index) {\n    // @ts-expect-error\n    const node = {\n      ...gltfNode,\n      // @ts-expect-error id could already be present, glTF standard does not prevent it\n      id: gltfNode?.id || `node-${index}`\n    };\n    if (gltfNode.mesh !== undefined) {\n      node.mesh = this.getMesh(gltfNode.mesh);\n    }\n    if (gltfNode.camera !== undefined) {\n      node.camera = this.getCamera(gltfNode.camera);\n    }\n    if (gltfNode.skin !== undefined) {\n      node.skin = this.getSkin(gltfNode.skin);\n    }\n    // TODO deprecated - Delete in v4.0?\n    // @ts-expect-error node.meshes does not seem to be part of the GLTF standard\n    if (gltfNode.meshes !== undefined && gltfNode.meshes.length) {\n      // @ts-expect-error\n      node.mesh = gltfNode.meshes.reduce((accum, meshIndex) => {\n        const mesh = this.getMesh(meshIndex);\n        accum.id = mesh.id;\n        accum.primitives = accum.primitives.concat(mesh.primitives);\n        return accum;\n      }, {\n        primitives: []\n      });\n    }\n    return node;\n  }\n  _resolveNodeChildren(node) {\n    if (node.children) {\n      // @ts-expect-error node.children are numbers at this stage\n      node.children = node.children.map(child => this.getNode(child));\n    }\n    return node;\n  }\n  _resolveSkin(gltfSkin, index) {\n    const inverseBindMatrices = typeof gltfSkin.inverseBindMatrices === 'number' ? this.getAccessor(gltfSkin.inverseBindMatrices) : undefined;\n    return {\n      ...gltfSkin,\n      id: gltfSkin.id || `skin-${index}`,\n      inverseBindMatrices\n    };\n  }\n  _resolveMesh(gltfMesh, index) {\n    const mesh = {\n      ...gltfMesh,\n      id: gltfMesh.id || `mesh-${index}`,\n      primitives: []\n    };\n    if (gltfMesh.primitives) {\n      mesh.primitives = gltfMesh.primitives.map(gltfPrimitive => {\n        const primitive = {\n          ...gltfPrimitive,\n          attributes: {},\n          indices: undefined,\n          material: undefined\n        };\n        const attributes = gltfPrimitive.attributes;\n        for (const attribute in attributes) {\n          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);\n        }\n        if (gltfPrimitive.indices !== undefined) {\n          primitive.indices = this.getAccessor(gltfPrimitive.indices);\n        }\n        if (gltfPrimitive.material !== undefined) {\n          primitive.material = this.getMaterial(gltfPrimitive.material);\n        }\n        return primitive;\n      });\n    }\n    return mesh;\n  }\n  _resolveMaterial(gltfMaterial, index) {\n    // @ts-expect-error\n    const material = {\n      ...gltfMaterial,\n      // @ts-expect-error\n      id: gltfMaterial.id || `material-${index}`\n    };\n    if (material.normalTexture) {\n      material.normalTexture = {\n        ...material.normalTexture\n      };\n      material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n    }\n    if (material.occlusionTexture) {\n      material.occlusionTexture = {\n        ...material.occlusionTexture\n      };\n      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n    }\n    if (material.emissiveTexture) {\n      material.emissiveTexture = {\n        ...material.emissiveTexture\n      };\n      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n    }\n    if (!material.emissiveFactor) {\n      material.emissiveFactor = material.emissiveTexture ? [1, 1, 1] : [0, 0, 0];\n    }\n    if (material.pbrMetallicRoughness) {\n      material.pbrMetallicRoughness = {\n        ...material.pbrMetallicRoughness\n      };\n      const mr = material.pbrMetallicRoughness;\n      if (mr.baseColorTexture) {\n        mr.baseColorTexture = {\n          ...mr.baseColorTexture\n        };\n        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n      }\n      if (mr.metallicRoughnessTexture) {\n        mr.metallicRoughnessTexture = {\n          ...mr.metallicRoughnessTexture\n        };\n        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n      }\n    }\n    return material;\n  }\n  _resolveAccessor(gltfAccessor, index) {\n    // Look up enums\n    const bytesPerComponent = getBytesFromComponentType(gltfAccessor.componentType);\n    const components = getSizeFromAccessorType(gltfAccessor.type);\n    const bytesPerElement = bytesPerComponent * components;\n    const accessor = {\n      ...gltfAccessor,\n      // @ts-expect-error\n      id: gltfAccessor.id || `accessor-${index}`,\n      bytesPerComponent,\n      components,\n      bytesPerElement,\n      value: undefined,\n      bufferView: undefined,\n      sparse: undefined\n    };\n    if (gltfAccessor.bufferView !== undefined) {\n      // Draco encoded meshes don't have bufferView\n      accessor.bufferView = this.getBufferView(gltfAccessor.bufferView);\n    }\n    // Create TypedArray for the accessor\n    // Note: The canonical way to instantiate is to ignore this array and create\n    // WebGLBuffer's using the bufferViews.\n    if (accessor.bufferView) {\n      const buffer = accessor.bufferView.buffer;\n      const {\n        ArrayType,\n        byteLength\n      } = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);\n      const byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n      let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n      if (accessor.bufferView.byteStride) {\n        cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);\n      }\n      accessor.value = new ArrayType(cutBuffer);\n    }\n    return accessor;\n  }\n  /**\n   * Take values of particular accessor from interleaved buffer\n   * various parts of the buffer\n   * @param buffer\n   * @param byteOffset\n   * @param byteStride\n   * @param bytesPerElement\n   * @param count\n   * @returns\n   */\n  _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {\n    const result = new Uint8Array(count * bytesPerElement);\n    for (let i = 0; i < count; i++) {\n      const elementOffset = byteOffset + i * byteStride;\n      result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i * bytesPerElement);\n    }\n    return result.buffer;\n  }\n  _resolveTexture(gltfTexture, index) {\n    return {\n      ...gltfTexture,\n      // @ts-expect-error id could already be present, glTF standard does not prevent it\n      id: gltfTexture.id || `texture-${index}`,\n      sampler: typeof gltfTexture.sampler === 'number' ? this.getSampler(gltfTexture.sampler) : makeDefaultSampler(),\n      source: typeof gltfTexture.source === 'number' ? this.getImage(gltfTexture.source) : undefined\n    };\n  }\n  _resolveSampler(gltfSampler, index) {\n    const sampler = {\n      // @ts-expect-error id could already be present, glTF standard does not prevent it\n      id: gltfSampler.id || `sampler-${index}`,\n      ...gltfSampler,\n      parameters: {}\n    };\n    // Map textual parameters to GL parameter values\n    for (const key in sampler) {\n      const glEnum = this._enumSamplerParameter(key);\n      if (glEnum !== undefined) {\n        sampler.parameters[glEnum] = sampler[key];\n      }\n    }\n    return sampler;\n  }\n  _enumSamplerParameter(key) {\n    return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n  }\n  _resolveImage(gltfImage, index) {\n    const image = {\n      ...gltfImage,\n      // @ts-expect-error id could already be present, glTF standard does not prevent it\n      id: gltfImage.id || `image-${index}`,\n      image: null,\n      bufferView: gltfImage.bufferView !== undefined ? this.getBufferView(gltfImage.bufferView) : undefined\n    };\n    // Check if image has been preloaded by the GLTFLoader\n    // If so, link it into the JSON and drop the URI\n    const preloadedImage = this.images[index];\n    if (preloadedImage) {\n      image.image = preloadedImage;\n    }\n    return image;\n  }\n  _resolveBufferView(gltfBufferView, index) {\n    const bufferIndex = gltfBufferView.buffer;\n    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n    // Add offset of buffer, then offset of buffer view\n    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n    if (gltfBufferView.byteOffset) {\n      byteOffset += gltfBufferView.byteOffset;\n    }\n    const bufferView = {\n      // // @ts-expect-error id could already be present, glTF standard does not prevent it\n      id: `bufferView-${index}`,\n      ...gltfBufferView,\n      // ...this.buffers[bufferIndex],\n      buffer: this.buffers[bufferIndex],\n      data: new Uint8Array(arrayBuffer, byteOffset, gltfBufferView.byteLength)\n    };\n    return bufferView;\n  }\n  _resolveCamera(gltfCamera, index) {\n    const camera = {\n      ...gltfCamera,\n      // @ts-expect-error id could already be present, glTF standard does not prevent it\n      id: gltfCamera.id || `camera-${index}`\n    };\n    // TODO - create 4x4 matrices\n    if (camera.perspective) {\n      // camera.matrix = createPerspectiveMatrix(camera.perspective);\n    }\n    if (camera.orthographic) {\n      // camera.matrix = createOrthographicMatrix(camera.orthographic);\n    }\n    return camera;\n  }\n}\nexport function postProcessGLTF(gltf, options) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}","map":{"version":3,"names":["assert","getAccessorArrayTypeAndLength","COMPONENTS","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","BYTES","GL_SAMPLER","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","REPEAT","LINEAR","NEAREST_MIPMAP_LINEAR","SAMPLER_PARAMETER_GLTF_TO_GL","magFilter","minFilter","wrapS","wrapT","DEFAULT_SAMPLER_PARAMETERS","makeDefaultSampler","id","parameters","getBytesFromComponentType","componentType","getSizeFromAccessorType","type","GLTFPostProcessor","baseUri","jsonUnprocessed","json","buffers","images","postProcess","gltf","options","_resolveTree","bufferViews","map","bufView","i","_resolveBufferView","image","_resolveImage","samplers","sampler","_resolveSampler","textures","texture","_resolveTexture","accessors","accessor","_resolveAccessor","materials","material","_resolveMaterial","meshes","mesh","_resolveMesh","nodes","node","_resolveNode","_resolveNodeChildren","skins","skin","_resolveSkin","scenes","scene","_resolveScene","getScene","index","_get","getNode","getSkin","getMesh","getMaterial","getAccessor","getCamera","cameras","getTexture","getSampler","getImage","getBufferView","getBuffer","array","object","console","warn","gltfNode","undefined","camera","length","reduce","accum","meshIndex","primitives","concat","children","child","gltfSkin","inverseBindMatrices","gltfMesh","gltfPrimitive","primitive","attributes","indices","attribute","gltfMaterial","normalTexture","occlusionTexture","emissiveTexture","emissiveFactor","pbrMetallicRoughness","mr","baseColorTexture","metallicRoughnessTexture","gltfAccessor","bytesPerComponent","components","bytesPerElement","value","bufferView","sparse","buffer","ArrayType","byteLength","byteOffset","cutBuffer","arrayBuffer","slice","byteStride","_getValueFromInterleavedBuffer","count","result","Uint8Array","elementOffset","set","gltfTexture","source","gltfSampler","key","glEnum","_enumSamplerParameter","gltfImage","preloadedImage","gltfBufferView","bufferIndex","data","_resolveCamera","gltfCamera","perspective","orthographic","postProcessGLTF"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/gltf/dist/lib/api/post-process-gltf.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { assert } from \"../utils/assert.js\";\nimport { getAccessorArrayTypeAndLength } from \"../gltf-utils/gltf-utils.js\";\n// This is a post processor for loaded glTF files\n// The goal is to make the loaded data easier to use in WebGL applications\n//\n// Functions:\n// * Resolve indexed arrays structure of glTF into a linked tree.\n// * Translate stringified enum keys and values into WebGL constants.\n// * Load images (optional)\n// ENUM LOOKUP\nconst COMPONENTS = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16\n};\nconst BYTES = {\n    5120: 1, // BYTE\n    5121: 1, // UNSIGNED_BYTE\n    5122: 2, // SHORT\n    5123: 2, // UNSIGNED_SHORT\n    5125: 4, // UNSIGNED_INT\n    5126: 4 // FLOAT\n};\nconst GL_SAMPLER = {\n    // Sampler parameters\n    TEXTURE_MAG_FILTER: 0x2800,\n    TEXTURE_MIN_FILTER: 0x2801,\n    TEXTURE_WRAP_S: 0x2802,\n    TEXTURE_WRAP_T: 0x2803,\n    // Sampler default values\n    REPEAT: 0x2901,\n    LINEAR: 0x2601,\n    NEAREST_MIPMAP_LINEAR: 0x2702\n};\nconst SAMPLER_PARAMETER_GLTF_TO_GL = {\n    magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n    minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n    wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n    wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\n// When undefined, a sampler with repeat wrapping and auto filtering should be used.\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\nconst DEFAULT_SAMPLER_PARAMETERS = {\n    [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,\n    [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,\n    [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,\n    [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT\n};\nfunction makeDefaultSampler() {\n    return {\n        id: 'default-sampler',\n        parameters: DEFAULT_SAMPLER_PARAMETERS\n    };\n}\nfunction getBytesFromComponentType(componentType) {\n    return BYTES[componentType];\n}\nfunction getSizeFromAccessorType(type) {\n    return COMPONENTS[type];\n}\nclass GLTFPostProcessor {\n    baseUri = '';\n    // @ts-expect-error\n    jsonUnprocessed;\n    // @ts-expect-error\n    json;\n    buffers = [];\n    images = [];\n    postProcess(gltf, options = {}) {\n        const { json, buffers = [], images = [] } = gltf;\n        // @ts-expect-error\n        const { baseUri = '' } = gltf;\n        assert(json);\n        this.baseUri = baseUri;\n        this.buffers = buffers;\n        this.images = images;\n        this.jsonUnprocessed = json;\n        this.json = this._resolveTree(gltf.json, options);\n        return this.json;\n    }\n    // Convert indexed glTF structure into tree structure\n    // cross-link index resolution, enum lookup, convenience calculations\n    // eslint-disable-next-line complexity, max-statements\n    _resolveTree(gltf, options = {}) {\n        // @ts-expect-error\n        const json = { ...gltf };\n        this.json = json;\n        if (gltf.bufferViews) {\n            json.bufferViews = gltf.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));\n        }\n        if (gltf.images) {\n            json.images = gltf.images.map((image, i) => this._resolveImage(image, i));\n        }\n        if (gltf.samplers) {\n            json.samplers = gltf.samplers.map((sampler, i) => this._resolveSampler(sampler, i));\n        }\n        if (gltf.textures) {\n            json.textures = gltf.textures.map((texture, i) => this._resolveTexture(texture, i));\n        }\n        if (gltf.accessors) {\n            json.accessors = gltf.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));\n        }\n        if (gltf.materials) {\n            json.materials = gltf.materials.map((material, i) => this._resolveMaterial(material, i));\n        }\n        if (gltf.meshes) {\n            json.meshes = gltf.meshes.map((mesh, i) => this._resolveMesh(mesh, i));\n        }\n        if (gltf.nodes) {\n            json.nodes = gltf.nodes.map((node, i) => this._resolveNode(node, i));\n            json.nodes = json.nodes.map((node, i) => this._resolveNodeChildren(node));\n        }\n        if (gltf.skins) {\n            json.skins = gltf.skins.map((skin, i) => this._resolveSkin(skin, i));\n        }\n        if (gltf.scenes) {\n            json.scenes = gltf.scenes.map((scene, i) => this._resolveScene(scene, i));\n        }\n        if (typeof this.json.scene === 'number' && json.scenes) {\n            json.scene = json.scenes[this.json.scene];\n        }\n        return json;\n    }\n    getScene(index) {\n        return this._get(this.json.scenes, index);\n    }\n    getNode(index) {\n        return this._get(this.json.nodes, index);\n    }\n    getSkin(index) {\n        return this._get(this.json.skins, index);\n    }\n    getMesh(index) {\n        return this._get(this.json.meshes, index);\n    }\n    getMaterial(index) {\n        return this._get(this.json.materials, index);\n    }\n    getAccessor(index) {\n        return this._get(this.json.accessors, index);\n    }\n    getCamera(index) {\n        return this._get(this.json.cameras, index);\n    }\n    getTexture(index) {\n        return this._get(this.json.textures, index);\n    }\n    getSampler(index) {\n        return this._get(this.json.samplers, index);\n    }\n    getImage(index) {\n        return this._get(this.json.images, index);\n    }\n    getBufferView(index) {\n        return this._get(this.json.bufferViews, index);\n    }\n    getBuffer(index) {\n        return this._get(this.json.buffers, index);\n    }\n    _get(array, index) {\n        // check if already resolved\n        if (typeof index === 'object') {\n            return index;\n        }\n        const object = array && array[index];\n        if (!object) {\n            console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n        }\n        return object;\n    }\n    // PARSING HELPERS\n    _resolveScene(scene, index) {\n        return {\n            ...scene,\n            // @ts-ignore\n            id: scene.id || `scene-${index}`,\n            nodes: (scene.nodes || []).map((node) => this.getNode(node))\n        };\n    }\n    _resolveNode(gltfNode, index) {\n        // @ts-expect-error\n        const node = {\n            ...gltfNode,\n            // @ts-expect-error id could already be present, glTF standard does not prevent it\n            id: gltfNode?.id || `node-${index}`\n        };\n        if (gltfNode.mesh !== undefined) {\n            node.mesh = this.getMesh(gltfNode.mesh);\n        }\n        if (gltfNode.camera !== undefined) {\n            node.camera = this.getCamera(gltfNode.camera);\n        }\n        if (gltfNode.skin !== undefined) {\n            node.skin = this.getSkin(gltfNode.skin);\n        }\n        // TODO deprecated - Delete in v4.0?\n        // @ts-expect-error node.meshes does not seem to be part of the GLTF standard\n        if (gltfNode.meshes !== undefined && gltfNode.meshes.length) {\n            // @ts-expect-error\n            node.mesh = gltfNode.meshes.reduce((accum, meshIndex) => {\n                const mesh = this.getMesh(meshIndex);\n                accum.id = mesh.id;\n                accum.primitives = accum.primitives.concat(mesh.primitives);\n                return accum;\n            }, { primitives: [] });\n        }\n        return node;\n    }\n    _resolveNodeChildren(node) {\n        if (node.children) {\n            // @ts-expect-error node.children are numbers at this stage\n            node.children = node.children.map((child) => this.getNode(child));\n        }\n        return node;\n    }\n    _resolveSkin(gltfSkin, index) {\n        const inverseBindMatrices = typeof gltfSkin.inverseBindMatrices === 'number'\n            ? this.getAccessor(gltfSkin.inverseBindMatrices)\n            : undefined;\n        return {\n            ...gltfSkin,\n            id: gltfSkin.id || `skin-${index}`,\n            inverseBindMatrices\n        };\n    }\n    _resolveMesh(gltfMesh, index) {\n        const mesh = {\n            ...gltfMesh,\n            id: gltfMesh.id || `mesh-${index}`,\n            primitives: []\n        };\n        if (gltfMesh.primitives) {\n            mesh.primitives = gltfMesh.primitives.map((gltfPrimitive) => {\n                const primitive = {\n                    ...gltfPrimitive,\n                    attributes: {},\n                    indices: undefined,\n                    material: undefined\n                };\n                const attributes = gltfPrimitive.attributes;\n                for (const attribute in attributes) {\n                    primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);\n                }\n                if (gltfPrimitive.indices !== undefined) {\n                    primitive.indices = this.getAccessor(gltfPrimitive.indices);\n                }\n                if (gltfPrimitive.material !== undefined) {\n                    primitive.material = this.getMaterial(gltfPrimitive.material);\n                }\n                return primitive;\n            });\n        }\n        return mesh;\n    }\n    _resolveMaterial(gltfMaterial, index) {\n        // @ts-expect-error\n        const material = {\n            ...gltfMaterial,\n            // @ts-expect-error\n            id: gltfMaterial.id || `material-${index}`\n        };\n        if (material.normalTexture) {\n            material.normalTexture = { ...material.normalTexture };\n            material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n        }\n        if (material.occlusionTexture) {\n            material.occlusionTexture = { ...material.occlusionTexture };\n            material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n        }\n        if (material.emissiveTexture) {\n            material.emissiveTexture = { ...material.emissiveTexture };\n            material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n        }\n        if (!material.emissiveFactor) {\n            material.emissiveFactor = material.emissiveTexture ? [1, 1, 1] : [0, 0, 0];\n        }\n        if (material.pbrMetallicRoughness) {\n            material.pbrMetallicRoughness = { ...material.pbrMetallicRoughness };\n            const mr = material.pbrMetallicRoughness;\n            if (mr.baseColorTexture) {\n                mr.baseColorTexture = { ...mr.baseColorTexture };\n                mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n            }\n            if (mr.metallicRoughnessTexture) {\n                mr.metallicRoughnessTexture = { ...mr.metallicRoughnessTexture };\n                mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n            }\n        }\n        return material;\n    }\n    _resolveAccessor(gltfAccessor, index) {\n        // Look up enums\n        const bytesPerComponent = getBytesFromComponentType(gltfAccessor.componentType);\n        const components = getSizeFromAccessorType(gltfAccessor.type);\n        const bytesPerElement = bytesPerComponent * components;\n        const accessor = {\n            ...gltfAccessor,\n            // @ts-expect-error\n            id: gltfAccessor.id || `accessor-${index}`,\n            bytesPerComponent,\n            components,\n            bytesPerElement,\n            value: undefined,\n            bufferView: undefined,\n            sparse: undefined\n        };\n        if (gltfAccessor.bufferView !== undefined) {\n            // Draco encoded meshes don't have bufferView\n            accessor.bufferView = this.getBufferView(gltfAccessor.bufferView);\n        }\n        // Create TypedArray for the accessor\n        // Note: The canonical way to instantiate is to ignore this array and create\n        // WebGLBuffer's using the bufferViews.\n        if (accessor.bufferView) {\n            const buffer = accessor.bufferView.buffer;\n            const { ArrayType, byteLength } = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);\n            const byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n            let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n            if (accessor.bufferView.byteStride) {\n                cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);\n            }\n            accessor.value = new ArrayType(cutBuffer);\n        }\n        return accessor;\n    }\n    /**\n     * Take values of particular accessor from interleaved buffer\n     * various parts of the buffer\n     * @param buffer\n     * @param byteOffset\n     * @param byteStride\n     * @param bytesPerElement\n     * @param count\n     * @returns\n     */\n    _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {\n        const result = new Uint8Array(count * bytesPerElement);\n        for (let i = 0; i < count; i++) {\n            const elementOffset = byteOffset + i * byteStride;\n            result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i * bytesPerElement);\n        }\n        return result.buffer;\n    }\n    _resolveTexture(gltfTexture, index) {\n        return {\n            ...gltfTexture,\n            // @ts-expect-error id could already be present, glTF standard does not prevent it\n            id: gltfTexture.id || `texture-${index}`,\n            sampler: typeof gltfTexture.sampler === 'number'\n                ? this.getSampler(gltfTexture.sampler)\n                : makeDefaultSampler(),\n            source: typeof gltfTexture.source === 'number' ? this.getImage(gltfTexture.source) : undefined\n        };\n    }\n    _resolveSampler(gltfSampler, index) {\n        const sampler = {\n            // @ts-expect-error id could already be present, glTF standard does not prevent it\n            id: gltfSampler.id || `sampler-${index}`,\n            ...gltfSampler,\n            parameters: {}\n        };\n        // Map textual parameters to GL parameter values\n        for (const key in sampler) {\n            const glEnum = this._enumSamplerParameter(key);\n            if (glEnum !== undefined) {\n                sampler.parameters[glEnum] = sampler[key];\n            }\n        }\n        return sampler;\n    }\n    _enumSamplerParameter(key) {\n        return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n    }\n    _resolveImage(gltfImage, index) {\n        const image = {\n            ...gltfImage,\n            // @ts-expect-error id could already be present, glTF standard does not prevent it\n            id: gltfImage.id || `image-${index}`,\n            image: null,\n            bufferView: gltfImage.bufferView !== undefined ? this.getBufferView(gltfImage.bufferView) : undefined\n        };\n        // Check if image has been preloaded by the GLTFLoader\n        // If so, link it into the JSON and drop the URI\n        const preloadedImage = this.images[index];\n        if (preloadedImage) {\n            image.image = preloadedImage;\n        }\n        return image;\n    }\n    _resolveBufferView(gltfBufferView, index) {\n        const bufferIndex = gltfBufferView.buffer;\n        const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n        // Add offset of buffer, then offset of buffer view\n        let byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n        if (gltfBufferView.byteOffset) {\n            byteOffset += gltfBufferView.byteOffset;\n        }\n        const bufferView = {\n            // // @ts-expect-error id could already be present, glTF standard does not prevent it\n            id: `bufferView-${index}`,\n            ...gltfBufferView,\n            // ...this.buffers[bufferIndex],\n            buffer: this.buffers[bufferIndex],\n            data: new Uint8Array(arrayBuffer, byteOffset, gltfBufferView.byteLength)\n        };\n        return bufferView;\n    }\n    _resolveCamera(gltfCamera, index) {\n        const camera = {\n            ...gltfCamera,\n            // @ts-expect-error id could already be present, glTF standard does not prevent it\n            id: gltfCamera.id || `camera-${index}`\n        };\n        // TODO - create 4x4 matrices\n        if (camera.perspective) {\n            // camera.matrix = createPerspectiveMatrix(camera.perspective);\n        }\n        if (camera.orthographic) {\n            // camera.matrix = createOrthographicMatrix(camera.orthographic);\n        }\n        return camera;\n    }\n}\nexport function postProcessGLTF(gltf, options) {\n    return new GLTFPostProcessor().postProcess(gltf, options);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}