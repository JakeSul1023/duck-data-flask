{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { MD5Hash } from '@loaders.gl/crypto';\nimport { DeflateCompression, NoCompression } from '@loaders.gl/compression';\nimport { IndexedArchive, parseZipLocalFileHeader } from '@loaders.gl/zip';\n/**\n * Handling different compression types in zip\n */\nconst COMPRESSION_METHODS = {\n  /** No compression */\n  0: data => new NoCompression().decompress(data),\n  /** Deflation */\n  8: data => new DeflateCompression({\n    raw: true\n  }).decompress(data)\n};\n/**\n * Class for handling information about 3tz file\n */\nexport class Tiles3DArchive extends IndexedArchive {\n  /** hash info */\n  hashTable;\n  /**\n   * creates Tiles3DArchive handler\n   * @param fileProvider - FileProvider with the whole file\n   * @param hashTable - hash info\n   */\n  constructor(fileProvider, hashTable, fileName) {\n    super(fileProvider, hashTable, fileName);\n    this.hashTable = hashTable;\n  }\n  /**\n   * Returns file with the given path from 3tz archive\n   * @param path - path inside the 3tz\n   * @returns buffer with ready to use file\n   */\n  async getFile(path) {\n    // sometimes paths are not in lower case when hash file is created,\n    // so first we're looking for lower case file name and then for original one\n    let data = await this.getFileBytes(path.toLocaleLowerCase());\n    if (!data) {\n      data = await this.getFileBytes(path);\n    }\n    if (!data) {\n      throw new Error(`No such file in the archive: ${path}`);\n    }\n    return data;\n  }\n  /**\n   * Trying to get raw file data by adress\n   * @param path - path inside the archive\n   * @returns buffer with the raw file data\n   */\n  async getFileBytes(path) {\n    let uncompressedFile;\n    if (this.hashTable) {\n      const arrayBuffer = new TextEncoder().encode(path).buffer;\n      const nameHash = await new MD5Hash().hash(arrayBuffer, 'hex');\n      const byteOffset = this.hashTable[nameHash];\n      if (byteOffset === undefined) {\n        return null;\n      }\n      const localFileHeader = await parseZipLocalFileHeader(byteOffset, this.fileProvider);\n      if (!localFileHeader) {\n        return null;\n      }\n      const compressedFile = await this.fileProvider.slice(localFileHeader.fileDataOffset, localFileHeader.fileDataOffset + localFileHeader.compressedSize);\n      const compressionMethod = COMPRESSION_METHODS[localFileHeader.compressionMethod];\n      if (!compressionMethod) {\n        throw Error('Only Deflation compression is supported');\n      }\n      uncompressedFile = await compressionMethod(compressedFile);\n    } else {\n      uncompressedFile = await this.getFileWithoutHash(path);\n    }\n    return uncompressedFile;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}