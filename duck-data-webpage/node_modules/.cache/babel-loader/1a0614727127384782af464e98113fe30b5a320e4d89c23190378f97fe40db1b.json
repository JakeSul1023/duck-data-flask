{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ImageSource } from '@loaders.gl/loader-utils';\n// import type {ImageSourceProps} from '@loaders.gl/loader-utils';\n// import {ImageSource} from '@loaders.gl/loader-utils';\nexport const ArcGISImageServerSource = {\n  name: 'ArcGISImageServer',\n  id: 'arcgis-image-server',\n  module: 'wms',\n  version: '0.0.0',\n  extensions: [],\n  mimeTypes: [],\n  options: {\n    'arcgis-image-server': {\n      // TODO - add options here\n    }\n  },\n  type: 'arcgis-image-server',\n  fromUrl: true,\n  fromBlob: false,\n  testURL: url => url.toLowerCase().includes('ImageServer'),\n  createDataSource: (url, props) => new ArcGISImageSource(url, props)\n};\n/**\n * ArcGIS ImageServer\n * Note - exports a big API, that could be exposed here if there is a use case\n * @see https://developers.arcgis.com/rest/services-reference/enterprise/image-service.htm\n */\nexport class ArcGISImageSource extends ImageSource {\n  url;\n  data;\n  constructor(url, props) {\n    super(props);\n    this.url = url;\n    this.data = url;\n  }\n  // ImageSource (normalized endpoints)\n  async getMetadata() {\n    return await this.metadata();\n    // TODO - normalize metadata\n  }\n  async getImage(parameters) {\n    throw new Error('not implemented');\n    // TODO - Map generic parameters to ArcGIS specific parameters\n    // return await this.exportImage(parameters);\n  }\n  // ImageServer endpoints\n  async metadata() {\n    // We just need a JSON parsing...\n    // return this.getUrl({path: '', ...options});\n    throw new Error('not implemented');\n  }\n  /**\n   * Form a URL to an ESRI ImageServer\n   // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&compressionQuality=&bandIds=&mosaicRule=&renderingRule=&f=image`,\n   */\n  exportImage(options) {\n    // See WMSService.getMap()\n    throw new Error('not implemented');\n  }\n  // URL creators\n  metadataURL(options) {\n    return `${this.url}?f=pjson`;\n  }\n  /**\n   * Form a URL to an ESRI ImageServer\n   // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?\n   //   bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&\n   //   size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&\n   //   noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&\n   //   compressionQuality=&bandIds=&mosaicRule=&renderingRule=&\n   //   f=image\n   */\n  exportImageURL(options) {\n    const bbox = `bbox=${options.bbox[0]},${options.bbox[1]},${options.bbox[2]},${options.bbox[3]}`;\n    const size = `size=${options.width},${options.height}`;\n    const arcgisOptions = {\n      ...options,\n      bbox,\n      size\n    };\n    // @ts-expect-error\n    delete arcgisOptions.width;\n    // @ts-expect-error\n    delete arcgisOptions.height;\n    return this.getUrl('exportImage', arcgisOptions);\n  }\n  // INTERNAL METHODS\n  /**\n   * @note protected, since perhaps getWMSUrl may need to be overridden to handle certain backends?\n   * @note if override is common, maybe add a callback prop?\n   * */\n  getUrl(path, options, extra) {\n    let url = `${this.url}/${path}`;\n    let first = true;\n    for (const [key, value] of Object.entries(options)) {\n      url += first ? '?' : '&';\n      first = false;\n      if (Array.isArray(value)) {\n        url += `${key.toUpperCase()}=${value.join(',')}`;\n      } else {\n        url += `${key.toUpperCase()}=${value ? String(value) : ''}`;\n      }\n    }\n    return url;\n  }\n  /** Checks for and parses a WMS XML formatted ServiceError and throws an exception */\n  async checkResponse(response) {\n    if (!response.ok) {\n      // } || response.headers['content-type'] === WMSErrorLoader.mimeTypes[0]) {\n      // const arrayBuffer = await response.arrayBuffer();\n      // const error = await WMSErrorLoader.parse(arrayBuffer, this.loadOptions);\n      throw new Error('error');\n    }\n  }\n}","map":{"version":3,"names":["ImageSource","ArcGISImageServerSource","name","id","module","version","extensions","mimeTypes","options","type","fromUrl","fromBlob","testURL","url","toLowerCase","includes","createDataSource","props","ArcGISImageSource","data","constructor","getMetadata","metadata","getImage","parameters","Error","exportImage","metadataURL","exportImageURL","bbox","size","width","height","arcgisOptions","getUrl","path","extra","first","key","value","Object","entries","Array","isArray","toUpperCase","join","String","checkResponse","response","ok"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/wms/dist/services/arcgis/arcgis-image-server.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ImageSource } from '@loaders.gl/loader-utils';\n// import type {ImageSourceProps} from '@loaders.gl/loader-utils';\n// import {ImageSource} from '@loaders.gl/loader-utils';\nexport const ArcGISImageServerSource = {\n    name: 'ArcGISImageServer',\n    id: 'arcgis-image-server',\n    module: 'wms',\n    version: '0.0.0',\n    extensions: [],\n    mimeTypes: [],\n    options: {\n        'arcgis-image-server': {\n        // TODO - add options here\n        }\n    },\n    type: 'arcgis-image-server',\n    fromUrl: true,\n    fromBlob: false,\n    testURL: (url) => url.toLowerCase().includes('ImageServer'),\n    createDataSource: (url, props) => new ArcGISImageSource(url, props)\n};\n/**\n * ArcGIS ImageServer\n * Note - exports a big API, that could be exposed here if there is a use case\n * @see https://developers.arcgis.com/rest/services-reference/enterprise/image-service.htm\n */\nexport class ArcGISImageSource extends ImageSource {\n    url;\n    data;\n    constructor(url, props) {\n        super(props);\n        this.url = url;\n        this.data = url;\n    }\n    // ImageSource (normalized endpoints)\n    async getMetadata() {\n        return (await this.metadata());\n        // TODO - normalize metadata\n    }\n    async getImage(parameters) {\n        throw new Error('not implemented');\n        // TODO - Map generic parameters to ArcGIS specific parameters\n        // return await this.exportImage(parameters);\n    }\n    // ImageServer endpoints\n    async metadata() {\n        // We just need a JSON parsing...\n        // return this.getUrl({path: '', ...options});\n        throw new Error('not implemented');\n    }\n    /**\n     * Form a URL to an ESRI ImageServer\n     // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&compressionQuality=&bandIds=&mosaicRule=&renderingRule=&f=image`,\n     */\n    exportImage(options) {\n        // See WMSService.getMap()\n        throw new Error('not implemented');\n    }\n    // URL creators\n    metadataURL(options) {\n        return `${this.url}?f=pjson`;\n    }\n    /**\n     * Form a URL to an ESRI ImageServer\n     // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?\n     //   bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&\n     //   size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&\n     //   noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&\n     //   compressionQuality=&bandIds=&mosaicRule=&renderingRule=&\n     //   f=image\n     */\n    exportImageURL(options) {\n        const bbox = `bbox=${options.bbox[0]},${options.bbox[1]},${options.bbox[2]},${options.bbox[3]}`;\n        const size = `size=${options.width},${options.height}`;\n        const arcgisOptions = { ...options, bbox, size };\n        // @ts-expect-error\n        delete arcgisOptions.width;\n        // @ts-expect-error\n        delete arcgisOptions.height;\n        return this.getUrl('exportImage', arcgisOptions);\n    }\n    // INTERNAL METHODS\n    /**\n     * @note protected, since perhaps getWMSUrl may need to be overridden to handle certain backends?\n     * @note if override is common, maybe add a callback prop?\n     * */\n    getUrl(path, options, extra) {\n        let url = `${this.url}/${path}`;\n        let first = true;\n        for (const [key, value] of Object.entries(options)) {\n            url += first ? '?' : '&';\n            first = false;\n            if (Array.isArray(value)) {\n                url += `${key.toUpperCase()}=${value.join(',')}`;\n            }\n            else {\n                url += `${key.toUpperCase()}=${value ? String(value) : ''}`;\n            }\n        }\n        return url;\n    }\n    /** Checks for and parses a WMS XML formatted ServiceError and throws an exception */\n    async checkResponse(response) {\n        if (!response.ok) {\n            // } || response.headers['content-type'] === WMSErrorLoader.mimeTypes[0]) {\n            // const arrayBuffer = await response.arrayBuffer();\n            // const error = await WMSErrorLoader.parse(arrayBuffer, this.loadOptions);\n            throw new Error('error');\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}