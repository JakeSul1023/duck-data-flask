{"ast":null,"code":"// GEO METADATA\n/**\n * Reads the GeoMetadata object from the metadata\n * @note geoarrow / parquet schema is stringified into a single key-value pair in the parquet metadata\n */\nexport function getGeoMetadata(schema) {\n  const geoMetadata = parseJSONStringMetadata(schema, 'geo');\n  if (!geoMetadata) {\n    return null;\n  }\n  for (const column of Object.values(geoMetadata.columns || {})) {\n    if (column.encoding) {\n      column.encoding = column.encoding.toLowerCase();\n    }\n  }\n  return geoMetadata;\n}\n/**\n * Stores a geoarrow / geoparquet geo metadata object in the schema\n * @note geoarrow / geoparquet geo metadata is a single stringified JSON field\n */\nexport function setGeoMetadata(schema, geoMetadata) {\n  const stringifiedGeoMetadata = JSON.stringify(geoMetadata);\n  schema.metadata.geo = stringifiedGeoMetadata;\n}\n/**\n * Unpacks geo metadata into separate metadata fields (parses the long JSON string)\n * @note geoarrow / parquet schema is stringified into a single key-value pair in the parquet metadata\n */\nexport function unpackGeoMetadata(schema) {\n  const geoMetadata = getGeoMetadata(schema);\n  if (!geoMetadata) {\n    return;\n  }\n  // Store Parquet Schema Level Metadata\n  const {\n    version,\n    primary_column,\n    columns\n  } = geoMetadata;\n  if (version) {\n    schema.metadata['geo.version'] = version;\n  }\n  if (primary_column) {\n    schema.metadata['geo.primary_column'] = primary_column;\n  }\n  // store column names as comma separated list\n  schema.metadata['geo.columns'] = Object.keys(columns || {}).join('');\n  for (const [columnName, columnMetadata] of Object.entries(columns || {})) {\n    const field = schema.fields.find(field => field.name === columnName);\n    if (field) {\n      if (field.name === primary_column) {\n        setFieldMetadata(field, 'geo.primary_field', 'true');\n      }\n      unpackGeoFieldMetadata(field, columnMetadata);\n    }\n  }\n}\n// eslint-disable-next-line complexity\nfunction unpackGeoFieldMetadata(field, columnMetadata) {\n  for (const [key, value] of Object.entries(columnMetadata || {})) {\n    switch (key) {\n      case 'geometry_types':\n        setFieldMetadata(field, `geo.${key}`, value.join(','));\n        break;\n      case 'bbox':\n        setFieldMetadata(field, `geo.crs.${key}`, JSON.stringify(value));\n        break;\n      case 'crs':\n        // @ts-ignore\n        for (const [crsKey, crsValue] of Object.entries(value || {})) {\n          switch (crsKey) {\n            case 'id':\n              // prettier-ignore\n              const crsId = typeof crsValue === 'object' ?\n              // @ts-ignore\n              `${crsValue?.authority}:${crsValue?.code}` : JSON.stringify(crsValue);\n              setFieldMetadata(field, `geo.crs.${crsKey}`, crsId);\n              break;\n            default:\n              setFieldMetadata(field, `geo.crs.${crsKey}`, typeof crsValue === 'string' ? crsValue : JSON.stringify(crsValue));\n              break;\n          }\n        }\n        break;\n      case 'edges':\n      default:\n        setFieldMetadata(field, `geo.${key}`, typeof value === 'string' ? value : JSON.stringify(value));\n    }\n  }\n}\nfunction setFieldMetadata(field, key, value) {\n  field.metadata = field.metadata || {};\n  field.metadata[key] = value;\n}\n// HELPERS\n/** Parse a key with stringified arrow metadata */\nexport function parseJSONStringMetadata(schema, metadataKey) {\n  const stringifiedMetadata = schema.metadata[metadataKey];\n  if (!stringifiedMetadata) {\n    return null;\n  }\n  try {\n    const metadata = JSON.parse(stringifiedMetadata);\n    if (!metadata || typeof metadata !== 'object') {\n      return null;\n    }\n    return metadata;\n  } catch {\n    return null;\n  }\n}\nexport function unpackJSONStringMetadata(schema, metadataKey) {\n  const json = parseJSONStringMetadata(schema, metadataKey);\n  for (const [key, value] of Object.entries(json || {})) {\n    schema.metadata[`${metadataKey}.${key}`] = typeof value === 'string' ? value : JSON.stringify(value);\n  }\n}","map":{"version":3,"names":["getGeoMetadata","schema","geoMetadata","parseJSONStringMetadata","column","Object","values","columns","encoding","toLowerCase","setGeoMetadata","stringifiedGeoMetadata","JSON","stringify","metadata","geo","unpackGeoMetadata","version","primary_column","keys","join","columnName","columnMetadata","entries","field","fields","find","name","setFieldMetadata","unpackGeoFieldMetadata","key","value","crsKey","crsValue","crsId","authority","code","metadataKey","stringifiedMetadata","parse","unpackJSONStringMetadata","json"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/gis/dist/lib/geo/geoparquet-metadata.js"],"sourcesContent":["// GEO METADATA\n/**\n * Reads the GeoMetadata object from the metadata\n * @note geoarrow / parquet schema is stringified into a single key-value pair in the parquet metadata\n */\nexport function getGeoMetadata(schema) {\n    const geoMetadata = parseJSONStringMetadata(schema, 'geo');\n    if (!geoMetadata) {\n        return null;\n    }\n    for (const column of Object.values(geoMetadata.columns || {})) {\n        if (column.encoding) {\n            column.encoding = column.encoding.toLowerCase();\n        }\n    }\n    return geoMetadata;\n}\n/**\n * Stores a geoarrow / geoparquet geo metadata object in the schema\n * @note geoarrow / geoparquet geo metadata is a single stringified JSON field\n */\nexport function setGeoMetadata(schema, geoMetadata) {\n    const stringifiedGeoMetadata = JSON.stringify(geoMetadata);\n    schema.metadata.geo = stringifiedGeoMetadata;\n}\n/**\n * Unpacks geo metadata into separate metadata fields (parses the long JSON string)\n * @note geoarrow / parquet schema is stringified into a single key-value pair in the parquet metadata\n */\nexport function unpackGeoMetadata(schema) {\n    const geoMetadata = getGeoMetadata(schema);\n    if (!geoMetadata) {\n        return;\n    }\n    // Store Parquet Schema Level Metadata\n    const { version, primary_column, columns } = geoMetadata;\n    if (version) {\n        schema.metadata['geo.version'] = version;\n    }\n    if (primary_column) {\n        schema.metadata['geo.primary_column'] = primary_column;\n    }\n    // store column names as comma separated list\n    schema.metadata['geo.columns'] = Object.keys(columns || {}).join('');\n    for (const [columnName, columnMetadata] of Object.entries(columns || {})) {\n        const field = schema.fields.find((field) => field.name === columnName);\n        if (field) {\n            if (field.name === primary_column) {\n                setFieldMetadata(field, 'geo.primary_field', 'true');\n            }\n            unpackGeoFieldMetadata(field, columnMetadata);\n        }\n    }\n}\n// eslint-disable-next-line complexity\nfunction unpackGeoFieldMetadata(field, columnMetadata) {\n    for (const [key, value] of Object.entries(columnMetadata || {})) {\n        switch (key) {\n            case 'geometry_types':\n                setFieldMetadata(field, `geo.${key}`, value.join(','));\n                break;\n            case 'bbox':\n                setFieldMetadata(field, `geo.crs.${key}`, JSON.stringify(value));\n                break;\n            case 'crs':\n                // @ts-ignore\n                for (const [crsKey, crsValue] of Object.entries(value || {})) {\n                    switch (crsKey) {\n                        case 'id':\n                            // prettier-ignore\n                            const crsId = typeof crsValue === 'object'\n                                ? // @ts-ignore\n                                    `${crsValue?.authority}:${crsValue?.code}`\n                                : JSON.stringify(crsValue);\n                            setFieldMetadata(field, `geo.crs.${crsKey}`, crsId);\n                            break;\n                        default:\n                            setFieldMetadata(field, `geo.crs.${crsKey}`, typeof crsValue === 'string' ? crsValue : JSON.stringify(crsValue));\n                            break;\n                    }\n                }\n                break;\n            case 'edges':\n            default:\n                setFieldMetadata(field, `geo.${key}`, typeof value === 'string' ? value : JSON.stringify(value));\n        }\n    }\n}\nfunction setFieldMetadata(field, key, value) {\n    field.metadata = field.metadata || {};\n    field.metadata[key] = value;\n}\n// HELPERS\n/** Parse a key with stringified arrow metadata */\nexport function parseJSONStringMetadata(schema, metadataKey) {\n    const stringifiedMetadata = schema.metadata[metadataKey];\n    if (!stringifiedMetadata) {\n        return null;\n    }\n    try {\n        const metadata = JSON.parse(stringifiedMetadata);\n        if (!metadata || typeof metadata !== 'object') {\n            return null;\n        }\n        return metadata;\n    }\n    catch {\n        return null;\n    }\n}\nexport function unpackJSONStringMetadata(schema, metadataKey) {\n    const json = parseJSONStringMetadata(schema, metadataKey);\n    for (const [key, value] of Object.entries(json || {})) {\n        schema.metadata[`${metadataKey}.${key}`] =\n            typeof value === 'string' ? value : JSON.stringify(value);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}