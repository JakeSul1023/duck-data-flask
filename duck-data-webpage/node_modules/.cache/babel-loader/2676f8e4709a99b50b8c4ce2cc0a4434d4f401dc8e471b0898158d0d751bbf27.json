{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBrowser } from '@probe.gl/env';\nimport { log } from \"../utils/log.js\";\nimport { uid } from \"../utils/uid.js\";\n/**\n * Manages a canvas. Supports both HTML or offscreen canvas\n * - Creates a new canvas or looks up a canvas from the DOM\n * - Provides check for DOM loaded\n * @todo commit(): https://github.com/w3ctag/design-reviews/issues/288\n * @todo transferControlToOffscreen: https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/transferControlToOffscreen\n */\nexport class CanvasContext {\n  static defaultProps = {\n    canvas: null,\n    width: 800,\n    // width are height are only used by headless gl\n    height: 600,\n    useDevicePixels: true,\n    autoResize: true,\n    container: null,\n    visible: true,\n    alphaMode: 'opaque',\n    colorSpace: 'srgb'\n  };\n  id;\n  props;\n  canvas;\n  htmlCanvas;\n  offscreenCanvas;\n  type;\n  width = 1;\n  height = 1;\n  resizeObserver;\n  /** State used by luma.gl classes: TODO - move to canvasContext*/\n  _canvasSizeInfo = {\n    clientWidth: 0,\n    clientHeight: 0,\n    devicePixelRatio: 1\n  };\n  toString() {\n    return `${this[Symbol.toStringTag]}(${this.id})`;\n  }\n  constructor(props) {\n    this.props = {\n      ...CanvasContext.defaultProps,\n      ...props\n    };\n    props = this.props;\n    if (!isBrowser()) {\n      this.id = 'node-canvas-context';\n      this.type = 'node';\n      this.width = this.props.width;\n      this.height = this.props.height;\n      // TODO - does this prevent app from using jsdom style polyfills?\n      this.canvas = null;\n      return;\n    }\n    if (!props.canvas) {\n      const canvas = createCanvas(props);\n      const container = getContainer(props?.container || null);\n      container.insertBefore(canvas, container.firstChild);\n      this.canvas = canvas;\n      if (!props?.visible) {\n        this.canvas.style.visibility = 'hidden';\n      }\n    } else if (typeof props.canvas === 'string') {\n      this.canvas = getCanvasFromDOM(props.canvas);\n    } else {\n      this.canvas = props.canvas;\n    }\n    if (this.canvas instanceof HTMLCanvasElement) {\n      this.id = this.canvas.id;\n      this.type = 'html-canvas';\n      this.htmlCanvas = this.canvas;\n    } else {\n      this.id = 'offscreen-canvas';\n      this.type = 'offscreen-canvas';\n      this.offscreenCanvas = this.canvas;\n    }\n    // React to size changes\n    if (this.canvas instanceof HTMLCanvasElement && props.autoResize) {\n      this.resizeObserver = new ResizeObserver(entries => {\n        for (const entry of entries) {\n          if (entry.target === this.canvas) {\n            this.update();\n          }\n        }\n      });\n      this.resizeObserver.observe(this.canvas);\n    }\n  }\n  /**\n   * Returns the current DPR, if props.useDevicePixels is true\n   * Device refers to physical\n   */\n  getDevicePixelRatio(useDevicePixels) {\n    if (typeof OffscreenCanvas !== 'undefined' && this.canvas instanceof OffscreenCanvas) {\n      return 1;\n    }\n    useDevicePixels = useDevicePixels === undefined ? this.props.useDevicePixels : useDevicePixels;\n    if (!useDevicePixels || useDevicePixels <= 0) {\n      return 1;\n    }\n    // The param was mainly provide to support the test cases, could be removed\n    if (useDevicePixels === true) {\n      const dpr = typeof window !== 'undefined' && window.devicePixelRatio;\n      return dpr || 1;\n    }\n    return useDevicePixels;\n  }\n  /**\n   * Returns the size of drawing buffer in device pixels.\n   * @note This can be different from the 'CSS' size of a canvas, and also from the\n   * canvas' internal drawing buffer size (.width, .height).\n   * This is the size required to cover the canvas, adjusted for DPR\n   */\n  getPixelSize() {\n    switch (this.type) {\n      case 'node':\n        return [this.width, this.height];\n      case 'offscreen-canvas':\n        return [this.canvas.width, this.canvas.height];\n      case 'html-canvas':\n        const dpr = this.getDevicePixelRatio();\n        const canvas = this.canvas;\n        // If not attached to DOM client size can be 0\n        return canvas.parentElement ? [canvas.clientWidth * dpr, canvas.clientHeight * dpr] : [this.canvas.width, this.canvas.height];\n      default:\n        throw new Error(this.type);\n    }\n  }\n  getAspect() {\n    const [width, height] = this.getPixelSize();\n    return width / height;\n  }\n  /**\n   * Returns multiplier need to convert CSS size to Device size\n   */\n  cssToDeviceRatio() {\n    try {\n      // For headless gl we might have used custom width and height\n      // hence use cached clientWidth\n      const [drawingBufferWidth] = this.getDrawingBufferSize();\n      // _canvasSizeInfo may not be populated if `setDevicePixelRatio` is never called\n      const clientWidth = this._canvasSizeInfo.clientWidth || this.htmlCanvas?.clientWidth;\n      return clientWidth ? drawingBufferWidth / clientWidth : 1;\n    } catch {\n      return 1;\n    }\n  }\n  /**\n   * Maps CSS pixel position to device pixel position\n   */\n  cssToDevicePixels(cssPixel, yInvert = true) {\n    const ratio = this.cssToDeviceRatio();\n    const [width, height] = this.getDrawingBufferSize();\n    return scalePixels(cssPixel, ratio, width, height, yInvert);\n  }\n  /**\n   * Use devicePixelRatio to set canvas width and height\n   * @note this is a raw port of luma.gl v8 code. Might be worth a review\n   */\n  setDevicePixelRatio(devicePixelRatio, options = {}) {\n    if (!this.htmlCanvas) {\n      return;\n    }\n    // NOTE: if options.width and options.height not used remove in v8\n    let clientWidth = 'width' in options ? options.width : this.htmlCanvas.clientWidth;\n    let clientHeight = 'height' in options ? options.height : this.htmlCanvas.clientHeight;\n    if (!clientWidth || !clientHeight) {\n      log.log(1, 'Canvas clientWidth/clientHeight is 0')();\n      // by forcing devicePixel ratio to 1, we do not scale canvas.width and height in each frame.\n      devicePixelRatio = 1;\n      clientWidth = this.htmlCanvas.width || 1;\n      clientHeight = this.htmlCanvas.height || 1;\n    }\n    const cachedSize = this._canvasSizeInfo;\n    // Check if canvas needs to be resized\n    if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {\n      let clampedPixelRatio = devicePixelRatio;\n      const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);\n      const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);\n      this.htmlCanvas.width = canvasWidth;\n      this.htmlCanvas.height = canvasHeight;\n      // @ts-expect-error This only works for WebGL\n      const gl = this.device.gl;\n      if (gl) {\n        // Note: when devicePixelRatio is too high, it is possible we might hit system limit for\n        // drawing buffer width and hight, in those cases they get clamped and resulting aspect ration may not be maintained\n        // for those cases, reduce devicePixelRatio.\n        const [drawingBufferWidth, drawingBufferHeight] = this.getDrawingBufferSize();\n        if (drawingBufferWidth !== canvasWidth || drawingBufferHeight !== canvasHeight) {\n          clampedPixelRatio = Math.min(drawingBufferWidth / clientWidth, drawingBufferHeight / clientHeight);\n          this.htmlCanvas.width = Math.floor(clientWidth * clampedPixelRatio);\n          this.htmlCanvas.height = Math.floor(clientHeight * clampedPixelRatio);\n          log.warn('Device pixel ratio clamped')();\n        }\n        this._canvasSizeInfo.clientWidth = clientWidth;\n        this._canvasSizeInfo.clientHeight = clientHeight;\n        this._canvasSizeInfo.devicePixelRatio = devicePixelRatio;\n      }\n    }\n  }\n  // PRIVATE\n  /** @todo Major hack done to port the CSS methods above, base canvas context should not depend on WebGL */\n  getDrawingBufferSize() {\n    // @ts-expect-error This only works for WebGL\n    const gl = this.device.gl;\n    if (!gl) {\n      // use default device pixel ratio\n      return this.getPixelSize();\n    }\n    return [gl.drawingBufferWidth, gl.drawingBufferHeight];\n  }\n  /**\n   * Allows subclass constructor to override the canvas id for auto created canvases.\n   * This can really help when debugging DOM in apps that create multiple devices\n   */\n  _setAutoCreatedCanvasId(id) {\n    if (this.htmlCanvas?.id === 'lumagl-auto-created-canvas') {\n      this.htmlCanvas.id = id;\n    }\n  }\n}\n// HELPER FUNCTIONS\nfunction getContainer(container) {\n  if (typeof container === 'string') {\n    const element = document.getElementById(container);\n    if (!element) {\n      throw new Error(`${container} is not an HTML element`);\n    }\n    return element;\n  } else if (container) {\n    return container;\n  }\n  return document.body;\n}\n/** Get a Canvas element from DOM id */\nfunction getCanvasFromDOM(canvasId) {\n  const canvas = document.getElementById(canvasId);\n  if (!(canvas instanceof HTMLCanvasElement)) {\n    throw new Error('Object is not a canvas element');\n  }\n  return canvas;\n}\n/** Create a new canvas */\nfunction createCanvas(props) {\n  const {\n    width,\n    height\n  } = props;\n  const targetCanvas = document.createElement('canvas');\n  targetCanvas.id = uid('lumagl-auto-created-canvas');\n  targetCanvas.width = width || 1;\n  targetCanvas.height = height || 1;\n  targetCanvas.style.width = Number.isFinite(width) ? `${width}px` : '100%';\n  targetCanvas.style.height = Number.isFinite(height) ? `${height}px` : '100%';\n  return targetCanvas;\n}\n/**\n *\n * @param pixel\n * @param ratio\n * @param width\n * @param height\n * @param yInvert\n * @returns\n */\nfunction scalePixels(pixel, ratio, width, height, yInvert) {\n  const point = pixel;\n  const x = scaleX(point[0], ratio, width);\n  let y = scaleY(point[1], ratio, height, yInvert);\n  // Find boundaries of next pixel to provide valid range of device pixel locations\n  let t = scaleX(point[0] + 1, ratio, width);\n  // If next pixel's position is clamped to boundary, use it as is, otherwise subtract 1 for current pixel boundary\n  const xHigh = t === width - 1 ? t : t - 1;\n  t = scaleY(point[1] + 1, ratio, height, yInvert);\n  let yHigh;\n  if (yInvert) {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    t = t === 0 ? t : t + 1;\n    // swap y and yHigh\n    yHigh = y;\n    y = t;\n  } else {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    yHigh = t === height - 1 ? t : t - 1;\n    // y remains same\n  }\n  return {\n    x,\n    y,\n    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.\n    width: Math.max(xHigh - x + 1, 1),\n    height: Math.max(yHigh - y + 1, 1)\n  };\n}\nfunction scaleX(x, ratio, width) {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  const r = Math.min(Math.round(x * ratio), width - 1);\n  return r;\n}\nfunction scaleY(y, ratio, height, yInvert) {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);\n}\n//# sourceMappingURL=canvas-context.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}