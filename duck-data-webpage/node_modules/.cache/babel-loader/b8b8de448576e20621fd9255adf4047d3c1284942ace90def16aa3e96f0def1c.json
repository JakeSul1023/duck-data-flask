{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = /* glsl */`\\\nuniform dataFilterUniforms {\n  bool useSoftMargin;\n  bool enabled;\n  bool transformSize;\n  bool transformColor;\n#ifdef DATAFILTER_TYPE\n  DATAFILTER_TYPE min;\n  DATAFILTER_TYPE softMin;\n  DATAFILTER_TYPE softMax;\n  DATAFILTER_TYPE max;\n#ifdef DATAFILTER_DOUBLE\n  DATAFILTER_TYPE min64High;\n  DATAFILTER_TYPE max64High;\n#endif\n#endif\n#ifdef DATACATEGORY_TYPE\n  highp uvec4 categoryBitMask;\n#endif\n} dataFilter;\n`;\nconst vertex = /* glsl */`\n#ifdef DATAFILTER_TYPE\n  in DATAFILTER_TYPE filterValues;\n#ifdef DATAFILTER_DOUBLE\n  in DATAFILTER_TYPE filterValues64Low;\n#endif\n#endif\n\n#ifdef DATACATEGORY_TYPE\n  in DATACATEGORY_TYPE filterCategoryValues;\n#endif\n\nout float dataFilter_value;\n\nfloat dataFilter_reduceValue(float value) {\n  return value;\n}\nfloat dataFilter_reduceValue(vec2 value) {\n  return min(value.x, value.y);\n}\nfloat dataFilter_reduceValue(vec3 value) {\n  return min(min(value.x, value.y), value.z);\n}\nfloat dataFilter_reduceValue(vec4 value) {\n  return min(min(value.x, value.y), min(value.z, value.w));\n}\n\n#ifdef DATAFILTER_TYPE\n  void dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax) {\n    if (dataFilter.useSoftMargin) {\n      // smoothstep results are undefined if edge0 â‰¥ edge1\n      // Fallback to ignore filterSoftRange if it is truncated by filterRange\n      DATAFILTER_TYPE leftInRange = mix(\n        smoothstep(dataFilter.min, dataFilter.softMin, valueFromMin),\n        step(dataFilter.min, valueFromMin),\n        step(dataFilter.softMin, dataFilter.min)\n      );\n      DATAFILTER_TYPE rightInRange = mix(\n        1.0 - smoothstep(dataFilter.softMax, dataFilter.max, valueFromMax),\n        step(valueFromMax, dataFilter.max),\n        step(dataFilter.max, dataFilter.softMax)\n      );\n      dataFilter_value = dataFilter_reduceValue(leftInRange * rightInRange);\n    } else {\n      dataFilter_value = dataFilter_reduceValue(\n        step(dataFilter.min, valueFromMin) * step(valueFromMax, dataFilter.max)\n      );\n    }\n  }\n#endif\n\n#ifdef DATACATEGORY_TYPE\n  void dataFilter_setCategoryValue(DATACATEGORY_TYPE category) {\n    #if DATACATEGORY_CHANNELS == 1 // One 128-bit mask\n    uint dataFilter_masks = dataFilter.categoryBitMask[category / 32u];\n    #elif DATACATEGORY_CHANNELS == 2 // Two 64-bit masks\n    uvec2 dataFilter_masks = uvec2(\n      dataFilter.categoryBitMask[category.x / 32u],\n      dataFilter.categoryBitMask[category.y / 32u + 2u]\n    );\n    #elif DATACATEGORY_CHANNELS == 3 // Three 32-bit masks\n    uvec3 dataFilter_masks = dataFilter.categoryBitMask.xyz;\n    #else // Four 32-bit masks\n    uvec4 dataFilter_masks = dataFilter.categoryBitMask;\n    #endif\n\n    // Shift mask and extract relevant bits\n    DATACATEGORY_TYPE dataFilter_bits = DATACATEGORY_TYPE(dataFilter_masks) >> (category & 31u);\n    dataFilter_bits &= 1u;\n\n    #if DATACATEGORY_CHANNELS == 1\n    if(dataFilter_bits == 0u) dataFilter_value = 0.0;\n    #else\n    if(any(equal(dataFilter_bits, DATACATEGORY_TYPE(0u)))) dataFilter_value = 0.0;\n    #endif\n  }\n#endif\n`;\nconst vs = `\n${uniformBlock}\n${vertex}\n`;\nconst fragment = /* glsl */`\nin float dataFilter_value;\n`;\nconst fs = `\n${uniformBlock}\n${fragment}\n`;\n/* eslint-disable camelcase */\nfunction getUniforms(opts) {\n  if (!opts || !('extensions' in opts)) {\n    return {};\n  }\n  const {\n    filterRange = [-1, 1],\n    filterEnabled = true,\n    filterTransformSize = true,\n    filterTransformColor = true,\n    categoryBitMask\n  } = opts;\n  const filterSoftRange = opts.filterSoftRange || filterRange;\n  return {\n    ...(Number.isFinite(filterRange[0]) ? {\n      min: filterRange[0],\n      softMin: filterSoftRange[0],\n      softMax: filterSoftRange[1],\n      max: filterRange[1]\n    } : {\n      min: filterRange.map(r => r[0]),\n      softMin: filterSoftRange.map(r => r[0]),\n      softMax: filterSoftRange.map(r => r[1]),\n      max: filterRange.map(r => r[1])\n    }),\n    enabled: filterEnabled,\n    useSoftMargin: Boolean(opts.filterSoftRange),\n    transformSize: filterEnabled && filterTransformSize,\n    transformColor: filterEnabled && filterTransformColor,\n    ...(categoryBitMask && {\n      categoryBitMask\n    })\n  };\n}\nfunction getUniforms64(opts) {\n  if (!opts || !('extensions' in opts)) {\n    return {};\n  }\n  const uniforms = getUniforms(opts);\n  if (Number.isFinite(uniforms.min)) {\n    const min64High = Math.fround(uniforms.min);\n    uniforms.min -= min64High;\n    uniforms.softMin -= min64High;\n    uniforms.min64High = min64High;\n    const max64High = Math.fround(uniforms.max);\n    uniforms.max -= max64High;\n    uniforms.softMax -= max64High;\n    uniforms.max64High = max64High;\n  } else {\n    const min64High = uniforms.min.map(Math.fround);\n    uniforms.min = uniforms.min.map((x, i) => x - min64High[i]);\n    uniforms.softMin = uniforms.softMin.map((x, i) => x - min64High[i]);\n    uniforms.min64High = min64High;\n    const max64High = uniforms.max.map(Math.fround);\n    uniforms.max = uniforms.max.map((x, i) => x - max64High[i]);\n    uniforms.softMax = uniforms.softMax.map((x, i) => x - max64High[i]);\n    uniforms.max64High = max64High;\n  }\n  return uniforms;\n}\nconst inject = {\n  'vs:#main-start': /* glsl */`\n    dataFilter_value = 1.0;\n    if (dataFilter.enabled) {\n      #ifdef DATAFILTER_TYPE\n        #ifdef DATAFILTER_DOUBLE\n          dataFilter_setValue(\n            filterValues - dataFilter.min64High + filterValues64Low,\n            filterValues - dataFilter.max64High + filterValues64Low\n          );\n        #else\n          dataFilter_setValue(filterValues, filterValues);\n        #endif\n      #endif\n\n      #ifdef DATACATEGORY_TYPE\n        dataFilter_setCategoryValue(filterCategoryValues);\n      #endif\n    }\n  `,\n  'vs:#main-end': /* glsl */`\n    if (dataFilter_value == 0.0) {\n      gl_Position = vec4(0.);\n    }\n  `,\n  'vs:DECKGL_FILTER_SIZE': /* glsl */`\n    if (dataFilter.transformSize) {\n      size = size * dataFilter_value;\n    }\n  `,\n  'fs:DECKGL_FILTER_COLOR': /* glsl */`\n    if (dataFilter_value == 0.0) discard;\n    if (dataFilter.transformColor) {\n      color.a *= dataFilter_value;\n    }\n  `\n};\nfunction uniformTypesFromOptions(opts) {\n  const {\n    categorySize,\n    filterSize,\n    fp64\n  } = opts;\n  const uniformTypes = {\n    useSoftMargin: 'i32',\n    enabled: 'i32',\n    transformSize: 'i32',\n    transformColor: 'i32'\n  };\n  if (filterSize) {\n    const uniformFormat = filterSize === 1 ? 'f32' : `vec${filterSize}<f32>`;\n    uniformTypes.min = uniformFormat;\n    uniformTypes.softMin = uniformFormat;\n    uniformTypes.softMax = uniformFormat;\n    uniformTypes.max = uniformFormat;\n    if (fp64) {\n      uniformTypes.min64High = uniformFormat;\n      uniformTypes.max64High = uniformFormat;\n    }\n  }\n  if (categorySize) {\n    uniformTypes.categoryBitMask = 'vec4<i32>';\n  }\n  return uniformTypes;\n}\nexport const dataFilter = {\n  name: 'dataFilter',\n  vs,\n  fs,\n  inject,\n  getUniforms,\n  uniformTypesFromOptions\n};\nexport const dataFilter64 = {\n  name: 'dataFilter',\n  vs,\n  fs,\n  inject,\n  getUniforms: getUniforms64,\n  uniformTypesFromOptions\n};\n//# sourceMappingURL=shader-module.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}