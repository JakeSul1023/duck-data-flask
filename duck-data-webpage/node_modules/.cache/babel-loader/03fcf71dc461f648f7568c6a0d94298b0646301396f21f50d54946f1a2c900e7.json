{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { RenderPipeline, log } from '@luma.gl/core';\n// import {getAttributeInfosFromLayouts} from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\nimport { getShaderLayoutFromGLSL } from \"../helpers/get-shader-layout.js\";\nimport { withDeviceAndGLParameters } from \"../converters/device-parameters.js\";\nimport { setUniform } from \"../helpers/set-uniform.js\";\nimport { splitUniformsAndBindings } from \"../../utils/split-uniforms-and-bindings.js\";\nimport { WEBGLBuffer } from \"./webgl-buffer.js\";\nimport { WEBGLFramebuffer } from \"./webgl-framebuffer.js\";\nimport { WEBGLTexture } from \"./webgl-texture.js\";\nimport { WEBGLTextureView } from \"./webgl-texture-view.js\";\nimport { getGLDrawMode } from \"../helpers/webgl-topology-utils.js\";\nconst LOG_PROGRAM_PERF_PRIORITY = 4;\n/** Creates a new render pipeline */\nexport class WEBGLRenderPipeline extends RenderPipeline {\n  /** The WebGL device that created this render pipeline */\n  device;\n  /** Handle to underlying WebGL program */\n  handle;\n  /** vertex shader */\n  vs;\n  /** fragment shader */\n  fs;\n  /** The layout extracted from shader by WebGL introspection APIs */\n  introspectedLayout;\n  /** Uniforms set on this model */\n  uniforms = {};\n  /** Bindings set on this model */\n  bindings = {};\n  /** WebGL varyings */\n  varyings = null;\n  _uniformCount = 0;\n  _uniformSetters = {}; // TODO are these used?\n  constructor(device, props) {\n    super(device, props);\n    this.device = device;\n    this.handle = this.props.handle || this.device.gl.createProgram();\n    this.device.setSpectorMetadata(this.handle, {\n      id: this.props.id\n    });\n    // Create shaders if needed\n    this.vs = props.vs;\n    this.fs = props.fs;\n    // assert(this.vs.stage === 'vertex');\n    // assert(this.fs.stage === 'fragment');\n    // Setup varyings if supplied\n    // @ts-expect-error WebGL only\n    const {\n      varyings,\n      bufferMode = 35981\n    } = props;\n    if (varyings && varyings.length > 0) {\n      this.varyings = varyings;\n      this.device.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);\n    }\n    this._linkShaders();\n    log.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)();\n    this.introspectedLayout = getShaderLayoutFromGLSL(this.device.gl, this.handle);\n    log.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)();\n    // Merge provided layout with introspected layout\n    this.shaderLayout = mergeShaderLayout(this.introspectedLayout, props.shaderLayout);\n  }\n  destroy() {\n    if (this.handle) {\n      this.device.gl.deleteProgram(this.handle);\n      // this.handle = null;\n      this.destroyed = true;\n    }\n  }\n  /**\n   * Bindings include: textures, samplers and uniform buffers\n   * @todo needed for portable model\n   */\n  setBindings(bindings, options) {\n    // if (log.priority >= 2) {\n    //   checkUniformValues(uniforms, this.id, this._uniformSetters);\n    // }\n    for (const [name, value] of Object.entries(bindings)) {\n      // Accept both `xyz` and `xyzUniforms` as valid names for `xyzUniforms` uniform block\n      // This convention allows shaders to name uniform blocks as `uniform appUniforms {} app;`\n      // and reference them as `app` from both GLSL and JS.\n      // TODO - this is rather hacky - we could also remap the name directly in the shader layout.\n      const binding = this.shaderLayout.bindings.find(binding_ => binding_.name === name) || this.shaderLayout.bindings.find(binding_ => binding_.name === `${name}Uniforms`);\n      if (!binding) {\n        const validBindings = this.shaderLayout.bindings.map(binding_ => `\"${binding_.name}\"`).join(', ');\n        if (!options?.disableWarnings) {\n          log.warn(`No binding \"${name}\" in render pipeline \"${this.id}\", expected one of ${validBindings}`, value)();\n        }\n        continue; // eslint-disable-line no-continue\n      }\n      if (!value) {\n        log.warn(`Unsetting binding \"${name}\" in render pipeline \"${this.id}\"`)();\n      }\n      switch (binding.type) {\n        case 'uniform':\n          // @ts-expect-error\n          if (!(value instanceof WEBGLBuffer) && !(value.buffer instanceof WEBGLBuffer)) {\n            throw new Error('buffer value');\n          }\n          break;\n        case 'texture':\n          if (!(value instanceof WEBGLTextureView || value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {\n            throw new Error('texture value');\n          }\n          break;\n        case 'sampler':\n          log.warn(`Ignoring sampler ${name}`)();\n          break;\n        default:\n          throw new Error(binding.type);\n      }\n      this.bindings[name] = value;\n    }\n  }\n  /** @todo needed for portable model\n   * @note The WebGL API is offers many ways to draw things\n   * This function unifies those ways into a single call using common parameters with sane defaults\n   */\n  draw(options) {\n    const {\n      renderPass,\n      parameters = this.props.parameters,\n      topology = this.props.topology,\n      vertexArray,\n      vertexCount,\n      // indexCount,\n      instanceCount,\n      isInstanced = false,\n      firstVertex = 0,\n      // firstIndex,\n      // firstInstance,\n      // baseVertex,\n      transformFeedback\n    } = options;\n    const glDrawMode = getGLDrawMode(topology);\n    const isIndexed = Boolean(vertexArray.indexBuffer);\n    const glIndexType = vertexArray.indexBuffer?.glIndexType;\n    // Note that we sometimes get called with 0 instances\n    // If we are using async linking, we need to wait until linking completes\n    if (this.linkStatus !== 'success') {\n      log.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)();\n      return false;\n    }\n    // Avoid WebGL draw call when not rendering any data or values are incomplete\n    // Note: async textures set as uniforms might still be loading.\n    // Now that all uniforms have been updated, check if any texture\n    // in the uniforms is not yet initialized, then we don't draw\n    if (!this._areTexturesRenderable()) {\n      log.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)();\n      //  Note: false means that the app needs to redraw the pipeline again.\n      return false;\n    }\n    // (isInstanced && instanceCount === 0)\n    // if (vertexCount === 0) {\n    //   log.info(2, `RenderPipeline:${this.id}.draw() aborted - no vertices to draw`)();\n    //   Note: false means that the app needs to redraw the pipeline again.\n    //   return true;\n    // }\n    this.device.gl.useProgram(this.handle);\n    // Note: Rebinds constant attributes before each draw call\n    vertexArray.bindBeforeRender(renderPass);\n    if (transformFeedback) {\n      transformFeedback.begin(this.props.topology);\n    }\n    // We have to apply bindings before every draw call since other draw calls will overwrite\n    this._applyBindings();\n    this._applyUniforms();\n    const webglRenderPass = renderPass;\n    withDeviceAndGLParameters(this.device, parameters, webglRenderPass.glParameters, () => {\n      if (isIndexed && isInstanced) {\n        this.device.gl.drawElementsInstanced(glDrawMode, vertexCount || 0,\n        // indexCount?\n        glIndexType, firstVertex, instanceCount || 0);\n        // } else if (isIndexed && this.device.isWebGL2 && !isNaN(start) && !isNaN(end)) {\n        //   this.device.gldrawRangeElements(glDrawMode, start, end, vertexCount, glIndexType, offset);\n      } else if (isIndexed) {\n        this.device.gl.drawElements(glDrawMode, vertexCount || 0, glIndexType, firstVertex); // indexCount?\n      } else if (isInstanced) {\n        this.device.gl.drawArraysInstanced(glDrawMode, firstVertex, vertexCount || 0, instanceCount || 0);\n      } else {\n        this.device.gl.drawArrays(glDrawMode, firstVertex, vertexCount || 0);\n      }\n      if (transformFeedback) {\n        transformFeedback.end();\n      }\n    });\n    vertexArray.unbindAfterRender(renderPass);\n    return true;\n  }\n  // DEPRECATED METHODS\n  setUniformsWebGL(uniforms) {\n    const {\n      bindings\n    } = splitUniformsAndBindings(uniforms);\n    Object.keys(bindings).forEach(name => {\n      log.warn(`Unsupported value \"${JSON.stringify(bindings[name])}\" used in setUniforms() for key ${name}. Use setBindings() instead?`)();\n    });\n    // TODO - check against layout\n    Object.assign(this.uniforms, uniforms);\n  }\n  // PRIVATE METHODS\n  // setAttributes(attributes: Record<string, Buffer>): void {}\n  // setBindings(bindings: Record<string, Binding>): void {}\n  async _linkShaders() {\n    const {\n      gl\n    } = this.device;\n    gl.attachShader(this.handle, this.vs.handle);\n    gl.attachShader(this.handle, this.fs.handle);\n    log.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();\n    gl.linkProgram(this.handle);\n    log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();\n    // TODO Avoid checking program linking error in production\n    if (log.level === 0) {\n      // return;\n    }\n    if (!this.device.features.has('compilation-status-async-webgl')) {\n      const status = this._getLinkStatus();\n      this._reportLinkStatus(status);\n      return;\n    }\n    // async case\n    log.once(1, 'RenderPipeline linking is asynchronous')();\n    await this._waitForLinkComplete();\n    log.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();\n    const status = this._getLinkStatus();\n    this._reportLinkStatus(status);\n  }\n  /** Report link status. First, check for shader compilation failures if linking fails */\n  async _reportLinkStatus(status) {\n    switch (status) {\n      case 'success':\n        return;\n      default:\n        // First check for shader compilation failures if linking fails\n        switch (this.vs.compilationStatus) {\n          case 'error':\n            this.vs.debugShader();\n            throw new Error(`Error during compilation of shader ${this.vs.id}`);\n          case 'pending':\n            this.vs.asyncCompilationStatus.then(() => this.vs.debugShader());\n            break;\n          case 'success':\n            break;\n        }\n        switch (this.fs?.compilationStatus) {\n          case 'error':\n            this.fs.debugShader();\n            throw new Error(`Error during compilation of shader ${this.fs.id}`);\n          case 'pending':\n            this.fs.asyncCompilationStatus.then(() => this.fs.debugShader());\n            break;\n          case 'success':\n            break;\n        }\n        const linkErrorLog = this.device.gl.getProgramInfoLog(this.handle);\n        throw new Error(`Error during ${status}: ${linkErrorLog}`);\n    }\n  }\n  /**\n   * Get the shader compilation status\n   * TODO - Load log even when no error reported, to catch warnings?\n   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings\n   */\n  _getLinkStatus() {\n    const {\n      gl\n    } = this.device;\n    const linked = gl.getProgramParameter(this.handle, 35714);\n    if (!linked) {\n      this.linkStatus = 'error';\n      return 'linking';\n    }\n    gl.validateProgram(this.handle);\n    const validated = gl.getProgramParameter(this.handle, 35715);\n    if (!validated) {\n      this.linkStatus = 'error';\n      return 'validation';\n    }\n    this.linkStatus = 'success';\n    return 'success';\n  }\n  /** Use KHR_parallel_shader_compile extension if available */\n  async _waitForLinkComplete() {\n    const waitMs = async ms => await new Promise(resolve => setTimeout(resolve, ms));\n    const DELAY_MS = 10; // Shader compilation is typically quite fast (with some exceptions)\n    // If status polling is not available, we can't wait for completion. Just wait a little to minimize blocking\n    if (!this.device.features.has('compilation-status-async-webgl')) {\n      await waitMs(DELAY_MS);\n      return;\n    }\n    const {\n      gl\n    } = this.device;\n    for (;;) {\n      const complete = gl.getProgramParameter(this.handle, 37297);\n      if (complete) {\n        return;\n      }\n      await waitMs(DELAY_MS);\n    }\n  }\n  /**\n   * Checks if all texture-values uniforms are renderable (i.e. loaded)\n   * Update a texture if needed (e.g. from video)\n   * Note: This is currently done before every draw call\n   */\n  _areTexturesRenderable() {\n    let texturesRenderable = true;\n    for (const bindingInfo of this.shaderLayout.bindings) {\n      if (!this.bindings[bindingInfo.name] && !this.bindings[bindingInfo.name.replace(/Uniforms$/, '')]) {\n        log.warn(`Binding ${bindingInfo.name} not found in ${this.id}`)();\n        texturesRenderable = false;\n      }\n    }\n    // TODO - remove this should be handled by ExternalTexture\n    // for (const [, texture] of Object.entries(this.bindings)) {\n    //   if (texture instanceof WEBGLTexture) {\n    //     texture.update();\n    //   }\n    // }\n    return texturesRenderable;\n  }\n  /** Apply any bindings (before each draw call) */\n  _applyBindings() {\n    // If we are using async linking, we need to wait until linking completes\n    if (this.linkStatus !== 'success') {\n      return;\n    }\n    const {\n      gl\n    } = this.device;\n    gl.useProgram(this.handle);\n    let textureUnit = 0;\n    let uniformBufferIndex = 0;\n    for (const binding of this.shaderLayout.bindings) {\n      // Accept both `xyz` and `xyzUniforms` as valid names for `xyzUniforms` uniform block\n      const value = this.bindings[binding.name] || this.bindings[binding.name.replace(/Uniforms$/, '')];\n      if (!value) {\n        throw new Error(`No value for binding ${binding.name} in ${this.id}`);\n      }\n      switch (binding.type) {\n        case 'uniform':\n          // Set buffer\n          const {\n            name\n          } = binding;\n          const location = gl.getUniformBlockIndex(this.handle, name);\n          if (location === 4294967295) {\n            throw new Error(`Invalid uniform block name ${name}`);\n          }\n          gl.uniformBlockBinding(this.handle, uniformBufferIndex, location);\n          // console.debug(binding, location);\n          if (value instanceof WEBGLBuffer) {\n            gl.bindBufferBase(35345, uniformBufferIndex, value.handle);\n          } else {\n            gl.bindBufferRange(35345, uniformBufferIndex,\n            // @ts-expect-error\n            value.buffer.handle,\n            // @ts-expect-error\n            value.offset || 0,\n            // @ts-expect-error\n            value.size || value.buffer.byteLength - value.offset);\n          }\n          uniformBufferIndex += 1;\n          break;\n        case 'texture':\n          if (!(value instanceof WEBGLTextureView || value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {\n            throw new Error('texture');\n          }\n          let texture;\n          if (value instanceof WEBGLTextureView) {\n            texture = value.texture;\n          } else if (value instanceof WEBGLTexture) {\n            texture = value;\n          } else if (value instanceof WEBGLFramebuffer && value.colorAttachments[0] instanceof WEBGLTextureView) {\n            log.warn('Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead')();\n            texture = value.colorAttachments[0].texture;\n          } else {\n            throw new Error('No texture');\n          }\n          gl.activeTexture(33984 + textureUnit);\n          gl.bindTexture(texture.glTarget, texture.handle);\n          // gl.bindSampler(textureUnit, sampler.handle);\n          textureUnit += 1;\n          break;\n        case 'sampler':\n          // ignore\n          break;\n        case 'storage':\n        case 'read-only-storage':\n          throw new Error(`binding type '${binding.type}' not supported in WebGL`);\n      }\n    }\n  }\n  /**\n   * Due to program sharing, uniforms need to be reset before every draw call\n   * (though caching will avoid redundant WebGL calls)\n   */\n  _applyUniforms() {\n    for (const uniformLayout of this.shaderLayout.uniforms || []) {\n      const {\n        name,\n        location,\n        type,\n        textureUnit\n      } = uniformLayout;\n      const value = this.uniforms[name] ?? textureUnit;\n      if (value !== undefined) {\n        setUniform(this.device.gl, location, type, value);\n      }\n    }\n  }\n}\n/**\n * Merges an provided shader layout into a base shader layout\n * In WebGL, this allows the auto generated shader layout to be overridden by the application\n * Typically to change the format of the vertex attributes (from float32x4 to uint8x4 etc).\n * @todo Drop this? Aren't all use cases covered by mergeBufferLayout()?\n */\nfunction mergeShaderLayout(baseLayout, overrideLayout) {\n  // Deep clone the base layout\n  const mergedLayout = {\n    ...baseLayout,\n    attributes: baseLayout.attributes.map(attribute => ({\n      ...attribute\n    }))\n  };\n  // Merge the attributes\n  for (const attribute of overrideLayout?.attributes || []) {\n    const baseAttribute = mergedLayout.attributes.find(attr => attr.name === attribute.name);\n    if (!baseAttribute) {\n      log.warn(`shader layout attribute ${attribute.name} not present in shader`);\n    } else {\n      baseAttribute.type = attribute.type || baseAttribute.type;\n      baseAttribute.stepMode = attribute.stepMode || baseAttribute.stepMode;\n    }\n  }\n  return mergedLayout;\n}\n//# sourceMappingURL=webgl-render-pipeline.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}