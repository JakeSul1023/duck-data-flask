{"ast":null,"code":"// TextDecoder iterators\n// TextDecoder will keep any partial undecoded bytes between calls to `decode`\nexport function makeTextDecoderIterator(arrayBufferIterator) {\n  try {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return async function* () {\n      const textDecoder = new TextDecoder(undefined, options);\n      for await (const arrayBuffer of arrayBufferIterator) {\n        yield typeof arrayBuffer === 'string' ? arrayBuffer : textDecoder.decode(arrayBuffer, {\n          stream: true\n        });\n      }\n    }();\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n// TextEncoder iterator\n// TODO - this is not useful unless min chunk size is given\n// TextEncoder will keep any partial undecoded bytes between calls to `encode`\n// If iterator does not yield strings, assume arrayBuffer and return unencoded\nexport async function* makeTextEncoderIterator(textIterator) {\n  const textEncoder = new TextEncoder();\n  for await (const text of textIterator) {\n    yield typeof text === 'string' ? textEncoder.encode(text) : text;\n  }\n}\n/**\n * @param textIterator async iterable yielding strings\n * @returns an async iterable over lines\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\nexport async function* makeLineIterator(textIterator) {\n  let previous = '';\n  for await (const textChunk of textIterator) {\n    previous += textChunk;\n    let eolIndex;\n    while ((eolIndex = previous.indexOf('\\n')) >= 0) {\n      // line includes the EOL\n      const line = previous.slice(0, eolIndex + 1);\n      previous = previous.slice(eolIndex + 1);\n      yield line;\n    }\n  }\n  if (previous.length > 0) {\n    yield previous;\n  }\n}\n/**\n * @param lineIterator async iterable yielding lines\n * @returns async iterable yielding numbered lines\n *\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\nexport async function* makeNumberedLineIterator(lineIterator) {\n  let counter = 1;\n  for await (const line of lineIterator) {\n    yield {\n      counter,\n      line\n    };\n    counter++;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}