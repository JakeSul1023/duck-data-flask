{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { CompositeLayer, log } from '@deck.gl/core';\nimport { SimpleMeshLayer } from '@deck.gl/mesh-layers';\nimport { COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { TerrainWorkerLoader } from '@loaders.gl/terrain';\nimport TileLayer from \"../tile-layer/tile-layer.js\";\nimport { urlType, getURLFromTemplate } from \"../tileset-2d/index.js\";\nconst DUMMY_DATA = [1];\nconst defaultProps = {\n  ...TileLayer.defaultProps,\n  // Image url that encodes height data\n  elevationData: urlType,\n  // Image url to use as texture\n  texture: {\n    ...urlType,\n    optional: true\n  },\n  // Martini error tolerance in meters, smaller number -> more detailed mesh\n  meshMaxError: {\n    type: 'number',\n    value: 4.0\n  },\n  // Bounding box of the terrain image, [minX, minY, maxX, maxY] in world coordinates\n  bounds: {\n    type: 'array',\n    value: null,\n    optional: true,\n    compare: true\n  },\n  // Color to use if texture is unavailable\n  color: {\n    type: 'color',\n    value: [255, 255, 255]\n  },\n  // Object to decode height data, from (r, g, b) to height in meters\n  elevationDecoder: {\n    type: 'object',\n    value: {\n      rScaler: 1,\n      gScaler: 0,\n      bScaler: 0,\n      offset: 0\n    }\n  },\n  // Supply url to local terrain worker bundle. Only required if running offline and cannot access CDN.\n  workerUrl: '',\n  // Same as SimpleMeshLayer wireframe\n  wireframe: false,\n  material: true,\n  loaders: [TerrainWorkerLoader]\n};\n// Turns array of templates into a single string to work around shallow change\nfunction urlTemplateToUpdateTrigger(template) {\n  if (Array.isArray(template)) {\n    return template.join(';');\n  }\n  return template || '';\n}\n/** Render mesh surfaces from height map images. */\nclass TerrainLayer extends CompositeLayer {\n  updateState(_ref) {\n    let {\n      props,\n      oldProps\n    } = _ref;\n    const elevationDataChanged = props.elevationData !== oldProps.elevationData;\n    if (elevationDataChanged) {\n      const {\n        elevationData\n      } = props;\n      const isTiled = elevationData && (Array.isArray(elevationData) || elevationData.includes('{x}') && elevationData.includes('{y}'));\n      this.setState({\n        isTiled\n      });\n    }\n    // Reloading for single terrain mesh\n    const shouldReload = elevationDataChanged || props.meshMaxError !== oldProps.meshMaxError || props.elevationDecoder !== oldProps.elevationDecoder || props.bounds !== oldProps.bounds;\n    if (!this.state.isTiled && shouldReload) {\n      // When state.isTiled, elevationData cannot be an array\n      const terrain = this.loadTerrain(props);\n      this.setState({\n        terrain\n      });\n    }\n    // TODO - remove in v9\n    // @ts-ignore\n    if (props.workerUrl) {\n      log.removed('workerUrl', 'loadOptions.terrain.workerUrl')();\n    }\n  }\n  loadTerrain(_ref2) {\n    let {\n      elevationData,\n      bounds,\n      elevationDecoder,\n      meshMaxError,\n      signal\n    } = _ref2;\n    if (!elevationData) {\n      return null;\n    }\n    let loadOptions = this.getLoadOptions();\n    loadOptions = {\n      ...loadOptions,\n      terrain: {\n        skirtHeight: this.state.isTiled ? meshMaxError * 2 : 0,\n        ...loadOptions?.terrain,\n        bounds,\n        meshMaxError,\n        elevationDecoder\n      }\n    };\n    const {\n      fetch\n    } = this.props;\n    return fetch(elevationData, {\n      propName: 'elevationData',\n      layer: this,\n      loadOptions,\n      signal\n    });\n  }\n  getTiledTerrainData(tile) {\n    const {\n      elevationData,\n      fetch,\n      texture,\n      elevationDecoder,\n      meshMaxError\n    } = this.props;\n    const {\n      viewport\n    } = this.context;\n    const dataUrl = getURLFromTemplate(elevationData, tile);\n    const textureUrl = texture && getURLFromTemplate(texture, tile);\n    const {\n      signal\n    } = tile;\n    let bottomLeft = [0, 0];\n    let topRight = [0, 0];\n    if (viewport.isGeospatial) {\n      const bbox = tile.bbox;\n      bottomLeft = viewport.projectFlat([bbox.west, bbox.south]);\n      topRight = viewport.projectFlat([bbox.east, bbox.north]);\n    } else {\n      const bbox = tile.bbox;\n      bottomLeft = [bbox.left, bbox.bottom];\n      topRight = [bbox.right, bbox.top];\n    }\n    const bounds = [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]];\n    const terrain = this.loadTerrain({\n      elevationData: dataUrl,\n      bounds,\n      elevationDecoder,\n      meshMaxError,\n      signal\n    });\n    const surface = textureUrl ?\n    // If surface image fails to load, the tile should still be displayed\n    fetch(textureUrl, {\n      propName: 'texture',\n      layer: this,\n      loaders: [],\n      signal\n    }).catch(_ => null) : Promise.resolve(null);\n    return Promise.all([terrain, surface]);\n  }\n  renderSubLayers(props) {\n    const SubLayerClass = this.getSubLayerClass('mesh', SimpleMeshLayer);\n    const {\n      color,\n      wireframe,\n      material\n    } = this.props;\n    const {\n      data\n    } = props;\n    if (!data) {\n      return null;\n    }\n    const [mesh, texture] = data;\n    return new SubLayerClass(props, {\n      data: DUMMY_DATA,\n      mesh,\n      texture,\n      _instanced: false,\n      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n      getPosition: d => [0, 0, 0],\n      getColor: color,\n      wireframe,\n      material\n    });\n  }\n  // Update zRange of viewport\n  onViewportLoad(tiles) {\n    if (!tiles) {\n      return;\n    }\n    const {\n      zRange\n    } = this.state;\n    const ranges = tiles.map(tile => tile.content).filter(Boolean).map(arr => {\n      // @ts-ignore\n      const bounds = arr[0].header.boundingBox;\n      return bounds.map(bound => bound[2]);\n    });\n    if (ranges.length === 0) {\n      return;\n    }\n    const minZ = Math.min(...ranges.map(x => x[0]));\n    const maxZ = Math.max(...ranges.map(x => x[1]));\n    if (!zRange || minZ < zRange[0] || maxZ > zRange[1]) {\n      this.setState({\n        zRange: [minZ, maxZ]\n      });\n    }\n  }\n  renderLayers() {\n    const {\n      color,\n      material,\n      elevationData,\n      texture,\n      wireframe,\n      meshMaxError,\n      elevationDecoder,\n      tileSize,\n      maxZoom,\n      minZoom,\n      extent,\n      maxRequests,\n      onTileLoad,\n      onTileUnload,\n      onTileError,\n      maxCacheSize,\n      maxCacheByteSize,\n      refinementStrategy\n    } = this.props;\n    if (this.state.isTiled) {\n      return new TileLayer(this.getSubLayerProps({\n        id: 'tiles'\n      }), {\n        getTileData: this.getTiledTerrainData.bind(this),\n        renderSubLayers: this.renderSubLayers.bind(this),\n        updateTriggers: {\n          getTileData: {\n            elevationData: urlTemplateToUpdateTrigger(elevationData),\n            texture: urlTemplateToUpdateTrigger(texture),\n            meshMaxError,\n            elevationDecoder\n          }\n        },\n        onViewportLoad: this.onViewportLoad.bind(this),\n        zRange: this.state.zRange || null,\n        tileSize,\n        maxZoom,\n        minZoom,\n        extent,\n        maxRequests,\n        onTileLoad,\n        onTileUnload,\n        onTileError,\n        maxCacheSize,\n        maxCacheByteSize,\n        refinementStrategy\n      });\n    }\n    if (!elevationData) {\n      return null;\n    }\n    const SubLayerClass = this.getSubLayerClass('mesh', SimpleMeshLayer);\n    return new SubLayerClass(this.getSubLayerProps({\n      id: 'mesh'\n    }), {\n      data: DUMMY_DATA,\n      mesh: this.state.terrain,\n      texture,\n      _instanced: false,\n      getPosition: d => [0, 0, 0],\n      getColor: color,\n      material,\n      wireframe\n    });\n  }\n}\nTerrainLayer.defaultProps = defaultProps;\nTerrainLayer.layerName = 'TerrainLayer';\nexport default TerrainLayer;\n//# sourceMappingURL=terrain-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}