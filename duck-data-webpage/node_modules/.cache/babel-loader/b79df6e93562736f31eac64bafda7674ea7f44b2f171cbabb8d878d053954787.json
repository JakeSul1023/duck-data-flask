{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Copyright (c) 2017 Uber Technologies, Inc.\nimport { Matrix } from \"./base/matrix.js\";\nimport { checkVector } from \"../lib/validators.js\";\nimport { vec4_transformMat3 } from \"../lib/gl-matrix-extras.js\";\nimport { fromQuat as mat3_fromQuat, determinant as mat3_determinant, transpose as mat3_transpose, invert as mat3_invert, multiply as mat3_multiply, rotate as mat3_rotate, scale as mat3_scale, translate as mat3_translate } from \"../gl-matrix/mat3.js\";\nimport { transformMat3 as vec2_transformMat3 } from \"../gl-matrix/vec2.js\";\nimport { transformMat3 as vec3_transformMat3 } from \"../gl-matrix/vec3.js\";\n// eslint-disable-next-line no-shadow\nvar INDICES;\n(function (INDICES) {\n  INDICES[INDICES[\"COL0ROW0\"] = 0] = \"COL0ROW0\";\n  INDICES[INDICES[\"COL0ROW1\"] = 1] = \"COL0ROW1\";\n  INDICES[INDICES[\"COL0ROW2\"] = 2] = \"COL0ROW2\";\n  INDICES[INDICES[\"COL1ROW0\"] = 3] = \"COL1ROW0\";\n  INDICES[INDICES[\"COL1ROW1\"] = 4] = \"COL1ROW1\";\n  INDICES[INDICES[\"COL1ROW2\"] = 5] = \"COL1ROW2\";\n  INDICES[INDICES[\"COL2ROW0\"] = 6] = \"COL2ROW0\";\n  INDICES[INDICES[\"COL2ROW1\"] = 7] = \"COL2ROW1\";\n  INDICES[INDICES[\"COL2ROW2\"] = 8] = \"COL2ROW2\";\n})(INDICES || (INDICES = {}));\nconst IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);\n/**\n * A 3x3 matrix with common linear algebra operations\n * Subclass of Array<number> meaning that it is highly compatible with other libraries\n */\nexport class Matrix3 extends Matrix {\n  static get IDENTITY() {\n    return getIdentityMatrix();\n  }\n  static get ZERO() {\n    return getZeroMatrix();\n  }\n  get ELEMENTS() {\n    return 9;\n  }\n  get RANK() {\n    return 3;\n  }\n  get INDICES() {\n    return INDICES;\n  }\n  constructor(array) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    // PERF NOTE: initialize elements as double precision numbers\n    super(-0, -0, -0, -0, -0, -0, -0, -0, -0);\n    if (arguments.length === 1 && Array.isArray(array)) {\n      this.copy(array);\n    } else if (args.length > 0) {\n      this.copy([array, ...args]);\n    } else {\n      this.identity();\n    }\n  }\n  copy(array) {\n    // Element wise copy for performance\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    this[3] = array[3];\n    this[4] = array[4];\n    this[5] = array[5];\n    this[6] = array[6];\n    this[7] = array[7];\n    this[8] = array[8];\n    return this.check();\n  }\n  // Constructors\n  identity() {\n    return this.copy(IDENTITY_MATRIX);\n  }\n  /**\n   *\n   * @param object\n   * @returns self\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  fromObject(object) {\n    return this.check();\n  }\n  /** Calculates a 3x3 matrix from the given quaternion\n   * q quat  Quaternion to create matrix from\n   */\n  fromQuaternion(q) {\n    mat3_fromQuat(this, q);\n    return this.check();\n  }\n  /**\n   * accepts column major order, stores in column major order\n   */\n  // eslint-disable-next-line max-params\n  set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {\n    this[0] = m00;\n    this[1] = m10;\n    this[2] = m20;\n    this[3] = m01;\n    this[4] = m11;\n    this[5] = m21;\n    this[6] = m02;\n    this[7] = m12;\n    this[8] = m22;\n    return this.check();\n  }\n  /**\n   * accepts row major order, stores as column major\n   */\n  // eslint-disable-next-line max-params\n  setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n    this[0] = m00;\n    this[1] = m10;\n    this[2] = m20;\n    this[3] = m01;\n    this[4] = m11;\n    this[5] = m21;\n    this[6] = m02;\n    this[7] = m12;\n    this[8] = m22;\n    return this.check();\n  }\n  // Accessors\n  determinant() {\n    return mat3_determinant(this);\n  }\n  // Modifiers\n  transpose() {\n    mat3_transpose(this, this);\n    return this.check();\n  }\n  /** Invert a matrix. Note that this can fail if the matrix is not invertible */\n  invert() {\n    mat3_invert(this, this);\n    return this.check();\n  }\n  // Operations\n  multiplyLeft(a) {\n    mat3_multiply(this, a, this);\n    return this.check();\n  }\n  multiplyRight(a) {\n    mat3_multiply(this, this, a);\n    return this.check();\n  }\n  rotate(radians) {\n    mat3_rotate(this, this, radians);\n    return this.check();\n  }\n  scale(factor) {\n    if (Array.isArray(factor)) {\n      mat3_scale(this, this, factor);\n    } else {\n      mat3_scale(this, this, [factor, factor]);\n    }\n    return this.check();\n  }\n  translate(vec) {\n    mat3_translate(this, this, vec);\n    return this.check();\n  }\n  // Transforms\n  transform(vector, result) {\n    let out;\n    switch (vector.length) {\n      case 2:\n        out = vec2_transformMat3(result || [-0, -0], vector, this);\n        break;\n      case 3:\n        out = vec3_transformMat3(result || [-0, -0, -0], vector, this);\n        break;\n      case 4:\n        out = vec4_transformMat3(result || [-0, -0, -0, -0], vector, this);\n        break;\n      default:\n        throw new Error('Illegal vector');\n    }\n    checkVector(out, vector.length);\n    return out;\n  }\n  /** @deprecated */\n  transformVector(vector, result) {\n    return this.transform(vector, result);\n  }\n  /** @deprecated */\n  transformVector2(vector, result) {\n    return this.transform(vector, result);\n  }\n  /** @deprecated */\n  transformVector3(vector, result) {\n    return this.transform(vector, result);\n  }\n}\nlet ZERO_MATRIX3;\nlet IDENTITY_MATRIX3 = null;\nfunction getZeroMatrix() {\n  if (!ZERO_MATRIX3) {\n    ZERO_MATRIX3 = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    Object.freeze(ZERO_MATRIX3);\n  }\n  return ZERO_MATRIX3;\n}\nfunction getIdentityMatrix() {\n  if (!IDENTITY_MATRIX3) {\n    IDENTITY_MATRIX3 = new Matrix3();\n    Object.freeze(IDENTITY_MATRIX3);\n  }\n  return IDENTITY_MATRIX3;\n}\n//# sourceMappingURL=matrix3.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}