{"ast":null,"code":"/**\n * loaders.gl, MIT license\n *\n * Shared code for 3DTiles extensions:\n * * EXT_feature_metadata\n * * EXT_mesh_features\n * * EXT_structural_metadata\n */\nimport { getComponentTypeFromArray } from \"../../gltf-utils/gltf-utils.js\";\nimport { getImageData } from '@loaders.gl/images';\nfunction emod(n) {\n  return (n % 1 + 1) % 1;\n}\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16,\n  BOOLEAN: 1,\n  STRING: 1,\n  ENUM: 1\n};\nconst ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  INT8: Int8Array,\n  UINT8: Uint8Array,\n  INT16: Int16Array,\n  UINT16: Uint16Array,\n  INT32: Int32Array,\n  UINT32: Uint32Array,\n  INT64: BigInt64Array,\n  UINT64: BigUint64Array,\n  FLOAT32: Float32Array,\n  FLOAT64: Float64Array\n};\nconst ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {\n  INT8: 1,\n  UINT8: 1,\n  INT16: 2,\n  UINT16: 2,\n  INT32: 4,\n  UINT32: 4,\n  INT64: 8,\n  UINT64: 8,\n  FLOAT32: 4,\n  FLOAT64: 8\n};\nexport function getArrayElementByteSize(attributeType, componentType) {\n  return ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[componentType] * ATTRIBUTE_TYPE_TO_COMPONENTS[attributeType];\n}\n/**\n * Gets offset array from `arrayOffsets` or `stringOffsets`.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param bufferViewIndex - Buffer view index\n * @param offsetType - The type of values in `arrayOffsets` or `stringOffsets`.\n * @param numberOfElements - The number of elements in each property array.\n * @returns Array of values offsets. The number of offsets in the array is equal to `numberOfElements` plus one.\n */\nexport function getOffsetsForProperty(scenegraph, bufferViewIndex, offsetType, numberOfElements) {\n  if (offsetType !== 'UINT8' && offsetType !== 'UINT16' && offsetType !== 'UINT32' && offsetType !== 'UINT64') {\n    return null;\n  }\n  const arrayOffsetsBytes = scenegraph.getTypedArrayForBufferView(bufferViewIndex);\n  const arrayOffsets = convertRawBufferToMetadataArray(arrayOffsetsBytes, 'SCALAR',\n  // offsets consist of ONE component\n  offsetType, numberOfElements + 1 // The number of offsets is equal to the property table `count` plus one.\n  );\n  // We don't support BigInt offsets at the moment. It requires additional logic and potential issues in Safari\n  if (arrayOffsets instanceof BigInt64Array || arrayOffsets instanceof BigUint64Array) {\n    return null;\n  }\n  return arrayOffsets;\n}\n/**\n * Converts raw bytes that are in the buffer to an array of the type defined by the schema.\n * @param data - Raw bytes in the buffer.\n * @param attributeType - SCALAR, VECN, MATN.\n * @param componentType - Type of the component in elements, e.g. 'UINT8' or 'FLOAT32'.\n * @param elementCount - Number of elements in the array. Default value is 1.\n * @returns Data array\n */\nexport function convertRawBufferToMetadataArray(data, attributeType, componentType, elementCount = 1) {\n  const numberOfComponents = ATTRIBUTE_TYPE_TO_COMPONENTS[attributeType];\n  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[componentType];\n  const size = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[componentType];\n  const length = elementCount * numberOfComponents;\n  const byteLength = length * size;\n  let buffer = data.buffer;\n  let offset = data.byteOffset;\n  if (offset % size !== 0) {\n    const bufferArray = new Uint8Array(buffer);\n    buffer = bufferArray.slice(offset, offset + byteLength).buffer;\n    offset = 0;\n  }\n  return new ArrayType(buffer, offset, length);\n}\n/**\n * Processes data encoded in the texture associated with the primitive.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param textureInfo - Reference to the texture where extension data are stored.\n * @param primitive - Primitive object in the mesh.\n * @returns Array of data taken. Null if data can't be taken from the texture.\n */\nexport function getPrimitiveTextureData(scenegraph, textureInfo, primitive) {\n  /*\n    texture.index is an index for the \"textures\" array.\n    The texture object referenced by this index looks like this:\n    {\n    \"sampler\": 0,\n    \"source\": 0\n    }\n    \"sampler\" is an index for the \"samplers\" array\n    \"source\" is an index for the \"images\" array that contains data stored in rgba channels of the image.\n       texture.texCoord is a number-suffix (like 1) for an attribute like \"TEXCOORD_1\" in meshes.primitives\n    The value of \"TEXCOORD_1\" is an accessor that is used to get coordinates.\n    These coordinates are being used to get data from the image.\n    \n    Default for texture.texCoord is 0\n    @see https://github.com/CesiumGS/glTF/blob/3d-tiles-next/specification/2.0/schema/textureInfo.schema.json\n  */\n  const texCoordAccessorKey = `TEXCOORD_${textureInfo.texCoord || 0}`;\n  const texCoordAccessorIndex = primitive.attributes[texCoordAccessorKey];\n  const textureCoordinates = scenegraph.getTypedArrayForAccessor(texCoordAccessorIndex);\n  const json = scenegraph.gltf.json;\n  const textureIndex = textureInfo.index;\n  const imageIndex = json.textures?.[textureIndex]?.source;\n  if (typeof imageIndex !== 'undefined') {\n    const mimeType = json.images?.[imageIndex]?.mimeType;\n    const parsedImage = scenegraph.gltf.images?.[imageIndex];\n    // Checking for width is to prevent handling Un-processed images (e.g. [analyze] stage, where loadImages option is set to false)\n    if (parsedImage && typeof parsedImage.width !== 'undefined') {\n      const textureData = [];\n      for (let index = 0; index < textureCoordinates.length; index += 2) {\n        const value = getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index, textureInfo.channels);\n        textureData.push(value);\n      }\n      return textureData;\n    }\n  }\n  return [];\n}\n/**\n * Puts property data to attributes.\n * It creates corresponding buffer, bufferView and accessor\n * so the data can be accessed like regular data stored in buffers.\n * @param scenegraph - Scenegraph object.\n * @param attributeName - Name of the attribute.\n * @param propertyData - Property data to store.\n * @param featureTable - Array where unique data from the property data are being stored.\n * @param primitive - Primitive object.\n */\nexport function primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTable, primitive) {\n  // No reason to create an empty buffer if there is no property data to store.\n  if (!propertyData?.length) {\n    return;\n  }\n  /*\n    featureTable will contain unique values, e.g.\n    propertyData = [24, 35, 28, 24]\n    featureTable = [24, 35, 28]\n    featureIndices will contain indices that refer featureTextureTable, e.g.\n    featureIndices = [0, 1, 2, 0]\n  */\n  const featureIndices = [];\n  for (const texelData of propertyData) {\n    let index = featureTable.findIndex(item => item === texelData);\n    if (index === -1) {\n      index = featureTable.push(texelData) - 1;\n    }\n    featureIndices.push(index);\n  }\n  const typedArray = new Uint32Array(featureIndices);\n  const bufferIndex = scenegraph.gltf.buffers.push({\n    arrayBuffer: typedArray.buffer,\n    byteOffset: typedArray.byteOffset,\n    byteLength: typedArray.byteLength\n  }) - 1;\n  const bufferViewIndex = scenegraph.addBufferView(typedArray, bufferIndex, 0);\n  const accessorIndex = scenegraph.addAccessor(bufferViewIndex, {\n    size: 1,\n    componentType: getComponentTypeFromArray(typedArray),\n    count: typedArray.length\n  });\n  primitive.attributes[attributeName] = accessorIndex;\n}\n/**\n * Gets the value from the texture by coordinates provided.\n * @param parsedImage - Image where the data are stored.\n * @param mimeType - MIME type.\n * @param textureCoordinates - uv coordinates to access data in the image.\n * @param index - Index of uv coordinates in the array textureCoordinates.\n * @param channels - Image channels where data are stored.\n *  Channels of an RGBA texture are numbered 0..3 respectively.\n *  For Ext_mesh_features and EXT_strucural_metadata the channels default is [0]\n *  @see https://github.com/CesiumGS/glTF/blob/3d-tiles-next/extensions/2.0/Vendor/EXT_mesh_features/schema/featureIdTexture.schema.json\n *  @see https://github.com/CesiumGS/glTF/blob/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata/schema/propertyTexture.property.schema.json\n * @returns Value taken from the image.\n */\nfunction getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index, channels = [0]) {\n  const CHANNELS_MAP = {\n    r: {\n      offset: 0,\n      shift: 0\n    },\n    g: {\n      offset: 1,\n      shift: 8\n    },\n    b: {\n      offset: 2,\n      shift: 16\n    },\n    a: {\n      offset: 3,\n      shift: 24\n    }\n  };\n  const u = textureCoordinates[index];\n  const v = textureCoordinates[index + 1];\n  let components = 1;\n  if (mimeType && (mimeType.indexOf('image/jpeg') !== -1 || mimeType.indexOf('image/png') !== -1)) components = 4;\n  const offset = coordinatesToOffset(u, v, parsedImage, components);\n  let value = 0;\n  for (const c of channels) {\n    /*\n    According to the EXT_feature_metadata extension specification:\n      Channels are labeled by rgba and are swizzled with a string of 1-4 characters.\n    According to the EXT_mesh_features extension specification:\n      The channels array contains non-negative integer values corresponding to channels of the source texture that the feature ID consists of.\n      Channels of an RGBA texture are numbered 0â€“3 respectively.\n    Function getImageValueByCoordinates is used to process both extensions.\n    So, there should be possible to get the element of CHANNELS_MAP by either index (0, 1, 2, 3) or key (r, g, b, a).\n    */\n    const map = typeof c === 'number' ? Object.values(CHANNELS_MAP)[c] : CHANNELS_MAP[c];\n    const imageOffset = offset + map.offset;\n    const imageData = getImageData(parsedImage);\n    if (imageData.data.length <= imageOffset) {\n      throw new Error(`${imageData.data.length} <= ${imageOffset}`);\n    }\n    const imageValue = imageData.data[imageOffset];\n    value |= imageValue << map.shift;\n  }\n  return value;\n}\n/**\n * Retrieves the offset in the image where the data are stored.\n * @param u - u-coordinate.\n * @param v - v-coordinate.\n * @param parsedImage - Image where the data are stored.\n * @param componentsCount - Number of components the data consists of.\n * @returns Offset in the image where the data are stored.\n */\nfunction coordinatesToOffset(u, v, parsedImage, componentsCount = 1) {\n  const w = parsedImage.width;\n  const iX = emod(u) * (w - 1);\n  const indX = Math.round(iX);\n  const h = parsedImage.height;\n  const iY = emod(v) * (h - 1);\n  const indY = Math.round(iY);\n  const components = parsedImage.components ? parsedImage.components : componentsCount;\n  // components is a number of channels in the image\n  const offset = (indY * w + indX) * components;\n  return offset;\n}\n/**\n * Parses variable-length array data.\n * In this case every value of the property in the table will be an array\n * of arbitrary length.\n * @param valuesData - Values in a flat typed array.\n * @param numberOfElements - Number of rows in the property table.\n * @param arrayOffsets - Offsets of nested arrays in the flat values array.\n * @param valuesDataBytesLength - Data byte length.\n * @param valueSize - Value size in bytes.\n * @returns Array of typed arrays.\n */\nexport function parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytesLength, valueSize) {\n  const attributeValueArray = [];\n  for (let index = 0; index < numberOfElements; index++) {\n    const arrayOffset = arrayOffsets[index];\n    const arrayByteSize = arrayOffsets[index + 1] - arrayOffsets[index];\n    if (arrayByteSize + arrayOffset > valuesDataBytesLength) {\n      break;\n    }\n    const typedArrayOffset = arrayOffset / valueSize;\n    const elementCount = arrayByteSize / valueSize;\n    attributeValueArray.push(valuesData.slice(typedArrayOffset, typedArrayOffset + elementCount));\n  }\n  return attributeValueArray;\n}\n/**\n * Parses fixed-length array data.\n * In this case every value of the property in the table will be an array\n * of constant length equal to `arrayCount`.\n * @param valuesData - Values in a flat typed array.\n * @param numberOfElements - Number of rows in the property table.\n * @param arrayCount - Nested arrays length.\n * @returns Array of typed arrays.\n */\nexport function parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount) {\n  const attributeValueArray = [];\n  for (let index = 0; index < numberOfElements; index++) {\n    const elementOffset = index * arrayCount;\n    attributeValueArray.push(valuesData.slice(elementOffset, elementOffset + arrayCount));\n  }\n  return attributeValueArray;\n}\n/**\n * Decodes properties of string type from binary source.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param valuesDataBytes - Data taken from values property of the property table property.\n * @param arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @param stringOffsets - Index of the buffer view containing offsets for strings. It should be available for string type.\n * @returns String property values\n */\nexport function getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets) {\n  if (arrayOffsets) {\n    // TODO: implement it as soon as we have the corresponding tileset\n    throw new Error('Not implemented - arrayOffsets for strings is specified');\n  }\n  if (stringOffsets) {\n    const stringsArray = [];\n    const textDecoder = new TextDecoder('utf8');\n    let stringOffset = 0;\n    for (let index = 0; index < numberOfElements; index++) {\n      const stringByteSize = stringOffsets[index + 1] - stringOffsets[index];\n      if (stringByteSize + stringOffset <= valuesDataBytes.length) {\n        const stringData = valuesDataBytes.subarray(stringOffset, stringByteSize + stringOffset);\n        const stringAttribute = textDecoder.decode(stringData);\n        stringsArray.push(stringAttribute);\n        stringOffset += stringByteSize;\n      }\n    }\n    return stringsArray;\n  }\n  return [];\n}","map":{"version":3,"names":["getComponentTypeFromArray","getImageData","emod","n","ATTRIBUTE_TYPE_TO_COMPONENTS","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","BOOLEAN","STRING","ENUM","ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY","INT8","Int8Array","UINT8","Uint8Array","INT16","Int16Array","UINT16","Uint16Array","INT32","Int32Array","UINT32","Uint32Array","INT64","BigInt64Array","UINT64","BigUint64Array","FLOAT32","Float32Array","FLOAT64","Float64Array","ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE","getArrayElementByteSize","attributeType","componentType","getOffsetsForProperty","scenegraph","bufferViewIndex","offsetType","numberOfElements","arrayOffsetsBytes","getTypedArrayForBufferView","arrayOffsets","convertRawBufferToMetadataArray","data","elementCount","numberOfComponents","ArrayType","size","length","byteLength","buffer","offset","byteOffset","bufferArray","slice","getPrimitiveTextureData","textureInfo","primitive","texCoordAccessorKey","texCoord","texCoordAccessorIndex","attributes","textureCoordinates","getTypedArrayForAccessor","json","gltf","textureIndex","index","imageIndex","textures","source","mimeType","images","parsedImage","width","textureData","value","getImageValueByCoordinates","channels","push","primitivePropertyDataToAttributes","attributeName","propertyData","featureTable","featureIndices","texelData","findIndex","item","typedArray","bufferIndex","buffers","arrayBuffer","addBufferView","accessorIndex","addAccessor","count","CHANNELS_MAP","r","shift","g","b","a","u","v","components","indexOf","coordinatesToOffset","c","map","Object","values","imageOffset","imageData","Error","imageValue","componentsCount","w","iX","indX","Math","round","h","height","iY","indY","parseVariableLengthArrayNumeric","valuesData","valuesDataBytesLength","valueSize","attributeValueArray","arrayOffset","arrayByteSize","typedArrayOffset","parseFixedLengthArrayNumeric","arrayCount","elementOffset","getPropertyDataString","valuesDataBytes","stringOffsets","stringsArray","textDecoder","TextDecoder","stringOffset","stringByteSize","stringData","subarray","stringAttribute","decode"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/gltf/dist/lib/extensions/utils/3d-tiles-utils.js"],"sourcesContent":["/**\n * loaders.gl, MIT license\n *\n * Shared code for 3DTiles extensions:\n * * EXT_feature_metadata\n * * EXT_mesh_features\n * * EXT_structural_metadata\n */\nimport { getComponentTypeFromArray } from \"../../gltf-utils/gltf-utils.js\";\nimport { getImageData } from '@loaders.gl/images';\nfunction emod(n) {\n    return ((n % 1) + 1) % 1;\n}\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16,\n    BOOLEAN: 1,\n    STRING: 1,\n    ENUM: 1\n};\nconst ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n    INT8: Int8Array,\n    UINT8: Uint8Array,\n    INT16: Int16Array,\n    UINT16: Uint16Array,\n    INT32: Int32Array,\n    UINT32: Uint32Array,\n    INT64: BigInt64Array,\n    UINT64: BigUint64Array,\n    FLOAT32: Float32Array,\n    FLOAT64: Float64Array\n};\nconst ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {\n    INT8: 1,\n    UINT8: 1,\n    INT16: 2,\n    UINT16: 2,\n    INT32: 4,\n    UINT32: 4,\n    INT64: 8,\n    UINT64: 8,\n    FLOAT32: 4,\n    FLOAT64: 8\n};\nexport function getArrayElementByteSize(attributeType, componentType) {\n    return (ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[componentType] *\n        ATTRIBUTE_TYPE_TO_COMPONENTS[attributeType]);\n}\n/**\n * Gets offset array from `arrayOffsets` or `stringOffsets`.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param bufferViewIndex - Buffer view index\n * @param offsetType - The type of values in `arrayOffsets` or `stringOffsets`.\n * @param numberOfElements - The number of elements in each property array.\n * @returns Array of values offsets. The number of offsets in the array is equal to `numberOfElements` plus one.\n */\nexport function getOffsetsForProperty(scenegraph, bufferViewIndex, offsetType, numberOfElements) {\n    if (offsetType !== 'UINT8' &&\n        offsetType !== 'UINT16' &&\n        offsetType !== 'UINT32' &&\n        offsetType !== 'UINT64') {\n        return null;\n    }\n    const arrayOffsetsBytes = scenegraph.getTypedArrayForBufferView(bufferViewIndex);\n    const arrayOffsets = convertRawBufferToMetadataArray(arrayOffsetsBytes, 'SCALAR', // offsets consist of ONE component\n    offsetType, numberOfElements + 1 // The number of offsets is equal to the property table `count` plus one.\n    );\n    // We don't support BigInt offsets at the moment. It requires additional logic and potential issues in Safari\n    if (arrayOffsets instanceof BigInt64Array || arrayOffsets instanceof BigUint64Array) {\n        return null;\n    }\n    return arrayOffsets;\n}\n/**\n * Converts raw bytes that are in the buffer to an array of the type defined by the schema.\n * @param data - Raw bytes in the buffer.\n * @param attributeType - SCALAR, VECN, MATN.\n * @param componentType - Type of the component in elements, e.g. 'UINT8' or 'FLOAT32'.\n * @param elementCount - Number of elements in the array. Default value is 1.\n * @returns Data array\n */\nexport function convertRawBufferToMetadataArray(data, attributeType, componentType, elementCount = 1) {\n    const numberOfComponents = ATTRIBUTE_TYPE_TO_COMPONENTS[attributeType];\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[componentType];\n    const size = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[componentType];\n    const length = elementCount * numberOfComponents;\n    const byteLength = length * size;\n    let buffer = data.buffer;\n    let offset = data.byteOffset;\n    if (offset % size !== 0) {\n        const bufferArray = new Uint8Array(buffer);\n        buffer = bufferArray.slice(offset, offset + byteLength).buffer;\n        offset = 0;\n    }\n    return new ArrayType(buffer, offset, length);\n}\n/**\n * Processes data encoded in the texture associated with the primitive.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param textureInfo - Reference to the texture where extension data are stored.\n * @param primitive - Primitive object in the mesh.\n * @returns Array of data taken. Null if data can't be taken from the texture.\n */\nexport function getPrimitiveTextureData(scenegraph, textureInfo, primitive) {\n    /*\n      texture.index is an index for the \"textures\" array.\n      The texture object referenced by this index looks like this:\n      {\n      \"sampler\": 0,\n      \"source\": 0\n      }\n      \"sampler\" is an index for the \"samplers\" array\n      \"source\" is an index for the \"images\" array that contains data stored in rgba channels of the image.\n  \n      texture.texCoord is a number-suffix (like 1) for an attribute like \"TEXCOORD_1\" in meshes.primitives\n      The value of \"TEXCOORD_1\" is an accessor that is used to get coordinates.\n      These coordinates are being used to get data from the image.\n      \n      Default for texture.texCoord is 0\n      @see https://github.com/CesiumGS/glTF/blob/3d-tiles-next/specification/2.0/schema/textureInfo.schema.json\n    */\n    const texCoordAccessorKey = `TEXCOORD_${textureInfo.texCoord || 0}`;\n    const texCoordAccessorIndex = primitive.attributes[texCoordAccessorKey];\n    const textureCoordinates = scenegraph.getTypedArrayForAccessor(texCoordAccessorIndex);\n    const json = scenegraph.gltf.json;\n    const textureIndex = textureInfo.index;\n    const imageIndex = json.textures?.[textureIndex]?.source;\n    if (typeof imageIndex !== 'undefined') {\n        const mimeType = json.images?.[imageIndex]?.mimeType;\n        const parsedImage = scenegraph.gltf.images?.[imageIndex];\n        // Checking for width is to prevent handling Un-processed images (e.g. [analyze] stage, where loadImages option is set to false)\n        if (parsedImage && typeof parsedImage.width !== 'undefined') {\n            const textureData = [];\n            for (let index = 0; index < textureCoordinates.length; index += 2) {\n                const value = getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index, textureInfo.channels);\n                textureData.push(value);\n            }\n            return textureData;\n        }\n    }\n    return [];\n}\n/**\n * Puts property data to attributes.\n * It creates corresponding buffer, bufferView and accessor\n * so the data can be accessed like regular data stored in buffers.\n * @param scenegraph - Scenegraph object.\n * @param attributeName - Name of the attribute.\n * @param propertyData - Property data to store.\n * @param featureTable - Array where unique data from the property data are being stored.\n * @param primitive - Primitive object.\n */\nexport function primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTable, primitive) {\n    // No reason to create an empty buffer if there is no property data to store.\n    if (!propertyData?.length) {\n        return;\n    }\n    /*\n      featureTable will contain unique values, e.g.\n      propertyData = [24, 35, 28, 24]\n      featureTable = [24, 35, 28]\n      featureIndices will contain indices that refer featureTextureTable, e.g.\n      featureIndices = [0, 1, 2, 0]\n    */\n    const featureIndices = [];\n    for (const texelData of propertyData) {\n        let index = featureTable.findIndex((item) => item === texelData);\n        if (index === -1) {\n            index = featureTable.push(texelData) - 1;\n        }\n        featureIndices.push(index);\n    }\n    const typedArray = new Uint32Array(featureIndices);\n    const bufferIndex = scenegraph.gltf.buffers.push({\n        arrayBuffer: typedArray.buffer,\n        byteOffset: typedArray.byteOffset,\n        byteLength: typedArray.byteLength\n    }) - 1;\n    const bufferViewIndex = scenegraph.addBufferView(typedArray, bufferIndex, 0);\n    const accessorIndex = scenegraph.addAccessor(bufferViewIndex, {\n        size: 1,\n        componentType: getComponentTypeFromArray(typedArray),\n        count: typedArray.length\n    });\n    primitive.attributes[attributeName] = accessorIndex;\n}\n/**\n * Gets the value from the texture by coordinates provided.\n * @param parsedImage - Image where the data are stored.\n * @param mimeType - MIME type.\n * @param textureCoordinates - uv coordinates to access data in the image.\n * @param index - Index of uv coordinates in the array textureCoordinates.\n * @param channels - Image channels where data are stored.\n *  Channels of an RGBA texture are numbered 0..3 respectively.\n *  For Ext_mesh_features and EXT_strucural_metadata the channels default is [0]\n *  @see https://github.com/CesiumGS/glTF/blob/3d-tiles-next/extensions/2.0/Vendor/EXT_mesh_features/schema/featureIdTexture.schema.json\n *  @see https://github.com/CesiumGS/glTF/blob/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata/schema/propertyTexture.property.schema.json\n * @returns Value taken from the image.\n */\nfunction getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index, channels = [0]) {\n    const CHANNELS_MAP = {\n        r: { offset: 0, shift: 0 },\n        g: { offset: 1, shift: 8 },\n        b: { offset: 2, shift: 16 },\n        a: { offset: 3, shift: 24 }\n    };\n    const u = textureCoordinates[index];\n    const v = textureCoordinates[index + 1];\n    let components = 1;\n    if (mimeType && (mimeType.indexOf('image/jpeg') !== -1 || mimeType.indexOf('image/png') !== -1))\n        components = 4;\n    const offset = coordinatesToOffset(u, v, parsedImage, components);\n    let value = 0;\n    for (const c of channels) {\n        /*\n        According to the EXT_feature_metadata extension specification:\n          Channels are labeled by rgba and are swizzled with a string of 1-4 characters.\n        According to the EXT_mesh_features extension specification:\n          The channels array contains non-negative integer values corresponding to channels of the source texture that the feature ID consists of.\n          Channels of an RGBA texture are numbered 0â€“3 respectively.\n        Function getImageValueByCoordinates is used to process both extensions.\n        So, there should be possible to get the element of CHANNELS_MAP by either index (0, 1, 2, 3) or key (r, g, b, a).\n        */\n        const map = typeof c === 'number' ? Object.values(CHANNELS_MAP)[c] : CHANNELS_MAP[c];\n        const imageOffset = offset + map.offset;\n        const imageData = getImageData(parsedImage);\n        if (imageData.data.length <= imageOffset) {\n            throw new Error(`${imageData.data.length} <= ${imageOffset}`);\n        }\n        const imageValue = imageData.data[imageOffset];\n        value |= imageValue << map.shift;\n    }\n    return value;\n}\n/**\n * Retrieves the offset in the image where the data are stored.\n * @param u - u-coordinate.\n * @param v - v-coordinate.\n * @param parsedImage - Image where the data are stored.\n * @param componentsCount - Number of components the data consists of.\n * @returns Offset in the image where the data are stored.\n */\nfunction coordinatesToOffset(u, v, parsedImage, componentsCount = 1) {\n    const w = parsedImage.width;\n    const iX = emod(u) * (w - 1);\n    const indX = Math.round(iX);\n    const h = parsedImage.height;\n    const iY = emod(v) * (h - 1);\n    const indY = Math.round(iY);\n    const components = parsedImage.components ? parsedImage.components : componentsCount;\n    // components is a number of channels in the image\n    const offset = (indY * w + indX) * components;\n    return offset;\n}\n/**\n * Parses variable-length array data.\n * In this case every value of the property in the table will be an array\n * of arbitrary length.\n * @param valuesData - Values in a flat typed array.\n * @param numberOfElements - Number of rows in the property table.\n * @param arrayOffsets - Offsets of nested arrays in the flat values array.\n * @param valuesDataBytesLength - Data byte length.\n * @param valueSize - Value size in bytes.\n * @returns Array of typed arrays.\n */\nexport function parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytesLength, valueSize) {\n    const attributeValueArray = [];\n    for (let index = 0; index < numberOfElements; index++) {\n        const arrayOffset = arrayOffsets[index];\n        const arrayByteSize = arrayOffsets[index + 1] - arrayOffsets[index];\n        if (arrayByteSize + arrayOffset > valuesDataBytesLength) {\n            break;\n        }\n        const typedArrayOffset = arrayOffset / valueSize;\n        const elementCount = arrayByteSize / valueSize;\n        attributeValueArray.push(valuesData.slice(typedArrayOffset, typedArrayOffset + elementCount));\n    }\n    return attributeValueArray;\n}\n/**\n * Parses fixed-length array data.\n * In this case every value of the property in the table will be an array\n * of constant length equal to `arrayCount`.\n * @param valuesData - Values in a flat typed array.\n * @param numberOfElements - Number of rows in the property table.\n * @param arrayCount - Nested arrays length.\n * @returns Array of typed arrays.\n */\nexport function parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount) {\n    const attributeValueArray = [];\n    for (let index = 0; index < numberOfElements; index++) {\n        const elementOffset = index * arrayCount;\n        attributeValueArray.push(valuesData.slice(elementOffset, elementOffset + arrayCount));\n    }\n    return attributeValueArray;\n}\n/**\n * Decodes properties of string type from binary source.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param valuesDataBytes - Data taken from values property of the property table property.\n * @param arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @param stringOffsets - Index of the buffer view containing offsets for strings. It should be available for string type.\n * @returns String property values\n */\nexport function getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets) {\n    if (arrayOffsets) {\n        // TODO: implement it as soon as we have the corresponding tileset\n        throw new Error('Not implemented - arrayOffsets for strings is specified');\n    }\n    if (stringOffsets) {\n        const stringsArray = [];\n        const textDecoder = new TextDecoder('utf8');\n        let stringOffset = 0;\n        for (let index = 0; index < numberOfElements; index++) {\n            const stringByteSize = stringOffsets[index + 1] - stringOffsets[index];\n            if (stringByteSize + stringOffset <= valuesDataBytes.length) {\n                const stringData = valuesDataBytes.subarray(stringOffset, stringByteSize + stringOffset);\n                const stringAttribute = textDecoder.decode(stringData);\n                stringsArray.push(stringAttribute);\n                stringOffset += stringByteSize;\n            }\n        }\n        return stringsArray;\n    }\n    return [];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}