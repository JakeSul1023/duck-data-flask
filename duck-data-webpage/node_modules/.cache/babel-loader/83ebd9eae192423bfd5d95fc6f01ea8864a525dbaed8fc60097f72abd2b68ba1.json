{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@deck.gl/core';\nimport { terrainModule } from \"./shader-module.js\";\nimport { TerrainCover } from \"./terrain-cover.js\";\nimport { TerrainPass } from \"./terrain-pass.js\";\nimport { TerrainPickingPass } from \"./terrain-picking-pass.js\";\nimport { HeightMapBuilder } from \"./height-map-builder.js\";\n/** Class to manage terrain effect */\nexport class TerrainEffect {\n  constructor() {\n    this.id = 'terrain-effect';\n    this.props = null;\n    this.useInPicking = true;\n    /** true if picking in the current pass */\n    this.isPicking = false;\n    /** true if should use in the current pass */\n    this.isDrapingEnabled = false;\n    /** One texture for each primitive terrain layer, into which the draped layers render */\n    this.terrainCovers = new Map();\n  }\n  setup({\n    device,\n    deck\n  }) {\n    this.dummyHeightMap = device.createTexture({\n      width: 1,\n      height: 1,\n      data: new Uint8Array([0, 0, 0, 0])\n    });\n    this.terrainPass = new TerrainPass(device, {\n      id: 'terrain'\n    });\n    this.terrainPickingPass = new TerrainPickingPass(device, {\n      id: 'terrain-picking'\n    });\n    if (HeightMapBuilder.isSupported(device)) {\n      this.heightMap = new HeightMapBuilder(device);\n    } else {\n      log.warn('Terrain offset mode is not supported by this browser')();\n    }\n    deck._addDefaultShaderModule(terrainModule);\n  }\n  preRender(opts) {\n    // @ts-expect-error pickZ only defined in picking pass\n    if (opts.pickZ) {\n      // Do not update if picking attributes\n      this.isDrapingEnabled = false;\n      return;\n    }\n    const {\n      viewports\n    } = opts;\n    const isPicking = opts.pass.startsWith('picking');\n    this.isPicking = isPicking;\n    this.isDrapingEnabled = true;\n    // TODO - support multiple views?\n    const viewport = viewports[0];\n    const layers = (isPicking ? this.terrainPickingPass : this.terrainPass).getRenderableLayers(viewport, opts);\n    const terrainLayers = layers.filter(l => l.props.operation.includes('terrain'));\n    if (terrainLayers.length === 0) {\n      return;\n    }\n    if (!isPicking) {\n      const offsetLayers = layers.filter(l => l.state.terrainDrawMode === 'offset');\n      if (offsetLayers.length > 0) {\n        this._updateHeightMap(terrainLayers, viewport, opts);\n      }\n    }\n    const drapeLayers = layers.filter(l => l.state.terrainDrawMode === 'drape');\n    this._updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts);\n  }\n  getShaderModuleProps(layer, otherShaderModuleProps) {\n    const {\n      terrainDrawMode\n    } = layer.state;\n    return {\n      terrain: {\n        project: otherShaderModuleProps.project,\n        isPicking: this.isPicking,\n        heightMap: this.heightMap?.getRenderFramebuffer()?.colorAttachments[0].texture || null,\n        heightMapBounds: this.heightMap?.bounds,\n        dummyHeightMap: this.dummyHeightMap,\n        terrainCover: this.isDrapingEnabled ? this.terrainCovers.get(layer.id) : null,\n        useTerrainHeightMap: terrainDrawMode === 'offset',\n        terrainSkipRender: terrainDrawMode === 'drape' || !layer.props.operation.includes('draw')\n      }\n    };\n  }\n  cleanup({\n    deck\n  }) {\n    if (this.dummyHeightMap) {\n      this.dummyHeightMap.delete();\n      this.dummyHeightMap = undefined;\n    }\n    if (this.heightMap) {\n      this.heightMap.delete();\n      this.heightMap = undefined;\n    }\n    for (const terrainCover of this.terrainCovers.values()) {\n      terrainCover.delete();\n    }\n    this.terrainCovers.clear();\n    deck._removeDefaultShaderModule(terrainModule);\n  }\n  _updateHeightMap(terrainLayers, viewport, opts) {\n    if (!this.heightMap) {\n      // Not supported\n      return;\n    }\n    const shouldUpdate = this.heightMap.shouldUpdate({\n      layers: terrainLayers,\n      viewport\n    });\n    if (!shouldUpdate) {\n      return;\n    }\n    this.terrainPass.renderHeightMap(this.heightMap, {\n      ...opts,\n      layers: terrainLayers,\n      shaderModuleProps: {\n        terrain: {\n          heightMapBounds: this.heightMap.bounds,\n          dummyHeightMap: this.dummyHeightMap,\n          drawToTerrainHeightMap: true\n        },\n        project: {\n          devicePixelRatio: 1\n        }\n      }\n    });\n  }\n  _updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts) {\n    // Mark a terrain cover as dirty if one of the drape layers needs redraw\n    const layerNeedsRedraw = {};\n    for (const layer of drapeLayers) {\n      if (layer.state.terrainCoverNeedsRedraw) {\n        layerNeedsRedraw[layer.id] = true;\n        layer.state.terrainCoverNeedsRedraw = false;\n      }\n    }\n    for (const terrainCover of this.terrainCovers.values()) {\n      terrainCover.isDirty = terrainCover.isDirty || terrainCover.shouldUpdate({\n        layerNeedsRedraw\n      });\n    }\n    for (const layer of terrainLayers) {\n      this._updateTerrainCover(layer, drapeLayers, viewport, opts);\n    }\n    if (!this.isPicking) {\n      this._pruneTerrainCovers();\n    }\n  }\n  _updateTerrainCover(terrainLayer, drapeLayers, viewport, opts) {\n    const renderPass = this.isPicking ? this.terrainPickingPass : this.terrainPass;\n    let terrainCover = this.terrainCovers.get(terrainLayer.id);\n    if (!terrainCover) {\n      terrainCover = new TerrainCover(terrainLayer);\n      this.terrainCovers.set(terrainLayer.id, terrainCover);\n    }\n    try {\n      const isDirty = terrainCover.shouldUpdate({\n        targetLayer: terrainLayer,\n        viewport,\n        layers: drapeLayers\n      });\n      if (this.isPicking || terrainCover.isDirty || isDirty) {\n        renderPass.renderTerrainCover(terrainCover, {\n          ...opts,\n          layers: drapeLayers,\n          shaderModuleProps: {\n            terrain: {\n              dummyHeightMap: this.dummyHeightMap,\n              terrainSkipRender: false\n            },\n            project: {\n              devicePixelRatio: 1\n            }\n          }\n        });\n        if (!this.isPicking) {\n          // IsDirty refers to the normal fbo, not the picking fbo.\n          // Only mark it as not dirty if the normal fbo was updated.\n          terrainCover.isDirty = false;\n        }\n      }\n    } catch (err) {\n      terrainLayer.raiseError(err, `Error rendering terrain cover ${terrainCover.id}`);\n    }\n  }\n  _pruneTerrainCovers() {\n    /** Prune the cache, remove textures for layers that have been removed */\n    const idsToRemove = [];\n    for (const [id, terrainCover] of this.terrainCovers) {\n      if (!terrainCover.isActive) {\n        idsToRemove.push(id);\n      }\n    }\n    for (const id of idsToRemove) {\n      this.terrainCovers.delete(id);\n    }\n  }\n}","map":{"version":3,"names":["log","terrainModule","TerrainCover","TerrainPass","TerrainPickingPass","HeightMapBuilder","TerrainEffect","constructor","id","props","useInPicking","isPicking","isDrapingEnabled","terrainCovers","Map","setup","device","deck","dummyHeightMap","createTexture","width","height","data","Uint8Array","terrainPass","terrainPickingPass","isSupported","heightMap","warn","_addDefaultShaderModule","preRender","opts","pickZ","viewports","pass","startsWith","viewport","layers","getRenderableLayers","terrainLayers","filter","l","operation","includes","length","offsetLayers","state","terrainDrawMode","_updateHeightMap","drapeLayers","_updateTerrainCovers","getShaderModuleProps","layer","otherShaderModuleProps","terrain","project","getRenderFramebuffer","colorAttachments","texture","heightMapBounds","bounds","terrainCover","get","useTerrainHeightMap","terrainSkipRender","cleanup","delete","undefined","values","clear","_removeDefaultShaderModule","shouldUpdate","renderHeightMap","shaderModuleProps","drawToTerrainHeightMap","devicePixelRatio","layerNeedsRedraw","terrainCoverNeedsRedraw","isDirty","_updateTerrainCover","_pruneTerrainCovers","terrainLayer","renderPass","set","targetLayer","renderTerrainCover","err","raiseError","idsToRemove","isActive","push"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\extensions\\src\\terrain\\terrain-effect.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Texture} from '@luma.gl/core';\nimport {log} from '@deck.gl/core';\n\nimport {terrainModule, TerrainModuleProps} from './shader-module';\nimport {TerrainCover} from './terrain-cover';\nimport {TerrainPass} from './terrain-pass';\nimport {TerrainPickingPass, TerrainPickingPassRenderOptions} from './terrain-picking-pass';\nimport {HeightMapBuilder} from './height-map-builder';\n\nimport type {Effect, EffectContext, PreRenderOptions, Layer, Viewport} from '@deck.gl/core';\n\n/** Class to manage terrain effect */\nexport class TerrainEffect implements Effect {\n  id = 'terrain-effect';\n  props = null;\n  useInPicking = true;\n\n  /** true if picking in the current pass */\n  private isPicking: boolean = false;\n  /** true if should use in the current pass */\n  private isDrapingEnabled: boolean = false;\n  /** An empty texture as placeholder */\n  private dummyHeightMap?: Texture;\n  /** A texture encoding the ground elevation, updated once per redraw. Used by layers with offset mode */\n  private heightMap?: HeightMapBuilder;\n  private terrainPass!: TerrainPass;\n  private terrainPickingPass!: TerrainPickingPass;\n  /** One texture for each primitive terrain layer, into which the draped layers render */\n  private terrainCovers: Map<string, TerrainCover> = new Map();\n\n  setup({device, deck}: EffectContext) {\n    this.dummyHeightMap = device.createTexture({\n      width: 1,\n      height: 1,\n      data: new Uint8Array([0, 0, 0, 0])\n    });\n    this.terrainPass = new TerrainPass(device, {id: 'terrain'});\n    this.terrainPickingPass = new TerrainPickingPass(device, {id: 'terrain-picking'});\n\n    if (HeightMapBuilder.isSupported(device)) {\n      this.heightMap = new HeightMapBuilder(device);\n    } else {\n      log.warn('Terrain offset mode is not supported by this browser')();\n    }\n\n    deck._addDefaultShaderModule(terrainModule);\n  }\n\n  preRender(opts: PreRenderOptions): void {\n    // @ts-expect-error pickZ only defined in picking pass\n    if (opts.pickZ) {\n      // Do not update if picking attributes\n      this.isDrapingEnabled = false;\n      return;\n    }\n\n    const {viewports} = opts;\n    const isPicking = opts.pass.startsWith('picking');\n    this.isPicking = isPicking;\n    this.isDrapingEnabled = true;\n\n    // TODO - support multiple views?\n    const viewport = viewports[0];\n    const layers = (isPicking ? this.terrainPickingPass : this.terrainPass).getRenderableLayers(\n      viewport,\n      opts as TerrainPickingPassRenderOptions\n    );\n\n    const terrainLayers = layers.filter(l => l.props.operation.includes('terrain'));\n    if (terrainLayers.length === 0) {\n      return;\n    }\n\n    if (!isPicking) {\n      const offsetLayers = layers.filter(l => l.state.terrainDrawMode === 'offset');\n      if (offsetLayers.length > 0) {\n        this._updateHeightMap(terrainLayers, viewport, opts);\n      }\n    }\n\n    const drapeLayers = layers.filter(l => l.state.terrainDrawMode === 'drape');\n    this._updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts);\n  }\n\n  getShaderModuleProps(\n    layer: Layer,\n    otherShaderModuleProps: Record<string, any>\n  ): {terrain: TerrainModuleProps} {\n    const {terrainDrawMode} = layer.state;\n\n    return {\n      terrain: {\n        project: otherShaderModuleProps.project,\n        isPicking: this.isPicking,\n        heightMap: this.heightMap?.getRenderFramebuffer()?.colorAttachments[0].texture || null,\n        heightMapBounds: this.heightMap?.bounds,\n        dummyHeightMap: this.dummyHeightMap!,\n        terrainCover: this.isDrapingEnabled ? this.terrainCovers.get(layer.id) : null,\n        useTerrainHeightMap: terrainDrawMode === 'offset',\n        terrainSkipRender: terrainDrawMode === 'drape' || !layer.props.operation.includes('draw')\n      }\n    };\n  }\n\n  cleanup({deck}: EffectContext): void {\n    if (this.dummyHeightMap) {\n      this.dummyHeightMap.delete();\n      this.dummyHeightMap = undefined;\n    }\n\n    if (this.heightMap) {\n      this.heightMap.delete();\n      this.heightMap = undefined;\n    }\n\n    for (const terrainCover of this.terrainCovers.values()) {\n      terrainCover.delete();\n    }\n    this.terrainCovers.clear();\n\n    deck._removeDefaultShaderModule(terrainModule);\n  }\n\n  private _updateHeightMap(terrainLayers: Layer[], viewport: Viewport, opts: PreRenderOptions) {\n    if (!this.heightMap) {\n      // Not supported\n      return;\n    }\n\n    const shouldUpdate = this.heightMap.shouldUpdate({layers: terrainLayers, viewport});\n    if (!shouldUpdate) {\n      return;\n    }\n\n    this.terrainPass.renderHeightMap(this.heightMap, {\n      ...opts,\n      layers: terrainLayers,\n      shaderModuleProps: {\n        terrain: {\n          heightMapBounds: this.heightMap.bounds,\n          dummyHeightMap: this.dummyHeightMap,\n          drawToTerrainHeightMap: true\n        },\n        project: {\n          devicePixelRatio: 1\n        }\n      }\n    });\n  }\n\n  private _updateTerrainCovers(\n    terrainLayers: Layer[],\n    drapeLayers: Layer[],\n    viewport: Viewport,\n    opts: PreRenderOptions\n  ) {\n    // Mark a terrain cover as dirty if one of the drape layers needs redraw\n    const layerNeedsRedraw: Record<string, boolean> = {};\n    for (const layer of drapeLayers) {\n      if (layer.state.terrainCoverNeedsRedraw) {\n        layerNeedsRedraw[layer.id] = true;\n        layer.state.terrainCoverNeedsRedraw = false;\n      }\n    }\n    for (const terrainCover of this.terrainCovers.values()) {\n      terrainCover.isDirty = terrainCover.isDirty || terrainCover.shouldUpdate({layerNeedsRedraw});\n    }\n\n    for (const layer of terrainLayers) {\n      this._updateTerrainCover(layer, drapeLayers, viewport, opts);\n    }\n\n    if (!this.isPicking) {\n      this._pruneTerrainCovers();\n    }\n  }\n\n  private _updateTerrainCover(\n    terrainLayer: Layer,\n    drapeLayers: Layer[],\n    viewport: Viewport,\n    opts: PreRenderOptions\n  ) {\n    const renderPass = this.isPicking ? this.terrainPickingPass : this.terrainPass;\n    let terrainCover = this.terrainCovers.get(terrainLayer.id);\n    if (!terrainCover) {\n      terrainCover = new TerrainCover(terrainLayer);\n      this.terrainCovers.set(terrainLayer.id, terrainCover);\n    }\n    try {\n      const isDirty = terrainCover.shouldUpdate({\n        targetLayer: terrainLayer,\n        viewport,\n        layers: drapeLayers\n      });\n      if (this.isPicking || terrainCover.isDirty || isDirty) {\n        renderPass.renderTerrainCover(terrainCover, {\n          ...opts,\n          layers: drapeLayers,\n          shaderModuleProps: {\n            terrain: {\n              dummyHeightMap: this.dummyHeightMap,\n              terrainSkipRender: false\n            },\n            project: {\n              devicePixelRatio: 1\n            }\n          }\n        });\n\n        if (!this.isPicking) {\n          // IsDirty refers to the normal fbo, not the picking fbo.\n          // Only mark it as not dirty if the normal fbo was updated.\n          terrainCover.isDirty = false;\n        }\n      }\n    } catch (err) {\n      terrainLayer.raiseError(err as Error, `Error rendering terrain cover ${terrainCover.id}`);\n    }\n  }\n\n  private _pruneTerrainCovers() {\n    /** Prune the cache, remove textures for layers that have been removed */\n    const idsToRemove: string[] = [];\n    for (const [id, terrainCover] of this.terrainCovers) {\n      if (!terrainCover.isActive) {\n        idsToRemove.push(id);\n      }\n    }\n    for (const id of idsToRemove) {\n      this.terrainCovers.delete(id);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}