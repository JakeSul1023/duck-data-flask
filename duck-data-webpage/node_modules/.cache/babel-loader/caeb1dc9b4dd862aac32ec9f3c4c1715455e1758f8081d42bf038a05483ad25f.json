{"ast":null,"code":"// The MIT License (MIT)\n//\n// Copyright (c) 2016 Zhipeng Jia\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n'use strict';\n\nvar WORD_MASK = [0, 0xff, 0xffff, 0xffffff, 0xffffffff];\nfunction copyBytes(fromArray, fromPos, toArray, toPos, length) {\n  var i;\n  for (i = 0; i < length; i++) {\n    toArray[toPos + i] = fromArray[fromPos + i];\n  }\n}\nfunction selfCopyBytes(array, pos, offset, length) {\n  var i;\n  for (i = 0; i < length; i++) {\n    array[pos + i] = array[pos - offset + i];\n  }\n}\nfunction SnappyDecompressor(compressed) {\n  this.array = compressed;\n  this.pos = 0;\n}\nSnappyDecompressor.prototype.readUncompressedLength = function () {\n  var result = 0;\n  var shift = 0;\n  var c, val;\n  while (shift < 32 && this.pos < this.array.length) {\n    c = this.array[this.pos];\n    this.pos += 1;\n    val = c & 0x7f;\n    if (val << shift >>> shift !== val) {\n      return -1;\n    }\n    result |= val << shift;\n    if (c < 128) {\n      return result;\n    }\n    shift += 7;\n  }\n  return -1;\n};\nSnappyDecompressor.prototype.uncompressToBuffer = function (outBuffer) {\n  var array = this.array;\n  var arrayLength = array.length;\n  var pos = this.pos;\n  var outPos = 0;\n  var c, len, smallLen;\n  var offset;\n  while (pos < array.length) {\n    c = array[pos];\n    pos += 1;\n    if ((c & 0x3) === 0) {\n      // Literal\n      len = (c >>> 2) + 1;\n      if (len > 60) {\n        if (pos + 3 >= arrayLength) {\n          return false;\n        }\n        smallLen = len - 60;\n        len = array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);\n        len = (len & WORD_MASK[smallLen]) + 1;\n        pos += smallLen;\n      }\n      if (pos + len > arrayLength) {\n        return false;\n      }\n      copyBytes(array, pos, outBuffer, outPos, len);\n      pos += len;\n      outPos += len;\n    } else {\n      switch (c & 0x3) {\n        case 1:\n          len = (c >>> 2 & 0x7) + 4;\n          offset = array[pos] + (c >>> 5 << 8);\n          pos += 1;\n          break;\n        case 2:\n          if (pos + 1 >= arrayLength) {\n            return false;\n          }\n          len = (c >>> 2) + 1;\n          offset = array[pos] + (array[pos + 1] << 8);\n          pos += 2;\n          break;\n        case 3:\n          if (pos + 3 >= arrayLength) {\n            return false;\n          }\n          len = (c >>> 2) + 1;\n          offset = array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);\n          pos += 4;\n          break;\n        default:\n          break;\n      }\n      if (offset === 0 || offset > outPos) {\n        return false;\n      }\n      selfCopyBytes(outBuffer, outPos, offset, len);\n      outPos += len;\n    }\n  }\n  return true;\n};\nexports.SnappyDecompressor = SnappyDecompressor;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}