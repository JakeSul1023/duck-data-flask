{"ast":null,"code":"// WebGL2 Query (also handles disjoint timer extensions)\nimport { QuerySet } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\n/**\n * Asynchronous queries for different kinds of information\n */\nexport class WEBGLQuerySet extends QuerySet {\n  device;\n  handle;\n  target = null;\n  _queryPending = false;\n  _pollingPromise = null;\n  get [Symbol.toStringTag]() {\n    return 'Query';\n  }\n  // Create a query class\n  constructor(device, props) {\n    super(device, props);\n    this.device = device;\n    if (props.count > 1) {\n      throw new Error('WebGL QuerySet can only have one value');\n    }\n    this.handle = this.device.gl.createQuery();\n    Object.seal(this);\n  }\n  destroy() {\n    this.device.gl.deleteQuery(this.handle);\n  }\n  // FOR RENDER PASS AND COMMAND ENCODER\n  /**\n   * Shortcut for timer query (dependent on extension in both WebGL1 and 2)\n   * Measures GPU time delta between this call and a matching `end` call in the\n   * GPU instruction stream.\n   */\n  beginTimestampQuery() {\n    return this._begin(35007);\n  }\n  endTimestampQuery() {\n    this._end();\n  }\n  // Shortcut for occlusion queries\n  beginOcclusionQuery(options) {\n    return this._begin(options?.conservative ? 36202 : 35887);\n  }\n  endOcclusionQuery() {\n    this._end();\n  }\n  // Shortcut for transformFeedbackQuery\n  beginTransformFeedbackQuery() {\n    return this._begin(35976);\n  }\n  endTransformFeedbackQuery() {\n    this._end();\n  }\n  async resolveQuery() {\n    const value = await this.pollQuery();\n    return [value];\n  }\n  // PRIVATE METHODS\n  /**\n   * Due to OpenGL API limitations, after calling `begin()` on one Query\n   * instance, `end()` must be called on that same instance before\n   * calling `begin()` on another query. While there can be multiple\n   * outstanding queries representing disjoint `begin()`/`end()` intervals.\n   * It is not possible to interleave or overlap `begin` and `end` calls.\n   */\n  _begin(target) {\n    // Don't start a new query if one is already active.\n    if (this._queryPending) {\n      return;\n    }\n    this.target = target;\n    this.device.gl.beginQuery(this.target, this.handle);\n    return;\n  }\n  // ends the current query\n  _end() {\n    // Can't end a new query if the last one hasn't been resolved.\n    if (this._queryPending) {\n      return;\n    }\n    if (this.target) {\n      this.device.gl.endQuery(this.target);\n      this.target = null;\n      this._queryPending = true;\n    }\n    return;\n  }\n  // Returns true if the query result is available\n  isResultAvailable() {\n    if (!this._queryPending) {\n      return false;\n    }\n    const resultAvailable = this.device.gl.getQueryParameter(this.handle, 34919);\n    if (resultAvailable) {\n      this._queryPending = false;\n    }\n    return resultAvailable;\n  }\n  // Timing query is disjoint, i.e. results are invalid\n  isTimerDisjoint() {\n    return this.device.gl.getParameter(36795);\n  }\n  // Returns query result.\n  getResult() {\n    return this.device.gl.getQueryParameter(this.handle, 34918);\n  }\n  // Returns the query result, converted to milliseconds to match JavaScript conventions.\n  getTimerMilliseconds() {\n    return this.getResult() / 1e6;\n  }\n  // Polls the query\n  pollQuery(limit = Number.POSITIVE_INFINITY) {\n    if (this._pollingPromise) {\n      return this._pollingPromise;\n    }\n    let counter = 0;\n    this._pollingPromise = new Promise((resolve, reject) => {\n      const poll = () => {\n        if (this.isResultAvailable()) {\n          resolve(this.getResult());\n          this._pollingPromise = null;\n        } else if (counter++ > limit) {\n          reject('Timed out');\n          this._pollingPromise = null;\n        } else {\n          requestAnimationFrame(poll);\n        }\n      };\n      requestAnimationFrame(poll);\n    });\n    return this._pollingPromise;\n  }\n}","map":{"version":3,"names":["QuerySet","GL","WEBGLQuerySet","device","handle","target","_queryPending","_pollingPromise","Symbol","toStringTag","constructor","props","count","Error","gl","createQuery","Object","seal","destroy","deleteQuery","beginTimestampQuery","_begin","endTimestampQuery","_end","beginOcclusionQuery","options","conservative","endOcclusionQuery","beginTransformFeedbackQuery","endTransformFeedbackQuery","resolveQuery","value","pollQuery","beginQuery","endQuery","isResultAvailable","resultAvailable","getQueryParameter","isTimerDisjoint","getParameter","getResult","getTimerMilliseconds","limit","Number","POSITIVE_INFINITY","counter","Promise","resolve","reject","poll","requestAnimationFrame"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\webgl\\src\\adapter\\resources\\webgl-query-set.ts"],"sourcesContent":["// WebGL2 Query (also handles disjoint timer extensions)\nimport {QuerySet, QuerySetProps} from '@luma.gl/core';\nimport {GL} from '@luma.gl/constants';\nimport {WebGLDevice} from '../webgl-device';\n\n/**\n * Asynchronous queries for different kinds of information\n */\nexport class WEBGLQuerySet extends QuerySet {\n  device: WebGLDevice;\n  handle: WebGLQuery;\n\n  target: number | null = null;\n  _queryPending = false;\n  _pollingPromise: Promise<any> | null = null;\n\n  override get [Symbol.toStringTag](): string {\n    return 'Query';\n  }\n\n  // Create a query class\n  constructor(device: WebGLDevice, props: QuerySetProps) {\n    super(device, props);\n    this.device = device;\n\n    if (props.count > 1) {\n      throw new Error('WebGL QuerySet can only have one value');\n    }\n\n    this.handle = this.device.gl.createQuery();\n    Object.seal(this);\n  }\n\n  override destroy() {\n    this.device.gl.deleteQuery(this.handle);\n  }\n\n  // FOR RENDER PASS AND COMMAND ENCODER\n\n  /**\n   * Shortcut for timer query (dependent on extension in both WebGL1 and 2)\n   * Measures GPU time delta between this call and a matching `end` call in the\n   * GPU instruction stream.\n   */\n  beginTimestampQuery(): void {\n    return this._begin(GL.TIME_ELAPSED_EXT);\n  }\n\n  endTimestampQuery(): void {\n    this._end();\n  }\n\n  // Shortcut for occlusion queries\n  beginOcclusionQuery(options?: {conservative?: boolean}): void {\n    return this._begin(\n      options?.conservative ? GL.ANY_SAMPLES_PASSED_CONSERVATIVE : GL.ANY_SAMPLES_PASSED\n    );\n  }\n\n  endOcclusionQuery() {\n    this._end();\n  }\n\n  // Shortcut for transformFeedbackQuery\n  beginTransformFeedbackQuery(): void {\n    return this._begin(GL.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);\n  }\n\n  endTransformFeedbackQuery(): void {\n    this._end();\n  }\n\n  async resolveQuery(): Promise<bigint[]> {\n    const value = await this.pollQuery();\n    return [value];\n  }\n\n  // PRIVATE METHODS\n\n  /**\n   * Due to OpenGL API limitations, after calling `begin()` on one Query\n   * instance, `end()` must be called on that same instance before\n   * calling `begin()` on another query. While there can be multiple\n   * outstanding queries representing disjoint `begin()`/`end()` intervals.\n   * It is not possible to interleave or overlap `begin` and `end` calls.\n   */\n  protected _begin(target: number): void {\n    // Don't start a new query if one is already active.\n    if (this._queryPending) {\n      return;\n    }\n\n    this.target = target;\n    this.device.gl.beginQuery(this.target, this.handle);\n\n    return;\n  }\n\n  // ends the current query\n  protected _end(): void {\n    // Can't end a new query if the last one hasn't been resolved.\n    if (this._queryPending) {\n      return;\n    }\n\n    if (this.target) {\n      this.device.gl.endQuery(this.target);\n      this.target = null;\n      this._queryPending = true;\n    }\n    return;\n  }\n\n  // Returns true if the query result is available\n  isResultAvailable(): boolean {\n    if (!this._queryPending) {\n      return false;\n    }\n\n    const resultAvailable = this.device.gl.getQueryParameter(\n      this.handle,\n      GL.QUERY_RESULT_AVAILABLE\n    );\n    if (resultAvailable) {\n      this._queryPending = false;\n    }\n    return resultAvailable;\n  }\n\n  // Timing query is disjoint, i.e. results are invalid\n  isTimerDisjoint(): boolean {\n    return this.device.gl.getParameter(GL.GPU_DISJOINT_EXT);\n  }\n\n  // Returns query result.\n  getResult(): any {\n    return this.device.gl.getQueryParameter(this.handle, GL.QUERY_RESULT);\n  }\n\n  // Returns the query result, converted to milliseconds to match JavaScript conventions.\n  getTimerMilliseconds() {\n    return this.getResult() / 1e6;\n  }\n\n  // Polls the query\n  pollQuery(limit: number = Number.POSITIVE_INFINITY): Promise<any> {\n    if (this._pollingPromise) {\n      return this._pollingPromise;\n    }\n\n    let counter = 0;\n\n    this._pollingPromise = new Promise((resolve, reject) => {\n      const poll = () => {\n        if (this.isResultAvailable()) {\n          resolve(this.getResult());\n          this._pollingPromise = null;\n        } else if (counter++ > limit) {\n          reject('Timed out');\n          this._pollingPromise = null;\n        } else {\n          requestAnimationFrame(poll);\n        }\n      };\n\n      requestAnimationFrame(poll);\n    });\n\n    return this._pollingPromise;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}