{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst FS_GLES = /* glsl */`\\\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}`;\nconst FS300 = `#version 300 es\\n${FS_GLES}`;\n// Prase given glsl line and return qualifier details or null\nexport function getQualifierDetails(line, qualifiers) {\n  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];\n  const words = line.replace(/^\\s+/, '').split(/\\s+/);\n  // TODO add support for precession qualifiers (highp, mediump and lowp)\n  const [qualifier, type, definition] = words;\n  if (!qualifiers.includes(qualifier) || !type || !definition) {\n    return null;\n  }\n  const name = definition.split(';')[0];\n  return {\n    qualifier,\n    type,\n    name\n  };\n}\n/**\n * Given the shader input and output variable names,\n * builds and return a pass through fragment shader.\n */\nexport function getPassthroughFS(options) {\n  const {\n    input,\n    inputChannels,\n    output\n  } = options || {};\n  if (!input) {\n    // Default shader\n    return FS300;\n  }\n  if (!inputChannels) {\n    throw new Error('inputChannels');\n  }\n  const inputType = channelCountToType(inputChannels);\n  const outputValue = convertToVec4(input, inputChannels);\n  return `\\\n#version 300 es\nin ${inputType} ${input};\nout vec4 ${output};\nvoid main() {\n  ${output} = ${outputValue};\n}`;\n}\n/** convert glsl type to suffix */\nexport function typeToChannelSuffix(type) {\n  // prettier-ignore\n  switch (type) {\n    case 'float':\n      return 'x';\n    case 'vec2':\n      return 'xy';\n    case 'vec3':\n      return 'xyz';\n    case 'vec4':\n      return 'xyzw';\n    default:\n      throw new Error(type);\n  }\n}\n/** convert glsl type to channel count */\nexport function typeToChannelCount(type) {\n  // prettier-ignore\n  switch (type) {\n    case 'float':\n      return 1;\n    case 'vec2':\n      return 2;\n    case 'vec3':\n      return 3;\n    case 'vec4':\n      return 4;\n    default:\n      throw new Error(type);\n  }\n}\nfunction channelCountToType(channels) {\n  // prettier-ignore\n  switch (channels) {\n    case 1:\n      return 'float';\n    case 2:\n      return 'vec2';\n    case 3:\n      return 'vec3';\n    case 4:\n      return 'vec4';\n    default:\n      throw new Error(`invalid channels: ${channels}`);\n  }\n}\n/** Returns glsl instruction for converting to vec4 */\nexport function convertToVec4(variable, channels) {\n  // prettier-ignore\n  switch (channels) {\n    case 1:\n      return `vec4(${variable}, 0.0, 0.0, 1.0)`;\n    case 2:\n      return `vec4(${variable}, 0.0, 1.0)`;\n    case 3:\n      return `vec4(${variable}, 1.0)`;\n    case 4:\n      return variable;\n    default:\n      throw new Error(`invalid channels: ${channels}`);\n  }\n}","map":{"version":3,"names":["FS_GLES","FS300","getQualifierDetails","line","qualifiers","Array","isArray","words","replace","split","qualifier","type","definition","includes","name","getPassthroughFS","options","input","inputChannels","output","Error","inputType","channelCountToType","outputValue","convertToVec4","typeToChannelSuffix","typeToChannelCount","channels","variable"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\shadertools\\src\\lib\\glsl-utils\\shader-utils.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nconst FS_GLES = /* glsl */ `\\\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}`;\nconst FS300 = `#version 300 es\\n${FS_GLES}`;\n\ntype QualifierInfo = {\n  qualifier: string;\n  type: string;\n  name: string;\n};\n\n// Prase given glsl line and return qualifier details or null\nexport function getQualifierDetails(\n  line: string,\n  qualifiers: string | string[]\n): QualifierInfo | null {\n  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];\n  const words = line.replace(/^\\s+/, '').split(/\\s+/);\n  // TODO add support for precession qualifiers (highp, mediump and lowp)\n  const [qualifier, type, definition] = words;\n  if (!qualifiers.includes(qualifier) || !type || !definition) {\n    return null;\n  }\n  const name = definition.split(';')[0];\n  return {qualifier, type, name};\n}\n\n/**\n * Given the shader input and output variable names,\n * builds and return a pass through fragment shader.\n */\nexport function getPassthroughFS(options?: {\n  input?: string;\n  inputChannels?: 1 | 2 | 3 | 4;\n  output?: string;\n}): string {\n  const {input, inputChannels, output} = options || {};\n  if (!input) {\n    // Default shader\n    return FS300;\n  }\n  if (!inputChannels) {\n    throw new Error('inputChannels');\n  }\n  const inputType = channelCountToType(inputChannels);\n  const outputValue = convertToVec4(input, inputChannels);\n  return `\\\n#version 300 es\nin ${inputType} ${input};\nout vec4 ${output};\nvoid main() {\n  ${output} = ${outputValue};\n}`;\n}\n\n/** convert glsl type to suffix */\nexport function typeToChannelSuffix(type: string): 'x' | 'xy' | 'xyz' | 'xyzw' {\n  // prettier-ignore\n  switch (type) {\n    case 'float': return 'x';\n    case 'vec2': return 'xy';\n    case 'vec3': return 'xyz';\n    case 'vec4': return 'xyzw';\n    default:\n      throw new Error(type);\n  }\n}\n\n/** convert glsl type to channel count */\nexport function typeToChannelCount(type: string): 1 | 2 | 3 | 4 {\n  // prettier-ignore\n  switch (type) {\n    case 'float': return 1;\n    case 'vec2': return 2;\n    case 'vec3': return 3;\n    case 'vec4': return 4;\n    default:\n      throw new Error(type);\n  }\n}\nfunction channelCountToType(channels: 1 | 2 | 3 | 4): 'float' | 'vec2' | 'vec3' | 'vec4' {\n  // prettier-ignore\n  switch (channels) {\n    case 1: return 'float';\n    case 2: return 'vec2';\n    case 3: return 'vec3';\n    case 4: return 'vec4';\n    default:\n      throw new Error(`invalid channels: ${channels}`);\n  }\n}\n\n/** Returns glsl instruction for converting to vec4 */\nexport function convertToVec4(variable: string, channels: 1 | 2 | 3 | 4): string {\n  // prettier-ignore\n  switch (channels) {\n    case 1: return `vec4(${variable}, 0.0, 0.0, 1.0)`;\n    case 2: return `vec4(${variable}, 0.0, 1.0)`;\n    case 3: return `vec4(${variable}, 1.0)`;\n    case 4: return variable;\n    default:\n      throw new Error(`invalid channels: ${channels}`);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}