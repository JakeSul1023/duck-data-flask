{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { GL } from '@luma.gl/constants';\nimport { decodeGLUniformType, decodeGLAttributeType, isSamplerUniform } from \"./decode-webgl-types.js\";\n/**\n * Extract metadata describing binding information for a program's shaders\n * Note: `linkProgram()` needs to have been called\n * (although linking does not need to have been successful).\n */\nexport function getShaderLayoutFromGLSL(gl, program) {\n  const shaderLayout = {\n    attributes: [],\n    bindings: []\n  };\n  shaderLayout.attributes = readAttributeDeclarations(gl, program);\n  // Uniform blocks\n  const uniformBlocks = readUniformBlocks(gl, program);\n  for (const uniformBlock of uniformBlocks) {\n    const uniforms = uniformBlock.uniforms.map(uniform => ({\n      name: uniform.name,\n      format: uniform.format,\n      byteOffset: uniform.byteOffset,\n      byteStride: uniform.byteStride,\n      arrayLength: uniform.arrayLength\n    }));\n    shaderLayout.bindings.push({\n      type: 'uniform',\n      name: uniformBlock.name,\n      group: 0,\n      location: uniformBlock.location,\n      visibility: (uniformBlock.vertex ? 0x1 : 0) & (uniformBlock.fragment ? 0x2 : 0),\n      minBindingSize: uniformBlock.byteLength,\n      uniforms\n    });\n  }\n  const uniforms = readUniformBindings(gl, program);\n  let textureUnit = 0;\n  for (const uniform of uniforms) {\n    if (isSamplerUniform(uniform.type)) {\n      const {\n        viewDimension,\n        sampleType\n      } = getSamplerInfo(uniform.type);\n      shaderLayout.bindings.push({\n        type: 'texture',\n        name: uniform.name,\n        group: 0,\n        location: textureUnit,\n        viewDimension,\n        sampleType\n      });\n      // @ts-expect-error\n      uniform.textureUnit = textureUnit;\n      textureUnit += 1;\n    }\n  }\n  if (uniforms.length) {\n    shaderLayout.uniforms = uniforms;\n  }\n  // Varyings\n  const varyings = readVaryings(gl, program);\n  // Note - samplers are always in unform bindings, even if uniform blocks are used\n  if (varyings?.length) {\n    shaderLayout.varyings = varyings;\n  }\n  return shaderLayout;\n}\n// HELPERS\n/**\n * Extract info about all transform feedback varyings\n *\n * linkProgram needs to have been called, although linking does not need to have been successful\n */\nfunction readAttributeDeclarations(gl, program) {\n  const attributes = [];\n  const count = gl.getProgramParameter(program, 35721);\n  for (let index = 0; index < count; index++) {\n    const activeInfo = gl.getActiveAttrib(program, index);\n    if (!activeInfo) {\n      throw new Error('activeInfo');\n    }\n    const {\n      name,\n      type: compositeType /* , size*/\n    } = activeInfo;\n    const location = gl.getAttribLocation(program, name);\n    // Add only user provided attributes, for built-in attributes like `gl_InstanceID` location will be < 0\n    if (location >= 0) {\n      const {\n        attributeType\n      } = decodeGLAttributeType(compositeType);\n      // Whether an attribute is instanced is essentially fixed by the structure of the shader code,\n      // so it is arguably a static property of the shader.\n      // There is no hint in the shader declarations\n      // Heuristic: Any attribute name containing the word \"instance\" will be assumed to be instanced\n      const stepMode = /instance/i.test(name) ? 'instance' : 'vertex';\n      attributes.push({\n        name,\n        location,\n        stepMode,\n        type: attributeType\n        // size - for arrays, size is the number of elements in the array\n      });\n    }\n  }\n  // Sort by declaration order\n  attributes.sort((a, b) => a.location - b.location);\n  return attributes;\n}\n/**\n * Extract info about all transform feedback varyings\n *\n * linkProgram needs to have been called, although linking does not need to have been successful\n */\nfunction readVaryings(gl, program) {\n  const varyings = [];\n  const count = gl.getProgramParameter(program, 35971);\n  for (let location = 0; location < count; location++) {\n    const activeInfo = gl.getTransformFeedbackVarying(program, location);\n    if (!activeInfo) {\n      throw new Error('activeInfo');\n    }\n    const {\n      name,\n      type: compositeType,\n      size\n    } = activeInfo;\n    const {\n      glType,\n      components\n    } = decodeGLUniformType(compositeType);\n    const varying = {\n      location,\n      name,\n      type: glType,\n      size: size * components\n    }; // Base values\n    varyings.push(varying);\n  }\n  varyings.sort((a, b) => a.location - b.location);\n  return varyings;\n}\n/**\n * Extract info about all uniforms\n *\n * Query uniform locations and build name to setter map.\n */\nfunction readUniformBindings(gl, program) {\n  const uniforms = [];\n  const uniformCount = gl.getProgramParameter(program, 35718);\n  for (let i = 0; i < uniformCount; i++) {\n    const activeInfo = gl.getActiveUniform(program, i);\n    if (!activeInfo) {\n      throw new Error('activeInfo');\n    }\n    const {\n      name: rawName,\n      size,\n      type\n    } = activeInfo;\n    const {\n      name,\n      isArray\n    } = parseUniformName(rawName);\n    let webglLocation = gl.getUniformLocation(program, name);\n    const uniformInfo = {\n      // WebGL locations are uniquely typed but just numbers\n      location: webglLocation,\n      name,\n      size,\n      type,\n      isArray\n    };\n    uniforms.push(uniformInfo);\n    // Array (e.g. matrix) uniforms can occupy several 4x4 byte banks\n    if (uniformInfo.size > 1) {\n      for (let j = 0; j < uniformInfo.size; j++) {\n        const elementName = `${name}[${j}]`;\n        webglLocation = gl.getUniformLocation(program, elementName);\n        const arrayElementUniformInfo = {\n          ...uniformInfo,\n          name: elementName,\n          location: webglLocation\n        };\n        uniforms.push(arrayElementUniformInfo);\n      }\n    }\n  }\n  return uniforms;\n}\n/**\n * Extract info about all \"active\" uniform blocks\n * @note In WebGL, \"active\" just means that unused (inactive) blocks may have been optimized away during linking)\n */\nfunction readUniformBlocks(gl, program) {\n  const getBlockParameter = (blockIndex, pname) => gl.getActiveUniformBlockParameter(program, blockIndex, pname);\n  const uniformBlocks = [];\n  const blockCount = gl.getProgramParameter(program, 35382);\n  for (let blockIndex = 0; blockIndex < blockCount; blockIndex++) {\n    const blockInfo = {\n      name: gl.getActiveUniformBlockName(program, blockIndex) || '',\n      location: getBlockParameter(blockIndex, 35391),\n      byteLength: getBlockParameter(blockIndex, 35392),\n      vertex: getBlockParameter(blockIndex, 35396),\n      fragment: getBlockParameter(blockIndex, 35398),\n      uniformCount: getBlockParameter(blockIndex, 35394),\n      uniforms: []\n    };\n    const uniformIndices = getBlockParameter(blockIndex, 35395) || [];\n    const uniformType = gl.getActiveUniforms(program, uniformIndices, 35383); // Array of GLenum indicating the types of the uniforms.\n    const uniformArrayLength = gl.getActiveUniforms(program, uniformIndices, 35384); // Array of GLuint indicating the sizes of the uniforms.\n    // const uniformBlockIndex = gl.getActiveUniforms(\n    //   program,\n    //   uniformIndices,\n    //   GL.UNIFORM_BLOCK_INDEX\n    // ); // Array of GLint indicating the block indices of the uniforms.\n    const uniformOffset = gl.getActiveUniforms(program, uniformIndices, 35387); // Array of GLint indicating the uniform buffer offsets.\n    const uniformStride = gl.getActiveUniforms(program, uniformIndices, 35388); // Array of GLint indicating the strides between the elements.\n    // const uniformMatrixStride = gl.getActiveUniforms(\n    //   program,\n    //   uniformIndices,\n    //   GL.UNIFORM_MATRIX_STRIDE\n    // ); // Array of GLint indicating the strides between columns of a column-major matrix or a row-major matrix.\n    // const uniformRowMajor = gl.getActiveUniforms(program, uniformIndices, GL.UNIFORM_IS_ROW_MAJOR);\n    for (let i = 0; i < blockInfo.uniformCount; ++i) {\n      const activeInfo = gl.getActiveUniform(program, uniformIndices[i]);\n      if (!activeInfo) {\n        throw new Error('activeInfo');\n      }\n      blockInfo.uniforms.push({\n        name: activeInfo.name,\n        format: decodeGLUniformType(uniformType[i]).format,\n        type: uniformType[i],\n        arrayLength: uniformArrayLength[i],\n        byteOffset: uniformOffset[i],\n        byteStride: uniformStride[i]\n        // matrixStride: uniformStride[i],\n        // rowMajor: uniformRowMajor[i]\n      });\n    }\n    uniformBlocks.push(blockInfo);\n  }\n  uniformBlocks.sort((a, b) => a.location - b.location);\n  return uniformBlocks;\n}\n/**\n * TOOD - compare with a above, confirm copy, then delete\n  const bindings: Binding[] = [];\n  const count = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);\n  for (let blockIndex = 0; blockIndex < count; blockIndex++) {\n    const vertex = gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),\n    const fragment = gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),\n    const visibility = (vertex) + (fragment);\n    const binding: BufferBinding = {\n      location: gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_BINDING),\n      // name: gl.getActiveUniformBlockName(program, blockIndex),\n      type: 'uniform',\n      visibility,\n      minBindingSize: gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_DATA_SIZE),\n      // uniformCount: gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_ACTIVE_UNIFORMS),\n      // uniformIndices: gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES),\n    }\n    bindings.push(binding);\n  }\n*/\nconst SAMPLER_UNIFORMS_GL_TO_GPU = {\n  [35678]: ['2d', 'float'],\n  [35680]: ['cube', 'float'],\n  [35679]: ['3d', 'float'],\n  [35682]: ['3d', 'depth'],\n  [36289]: ['2d-array', 'float'],\n  [36292]: ['2d-array', 'depth'],\n  [36293]: ['cube', 'float'],\n  [36298]: ['2d', 'sint'],\n  [36299]: ['3d', 'sint'],\n  [36300]: ['cube', 'sint'],\n  [36303]: ['2d-array', 'uint'],\n  [36306]: ['2d', 'uint'],\n  [36307]: ['3d', 'uint'],\n  [36308]: ['cube', 'uint'],\n  [36311]: ['2d-array', 'uint']\n};\nfunction getSamplerInfo(type) {\n  const sampler = SAMPLER_UNIFORMS_GL_TO_GPU[type];\n  if (!sampler) {\n    throw new Error('sampler');\n  }\n  const [viewDimension, sampleType] = sampler;\n  return {\n    viewDimension,\n    sampleType\n  };\n}\n// HELPERS\nfunction parseUniformName(name) {\n  // Shortcut to avoid redundant or bad matches\n  if (name[name.length - 1] !== ']') {\n    return {\n      name,\n      length: 1,\n      isArray: false\n    };\n  }\n  // if array name then clean the array brackets\n  const UNIFORM_NAME_REGEXP = /([^[]*)(\\[[0-9]+\\])?/;\n  const matches = UNIFORM_NAME_REGEXP.exec(name);\n  if (!matches || matches.length < 2) {\n    throw new Error(`Failed to parse GLSL uniform name ${name}`);\n  }\n  return {\n    name: matches[1],\n    length: matches[2] ? 1 : 0,\n    isArray: Boolean(matches[2])\n  };\n}","map":{"version":3,"names":["GL","decodeGLUniformType","decodeGLAttributeType","isSamplerUniform","getShaderLayoutFromGLSL","gl","program","shaderLayout","attributes","bindings","readAttributeDeclarations","uniformBlocks","readUniformBlocks","uniformBlock","uniforms","map","uniform","name","format","byteOffset","byteStride","arrayLength","push","type","group","location","visibility","vertex","fragment","minBindingSize","byteLength","readUniformBindings","textureUnit","viewDimension","sampleType","getSamplerInfo","length","varyings","readVaryings","count","getProgramParameter","index","activeInfo","getActiveAttrib","Error","compositeType","getAttribLocation","attributeType","stepMode","test","sort","a","b","getTransformFeedbackVarying","size","glType","components","varying","uniformCount","i","getActiveUniform","rawName","isArray","parseUniformName","webglLocation","getUniformLocation","uniformInfo","j","elementName","arrayElementUniformInfo","getBlockParameter","blockIndex","pname","getActiveUniformBlockParameter","blockCount","blockInfo","getActiveUniformBlockName","uniformIndices","uniformType","getActiveUniforms","uniformArrayLength","uniformOffset","uniformStride","SAMPLER_UNIFORMS_GL_TO_GPU","sampler","UNIFORM_NAME_REGEXP","matches","exec","Boolean"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\webgl\\src\\adapter\\helpers\\get-shader-layout.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {\n  ShaderLayout,\n  UniformBinding,\n  UniformBlockBinding,\n  AttributeDeclaration,\n  VaryingBinding\n} from '@luma.gl/core';\n\nimport {GL} from '@luma.gl/constants';\nimport {decodeGLUniformType, decodeGLAttributeType, isSamplerUniform} from './decode-webgl-types';\n\n/**\n * Extract metadata describing binding information for a program's shaders\n * Note: `linkProgram()` needs to have been called\n * (although linking does not need to have been successful).\n */\nexport function getShaderLayoutFromGLSL(\n  gl: WebGL2RenderingContext,\n  program: WebGLProgram\n): ShaderLayout {\n  const shaderLayout: ShaderLayout = {\n    attributes: [],\n    bindings: []\n  };\n\n  shaderLayout.attributes = readAttributeDeclarations(gl, program);\n\n  // Uniform blocks\n  const uniformBlocks: UniformBlockBinding[] = readUniformBlocks(gl, program);\n  for (const uniformBlock of uniformBlocks) {\n    const uniforms = uniformBlock.uniforms.map(uniform => ({\n      name: uniform.name,\n      format: uniform.format,\n      byteOffset: uniform.byteOffset,\n      byteStride: uniform.byteStride,\n      arrayLength: uniform.arrayLength\n    }));\n    shaderLayout.bindings.push({\n      type: 'uniform',\n      name: uniformBlock.name,\n      group: 0,\n      location: uniformBlock.location,\n      visibility: (uniformBlock.vertex ? 0x1 : 0) & (uniformBlock.fragment ? 0x2 : 0),\n      minBindingSize: uniformBlock.byteLength,\n      uniforms\n    });\n  }\n\n  const uniforms: UniformBinding[] = readUniformBindings(gl, program);\n  let textureUnit = 0;\n  for (const uniform of uniforms) {\n    if (isSamplerUniform(uniform.type)) {\n      const {viewDimension, sampleType} = getSamplerInfo(uniform.type);\n      shaderLayout.bindings.push({\n        type: 'texture',\n        name: uniform.name,\n        group: 0,\n        location: textureUnit,\n        viewDimension,\n        sampleType\n      });\n\n      // @ts-expect-error\n      uniform.textureUnit = textureUnit;\n      textureUnit += 1;\n    }\n  }\n\n  if (uniforms.length) {\n    shaderLayout.uniforms = uniforms;\n  }\n\n  // Varyings\n  const varyings: VaryingBinding[] = readVaryings(gl, program);\n  // Note - samplers are always in unform bindings, even if uniform blocks are used\n  if (varyings?.length) {\n    shaderLayout.varyings = varyings;\n  }\n\n  return shaderLayout;\n}\n\n// HELPERS\n\n/**\n * Extract info about all transform feedback varyings\n *\n * linkProgram needs to have been called, although linking does not need to have been successful\n */\nfunction readAttributeDeclarations(\n  gl: WebGL2RenderingContext,\n  program: WebGLProgram\n): AttributeDeclaration[] {\n  const attributes: AttributeDeclaration[] = [];\n\n  const count = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\n  for (let index = 0; index < count; index++) {\n    const activeInfo = gl.getActiveAttrib(program, index);\n    if (!activeInfo) {\n      throw new Error('activeInfo');\n    }\n    const {name, type: compositeType /* , size*/} = activeInfo;\n    const location = gl.getAttribLocation(program, name);\n    // Add only user provided attributes, for built-in attributes like `gl_InstanceID` location will be < 0\n    if (location >= 0) {\n      const {attributeType} = decodeGLAttributeType(compositeType);\n\n      // Whether an attribute is instanced is essentially fixed by the structure of the shader code,\n      // so it is arguably a static property of the shader.\n      // There is no hint in the shader declarations\n      // Heuristic: Any attribute name containing the word \"instance\" will be assumed to be instanced\n      const stepMode = /instance/i.test(name) ? 'instance' : 'vertex';\n\n      attributes.push({\n        name,\n        location,\n        stepMode,\n        type: attributeType\n        // size - for arrays, size is the number of elements in the array\n      });\n    }\n  }\n\n  // Sort by declaration order\n  attributes.sort((a: AttributeDeclaration, b: AttributeDeclaration) => a.location - b.location);\n  return attributes;\n}\n\n/**\n * Extract info about all transform feedback varyings\n *\n * linkProgram needs to have been called, although linking does not need to have been successful\n */\nfunction readVaryings(gl: WebGL2RenderingContext, program: WebGLProgram): VaryingBinding[] {\n  const varyings: VaryingBinding[] = [];\n\n  const count = gl.getProgramParameter(program, GL.TRANSFORM_FEEDBACK_VARYINGS);\n  for (let location = 0; location < count; location++) {\n    const activeInfo = gl.getTransformFeedbackVarying(program, location);\n    if (!activeInfo) {\n      throw new Error('activeInfo');\n    }\n    const {name, type: compositeType, size} = activeInfo;\n    const {glType, components} = decodeGLUniformType(compositeType);\n    const varying = {location, name, type: glType, size: size * components}; // Base values\n    varyings.push(varying);\n  }\n\n  varyings.sort((a, b) => a.location - b.location);\n  return varyings;\n}\n\n/**\n * Extract info about all uniforms\n *\n * Query uniform locations and build name to setter map.\n */\nfunction readUniformBindings(gl: WebGL2RenderingContext, program: WebGLProgram): UniformBinding[] {\n  const uniforms: UniformBinding[] = [];\n\n  const uniformCount = gl.getProgramParameter(program, GL.ACTIVE_UNIFORMS);\n  for (let i = 0; i < uniformCount; i++) {\n    const activeInfo = gl.getActiveUniform(program, i);\n    if (!activeInfo) {\n      throw new Error('activeInfo');\n    }\n    const {name: rawName, size, type} = activeInfo;\n    const {name, isArray} = parseUniformName(rawName);\n    let webglLocation = gl.getUniformLocation(program, name);\n    const uniformInfo = {\n      // WebGL locations are uniquely typed but just numbers\n      location: webglLocation as number,\n      name,\n      size,\n      type,\n      isArray\n    };\n    uniforms.push(uniformInfo);\n\n    // Array (e.g. matrix) uniforms can occupy several 4x4 byte banks\n    if (uniformInfo.size > 1) {\n      for (let j = 0; j < uniformInfo.size; j++) {\n        const elementName = `${name}[${j}]`;\n\n        webglLocation = gl.getUniformLocation(program, elementName);\n\n        const arrayElementUniformInfo = {\n          ...uniformInfo,\n          name: elementName,\n          location: webglLocation as number\n        };\n\n        uniforms.push(arrayElementUniformInfo);\n      }\n    }\n  }\n  return uniforms;\n}\n\n/**\n * Extract info about all \"active\" uniform blocks\n * @note In WebGL, \"active\" just means that unused (inactive) blocks may have been optimized away during linking)\n */\nfunction readUniformBlocks(\n  gl: WebGL2RenderingContext,\n  program: WebGLProgram\n): UniformBlockBinding[] {\n  const getBlockParameter = (blockIndex: number, pname: GL): any =>\n    gl.getActiveUniformBlockParameter(program, blockIndex, pname);\n\n  const uniformBlocks: UniformBlockBinding[] = [];\n\n  const blockCount = gl.getProgramParameter(program, GL.ACTIVE_UNIFORM_BLOCKS);\n  for (let blockIndex = 0; blockIndex < blockCount; blockIndex++) {\n    const blockInfo: UniformBlockBinding = {\n      name: gl.getActiveUniformBlockName(program, blockIndex) || '',\n      location: getBlockParameter(blockIndex, GL.UNIFORM_BLOCK_BINDING),\n      byteLength: getBlockParameter(blockIndex, GL.UNIFORM_BLOCK_DATA_SIZE),\n      vertex: getBlockParameter(blockIndex, GL.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),\n      fragment: getBlockParameter(blockIndex, GL.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),\n      uniformCount: getBlockParameter(blockIndex, GL.UNIFORM_BLOCK_ACTIVE_UNIFORMS),\n      uniforms: [] as any[]\n    };\n\n    const uniformIndices =\n      (getBlockParameter(blockIndex, GL.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES) as number[]) || [];\n\n    const uniformType = gl.getActiveUniforms(program, uniformIndices, GL.UNIFORM_TYPE); // Array of GLenum indicating the types of the uniforms.\n    const uniformArrayLength = gl.getActiveUniforms(program, uniformIndices, GL.UNIFORM_SIZE); // Array of GLuint indicating the sizes of the uniforms.\n    // const uniformBlockIndex = gl.getActiveUniforms(\n    //   program,\n    //   uniformIndices,\n    //   GL.UNIFORM_BLOCK_INDEX\n    // ); // Array of GLint indicating the block indices of the uniforms.\n    const uniformOffset = gl.getActiveUniforms(program, uniformIndices, GL.UNIFORM_OFFSET); // Array of GLint indicating the uniform buffer offsets.\n    const uniformStride = gl.getActiveUniforms(program, uniformIndices, GL.UNIFORM_ARRAY_STRIDE); // Array of GLint indicating the strides between the elements.\n    // const uniformMatrixStride = gl.getActiveUniforms(\n    //   program,\n    //   uniformIndices,\n    //   GL.UNIFORM_MATRIX_STRIDE\n    // ); // Array of GLint indicating the strides between columns of a column-major matrix or a row-major matrix.\n    // const uniformRowMajor = gl.getActiveUniforms(program, uniformIndices, GL.UNIFORM_IS_ROW_MAJOR);\n    for (let i = 0; i < blockInfo.uniformCount; ++i) {\n      const activeInfo = gl.getActiveUniform(program, uniformIndices[i]);\n      if (!activeInfo) {\n        throw new Error('activeInfo');\n      }\n\n      blockInfo.uniforms.push({\n        name: activeInfo.name,\n        format: decodeGLUniformType(uniformType[i]).format,\n        type: uniformType[i],\n        arrayLength: uniformArrayLength[i],\n        byteOffset: uniformOffset[i],\n        byteStride: uniformStride[i]\n        // matrixStride: uniformStride[i],\n        // rowMajor: uniformRowMajor[i]\n      });\n    }\n\n    uniformBlocks.push(blockInfo);\n  }\n\n  uniformBlocks.sort((a, b) => a.location - b.location);\n  return uniformBlocks;\n}\n\n/**\n * TOOD - compare with a above, confirm copy, then delete\n  const bindings: Binding[] = [];\n  const count = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);\n  for (let blockIndex = 0; blockIndex < count; blockIndex++) {\n    const vertex = gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),\n    const fragment = gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),\n    const visibility = (vertex) + (fragment);\n    const binding: BufferBinding = {\n      location: gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_BINDING),\n      // name: gl.getActiveUniformBlockName(program, blockIndex),\n      type: 'uniform',\n      visibility,\n      minBindingSize: gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_DATA_SIZE),\n      // uniformCount: gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_ACTIVE_UNIFORMS),\n      // uniformIndices: gl.getActiveUniformBlockParameter(program, blockIndex, gl.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES),\n    }\n    bindings.push(binding);\n  }\n*/\n\nconst SAMPLER_UNIFORMS_GL_TO_GPU: Record<\n  number,\n  [\n    '1d' | '2d' | '2d-array' | 'cube' | 'cube-array' | '3d',\n    'float' | 'unfilterable-float' | 'depth' | 'sint' | 'uint'\n  ]\n> = {\n  [GL.SAMPLER_2D]: ['2d', 'float'],\n  [GL.SAMPLER_CUBE]: ['cube', 'float'],\n  [GL.SAMPLER_3D]: ['3d', 'float'],\n  [GL.SAMPLER_2D_SHADOW]: ['3d', 'depth'],\n  [GL.SAMPLER_2D_ARRAY]: ['2d-array', 'float'],\n  [GL.SAMPLER_2D_ARRAY_SHADOW]: ['2d-array', 'depth'],\n  [GL.SAMPLER_CUBE_SHADOW]: ['cube', 'float'],\n  [GL.INT_SAMPLER_2D]: ['2d', 'sint'],\n  [GL.INT_SAMPLER_3D]: ['3d', 'sint'],\n  [GL.INT_SAMPLER_CUBE]: ['cube', 'sint'],\n  [GL.INT_SAMPLER_2D_ARRAY]: ['2d-array', 'uint'],\n  [GL.UNSIGNED_INT_SAMPLER_2D]: ['2d', 'uint'],\n  [GL.UNSIGNED_INT_SAMPLER_3D]: ['3d', 'uint'],\n  [GL.UNSIGNED_INT_SAMPLER_CUBE]: ['cube', 'uint'],\n  [GL.UNSIGNED_INT_SAMPLER_2D_ARRAY]: ['2d-array', 'uint']\n};\n\ntype SamplerInfo = {\n  viewDimension: '1d' | '2d' | '2d-array' | 'cube' | 'cube-array' | '3d';\n  sampleType: 'float' | 'unfilterable-float' | 'depth' | 'sint' | 'uint';\n};\n\nfunction getSamplerInfo(type: GL): SamplerInfo {\n  const sampler = SAMPLER_UNIFORMS_GL_TO_GPU[type];\n  if (!sampler) {\n    throw new Error('sampler');\n  }\n  const [viewDimension, sampleType] = sampler;\n  return {viewDimension, sampleType};\n}\n\n// HELPERS\n\nfunction parseUniformName(name: string): {name: string; length: number; isArray: boolean} {\n  // Shortcut to avoid redundant or bad matches\n  if (name[name.length - 1] !== ']') {\n    return {\n      name,\n      length: 1,\n      isArray: false\n    };\n  }\n\n  // if array name then clean the array brackets\n  const UNIFORM_NAME_REGEXP = /([^[]*)(\\[[0-9]+\\])?/;\n  const matches = UNIFORM_NAME_REGEXP.exec(name);\n  if (!matches || matches.length < 2) {\n    throw new Error(`Failed to parse GLSL uniform name ${name}`);\n  }\n\n  return {\n    name: matches[1],\n    length: matches[2] ? 1 : 0,\n    isArray: Boolean(matches[2])\n  };\n}\n"],"mappings":"AAAA;AACA;AACA;AAUA,SAAQA,EAAE,QAAO,oBAAoB;AACrC,SAAQC,mBAAmB,EAAEC,qBAAqB,EAAEC,gBAAgB,QAAC;AAErE;;;;;AAKA,OAAM,SAAUC,uBAAuBA,CACrCC,EAA0B,EAC1BC,OAAqB;EAErB,MAAMC,YAAY,GAAiB;IACjCC,UAAU,EAAE,EAAE;IACdC,QAAQ,EAAE;GACX;EAEDF,YAAY,CAACC,UAAU,GAAGE,yBAAyB,CAACL,EAAE,EAAEC,OAAO,CAAC;EAEhE;EACA,MAAMK,aAAa,GAA0BC,iBAAiB,CAACP,EAAE,EAAEC,OAAO,CAAC;EAC3E,KAAK,MAAMO,YAAY,IAAIF,aAAa,EAAE;IACxC,MAAMG,QAAQ,GAAGD,YAAY,CAACC,QAAQ,CAACC,GAAG,CAACC,OAAO,KAAK;MACrDC,IAAI,EAAED,OAAO,CAACC,IAAI;MAClBC,MAAM,EAAEF,OAAO,CAACE,MAAM;MACtBC,UAAU,EAAEH,OAAO,CAACG,UAAU;MAC9BC,UAAU,EAAEJ,OAAO,CAACI,UAAU;MAC9BC,WAAW,EAAEL,OAAO,CAACK;KACtB,CAAC,CAAC;IACHd,YAAY,CAACE,QAAQ,CAACa,IAAI,CAAC;MACzBC,IAAI,EAAE,SAAS;MACfN,IAAI,EAAEJ,YAAY,CAACI,IAAI;MACvBO,KAAK,EAAE,CAAC;MACRC,QAAQ,EAAEZ,YAAY,CAACY,QAAQ;MAC/BC,UAAU,EAAE,CAACb,YAAY,CAACc,MAAM,GAAG,GAAG,GAAG,CAAC,KAAKd,YAAY,CAACe,QAAQ,GAAG,GAAG,GAAG,CAAC,CAAC;MAC/EC,cAAc,EAAEhB,YAAY,CAACiB,UAAU;MACvChB;KACD,CAAC;EACJ;EAEA,MAAMA,QAAQ,GAAqBiB,mBAAmB,CAAC1B,EAAE,EAAEC,OAAO,CAAC;EACnE,IAAI0B,WAAW,GAAG,CAAC;EACnB,KAAK,MAAMhB,OAAO,IAAIF,QAAQ,EAAE;IAC9B,IAAIX,gBAAgB,CAACa,OAAO,CAACO,IAAI,CAAC,EAAE;MAClC,MAAM;QAACU,aAAa;QAAEC;MAAU,CAAC,GAAGC,cAAc,CAACnB,OAAO,CAACO,IAAI,CAAC;MAChEhB,YAAY,CAACE,QAAQ,CAACa,IAAI,CAAC;QACzBC,IAAI,EAAE,SAAS;QACfN,IAAI,EAAED,OAAO,CAACC,IAAI;QAClBO,KAAK,EAAE,CAAC;QACRC,QAAQ,EAAEO,WAAW;QACrBC,aAAa;QACbC;OACD,CAAC;MAEF;MACAlB,OAAO,CAACgB,WAAW,GAAGA,WAAW;MACjCA,WAAW,IAAI,CAAC;IAClB;EACF;EAEA,IAAIlB,QAAQ,CAACsB,MAAM,EAAE;IACnB7B,YAAY,CAACO,QAAQ,GAAGA,QAAQ;EAClC;EAEA;EACA,MAAMuB,QAAQ,GAAqBC,YAAY,CAACjC,EAAE,EAAEC,OAAO,CAAC;EAC5D;EACA,IAAI+B,QAAQ,EAAED,MAAM,EAAE;IACpB7B,YAAY,CAAC8B,QAAQ,GAAGA,QAAQ;EAClC;EAEA,OAAO9B,YAAY;AACrB;AAEA;AAEA;;;;;AAKA,SAASG,yBAAyBA,CAChCL,EAA0B,EAC1BC,OAAqB;EAErB,MAAME,UAAU,GAA2B,EAAE;EAE7C,MAAM+B,KAAK,GAAGlC,EAAE,CAACmC,mBAAmB,CAAClC,OAAO,QAAuB;EAEnE,KAAK,IAAImC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGF,KAAK,EAAEE,KAAK,EAAE,EAAE;IAC1C,MAAMC,UAAU,GAAGrC,EAAE,CAACsC,eAAe,CAACrC,OAAO,EAAEmC,KAAK,CAAC;IACrD,IAAI,CAACC,UAAU,EAAE;MACf,MAAM,IAAIE,KAAK,CAAC,YAAY,CAAC;IAC/B;IACA,MAAM;MAAC3B,IAAI;MAAEM,IAAI,EAAEsB,aAAa,CAAC;IAAW,CAAC,GAAGH,UAAU;IAC1D,MAAMjB,QAAQ,GAAGpB,EAAE,CAACyC,iBAAiB,CAACxC,OAAO,EAAEW,IAAI,CAAC;IACpD;IACA,IAAIQ,QAAQ,IAAI,CAAC,EAAE;MACjB,MAAM;QAACsB;MAAa,CAAC,GAAG7C,qBAAqB,CAAC2C,aAAa,CAAC;MAE5D;MACA;MACA;MACA;MACA,MAAMG,QAAQ,GAAG,WAAW,CAACC,IAAI,CAAChC,IAAI,CAAC,GAAG,UAAU,GAAG,QAAQ;MAE/DT,UAAU,CAACc,IAAI,CAAC;QACdL,IAAI;QACJQ,QAAQ;QACRuB,QAAQ;QACRzB,IAAI,EAAEwB;QACN;OACD,CAAC;IACJ;EACF;EAEA;EACAvC,UAAU,CAAC0C,IAAI,CAAC,CAACC,CAAuB,EAAEC,CAAuB,KAAKD,CAAC,CAAC1B,QAAQ,GAAG2B,CAAC,CAAC3B,QAAQ,CAAC;EAC9F,OAAOjB,UAAU;AACnB;AAEA;;;;;AAKA,SAAS8B,YAAYA,CAACjC,EAA0B,EAAEC,OAAqB;EACrE,MAAM+B,QAAQ,GAAqB,EAAE;EAErC,MAAME,KAAK,GAAGlC,EAAE,CAACmC,mBAAmB,CAAClC,OAAO,QAAiC;EAC7E,KAAK,IAAImB,QAAQ,GAAG,CAAC,EAAEA,QAAQ,GAAGc,KAAK,EAAEd,QAAQ,EAAE,EAAE;IACnD,MAAMiB,UAAU,GAAGrC,EAAE,CAACgD,2BAA2B,CAAC/C,OAAO,EAAEmB,QAAQ,CAAC;IACpE,IAAI,CAACiB,UAAU,EAAE;MACf,MAAM,IAAIE,KAAK,CAAC,YAAY,CAAC;IAC/B;IACA,MAAM;MAAC3B,IAAI;MAAEM,IAAI,EAAEsB,aAAa;MAAES;IAAI,CAAC,GAAGZ,UAAU;IACpD,MAAM;MAACa,MAAM;MAAEC;IAAU,CAAC,GAAGvD,mBAAmB,CAAC4C,aAAa,CAAC;IAC/D,MAAMY,OAAO,GAAG;MAAChC,QAAQ;MAAER,IAAI;MAAEM,IAAI,EAAEgC,MAAM;MAAED,IAAI,EAAEA,IAAI,GAAGE;IAAU,CAAC,CAAC,CAAC;IACzEnB,QAAQ,CAACf,IAAI,CAACmC,OAAO,CAAC;EACxB;EAEApB,QAAQ,CAACa,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAAC1B,QAAQ,GAAG2B,CAAC,CAAC3B,QAAQ,CAAC;EAChD,OAAOY,QAAQ;AACjB;AAEA;;;;;AAKA,SAASN,mBAAmBA,CAAC1B,EAA0B,EAAEC,OAAqB;EAC5E,MAAMQ,QAAQ,GAAqB,EAAE;EAErC,MAAM4C,YAAY,GAAGrD,EAAE,CAACmC,mBAAmB,CAAClC,OAAO,QAAqB;EACxE,KAAK,IAAIqD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,YAAY,EAAEC,CAAC,EAAE,EAAE;IACrC,MAAMjB,UAAU,GAAGrC,EAAE,CAACuD,gBAAgB,CAACtD,OAAO,EAAEqD,CAAC,CAAC;IAClD,IAAI,CAACjB,UAAU,EAAE;MACf,MAAM,IAAIE,KAAK,CAAC,YAAY,CAAC;IAC/B;IACA,MAAM;MAAC3B,IAAI,EAAE4C,OAAO;MAAEP,IAAI;MAAE/B;IAAI,CAAC,GAAGmB,UAAU;IAC9C,MAAM;MAACzB,IAAI;MAAE6C;IAAO,CAAC,GAAGC,gBAAgB,CAACF,OAAO,CAAC;IACjD,IAAIG,aAAa,GAAG3D,EAAE,CAAC4D,kBAAkB,CAAC3D,OAAO,EAAEW,IAAI,CAAC;IACxD,MAAMiD,WAAW,GAAG;MAClB;MACAzC,QAAQ,EAAEuC,aAAuB;MACjC/C,IAAI;MACJqC,IAAI;MACJ/B,IAAI;MACJuC;KACD;IACDhD,QAAQ,CAACQ,IAAI,CAAC4C,WAAW,CAAC;IAE1B;IACA,IAAIA,WAAW,CAACZ,IAAI,GAAG,CAAC,EAAE;MACxB,KAAK,IAAIa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,WAAW,CAACZ,IAAI,EAAEa,CAAC,EAAE,EAAE;QACzC,MAAMC,WAAW,GAAG,GAAGnD,IAAI,IAAIkD,CAAC,GAAG;QAEnCH,aAAa,GAAG3D,EAAE,CAAC4D,kBAAkB,CAAC3D,OAAO,EAAE8D,WAAW,CAAC;QAE3D,MAAMC,uBAAuB,GAAG;UAC9B,GAAGH,WAAW;UACdjD,IAAI,EAAEmD,WAAW;UACjB3C,QAAQ,EAAEuC;SACX;QAEDlD,QAAQ,CAACQ,IAAI,CAAC+C,uBAAuB,CAAC;MACxC;IACF;EACF;EACA,OAAOvD,QAAQ;AACjB;AAEA;;;;AAIA,SAASF,iBAAiBA,CACxBP,EAA0B,EAC1BC,OAAqB;EAErB,MAAMgE,iBAAiB,GAAGA,CAACC,UAAkB,EAAEC,KAAS,KACtDnE,EAAE,CAACoE,8BAA8B,CAACnE,OAAO,EAAEiE,UAAU,EAAEC,KAAK,CAAC;EAE/D,MAAM7D,aAAa,GAA0B,EAAE;EAE/C,MAAM+D,UAAU,GAAGrE,EAAE,CAACmC,mBAAmB,CAAClC,OAAO,QAA2B;EAC5E,KAAK,IAAIiE,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAGG,UAAU,EAAEH,UAAU,EAAE,EAAE;IAC9D,MAAMI,SAAS,GAAwB;MACrC1D,IAAI,EAAEZ,EAAE,CAACuE,yBAAyB,CAACtE,OAAO,EAAEiE,UAAU,CAAC,IAAI,EAAE;MAC7D9C,QAAQ,EAAE6C,iBAAiB,CAACC,UAAU,QAA2B;MACjEzC,UAAU,EAAEwC,iBAAiB,CAACC,UAAU,QAA6B;MACrE5C,MAAM,EAAE2C,iBAAiB,CAACC,UAAU,QAA+C;MACnF3C,QAAQ,EAAE0C,iBAAiB,CAACC,UAAU,QAAiD;MACvFb,YAAY,EAAEY,iBAAiB,CAACC,UAAU,QAAmC;MAC7EzD,QAAQ,EAAE;KACX;IAED,MAAM+D,cAAc,GACjBP,iBAAiB,CAACC,UAAU,QAAuD,IAAI,EAAE;IAE5F,MAAMO,WAAW,GAAGzE,EAAE,CAAC0E,iBAAiB,CAACzE,OAAO,EAAEuE,cAAc,QAAkB,CAAC,CAAC;IACpF,MAAMG,kBAAkB,GAAG3E,EAAE,CAAC0E,iBAAiB,CAACzE,OAAO,EAAEuE,cAAc,QAAkB,CAAC,CAAC;IAC3F;IACA;IACA;IACA;IACA;IACA,MAAMI,aAAa,GAAG5E,EAAE,CAAC0E,iBAAiB,CAACzE,OAAO,EAAEuE,cAAc,QAAoB,CAAC,CAAC;IACxF,MAAMK,aAAa,GAAG7E,EAAE,CAAC0E,iBAAiB,CAACzE,OAAO,EAAEuE,cAAc,QAA0B,CAAC,CAAC;IAC9F;IACA;IACA;IACA;IACA;IACA;IACA,KAAK,IAAIlB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgB,SAAS,CAACjB,YAAY,EAAE,EAAEC,CAAC,EAAE;MAC/C,MAAMjB,UAAU,GAAGrC,EAAE,CAACuD,gBAAgB,CAACtD,OAAO,EAAEuE,cAAc,CAAClB,CAAC,CAAC,CAAC;MAClE,IAAI,CAACjB,UAAU,EAAE;QACf,MAAM,IAAIE,KAAK,CAAC,YAAY,CAAC;MAC/B;MAEA+B,SAAS,CAAC7D,QAAQ,CAACQ,IAAI,CAAC;QACtBL,IAAI,EAAEyB,UAAU,CAACzB,IAAI;QACrBC,MAAM,EAAEjB,mBAAmB,CAAC6E,WAAW,CAACnB,CAAC,CAAC,CAAC,CAACzC,MAAM;QAClDK,IAAI,EAAEuD,WAAW,CAACnB,CAAC,CAAC;QACpBtC,WAAW,EAAE2D,kBAAkB,CAACrB,CAAC,CAAC;QAClCxC,UAAU,EAAE8D,aAAa,CAACtB,CAAC,CAAC;QAC5BvC,UAAU,EAAE8D,aAAa,CAACvB,CAAC;QAC3B;QACA;OACD,CAAC;IACJ;IAEAhD,aAAa,CAACW,IAAI,CAACqD,SAAS,CAAC;EAC/B;EAEAhE,aAAa,CAACuC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAAC1B,QAAQ,GAAG2B,CAAC,CAAC3B,QAAQ,CAAC;EACrD,OAAOd,aAAa;AACtB;AAEA;;;;;;;;;;;;;;;;;;;;AAqBA,MAAMwE,0BAA0B,GAM5B;EACF,SAAiB,CAAC,IAAI,EAAE,OAAO,CAAC;EAChC,SAAmB,CAAC,MAAM,EAAE,OAAO,CAAC;EACpC,SAAiB,CAAC,IAAI,EAAE,OAAO,CAAC;EAChC,SAAwB,CAAC,IAAI,EAAE,OAAO,CAAC;EACvC,SAAuB,CAAC,UAAU,EAAE,OAAO,CAAC;EAC5C,SAA8B,CAAC,UAAU,EAAE,OAAO,CAAC;EACnD,SAA0B,CAAC,MAAM,EAAE,OAAO,CAAC;EAC3C,SAAqB,CAAC,IAAI,EAAE,MAAM,CAAC;EACnC,SAAqB,CAAC,IAAI,EAAE,MAAM,CAAC;EACnC,SAAuB,CAAC,MAAM,EAAE,MAAM,CAAC;EACvC,SAA2B,CAAC,UAAU,EAAE,MAAM,CAAC;EAC/C,SAA8B,CAAC,IAAI,EAAE,MAAM,CAAC;EAC5C,SAA8B,CAAC,IAAI,EAAE,MAAM,CAAC;EAC5C,SAAgC,CAAC,MAAM,EAAE,MAAM,CAAC;EAChD,SAAoC,CAAC,UAAU,EAAE,MAAM;CACxD;AAOD,SAAShD,cAAcA,CAACZ,IAAQ;EAC9B,MAAM6D,OAAO,GAAGD,0BAA0B,CAAC5D,IAAI,CAAC;EAChD,IAAI,CAAC6D,OAAO,EAAE;IACZ,MAAM,IAAIxC,KAAK,CAAC,SAAS,CAAC;EAC5B;EACA,MAAM,CAACX,aAAa,EAAEC,UAAU,CAAC,GAAGkD,OAAO;EAC3C,OAAO;IAACnD,aAAa;IAAEC;EAAU,CAAC;AACpC;AAEA;AAEA,SAAS6B,gBAAgBA,CAAC9C,IAAY;EACpC;EACA,IAAIA,IAAI,CAACA,IAAI,CAACmB,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;IACjC,OAAO;MACLnB,IAAI;MACJmB,MAAM,EAAE,CAAC;MACT0B,OAAO,EAAE;KACV;EACH;EAEA;EACA,MAAMuB,mBAAmB,GAAG,sBAAsB;EAClD,MAAMC,OAAO,GAAGD,mBAAmB,CAACE,IAAI,CAACtE,IAAI,CAAC;EAC9C,IAAI,CAACqE,OAAO,IAAIA,OAAO,CAAClD,MAAM,GAAG,CAAC,EAAE;IAClC,MAAM,IAAIQ,KAAK,CAAC,qCAAqC3B,IAAI,EAAE,CAAC;EAC9D;EAEA,OAAO;IACLA,IAAI,EAAEqE,OAAO,CAAC,CAAC,CAAC;IAChBlD,MAAM,EAAEkD,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC;IAC1BxB,OAAO,EAAE0B,OAAO,CAACF,OAAO,CAAC,CAAC,CAAC;GAC5B;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}