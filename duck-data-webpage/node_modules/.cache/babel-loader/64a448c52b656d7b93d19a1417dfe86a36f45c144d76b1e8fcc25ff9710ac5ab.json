{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Resource } from \"./resource.js\";\n// import { log } from '../../utils/log';\nimport { uid } from \"../../utils/uid.js\";\nimport { formatCompilerLog } from \"../../adapter-utils/format-compiler-log.js\";\n/**\n * Immutable Shader object\n * In WebGPU the handle can be copied between threads\n */\nexport class Shader extends Resource {\n  static defaultProps = {\n    ...Resource.defaultProps,\n    language: 'auto',\n    stage: undefined,\n    source: '',\n    sourceMap: null,\n    entryPoint: 'main',\n    debugShaders: undefined\n  };\n  get [Symbol.toStringTag]() {\n    return 'Shader';\n  }\n  /** The stage of this shader */\n  stage;\n  /** The source code of this shader */\n  source;\n  /** The compilation status of the shader. 'pending' if compilation is asynchronous, and on production */\n  compilationStatus = 'pending';\n  /** Create a new Shader instance */\n  constructor(device, props) {\n    props = {\n      ...props,\n      debugShaders: props.debugShaders || device.props.debugShaders || 'errors'\n    };\n    super(device, {\n      id: getShaderIdFromProps(props),\n      ...props\n    }, Shader.defaultProps);\n    this.stage = this.props.stage;\n    this.source = this.props.source;\n  }\n  /** Get compiler log synchronously (WebGL only) */\n  getCompilationInfoSync() {\n    return null;\n  }\n  /** Get translated shader source in host platform's native language (HLSL, GLSL, and even GLSL ES), if available */\n  getTranslatedSource() {\n    return null;\n  }\n  // PORTABLE HELPERS\n  /** In browser logging of errors */\n  async debugShader() {\n    const trigger = this.props.debugShaders;\n    switch (trigger) {\n      case 'never':\n        return;\n      case 'errors':\n        // On WebGL - Don't extract the log unless errors\n        if (this.compilationStatus === 'success') {\n          return;\n        }\n        break;\n      case 'warnings':\n      case 'always':\n        break;\n    }\n    const messages = await this.getCompilationInfo();\n    if (trigger === 'warnings' && messages?.length === 0) {\n      return;\n    }\n    this._displayShaderLog(messages);\n  }\n  // PRIVATE\n  /**\n   * In-browser UI logging of errors\n   * TODO - this HTML formatting code should not be in Device, should be pluggable\n   */\n  _displayShaderLog(messages) {\n    // Return if under Node.js / incomplete `document` polyfills\n    if (typeof document === 'undefined' || !document?.createElement) {\n      return;\n    }\n    const shaderName = getShaderName(this.source);\n    const shaderTitle = `${this.stage} ${shaderName}`;\n    let htmlLog = formatCompilerLog(messages, this.source, {\n      showSourceCode: 'all',\n      html: true\n    });\n    // Show translated source if available\n    const translatedSource = this.getTranslatedSource();\n    if (translatedSource) {\n      htmlLog += `<br /><br /><h1>Translated Source</h1><br /><br /><code style=\"user-select:text;\"><pre>${translatedSource}</pre></code>`;\n    }\n    // Make it clickable so we can copy to clipboard\n    const button = document.createElement('Button');\n    button.innerHTML = `\n<h1>Shader Compilation Error in ${shaderTitle}</h1><br /><br />\n<code style=\"user-select:text;\"><pre>\n${htmlLog}\n</pre></code>`;\n    button.style.top = '10px';\n    button.style.left = '10px';\n    button.style.position = 'absolute';\n    button.style.zIndex = '9999';\n    button.style.width = '100%';\n    button.style.textAlign = 'left';\n    document.body.appendChild(button);\n    const errors = document.getElementsByClassName('luma-compiler-log-error');\n    errors[0]?.scrollIntoView();\n    // TODO - add a small embedded copy button (instead of main button)\n    button.onclick = () => {\n      // const source = this.source.replaceAll('\\n', '<br />');\n      const dataURI = `data:text/plain,${encodeURIComponent(this.source)}`;\n      navigator.clipboard.writeText(dataURI);\n    };\n    // TODO - add a small embedded close button\n  }\n}\n// HELPERS\n/** Deduce an id, from shader source, or supplied id, or shader type */\nfunction getShaderIdFromProps(props) {\n  return getShaderName(props.source) || props.id || uid(`unnamed ${props.stage}-shader`);\n}\n/** Extracts GLSLIFY style naming of shaders: `#define SHADER_NAME ...` */\nfunction getShaderName(shader, defaultName = 'unnamed') {\n  const SHADER_NAME_REGEXP = /#define[\\s*]SHADER_NAME[\\s*]([A-Za-z0-9_-]+)[\\s*]/;\n  const match = SHADER_NAME_REGEXP.exec(shader);\n  return match ? match[1] : defaultName;\n}\n//# sourceMappingURL=shader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}