{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { AmbientLight } from \"./ambient-light.js\";\nimport { DirectionalLight } from \"./directional-light.js\";\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport ShadowPass from \"../../passes/shadow-pass.js\";\nimport shadow from \"../../shaderlib/shadow/shadow.js\";\nconst DEFAULT_AMBIENT_LIGHT_PROPS = {\n  color: [255, 255, 255],\n  intensity: 1.0\n};\nconst DEFAULT_DIRECTIONAL_LIGHT_PROPS = [{\n  color: [255, 255, 255],\n  intensity: 1.0,\n  direction: [-1, 3, -1]\n}, {\n  color: [255, 255, 255],\n  intensity: 0.9,\n  direction: [1, -8, -2.5]\n}];\nconst DEFAULT_SHADOW_COLOR = [0, 0, 0, 200 / 255];\n// Class to manage ambient, point and directional light sources in deck\nexport default class LightingEffect {\n  constructor(props = {}) {\n    this.id = 'lighting-effect';\n    this.shadowColor = DEFAULT_SHADOW_COLOR;\n    this.shadow = false;\n    this.directionalLights = [];\n    this.pointLights = [];\n    this.shadowPasses = [];\n    this.dummyShadowMap = null;\n    this.setProps(props);\n  }\n  setup(context) {\n    this.context = context;\n    const {\n      device,\n      deck\n    } = context;\n    if (this.shadow && !this.dummyShadowMap) {\n      this._createShadowPasses(device);\n      deck._addDefaultShaderModule(shadow);\n      this.dummyShadowMap = device.createTexture({\n        width: 1,\n        height: 1\n      });\n    }\n  }\n  setProps(props) {\n    this.ambientLight = undefined;\n    this.directionalLights = [];\n    this.pointLights = [];\n    for (const key in props) {\n      const lightSource = props[key];\n      switch (lightSource.type) {\n        case 'ambient':\n          this.ambientLight = lightSource;\n          break;\n        case 'directional':\n          this.directionalLights.push(lightSource);\n          break;\n        case 'point':\n          this.pointLights.push(lightSource);\n          break;\n        default:\n      }\n    }\n    this._applyDefaultLights();\n    this.shadow = this.directionalLights.some(light => light.shadow);\n    if (this.context) {\n      // Create resources if necessary\n      this.setup(this.context);\n    }\n    this.props = props;\n  }\n  preRender({\n    layers,\n    layerFilter,\n    viewports,\n    onViewportActive,\n    views\n  }) {\n    if (!this.shadow) return;\n    // create light matrix every frame to make sure always updated from light source\n    this.shadowMatrices = this._calculateMatrices();\n    for (let i = 0; i < this.shadowPasses.length; i++) {\n      const shadowPass = this.shadowPasses[i];\n      shadowPass.render({\n        layers,\n        layerFilter,\n        viewports,\n        onViewportActive,\n        views,\n        shaderModuleProps: {\n          shadow: {\n            shadowLightId: i,\n            dummyShadowMap: this.dummyShadowMap,\n            shadowMatrices: this.shadowMatrices\n          }\n        }\n      });\n    }\n  }\n  getShaderModuleProps(layer, otherShaderModuleProps) {\n    const shadowProps = this.shadow ? {\n      project: otherShaderModuleProps.project,\n      shadowMaps: this.shadowPasses.map(shadowPass => shadowPass.getShadowMap()),\n      dummyShadowMap: this.dummyShadowMap,\n      shadowColor: this.shadowColor,\n      shadowMatrices: this.shadowMatrices\n    } : {};\n    // when not rendering to screen, turn off lighting by adding empty light source object\n    // lights shader module relies on the `lightSources` to turn on/off lighting\n    const lightingProps = {\n      enabled: true,\n      ambientLight: this.ambientLight,\n      directionalLights: this.directionalLights.map(directionalLight => directionalLight.getProjectedLight({\n        layer\n      })),\n      pointLights: this.pointLights.map(pointLight => pointLight.getProjectedLight({\n        layer\n      }))\n    };\n    // @ts-expect-error material is not a Layer prop\n    const materialProps = layer.props.material;\n    return {\n      shadow: shadowProps,\n      lighting: lightingProps,\n      phongMaterial: materialProps,\n      gouraudMaterial: materialProps\n    };\n  }\n  cleanup(context) {\n    for (const shadowPass of this.shadowPasses) {\n      shadowPass.delete();\n    }\n    this.shadowPasses.length = 0;\n    if (this.dummyShadowMap) {\n      this.dummyShadowMap.destroy();\n      this.dummyShadowMap = null;\n      context.deck._removeDefaultShaderModule(shadow);\n    }\n  }\n  _calculateMatrices() {\n    const lightMatrices = [];\n    for (const light of this.directionalLights) {\n      const viewMatrix = new Matrix4().lookAt({\n        eye: new Vector3(light.direction).negate()\n      });\n      lightMatrices.push(viewMatrix);\n    }\n    return lightMatrices;\n  }\n  _createShadowPasses(device) {\n    for (let i = 0; i < this.directionalLights.length; i++) {\n      const shadowPass = new ShadowPass(device);\n      this.shadowPasses[i] = shadowPass;\n    }\n  }\n  _applyDefaultLights() {\n    const {\n      ambientLight,\n      pointLights,\n      directionalLights\n    } = this;\n    if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {\n      this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);\n      this.directionalLights.push(new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));\n    }\n  }\n}","map":{"version":3,"names":["AmbientLight","DirectionalLight","Matrix4","Vector3","ShadowPass","shadow","DEFAULT_AMBIENT_LIGHT_PROPS","color","intensity","DEFAULT_DIRECTIONAL_LIGHT_PROPS","direction","DEFAULT_SHADOW_COLOR","LightingEffect","constructor","props","id","shadowColor","directionalLights","pointLights","shadowPasses","dummyShadowMap","setProps","setup","context","device","deck","_createShadowPasses","_addDefaultShaderModule","createTexture","width","height","ambientLight","undefined","key","lightSource","type","push","_applyDefaultLights","some","light","preRender","layers","layerFilter","viewports","onViewportActive","views","shadowMatrices","_calculateMatrices","i","length","shadowPass","render","shaderModuleProps","shadowLightId","getShaderModuleProps","layer","otherShaderModuleProps","shadowProps","project","shadowMaps","map","getShadowMap","lightingProps","enabled","directionalLight","getProjectedLight","pointLight","materialProps","material","lighting","phongMaterial","gouraudMaterial","cleanup","delete","destroy","_removeDefaultShaderModule","lightMatrices","viewMatrix","lookAt","eye","negate"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\effects\\lighting\\lighting-effect.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '@luma.gl/core';\nimport {Texture} from '@luma.gl/core';\nimport {AmbientLight} from './ambient-light';\nimport {DirectionalLight} from './directional-light';\nimport {PointLight} from './point-light';\nimport {Matrix4, Vector3} from '@math.gl/core';\nimport ShadowPass from '../../passes/shadow-pass';\nimport shadow from '../../shaderlib/shadow/shadow';\n\nimport type {LightingProps} from '@luma.gl/shadertools';\nimport type {ShadowModuleProps} from '../../shaderlib/shadow/shadow';\nimport type Layer from '../../lib/layer';\nimport type {Effect, EffectContext, PreRenderOptions} from '../../lib/effect';\n\nconst DEFAULT_AMBIENT_LIGHT_PROPS = {\n  color: [255, 255, 255] as [number, number, number],\n  intensity: 1.0\n};\nconst DEFAULT_DIRECTIONAL_LIGHT_PROPS = [\n  {\n    color: [255, 255, 255] as [number, number, number],\n    intensity: 1.0,\n    direction: [-1, 3, -1] as [number, number, number]\n  },\n  {\n    color: [255, 255, 255] as [number, number, number],\n    intensity: 0.9,\n    direction: [1, -8, -2.5] as [number, number, number]\n  }\n];\nconst DEFAULT_SHADOW_COLOR = [0, 0, 0, 200 / 255] as [number, number, number, number];\n\nexport type LightingEffectProps = Record<string, PointLight | DirectionalLight | AmbientLight>;\n\n// Class to manage ambient, point and directional light sources in deck\nexport default class LightingEffect implements Effect {\n  id = 'lighting-effect';\n  props!: LightingEffectProps;\n  shadowColor: [number, number, number, number] = DEFAULT_SHADOW_COLOR;\n  context?: EffectContext;\n\n  private shadow: boolean = false;\n  private ambientLight?: AmbientLight;\n  private directionalLights: DirectionalLight[] = [];\n  private pointLights: PointLight[] = [];\n  private shadowPasses: ShadowPass[] = [];\n  private dummyShadowMap: Texture | null = null;\n  private shadowMatrices?: Matrix4[];\n\n  constructor(props: LightingEffectProps = {}) {\n    this.setProps(props);\n  }\n\n  setup(context: EffectContext) {\n    this.context = context;\n    const {device, deck} = context;\n\n    if (this.shadow && !this.dummyShadowMap) {\n      this._createShadowPasses(device);\n\n      deck._addDefaultShaderModule(shadow);\n\n      this.dummyShadowMap = device.createTexture({\n        width: 1,\n        height: 1\n      });\n    }\n  }\n\n  setProps(props: LightingEffectProps) {\n    this.ambientLight = undefined;\n    this.directionalLights = [];\n    this.pointLights = [];\n\n    for (const key in props) {\n      const lightSource = props[key];\n\n      switch (lightSource.type) {\n        case 'ambient':\n          this.ambientLight = lightSource;\n          break;\n\n        case 'directional':\n          this.directionalLights.push(lightSource);\n          break;\n\n        case 'point':\n          this.pointLights.push(lightSource);\n          break;\n        default:\n      }\n    }\n    this._applyDefaultLights();\n\n    this.shadow = this.directionalLights.some(light => light.shadow);\n    if (this.context) {\n      // Create resources if necessary\n      this.setup(this.context);\n    }\n    this.props = props;\n  }\n\n  preRender({layers, layerFilter, viewports, onViewportActive, views}: PreRenderOptions) {\n    if (!this.shadow) return;\n\n    // create light matrix every frame to make sure always updated from light source\n    this.shadowMatrices = this._calculateMatrices();\n\n    for (let i = 0; i < this.shadowPasses.length; i++) {\n      const shadowPass = this.shadowPasses[i];\n      shadowPass.render({\n        layers,\n        layerFilter,\n        viewports,\n        onViewportActive,\n        views,\n        shaderModuleProps: {\n          shadow: {\n            shadowLightId: i,\n            dummyShadowMap: this.dummyShadowMap,\n            shadowMatrices: this.shadowMatrices\n          }\n        }\n      });\n    }\n  }\n\n  getShaderModuleProps(layer: Layer, otherShaderModuleProps: Record<string, any>) {\n    const shadowProps = this.shadow\n      ? ({\n          project: otherShaderModuleProps.project,\n          shadowMaps: this.shadowPasses.map(shadowPass => shadowPass.getShadowMap()),\n          dummyShadowMap: this.dummyShadowMap!,\n          shadowColor: this.shadowColor,\n          shadowMatrices: this.shadowMatrices\n        } satisfies ShadowModuleProps)\n      : {};\n\n    // when not rendering to screen, turn off lighting by adding empty light source object\n    // lights shader module relies on the `lightSources` to turn on/off lighting\n    const lightingProps: LightingProps = {\n      enabled: true,\n      ambientLight: this.ambientLight,\n      directionalLights: this.directionalLights.map(directionalLight =>\n        directionalLight.getProjectedLight({layer})\n      ),\n      pointLights: this.pointLights.map(pointLight => pointLight.getProjectedLight({layer}))\n    };\n    // @ts-expect-error material is not a Layer prop\n    const materialProps = layer.props.material;\n\n    return {\n      shadow: shadowProps,\n      lighting: lightingProps,\n      phongMaterial: materialProps,\n      gouraudMaterial: materialProps\n    };\n  }\n\n  cleanup(context: EffectContext): void {\n    for (const shadowPass of this.shadowPasses) {\n      shadowPass.delete();\n    }\n    this.shadowPasses.length = 0;\n\n    if (this.dummyShadowMap) {\n      this.dummyShadowMap.destroy();\n      this.dummyShadowMap = null;\n      context.deck._removeDefaultShaderModule(shadow);\n    }\n  }\n\n  private _calculateMatrices(): Matrix4[] {\n    const lightMatrices: Matrix4[] = [];\n    for (const light of this.directionalLights) {\n      const viewMatrix = new Matrix4().lookAt({\n        eye: new Vector3(light.direction).negate()\n      });\n\n      lightMatrices.push(viewMatrix);\n    }\n    return lightMatrices;\n  }\n\n  private _createShadowPasses(device: Device): void {\n    for (let i = 0; i < this.directionalLights.length; i++) {\n      const shadowPass = new ShadowPass(device);\n      this.shadowPasses[i] = shadowPass;\n    }\n  }\n\n  private _applyDefaultLights(): void {\n    const {ambientLight, pointLights, directionalLights} = this;\n    if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {\n      this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);\n      this.directionalLights.push(\n        new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]),\n        new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1])\n      );\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}