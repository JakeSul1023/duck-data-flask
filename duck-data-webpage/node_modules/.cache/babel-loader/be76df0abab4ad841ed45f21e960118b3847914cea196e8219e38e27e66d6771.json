{"ast":null,"code":"// mjolnir.js\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Input } from \"./input.js\";\nconst MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'mouseover', 'mouseout', 'mouseleave'];\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\nexport class MoveInput extends Input {\n  constructor(element, callback, options) {\n    super(element, callback, {\n      enable: true,\n      ...options\n    });\n    this.handleEvent = event => {\n      this.handleOverEvent(event);\n      this.handleOutEvent(event);\n      this.handleEnterEvent(event);\n      this.handleLeaveEvent(event);\n      this.handleMoveEvent(event);\n    };\n    this.pressed = false;\n    const {\n      enable\n    } = this.options;\n    this.enableMoveEvent = enable;\n    this.enableLeaveEvent = enable;\n    this.enableEnterEvent = enable;\n    this.enableOutEvent = enable;\n    this.enableOverEvent = enable;\n    MOUSE_EVENTS.forEach(event => element.addEventListener(event, this.handleEvent));\n  }\n  destroy() {\n    MOUSE_EVENTS.forEach(event => this.element.removeEventListener(event, this.handleEvent));\n  }\n  /**\n   * Enable this input (begin processing events)\n   * if the specified event type is among those handled by this input.\n   */\n  enableEventType(eventType, enabled) {\n    switch (eventType) {\n      case 'pointermove':\n        this.enableMoveEvent = enabled;\n        break;\n      case 'pointerover':\n        this.enableOverEvent = enabled;\n        break;\n      case 'pointerout':\n        this.enableOutEvent = enabled;\n        break;\n      case 'pointerenter':\n        this.enableEnterEvent = enabled;\n        break;\n      case 'pointerleave':\n        this.enableLeaveEvent = enabled;\n        break;\n      default:\n      // ignore\n    }\n  }\n  handleOverEvent(event) {\n    if (this.enableOverEvent && event.type === 'mouseover') {\n      this._emit('pointerover', event);\n    }\n  }\n  handleOutEvent(event) {\n    if (this.enableOutEvent && event.type === 'mouseout') {\n      this._emit('pointerout', event);\n    }\n  }\n  handleEnterEvent(event) {\n    if (this.enableEnterEvent && event.type === 'mouseenter') {\n      this._emit('pointerenter', event);\n    }\n  }\n  handleLeaveEvent(event) {\n    if (this.enableLeaveEvent && event.type === 'mouseleave') {\n      this._emit('pointerleave', event);\n    }\n  }\n  handleMoveEvent(event) {\n    if (this.enableMoveEvent) {\n      switch (event.type) {\n        case 'mousedown':\n          if (event.button >= 0) {\n            // Button is down\n            this.pressed = true;\n          }\n          break;\n        case 'mousemove':\n          // Move events use `bottons` to track the button being pressed\n          if (event.buttons === 0) {\n            // Button is not down\n            this.pressed = false;\n          }\n          if (!this.pressed) {\n            // Drag events are emitted by hammer already\n            // we just need to emit the move event on hover\n            this._emit('pointermove', event);\n          }\n          break;\n        case 'mouseup':\n          this.pressed = false;\n          break;\n        default:\n      }\n    }\n  }\n  _emit(type, event) {\n    this.callback({\n      type,\n      center: {\n        x: event.clientX,\n        y: event.clientY\n      },\n      srcEvent: event,\n      pointerType: 'mouse',\n      target: event.target\n    });\n  }\n}\n//# sourceMappingURL=move-input.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}