{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport Viewport from \"../viewports/viewport.js\";\nimport { Matrix4 } from '@math.gl/core';\nimport { pixelsToWorld, fovyToAltitude } from '@math.gl/web-mercator';\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nfunction getViewMatrix({\n  height,\n  focalDistance,\n  orbitAxis,\n  rotationX,\n  rotationOrbit,\n  zoom\n}) {\n  // We position the camera so that one common space unit (world space unit scaled by zoom)\n  // at the target maps to one screen pixel.\n  // This is a similar technique to that used in web mercator projection\n  // By doing so we are able to convert between common space and screen space sizes efficiently\n  // in the vertex shader.\n  const up = orbitAxis === 'Z' ? [0, 0, 1] : [0, 1, 0];\n  const eye = orbitAxis === 'Z' ? [0, -focalDistance, 0] : [0, 0, focalDistance];\n  const viewMatrix = new Matrix4().lookAt({\n    eye,\n    up\n  });\n  viewMatrix.rotateX(rotationX * DEGREES_TO_RADIANS);\n  if (orbitAxis === 'Z') {\n    viewMatrix.rotateZ(rotationOrbit * DEGREES_TO_RADIANS);\n  } else {\n    viewMatrix.rotateY(rotationOrbit * DEGREES_TO_RADIANS);\n  }\n  // When height increases, we need to increase the distance from the camera to the target to\n  // keep the 1:1 mapping. However, this also changes the projected depth of each position by\n  // moving them further away between the near/far plane.\n  // Without modifying the default near/far planes, we instead scale down the common space to\n  // remove the distortion to the depth field.\n  const projectionScale = Math.pow(2, zoom) / height;\n  viewMatrix.scale(projectionScale);\n  return viewMatrix;\n}\nexport default class OrbitViewport extends Viewport {\n  constructor(props) {\n    const {\n      height,\n      projectionMatrix,\n      fovy = 50,\n      // For setting camera position\n      orbitAxis = 'Z',\n      // Orbit axis with 360 degrees rotating freedom, can only be 'Y' or 'Z'\n      target = [0, 0, 0],\n      // Which point is camera looking at, default origin\n      rotationX = 0,\n      // Rotating angle around X axis\n      rotationOrbit = 0,\n      // Rotating angle around orbit axis\n      zoom = 0\n    } = props;\n    const focalDistance = projectionMatrix ? projectionMatrix[5] / 2 : fovyToAltitude(fovy);\n    super({\n      ...props,\n      // in case viewState contains longitude/latitude values,\n      // make sure that the base Viewport class does not treat this as a geospatial viewport\n      longitude: undefined,\n      viewMatrix: getViewMatrix({\n        height: height || 1,\n        focalDistance,\n        orbitAxis,\n        rotationX,\n        rotationOrbit,\n        zoom\n      }),\n      fovy,\n      focalDistance,\n      position: target,\n      zoom\n    });\n    this.projectedCenter = this.project(this.center);\n  }\n  unproject(xyz, {\n    topLeft = true\n  } = {}) {\n    const [x, y, z = this.projectedCenter[2]] = xyz;\n    const y2 = topLeft ? y : this.height - y;\n    const [X, Y, Z] = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix);\n    return [X, Y, Z];\n  }\n  panByPosition(coords, pixel) {\n    const p0 = this.project(coords);\n    const nextCenter = [this.width / 2 + p0[0] - pixel[0], this.height / 2 + p0[1] - pixel[1], this.projectedCenter[2]];\n    return {\n      target: this.unproject(nextCenter)\n    };\n  }\n}","map":{"version":3,"names":["Viewport","Matrix4","pixelsToWorld","fovyToAltitude","DEGREES_TO_RADIANS","Math","PI","getViewMatrix","height","focalDistance","orbitAxis","rotationX","rotationOrbit","zoom","up","eye","viewMatrix","lookAt","rotateX","rotateZ","rotateY","projectionScale","pow","scale","OrbitViewport","constructor","props","projectionMatrix","fovy","target","longitude","undefined","position","projectedCenter","project","center","unproject","xyz","topLeft","x","y","z","y2","X","Y","Z","pixelUnprojectionMatrix","panByPosition","coords","pixel","p0","nextCenter","width"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\viewports\\orbit-viewport.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport Viewport from '../viewports/viewport';\n\nimport {Matrix4} from '@math.gl/core';\nimport {pixelsToWorld, fovyToAltitude} from '@math.gl/web-mercator';\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\n\nfunction getViewMatrix({\n  height,\n  focalDistance,\n  orbitAxis,\n  rotationX,\n  rotationOrbit,\n  zoom\n}: {\n  height: number;\n  focalDistance: number;\n  orbitAxis: 'Y' | 'Z';\n  rotationX: number;\n  rotationOrbit: number;\n  zoom: number;\n}): Matrix4 {\n  // We position the camera so that one common space unit (world space unit scaled by zoom)\n  // at the target maps to one screen pixel.\n  // This is a similar technique to that used in web mercator projection\n  // By doing so we are able to convert between common space and screen space sizes efficiently\n  // in the vertex shader.\n  const up = orbitAxis === 'Z' ? [0, 0, 1] : [0, 1, 0];\n  const eye = orbitAxis === 'Z' ? [0, -focalDistance, 0] : [0, 0, focalDistance];\n\n  const viewMatrix = new Matrix4().lookAt({eye, up});\n\n  viewMatrix.rotateX(rotationX * DEGREES_TO_RADIANS);\n  if (orbitAxis === 'Z') {\n    viewMatrix.rotateZ(rotationOrbit * DEGREES_TO_RADIANS);\n  } else {\n    viewMatrix.rotateY(rotationOrbit * DEGREES_TO_RADIANS);\n  }\n\n  // When height increases, we need to increase the distance from the camera to the target to\n  // keep the 1:1 mapping. However, this also changes the projected depth of each position by\n  // moving them further away between the near/far plane.\n  // Without modifying the default near/far planes, we instead scale down the common space to\n  // remove the distortion to the depth field.\n  const projectionScale = Math.pow(2, zoom) / height;\n  viewMatrix.scale(projectionScale);\n\n  return viewMatrix;\n}\n\nexport type OrbitViewportOptions = {\n  /** Name of the viewport */\n  id?: string;\n  /** Left offset from the canvas edge, in pixels */\n  x?: number;\n  /** Top offset from the canvas edge, in pixels */\n  y?: number;\n  /** Viewport width in pixels */\n  width?: number;\n  /** Viewport height in pixels */\n  height?: number;\n  /** Axis with 360 degrees rotating freedom, either `'Y'` or `'Z'`, default to `'Z'`. */\n  orbitAxis?: 'Y' | 'Z';\n  /** The world position at the center of the viewport. Default `[0, 0, 0]`. */\n  target?: [number, number, number];\n  /** The zoom level of the viewport. `zoom: 0` maps one unit distance to one pixel on screen, and increasing `zoom` by `1` scales the same object to twice as large. Default `0`. */\n  zoom?: number;\n  /** Rotating angle around orbit axis. Default `0`. */\n  rotationOrbit?: number;\n  /** Rotating angle around orbit axis. Default `0`. */\n  rotationX?: number;\n  /** Custom projection matrix */\n  projectionMatrix?: number[];\n  /** Field of view covered by camera, in the perspective case. In degrees. Default `50`. */\n  fovy?: number;\n  /** Distance of near clipping plane. Default `0.1`. */\n  near?: number;\n  /** Distance of far clipping plane. Default `1000`. */\n  far?: number;\n  /** Whether to create an orthographic or perspective projection matrix. Default is `false` (perspective projection). */\n  orthographic?: boolean;\n};\n\nexport default class OrbitViewport extends Viewport {\n  projectedCenter: number[];\n\n  constructor(props: OrbitViewportOptions) {\n    const {\n      height,\n\n      projectionMatrix,\n\n      fovy = 50, // For setting camera position\n      orbitAxis = 'Z', // Orbit axis with 360 degrees rotating freedom, can only be 'Y' or 'Z'\n      target = [0, 0, 0], // Which point is camera looking at, default origin\n\n      rotationX = 0, // Rotating angle around X axis\n      rotationOrbit = 0, // Rotating angle around orbit axis\n\n      zoom = 0\n    } = props;\n\n    const focalDistance = projectionMatrix ? projectionMatrix[5] / 2 : fovyToAltitude(fovy);\n\n    super({\n      ...props,\n      // in case viewState contains longitude/latitude values,\n      // make sure that the base Viewport class does not treat this as a geospatial viewport\n      longitude: undefined,\n      viewMatrix: getViewMatrix({\n        height: height || 1,\n        focalDistance,\n        orbitAxis,\n        rotationX,\n        rotationOrbit,\n        zoom\n      }),\n      fovy,\n      focalDistance,\n      position: target,\n      zoom\n    });\n\n    this.projectedCenter = this.project(this.center);\n  }\n\n  unproject(xyz: number[], {topLeft = true}: {topLeft?: boolean} = {}): [number, number, number] {\n    const [x, y, z = this.projectedCenter[2]] = xyz;\n\n    const y2 = topLeft ? y : this.height - y;\n    const [X, Y, Z] = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix);\n    return [X, Y, Z];\n  }\n\n  panByPosition(coords: number[], pixel: number[]): OrbitViewportOptions {\n    const p0 = this.project(coords);\n    const nextCenter = [\n      this.width / 2 + p0[0] - pixel[0],\n      this.height / 2 + p0[1] - pixel[1],\n      this.projectedCenter[2]\n    ];\n    return {\n      target: this.unproject(nextCenter)\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}