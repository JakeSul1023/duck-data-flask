{"ast":null,"code":"// GEO METADATA\n/**\n * Reads the GeoMetadata object from the metadata\n * @note geoarrow / parquet schema is stringified into a single key-value pair in the parquet metadata\n */\nexport function getGeoMetadata(schema) {\n  const geoMetadata = parseJSONStringMetadata(schema, 'geo');\n  if (!geoMetadata) {\n    return null;\n  }\n  for (const column of Object.values(geoMetadata.columns || {})) {\n    if (column.encoding) {\n      column.encoding = column.encoding.toLowerCase();\n    }\n  }\n  return geoMetadata;\n}\n/**\n * Stores a geoarrow / geoparquet geo metadata object in the schema\n * @note geoarrow / geoparquet geo metadata is a single stringified JSON field\n */\nexport function setGeoMetadata(schema, geoMetadata) {\n  const stringifiedGeoMetadata = JSON.stringify(geoMetadata);\n  schema.metadata.geo = stringifiedGeoMetadata;\n}\n/**\n * Unpacks geo metadata into separate metadata fields (parses the long JSON string)\n * @note geoarrow / parquet schema is stringified into a single key-value pair in the parquet metadata\n */\nexport function unpackGeoMetadata(schema) {\n  const geoMetadata = getGeoMetadata(schema);\n  if (!geoMetadata) {\n    return;\n  }\n  // Store Parquet Schema Level Metadata\n  const {\n    version,\n    primary_column,\n    columns\n  } = geoMetadata;\n  if (version) {\n    schema.metadata['geo.version'] = version;\n  }\n  if (primary_column) {\n    schema.metadata['geo.primary_column'] = primary_column;\n  }\n  // store column names as comma separated list\n  schema.metadata['geo.columns'] = Object.keys(columns || {}).join('');\n  for (const [columnName, columnMetadata] of Object.entries(columns || {})) {\n    const field = schema.fields.find(field => field.name === columnName);\n    if (field) {\n      if (field.name === primary_column) {\n        setFieldMetadata(field, 'geo.primary_field', 'true');\n      }\n      unpackGeoFieldMetadata(field, columnMetadata);\n    }\n  }\n}\n// eslint-disable-next-line complexity\nfunction unpackGeoFieldMetadata(field, columnMetadata) {\n  for (const [key, value] of Object.entries(columnMetadata || {})) {\n    switch (key) {\n      case 'geometry_types':\n        setFieldMetadata(field, `geo.${key}`, value.join(','));\n        break;\n      case 'bbox':\n        setFieldMetadata(field, `geo.crs.${key}`, JSON.stringify(value));\n        break;\n      case 'crs':\n        // @ts-ignore\n        for (const [crsKey, crsValue] of Object.entries(value || {})) {\n          switch (crsKey) {\n            case 'id':\n              // prettier-ignore\n              const crsId = typeof crsValue === 'object' ?\n              // @ts-ignore\n              `${crsValue?.authority}:${crsValue?.code}` : JSON.stringify(crsValue);\n              setFieldMetadata(field, `geo.crs.${crsKey}`, crsId);\n              break;\n            default:\n              setFieldMetadata(field, `geo.crs.${crsKey}`, typeof crsValue === 'string' ? crsValue : JSON.stringify(crsValue));\n              break;\n          }\n        }\n        break;\n      case 'edges':\n      default:\n        setFieldMetadata(field, `geo.${key}`, typeof value === 'string' ? value : JSON.stringify(value));\n    }\n  }\n}\nfunction setFieldMetadata(field, key, value) {\n  field.metadata = field.metadata || {};\n  field.metadata[key] = value;\n}\n// HELPERS\n/** Parse a key with stringified arrow metadata */\nexport function parseJSONStringMetadata(schema, metadataKey) {\n  const stringifiedMetadata = schema.metadata[metadataKey];\n  if (!stringifiedMetadata) {\n    return null;\n  }\n  try {\n    const metadata = JSON.parse(stringifiedMetadata);\n    if (!metadata || typeof metadata !== 'object') {\n      return null;\n    }\n    return metadata;\n  } catch {\n    return null;\n  }\n}\nexport function unpackJSONStringMetadata(schema, metadataKey) {\n  const json = parseJSONStringMetadata(schema, metadataKey);\n  for (const [key, value] of Object.entries(json || {})) {\n    schema.metadata[`${metadataKey}.${key}`] = typeof value === 'string' ? value : JSON.stringify(value);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}