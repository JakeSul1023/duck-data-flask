{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* eslint-disable guard-for-in */\nimport Attribute from \"./attribute.js\";\nimport log from \"../../utils/log.js\";\nimport memoize from \"../../utils/memoize.js\";\nimport { mergeBounds } from \"../../utils/math-utils.js\";\nimport debug from \"../../debug/index.js\";\nimport AttributeTransitionManager from \"./attribute-transition-manager.js\";\nconst TRACE_INVALIDATE = 'attributeManager.invalidate';\nconst TRACE_UPDATE_START = 'attributeManager.updateStart';\nconst TRACE_UPDATE_END = 'attributeManager.updateEnd';\nconst TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';\nconst TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';\nconst TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';\nexport default class AttributeManager {\n  constructor(device, {\n    id = 'attribute-manager',\n    stats,\n    timeline\n  } = {}) {\n    this.mergeBoundsMemoized = memoize(mergeBounds);\n    this.id = id;\n    this.device = device;\n    this.attributes = {};\n    this.updateTriggers = {};\n    this.needsRedraw = true;\n    this.userData = {};\n    this.stats = stats;\n    this.attributeTransitionManager = new AttributeTransitionManager(device, {\n      id: `${id}-transitions`,\n      timeline\n    });\n    // For debugging sanity, prevent uninitialized members\n    Object.seal(this);\n  }\n  finalize() {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].delete();\n    }\n    this.attributeTransitionManager.finalize();\n  }\n  // Returns the redraw flag, optionally clearing it.\n  // Redraw flag will be set if any attributes attributes changed since\n  // flag was last cleared.\n  //\n  // @param {String} [clearRedrawFlags=false] - whether to clear the flag\n  // @return {false|String} - reason a redraw is needed.\n  getNeedsRedraw(opts = {\n    clearRedrawFlags: false\n  }) {\n    const redraw = this.needsRedraw;\n    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;\n    return redraw && this.id;\n  }\n  // Sets the redraw flag.\n  // @param {Boolean} redraw=true\n  setNeedsRedraw() {\n    this.needsRedraw = true;\n  }\n  // Adds attributes\n  add(attributes) {\n    this._add(attributes);\n  }\n  // Adds attributes\n  addInstanced(attributes) {\n    this._add(attributes, {\n      stepMode: 'instance'\n    });\n  }\n  /**\n   * Removes attributes\n   * Takes an array of attribute names and delete them from\n   * the attribute map if they exists\n   *\n   * @example\n   * attributeManager.remove(['position']);\n   *\n   * @param {Object} attributeNameArray - attribute name array (see above)\n   */\n  remove(attributeNameArray) {\n    for (const name of attributeNameArray) {\n      if (this.attributes[name] !== undefined) {\n        this.attributes[name].delete();\n        delete this.attributes[name];\n      }\n    }\n  }\n  // Marks an attribute for update\n  invalidate(triggerName, dataRange) {\n    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);\n  }\n  invalidateAll(dataRange) {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);\n    }\n    // For performance tuning\n    debug(TRACE_INVALIDATE, this, 'all');\n  }\n  // Ensure all attribute buffers are updated from props or data.\n  // eslint-disable-next-line complexity\n  update({\n    data,\n    numInstances,\n    startIndices = null,\n    transitions,\n    props = {},\n    buffers = {},\n    context = {}\n  }) {\n    // keep track of whether some attributes are updated\n    let updated = false;\n    debug(TRACE_UPDATE_START, this);\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeStart();\n    }\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      const accessorName = attribute.settings.accessor;\n      attribute.startIndices = startIndices;\n      attribute.numInstances = numInstances;\n      if (props[attributeName]) {\n        log.removed(`props.${attributeName}`, `data.attributes.${attributeName}`)();\n      }\n      if (attribute.setExternalBuffer(buffers[attributeName])) {\n        // Step 1: try update attribute directly from external buffers\n      } else if (attribute.setBinaryValue(typeof accessorName === 'string' ? buffers[accessorName] : undefined, data.startIndices)) {\n        // Step 2: try set packed value from external typed array\n      } else if (typeof accessorName === 'string' && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {\n        // Step 3: try set constant value from props\n        // Note: if buffers[accessorName] is supplied, ignore props[accessorName]\n        // This may happen when setBinaryValue falls through to use the auto updater\n      } else if (attribute.needsUpdate()) {\n        // Step 4: update via updater callback\n        updated = true;\n        this._updateAttribute({\n          attribute,\n          numInstances,\n          data,\n          props,\n          context\n        });\n      }\n      this.needsRedraw = this.needsRedraw || attribute.needsRedraw();\n    }\n    if (updated) {\n      // Only initiate alloc/update (and logging) if actually needed\n      debug(TRACE_UPDATE_END, this, numInstances);\n    }\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeEnd();\n    }\n    this.attributeTransitionManager.update({\n      attributes: this.attributes,\n      numInstances,\n      transitions\n    });\n  }\n  // Update attribute transition to the current timestamp\n  // Returns `true` if any transition is in progress\n  updateTransition() {\n    const {\n      attributeTransitionManager\n    } = this;\n    const transitionUpdated = attributeTransitionManager.run();\n    this.needsRedraw = this.needsRedraw || transitionUpdated;\n    return transitionUpdated;\n  }\n  /**\n   * Returns all attribute descriptors\n   * Note: Format matches luma.gl Model/Program.setAttributes()\n   * @return {Object} attributes - descriptors\n   */\n  getAttributes() {\n    return {\n      ...this.attributes,\n      ...this.attributeTransitionManager.getAttributes()\n    };\n  }\n  /**\n   * Computes the spatial bounds of a given set of attributes\n   */\n  getBounds(attributeNames) {\n    const bounds = attributeNames.map(attributeName => this.attributes[attributeName]?.getBounds());\n    return this.mergeBoundsMemoized(bounds);\n  }\n  /**\n   * Returns changed attribute descriptors\n   * This indicates which WebGLBuffers need to be updated\n   * @return {Object} attributes - descriptors\n   */\n  getChangedAttributes(opts = {\n    clearChangedFlags: false\n  }) {\n    const {\n      attributes,\n      attributeTransitionManager\n    } = this;\n    const changedAttributes = {\n      ...attributeTransitionManager.getAttributes()\n    };\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {\n        changedAttributes[attributeName] = attribute;\n      }\n    }\n    return changedAttributes;\n  }\n  /** Generate WebGPU-style buffer layout descriptors from all attributes */\n  getBufferLayouts(/** A luma.gl Model-shaped object that supplies additional hint to attribute resolution */\n  modelInfo) {\n    return Object.values(this.getAttributes()).map(attribute => attribute.getBufferLayout(modelInfo));\n  }\n  // PRIVATE METHODS\n  /** Register new attributes */\n  _add(/** A map from attribute name to attribute descriptors */\n  attributes, /** Additional attribute settings to pass to all attributes */\n  overrideOptions) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const props = {\n        ...attribute,\n        id: attributeName,\n        size: attribute.isIndexed && 1 || attribute.size || 1,\n        ...overrideOptions\n      };\n      // Initialize the attribute descriptor, with WebGL and metadata fields\n      this.attributes[attributeName] = new Attribute(this.device, props);\n    }\n    this._mapUpdateTriggersToAttributes();\n  }\n  // build updateTrigger name to attribute name mapping\n  _mapUpdateTriggersToAttributes() {\n    const triggers = {};\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      attribute.getUpdateTriggers().forEach(triggerName => {\n        if (!triggers[triggerName]) {\n          triggers[triggerName] = [];\n        }\n        triggers[triggerName].push(attributeName);\n      });\n    }\n    this.updateTriggers = triggers;\n  }\n  _invalidateTrigger(triggerName, dataRange) {\n    const {\n      attributes,\n      updateTriggers\n    } = this;\n    const invalidatedAttributes = updateTriggers[triggerName];\n    if (invalidatedAttributes) {\n      invalidatedAttributes.forEach(name => {\n        const attribute = attributes[name];\n        if (attribute) {\n          attribute.setNeedsUpdate(attribute.id, dataRange);\n        }\n      });\n    }\n    return invalidatedAttributes;\n  }\n  _updateAttribute(opts) {\n    const {\n      attribute,\n      numInstances\n    } = opts;\n    debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);\n    if (attribute.constant) {\n      // The attribute is flagged as constant outside of an update cycle\n      // Skip allocation and updater call\n      // @ts-ignore value can be set to an array by user but always cast to typed array during attribute update\n      attribute.setConstantValue(attribute.value);\n      return;\n    }\n    if (attribute.allocate(numInstances)) {\n      debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);\n    }\n    // Calls update on any buffers that need update\n    const updated = attribute.updateBuffer(opts);\n    if (updated) {\n      this.needsRedraw = true;\n      debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);\n    }\n  }\n}\n//# sourceMappingURL=attribute-manager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}