{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\nimport { createProtoFeature } from \"./proto-feature.js\";\n/* eslint-disable no-continue */\n/**\n * Clip features between two vertical or horizontal axis-parallel lines:\n *     |        |\n *  ___|___     |     /\n * /   |   \\____|____/\n *     |        |\n *\n * @param k1 and k2 are the line coordinates\n * @param axis: 0 for x, 1 for y\n * @param minAll and maxAll: minimum and maximum coordinate value for all features\n */\n// eslint-disable-next-line max-params, complexity, max-statements\nexport function clipFeatures(features, scale, k1, k2, axis, minAll, maxAll, options) {\n  k1 /= scale;\n  k2 /= scale;\n  if (minAll >= k1 && maxAll < k2) {\n    return features;\n  }\n  // trivial accept\n  else if (maxAll < k1 || minAll >= k2) {\n    return null; // trivial reject\n  }\n  const clipped = [];\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    let type = feature.type;\n    const min = axis === 0 ? feature.minX : feature.minY;\n    const max = axis === 0 ? feature.maxX : feature.maxY;\n    if (min >= k1 && max < k2) {\n      // trivial accept\n      clipped.push(feature);\n      continue;\n    } else if (max < k1 || min >= k2) {\n      // trivial reject\n      continue;\n    }\n    let newGeometry = [];\n    if (type === 'Point' || type === 'MultiPoint') {\n      clipPoints(geometry, newGeometry, k1, k2, axis);\n    } else if (type === 'LineString') {\n      clipLine(geometry, newGeometry, k1, k2, axis, false, options.lineMetrics);\n    } else if (type === 'MultiLineString') {\n      clipLines(geometry, newGeometry, k1, k2, axis, false);\n    } else if (type === 'Polygon') {\n      clipLines(geometry, newGeometry, k1, k2, axis, true);\n    } else if (type === 'MultiPolygon') {\n      for (const polygon of geometry) {\n        const newPolygon = [];\n        clipLines(polygon, newPolygon, k1, k2, axis, true);\n        if (newPolygon.length) {\n          newGeometry.push(newPolygon);\n        }\n      }\n    }\n    if (newGeometry.length) {\n      if (options.lineMetrics && type === 'LineString') {\n        for (const line of newGeometry) {\n          clipped.push(createProtoFeature(feature.id, type, line, feature.tags));\n        }\n        continue;\n      }\n      if (type === 'LineString' || type === 'MultiLineString') {\n        if (newGeometry.length === 1) {\n          type = 'LineString';\n          // @ts-expect-error TODO - use proper GeoJSON geometry types\n          newGeometry = newGeometry[0];\n        } else {\n          type = 'MultiLineString';\n        }\n      }\n      if (type === 'Point' || type === 'MultiPoint') {\n        type = newGeometry.length === 3 ? 'Point' : 'MultiPoint';\n      }\n      clipped.push(createProtoFeature(feature.id, type, newGeometry, feature.tags));\n    }\n  }\n  return clipped.length ? clipped : null;\n}\nfunction clipPoints(geom, newGeom, k1, k2, axis) {\n  for (let i = 0; i < geom.length; i += 3) {\n    const a = geom[i + axis];\n    if (a >= k1 && a <= k2) {\n      addPoint(newGeom, geom[i], geom[i + 1], geom[i + 2]);\n    }\n  }\n}\n// eslint-disable-next-line max-params, complexity, max-statements\nfunction clipLine(geom, newGeom, k1, k2, axis, isPolygon, trackMetrics) {\n  let slice = newSlice(geom);\n  const intersect = axis === 0 ? intersectX : intersectY;\n  let len = geom.start;\n  let segLen;\n  let t;\n  for (let i = 0; i < geom.length - 3; i += 3) {\n    const ax = geom[i];\n    const ay = geom[i + 1];\n    const az = geom[i + 2];\n    const bx = geom[i + 3];\n    const by = geom[i + 4];\n    const a = axis === 0 ? ax : ay;\n    const b = axis === 0 ? bx : by;\n    let exited = false;\n    if (trackMetrics) {\n      segLen = Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));\n    }\n    if (a < k1) {\n      // ---|-->  | (line enters the clip region from the left)\n      if (b > k1) {\n        t = intersect(slice, ax, ay, bx, by, k1);\n        if (trackMetrics) {\n          slice.start = len + segLen * t;\n        }\n      }\n    } else if (a > k2) {\n      // |  <--|--- (line enters the clip region from the right)\n      if (b < k2) {\n        t = intersect(slice, ax, ay, bx, by, k2);\n        if (trackMetrics) {\n          slice.start = len + segLen * t;\n        }\n      }\n    } else {\n      addPoint(slice, ax, ay, az);\n    }\n    if (b < k1 && a >= k1) {\n      // <--|---  | or <--|-----|--- (line exits the clip region on the left)\n      t = intersect(slice, ax, ay, bx, by, k1);\n      exited = true;\n    }\n    if (b > k2 && a <= k2) {\n      // |  ---|--> or ---|-----|--> (line exits the clip region on the right)\n      t = intersect(slice, ax, ay, bx, by, k2);\n      exited = true;\n    }\n    if (!isPolygon && exited) {\n      if (trackMetrics) {\n        slice.end = len + segLen * t;\n      }\n      newGeom.push(slice);\n      slice = newSlice(geom);\n    }\n    if (trackMetrics) {\n      len += segLen;\n    }\n  }\n  // add the last point\n  let last = geom.length - 3;\n  const ax = geom[last];\n  const ay = geom[last + 1];\n  const az = geom[last + 2];\n  const a = axis === 0 ? ax : ay;\n  if (a >= k1 && a <= k2) addPoint(slice, ax, ay, az);\n  // close the polygon if its endpoints are not the same after clipping\n  last = slice.length - 3;\n  if (isPolygon && last >= 3 && (slice[last] !== slice[0] || slice[last + 1] !== slice[1])) {\n    addPoint(slice, slice[0], slice[1], slice[2]);\n  }\n  // add the final slice\n  if (slice.length) {\n    newGeom.push(slice);\n  }\n}\nclass Slice extends Array {\n  size;\n  start;\n  end;\n}\nfunction newSlice(line) {\n  const slice = [];\n  slice.size = line.size;\n  slice.start = line.start;\n  slice.end = line.end;\n  return slice;\n}\n// eslint-disable-next-line max-params\nfunction clipLines(geom, newGeom, k1, k2, axis, isPolygon) {\n  for (const line of geom) {\n    clipLine(line, newGeom, k1, k2, axis, isPolygon, false);\n  }\n}\nfunction addPoint(out, x, y, z) {\n  out.push(x, y, z);\n}\n// eslint-disable-next-line max-params\nfunction intersectX(out, ax, ay, bx, by, x) {\n  const t = (x - ax) / (bx - ax);\n  addPoint(out, x, ay + (by - ay) * t, 1);\n  return t;\n}\n// eslint-disable-next-line max-params\nfunction intersectY(out, ax, ay, bx, by, y) {\n  const t = (y - ay) / (by - ay);\n  addPoint(out, ax + (bx - ax) * t, y, 1);\n  return t;\n}","map":{"version":3,"names":["createProtoFeature","clipFeatures","features","scale","k1","k2","axis","minAll","maxAll","options","clipped","feature","geometry","type","min","minX","minY","max","maxX","maxY","push","newGeometry","clipPoints","clipLine","lineMetrics","clipLines","polygon","newPolygon","length","line","id","tags","geom","newGeom","i","a","addPoint","isPolygon","trackMetrics","slice","newSlice","intersect","intersectX","intersectY","len","start","segLen","t","ax","ay","az","bx","by","b","exited","Math","sqrt","pow","end","last","Slice","Array","size","out","x","y","z"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/mvt/dist/lib/vector-tiler/features/clip-features.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\nimport { createProtoFeature } from \"./proto-feature.js\";\n/* eslint-disable no-continue */\n/**\n * Clip features between two vertical or horizontal axis-parallel lines:\n *     |        |\n *  ___|___     |     /\n * /   |   \\____|____/\n *     |        |\n *\n * @param k1 and k2 are the line coordinates\n * @param axis: 0 for x, 1 for y\n * @param minAll and maxAll: minimum and maximum coordinate value for all features\n */\n// eslint-disable-next-line max-params, complexity, max-statements\nexport function clipFeatures(features, scale, k1, k2, axis, minAll, maxAll, options) {\n    k1 /= scale;\n    k2 /= scale;\n    if (minAll >= k1 && maxAll < k2) {\n        return features;\n    }\n    // trivial accept\n    else if (maxAll < k1 || minAll >= k2) {\n        return null; // trivial reject\n    }\n    const clipped = [];\n    for (const feature of features) {\n        const geometry = feature.geometry;\n        let type = feature.type;\n        const min = axis === 0 ? feature.minX : feature.minY;\n        const max = axis === 0 ? feature.maxX : feature.maxY;\n        if (min >= k1 && max < k2) {\n            // trivial accept\n            clipped.push(feature);\n            continue;\n        }\n        else if (max < k1 || min >= k2) {\n            // trivial reject\n            continue;\n        }\n        let newGeometry = [];\n        if (type === 'Point' || type === 'MultiPoint') {\n            clipPoints(geometry, newGeometry, k1, k2, axis);\n        }\n        else if (type === 'LineString') {\n            clipLine(geometry, newGeometry, k1, k2, axis, false, options.lineMetrics);\n        }\n        else if (type === 'MultiLineString') {\n            clipLines(geometry, newGeometry, k1, k2, axis, false);\n        }\n        else if (type === 'Polygon') {\n            clipLines(geometry, newGeometry, k1, k2, axis, true);\n        }\n        else if (type === 'MultiPolygon') {\n            for (const polygon of geometry) {\n                const newPolygon = [];\n                clipLines(polygon, newPolygon, k1, k2, axis, true);\n                if (newPolygon.length) {\n                    newGeometry.push(newPolygon);\n                }\n            }\n        }\n        if (newGeometry.length) {\n            if (options.lineMetrics && type === 'LineString') {\n                for (const line of newGeometry) {\n                    clipped.push(createProtoFeature(feature.id, type, line, feature.tags));\n                }\n                continue;\n            }\n            if (type === 'LineString' || type === 'MultiLineString') {\n                if (newGeometry.length === 1) {\n                    type = 'LineString';\n                    // @ts-expect-error TODO - use proper GeoJSON geometry types\n                    newGeometry = newGeometry[0];\n                }\n                else {\n                    type = 'MultiLineString';\n                }\n            }\n            if (type === 'Point' || type === 'MultiPoint') {\n                type = newGeometry.length === 3 ? 'Point' : 'MultiPoint';\n            }\n            clipped.push(createProtoFeature(feature.id, type, newGeometry, feature.tags));\n        }\n    }\n    return clipped.length ? clipped : null;\n}\nfunction clipPoints(geom, newGeom, k1, k2, axis) {\n    for (let i = 0; i < geom.length; i += 3) {\n        const a = geom[i + axis];\n        if (a >= k1 && a <= k2) {\n            addPoint(newGeom, geom[i], geom[i + 1], geom[i + 2]);\n        }\n    }\n}\n// eslint-disable-next-line max-params, complexity, max-statements\nfunction clipLine(geom, newGeom, k1, k2, axis, isPolygon, trackMetrics) {\n    let slice = newSlice(geom);\n    const intersect = axis === 0 ? intersectX : intersectY;\n    let len = geom.start;\n    let segLen;\n    let t;\n    for (let i = 0; i < geom.length - 3; i += 3) {\n        const ax = geom[i];\n        const ay = geom[i + 1];\n        const az = geom[i + 2];\n        const bx = geom[i + 3];\n        const by = geom[i + 4];\n        const a = axis === 0 ? ax : ay;\n        const b = axis === 0 ? bx : by;\n        let exited = false;\n        if (trackMetrics) {\n            segLen = Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));\n        }\n        if (a < k1) {\n            // ---|-->  | (line enters the clip region from the left)\n            if (b > k1) {\n                t = intersect(slice, ax, ay, bx, by, k1);\n                if (trackMetrics) {\n                    slice.start = len + segLen * t;\n                }\n            }\n        }\n        else if (a > k2) {\n            // |  <--|--- (line enters the clip region from the right)\n            if (b < k2) {\n                t = intersect(slice, ax, ay, bx, by, k2);\n                if (trackMetrics) {\n                    slice.start = len + segLen * t;\n                }\n            }\n        }\n        else {\n            addPoint(slice, ax, ay, az);\n        }\n        if (b < k1 && a >= k1) {\n            // <--|---  | or <--|-----|--- (line exits the clip region on the left)\n            t = intersect(slice, ax, ay, bx, by, k1);\n            exited = true;\n        }\n        if (b > k2 && a <= k2) {\n            // |  ---|--> or ---|-----|--> (line exits the clip region on the right)\n            t = intersect(slice, ax, ay, bx, by, k2);\n            exited = true;\n        }\n        if (!isPolygon && exited) {\n            if (trackMetrics) {\n                slice.end = len + segLen * t;\n            }\n            newGeom.push(slice);\n            slice = newSlice(geom);\n        }\n        if (trackMetrics) {\n            len += segLen;\n        }\n    }\n    // add the last point\n    let last = geom.length - 3;\n    const ax = geom[last];\n    const ay = geom[last + 1];\n    const az = geom[last + 2];\n    const a = axis === 0 ? ax : ay;\n    if (a >= k1 && a <= k2)\n        addPoint(slice, ax, ay, az);\n    // close the polygon if its endpoints are not the same after clipping\n    last = slice.length - 3;\n    if (isPolygon && last >= 3 && (slice[last] !== slice[0] || slice[last + 1] !== slice[1])) {\n        addPoint(slice, slice[0], slice[1], slice[2]);\n    }\n    // add the final slice\n    if (slice.length) {\n        newGeom.push(slice);\n    }\n}\nclass Slice extends Array {\n    size;\n    start;\n    end;\n}\nfunction newSlice(line) {\n    const slice = [];\n    slice.size = line.size;\n    slice.start = line.start;\n    slice.end = line.end;\n    return slice;\n}\n// eslint-disable-next-line max-params\nfunction clipLines(geom, newGeom, k1, k2, axis, isPolygon) {\n    for (const line of geom) {\n        clipLine(line, newGeom, k1, k2, axis, isPolygon, false);\n    }\n}\nfunction addPoint(out, x, y, z) {\n    out.push(x, y, z);\n}\n// eslint-disable-next-line max-params\nfunction intersectX(out, ax, ay, bx, by, x) {\n    const t = (x - ax) / (bx - ax);\n    addPoint(out, x, ay + (by - ay) * t, 1);\n    return t;\n}\n// eslint-disable-next-line max-params\nfunction intersectY(out, ax, ay, bx, by, y) {\n    const t = (y - ay) / (by - ay);\n    addPoint(out, ax + (bx - ax) * t, y, 1);\n    return t;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}