{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { createElement } from 'react';\nimport { View } from '@deck.gl/core';\nimport { inheritsFrom } from \"./inherits-from.js\";\nimport evaluateChildren, { isComponent } from \"./evaluate-children.js\";\nimport { DeckGlContext } from \"./deckgl-context.js\";\n// Iterate over views and reposition children associated with views\n// TODO - Can we supply a similar function for the non-React case?\nexport default function positionChildrenUnderViews({\n  children,\n  deck,\n  ContextProvider = DeckGlContext.Provider\n}) {\n  // @ts-expect-error accessing protected property\n  const {\n    viewManager\n  } = deck || {};\n  if (!viewManager || !viewManager.views.length) {\n    return [];\n  }\n  const views = {};\n  const defaultViewId = viewManager.views[0].id;\n  // Sort children by view id\n  for (const child of children) {\n    // Unless child is a View, position / render as part of the default view\n    let viewId = defaultViewId;\n    let viewChildren = child;\n    if (isComponent(child) && inheritsFrom(child.type, View)) {\n      viewId = child.props.id || defaultViewId;\n      viewChildren = child.props.children;\n    }\n    const viewport = viewManager.getViewport(viewId);\n    const viewState = viewManager.getViewState(viewId);\n    // Drop (auto-hide) elements with viewId that are not matched by any current view\n    if (viewport) {\n      viewState.padding = viewport.padding;\n      const {\n        x,\n        y,\n        width,\n        height\n      } = viewport;\n      // Resolve potentially relative dimensions using the deck.gl container size\n      viewChildren = evaluateChildren(viewChildren, {\n        x,\n        y,\n        width,\n        height,\n        viewport,\n        viewState\n      });\n      if (!views[viewId]) {\n        views[viewId] = {\n          viewport,\n          children: []\n        };\n      }\n      views[viewId].children.push(viewChildren);\n    }\n  }\n  // Render views\n  return Object.keys(views).map(viewId => {\n    const {\n      viewport,\n      children: viewChildren\n    } = views[viewId];\n    const {\n      x,\n      y,\n      width,\n      height\n    } = viewport;\n    const style = {\n      position: 'absolute',\n      left: x,\n      top: y,\n      width,\n      height\n    };\n    const key = `view-${viewId}`;\n    // If children is passed as an array, React will throw the \"each element in a list needs\n    // a key\" warning. Sending each child as separate arguments removes this requirement.\n    const viewElement = createElement('div', {\n      key,\n      id: key,\n      style\n    }, ...viewChildren);\n    const contextValue = {\n      deck,\n      viewport,\n      // @ts-expect-error accessing protected property\n      container: deck.canvas.offsetParent,\n      // @ts-expect-error accessing protected property\n      eventManager: deck.eventManager,\n      onViewStateChange: params => {\n        params.viewId = viewId;\n        // @ts-expect-error accessing protected method\n        deck._onViewStateChange(params);\n      },\n      widgets: []\n    };\n    const providerKey = `view-${viewId}-context`;\n    return createElement(ContextProvider, {\n      key: providerKey,\n      value: contextValue\n    }, viewElement);\n  });\n}","map":{"version":3,"names":["createElement","View","inheritsFrom","evaluateChildren","isComponent","DeckGlContext","positionChildrenUnderViews","children","deck","ContextProvider","Provider","viewManager","views","length","defaultViewId","id","child","viewId","viewChildren","type","props","viewport","getViewport","viewState","getViewState","padding","x","y","width","height","push","Object","keys","map","style","position","left","top","key","viewElement","contextValue","container","canvas","offsetParent","eventManager","onViewStateChange","params","_onViewStateChange","widgets","providerKey","value"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\react\\src\\utils\\position-children-under-views.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport * as React from 'react';\nimport {createElement} from 'react';\nimport {View} from '@deck.gl/core';\nimport {inheritsFrom} from './inherits-from';\nimport evaluateChildren, {isComponent} from './evaluate-children';\n\nimport type {ViewOrViews} from '../deckgl';\nimport type {Deck, Viewport} from '@deck.gl/core';\nimport {DeckGlContext, type DeckGLContextValue} from './deckgl-context';\n\n// Iterate over views and reposition children associated with views\n// TODO - Can we supply a similar function for the non-React case?\nexport default function positionChildrenUnderViews<ViewsT extends ViewOrViews>({\n  children,\n  deck,\n  ContextProvider = DeckGlContext.Provider\n}: {\n  children: React.ReactNode[];\n  deck?: Deck<ViewsT>;\n  ContextProvider?: React.Context<DeckGLContextValue>['Provider'];\n}): React.ReactNode[] {\n  // @ts-expect-error accessing protected property\n  const {viewManager} = deck || {};\n\n  if (!viewManager || !viewManager.views.length) {\n    return [];\n  }\n\n  const views: Record<\n    string,\n    {\n      viewport: Viewport;\n      children: React.ReactNode[];\n    }\n  > = {};\n  const defaultViewId = (viewManager.views[0] as View).id;\n\n  // Sort children by view id\n  for (const child of children) {\n    // Unless child is a View, position / render as part of the default view\n    let viewId = defaultViewId;\n    let viewChildren = child;\n\n    if (isComponent(child) && inheritsFrom(child.type, View)) {\n      viewId = child.props.id || defaultViewId;\n      viewChildren = child.props.children;\n    }\n\n    const viewport = viewManager.getViewport(viewId) as Viewport;\n    const viewState = viewManager.getViewState(viewId);\n\n    // Drop (auto-hide) elements with viewId that are not matched by any current view\n    if (viewport) {\n      viewState.padding = viewport.padding;\n      const {x, y, width, height} = viewport;\n      // Resolve potentially relative dimensions using the deck.gl container size\n      viewChildren = evaluateChildren(viewChildren, {\n        x,\n        y,\n        width,\n        height,\n        viewport,\n        viewState\n      });\n\n      if (!views[viewId]) {\n        views[viewId] = {\n          viewport,\n          children: []\n        };\n      }\n      views[viewId].children.push(viewChildren);\n    }\n  }\n\n  // Render views\n  return Object.keys(views).map(viewId => {\n    const {viewport, children: viewChildren} = views[viewId];\n    const {x, y, width, height} = viewport;\n    const style = {\n      position: 'absolute',\n      left: x,\n      top: y,\n      width,\n      height\n    };\n\n    const key = `view-${viewId}`;\n    // If children is passed as an array, React will throw the \"each element in a list needs\n    // a key\" warning. Sending each child as separate arguments removes this requirement.\n    const viewElement = createElement('div', {key, id: key, style}, ...viewChildren);\n\n    const contextValue: DeckGLContextValue = {\n      deck,\n      viewport,\n      // @ts-expect-error accessing protected property\n      container: deck.canvas.offsetParent,\n      // @ts-expect-error accessing protected property\n      eventManager: deck.eventManager,\n      onViewStateChange: params => {\n        params.viewId = viewId;\n        // @ts-expect-error accessing protected method\n        deck._onViewStateChange(params);\n      },\n      widgets: []\n    };\n    const providerKey = `view-${viewId}-context`;\n    return createElement(ContextProvider, {key: providerKey, value: contextValue}, viewElement);\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}