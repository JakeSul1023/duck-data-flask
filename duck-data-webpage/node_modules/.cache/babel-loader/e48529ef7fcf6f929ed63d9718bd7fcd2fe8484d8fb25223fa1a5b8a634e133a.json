{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Layer, project32, picking, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { Model } from '@luma.gl/engine';\nimport { lngLatToWorld } from '@math.gl/web-mercator';\nimport createMesh from \"./create-mesh.js\";\nimport { bitmapUniforms } from \"./bitmap-layer-uniforms.js\";\nimport vs from \"./bitmap-layer-vertex.js\";\nimport fs from \"./bitmap-layer-fragment.js\";\nconst defaultProps = {\n  image: {\n    type: 'image',\n    value: null,\n    async: true\n  },\n  bounds: {\n    type: 'array',\n    value: [1, 0, 0, 1],\n    compare: true\n  },\n  _imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n  desaturate: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 0\n  },\n  // More context: because of the blending mode we're using for ground imagery,\n  // alpha is not effective when blending the bitmap layers with the base map.\n  // Instead we need to manually dim/blend rgb values with a background color.\n  transparentColor: {\n    type: 'color',\n    value: [0, 0, 0, 0]\n  },\n  tintColor: {\n    type: 'color',\n    value: [255, 255, 255]\n  },\n  textureParameters: {\n    type: 'object',\n    ignore: true,\n    value: null\n  }\n};\n/** Render a bitmap at specified boundaries. */\nclass BitmapLayer extends Layer {\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, picking, bitmapUniforms]\n    });\n  }\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    attributeManager.remove(['instancePickingColors']);\n    const noAlloc = true;\n    attributeManager.add({\n      indices: {\n        size: 1,\n        isIndexed: true,\n        update: attribute => attribute.value = this.state.mesh.indices,\n        noAlloc\n      },\n      positions: {\n        size: 3,\n        type: 'float64',\n        fp64: this.use64bitPositions(),\n        update: attribute => attribute.value = this.state.mesh.positions,\n        noAlloc\n      },\n      texCoords: {\n        size: 2,\n        update: attribute => attribute.value = this.state.mesh.texCoords,\n        noAlloc\n      }\n    });\n  }\n  updateState({\n    props,\n    oldProps,\n    changeFlags\n  }) {\n    // setup model first\n    const attributeManager = this.getAttributeManager();\n    if (changeFlags.extensionsChanged) {\n      this.state.model?.destroy();\n      this.state.model = this._getModel();\n      attributeManager.invalidateAll();\n    }\n    if (props.bounds !== oldProps.bounds) {\n      const oldMesh = this.state.mesh;\n      const mesh = this._createMesh();\n      this.state.model.setVertexCount(mesh.vertexCount);\n      for (const key in mesh) {\n        if (oldMesh && oldMesh[key] !== mesh[key]) {\n          attributeManager.invalidate(key);\n        }\n      }\n      this.setState({\n        mesh,\n        ...this._getCoordinateUniforms()\n      });\n    } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {\n      this.setState(this._getCoordinateUniforms());\n    }\n  }\n  getPickingInfo(params) {\n    const {\n      image\n    } = this.props;\n    const info = params.info;\n    if (!info.color || !image) {\n      info.bitmap = null;\n      return info;\n    }\n    const {\n      width,\n      height\n    } = image;\n    // Picking color doesn't represent object index in this layer\n    info.index = 0;\n    // Calculate uv and pixel in bitmap\n    const uv = unpackUVsFromRGB(info.color);\n    info.bitmap = {\n      size: {\n        width,\n        height\n      },\n      uv,\n      pixel: [Math.floor(uv[0] * width), Math.floor(uv[1] * height)]\n    };\n    return info;\n  }\n  // Override base Layer multi-depth picking logic\n  disablePickingIndex() {\n    this.setState({\n      disablePicking: true\n    });\n  }\n  restorePickingColors() {\n    this.setState({\n      disablePicking: false\n    });\n  }\n  _updateAutoHighlight(info) {\n    super._updateAutoHighlight({\n      ...info,\n      color: this.encodePickingColor(0)\n    });\n  }\n  _createMesh() {\n    const {\n      bounds\n    } = this.props;\n    let normalizedBounds = bounds;\n    // bounds as [minX, minY, maxX, maxY]\n    if (isRectangularBounds(bounds)) {\n      /*\n        (minX0, maxY3) ---- (maxX2, maxY3)\n               |                  |\n               |                  |\n               |                  |\n        (minX0, minY1) ---- (maxX2, minY1)\n      */\n      normalizedBounds = [[bounds[0], bounds[1]], [bounds[0], bounds[3]], [bounds[2], bounds[3]], [bounds[2], bounds[1]]];\n    }\n    return createMesh(normalizedBounds, this.context.viewport.resolution);\n  }\n  _getModel() {\n    /*\n      0,0 --- 1,0\n       |       |\n      0,1 --- 1,1\n    */\n    return new Model(this.context.device, {\n      ...this.getShaders(),\n      id: this.props.id,\n      bufferLayout: this.getAttributeManager().getBufferLayouts(),\n      topology: 'triangle-list',\n      isInstanced: false\n    });\n  }\n  draw(opts) {\n    const {\n      shaderModuleProps\n    } = opts;\n    const {\n      model,\n      coordinateConversion,\n      bounds,\n      disablePicking\n    } = this.state;\n    const {\n      image,\n      desaturate,\n      transparentColor,\n      tintColor\n    } = this.props;\n    if (shaderModuleProps.picking.isActive && disablePicking) {\n      return;\n    }\n    // // TODO fix zFighting\n    // Render the image\n    if (image && model) {\n      const bitmapProps = {\n        bitmapTexture: image,\n        bounds,\n        coordinateConversion,\n        desaturate,\n        tintColor: tintColor.slice(0, 3).map(x => x / 255),\n        transparentColor: transparentColor.map(x => x / 255)\n      };\n      model.shaderInputs.setProps({\n        bitmap: bitmapProps\n      });\n      model.draw(this.context.renderPass);\n    }\n  }\n  _getCoordinateUniforms() {\n    const {\n      LNGLAT,\n      CARTESIAN,\n      DEFAULT\n    } = COORDINATE_SYSTEM;\n    let {\n      _imageCoordinateSystem: imageCoordinateSystem\n    } = this.props;\n    if (imageCoordinateSystem !== DEFAULT) {\n      const {\n        bounds\n      } = this.props;\n      if (!isRectangularBounds(bounds)) {\n        throw new Error('_imageCoordinateSystem only supports rectangular bounds');\n      }\n      // The default behavior (linearly interpolated tex coords)\n      const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;\n      imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;\n      if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {\n        // LNGLAT in Mercator, e.g. display LNGLAT-encoded image in WebMercator projection\n        return {\n          coordinateConversion: -1,\n          bounds\n        };\n      }\n      if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {\n        // Mercator in LNGLAT, e.g. display WebMercator encoded image in Globe projection\n        const bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);\n        const topRight = lngLatToWorld([bounds[2], bounds[3]]);\n        return {\n          coordinateConversion: 1,\n          bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]\n        };\n      }\n    }\n    return {\n      coordinateConversion: 0,\n      bounds: [0, 0, 0, 0]\n    };\n  }\n}\nBitmapLayer.layerName = 'BitmapLayer';\nBitmapLayer.defaultProps = defaultProps;\nexport default BitmapLayer;\n/**\n * Decode uv floats from rgb bytes where b contains 4-bit fractions of uv\n * @param {number[]} color\n * @returns {number[]} uvs\n * https://stackoverflow.com/questions/30242013/glsl-compressing-packing-multiple-0-1-colours-var4-into-a-single-var4-variab\n */\nfunction unpackUVsFromRGB(color) {\n  const [u, v, fracUV] = color;\n  const vFrac = (fracUV & 0xf0) / 256;\n  const uFrac = (fracUV & 0x0f) / 16;\n  return [(u + uFrac) / 256, (v + vFrac) / 256];\n}\nfunction isRectangularBounds(bounds) {\n  return Number.isFinite(bounds[0]);\n}","map":{"version":3,"names":["Layer","project32","picking","COORDINATE_SYSTEM","Model","lngLatToWorld","createMesh","bitmapUniforms","vs","fs","defaultProps","image","type","value","async","bounds","compare","_imageCoordinateSystem","DEFAULT","desaturate","min","max","transparentColor","tintColor","textureParameters","ignore","BitmapLayer","getShaders","modules","initializeState","attributeManager","getAttributeManager","remove","noAlloc","add","indices","size","isIndexed","update","attribute","state","mesh","positions","fp64","use64bitPositions","texCoords","updateState","props","oldProps","changeFlags","extensionsChanged","model","destroy","_getModel","invalidateAll","oldMesh","_createMesh","setVertexCount","vertexCount","key","invalidate","setState","_getCoordinateUniforms","getPickingInfo","params","info","color","bitmap","width","height","index","uv","unpackUVsFromRGB","pixel","Math","floor","disablePickingIndex","disablePicking","restorePickingColors","_updateAutoHighlight","encodePickingColor","normalizedBounds","isRectangularBounds","context","viewport","resolution","device","id","bufferLayout","getBufferLayouts","topology","isInstanced","draw","opts","shaderModuleProps","coordinateConversion","isActive","bitmapProps","bitmapTexture","slice","map","x","shaderInputs","setProps","renderPass","LNGLAT","CARTESIAN","imageCoordinateSystem","Error","defaultImageCoordinateSystem","bottomLeft","topRight","layerName","u","v","fracUV","vFrac","uFrac","Number","isFinite"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\layers\\src\\bitmap-layer\\bitmap-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  Layer,\n  project32,\n  picking,\n  CoordinateSystem,\n  COORDINATE_SYSTEM,\n  LayerProps,\n  PickingInfo,\n  GetPickingInfoParams,\n  UpdateParameters,\n  Color,\n  TextureSource,\n  Position,\n  DefaultProps\n} from '@deck.gl/core';\nimport {Model} from '@luma.gl/engine';\nimport type {SamplerProps, Texture} from '@luma.gl/core';\nimport {lngLatToWorld} from '@math.gl/web-mercator';\n\nimport createMesh from './create-mesh';\n\nimport {bitmapUniforms, BitmapProps} from './bitmap-layer-uniforms';\nimport vs from './bitmap-layer-vertex';\nimport fs from './bitmap-layer-fragment';\n\nconst defaultProps: DefaultProps<BitmapLayerProps> = {\n  image: {type: 'image', value: null, async: true},\n  bounds: {type: 'array', value: [1, 0, 0, 1], compare: true},\n  _imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n\n  desaturate: {type: 'number', min: 0, max: 1, value: 0},\n  // More context: because of the blending mode we're using for ground imagery,\n  // alpha is not effective when blending the bitmap layers with the base map.\n  // Instead we need to manually dim/blend rgb values with a background color.\n  transparentColor: {type: 'color', value: [0, 0, 0, 0]},\n  tintColor: {type: 'color', value: [255, 255, 255]},\n\n  textureParameters: {type: 'object', ignore: true, value: null}\n};\n\n/** All properties supported by BitmapLayer. */\nexport type BitmapLayerProps = _BitmapLayerProps & LayerProps;\nexport type BitmapBoundingBox =\n  | [left: number, bottom: number, right: number, top: number]\n  | [Position, Position, Position, Position];\n\n/** Properties added by BitmapLayer. */\ntype _BitmapLayerProps = {\n  data: never;\n  /**\n   * The image to display.\n   *\n   * @default null\n   */\n  image?: string | TextureSource | null;\n\n  /**\n   * Supported formats:\n   *  - Coordinates of the bounding box of the bitmap `[left, bottom, right, top]`\n   *  - Coordinates of four corners of the bitmap, should follow the sequence of `[[left, bottom], [left, top], [right, top], [right, bottom]]`.\n   *   Each position could optionally contain a third component `z`.\n   * @default [1, 0, 0, 1]\n   */\n  bounds?: BitmapBoundingBox;\n\n  /**\n   * > Note: this prop is experimental.\n   *\n   * Specifies how image coordinates should be geographically interpreted.\n   * @default COORDINATE_SYSTEM.DEFAULT\n   */\n  _imageCoordinateSystem?: CoordinateSystem;\n\n  /**\n   * The desaturation of the bitmap. Between `[0, 1]`.\n   * @default 0\n   */\n  desaturate?: number;\n\n  /**\n   * The color to use for transparent pixels, in `[r, g, b, a]`.\n   * @default [0, 0, 0, 0]\n   */\n  transparentColor?: Color;\n\n  /**\n   * The color to tint the bitmap by, in `[r, g, b]`.\n   * @default [255, 255, 255]\n   */\n  tintColor?: Color;\n\n  /** Customize the [texture parameters](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter). */\n  textureParameters?: SamplerProps | null;\n};\n\nexport type BitmapLayerPickingInfo = PickingInfo<\n  null,\n  {\n    bitmap: {\n      /** Size of the original image */\n      size: {\n        width: number;\n        height: number;\n      };\n      /** Hovered pixel uv in 0-1 range */\n      uv: [number, number];\n      /** Hovered pixel in the original image */\n      pixel: [number, number];\n    } | null;\n  }\n>;\n\n/** Render a bitmap at specified boundaries. */\nexport default class BitmapLayer<ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_BitmapLayerProps>\n> {\n  static layerName = 'BitmapLayer';\n  static defaultProps = defaultProps;\n\n  state!: {\n    disablePicking?: boolean;\n    model?: Model;\n    mesh?: any;\n    coordinateConversion: number;\n    bounds: [number, number, number, number];\n  };\n\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking, bitmapUniforms]});\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager()!;\n\n    attributeManager.remove(['instancePickingColors']);\n    const noAlloc = true;\n\n    attributeManager.add({\n      indices: {\n        size: 1,\n        isIndexed: true,\n        update: attribute => (attribute.value = this.state.mesh.indices),\n        noAlloc\n      },\n      positions: {\n        size: 3,\n        type: 'float64',\n        fp64: this.use64bitPositions(),\n        update: attribute => (attribute.value = this.state.mesh.positions),\n        noAlloc\n      },\n      texCoords: {\n        size: 2,\n        update: attribute => (attribute.value = this.state.mesh.texCoords),\n        noAlloc\n      }\n    });\n  }\n\n  updateState({props, oldProps, changeFlags}: UpdateParameters<this>): void {\n    // setup model first\n    const attributeManager = this.getAttributeManager()!;\n\n    if (changeFlags.extensionsChanged) {\n      this.state.model?.destroy();\n      this.state.model = this._getModel();\n      attributeManager.invalidateAll();\n    }\n\n    if (props.bounds !== oldProps.bounds) {\n      const oldMesh = this.state.mesh;\n      const mesh = this._createMesh();\n      this.state.model!.setVertexCount(mesh.vertexCount);\n      for (const key in mesh) {\n        if (oldMesh && oldMesh[key] !== mesh[key]) {\n          attributeManager.invalidate(key);\n        }\n      }\n      this.setState({mesh, ...this._getCoordinateUniforms()});\n    } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {\n      this.setState(this._getCoordinateUniforms());\n    }\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): BitmapLayerPickingInfo {\n    const {image} = this.props;\n    const info = params.info as BitmapLayerPickingInfo;\n\n    if (!info.color || !image) {\n      info.bitmap = null;\n      return info;\n    }\n\n    const {width, height} = image as Texture;\n\n    // Picking color doesn't represent object index in this layer\n    info.index = 0;\n\n    // Calculate uv and pixel in bitmap\n    const uv = unpackUVsFromRGB(info.color);\n\n    info.bitmap = {\n      size: {width, height},\n      uv,\n      pixel: [Math.floor(uv[0] * width), Math.floor(uv[1] * height)]\n    };\n\n    return info;\n  }\n\n  // Override base Layer multi-depth picking logic\n  disablePickingIndex() {\n    this.setState({disablePicking: true});\n  }\n\n  restorePickingColors() {\n    this.setState({disablePicking: false});\n  }\n\n  protected _updateAutoHighlight(info) {\n    super._updateAutoHighlight({\n      ...info,\n      color: this.encodePickingColor(0)\n    });\n  }\n\n  protected _createMesh() {\n    const {bounds} = this.props;\n\n    let normalizedBounds = bounds;\n    // bounds as [minX, minY, maxX, maxY]\n    if (isRectangularBounds(bounds)) {\n      /*\n        (minX0, maxY3) ---- (maxX2, maxY3)\n               |                  |\n               |                  |\n               |                  |\n        (minX0, minY1) ---- (maxX2, minY1)\n     */\n      normalizedBounds = [\n        [bounds[0], bounds[1]],\n        [bounds[0], bounds[3]],\n        [bounds[2], bounds[3]],\n        [bounds[2], bounds[1]]\n      ];\n    }\n\n    return createMesh(normalizedBounds, this.context.viewport.resolution);\n  }\n\n  protected _getModel(): Model {\n    /*\n      0,0 --- 1,0\n       |       |\n      0,1 --- 1,1\n    */\n    return new Model(this.context.device, {\n      ...this.getShaders(),\n      id: this.props.id,\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts(),\n      topology: 'triangle-list',\n      isInstanced: false\n    });\n  }\n\n  draw(opts) {\n    const {shaderModuleProps} = opts;\n    const {model, coordinateConversion, bounds, disablePicking} = this.state;\n    const {image, desaturate, transparentColor, tintColor} = this.props;\n\n    if (shaderModuleProps.picking.isActive && disablePicking) {\n      return;\n    }\n\n    // // TODO fix zFighting\n    // Render the image\n    if (image && model) {\n      const bitmapProps: BitmapProps = {\n        bitmapTexture: image as Texture,\n        bounds,\n        coordinateConversion,\n        desaturate,\n        tintColor: tintColor.slice(0, 3).map(x => x / 255) as [number, number, number],\n        transparentColor: transparentColor.map(x => x / 255) as [number, number, number, number]\n      };\n      model.shaderInputs.setProps({bitmap: bitmapProps});\n      model.draw(this.context.renderPass);\n    }\n  }\n\n  _getCoordinateUniforms() {\n    const {LNGLAT, CARTESIAN, DEFAULT} = COORDINATE_SYSTEM;\n    let {_imageCoordinateSystem: imageCoordinateSystem} = this.props;\n    if (imageCoordinateSystem !== DEFAULT) {\n      const {bounds} = this.props;\n      if (!isRectangularBounds(bounds)) {\n        throw new Error('_imageCoordinateSystem only supports rectangular bounds');\n      }\n\n      // The default behavior (linearly interpolated tex coords)\n      const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;\n      imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;\n\n      if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {\n        // LNGLAT in Mercator, e.g. display LNGLAT-encoded image in WebMercator projection\n        return {coordinateConversion: -1, bounds};\n      }\n      if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {\n        // Mercator in LNGLAT, e.g. display WebMercator encoded image in Globe projection\n        const bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);\n        const topRight = lngLatToWorld([bounds[2], bounds[3]]);\n        return {\n          coordinateConversion: 1,\n          bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]\n        };\n      }\n    }\n    return {\n      coordinateConversion: 0,\n      bounds: [0, 0, 0, 0]\n    };\n  }\n}\n\n/**\n * Decode uv floats from rgb bytes where b contains 4-bit fractions of uv\n * @param {number[]} color\n * @returns {number[]} uvs\n * https://stackoverflow.com/questions/30242013/glsl-compressing-packing-multiple-0-1-colours-var4-into-a-single-var4-variab\n */\nfunction unpackUVsFromRGB(color: Uint8Array): [number, number] {\n  const [u, v, fracUV] = color;\n  const vFrac = (fracUV & 0xf0) / 256;\n  const uFrac = (fracUV & 0x0f) / 16;\n  return [(u + uFrac) / 256, (v + vFrac) / 256];\n}\n\nfunction isRectangularBounds(\n  bounds: [number, number, number, number] | [Position, Position, Position, Position]\n): bounds is [number, number, number, number] {\n  return Number.isFinite(bounds[0]);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}