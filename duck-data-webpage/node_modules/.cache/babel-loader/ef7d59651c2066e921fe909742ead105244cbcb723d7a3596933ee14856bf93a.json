{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { createTexture, destroyTexture } from \"../utils/texture.js\";\nimport { deepEqual } from \"../utils/deep-equal.js\";\nconst TYPE_DEFINITIONS = {\n  boolean: {\n    validate(value, propType) {\n      return true;\n    },\n    equal(value1, value2, propType) {\n      return Boolean(value1) === Boolean(value2);\n    }\n  },\n  number: {\n    validate(value, propType) {\n      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);\n    }\n  },\n  color: {\n    validate(value, propType) {\n      return propType.optional && !value || isArray(value) && (value.length === 3 || value.length === 4);\n    },\n    equal(value1, value2, propType) {\n      return deepEqual(value1, value2, 1);\n    }\n  },\n  accessor: {\n    validate(value, propType) {\n      const valueType = getTypeOf(value);\n      return valueType === 'function' || valueType === getTypeOf(propType.value);\n    },\n    equal(value1, value2, propType) {\n      if (typeof value2 === 'function') {\n        return true;\n      }\n      return deepEqual(value1, value2, 1);\n    }\n  },\n  array: {\n    validate(value, propType) {\n      return propType.optional && !value || isArray(value);\n    },\n    equal(value1, value2, propType) {\n      const {\n        compare\n      } = propType;\n      const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;\n      return compare ? deepEqual(value1, value2, depth) : value1 === value2;\n    }\n  },\n  object: {\n    equal(value1, value2, propType) {\n      if (propType.ignore) {\n        return true;\n      }\n      const {\n        compare\n      } = propType;\n      const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;\n      return compare ? deepEqual(value1, value2, depth) : value1 === value2;\n    }\n  },\n  function: {\n    validate(value, propType) {\n      return propType.optional && !value || typeof value === 'function';\n    },\n    equal(value1, value2, propType) {\n      // Backward compatibility - {compare: true} and {ignore: false} are equivalent\n      const shouldIgnore = !propType.compare && propType.ignore !== false;\n      return shouldIgnore || value1 === value2;\n    }\n  },\n  data: {\n    transform: (value, propType, component) => {\n      if (!value) {\n        return value;\n      }\n      const {\n        dataTransform\n      } = component.props;\n      if (dataTransform) {\n        return dataTransform(value);\n      }\n      // Detect loaders.gl v4 table format\n      if (typeof value.shape === 'string' && value.shape.endsWith('-table') && Array.isArray(value.data)) {\n        return value.data;\n      }\n      return value;\n    }\n  },\n  image: {\n    transform: (value, propType, component) => {\n      const context = component.context;\n      if (!context || !context.device) {\n        return null;\n      }\n      return createTexture(component.id, context.device, value, {\n        ...propType.parameters,\n        ...component.props.textureParameters\n      });\n    },\n    release: (value, propType, component) => {\n      destroyTexture(component.id, value);\n    }\n  }\n};\nexport function parsePropTypes(propDefs) {\n  const propTypes = {};\n  const defaultProps = {};\n  const deprecatedProps = {};\n  for (const [propName, propDef] of Object.entries(propDefs)) {\n    const deprecated = propDef?.deprecatedFor;\n    if (deprecated) {\n      deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];\n    } else {\n      const propType = parsePropType(propName, propDef);\n      propTypes[propName] = propType;\n      defaultProps[propName] = propType.value;\n    }\n  }\n  return {\n    propTypes,\n    defaultProps,\n    deprecatedProps\n  };\n}\n// Parses one property definition entry. Either contains:\n// * a valid prop type object ({type, ...})\n// * or just a default value, in which case type and name inference is used\nfunction parsePropType(name, propDef) {\n  switch (getTypeOf(propDef)) {\n    case 'object':\n      return normalizePropDefinition(name, propDef);\n    case 'array':\n      return normalizePropDefinition(name, {\n        type: 'array',\n        value: propDef,\n        compare: false\n      });\n    case 'boolean':\n      return normalizePropDefinition(name, {\n        type: 'boolean',\n        value: propDef\n      });\n    case 'number':\n      return normalizePropDefinition(name, {\n        type: 'number',\n        value: propDef\n      });\n    case 'function':\n      // return guessFunctionType(name, propDef);\n      return normalizePropDefinition(name, {\n        type: 'function',\n        value: propDef,\n        compare: true\n      });\n    default:\n      return {\n        name,\n        type: 'unknown',\n        value: propDef\n      };\n  }\n}\nfunction normalizePropDefinition(name, propDef) {\n  if (!('type' in propDef)) {\n    if (!('value' in propDef)) {\n      // If no type and value this object is likely the value\n      return {\n        name,\n        type: 'object',\n        value: propDef\n      };\n    }\n    return {\n      name,\n      type: getTypeOf(propDef.value),\n      ...propDef\n    };\n  }\n  return {\n    name,\n    ...TYPE_DEFINITIONS[propDef.type],\n    ...propDef\n  };\n}\nfunction isArray(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value);\n}\n// improved version of javascript typeof that can distinguish arrays and null values\nfunction getTypeOf(value) {\n  if (isArray(value)) {\n    return 'array';\n  }\n  if (value === null) {\n    return 'null';\n  }\n  return typeof value;\n}\n//# sourceMappingURL=prop-types.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}