{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { VertexArray, getScratchArray } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\nimport { getBrowser } from '@probe.gl/env';\nimport { getGLFromVertexType } from \"../converters/vertex-formats.js\";\nimport { fillArray } from \"../../utils/fill-array.js\";\n/** VertexArrayObject wrapper */\nexport class WEBGLVertexArray extends VertexArray {\n  get [Symbol.toStringTag]() {\n    return 'VertexArray';\n  }\n  device;\n  handle;\n  /** Attribute 0 buffer constant */\n  buffer = null;\n  bufferValue = null;\n  /** * Attribute 0 can not be disable on most desktop OpenGL based browsers */\n  static isConstantAttributeZeroSupported(device) {\n    return getBrowser() === 'Chrome';\n  }\n  // Create a VertexArray\n  constructor(device, props) {\n    super(device, props);\n    this.device = device;\n    this.handle = this.device.gl.createVertexArray();\n  }\n  destroy() {\n    super.destroy();\n    if (this.buffer) {\n      this.buffer?.destroy();\n    }\n    if (this.handle) {\n      this.device.gl.deleteVertexArray(this.handle);\n      // @ts-expect-error read-only/undefined\n      this.handle = undefined;\n    }\n    // Auto-delete elements?\n    // return [this.elements];\n  }\n  /**\n  // Set (bind/unbind) an elements buffer, for indexed rendering.\n  // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER or null. Constants not supported\n   *\n   * @param elementBuffer\n   */\n  setIndexBuffer(indexBuffer) {\n    const buffer = indexBuffer;\n    // Explicitly allow `null` to support clearing the index buffer\n    if (buffer && buffer.glTarget !== 34963) {\n      throw new Error('Use .setBuffer()');\n    }\n    // In WebGL The GL.ELEMENT_ARRAY_BUFFER_BINDING is stored on the VertexArrayObject\n    this.device.gl.bindVertexArray(this.handle);\n    this.device.gl.bindBuffer(34963, buffer ? buffer.handle : null);\n    this.indexBuffer = buffer;\n    // Unbind to prevent unintended changes to the VAO.\n    this.device.gl.bindVertexArray(null);\n  }\n  /** Set a location in vertex attributes array to a buffer, enables the location, sets divisor */\n  setBuffer(location, attributeBuffer) {\n    const buffer = attributeBuffer;\n    // Sanity check target\n    if (buffer.glTarget === 34963) {\n      throw new Error('Use .setIndexBuffer()');\n    }\n    const {\n      size,\n      type,\n      stride,\n      offset,\n      normalized,\n      integer,\n      divisor\n    } = this._getAccessor(location);\n    this.device.gl.bindVertexArray(this.handle);\n    // A non-zero buffer object must be bound to the GL_ARRAY_BUFFER target\n    this.device.gl.bindBuffer(34962, buffer.handle);\n    // WebGL2 supports *integer* data formats, i.e. GPU will see integer values\n    if (integer) {\n      this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);\n    } else {\n      // Attaches ARRAY_BUFFER with specified buffer format to location\n      this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);\n    }\n    // Clear binding - keeping it may cause [.WebGL-0x12804417100]\n    // GL_INVALID_OPERATION: A transform feedback buffer that would be written to is also bound to a non-transform-feedback target\n    this.device.gl.bindBuffer(34962, null);\n    // Mark as non-constant\n    this.device.gl.enableVertexAttribArray(location);\n    // Set the step mode 0=vertex, 1=instance\n    this.device.gl.vertexAttribDivisor(location, divisor || 0);\n    this.attributes[location] = buffer;\n    // Unbind to prevent unintended changes to the VAO.\n    this.device.gl.bindVertexArray(null);\n  }\n  /** Set a location in vertex attributes array to a constant value, disables the location */\n  setConstantWebGL(location, value) {\n    this._enable(location, false);\n    this.attributes[location] = value;\n  }\n  bindBeforeRender() {\n    this.device.gl.bindVertexArray(this.handle);\n    this._applyConstantAttributes();\n  }\n  unbindAfterRender() {\n    // Unbind to prevent unintended changes to the VAO.\n    this.device.gl.bindVertexArray(null);\n  }\n  // Internal methods\n  /**\n   * Constant attributes need to be reset before every draw call\n   * Any attribute that is disabled in the current vertex array object\n   * is read from the context's global constant value for that attribute location.\n   * @note Constant attributes are only supported in WebGL, not in WebGPU\n   */\n  _applyConstantAttributes() {\n    for (let location = 0; location < this.maxVertexAttributes; ++location) {\n      const constant = this.attributes[location];\n      // A typed array means this is a constant\n      if (ArrayBuffer.isView(constant)) {\n        this.device.setConstantAttributeWebGL(location, constant);\n      }\n    }\n  }\n  /**\n   * Set a location in vertex attributes array to a buffer, enables the location, sets divisor\n   * @note requires vertex array to be bound\n   */\n  // protected _setAttributeLayout(location: number): void {\n  //   const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);\n  //   // WebGL2 supports *integer* data formats, i.e. GPU will see integer values\n  //   if (integer) {\n  //     this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);\n  //   } else {\n  //     // Attaches ARRAY_BUFFER with specified buffer format to location\n  //     this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);\n  //   }\n  //   this.device.gl.vertexAttribDivisor(location, divisor || 0);\n  // }\n  /** Get an accessor from the  */\n  _getAccessor(location) {\n    const attributeInfo = this.attributeInfos[location];\n    if (!attributeInfo) {\n      throw new Error(`Unknown attribute location ${location}`);\n    }\n    const glType = getGLFromVertexType(attributeInfo.bufferDataType);\n    return {\n      size: attributeInfo.bufferComponents,\n      type: glType,\n      stride: attributeInfo.byteStride,\n      offset: attributeInfo.byteOffset,\n      normalized: attributeInfo.normalized,\n      // it is the shader attribute declaration, not the vertex memory format,\n      // that determines if the data in the buffer will be treated as integers.\n      //\n      // Also note that WebGL supports assigning non-normalized integer data to floating point attributes,\n      // but as far as we can tell, WebGPU does not.\n      integer: attributeInfo.integer,\n      divisor: attributeInfo.stepMode === 'instance' ? 1 : 0\n    };\n  }\n  /**\n   * Enabling an attribute location makes it reference the currently bound buffer\n   * Disabling an attribute location makes it reference the global constant value\n   * TODO - handle single values for size 1 attributes?\n   * TODO - convert classic arrays based on known type?\n   */\n  _enable(location, enable = true) {\n    // Attribute 0 cannot be disabled in most desktop OpenGL based browsers...\n    const canDisableAttributeZero = WEBGLVertexArray.isConstantAttributeZeroSupported(this.device);\n    const canDisableAttribute = canDisableAttributeZero || location !== 0;\n    if (enable || canDisableAttribute) {\n      location = Number(location);\n      this.device.gl.bindVertexArray(this.handle);\n      if (enable) {\n        this.device.gl.enableVertexAttribArray(location);\n      } else {\n        this.device.gl.disableVertexAttribArray(location);\n      }\n      this.device.gl.bindVertexArray(null);\n    }\n  }\n  /**\n   * Provide a means to create a buffer that is equivalent to a constant.\n   * NOTE: Desktop OpenGL cannot disable attribute 0.\n   * https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-\n   * this-has-significant-performance-penalty\n   */\n  getConstantBuffer(elementCount, value) {\n    // Create buffer only when needed, and reuse it (avoids inflating buffer creation statistics)\n    const constantValue = normalizeConstantArrayValue(value);\n    const byteLength = constantValue.byteLength * elementCount;\n    const length = constantValue.length * elementCount;\n    if (this.buffer && byteLength !== this.buffer.byteLength) {\n      throw new Error(`Buffer size is immutable, byte length ${byteLength} !== ${this.buffer.byteLength}.`);\n    }\n    let updateNeeded = !this.buffer;\n    this.buffer = this.buffer || this.device.createBuffer({\n      byteLength\n    });\n    // Reallocate and update contents if needed\n    updateNeeded = updateNeeded || !compareConstantArrayValues(constantValue, this.bufferValue);\n    if (updateNeeded) {\n      // Create a typed array that is big enough, and fill it with the required data\n      const typedArray = getScratchArray(value.constructor, length);\n      fillArray({\n        target: typedArray,\n        source: constantValue,\n        start: 0,\n        count: length\n      });\n      this.buffer.write(typedArray);\n      this.bufferValue = value;\n    }\n    return this.buffer;\n  }\n}\n// HELPER FUNCTIONS\n/**\n * TODO - convert Arrays based on known type? (read type from accessor, don't assume Float32Array)\n * TODO - handle single values for size 1 attributes?\n */\nfunction normalizeConstantArrayValue(arrayValue) {\n  if (Array.isArray(arrayValue)) {\n    return new Float32Array(arrayValue);\n  }\n  return arrayValue;\n}\n/**\n *\n */\nfunction compareConstantArrayValues(v1, v2) {\n  if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {\n    return false;\n  }\n  for (let i = 0; i < v1.length; ++i) {\n    if (v1[i] !== v2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n//# sourceMappingURL=webgl-vertex-array.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}