{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Geometry, GroupNode } from '@luma.gl/engine';\nimport { Matrix4 } from '@math.gl/core';\nimport { GLTFAnimator } from \"./gltf-animator.js\";\nimport { createGLTFModel } from \"./create-gltf-model.js\";\nimport { convertGLDrawModeToTopology } from \"./gl-utils.js\";\nconst DEFAULT_OPTIONS = {\n  modelOptions: {},\n  pbrDebug: false,\n  imageBasedLightingEnvironment: null,\n  lights: true,\n  useTangents: false\n};\n/**\n * GLTF instantiator for luma.gl\n * Walks the parsed and resolved glTF structure and builds a luma.gl scenegraph\n */\nexport class GLTFInstantiator {\n  device;\n  options;\n  gltf;\n  constructor(device) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.device = device;\n    this.options = {\n      ...DEFAULT_OPTIONS,\n      ...options\n    };\n  }\n  instantiate(gltf) {\n    this.gltf = deepCopy(gltf);\n    const scenes = (this.gltf.scenes || []).map(scene => this.createScene(scene));\n    return scenes;\n  }\n  createAnimator() {\n    if (Array.isArray(this.gltf.animations)) {\n      return new GLTFAnimator(this.gltf);\n    }\n    return null;\n  }\n  createScene(gltfScene) {\n    const gltfNodes = gltfScene.nodes || [];\n    const nodes = gltfNodes.map(node => this.createNode(node));\n    const scene = new GroupNode({\n      id: gltfScene.name || gltfScene.id,\n      children: nodes\n    });\n    return scene;\n  }\n  createNode(gltfNode) {\n    if (!gltfNode._node) {\n      const gltfChildren = gltfNode.children || [];\n      const children = gltfChildren.map(child => this.createNode(child));\n      // Node can have children nodes and meshes at the same time\n      if (gltfNode.mesh) {\n        children.push(this.createMesh(gltfNode.mesh));\n      }\n      const node = new GroupNode({\n        id: gltfNode.name || gltfNode.id,\n        children\n      });\n      if (gltfNode.matrix) {\n        node.setMatrix(gltfNode.matrix);\n      } else {\n        node.matrix.identity();\n        if (gltfNode.translation) {\n          node.matrix.translate(gltfNode.translation);\n        }\n        if (gltfNode.rotation) {\n          const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);\n          node.matrix.multiplyRight(rotationMatrix);\n        }\n        if (gltfNode.scale) {\n          node.matrix.scale(gltfNode.scale);\n        }\n      }\n      gltfNode._node = node;\n    }\n    // Copy _node so that gltf-animator can access\n    const topLevelNode = this.gltf.nodes.find(node => node.id === gltfNode.id);\n    topLevelNode._node = gltfNode._node;\n    return gltfNode._node;\n  }\n  createMesh(gltfMesh) {\n    // TODO: avoid changing the gltf\n    if (!gltfMesh._mesh) {\n      const gltfPrimitives = gltfMesh.primitives || [];\n      const primitives = gltfPrimitives.map((gltfPrimitive, i) => this.createPrimitive(gltfPrimitive, i, gltfMesh));\n      const mesh = new GroupNode({\n        id: gltfMesh.name || gltfMesh.id,\n        children: primitives\n      });\n      gltfMesh._mesh = mesh;\n    }\n    return gltfMesh._mesh;\n  }\n  createPrimitive(gltfPrimitive, i, gltfMesh) {\n    const id = gltfPrimitive.name || `${gltfMesh.name || gltfMesh.id}-primitive-${i}`;\n    const topology = convertGLDrawModeToTopology(gltfPrimitive.mode || 4);\n    const vertexCount = gltfPrimitive.indices ? gltfPrimitive.indices.count : this.getVertexCount(gltfPrimitive.attributes);\n    const modelNode = createGLTFModel(this.device, {\n      id,\n      geometry: this.createGeometry(id, gltfPrimitive, topology),\n      material: gltfPrimitive.material,\n      materialOptions: this.options,\n      modelOptions: this.options.modelOptions,\n      vertexCount\n    });\n    modelNode.bounds = [gltfPrimitive.attributes.POSITION.min, gltfPrimitive.attributes.POSITION.max];\n    // TODO this holds on to all the CPU side texture and attribute data\n    // modelNode.material =  gltfPrimitive.material;\n    return modelNode;\n  }\n  getVertexCount(attributes) {\n    throw new Error('getVertexCount not implemented');\n  }\n  createGeometry(id, gltfPrimitive, topology) {\n    const attributes = {};\n    for (const [attributeName, attribute] of Object.entries(gltfPrimitive.attributes)) {\n      const {\n        components,\n        size,\n        value\n      } = attribute;\n      attributes[attributeName] = {\n        size: size ?? components,\n        value\n      };\n    }\n    return new Geometry({\n      id,\n      topology,\n      indices: gltfPrimitive.indices.value,\n      attributes\n    });\n  }\n  createBuffer(attribute, usage) {\n    if (!attribute.bufferView) {\n      // Draco decoded files do not have a bufferView\n      attribute.bufferView = {};\n    }\n    const {\n      bufferView\n    } = attribute;\n    if (!bufferView.lumaBuffers) {\n      bufferView.lumaBuffers = {};\n    }\n    if (!bufferView.lumaBuffers[usage]) {\n      bufferView.lumaBuffers[usage] = this.device.createBuffer({\n        id: `from-${bufferView.id}`,\n        // Draco decoded files have attribute.value\n        data: bufferView.data || attribute.value\n      });\n    }\n    return bufferView.lumaBuffers[usage];\n  }\n  // TODO - create sampler in WebGL2\n  createSampler(gltfSampler) {\n    return gltfSampler;\n  }\n  // Helper methods (move to GLTFLoader.resolve...?)\n  needsPOT() {\n    // Has a wrapping mode (either wrapS or wrapT) equal to REPEAT or MIRRORED_REPEAT, or\n    // Has a minification filter (minFilter) that uses mipmapping\n    // (NEAREST_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR,\n    // LINEAR_MIPMAP_NEAREST, or LINEAR_MIPMAP_LINEAR).\n    return false;\n  }\n}\n/** Deeply copies a JS data structure */\nfunction deepCopy(object) {\n  // don't copy binary data\n  if (ArrayBuffer.isView(object) || object instanceof ArrayBuffer || object instanceof ImageBitmap) {\n    return object;\n  }\n  if (Array.isArray(object)) {\n    return object.map(deepCopy);\n  }\n  if (object && typeof object === 'object') {\n    const result = {};\n    for (const key in object) {\n      result[key] = deepCopy(object[key]);\n    }\n    return result;\n  }\n  return object;\n}\n//# sourceMappingURL=gltf-instantiator.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}