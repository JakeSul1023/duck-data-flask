{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { path } from '@loaders.gl/loader-utils';\nimport { Tile3DSubtreeLoader } from \"../../tile-3d-subtree-loader.js\";\nimport { load } from '@loaders.gl/core';\nimport { LOD_METRIC_TYPE, TILE_REFINEMENT, TILE_TYPE } from '@loaders.gl/tiles';\nimport { parseImplicitTiles, replaceContentUrlTemplate } from \"./helpers/parse-3d-implicit-tiles.js\";\nimport { convertS2BoundingVolumetoOBB } from \"../utils/obb/s2-corners-to-obb.js\";\nfunction getTileType(tile, tileContentUrl = '') {\n  if (!tileContentUrl) {\n    return TILE_TYPE.EMPTY;\n  }\n  const contentUrl = tileContentUrl.split('?')[0]; // Discard query string\n  const fileExtension = contentUrl.split('.').pop();\n  switch (fileExtension) {\n    case 'pnts':\n      return TILE_TYPE.POINTCLOUD;\n    case 'i3dm':\n    case 'b3dm':\n    case 'glb':\n    case 'gltf':\n      return TILE_TYPE.SCENEGRAPH;\n    default:\n      return fileExtension || TILE_TYPE.EMPTY;\n  }\n}\nfunction getRefine(refine) {\n  switch (refine) {\n    case 'REPLACE':\n    case 'replace':\n      return TILE_REFINEMENT.REPLACE;\n    case 'ADD':\n    case 'add':\n      return TILE_REFINEMENT.ADD;\n    default:\n      return refine;\n  }\n}\nfunction resolveUri(uri, basePath) {\n  // url scheme per RFC3986\n  const urlSchemeRegex = /^[a-z][0-9a-z+.-]*:/i;\n  if (urlSchemeRegex.test(basePath)) {\n    const url = new URL(uri, `${basePath}/`);\n    return decodeURI(url.toString());\n  } else if (uri.startsWith('/')) {\n    return uri;\n  }\n  return path.resolve(basePath, uri);\n}\nexport function normalizeTileData(tile, basePath) {\n  if (!tile) {\n    return null;\n  }\n  let tileContentUrl;\n  if (tile.content) {\n    const contentUri = tile.content.uri || tile.content?.url;\n    if (typeof contentUri !== 'undefined') {\n      // sparse implicit tilesets may not define content for all nodes\n      tileContentUrl = resolveUri(contentUri, basePath);\n    }\n  }\n  const tilePostprocessed = {\n    ...tile,\n    id: tileContentUrl,\n    contentUrl: tileContentUrl,\n    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n    lodMetricValue: tile.geometricError,\n    transformMatrix: tile.transform,\n    type: getTileType(tile, tileContentUrl),\n    refine: getRefine(tile.refine)\n  };\n  return tilePostprocessed;\n}\n// normalize tile headers\nexport async function normalizeTileHeaders(tileset, basePath, options) {\n  let root = null;\n  const rootImplicitTilingExtension = getImplicitTilingExtensionData(tileset.root);\n  if (rootImplicitTilingExtension && tileset.root) {\n    root = await normalizeImplicitTileHeaders(tileset.root, tileset, basePath, rootImplicitTilingExtension, options);\n  } else {\n    root = normalizeTileData(tileset.root, basePath);\n  }\n  const stack = [];\n  stack.push(root);\n  while (stack.length > 0) {\n    const tile = stack.pop() || {};\n    const children = tile.children || [];\n    const childrenPostprocessed = [];\n    for (const childHeader of children) {\n      const childImplicitTilingExtension = getImplicitTilingExtensionData(childHeader);\n      let childHeaderPostprocessed;\n      if (childImplicitTilingExtension) {\n        childHeaderPostprocessed = await normalizeImplicitTileHeaders(childHeader, tileset, basePath, childImplicitTilingExtension, options);\n      } else {\n        childHeaderPostprocessed = normalizeTileData(childHeader, basePath);\n      }\n      if (childHeaderPostprocessed) {\n        childrenPostprocessed.push(childHeaderPostprocessed);\n        stack.push(childHeaderPostprocessed);\n      }\n    }\n    tile.children = childrenPostprocessed;\n  }\n  return root;\n}\n/**\n * Do normalisation of implicit tile headers\n * TODO Check if Tile3D class can be a return type here.\n * @param tileset\n */\nexport async function normalizeImplicitTileHeaders(tile, tileset, basePath, implicitTilingExtension, options) {\n  const {\n    subdivisionScheme,\n    maximumLevel,\n    availableLevels,\n    subtreeLevels,\n    subtrees: {\n      uri: subtreesUriTemplate\n    }\n  } = implicitTilingExtension;\n  const replacedUrlTemplate = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);\n  const subtreeUrl = resolveUri(replacedUrlTemplate, basePath);\n  const subtree = await load(subtreeUrl, Tile3DSubtreeLoader, options);\n  const tileContentUri = tile.content?.uri;\n  const contentUrlTemplate = tileContentUri ? resolveUri(tileContentUri, basePath) : '';\n  const refine = tileset?.root?.refine;\n  // @ts-ignore\n  const rootLodMetricValue = tile.geometricError;\n  // Replace tile.boundingVolume with the the bounding volume specified by the extensions['3DTILES_bounding_volume_S2']\n  const s2VolumeInfo = tile.boundingVolume.extensions?.['3DTILES_bounding_volume_S2'];\n  if (s2VolumeInfo) {\n    const box = convertS2BoundingVolumetoOBB(s2VolumeInfo);\n    const s2VolumeBox = {\n      box,\n      s2VolumeInfo\n    };\n    tile.boundingVolume = s2VolumeBox;\n  }\n  const rootBoundingVolume = tile.boundingVolume;\n  const implicitOptions = {\n    contentUrlTemplate,\n    subtreesUriTemplate,\n    subdivisionScheme,\n    subtreeLevels,\n    maximumLevel: Number.isFinite(availableLevels) ? availableLevels - 1 : maximumLevel,\n    refine,\n    basePath,\n    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n    rootLodMetricValue,\n    rootBoundingVolume,\n    getTileType,\n    getRefine\n  };\n  return await normalizeImplicitTileData(tile, basePath, subtree, implicitOptions, options);\n}\n/**\n * Do implicit data normalisation to create hierarchical tile structure\n * @param tile\n * @param rootSubtree\n * @param options\n * @returns\n */\nexport async function normalizeImplicitTileData(tile, basePath, rootSubtree, implicitOptions, loaderOptions) {\n  if (!tile) {\n    return null;\n  }\n  const {\n    children,\n    contentUrl\n  } = await parseImplicitTiles({\n    subtree: rootSubtree,\n    implicitOptions,\n    loaderOptions\n  });\n  let tileContentUrl;\n  let tileContent = null;\n  if (contentUrl) {\n    tileContentUrl = contentUrl;\n    tileContent = {\n      uri: contentUrl.replace(`${basePath}/`, '')\n    };\n  }\n  const tilePostprocessed = {\n    ...tile,\n    id: tileContentUrl,\n    contentUrl: tileContentUrl,\n    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n    lodMetricValue: tile.geometricError,\n    transformMatrix: tile.transform,\n    type: getTileType(tile, tileContentUrl),\n    refine: getRefine(tile.refine),\n    content: tileContent || tile.content,\n    children\n  };\n  return tilePostprocessed;\n}\n/**\n * Implicit Tiling data can be in 3DTILES_implicit_tiling for 3DTiles v.Next or directly in implicitTiling object for 3DTiles v1.1.\n * Spec 3DTiles v.Next - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling\n * Spec 3DTiles v.1.1 - https://github.com/CesiumGS/3d-tiles/tree/draft-1.1/specification/ImplicitTiling\n * @param tile\n * @returns\n */\nfunction getImplicitTilingExtensionData(tile) {\n  return tile?.extensions?.['3DTILES_implicit_tiling'] || tile?.implicitTiling;\n}","map":{"version":3,"names":["path","Tile3DSubtreeLoader","load","LOD_METRIC_TYPE","TILE_REFINEMENT","TILE_TYPE","parseImplicitTiles","replaceContentUrlTemplate","convertS2BoundingVolumetoOBB","getTileType","tile","tileContentUrl","EMPTY","contentUrl","split","fileExtension","pop","POINTCLOUD","SCENEGRAPH","getRefine","refine","REPLACE","ADD","resolveUri","uri","basePath","urlSchemeRegex","test","url","URL","decodeURI","toString","startsWith","resolve","normalizeTileData","content","contentUri","tilePostprocessed","id","lodMetricType","GEOMETRIC_ERROR","lodMetricValue","geometricError","transformMatrix","transform","type","normalizeTileHeaders","tileset","options","root","rootImplicitTilingExtension","getImplicitTilingExtensionData","normalizeImplicitTileHeaders","stack","push","length","children","childrenPostprocessed","childHeader","childImplicitTilingExtension","childHeaderPostprocessed","implicitTilingExtension","subdivisionScheme","maximumLevel","availableLevels","subtreeLevels","subtrees","subtreesUriTemplate","replacedUrlTemplate","subtreeUrl","subtree","tileContentUri","contentUrlTemplate","rootLodMetricValue","s2VolumeInfo","boundingVolume","extensions","box","s2VolumeBox","rootBoundingVolume","implicitOptions","Number","isFinite","normalizeImplicitTileData","rootSubtree","loaderOptions","tileContent","replace","implicitTiling"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-header.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { path } from '@loaders.gl/loader-utils';\nimport { Tile3DSubtreeLoader } from \"../../tile-3d-subtree-loader.js\";\nimport { load } from '@loaders.gl/core';\nimport { LOD_METRIC_TYPE, TILE_REFINEMENT, TILE_TYPE } from '@loaders.gl/tiles';\nimport { parseImplicitTiles, replaceContentUrlTemplate } from \"./helpers/parse-3d-implicit-tiles.js\";\nimport { convertS2BoundingVolumetoOBB } from \"../utils/obb/s2-corners-to-obb.js\";\nfunction getTileType(tile, tileContentUrl = '') {\n    if (!tileContentUrl) {\n        return TILE_TYPE.EMPTY;\n    }\n    const contentUrl = tileContentUrl.split('?')[0]; // Discard query string\n    const fileExtension = contentUrl.split('.').pop();\n    switch (fileExtension) {\n        case 'pnts':\n            return TILE_TYPE.POINTCLOUD;\n        case 'i3dm':\n        case 'b3dm':\n        case 'glb':\n        case 'gltf':\n            return TILE_TYPE.SCENEGRAPH;\n        default:\n            return fileExtension || TILE_TYPE.EMPTY;\n    }\n}\nfunction getRefine(refine) {\n    switch (refine) {\n        case 'REPLACE':\n        case 'replace':\n            return TILE_REFINEMENT.REPLACE;\n        case 'ADD':\n        case 'add':\n            return TILE_REFINEMENT.ADD;\n        default:\n            return refine;\n    }\n}\nfunction resolveUri(uri, basePath) {\n    // url scheme per RFC3986\n    const urlSchemeRegex = /^[a-z][0-9a-z+.-]*:/i;\n    if (urlSchemeRegex.test(basePath)) {\n        const url = new URL(uri, `${basePath}/`);\n        return decodeURI(url.toString());\n    }\n    else if (uri.startsWith('/')) {\n        return uri;\n    }\n    return path.resolve(basePath, uri);\n}\nexport function normalizeTileData(tile, basePath) {\n    if (!tile) {\n        return null;\n    }\n    let tileContentUrl;\n    if (tile.content) {\n        const contentUri = tile.content.uri || tile.content?.url;\n        if (typeof contentUri !== 'undefined') {\n            // sparse implicit tilesets may not define content for all nodes\n            tileContentUrl = resolveUri(contentUri, basePath);\n        }\n    }\n    const tilePostprocessed = {\n        ...tile,\n        id: tileContentUrl,\n        contentUrl: tileContentUrl,\n        lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n        lodMetricValue: tile.geometricError,\n        transformMatrix: tile.transform,\n        type: getTileType(tile, tileContentUrl),\n        refine: getRefine(tile.refine)\n    };\n    return tilePostprocessed;\n}\n// normalize tile headers\nexport async function normalizeTileHeaders(tileset, basePath, options) {\n    let root = null;\n    const rootImplicitTilingExtension = getImplicitTilingExtensionData(tileset.root);\n    if (rootImplicitTilingExtension && tileset.root) {\n        root = await normalizeImplicitTileHeaders(tileset.root, tileset, basePath, rootImplicitTilingExtension, options);\n    }\n    else {\n        root = normalizeTileData(tileset.root, basePath);\n    }\n    const stack = [];\n    stack.push(root);\n    while (stack.length > 0) {\n        const tile = stack.pop() || {};\n        const children = tile.children || [];\n        const childrenPostprocessed = [];\n        for (const childHeader of children) {\n            const childImplicitTilingExtension = getImplicitTilingExtensionData(childHeader);\n            let childHeaderPostprocessed;\n            if (childImplicitTilingExtension) {\n                childHeaderPostprocessed = await normalizeImplicitTileHeaders(childHeader, tileset, basePath, childImplicitTilingExtension, options);\n            }\n            else {\n                childHeaderPostprocessed = normalizeTileData(childHeader, basePath);\n            }\n            if (childHeaderPostprocessed) {\n                childrenPostprocessed.push(childHeaderPostprocessed);\n                stack.push(childHeaderPostprocessed);\n            }\n        }\n        tile.children = childrenPostprocessed;\n    }\n    return root;\n}\n/**\n * Do normalisation of implicit tile headers\n * TODO Check if Tile3D class can be a return type here.\n * @param tileset\n */\nexport async function normalizeImplicitTileHeaders(tile, tileset, basePath, implicitTilingExtension, options) {\n    const { subdivisionScheme, maximumLevel, availableLevels, subtreeLevels, subtrees: { uri: subtreesUriTemplate } } = implicitTilingExtension;\n    const replacedUrlTemplate = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);\n    const subtreeUrl = resolveUri(replacedUrlTemplate, basePath);\n    const subtree = await load(subtreeUrl, Tile3DSubtreeLoader, options);\n    const tileContentUri = tile.content?.uri;\n    const contentUrlTemplate = tileContentUri ? resolveUri(tileContentUri, basePath) : '';\n    const refine = tileset?.root?.refine;\n    // @ts-ignore\n    const rootLodMetricValue = tile.geometricError;\n    // Replace tile.boundingVolume with the the bounding volume specified by the extensions['3DTILES_bounding_volume_S2']\n    const s2VolumeInfo = tile.boundingVolume.extensions?.['3DTILES_bounding_volume_S2'];\n    if (s2VolumeInfo) {\n        const box = convertS2BoundingVolumetoOBB(s2VolumeInfo);\n        const s2VolumeBox = { box, s2VolumeInfo };\n        tile.boundingVolume = s2VolumeBox;\n    }\n    const rootBoundingVolume = tile.boundingVolume;\n    const implicitOptions = {\n        contentUrlTemplate,\n        subtreesUriTemplate,\n        subdivisionScheme,\n        subtreeLevels,\n        maximumLevel: Number.isFinite(availableLevels) ? availableLevels - 1 : maximumLevel,\n        refine,\n        basePath,\n        lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n        rootLodMetricValue,\n        rootBoundingVolume,\n        getTileType,\n        getRefine\n    };\n    return await normalizeImplicitTileData(tile, basePath, subtree, implicitOptions, options);\n}\n/**\n * Do implicit data normalisation to create hierarchical tile structure\n * @param tile\n * @param rootSubtree\n * @param options\n * @returns\n */\nexport async function normalizeImplicitTileData(tile, basePath, rootSubtree, implicitOptions, loaderOptions) {\n    if (!tile) {\n        return null;\n    }\n    const { children, contentUrl } = await parseImplicitTiles({\n        subtree: rootSubtree,\n        implicitOptions,\n        loaderOptions\n    });\n    let tileContentUrl;\n    let tileContent = null;\n    if (contentUrl) {\n        tileContentUrl = contentUrl;\n        tileContent = { uri: contentUrl.replace(`${basePath}/`, '') };\n    }\n    const tilePostprocessed = {\n        ...tile,\n        id: tileContentUrl,\n        contentUrl: tileContentUrl,\n        lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n        lodMetricValue: tile.geometricError,\n        transformMatrix: tile.transform,\n        type: getTileType(tile, tileContentUrl),\n        refine: getRefine(tile.refine),\n        content: tileContent || tile.content,\n        children\n    };\n    return tilePostprocessed;\n}\n/**\n * Implicit Tiling data can be in 3DTILES_implicit_tiling for 3DTiles v.Next or directly in implicitTiling object for 3DTiles v1.1.\n * Spec 3DTiles v.Next - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling\n * Spec 3DTiles v.1.1 - https://github.com/CesiumGS/3d-tiles/tree/draft-1.1/specification/ImplicitTiling\n * @param tile\n * @returns\n */\nfunction getImplicitTilingExtensionData(tile) {\n    return tile?.extensions?.['3DTILES_implicit_tiling'] || tile?.implicitTiling;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}