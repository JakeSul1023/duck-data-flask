{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { AmbientLight } from \"./ambient-light.js\";\nimport { DirectionalLight } from \"./directional-light.js\";\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport ShadowPass from \"../../passes/shadow-pass.js\";\nimport shadow from \"../../shaderlib/shadow/shadow.js\";\nconst DEFAULT_AMBIENT_LIGHT_PROPS = {\n  color: [255, 255, 255],\n  intensity: 1.0\n};\nconst DEFAULT_DIRECTIONAL_LIGHT_PROPS = [{\n  color: [255, 255, 255],\n  intensity: 1.0,\n  direction: [-1, 3, -1]\n}, {\n  color: [255, 255, 255],\n  intensity: 0.9,\n  direction: [1, -8, -2.5]\n}];\nconst DEFAULT_SHADOW_COLOR = [0, 0, 0, 200 / 255];\n// Class to manage ambient, point and directional light sources in deck\nexport default class LightingEffect {\n  constructor() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.id = 'lighting-effect';\n    this.shadowColor = DEFAULT_SHADOW_COLOR;\n    this.shadow = false;\n    this.directionalLights = [];\n    this.pointLights = [];\n    this.shadowPasses = [];\n    this.dummyShadowMap = null;\n    this.setProps(props);\n  }\n  setup(context) {\n    this.context = context;\n    const {\n      device,\n      deck\n    } = context;\n    if (this.shadow && !this.dummyShadowMap) {\n      this._createShadowPasses(device);\n      deck._addDefaultShaderModule(shadow);\n      this.dummyShadowMap = device.createTexture({\n        width: 1,\n        height: 1\n      });\n    }\n  }\n  setProps(props) {\n    this.ambientLight = undefined;\n    this.directionalLights = [];\n    this.pointLights = [];\n    for (const key in props) {\n      const lightSource = props[key];\n      switch (lightSource.type) {\n        case 'ambient':\n          this.ambientLight = lightSource;\n          break;\n        case 'directional':\n          this.directionalLights.push(lightSource);\n          break;\n        case 'point':\n          this.pointLights.push(lightSource);\n          break;\n        default:\n      }\n    }\n    this._applyDefaultLights();\n    this.shadow = this.directionalLights.some(light => light.shadow);\n    if (this.context) {\n      // Create resources if necessary\n      this.setup(this.context);\n    }\n    this.props = props;\n  }\n  preRender(_ref) {\n    let {\n      layers,\n      layerFilter,\n      viewports,\n      onViewportActive,\n      views\n    } = _ref;\n    if (!this.shadow) return;\n    // create light matrix every frame to make sure always updated from light source\n    this.shadowMatrices = this._calculateMatrices();\n    for (let i = 0; i < this.shadowPasses.length; i++) {\n      const shadowPass = this.shadowPasses[i];\n      shadowPass.render({\n        layers,\n        layerFilter,\n        viewports,\n        onViewportActive,\n        views,\n        shaderModuleProps: {\n          shadow: {\n            shadowLightId: i,\n            dummyShadowMap: this.dummyShadowMap,\n            shadowMatrices: this.shadowMatrices\n          }\n        }\n      });\n    }\n  }\n  getShaderModuleProps(layer, otherShaderModuleProps) {\n    const shadowProps = this.shadow ? {\n      project: otherShaderModuleProps.project,\n      shadowMaps: this.shadowPasses.map(shadowPass => shadowPass.getShadowMap()),\n      dummyShadowMap: this.dummyShadowMap,\n      shadowColor: this.shadowColor,\n      shadowMatrices: this.shadowMatrices\n    } : {};\n    // when not rendering to screen, turn off lighting by adding empty light source object\n    // lights shader module relies on the `lightSources` to turn on/off lighting\n    const lightingProps = {\n      enabled: true,\n      ambientLight: this.ambientLight,\n      directionalLights: this.directionalLights.map(directionalLight => directionalLight.getProjectedLight({\n        layer\n      })),\n      pointLights: this.pointLights.map(pointLight => pointLight.getProjectedLight({\n        layer\n      }))\n    };\n    // @ts-expect-error material is not a Layer prop\n    const materialProps = layer.props.material;\n    return {\n      shadow: shadowProps,\n      lighting: lightingProps,\n      phongMaterial: materialProps,\n      gouraudMaterial: materialProps\n    };\n  }\n  cleanup(context) {\n    for (const shadowPass of this.shadowPasses) {\n      shadowPass.delete();\n    }\n    this.shadowPasses.length = 0;\n    if (this.dummyShadowMap) {\n      this.dummyShadowMap.destroy();\n      this.dummyShadowMap = null;\n      context.deck._removeDefaultShaderModule(shadow);\n    }\n  }\n  _calculateMatrices() {\n    const lightMatrices = [];\n    for (const light of this.directionalLights) {\n      const viewMatrix = new Matrix4().lookAt({\n        eye: new Vector3(light.direction).negate()\n      });\n      lightMatrices.push(viewMatrix);\n    }\n    return lightMatrices;\n  }\n  _createShadowPasses(device) {\n    for (let i = 0; i < this.directionalLights.length; i++) {\n      const shadowPass = new ShadowPass(device);\n      this.shadowPasses[i] = shadowPass;\n    }\n  }\n  _applyDefaultLights() {\n    const {\n      ambientLight,\n      pointLights,\n      directionalLights\n    } = this;\n    if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {\n      this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);\n      this.directionalLights.push(new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));\n    }\n  }\n}\n//# sourceMappingURL=lighting-effect.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}