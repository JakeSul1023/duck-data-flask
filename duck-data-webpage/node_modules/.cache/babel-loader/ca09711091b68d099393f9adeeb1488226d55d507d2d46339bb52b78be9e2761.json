{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\n/**\n * Create a tile from features and tile index\n */\nexport function createProtoTile(features, z, tx, ty, options) {\n  const tolerance = z === options.maxZoom ? 0 : options.tolerance / ((1 << z) * options.extent);\n  const tile = {\n    protoFeatures: [],\n    sourceFeatures: null,\n    numPoints: 0,\n    numSimplified: 0,\n    numFeatures: features.length,\n    x: tx,\n    y: ty,\n    z,\n    transformed: false,\n    minX: 2,\n    minY: 1,\n    maxX: -1,\n    maxY: 0\n  };\n  for (const feature of features) {\n    addProtoFeature(tile, feature, tolerance, options);\n  }\n  return tile;\n}\n// eslint-disable-next-line complexity, max-statements\nfunction addProtoFeature(tile, feature, tolerance, options) {\n  const geometry = feature.geometry;\n  const type = feature.type;\n  const simplifiedGeometry = [];\n  tile.minX = Math.min(tile.minX, feature.minX);\n  tile.minY = Math.min(tile.minY, feature.minY);\n  tile.maxX = Math.max(tile.maxX, feature.maxX);\n  tile.maxY = Math.max(tile.maxY, feature.maxY);\n  let simplifiedType;\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n      simplifiedType = 1;\n      for (let i = 0; i < geometry.length; i += 3) {\n        simplifiedGeometry.push(geometry[i], geometry[i + 1]);\n        tile.numPoints++;\n        tile.numSimplified++;\n      }\n      break;\n    case 'LineString':\n      simplifiedType = 2;\n      addProtoLine(simplifiedGeometry, geometry, tile, tolerance, false, false);\n      break;\n    case 'MultiLineString':\n      simplifiedType = 2;\n      for (let i = 0; i < geometry.length; i++) {\n        addProtoLine(simplifiedGeometry, geometry[i], tile, tolerance, false, i === 0);\n      }\n      break;\n    case 'Polygon':\n      simplifiedType = 3;\n      for (let i = 0; i < geometry.length; i++) {\n        addProtoLine(simplifiedGeometry, geometry[i], tile, tolerance, true, i === 0);\n      }\n      break;\n    case 'MultiPolygon':\n      simplifiedType = 3;\n      for (let k = 0; k < geometry.length; k++) {\n        const polygon = geometry[k];\n        for (let i = 0; i < polygon.length; i++) {\n          addProtoLine(simplifiedGeometry, polygon[i], tile, tolerance, true, i === 0);\n        }\n      }\n      break;\n    default:\n      throw new Error(`Unknown geometry type: ${type}`);\n  }\n  if (simplifiedGeometry.length) {\n    let tags = feature.tags || null;\n    if (type === 'LineString' && options.lineMetrics) {\n      tags = {};\n      for (const key in feature.tags) {\n        tags[key] = feature.tags[key];\n      }\n      // @ts-expect-error adding fields to arrays\n      // eslint-disable-next-line camelcase\n      tags.mapbox_clip_start = geometry.start / geometry.size;\n      // @ts-expect-error adding fields to arrays\n      // eslint-disable-next-line camelcase\n      tags.mapbox_clip_end = geometry.end / geometry.size;\n    }\n    const tileFeature = {\n      geometry: simplifiedGeometry,\n      simplifiedType,\n      // @ts-expect-error\n      tags\n    };\n    if (feature.id !== null) {\n      tileFeature.id = feature.id;\n    }\n    tile.protoFeatures.push(tileFeature);\n  }\n}\n// eslint-disable-next-line max-params, max-statements\nfunction addProtoLine(result, geometry, tile, tolerance, isPolygon, isOuter) {\n  const sqTolerance = tolerance * tolerance;\n  if (tolerance > 0 && geometry.size < (isPolygon ? sqTolerance : tolerance)) {\n    tile.numPoints += geometry.length / 3;\n    return;\n  }\n  const ring = [];\n  for (let i = 0; i < geometry.length; i += 3) {\n    if (tolerance === 0 || geometry[i + 2] > sqTolerance) {\n      tile.numSimplified++;\n      ring.push(geometry[i], geometry[i + 1]);\n    }\n    tile.numPoints++;\n  }\n  if (isPolygon) rewind(ring, isOuter);\n  result.push(ring);\n}\nfunction rewind(ring, clockwise) {\n  let area = 0;\n  for (let i = 0, j = ring.length - 2; i < ring.length; j = i, i += 2) {\n    area += (ring[i] - ring[j]) * (ring[i + 1] + ring[j + 1]);\n  }\n  if (area > 0 === clockwise) {\n    for (let i = 0, len = ring.length; i < len / 2; i += 2) {\n      const x = ring[i];\n      const y = ring[i + 1];\n      ring[i] = ring[len - 2 - i];\n      ring[i + 1] = ring[len - 1 - i];\n      ring[len - 2 - i] = x;\n      ring[len - 1 - i] = y;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}