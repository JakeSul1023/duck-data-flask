{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Matrix4 } from '@math.gl/core';\nimport Viewport from \"./viewport.js\";\nimport { PROJECTION_MODE } from \"../lib/constants.js\";\nimport { altitudeToFovy, fovyToAltitude } from '@math.gl/web-mercator';\nimport { MAX_LATITUDE } from '@math.gl/web-mercator';\nimport { vec3, vec4 } from '@math.gl/core';\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nconst RADIANS_TO_DEGREES = 180 / Math.PI;\nconst EARTH_RADIUS = 6370972;\nconst GLOBE_RADIUS = 256;\nfunction getDistanceScales() {\n  const unitsPerMeter = GLOBE_RADIUS / EARTH_RADIUS;\n  const unitsPerDegree = Math.PI / 180 * GLOBE_RADIUS;\n  return {\n    unitsPerMeter: [unitsPerMeter, unitsPerMeter, unitsPerMeter],\n    unitsPerMeter2: [0, 0, 0],\n    metersPerUnit: [1 / unitsPerMeter, 1 / unitsPerMeter, 1 / unitsPerMeter],\n    unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter],\n    unitsPerDegree2: [0, 0, 0],\n    degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter]\n  };\n}\nexport default class GlobeViewport extends Viewport {\n  constructor(opts = {}) {\n    const {\n      longitude = 0,\n      zoom = 0,\n      // Matches Maplibre defaults\n      // https://github.com/maplibre/maplibre-gl-js/blob/f8ab4b48d59ab8fe7b068b102538793bbdd4c848/src/geo/projection/globe_transform.ts#L632-L633\n      nearZMultiplier = 0.5,\n      farZMultiplier = 1,\n      resolution = 10\n    } = opts;\n    let {\n      latitude = 0,\n      height,\n      altitude = 1.5,\n      fovy\n    } = opts;\n    // Clamp to web mercator limit to prevent bad inputs\n    latitude = Math.max(Math.min(latitude, MAX_LATITUDE), -MAX_LATITUDE);\n    height = height || 1;\n    if (fovy) {\n      altitude = fovyToAltitude(fovy);\n    } else {\n      fovy = altitudeToFovy(altitude);\n    }\n    // Exagerate distance by latitude to match the Web Mercator distortion\n    // The goal is that globe and web mercator projection results converge at high zoom\n    // https://github.com/maplibre/maplibre-gl-js/blob/f8ab4b48d59ab8fe7b068b102538793bbdd4c848/src/geo/projection/globe_transform.ts#L575-L577\n    const scaleAdjust = 1 / Math.PI / Math.cos(latitude * Math.PI / 180);\n    const scale = Math.pow(2, zoom) * scaleAdjust;\n    const nearZ = opts.nearZ ?? nearZMultiplier;\n    const farZ = opts.farZ ?? (altitude + GLOBE_RADIUS * 2 * scale / height) * farZMultiplier;\n    // Calculate view matrix\n    const viewMatrix = new Matrix4().lookAt({\n      eye: [0, -altitude, 0],\n      up: [0, 0, 1]\n    });\n    viewMatrix.rotateX(latitude * DEGREES_TO_RADIANS);\n    viewMatrix.rotateZ(-longitude * DEGREES_TO_RADIANS);\n    viewMatrix.scale(scale / height);\n    super({\n      ...opts,\n      // x, y, width,\n      height,\n      // view matrix\n      viewMatrix,\n      longitude,\n      latitude,\n      zoom,\n      // projection matrix parameters\n      distanceScales: getDistanceScales(),\n      fovy,\n      focalDistance: altitude,\n      near: nearZ,\n      far: farZ\n    });\n    this.scale = scale;\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.resolution = resolution;\n  }\n  get projectionMode() {\n    return PROJECTION_MODE.GLOBE;\n  }\n  getDistanceScales() {\n    return this.distanceScales;\n  }\n  getBounds(options = {}) {\n    const unprojectOption = {\n      targetZ: options.z || 0\n    };\n    const left = this.unproject([0, this.height / 2], unprojectOption);\n    const top = this.unproject([this.width / 2, 0], unprojectOption);\n    const right = this.unproject([this.width, this.height / 2], unprojectOption);\n    const bottom = this.unproject([this.width / 2, this.height], unprojectOption);\n    if (right[0] < this.longitude) right[0] += 360;\n    if (left[0] > this.longitude) left[0] -= 360;\n    return [Math.min(left[0], right[0], top[0], bottom[0]), Math.min(left[1], right[1], top[1], bottom[1]), Math.max(left[0], right[0], top[0], bottom[0]), Math.max(left[1], right[1], top[1], bottom[1])];\n  }\n  unproject(xyz, {\n    topLeft = true,\n    targetZ\n  } = {}) {\n    const [x, y, z] = xyz;\n    const y2 = topLeft ? y : this.height - y;\n    const {\n      pixelUnprojectionMatrix\n    } = this;\n    let coord;\n    if (Number.isFinite(z)) {\n      // Has depth component\n      coord = transformVector(pixelUnprojectionMatrix, [x, y2, z, 1]);\n    } else {\n      // since we don't know the correct projected z value for the point,\n      // unproject two points to get a line and then find the point on that line that intersects with the sphere\n      const coord0 = transformVector(pixelUnprojectionMatrix, [x, y2, -1, 1]);\n      const coord1 = transformVector(pixelUnprojectionMatrix, [x, y2, 1, 1]);\n      const lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n      const lSqr = vec3.sqrLen(vec3.sub([], coord0, coord1));\n      const l0Sqr = vec3.sqrLen(coord0);\n      const l1Sqr = vec3.sqrLen(coord1);\n      const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;\n      const dSqr = 4 * sSqr / lSqr;\n      const r0 = Math.sqrt(l0Sqr - dSqr);\n      const dr = Math.sqrt(Math.max(0, lt * lt - dSqr));\n      const t = (r0 - dr) / Math.sqrt(lSqr);\n      coord = vec3.lerp([], coord0, coord1, t);\n    }\n    const [X, Y, Z] = this.unprojectPosition(coord);\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  }\n  projectPosition(xyz) {\n    const [lng, lat, Z = 0] = xyz;\n    const lambda = lng * DEGREES_TO_RADIANS;\n    const phi = lat * DEGREES_TO_RADIANS;\n    const cosPhi = Math.cos(phi);\n    const D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n    return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];\n  }\n  unprojectPosition(xyz) {\n    const [x, y, z] = xyz;\n    const D = vec3.len(xyz);\n    const phi = Math.asin(z / D);\n    const lambda = Math.atan2(x, -y);\n    const lng = lambda * RADIANS_TO_DEGREES;\n    const lat = phi * RADIANS_TO_DEGREES;\n    const Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;\n    return [lng, lat, Z];\n  }\n  projectFlat(xyz) {\n    return xyz;\n  }\n  unprojectFlat(xyz) {\n    return xyz;\n  }\n  panByPosition(coords, pixel) {\n    const fromPosition = this.unproject(pixel);\n    return {\n      longitude: coords[0] - fromPosition[0] + this.longitude,\n      latitude: coords[1] - fromPosition[1] + this.latitude\n    };\n  }\n}\nfunction transformVector(matrix, vector) {\n  const result = vec4.transformMat4([], vector, matrix);\n  vec4.scale(result, result, 1 / result[3]);\n  return result;\n}","map":{"version":3,"names":["Matrix4","Viewport","PROJECTION_MODE","altitudeToFovy","fovyToAltitude","MAX_LATITUDE","vec3","vec4","DEGREES_TO_RADIANS","Math","PI","RADIANS_TO_DEGREES","EARTH_RADIUS","GLOBE_RADIUS","getDistanceScales","unitsPerMeter","unitsPerDegree","unitsPerMeter2","metersPerUnit","unitsPerDegree2","degreesPerUnit","GlobeViewport","constructor","opts","longitude","zoom","nearZMultiplier","farZMultiplier","resolution","latitude","height","altitude","fovy","max","min","scaleAdjust","cos","scale","pow","nearZ","farZ","viewMatrix","lookAt","eye","up","rotateX","rotateZ","distanceScales","focalDistance","near","far","projectionMode","GLOBE","getBounds","options","unprojectOption","targetZ","z","left","unproject","top","width","right","bottom","xyz","topLeft","x","y","y2","pixelUnprojectionMatrix","coord","Number","isFinite","transformVector","coord0","coord1","lt","lSqr","sqrLen","sub","l0Sqr","l1Sqr","sSqr","dSqr","r0","sqrt","dr","t","lerp","X","Y","Z","unprojectPosition","projectPosition","lng","lat","lambda","phi","cosPhi","D","sin","len","asin","atan2","projectFlat","unprojectFlat","panByPosition","coords","pixel","fromPosition","matrix","vector","result","transformMat4"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\viewports\\globe-viewport.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Matrix4} from '@math.gl/core';\nimport Viewport from './viewport';\nimport {PROJECTION_MODE} from '../lib/constants';\nimport {altitudeToFovy, fovyToAltitude} from '@math.gl/web-mercator';\nimport {MAX_LATITUDE} from '@math.gl/web-mercator';\n\nimport {vec3, vec4} from '@math.gl/core';\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nconst RADIANS_TO_DEGREES = 180 / Math.PI;\nconst EARTH_RADIUS = 6370972;\nconst GLOBE_RADIUS = 256;\n\nfunction getDistanceScales() {\n  const unitsPerMeter = GLOBE_RADIUS / EARTH_RADIUS;\n  const unitsPerDegree = (Math.PI / 180) * GLOBE_RADIUS;\n\n  return {\n    unitsPerMeter: [unitsPerMeter, unitsPerMeter, unitsPerMeter],\n    unitsPerMeter2: [0, 0, 0],\n    metersPerUnit: [1 / unitsPerMeter, 1 / unitsPerMeter, 1 / unitsPerMeter],\n    unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter],\n    unitsPerDegree2: [0, 0, 0],\n    degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter]\n  };\n}\n\nexport type GlobeViewportOptions = {\n  /** Name of the viewport */\n  id?: string;\n  /** Left offset from the canvas edge, in pixels */\n  x?: number;\n  /** Top offset from the canvas edge, in pixels */\n  y?: number;\n  /** Viewport width in pixels */\n  width?: number;\n  /** Viewport height in pixels */\n  height?: number;\n  /** Longitude in degrees */\n  longitude?: number;\n  /** Latitude in degrees */\n  latitude?: number;\n  /** Camera altitude relative to the viewport height, used to control the FOV. Default `1.5` */\n  altitude?: number;\n  /* Meter offsets of the viewport center from lng, lat, elevation */\n  position?: number[];\n  /** Zoom level */\n  zoom?: number;\n  /** Use orthographic projection */\n  orthographic?: boolean;\n  /** Camera fovy in degrees. If provided, overrides `altitude` */\n  fovy?: number;\n  /** Scaler for the near plane, 1 unit equals to the height of the viewport. Default `0.5` */\n  nearZMultiplier?: number;\n  /** Scaler for the far plane, 1 unit equals to the distance from the camera to the edge of the screen. Default `1` */\n  farZMultiplier?: number;\n  /** Optionally override the near plane position. `nearZMultiplier` is ignored if `nearZ` is supplied. */\n  nearZ?: number;\n  /** Optionally override the far plane position. `farZMultiplier` is ignored if `farZ` is supplied. */\n  farZ?: number;\n  /** The resolution at which to turn flat features into 3D meshes, in degrees. Smaller numbers will generate more detailed mesh. Default `10` */\n  resolution?: number;\n};\n\nexport default class GlobeViewport extends Viewport {\n  longitude!: number;\n  latitude!: number;\n  resolution!: number;\n\n  constructor(opts: GlobeViewportOptions = {}) {\n    const {\n      longitude = 0,\n      zoom = 0,\n      // Matches Maplibre defaults\n      // https://github.com/maplibre/maplibre-gl-js/blob/f8ab4b48d59ab8fe7b068b102538793bbdd4c848/src/geo/projection/globe_transform.ts#L632-L633\n      nearZMultiplier = 0.5,\n      farZMultiplier = 1,\n      resolution = 10\n    } = opts;\n\n    let {latitude = 0, height, altitude = 1.5, fovy} = opts;\n\n    // Clamp to web mercator limit to prevent bad inputs\n    latitude = Math.max(Math.min(latitude, MAX_LATITUDE), -MAX_LATITUDE);\n\n    height = height || 1;\n    if (fovy) {\n      altitude = fovyToAltitude(fovy);\n    } else {\n      fovy = altitudeToFovy(altitude);\n    }\n    // Exagerate distance by latitude to match the Web Mercator distortion\n    // The goal is that globe and web mercator projection results converge at high zoom\n    // https://github.com/maplibre/maplibre-gl-js/blob/f8ab4b48d59ab8fe7b068b102538793bbdd4c848/src/geo/projection/globe_transform.ts#L575-L577\n    const scaleAdjust = 1 / Math.PI / Math.cos((latitude * Math.PI) / 180);\n    const scale = Math.pow(2, zoom) * scaleAdjust;\n    const nearZ = opts.nearZ ?? nearZMultiplier;\n    const farZ = opts.farZ ?? (altitude + (GLOBE_RADIUS * 2 * scale) / height) * farZMultiplier;\n\n    // Calculate view matrix\n    const viewMatrix = new Matrix4().lookAt({eye: [0, -altitude, 0], up: [0, 0, 1]});\n    viewMatrix.rotateX(latitude * DEGREES_TO_RADIANS);\n    viewMatrix.rotateZ(-longitude * DEGREES_TO_RADIANS);\n    viewMatrix.scale(scale / height);\n\n    super({\n      ...opts,\n      // x, y, width,\n      height,\n\n      // view matrix\n      viewMatrix,\n      longitude,\n      latitude,\n      zoom,\n\n      // projection matrix parameters\n      distanceScales: getDistanceScales(),\n      fovy,\n      focalDistance: altitude,\n      near: nearZ,\n      far: farZ\n    });\n\n    this.scale = scale;\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.resolution = resolution;\n  }\n\n  get projectionMode() {\n    return PROJECTION_MODE.GLOBE;\n  }\n\n  getDistanceScales() {\n    return this.distanceScales;\n  }\n\n  getBounds(options: {z?: number} = {}): [number, number, number, number] {\n    const unprojectOption = {targetZ: options.z || 0};\n\n    const left = this.unproject([0, this.height / 2], unprojectOption);\n    const top = this.unproject([this.width / 2, 0], unprojectOption);\n    const right = this.unproject([this.width, this.height / 2], unprojectOption);\n    const bottom = this.unproject([this.width / 2, this.height], unprojectOption);\n\n    if (right[0] < this.longitude) right[0] += 360;\n    if (left[0] > this.longitude) left[0] -= 360;\n\n    return [\n      Math.min(left[0], right[0], top[0], bottom[0]),\n      Math.min(left[1], right[1], top[1], bottom[1]),\n      Math.max(left[0], right[0], top[0], bottom[0]),\n      Math.max(left[1], right[1], top[1], bottom[1])\n    ];\n  }\n\n  unproject(\n    xyz: number[],\n    {topLeft = true, targetZ}: {topLeft?: boolean; targetZ?: number} = {}\n  ): number[] {\n    const [x, y, z] = xyz;\n\n    const y2 = topLeft ? y : this.height - y;\n    const {pixelUnprojectionMatrix} = this;\n\n    let coord;\n    if (Number.isFinite(z)) {\n      // Has depth component\n      coord = transformVector(pixelUnprojectionMatrix, [x, y2, z, 1]);\n    } else {\n      // since we don't know the correct projected z value for the point,\n      // unproject two points to get a line and then find the point on that line that intersects with the sphere\n      const coord0 = transformVector(pixelUnprojectionMatrix, [x, y2, -1, 1]);\n      const coord1 = transformVector(pixelUnprojectionMatrix, [x, y2, 1, 1]);\n\n      const lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n      const lSqr = vec3.sqrLen(vec3.sub([], coord0, coord1));\n      const l0Sqr = vec3.sqrLen(coord0);\n      const l1Sqr = vec3.sqrLen(coord1);\n      const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;\n      const dSqr = (4 * sSqr) / lSqr;\n      const r0 = Math.sqrt(l0Sqr - dSqr);\n      const dr = Math.sqrt(Math.max(0, lt * lt - dSqr));\n      const t = (r0 - dr) / Math.sqrt(lSqr);\n\n      coord = vec3.lerp([], coord0, coord1, t);\n    }\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ as number] : [X, Y];\n  }\n\n  projectPosition(xyz: number[]): [number, number, number] {\n    const [lng, lat, Z = 0] = xyz;\n    const lambda = lng * DEGREES_TO_RADIANS;\n    const phi = lat * DEGREES_TO_RADIANS;\n    const cosPhi = Math.cos(phi);\n    const D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;\n\n    return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];\n  }\n\n  unprojectPosition(xyz: number[]): [number, number, number] {\n    const [x, y, z] = xyz;\n    const D = vec3.len(xyz);\n    const phi = Math.asin(z / D);\n    const lambda = Math.atan2(x, -y);\n\n    const lng = lambda * RADIANS_TO_DEGREES;\n    const lat = phi * RADIANS_TO_DEGREES;\n    const Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;\n    return [lng, lat, Z];\n  }\n\n  projectFlat(xyz: number[]): [number, number] {\n    return xyz as [number, number];\n  }\n\n  unprojectFlat(xyz: number[]): [number, number] {\n    return xyz as [number, number];\n  }\n\n  panByPosition(coords: number[], pixel: number[]): GlobeViewportOptions {\n    const fromPosition = this.unproject(pixel);\n    return {\n      longitude: coords[0] - fromPosition[0] + this.longitude,\n      latitude: coords[1] - fromPosition[1] + this.latitude\n    };\n  }\n}\n\nfunction transformVector(matrix: number[], vector: number[]): number[] {\n  const result = vec4.transformMat4([], vector, matrix);\n  vec4.scale(result, result, 1 / result[3]);\n  return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}