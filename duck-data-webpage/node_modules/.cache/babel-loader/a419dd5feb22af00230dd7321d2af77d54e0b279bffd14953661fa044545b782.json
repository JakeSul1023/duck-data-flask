{"ast":null,"code":"const INF = 1e20;\nexport default class TinySDF {\n  constructor() {\n    let {\n      fontSize = 24,\n      buffer = 3,\n      radius = 8,\n      cutoff = 0.25,\n      fontFamily = 'sans-serif',\n      fontWeight = 'normal',\n      fontStyle = 'normal'\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.buffer = buffer;\n    this.cutoff = cutoff;\n    this.radius = radius;\n\n    // make the canvas size big enough to both have the specified buffer around the glyph\n    // for \"halo\", and account for some glyphs possibly being larger than their font size\n    const size = this.size = fontSize + buffer * 4;\n    const canvas = this._createCanvas(size);\n    const ctx = this.ctx = canvas.getContext('2d', {\n      willReadFrequently: true\n    });\n    ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;\n    ctx.textBaseline = 'alphabetic';\n    ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment\n    ctx.fillStyle = 'black';\n\n    // temporary arrays for the distance transform\n    this.gridOuter = new Float64Array(size * size);\n    this.gridInner = new Float64Array(size * size);\n    this.f = new Float64Array(size);\n    this.z = new Float64Array(size + 1);\n    this.v = new Uint16Array(size);\n  }\n  _createCanvas(size) {\n    const canvas = document.createElement('canvas');\n    canvas.width = canvas.height = size;\n    return canvas;\n  }\n  draw(char) {\n    const {\n      width: glyphAdvance,\n      actualBoundingBoxAscent,\n      actualBoundingBoxDescent,\n      actualBoundingBoxLeft,\n      actualBoundingBoxRight\n    } = this.ctx.measureText(char);\n\n    // The integer/pixel part of the top alignment is encoded in metrics.glyphTop\n    // The remainder is implicitly encoded in the rasterization\n    const glyphTop = Math.ceil(actualBoundingBoxAscent);\n    const glyphLeft = 0;\n\n    // If the glyph overflows the canvas size, it will be clipped at the bottom/right\n    const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));\n    const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));\n    const width = glyphWidth + 2 * this.buffer;\n    const height = glyphHeight + 2 * this.buffer;\n    const len = Math.max(width * height, 0);\n    const data = new Uint8ClampedArray(len);\n    const glyph = {\n      data,\n      width,\n      height,\n      glyphWidth,\n      glyphHeight,\n      glyphTop,\n      glyphLeft,\n      glyphAdvance\n    };\n    if (glyphWidth === 0 || glyphHeight === 0) return glyph;\n    const {\n      ctx,\n      buffer,\n      gridInner,\n      gridOuter\n    } = this;\n    ctx.clearRect(buffer, buffer, glyphWidth, glyphHeight);\n    ctx.fillText(char, buffer, buffer + glyphTop);\n    const imgData = ctx.getImageData(buffer, buffer, glyphWidth, glyphHeight);\n\n    // Initialize grids outside the glyph range to alpha 0\n    gridOuter.fill(INF, 0, len);\n    gridInner.fill(0, 0, len);\n    for (let y = 0; y < glyphHeight; y++) {\n      for (let x = 0; x < glyphWidth; x++) {\n        const a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value\n        if (a === 0) continue; // empty pixels\n\n        const j = (y + buffer) * width + x + buffer;\n        if (a === 1) {\n          // fully drawn pixels\n          gridOuter[j] = 0;\n          gridInner[j] = INF;\n        } else {\n          // aliased pixels\n          const d = 0.5 - a;\n          gridOuter[j] = d > 0 ? d * d : 0;\n          gridInner[j] = d < 0 ? d * d : 0;\n        }\n      }\n    }\n    edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);\n    edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);\n    for (let i = 0; i < len; i++) {\n      const d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);\n      data[i] = Math.round(255 - 255 * (d / this.radius + this.cutoff));\n    }\n    return glyph;\n  }\n}\n\n// 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf\nfunction edt(data, x0, y0, width, height, gridSize, f, v, z) {\n  for (let x = x0; x < x0 + width; x++) edt1d(data, y0 * gridSize + x, gridSize, height, f, v, z);\n  for (let y = y0; y < y0 + height; y++) edt1d(data, y * gridSize + x0, 1, width, f, v, z);\n}\n\n// 1D squared distance transform\nfunction edt1d(grid, offset, stride, length, f, v, z) {\n  v[0] = 0;\n  z[0] = -INF;\n  z[1] = INF;\n  f[0] = grid[offset];\n  for (let q = 1, k = 0, s = 0; q < length; q++) {\n    f[q] = grid[offset + q * stride];\n    const q2 = q * q;\n    do {\n      const r = v[k];\n      s = (f[q] - f[r] + q2 - r * r) / (q - r) / 2;\n    } while (s <= z[k] && --k > -1);\n    k++;\n    v[k] = q;\n    z[k] = s;\n    z[k + 1] = INF;\n  }\n  for (let q = 0, k = 0; q < length; q++) {\n    while (z[k + 1] < q) k++;\n    const r = v[k];\n    const qr = q - r;\n    grid[offset + q * stride] = f[r] + qr * qr;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}