{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { setGLParameters, getGLParameters } from \"../parameters/unified-parameter-api.js\";\nimport { deepArrayEqual } from \"./deep-array-equal.js\";\nimport { GL_PARAMETER_DEFAULTS, GL_HOOKED_SETTERS, NON_CACHE_PARAMETERS } from \"../parameters/webgl-parameter-tables.js\";\n// HELPER CLASS - WebGLStateTracker\n/**\n * Support for listening to context state changes and intercepting state queries\n * NOTE: this system does not handle buffer bindings\n */\nexport class WebGLStateTracker {\n  static get(gl) {\n    // @ts-expect-error\n    return gl.state;\n  }\n  gl;\n  program = null;\n  stateStack = [];\n  enable = true;\n  cache = null;\n  log;\n  initialized = false;\n  constructor(gl, props) {\n    this.gl = gl;\n    this.log = props?.log || (() => {});\n    this._updateCache = this._updateCache.bind(this);\n    Object.seal(this);\n  }\n  push(values = {}) {\n    this.stateStack.push({});\n  }\n  pop() {\n    // assert(this.stateStack.length > 0);\n    // Use the saved values in the state stack to restore parameters\n    const oldValues = this.stateStack[this.stateStack.length - 1];\n    setGLParameters(this.gl, oldValues);\n    // Don't pop until we have reset parameters (to make sure other \"stack frames\" are not affected)\n    this.stateStack.pop();\n  }\n  /**\n   * Initialize WebGL state caching on a context\n   * can be called multiple times to enable/disable\n   *\n   * @note After calling this function, context state will be cached\n   * .push() and .pop() will be available for saving,\n   * temporarily modifying, and then restoring state.\n   */\n  trackState(gl, options) {\n    this.cache = options.copyState ? getGLParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);\n    if (this.initialized) {\n      throw new Error('WebGLStateTracker');\n    }\n    this.initialized = true;\n    // @ts-expect-error\n    this.gl.state = this;\n    installProgramSpy(gl);\n    // intercept all setter functions in the table\n    for (const key in GL_HOOKED_SETTERS) {\n      const setter = GL_HOOKED_SETTERS[key];\n      installSetterSpy(gl, key, setter);\n    }\n    // intercept all getter functions in the table\n    installGetterOverride(gl, 'getParameter');\n    installGetterOverride(gl, 'isEnabled');\n  }\n  /**\n  // interceptor for context set functions - update our cache and our stack\n  // values (Object) - the key values for this setter\n   * @param values\n   * @returns\n   */\n  _updateCache(values) {\n    let valueChanged = false;\n    let oldValue; // = undefined\n    const oldValues = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;\n    for (const key in values) {\n      // assert(key !== undefined);\n      const value = values[key];\n      const cached = this.cache[key];\n      // Check that value hasn't already been shadowed\n      if (!deepArrayEqual(value, cached)) {\n        valueChanged = true;\n        oldValue = cached;\n        // First, save current value being shadowed\n        // If a state stack frame is active, save the current parameter values for pop\n        // but first check that value hasn't already been shadowed and saved\n        if (oldValues && !(key in oldValues)) {\n          oldValues[key] = cached;\n        }\n        // Save current value being shadowed\n        this.cache[key] = value;\n      }\n    }\n    return {\n      valueChanged,\n      oldValue\n    };\n  }\n}\n// HELPER FUNCTIONS - INSTALL GET/SET INTERCEPTORS (SPYS) ON THE CONTEXT\n/**\n// Overrides a WebGL2RenderingContext state \"getter\" function\n// to return values directly from cache\n * @param gl\n * @param functionName\n */\nfunction installGetterOverride(gl, functionName) {\n  // Get the original function from the WebGL2RenderingContext\n  const originalGetterFunc = gl[functionName].bind(gl);\n  // Wrap it with a spy so that we can update our state cache when it gets called\n  gl[functionName] = function get(pname) {\n    if (pname === undefined || NON_CACHE_PARAMETERS.has(pname)) {\n      // Invalid or blacklisted parameter, do not cache\n      return originalGetterFunc(pname);\n    }\n    const glState = WebGLStateTracker.get(gl);\n    if (!(pname in glState.cache)) {\n      // WebGL limits are not prepopulated in the cache, call the original getter when first queried.\n      glState.cache[pname] = originalGetterFunc(pname);\n    }\n    // Optionally call the original function to do a \"hard\" query from the WebGL2RenderingContext\n    return glState.enable ?\n    // Call the getter the params so that it can e.g. serve from a cache\n    glState.cache[pname] :\n    // Optionally call the original function to do a \"hard\" query from the WebGL2RenderingContext\n    originalGetterFunc(pname);\n  };\n  // Set the name of this anonymous function to help in debugging and profiling\n  Object.defineProperty(gl[functionName], 'name', {\n    value: `${functionName}-from-cache`,\n    configurable: false\n  });\n}\n/**\n// Overrides a WebGL2RenderingContext state \"setter\" function\n// to call a setter spy before the actual setter. Allows us to keep a cache\n// updated with a copy of the WebGL context state.\n * @param gl\n * @param functionName\n * @param setter\n * @returns\n */\nfunction installSetterSpy(gl, functionName, setter) {\n  // Get the original function from the WebGL2RenderingContext\n  if (!gl[functionName]) {\n    // TODO - remove?\n    // This could happen if we try to intercept WebGL2 method on a WebGL1 context\n    return;\n  }\n  const originalSetterFunc = gl[functionName].bind(gl);\n  // Wrap it with a spy so that we can update our state cache when it gets called\n  gl[functionName] = function set(...params) {\n    // Update the value\n    // Call the setter with the state cache and the params so that it can store the parameters\n    const glState = WebGLStateTracker.get(gl);\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const {\n      valueChanged,\n      oldValue\n    } = setter(glState._updateCache, ...params);\n    // Call the original WebGL2RenderingContext func to make sure the context actually gets updated\n    if (valueChanged) {\n      originalSetterFunc(...params);\n    }\n    // Note: if the original function fails to set the value, our state cache will be bad\n    // No solution for this at the moment, but assuming that this is unlikely to be a real problem\n    // We could call the setter after the originalSetterFunc. Concern is that this would\n    // cause different behavior in debug mode, where originalSetterFunc can throw exceptions\n    return oldValue;\n  };\n  // Set the name of this anonymous function to help in debugging and profiling\n  Object.defineProperty(gl[functionName], 'name', {\n    value: `${functionName}-to-cache`,\n    configurable: false\n  });\n}\nfunction installProgramSpy(gl) {\n  const originalUseProgram = gl.useProgram.bind(gl);\n  gl.useProgram = function useProgramLuma(handle) {\n    const glState = WebGLStateTracker.get(gl);\n    if (glState.program !== handle) {\n      originalUseProgram(handle);\n      glState.program = handle;\n    }\n  };\n}","map":{"version":3,"names":["setGLParameters","getGLParameters","deepArrayEqual","GL_PARAMETER_DEFAULTS","GL_HOOKED_SETTERS","NON_CACHE_PARAMETERS","WebGLStateTracker","get","gl","state","program","stateStack","enable","cache","log","initialized","constructor","props","_updateCache","bind","Object","seal","push","values","pop","oldValues","length","trackState","options","copyState","assign","Error","installProgramSpy","key","setter","installSetterSpy","installGetterOverride","valueChanged","oldValue","value","cached","functionName","originalGetterFunc","pname","undefined","has","glState","defineProperty","configurable","originalSetterFunc","set","params","originalUseProgram","useProgram","useProgramLuma","handle"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\webgl\\src\\context\\state-tracker\\webgl-state-tracker.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {setGLParameters, getGLParameters} from '../parameters/unified-parameter-api';\nimport {deepArrayEqual} from './deep-array-equal';\nimport {\n  GL_PARAMETER_DEFAULTS,\n  GL_HOOKED_SETTERS,\n  NON_CACHE_PARAMETERS\n} from '../parameters/webgl-parameter-tables';\n\n// HELPER CLASS - WebGLStateTracker\n\n/**\n * Support for listening to context state changes and intercepting state queries\n * NOTE: this system does not handle buffer bindings\n */\nexport class WebGLStateTracker {\n  static get(gl: WebGL2RenderingContext): WebGLStateTracker {\n    // @ts-expect-error\n    return gl.state as WebGLStateTracker;\n  }\n\n  gl: WebGL2RenderingContext;\n  program: unknown = null;\n  stateStack: object[] = [];\n  enable = true;\n  cache: Record<string, any> = null!;\n  log;\n\n  protected initialized = false;\n\n  constructor(\n    gl: WebGL2RenderingContext,\n    props?: {\n      log; // Logging function, called when gl parameter change calls are actually issued\n    }\n  ) {\n    this.gl = gl;\n    this.log = props?.log || (() => {});\n\n    this._updateCache = this._updateCache.bind(this);\n    Object.seal(this);\n  }\n\n  push(values = {}) {\n    this.stateStack.push({});\n  }\n\n  pop() {\n    // assert(this.stateStack.length > 0);\n    // Use the saved values in the state stack to restore parameters\n    const oldValues = this.stateStack[this.stateStack.length - 1];\n    setGLParameters(this.gl, oldValues);\n    // Don't pop until we have reset parameters (to make sure other \"stack frames\" are not affected)\n    this.stateStack.pop();\n  }\n\n  /**\n   * Initialize WebGL state caching on a context\n   * can be called multiple times to enable/disable\n   *\n   * @note After calling this function, context state will be cached\n   * .push() and .pop() will be available for saving,\n   * temporarily modifying, and then restoring state.\n   */\n  trackState(gl: WebGL2RenderingContext, options?: {copyState?: boolean}): void {\n    this.cache = options.copyState ? getGLParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);\n\n    if (this.initialized) {\n      throw new Error('WebGLStateTracker');\n    }\n    this.initialized = true;\n\n    // @ts-expect-error\n    this.gl.state = this;\n\n    installProgramSpy(gl);\n\n    // intercept all setter functions in the table\n    for (const key in GL_HOOKED_SETTERS) {\n      const setter = GL_HOOKED_SETTERS[key];\n      installSetterSpy(gl, key, setter);\n    }\n\n    // intercept all getter functions in the table\n    installGetterOverride(gl, 'getParameter');\n    installGetterOverride(gl, 'isEnabled');\n  }\n\n  /**\n  // interceptor for context set functions - update our cache and our stack\n  // values (Object) - the key values for this setter\n   * @param values\n   * @returns\n   */\n  _updateCache(values: {[key: number | string]: any}) {\n    let valueChanged = false;\n    let oldValue; // = undefined\n\n    const oldValues: {[key: number | string]: any} | null =\n      this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;\n\n    for (const key in values) {\n      // assert(key !== undefined);\n      const value = values[key];\n      const cached = this.cache[key];\n      // Check that value hasn't already been shadowed\n      if (!deepArrayEqual(value, cached)) {\n        valueChanged = true;\n        oldValue = cached;\n\n        // First, save current value being shadowed\n        // If a state stack frame is active, save the current parameter values for pop\n        // but first check that value hasn't already been shadowed and saved\n        if (oldValues && !(key in oldValues)) {\n          oldValues[key] = cached;\n        }\n\n        // Save current value being shadowed\n        this.cache[key] = value;\n      }\n    }\n\n    return {valueChanged, oldValue};\n  }\n}\n\n// HELPER FUNCTIONS - INSTALL GET/SET INTERCEPTORS (SPYS) ON THE CONTEXT\n\n/**\n// Overrides a WebGL2RenderingContext state \"getter\" function\n// to return values directly from cache\n * @param gl\n * @param functionName\n */\nfunction installGetterOverride(gl: WebGL2RenderingContext, functionName: string) {\n  // Get the original function from the WebGL2RenderingContext\n  const originalGetterFunc = gl[functionName].bind(gl);\n\n  // Wrap it with a spy so that we can update our state cache when it gets called\n  gl[functionName] = function get(pname) {\n    if (pname === undefined || NON_CACHE_PARAMETERS.has(pname)) {\n      // Invalid or blacklisted parameter, do not cache\n      return originalGetterFunc(pname);\n    }\n\n    const glState = WebGLStateTracker.get(gl);\n    if (!(pname in glState.cache)) {\n      // WebGL limits are not prepopulated in the cache, call the original getter when first queried.\n      glState.cache[pname] = originalGetterFunc(pname);\n    }\n\n    // Optionally call the original function to do a \"hard\" query from the WebGL2RenderingContext\n    return glState.enable\n      ? // Call the getter the params so that it can e.g. serve from a cache\n        glState.cache[pname]\n      : // Optionally call the original function to do a \"hard\" query from the WebGL2RenderingContext\n        originalGetterFunc(pname);\n  };\n\n  // Set the name of this anonymous function to help in debugging and profiling\n  Object.defineProperty(gl[functionName], 'name', {\n    value: `${functionName}-from-cache`,\n    configurable: false\n  });\n}\n\n/**\n// Overrides a WebGL2RenderingContext state \"setter\" function\n// to call a setter spy before the actual setter. Allows us to keep a cache\n// updated with a copy of the WebGL context state.\n * @param gl\n * @param functionName\n * @param setter\n * @returns\n */\nfunction installSetterSpy(gl: WebGL2RenderingContext, functionName: string, setter: Function) {\n  // Get the original function from the WebGL2RenderingContext\n  if (!gl[functionName]) {\n    // TODO - remove?\n    // This could happen if we try to intercept WebGL2 method on a WebGL1 context\n    return;\n  }\n\n  const originalSetterFunc = gl[functionName].bind(gl);\n\n  // Wrap it with a spy so that we can update our state cache when it gets called\n  gl[functionName] = function set(...params) {\n    // Update the value\n    // Call the setter with the state cache and the params so that it can store the parameters\n    const glState = WebGLStateTracker.get(gl);\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const {valueChanged, oldValue} = setter(glState._updateCache, ...params);\n\n    // Call the original WebGL2RenderingContext func to make sure the context actually gets updated\n    if (valueChanged) {\n      originalSetterFunc(...params);\n    }\n\n    // Note: if the original function fails to set the value, our state cache will be bad\n    // No solution for this at the moment, but assuming that this is unlikely to be a real problem\n    // We could call the setter after the originalSetterFunc. Concern is that this would\n    // cause different behavior in debug mode, where originalSetterFunc can throw exceptions\n\n    return oldValue;\n  };\n\n  // Set the name of this anonymous function to help in debugging and profiling\n  Object.defineProperty(gl[functionName], 'name', {\n    value: `${functionName}-to-cache`,\n    configurable: false\n  });\n}\n\nfunction installProgramSpy(gl: WebGL2RenderingContext): void {\n  const originalUseProgram = gl.useProgram.bind(gl);\n\n  gl.useProgram = function useProgramLuma(handle) {\n    const glState = WebGLStateTracker.get(gl);\n    if (glState.program !== handle) {\n      originalUseProgram(handle);\n      glState.program = handle;\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}