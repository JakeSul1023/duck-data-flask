{"ast":null,"code":"import { FileHandleFile, concatenateArrayBuffers, path, NodeFilesystem, NodeFile } from '@loaders.gl/loader-utils';\nimport { generateEoCD, parseEoCDRecord, updateEoCD } from \"./end-of-central-directory.js\";\nimport { CRC32Hash } from '@loaders.gl/crypto';\nimport { generateLocalHeader } from \"./local-file-header.js\";\nimport { generateCDHeader } from \"./cd-file-header.js\";\nimport { fetchFile } from '@loaders.gl/core';\n/**\n * cut off CD and EoCD records from zip file\n * @param provider zip file\n * @returns tuple with three values: CD, EoCD record, EoCD information\n */\nasync function cutTheTailOff(provider) {\n  // define where the body ends\n  const oldEoCDinfo = await parseEoCDRecord(provider);\n  const oldCDStartOffset = oldEoCDinfo.cdStartOffset;\n  // define cd length\n  const oldCDLength = Number(oldEoCDinfo.offsets.zip64EoCDOffset ? oldEoCDinfo.offsets.zip64EoCDOffset - oldCDStartOffset : oldEoCDinfo.offsets.zipEoCDOffset - oldCDStartOffset);\n  // cut off everything except of archieve body\n  const zipEnding = await provider.slice(oldCDStartOffset, provider.length);\n  await provider.truncate(Number(oldCDStartOffset));\n  // divide cd body and eocd record\n  const oldCDBody = zipEnding.slice(0, oldCDLength);\n  const eocdBody = zipEnding.slice(oldCDLength, zipEnding.byteLength);\n  return [oldCDBody, eocdBody, oldEoCDinfo];\n}\n/**\n * generates CD and local headers for the file\n * @param fileName name of the file\n * @param fileToAdd buffer with the file\n * @param localFileHeaderOffset offset of the file local header\n * @returns tuple with two values: local header and file body, cd header\n */\nasync function generateFileHeaders(fileName, fileToAdd, localFileHeaderOffset) {\n  // generating CRC32 of the content\n  const newFileCRC322 = parseInt(await new CRC32Hash().hash(fileToAdd, 'hex'), 16);\n  // generate local header for the file\n  const newFileLocalHeader = generateLocalHeader({\n    crc32: newFileCRC322,\n    fileName,\n    length: fileToAdd.byteLength\n  });\n  // generate hash file cd header\n  const newFileCDHeader = generateCDHeader({\n    crc32: newFileCRC322,\n    fileName,\n    offset: localFileHeaderOffset,\n    length: fileToAdd.byteLength\n  });\n  return [new Uint8Array(concatenateArrayBuffers(newFileLocalHeader, fileToAdd)), new Uint8Array(newFileCDHeader)];\n}\n/**\n * adds one file in the end of the archieve\n * @param zipUrl path to the file\n * @param fileToAdd new file body\n * @param fileName new file name\n */\nexport async function addOneFile(zipUrl, fileToAdd, fileName) {\n  // init file handler\n  const provider = new FileHandleFile(zipUrl, true);\n  const [oldCDBody, eocdBody, oldEoCDinfo] = await cutTheTailOff(provider);\n  // remember the new file local header start offset\n  const newFileOffset = provider.length;\n  const [localPart, cdHeaderPart] = await generateFileHeaders(fileName, fileToAdd, newFileOffset);\n  // write down the file local header\n  await provider.append(localPart);\n  // add the file CD header to the CD\n  const newCDBody = concatenateArrayBuffers(oldCDBody, cdHeaderPart);\n  // remember the CD start offset\n  const newCDStartOffset = provider.length;\n  // write down new CD\n  await provider.append(new Uint8Array(newCDBody));\n  // remember where eocd starts\n  const eocdOffset = provider.length;\n  await provider.append(updateEoCD(eocdBody, oldEoCDinfo.offsets, newCDStartOffset, eocdOffset, oldEoCDinfo.cdRecordsNumber + 1n));\n}\n/**\n * creates zip archive with no compression\n * @note This is a node specific function that works on files\n * @param inputPath path where files for the achive are stored\n * @param outputPath path where zip archive will be placed\n */\nexport async function createZip(inputPath, outputPath, createAdditionalData) {\n  const fileIterator = getFileIterator(inputPath);\n  const resFile = new NodeFile(outputPath, 'w');\n  const fileList = [];\n  const cdArray = [];\n  for await (const file of fileIterator) {\n    await addFile(file, resFile, cdArray, fileList);\n  }\n  if (createAdditionalData) {\n    const additionaldata = await createAdditionalData(fileList);\n    await addFile(additionaldata, resFile, cdArray);\n  }\n  const cdOffset = (await resFile.stat()).bigsize;\n  const cd = concatenateArrayBuffers(...cdArray);\n  await resFile.append(new Uint8Array(cd));\n  const eoCDStart = (await resFile.stat()).bigsize;\n  await resFile.append(new Uint8Array(generateEoCD({\n    recordsNumber: cdArray.length,\n    cdSize: cd.byteLength,\n    cdOffset,\n    eoCDStart\n  })));\n}\n/**\n * Adds file to zip parts\n * @param file file to add\n * @param resFile zip file body\n * @param cdArray zip file central directory\n * @param fileList list of file offsets\n */\nasync function addFile(file, resFile, cdArray, fileList) {\n  const size = (await resFile.stat()).bigsize;\n  fileList?.push({\n    fileName: file.path,\n    localHeaderOffset: size\n  });\n  const [localPart, cdHeaderPart] = await generateFileHeaders(file.path, file.file, size);\n  await resFile.append(localPart);\n  cdArray.push(cdHeaderPart);\n}\n/**\n * creates iterator providing buffer with file content and path to every file in the input folder\n * @param inputPath path to the input folder\n * @returns iterator\n */\nexport function getFileIterator(inputPath) {\n  async function* iterable() {\n    const fileList = await getAllFiles(inputPath);\n    for (const filePath of fileList) {\n      const file = await (await fetchFile(path.join(inputPath, filePath))).arrayBuffer();\n      yield {\n        path: filePath,\n        file\n      };\n    }\n  }\n  return iterable();\n}\n/**\n * creates a list of relative paths to all files in the provided folder\n * @param basePath path of the root folder\n * @param subfolder relative path from the root folder.\n * @returns list of paths\n */\nexport async function getAllFiles(basePath, subfolder = '', fsPassed) {\n  const fs = fsPassed ? fsPassed : new NodeFilesystem({});\n  const files = await fs.readdir(pathJoin(basePath, subfolder));\n  const arrayOfFiles = [];\n  for (const file of files) {\n    const fullPath = pathJoin(basePath, subfolder, file);\n    if ((await fs.stat(fullPath)).isDirectory) {\n      const files = await getAllFiles(basePath, pathJoin(subfolder, file));\n      arrayOfFiles.push(...files);\n    } else {\n      arrayOfFiles.push(pathJoin(subfolder, file));\n    }\n  }\n  return arrayOfFiles;\n}\n/**\n * removes empty parts from path array and joins it\n * @param paths paths to join\n * @returns joined path\n */\nfunction pathJoin(...paths) {\n  const resPaths = paths.filter(val => val.length);\n  return path.join(...resPaths);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}