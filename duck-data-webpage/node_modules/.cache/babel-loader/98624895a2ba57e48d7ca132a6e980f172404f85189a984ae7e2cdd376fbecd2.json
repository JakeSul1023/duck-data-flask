{"ast":null,"code":"// GLTF EXTENSION: KHR_techniques_webgl\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_techniques_webgl\nimport { GLTFScenegraph } from \"../../api/gltf-scenegraph.js\";\nconst KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\nexport const name = KHR_TECHNIQUES_WEBGL;\nexport async function decode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = gltfScenegraph;\n  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n  if (extension) {\n    const techniques = resolveTechniques(extension, gltfScenegraph);\n    for (const material of json.materials || []) {\n      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n      if (materialExtension) {\n        // @ts-ignore TODO\n        material.technique = Object.assign({}, materialExtension,\n        // @ts-ignore\n        techniques[materialExtension.technique]);\n        // @ts-ignore TODO\n        material.technique.values = resolveValues(material.technique, gltfScenegraph);\n      }\n      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n    }\n    // Remove the top-level extension\n    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n  }\n}\n// eslint-disable-next-line\nexport async function encode(gltfData, options) {\n  // TODO\n}\nfunction resolveTechniques(techniquesExtension,\n// programs: {[key: string]: any}[],\n// shaders: {[key: string]: any}[],\n// techniques: {[key: string]: any}[]\ngltfScenegraph) {\n  const {\n    programs = [],\n    shaders = [],\n    techniques = []\n  } = techniquesExtension;\n  const textDecoder = new TextDecoder();\n  shaders.forEach(shader => {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));\n    } else {\n      // TODO: handle URI shader\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n  programs.forEach(program => {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n  techniques.forEach(technique => {\n    technique.program = programs[technique.program];\n  });\n  return techniques;\n}\nfunction resolveValues(technique, gltfScenegraph) {\n  const values = Object.assign({}, technique.values);\n  // merge values from uniforms\n  Object.keys(technique.uniforms || {}).forEach(uniform => {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n  // resolve textures\n  Object.keys(values).forEach(uniform => {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      // Assume this is a texture\n      // TODO: find if there are any other types that can be referenced\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n  return values;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}