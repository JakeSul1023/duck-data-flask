{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport Pass from \"./pass.js\";\n/** A Pass that renders all layers */\nexport default class LayersPass extends Pass {\n  constructor() {\n    super(...arguments);\n    this._lastRenderIndex = -1;\n  }\n  render(options) {\n    // @ts-expect-error TODO - assuming WebGL context\n    const [width, height] = this.device.canvasContext.getDrawingBufferSize();\n    // Explicitly specify clearColor and clearDepth, overriding render pass defaults.\n    const clearCanvas = options.clearCanvas ?? true;\n    const clearColor = options.clearColor ?? (clearCanvas ? [0, 0, 0, 0] : false);\n    const clearDepth = clearCanvas ? 1 : false;\n    const clearStencil = clearCanvas ? 0 : false;\n    const colorMask = options.colorMask ?? 0xf;\n    const parameters = {\n      viewport: [0, 0, width, height]\n    };\n    if (options.colorMask) {\n      parameters.colorMask = colorMask;\n    }\n    if (options.scissorRect) {\n      parameters.scissorRect = options.scissorRect;\n    }\n    const renderPass = this.device.beginRenderPass({\n      framebuffer: options.target,\n      parameters,\n      clearColor: clearColor,\n      clearDepth,\n      clearStencil\n    });\n    try {\n      return this._drawLayers(renderPass, options);\n    } finally {\n      renderPass.end();\n      // TODO(ibgreen): WebGPU - submit may not be needed here but initial port had issues with out of render loop rendering\n      this.device.submit();\n    }\n  }\n  /** Draw a list of layers in a list of viewports */\n  _drawLayers(renderPass, options) {\n    const {\n      target,\n      shaderModuleProps,\n      viewports,\n      views,\n      onViewportActive,\n      clearStack = true\n    } = options;\n    options.pass = options.pass || 'unknown';\n    if (clearStack) {\n      this._lastRenderIndex = -1;\n    }\n    const renderStats = [];\n    for (const viewport of viewports) {\n      const view = views && views[viewport.id];\n      // Update context to point to this viewport\n      onViewportActive?.(viewport);\n      const drawLayerParams = this._getDrawLayerParams(viewport, options);\n      // render this viewport\n      const subViewports = viewport.subViewports || [viewport];\n      for (const subViewport of subViewports) {\n        const stats = this._drawLayersInViewport(renderPass, {\n          target,\n          shaderModuleProps,\n          viewport: subViewport,\n          view,\n          pass: options.pass,\n          layers: options.layers\n        }, drawLayerParams);\n        renderStats.push(stats);\n      }\n    }\n    return renderStats;\n  }\n  // When a viewport contains multiple subviewports (e.g. repeated web mercator map),\n  // this is only done once for the parent viewport\n  /* Resolve the parameters needed to draw each layer */\n  _getDrawLayerParams(viewport, _ref) {\n    let {\n      layers,\n      pass,\n      isPicking = false,\n      layerFilter,\n      cullRect,\n      effects,\n      shaderModuleProps\n    } = _ref;\n    let evaluateShouldDrawOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const drawLayerParams = [];\n    const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);\n    const drawContext = {\n      layer: layers[0],\n      viewport,\n      isPicking,\n      renderPass: pass,\n      cullRect\n    };\n    const layerFilterCache = {};\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex];\n      // Check if we should draw layer\n      const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);\n      const layerParam = {\n        shouldDrawLayer\n      };\n      if (shouldDrawLayer && !evaluateShouldDrawOnly) {\n        layerParam.shouldDrawLayer = true;\n        // This is the \"logical\" index for ordering this layer in the stack\n        // used to calculate polygon offsets\n        // It can be the same as another layer\n        layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);\n        layerParam.shaderModuleProps = this._getShaderModuleProps(layer, effects, pass, shaderModuleProps);\n        layerParam.layerParameters = {\n          ...layer.context.deck?.props.parameters,\n          ...this.getLayerParameters(layer, layerIndex, viewport)\n        };\n      }\n      drawLayerParams[layerIndex] = layerParam;\n    }\n    return drawLayerParams;\n  }\n  // Draws a list of layers in one viewport\n  // TODO - when picking we could completely skip rendering viewports that dont\n  // intersect with the picking rect\n  /* eslint-disable max-depth, max-statements */\n  _drawLayersInViewport(renderPass, _ref2, drawLayerParams) {\n    let {\n      layers,\n      shaderModuleProps: globalModuleParameters,\n      pass,\n      target,\n      viewport,\n      view\n    } = _ref2;\n    const glViewport = getGLViewport(this.device, {\n      shaderModuleProps: globalModuleParameters,\n      target,\n      viewport\n    });\n    if (view && view.props.clear) {\n      const clearOpts = view.props.clear === true ? {\n        color: true,\n        depth: true\n      } : view.props.clear;\n      const clearRenderPass = this.device.beginRenderPass({\n        framebuffer: target,\n        parameters: {\n          viewport: glViewport,\n          scissorRect: glViewport\n        },\n        clearColor: clearOpts.color ? [0, 0, 0, 0] : false,\n        clearDepth: clearOpts.depth ? 1 : false\n      });\n      clearRenderPass.end();\n    }\n    // render layers in normal colors\n    const renderStatus = {\n      totalCount: layers.length,\n      visibleCount: 0,\n      compositeCount: 0,\n      pickableCount: 0\n    };\n    renderPass.setParameters({\n      viewport: glViewport\n    });\n    // render layers in normal colors\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex];\n      const drawLayerParameters = drawLayerParams[layerIndex];\n      const {\n        shouldDrawLayer\n      } = drawLayerParameters;\n      // Calculate stats\n      if (shouldDrawLayer && layer.props.pickable) {\n        renderStatus.pickableCount++;\n      }\n      if (layer.isComposite) {\n        renderStatus.compositeCount++;\n      }\n      if (layer.isDrawable && drawLayerParameters.shouldDrawLayer) {\n        const {\n          layerRenderIndex,\n          shaderModuleProps,\n          layerParameters\n        } = drawLayerParameters;\n        // Draw the layer\n        renderStatus.visibleCount++;\n        this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);\n        // overwrite layer.context.viewport with the sub viewport\n        if (shaderModuleProps.project) {\n          shaderModuleProps.project.viewport = viewport;\n        }\n        // TODO v9 - we are sending renderPass both as a parameter and through the context.\n        // Long-term, it is likely better not to have user defined layer methods have to access\n        // the \"global\" layer context.\n        layer.context.renderPass = renderPass;\n        try {\n          layer._drawLayer({\n            renderPass,\n            shaderModuleProps,\n            uniforms: {\n              layerIndex: layerRenderIndex\n            },\n            parameters: layerParameters\n          });\n        } catch (err) {\n          layer.raiseError(err, `drawing ${layer} to ${pass}`);\n        }\n      }\n    }\n    return renderStatus;\n  }\n  /* eslint-enable max-depth, max-statements */\n  /* Methods for subclass overrides */\n  shouldDrawLayer(layer) {\n    return true;\n  }\n  getShaderModuleProps(layer, effects, otherShaderModuleProps) {\n    return null;\n  }\n  getLayerParameters(layer, layerIndex, viewport) {\n    return layer.props.parameters;\n  }\n  /* Private */\n  _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {\n    const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);\n    if (!shouldDrawLayer) {\n      return false;\n    }\n    drawContext.layer = layer;\n    let parent = layer.parent;\n    while (parent) {\n      // @ts-ignore\n      if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {\n        return false;\n      }\n      drawContext.layer = parent;\n      parent = parent.parent;\n    }\n    if (layerFilter) {\n      const rootLayerId = drawContext.layer.id;\n      if (!(rootLayerId in layerFilterCache)) {\n        layerFilterCache[rootLayerId] = layerFilter(drawContext);\n      }\n      if (!layerFilterCache[rootLayerId]) {\n        return false;\n      }\n    }\n    // If a layer is drawn, update its viewportChanged flag\n    layer.activateViewport(drawContext.viewport);\n    return true;\n  }\n  _getShaderModuleProps(layer, effects, pass, overrides) {\n    // @ts-expect-error TODO - assuming WebGL context\n    const devicePixelRatio = this.device.canvasContext.cssToDeviceRatio();\n    const layerProps = layer.internalState?.propsInTransition || layer.props;\n    const shaderModuleProps = {\n      layer: layerProps,\n      picking: {\n        isActive: false\n      },\n      project: {\n        viewport: layer.context.viewport,\n        devicePixelRatio,\n        modelMatrix: layerProps.modelMatrix,\n        coordinateSystem: layerProps.coordinateSystem,\n        coordinateOrigin: layerProps.coordinateOrigin,\n        autoWrapLongitude: layer.wrapLongitude\n      }\n    };\n    if (effects) {\n      for (const effect of effects) {\n        mergeModuleParameters(shaderModuleProps, effect.getShaderModuleProps?.(layer, shaderModuleProps));\n      }\n    }\n    return mergeModuleParameters(shaderModuleProps, this.getShaderModuleProps(layer, effects, shaderModuleProps), overrides);\n  }\n}\n// If the _index prop is defined, return a layer index that's relative to its parent\n// Otherwise return the index of the layer among all rendered layers\n// This is done recursively, i.e. if the user overrides a layer's default index,\n// all its descendants will be resolved relative to that index.\n// This implementation assumes that parent layers always appear before its children\n// which is true if the layer array comes from the LayerManager\nexport function layerIndexResolver() {\n  let startIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let layerIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const resolvers = {};\n  const resolveLayerIndex = (layer, isDrawn) => {\n    const indexOverride = layer.props._offset;\n    const layerId = layer.id;\n    const parentId = layer.parent && layer.parent.id;\n    let index;\n    if (parentId && !(parentId in layerIndices)) {\n      // Populate layerIndices with the parent layer's index\n      resolveLayerIndex(layer.parent, false);\n    }\n    if (parentId in resolvers) {\n      const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);\n      index = resolver(layer, isDrawn);\n      resolvers[layerId] = resolver;\n    } else if (Number.isFinite(indexOverride)) {\n      index = indexOverride + (layerIndices[parentId] || 0);\n      // Mark layer as needing its own resolver\n      // We don't actually create it until it's used for the first time\n      resolvers[layerId] = null;\n    } else {\n      index = startIndex;\n    }\n    if (isDrawn && index >= startIndex) {\n      startIndex = index + 1;\n    }\n    layerIndices[layerId] = index;\n    return index;\n  };\n  return resolveLayerIndex;\n}\n// Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\nfunction getGLViewport(device, _ref3) {\n  let {\n    shaderModuleProps,\n    target,\n    viewport\n  } = _ref3;\n  const pixelRatio = shaderModuleProps?.project?.devicePixelRatio ??\n  // @ts-expect-error TODO - assuming WebGL context\n  device.canvasContext.cssToDeviceRatio();\n  // Default framebuffer is used when writing to canvas\n  // @ts-expect-error TODO - assuming WebGL context\n  const [, drawingBufferHeight] = device.canvasContext.getDrawingBufferSize();\n  const height = target ? target.height : drawingBufferHeight;\n  // Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\n  const dimensions = viewport;\n  return [dimensions.x * pixelRatio, height - (dimensions.y + dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];\n}\nfunction mergeModuleParameters(target) {\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n  for (const source of sources) {\n    if (source) {\n      for (const key in source) {\n        if (target[key]) {\n          Object.assign(target[key], source[key]);\n        } else {\n          target[key] = source[key];\n        }\n      }\n    }\n  }\n  return target;\n}\n//# sourceMappingURL=layers-pass.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}