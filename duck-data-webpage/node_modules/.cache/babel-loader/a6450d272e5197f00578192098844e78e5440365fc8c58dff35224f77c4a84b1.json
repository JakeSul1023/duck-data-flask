{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@luma.gl/core';\nimport { Matrix4, Quaternion } from '@math.gl/core';\n// TODO: import from loaders.gl?\nexport const ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nclass GLTFAnimation {\n  name;\n  startTime = 0;\n  playing = true;\n  speed = 1;\n  channels = [];\n  constructor(props) {\n    Object.assign(this, props);\n  }\n  animate(timeMs) {\n    if (!this.playing) {\n      return;\n    }\n    const absTime = timeMs / 1000;\n    const time = (absTime - this.startTime) * this.speed;\n    this.channels.forEach(({\n      sampler,\n      target,\n      path\n    }) => {\n      interpolate(time, sampler, target, path);\n      applyTranslationRotationScale(target, target._node);\n    });\n  }\n}\nexport class GLTFAnimator {\n  animations;\n  constructor(gltf) {\n    this.animations = gltf.animations.map((animation, index) => {\n      const name = animation.name || `Animation-${index}`;\n      const samplers = animation.samplers.map(({\n        input,\n        interpolation = 'LINEAR',\n        output\n      }) => ({\n        input: accessorToJsArray(gltf.accessors[input]),\n        interpolation,\n        output: accessorToJsArray(gltf.accessors[output])\n      }));\n      const channels = animation.channels.map(({\n        sampler,\n        target\n      }) => ({\n        sampler: samplers[sampler],\n        target: gltf.nodes[target.node],\n        path: target.path\n      }));\n      return new GLTFAnimation({\n        name,\n        channels\n      });\n    });\n  }\n  /** @deprecated Use .setTime(). Will be removed (deck.gl is using this) */\n  animate(time) {\n    this.setTime(time);\n  }\n  setTime(time) {\n    this.animations.forEach(animation => animation.animate(time));\n  }\n  getAnimations() {\n    return this.animations;\n  }\n}\n//\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    const length = components * accessor.count;\n    const {\n      buffer,\n      byteOffset\n    } = accessor.bufferView.data;\n    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      // Slice array\n      const slicedArray = [];\n      for (let i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n      accessor._animation = slicedArray;\n    }\n  }\n  return accessor._animation;\n}\n// TODO: share with GLTFInstantiator\nconst helperMatrix = new Matrix4();\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n  if (gltfNode.rotation) {\n    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\nconst quaternion = new Quaternion();\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    // SLERP when path is rotation\n    quaternion.slerp({\n      start,\n      target: stop,\n      ratio\n    });\n    for (let i = 0; i < quaternion.length; i++) {\n      target[path][i] = quaternion[i];\n    }\n  } else {\n    // regular interpolation\n    for (let i = 0; i < start.length; i++) {\n      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];\n    }\n  }\n}\nfunction cubicsplineInterpolate(target, path, {\n  p0,\n  outTangent0,\n  inTangent1,\n  p1,\n  tDiff,\n  ratio: t\n}) {\n  // TODO: Quaternion might need normalization\n  for (let i = 0; i < target[path].length; i++) {\n    const m0 = outTangent0[i] * tDiff;\n    const m1 = inTangent1[i] * tDiff;\n    target[path][i] = (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] + (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 + (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] + (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\nfunction stepInterpolate(target, path, value) {\n  for (let i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\nfunction interpolate(time, {\n  input,\n  interpolation,\n  output\n}, target, path) {\n  const maxTime = input[input.length - 1];\n  const animationTime = time % maxTime;\n  const nextIndex = input.findIndex(t => t >= animationTime);\n  const previousIndex = Math.max(0, nextIndex - 1);\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n      default:\n        log.warn(`Bad animation path ${path}`)();\n    }\n  }\n  // assert(target[path].length === output[previousIndex].length);\n  const previousTime = input[previousIndex];\n  const nextTime = input[nextIndex];\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n      break;\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        const tDiff = nextTime - previousTime;\n        const p0 = output[3 * previousIndex + 1];\n        const outTangent0 = output[3 * previousIndex + 2];\n        const inTangent1 = output[3 * nextIndex + 0];\n        const p1 = output[3 * nextIndex + 1];\n        cubicsplineInterpolate(target, path, {\n          p0,\n          outTangent0,\n          inTangent1,\n          p1,\n          tDiff,\n          ratio\n        });\n      }\n      break;\n    default:\n      log.warn(`Interpolation ${interpolation} not supported`)();\n      break;\n  }\n}\n//# sourceMappingURL=gltf-animator.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}