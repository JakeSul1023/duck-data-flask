{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { project32 } from '@deck.gl/core';\nimport { WebGLAggregator, CPUAggregator } from \"../common/aggregator/index.js\";\nimport AggregationLayer from \"../common/aggregation-layer.js\";\nimport ScreenGridCellLayer from \"./screen-grid-cell-layer.js\";\nimport { binOptionsUniforms } from \"./bin-options-uniforms.js\";\nimport { defaultColorRange } from \"../common/utils/color-utils.js\";\nconst defaultProps = {\n  cellSizePixels: {\n    type: 'number',\n    value: 100,\n    min: 1\n  },\n  cellMarginPixels: {\n    type: 'number',\n    value: 2,\n    min: 0\n  },\n  colorRange: defaultColorRange,\n  colorScaleType: 'linear',\n  getPosition: {\n    type: 'accessor',\n    value: d => d.position\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  gpuAggregation: true,\n  aggregation: 'SUM'\n};\n/** Aggregates data into histogram bins and renders them as a grid. */\nclass ScreenGridLayer extends AggregationLayer {\n  getAggregatorType() {\n    return this.props.gpuAggregation && WebGLAggregator.isSupported(this.context.device) ? 'gpu' : 'cpu';\n  }\n  createAggregator(type) {\n    if (type === 'cpu' || !WebGLAggregator.isSupported(this.context.device)) {\n      return new CPUAggregator({\n        dimensions: 2,\n        getBin: {\n          sources: ['positions'],\n          getValue: (_ref, index, opts) => {\n            let {\n              positions\n            } = _ref;\n            const viewport = this.context.viewport;\n            const p = viewport.project(positions);\n            const cellSizePixels = opts.cellSizePixels;\n            if (p[0] < 0 || p[0] >= viewport.width || p[1] < 0 || p[1] >= viewport.height) {\n              // Not on screen\n              return null;\n            }\n            return [Math.floor(p[0] / cellSizePixels), Math.floor(p[1] / cellSizePixels)];\n          }\n        },\n        getValue: [{\n          sources: ['counts'],\n          getValue: _ref2 => {\n            let {\n              counts\n            } = _ref2;\n            return counts;\n          }\n        }]\n      });\n    }\n    return new WebGLAggregator(this.context.device, {\n      dimensions: 2,\n      channelCount: 1,\n      bufferLayout: this.getAttributeManager().getBufferLayouts({\n        isInstanced: false\n      }),\n      ...super.getShaders({\n        modules: [project32, binOptionsUniforms],\n        vs: `\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float counts;\n  \n  void getBin(out ivec2 binId) {\n    vec4 pos = project_position_to_clipspace(positions, positions64Low, vec3(0.0));\n    vec2 screenCoords = vec2(pos.x / pos.w + 1.0, 1.0 - pos.y / pos.w) / 2.0 * project.viewportSize / project.devicePixelRatio;\n    vec2 gridCoords = floor(screenCoords / binOptions.cellSizePixels);\n    binId = ivec2(gridCoords);\n  }\n  void getValue(out float weight) {\n    weight = counts;\n  }\n  `\n      })\n    });\n  }\n  initializeState() {\n    super.initializeState();\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 'float64',\n        fp64: this.use64bitPositions()\n      },\n      // this attribute is used in gpu aggregation path only\n      counts: {\n        size: 1,\n        accessor: 'getWeight'\n      }\n    });\n  }\n  shouldUpdateState(_ref3) {\n    let {\n      changeFlags\n    } = _ref3;\n    return changeFlags.somethingChanged;\n  }\n  updateState(params) {\n    const aggregatorChanged = super.updateState(params);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const {\n      cellSizePixels,\n      aggregation\n    } = props;\n    if (aggregatorChanged || changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.viewportChanged || aggregation !== oldProps.aggregation || cellSizePixels !== oldProps.cellSizePixels) {\n      const {\n        width,\n        height\n      } = this.context.viewport;\n      const {\n        aggregator\n      } = this.state;\n      if (aggregator instanceof WebGLAggregator) {\n        aggregator.setProps({\n          binIdRange: [[0, Math.ceil(width / cellSizePixels)], [0, Math.ceil(height / cellSizePixels)]]\n        });\n      }\n      aggregator.setProps({\n        pointCount: this.getNumInstances(),\n        operations: [aggregation],\n        binOptions: {\n          cellSizePixels\n        }\n      });\n    }\n    if (changeFlags.viewportChanged) {\n      // Rerun aggregation on viewport change\n      this.state.aggregator.setNeedsUpdate();\n    }\n    return aggregatorChanged;\n  }\n  onAttributeChange(id) {\n    const {\n      aggregator\n    } = this.state;\n    switch (id) {\n      case 'positions':\n        aggregator.setNeedsUpdate();\n        break;\n      case 'counts':\n        aggregator.setNeedsUpdate(0);\n        break;\n      default:\n      // This should not happen\n    }\n  }\n  renderLayers() {\n    const {\n      aggregator\n    } = this.state;\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n    const binAttribute = aggregator.getBins();\n    const weightAttribute = aggregator.getResult(0);\n    return new CellLayerClass(this.props, this.getSubLayerProps({\n      id: 'cell-layer'\n    }), {\n      data: {\n        length: aggregator.binCount,\n        attributes: {\n          getBin: binAttribute,\n          getWeight: weightAttribute\n        }\n      },\n      // Data has changed shallowly, but we likely don't need to update the attributes\n      dataComparator: (data, oldData) => data.length === oldData.length,\n      updateTriggers: {\n        getBin: [binAttribute],\n        getWeight: [weightAttribute]\n      },\n      parameters: {\n        depthWriteEnabled: false,\n        ...this.props.parameters\n      },\n      // Evaluate domain at draw() time\n      colorDomain: () => this.props.colorDomain || aggregator.getResultDomain(0),\n      // Extensions are already handled by the GPUAggregator, do not pass it down\n      extensions: []\n    });\n  }\n  getPickingInfo(params) {\n    const info = params.info;\n    const {\n      index\n    } = info;\n    if (index >= 0) {\n      const bin = this.state.aggregator.getBin(index);\n      let object;\n      if (bin) {\n        object = {\n          col: bin.id[0],\n          row: bin.id[1],\n          value: bin.value[0],\n          count: bin.count\n        };\n        if (bin.pointIndices) {\n          object.pointIndices = bin.pointIndices;\n          object.points = Array.isArray(this.props.data) ? bin.pointIndices.map(i => this.props.data[i]) : [];\n        }\n      }\n      info.object = object;\n    }\n    return info;\n  }\n}\nScreenGridLayer.layerName = 'ScreenGridLayer';\nScreenGridLayer.defaultProps = defaultProps;\nexport default ScreenGridLayer;\n//# sourceMappingURL=screen-grid-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}