{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@deck.gl/core';\nimport IconLayer from \"../../icon-layer/icon-layer.js\";\nimport { sdfUniforms } from \"./sdf-uniforms.js\";\nimport fs from \"./multi-icon-layer-fragment.glsl.js\";\n// TODO expose as layer properties\nconst DEFAULT_BUFFER = 192.0 / 256;\nconst EMPTY_ARRAY = [];\nconst defaultProps = {\n  getIconOffsets: {\n    type: 'accessor',\n    value: x => x.offsets\n  },\n  alphaCutoff: 0.001,\n  smoothing: 0.1,\n  outlineWidth: 0,\n  outlineColor: {\n    type: 'color',\n    value: [0, 0, 0, 255]\n  }\n};\nclass MultiIconLayer extends IconLayer {\n  getShaders() {\n    const shaders = super.getShaders();\n    return {\n      ...shaders,\n      modules: [...shaders.modules, sdfUniforms],\n      fs\n    };\n  }\n  initializeState() {\n    super.initializeState();\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instanceOffsets: {\n        size: 2,\n        accessor: 'getIconOffsets'\n      },\n      instancePickingColors: {\n        type: 'uint8',\n        size: 3,\n        accessor: (object, {\n          index,\n          target: value\n        }) => this.encodePickingColor(index, value)\n      }\n    });\n  }\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps\n    } = params;\n    let {\n      outlineColor\n    } = props;\n    if (outlineColor !== oldProps.outlineColor) {\n      outlineColor = outlineColor.map(x => x / 255);\n      outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;\n      this.setState({\n        outlineColor\n      });\n    }\n    if (!props.sdf && props.outlineWidth) {\n      log.warn(`${this.id}: fontSettings.sdf is required to render outline`)();\n    }\n  }\n  draw(params) {\n    const {\n      sdf,\n      smoothing,\n      outlineWidth\n    } = this.props;\n    const {\n      outlineColor\n    } = this.state;\n    const outlineBuffer = outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER * (1 - outlineWidth)) : -1;\n    const model = this.state.model;\n    const sdfProps = {\n      buffer: DEFAULT_BUFFER,\n      outlineBuffer,\n      gamma: smoothing,\n      enabled: Boolean(sdf),\n      outlineColor\n    };\n    model.shaderInputs.setProps({\n      sdf: sdfProps\n    });\n    super.draw(params);\n    // draw text without outline on top to ensure a thick outline won't occlude other characters\n    if (sdf && outlineWidth) {\n      const {\n        iconManager\n      } = this.state;\n      const iconsTexture = iconManager.getTexture();\n      if (iconsTexture) {\n        model.shaderInputs.setProps({\n          sdf: {\n            ...sdfProps,\n            outlineBuffer: DEFAULT_BUFFER\n          }\n        });\n        model.draw(this.context.renderPass);\n      }\n    }\n  }\n  getInstanceOffset(icons) {\n    return icons ? Array.from(icons).flatMap(icon => super.getInstanceOffset(icon)) : EMPTY_ARRAY;\n  }\n  getInstanceColorMode(icons) {\n    return 1; // mask\n  }\n  getInstanceIconFrame(icons) {\n    return icons ? Array.from(icons).flatMap(icon => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY;\n  }\n}\nMultiIconLayer.defaultProps = defaultProps;\nMultiIconLayer.layerName = 'MultiIconLayer';\nexport default MultiIconLayer;\n//# sourceMappingURL=multi-icon-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}