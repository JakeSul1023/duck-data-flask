{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n/* eslint-disable */\nimport { Vector3, Matrix4, assert, equals, _MathUtils, vec3 } from '@math.gl/core';\nimport { WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z } from \"../constants.js\";\nimport { fromCartographicToRadians, toCartographicFromRadians } from \"../type-utils.js\";\nimport { localFrameToFixedFrame } from \"./helpers/ellipsoid-transform.js\";\nimport { scaleToGeodeticSurface } from \"./helpers/scale-to-geodetic-surface.js\";\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\nconst scratchK = new Vector3();\nconst scratchPosition = new Vector3();\nconst scratchHeight = new Vector3();\nconst scratchCartesian = new Vector3();\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * `(x / a)^2 + (y / b)^2 + (z / c)^2 = 1`.  Primarily used\n * to represent the shape of planetary bodies.\n */\nexport class Ellipsoid {\n  constructor(x = 0.0, y = 0.0, z = 0.0) {\n    this.centerToleranceSquared = _MathUtils.EPSILON1;\n    assert(x >= 0.0);\n    assert(y >= 0.0);\n    assert(z >= 0.0);\n    this.radii = new Vector3(x, y, z);\n    this.radiiSquared = new Vector3(x * x, y * y, z * z);\n    this.radiiToTheFourth = new Vector3(x * x * x * x, y * y * y * y, z * z * z * z);\n    this.oneOverRadii = new Vector3(x === 0.0 ? 0.0 : 1.0 / x, y === 0.0 ? 0.0 : 1.0 / y, z === 0.0 ? 0.0 : 1.0 / z);\n    this.oneOverRadiiSquared = new Vector3(x === 0.0 ? 0.0 : 1.0 / (x * x), y === 0.0 ? 0.0 : 1.0 / (y * y), z === 0.0 ? 0.0 : 1.0 / (z * z));\n    this.minimumRadius = Math.min(x, y, z);\n    this.maximumRadius = Math.max(x, y, z);\n    if (this.radiiSquared.z !== 0) {\n      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;\n    }\n    Object.freeze(this);\n  }\n  /** Compares this Ellipsoid against the provided Ellipsoid componentwise */\n  equals(right) {\n    return this === right || Boolean(right && this.radii.equals(right.radii));\n  }\n  /** Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'. */\n  toString() {\n    return this.radii.toString();\n  }\n  cartographicToCartesian(cartographic, result = [0, 0, 0]) {\n    const normal = scratchNormal;\n    const k = scratchK;\n    const [,, height] = cartographic;\n    this.geodeticSurfaceNormalCartographic(cartographic, normal);\n    k.copy(this.radiiSquared).scale(normal);\n    const gamma = Math.sqrt(normal.dot(k));\n    k.scale(1 / gamma);\n    normal.scale(height);\n    k.add(normal);\n    return k.to(result);\n  }\n  cartesianToCartographic(cartesian, result = [0, 0, 0]) {\n    scratchCartesian.from(cartesian);\n    const point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition);\n    if (!point) {\n      return undefined;\n    }\n    const normal = this.geodeticSurfaceNormal(point, scratchNormal);\n    const h = scratchHeight;\n    h.copy(scratchCartesian).subtract(point);\n    const longitude = Math.atan2(normal.y, normal.x);\n    const latitude = Math.asin(normal.z);\n    const height = Math.sign(vec3.dot(h, scratchCartesian)) * vec3.length(h);\n    return toCartographicFromRadians([longitude, latitude, height], result);\n  }\n  eastNorthUpToFixedFrame(origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, 'east', 'north', 'up', origin, result);\n  }\n  // Computes a 4x4 transformation matrix from a reference frame centered at\n  // the provided origin to the ellipsoid's fixed reference frame.\n  localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);\n  }\n  geocentricSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector.from(cartesian).normalize().to(result);\n  }\n  geodeticSurfaceNormalCartographic(cartographic, result = [0, 0, 0]) {\n    const cartographicVectorRadians = fromCartographicToRadians(cartographic);\n    const longitude = cartographicVectorRadians[0];\n    const latitude = cartographicVectorRadians[1];\n    const cosLatitude = Math.cos(latitude);\n    scratchVector.set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude)).normalize();\n    return scratchVector.to(result);\n  }\n  geodeticSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);\n  }\n  /** Scales the provided Cartesian position along the geodetic surface normal\n   * so that it is on the surface of this ellipsoid.  If the position is\n   * at the center of the ellipsoid, this function returns undefined. */\n  scaleToGeodeticSurface(cartesian, result) {\n    return scaleToGeodeticSurface(cartesian, this, result);\n  }\n  /** Scales the provided Cartesian position along the geocentric surface normal\n   * so that it is on the surface of this ellipsoid. */\n  scaleToGeocentricSurface(cartesian, result = [0, 0, 0]) {\n    scratchPosition.from(cartesian);\n    const positionX = scratchPosition.x;\n    const positionY = scratchPosition.y;\n    const positionZ = scratchPosition.z;\n    const oneOverRadiiSquared = this.oneOverRadiiSquared;\n    const beta = 1.0 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);\n    return scratchPosition.multiplyScalar(beta).to(result);\n  }\n  /** Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n   * its components by the result of `Ellipsoid#oneOverRadii` */\n  transformPositionToScaledSpace(position, result = [0, 0, 0]) {\n    return scratchPosition.from(position).scale(this.oneOverRadii).to(result);\n  }\n  /** Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n   * its components by the result of `Ellipsoid#radii`. */\n  transformPositionFromScaledSpace(position, result = [0, 0, 0]) {\n    return scratchPosition.from(position).scale(this.radii).to(result);\n  }\n  /** Computes a point which is the intersection of the surface normal with the z-axis. */\n  getSurfaceNormalIntersectionWithZAxis(position, buffer = 0, result = [0, 0, 0]) {\n    // Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\n    assert(equals(this.radii.x, this.radii.y, _MathUtils.EPSILON15));\n    assert(this.radii.z > 0);\n    scratchPosition.from(position);\n    const z = scratchPosition.z * (1 - this.squaredXOverSquaredZ);\n    if (Math.abs(z) >= this.radii.z - buffer) {\n      return undefined;\n    }\n    return scratchPosition.set(0.0, 0.0, z).to(result);\n  }\n}\n/** An Ellipsoid instance initialized to the WGS84 standard. */\nEllipsoid.WGS84 = new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z);","map":{"version":3,"names":["Vector3","Matrix4","assert","equals","_MathUtils","vec3","WGS84_RADIUS_X","WGS84_RADIUS_Y","WGS84_RADIUS_Z","fromCartographicToRadians","toCartographicFromRadians","localFrameToFixedFrame","scaleToGeodeticSurface","scratchVector","scratchNormal","scratchK","scratchPosition","scratchHeight","scratchCartesian","Ellipsoid","constructor","x","y","z","centerToleranceSquared","EPSILON1","radii","radiiSquared","radiiToTheFourth","oneOverRadii","oneOverRadiiSquared","minimumRadius","Math","min","maximumRadius","max","squaredXOverSquaredZ","Object","freeze","right","Boolean","toString","cartographicToCartesian","cartographic","result","normal","k","height","geodeticSurfaceNormalCartographic","copy","scale","gamma","sqrt","dot","add","to","cartesianToCartographic","cartesian","from","point","undefined","geodeticSurfaceNormal","h","subtract","longitude","atan2","latitude","asin","sign","length","eastNorthUpToFixedFrame","origin","firstAxis","secondAxis","thirdAxis","geocentricSurfaceNormal","normalize","cartographicVectorRadians","cosLatitude","cos","set","sin","scaleToGeocentricSurface","positionX","positionY","positionZ","beta","multiplyScalar","transformPositionToScaledSpace","position","transformPositionFromScaledSpace","getSurfaceNormalIntersectionWithZAxis","buffer","EPSILON15","abs","WGS84"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\geospatial\\src\\ellipsoid\\ellipsoid.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, Matrix4, assert, equals, _MathUtils, NumericArray, vec3} from '@math.gl/core';\n\nimport {WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z} from '../constants';\nimport {fromCartographicToRadians, toCartographicFromRadians} from '../type-utils';\n\nimport type {AxisDirection} from './helpers/ellipsoid-transform';\nimport {localFrameToFixedFrame} from './helpers/ellipsoid-transform';\nimport {scaleToGeodeticSurface} from './helpers/scale-to-geodetic-surface';\n\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\nconst scratchK = new Vector3();\nconst scratchPosition = new Vector3();\nconst scratchHeight = new Vector3();\nconst scratchCartesian = new Vector3();\n\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * `(x / a)^2 + (y / b)^2 + (z / c)^2 = 1`.  Primarily used\n * to represent the shape of planetary bodies.\n */\nexport class Ellipsoid {\n  /** An Ellipsoid instance initialized to the WGS84 standard. */\n  static readonly WGS84: Ellipsoid = new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z);\n\n  readonly radii: Vector3;\n  readonly radiiSquared: Vector3;\n  readonly radiiToTheFourth: Vector3;\n  readonly oneOverRadii: Vector3;\n  readonly oneOverRadiiSquared: Vector3;\n  readonly minimumRadius: number;\n  readonly maximumRadius: number;\n  readonly centerToleranceSquared: number = _MathUtils.EPSILON1;\n  readonly squaredXOverSquaredZ: number;\n\n  /** Creates an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions. */\n  constructor(x: number, y: number, z: number);\n  constructor();\n\n  constructor(x = 0.0, y = 0.0, z = 0.0) {\n    assert(x >= 0.0);\n    assert(y >= 0.0);\n    assert(z >= 0.0);\n\n    this.radii = new Vector3(x, y, z);\n\n    this.radiiSquared = new Vector3(x * x, y * y, z * z);\n\n    this.radiiToTheFourth = new Vector3(x * x * x * x, y * y * y * y, z * z * z * z);\n\n    this.oneOverRadii = new Vector3(\n      x === 0.0 ? 0.0 : 1.0 / x,\n      y === 0.0 ? 0.0 : 1.0 / y,\n      z === 0.0 ? 0.0 : 1.0 / z\n    );\n\n    this.oneOverRadiiSquared = new Vector3(\n      x === 0.0 ? 0.0 : 1.0 / (x * x),\n      y === 0.0 ? 0.0 : 1.0 / (y * y),\n      z === 0.0 ? 0.0 : 1.0 / (z * z)\n    );\n\n    this.minimumRadius = Math.min(x, y, z);\n\n    this.maximumRadius = Math.max(x, y, z);\n\n    if (this.radiiSquared.z !== 0) {\n      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;\n    }\n\n    Object.freeze(this);\n  }\n\n  /** Compares this Ellipsoid against the provided Ellipsoid componentwise */\n  equals(right: Ellipsoid): boolean {\n    return this === right || Boolean(right && this.radii.equals(right.radii));\n  }\n\n  /** Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'. */\n  toString(): string {\n    return this.radii.toString();\n  }\n\n  /** Converts the provided cartographic to Cartesian representation. */\n  cartographicToCartesian(cartographic: number[], result: Vector3): Vector3;\n  cartographicToCartesian(cartographic: number[], result?: number[]): number[];\n\n  cartographicToCartesian(cartographic: Readonly<NumericArray>, result = [0, 0, 0]) {\n    const normal = scratchNormal;\n    const k = scratchK;\n\n    const [, , height] = cartographic;\n    this.geodeticSurfaceNormalCartographic(cartographic, normal);\n    k.copy(this.radiiSquared).scale(normal);\n\n    const gamma = Math.sqrt(normal.dot(k));\n    k.scale(1 / gamma);\n\n    normal.scale(height);\n\n    k.add(normal);\n\n    return k.to(result);\n  }\n\n  /** Converts the provided cartesian to cartographic (lng/lat/z) representation.\n   * The cartesian is undefined at the center of the ellipsoid. */\n  cartesianToCartographic(cartesian: Readonly<NumericArray>, result: Vector3): Vector3;\n  cartesianToCartographic(cartesian: Readonly<NumericArray>, result?: number[]): number[];\n\n  cartesianToCartographic(cartesian: Readonly<NumericArray>, result = [0, 0, 0]) {\n    scratchCartesian.from(cartesian);\n    const point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition);\n\n    if (!point) {\n      return undefined;\n    }\n\n    const normal = this.geodeticSurfaceNormal(point, scratchNormal);\n\n    const h = scratchHeight;\n    h.copy(scratchCartesian).subtract(point);\n\n    const longitude = Math.atan2(normal.y, normal.x);\n    const latitude = Math.asin(normal.z);\n    const height = Math.sign(vec3.dot(h, scratchCartesian)) * vec3.length(h);\n\n    return toCartographicFromRadians([longitude, latitude, height], result);\n  }\n\n  /** Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes\n   * centered at the provided origin to the provided ellipsoid's fixed reference frame. */\n  eastNorthUpToFixedFrame(origin: Readonly<NumericArray>, result?: Matrix4): Matrix4;\n  eastNorthUpToFixedFrame(origin: Readonly<NumericArray>, result: number[]): number[];\n\n  eastNorthUpToFixedFrame(origin: Readonly<NumericArray>, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, 'east', 'north', 'up', origin, result);\n  }\n\n  /** Computes a 4x4 transformation matrix from a reference frame centered at\n   * the provided origin to the ellipsoid's fixed reference frame.\n   */\n  localFrameToFixedFrame(\n    firstAxis: AxisDirection,\n    secondAxis: AxisDirection,\n    thirdAxis: AxisDirection,\n    origin: Readonly<NumericArray>,\n    result?: Matrix4\n  ): Matrix4;\n  localFrameToFixedFrame<Matrix4T>(\n    firstAxis: AxisDirection,\n    secondAxis: AxisDirection,\n    thirdAxis: AxisDirection,\n    origin: Readonly<NumericArray>,\n    result: number[]\n  ): number[];\n\n  // Computes a 4x4 transformation matrix from a reference frame centered at\n  // the provided origin to the ellipsoid's fixed reference frame.\n  localFrameToFixedFrame(\n    firstAxis: AxisDirection,\n    secondAxis: AxisDirection,\n    thirdAxis: AxisDirection,\n    origin: Readonly<NumericArray>,\n    result = new Matrix4()\n  ) {\n    return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);\n  }\n\n  /** Computes the unit vector directed from the center of this ellipsoid toward\n   * the provided Cartesian position. */\n  geocentricSurfaceNormal(cartesian: number[], result?: number[]): number[];\n  geocentricSurfaceNormal<NumArray>(cartesian: number[], result: NumArray): NumArray;\n  geocentricSurfaceNormal(cartesian: Readonly<NumericArray>, result = [0, 0, 0]) {\n    return scratchVector.from(cartesian).normalize().to(result);\n  }\n\n  /** Computes the normal of the plane tangent to the surface of the ellipsoid at provided position. */\n  geodeticSurfaceNormalCartographic<NumArray>(\n    cartographic: Readonly<NumericArray>,\n    result: NumArray\n  ): NumArray;\n  geodeticSurfaceNormalCartographic(cartographic: number[]): number[];\n  geodeticSurfaceNormalCartographic(cartographic: Readonly<NumericArray>, result = [0, 0, 0]) {\n    const cartographicVectorRadians = fromCartographicToRadians(cartographic);\n\n    const longitude = cartographicVectorRadians[0];\n    const latitude = cartographicVectorRadians[1];\n\n    const cosLatitude = Math.cos(latitude);\n\n    scratchVector\n      .set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude))\n      .normalize();\n\n    return scratchVector.to(result);\n  }\n\n  /** Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position. */\n  geodeticSurfaceNormal<NumArrayT>(cartesian: number[], result: NumArrayT): NumArrayT;\n  geodeticSurfaceNormal(cartesian: number[]): number[];\n  geodeticSurfaceNormal(cartesian: Readonly<NumericArray>, result = [0, 0, 0]) {\n    return scratchVector.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);\n  }\n\n  /** Scales the provided Cartesian position along the geodetic surface normal\n   * so that it is on the surface of this ellipsoid.  If the position is\n   * at the center of the ellipsoid, this function returns undefined. */\n  scaleToGeodeticSurface(cartesian: number[], result?: number[]): number[] {\n    return scaleToGeodeticSurface(cartesian, this, result);\n  }\n\n  /** Scales the provided Cartesian position along the geocentric surface normal\n   * so that it is on the surface of this ellipsoid. */\n  scaleToGeocentricSurface(cartesian: number[], result: number[] = [0, 0, 0]): number[] {\n    scratchPosition.from(cartesian);\n\n    const positionX = scratchPosition.x;\n    const positionY = scratchPosition.y;\n    const positionZ = scratchPosition.z;\n    const oneOverRadiiSquared = this.oneOverRadiiSquared;\n\n    const beta =\n      1.0 /\n      Math.sqrt(\n        positionX * positionX * oneOverRadiiSquared.x +\n          positionY * positionY * oneOverRadiiSquared.y +\n          positionZ * positionZ * oneOverRadiiSquared.z\n      );\n\n    return scratchPosition.multiplyScalar(beta).to(result);\n  }\n\n  /** Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n   * its components by the result of `Ellipsoid#oneOverRadii` */\n  transformPositionToScaledSpace(position: number[], result: number[] = [0, 0, 0]): number[] {\n    return scratchPosition.from(position).scale(this.oneOverRadii).to(result);\n  }\n\n  /** Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n   * its components by the result of `Ellipsoid#radii`. */\n  transformPositionFromScaledSpace(position: number[], result: number[] = [0, 0, 0]): number[] {\n    return scratchPosition.from(position).scale(this.radii).to(result);\n  }\n\n  /** Computes a point which is the intersection of the surface normal with the z-axis. */\n  getSurfaceNormalIntersectionWithZAxis(\n    position: number[],\n    buffer: number = 0,\n    result: number[] = [0, 0, 0]\n  ): number[] {\n    // Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\n    assert(equals(this.radii.x, this.radii.y, _MathUtils.EPSILON15));\n    assert(this.radii.z > 0);\n\n    scratchPosition.from(position);\n    const z = scratchPosition.z * (1 - this.squaredXOverSquaredZ);\n\n    if (Math.abs(z) >= this.radii.z - buffer) {\n      return undefined;\n    }\n\n    return scratchPosition.set(0.0, 0.0, z).to(result);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}