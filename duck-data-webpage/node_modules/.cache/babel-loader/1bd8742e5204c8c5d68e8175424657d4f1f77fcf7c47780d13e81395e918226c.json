{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { initializeShaderModules } from \"./shader-module.js\";\n/**\n * Takes a list of shader module names and returns a new list of\n * shader module names that includes all dependencies, sorted so\n * that modules that are dependencies of other modules come first.\n *\n * If the shader glsl code from the returned modules is concatenated\n * in the reverse order, it is guaranteed that all functions be resolved and\n * that all function and variable definitions come before use.\n *\n * @param modules - Array of modules (inline modules or module names)\n * @return - Array of modules\n */\nexport function getShaderModuleDependencies(modules) {\n  initializeShaderModules(modules);\n  const moduleMap = {};\n  const moduleDepth = {};\n  getDependencyGraph({\n    modules,\n    level: 0,\n    moduleMap,\n    moduleDepth\n  });\n  // Return a reverse sort so that dependencies come before the modules that use them\n  const dependencies = Object.keys(moduleDepth).sort((a, b) => moduleDepth[b] - moduleDepth[a]).map(name => moduleMap[name]);\n  initializeShaderModules(dependencies);\n  return dependencies;\n}\n/**\n * Recursively checks module dependencies to calculate dependency level of each module.\n *\n * @param options.modules - Array of modules\n * @param options.level - Current level\n * @param options.moduleMap -\n * @param options.moduleDepth - Current level\n * @return - Map of module name to its level\n */\n// Adds another level of dependencies to the result map\nexport function getDependencyGraph(options) {\n  const {\n    modules,\n    level,\n    moduleMap,\n    moduleDepth\n  } = options;\n  if (level >= 5) {\n    throw new Error('Possible loop in shader dependency graph');\n  }\n  // Update level on all current modules\n  for (const module of modules) {\n    moduleMap[module.name] = module;\n    if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {\n      moduleDepth[module.name] = level;\n    }\n  }\n  // Recurse\n  for (const module of modules) {\n    if (module.dependencies) {\n      getDependencyGraph({\n        modules: module.dependencies,\n        level: level + 1,\n        moduleMap,\n        moduleDepth\n      });\n    }\n  }\n}\n/**\n * Takes a list of shader module names and returns a new list of\n * shader module names that includes all dependencies, sorted so\n * that modules that are dependencies of other modules come first.\n *\n * If the shader glsl code from the returned modules is concatenated\n * in the reverse order, it is guaranteed that all functions be resolved and\n * that all function and variable definitions come before use.\n *\n * @param modules - Array of modules (inline modules or module names)\n * @return - Array of modules\n */\nexport function getShaderDependencies(modules) {\n  initializeShaderModules(modules);\n  const moduleMap = {};\n  const moduleDepth = {};\n  getDependencyGraph({\n    modules,\n    level: 0,\n    moduleMap,\n    moduleDepth\n  });\n  // Return a reverse sort so that dependencies come before the modules that use them\n  modules = Object.keys(moduleDepth).sort((a, b) => moduleDepth[b] - moduleDepth[a]).map(name => moduleMap[name]);\n  initializeShaderModules(modules);\n  return modules;\n}\n// DEPRECATED\n/**\n * Instantiate shader modules and resolve any dependencies\n * @deprecated Use getShaderDpendencies\n */\nexport function resolveModules(modules) {\n  return getShaderDependencies(modules);\n}","map":{"version":3,"names":["initializeShaderModules","getShaderModuleDependencies","modules","moduleMap","moduleDepth","getDependencyGraph","level","dependencies","Object","keys","sort","a","b","map","name","options","Error","module","undefined","getShaderDependencies","resolveModules"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\shadertools\\src\\lib\\shader-module\\shader-module-dependencies.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderModule, initializeShaderModules} from './shader-module';\n\n// import type {ShaderModule} from '../shader-module/shader-module';\n\ntype AbstractModule = {\n  name: string;\n  dependencies?: AbstractModule[];\n};\n\n/**\n * Takes a list of shader module names and returns a new list of\n * shader module names that includes all dependencies, sorted so\n * that modules that are dependencies of other modules come first.\n *\n * If the shader glsl code from the returned modules is concatenated\n * in the reverse order, it is guaranteed that all functions be resolved and\n * that all function and variable definitions come before use.\n *\n * @param modules - Array of modules (inline modules or module names)\n * @return - Array of modules\n */\nexport function getShaderModuleDependencies<T extends AbstractModule>(modules: T[]): T[] {\n  initializeShaderModules(modules);\n  const moduleMap: Record<string, T> = {};\n  const moduleDepth: Record<string, number> = {};\n  getDependencyGraph({modules, level: 0, moduleMap, moduleDepth});\n\n  // Return a reverse sort so that dependencies come before the modules that use them\n  const dependencies = Object.keys(moduleDepth)\n    .sort((a, b) => moduleDepth[b] - moduleDepth[a])\n    .map(name => moduleMap[name]);\n  initializeShaderModules(dependencies);\n  return dependencies;\n}\n\n/**\n * Recursively checks module dependencies to calculate dependency level of each module.\n *\n * @param options.modules - Array of modules\n * @param options.level - Current level\n * @param options.moduleMap -\n * @param options.moduleDepth - Current level\n * @return - Map of module name to its level\n */\n// Adds another level of dependencies to the result map\nexport function getDependencyGraph<T extends AbstractModule>(options: {\n  modules: T[];\n  level: number;\n  moduleMap: Record<string, T>;\n  moduleDepth: Record<string, number>;\n}) {\n  const {modules, level, moduleMap, moduleDepth} = options;\n  if (level >= 5) {\n    throw new Error('Possible loop in shader dependency graph');\n  }\n\n  // Update level on all current modules\n  for (const module of modules) {\n    moduleMap[module.name] = module;\n    if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {\n      moduleDepth[module.name] = level;\n    }\n  }\n\n  // Recurse\n  for (const module of modules) {\n    if (module.dependencies) {\n      getDependencyGraph({modules: module.dependencies, level: level + 1, moduleMap, moduleDepth});\n    }\n  }\n}\n\n/**\n * Takes a list of shader module names and returns a new list of\n * shader module names that includes all dependencies, sorted so\n * that modules that are dependencies of other modules come first.\n *\n * If the shader glsl code from the returned modules is concatenated\n * in the reverse order, it is guaranteed that all functions be resolved and\n * that all function and variable definitions come before use.\n *\n * @param modules - Array of modules (inline modules or module names)\n * @return - Array of modules\n */\nexport function getShaderDependencies(modules: ShaderModule[]): ShaderModule[] {\n  initializeShaderModules(modules);\n  const moduleMap: Record<string, ShaderModule> = {};\n  const moduleDepth: Record<string, number> = {};\n  getDependencyGraph({modules, level: 0, moduleMap, moduleDepth});\n\n  // Return a reverse sort so that dependencies come before the modules that use them\n  modules = Object.keys(moduleDepth)\n    .sort((a, b) => moduleDepth[b] - moduleDepth[a])\n    .map(name => moduleMap[name]);\n  initializeShaderModules(modules);\n  return modules;\n}\n\n// DEPRECATED\n\n/**\n * Instantiate shader modules and resolve any dependencies\n * @deprecated Use getShaderDpendencies\n */\nexport function resolveModules(modules: ShaderModule[]): ShaderModule[] {\n  return getShaderDependencies(modules);\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA,SAAsBA,uBAAuB,QAAC;AAS9C;;;;;;;;;;;;AAYA,OAAM,SAAUC,2BAA2BA,CAA2BC,OAAY;EAChFF,uBAAuB,CAACE,OAAO,CAAC;EAChC,MAAMC,SAAS,GAAsB,EAAE;EACvC,MAAMC,WAAW,GAA2B,EAAE;EAC9CC,kBAAkB,CAAC;IAACH,OAAO;IAAEI,KAAK,EAAE,CAAC;IAAEH,SAAS;IAAEC;EAAW,CAAC,CAAC;EAE/D;EACA,MAAMG,YAAY,GAAGC,MAAM,CAACC,IAAI,CAACL,WAAW,CAAC,CAC1CM,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKR,WAAW,CAACQ,CAAC,CAAC,GAAGR,WAAW,CAACO,CAAC,CAAC,CAAC,CAC/CE,GAAG,CAACC,IAAI,IAAIX,SAAS,CAACW,IAAI,CAAC,CAAC;EAC/Bd,uBAAuB,CAACO,YAAY,CAAC;EACrC,OAAOA,YAAY;AACrB;AAEA;;;;;;;;;AASA;AACA,OAAM,SAAUF,kBAAkBA,CAA2BU,OAK5D;EACC,MAAM;IAACb,OAAO;IAAEI,KAAK;IAAEH,SAAS;IAAEC;EAAW,CAAC,GAAGW,OAAO;EACxD,IAAIT,KAAK,IAAI,CAAC,EAAE;IACd,MAAM,IAAIU,KAAK,CAAC,0CAA0C,CAAC;EAC7D;EAEA;EACA,KAAK,MAAMC,MAAM,IAAIf,OAAO,EAAE;IAC5BC,SAAS,CAACc,MAAM,CAACH,IAAI,CAAC,GAAGG,MAAM;IAC/B,IAAIb,WAAW,CAACa,MAAM,CAACH,IAAI,CAAC,KAAKI,SAAS,IAAId,WAAW,CAACa,MAAM,CAACH,IAAI,CAAC,GAAGR,KAAK,EAAE;MAC9EF,WAAW,CAACa,MAAM,CAACH,IAAI,CAAC,GAAGR,KAAK;IAClC;EACF;EAEA;EACA,KAAK,MAAMW,MAAM,IAAIf,OAAO,EAAE;IAC5B,IAAIe,MAAM,CAACV,YAAY,EAAE;MACvBF,kBAAkB,CAAC;QAACH,OAAO,EAAEe,MAAM,CAACV,YAAY;QAAED,KAAK,EAAEA,KAAK,GAAG,CAAC;QAAEH,SAAS;QAAEC;MAAW,CAAC,CAAC;IAC9F;EACF;AACF;AAEA;;;;;;;;;;;;AAYA,OAAM,SAAUe,qBAAqBA,CAACjB,OAAuB;EAC3DF,uBAAuB,CAACE,OAAO,CAAC;EAChC,MAAMC,SAAS,GAAiC,EAAE;EAClD,MAAMC,WAAW,GAA2B,EAAE;EAC9CC,kBAAkB,CAAC;IAACH,OAAO;IAAEI,KAAK,EAAE,CAAC;IAAEH,SAAS;IAAEC;EAAW,CAAC,CAAC;EAE/D;EACAF,OAAO,GAAGM,MAAM,CAACC,IAAI,CAACL,WAAW,CAAC,CAC/BM,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKR,WAAW,CAACQ,CAAC,CAAC,GAAGR,WAAW,CAACO,CAAC,CAAC,CAAC,CAC/CE,GAAG,CAACC,IAAI,IAAIX,SAAS,CAACW,IAAI,CAAC,CAAC;EAC/Bd,uBAAuB,CAACE,OAAO,CAAC;EAChC,OAAOA,OAAO;AAChB;AAEA;AAEA;;;;AAIA,OAAM,SAAUkB,cAAcA,CAAClB,OAAuB;EACpD,OAAOiB,qBAAqB,CAACjB,OAAO,CAAC;AACvC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}