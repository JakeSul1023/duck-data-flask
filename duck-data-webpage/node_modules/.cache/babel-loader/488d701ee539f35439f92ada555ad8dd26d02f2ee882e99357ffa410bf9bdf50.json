{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport LayersPass from \"./layers-pass.js\";\nimport log from \"../utils/log.js\";\nconst PICKING_BLENDING = {\n  blendColorOperation: 'add',\n  blendColorSrcFactor: 'one',\n  blendColorDstFactor: 'zero',\n  blendAlphaOperation: 'add',\n  blendAlphaSrcFactor: 'constant-alpha',\n  blendAlphaDstFactor: 'zero'\n};\nexport default class PickLayersPass extends LayersPass {\n  constructor() {\n    super(...arguments);\n    this._colorEncoderState = null;\n  }\n  render(props) {\n    if ('pickingFBO' in props) {\n      // When drawing into an off-screen buffer, use the alpha channel to encode layer index\n      return this._drawPickingBuffer(props);\n    }\n    // When drawing to screen (debug mode), do not use the alpha channel so that result is always visible\n    return super.render(props);\n  }\n  // Private\n  // Draws list of layers and viewports into the picking buffer\n  // Note: does not sample the buffer, that has to be done by the caller\n  _drawPickingBuffer({\n    layers,\n    layerFilter,\n    views,\n    viewports,\n    onViewportActive,\n    pickingFBO,\n    deviceRect: {\n      x,\n      y,\n      width,\n      height\n    },\n    cullRect,\n    effects,\n    pass = 'picking',\n    pickZ,\n    shaderModuleProps\n  }) {\n    this.pickZ = pickZ;\n    const colorEncoderState = this._resetColorEncoder(pickZ);\n    const scissorRect = [x, y, width, height];\n    // Make sure we clear scissor test and fbo bindings in case of exceptions\n    // We are only interested in one pixel, no need to render anything else\n    // Note that the callback here is called synchronously.\n    // Set blend mode for picking\n    // always overwrite existing pixel with [r,g,b,layerIndex]\n    const renderStatus = super.render({\n      target: pickingFBO,\n      layers,\n      layerFilter,\n      views,\n      viewports,\n      onViewportActive,\n      cullRect,\n      effects: effects?.filter(e => e.useInPicking),\n      pass,\n      isPicking: true,\n      shaderModuleProps,\n      clearColor: [0, 0, 0, 0],\n      colorMask: 0xf,\n      scissorRect\n    });\n    // Clear the temp field\n    this._colorEncoderState = null;\n    const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);\n    return {\n      decodePickingColor,\n      stats: renderStatus\n    };\n  }\n  shouldDrawLayer(layer) {\n    const {\n      pickable,\n      operation\n    } = layer.props;\n    return pickable && operation.includes('draw') || operation.includes('terrain') || operation.includes('mask');\n  }\n  getShaderModuleProps(layer, effects, otherShaderModuleProps) {\n    return {\n      picking: {\n        isActive: 1,\n        isAttribute: this.pickZ\n      },\n      lighting: {\n        enabled: false\n      }\n    };\n  }\n  getLayerParameters(layer, layerIndex, viewport) {\n    // TODO use Parameters type\n    const pickParameters = {\n      ...layer.props.parameters\n    };\n    const {\n      pickable,\n      operation\n    } = layer.props;\n    if (!this._colorEncoderState || operation.includes('terrain')) {\n      pickParameters.blend = false;\n    } else if (pickable && operation.includes('draw')) {\n      Object.assign(pickParameters, PICKING_BLENDING);\n      pickParameters.blend = true;\n      // TODO: blendColor no longer part of luma.gl API\n      pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);\n    }\n    return pickParameters;\n  }\n  _resetColorEncoder(pickZ) {\n    // Track encoded layer indices\n    this._colorEncoderState = pickZ ? null : {\n      byLayer: new Map(),\n      byAlpha: []\n    };\n    // Temporarily store it on the instance so that it can be accessed by this.getLayerParameters\n    return this._colorEncoderState;\n  }\n}\n// Assign an unique alpha value for each pickable layer and track the encoding in the cache object\n// Returns normalized blend color\nfunction encodeColor(encoded, layer, viewport) {\n  const {\n    byLayer,\n    byAlpha\n  } = encoded;\n  let a;\n  // Encode layerIndex in the alpha channel\n  // TODO - combine small layers to better utilize the picking color space\n  let entry = byLayer.get(layer);\n  if (entry) {\n    entry.viewports.push(viewport);\n    a = entry.a;\n  } else {\n    a = byLayer.size + 1;\n    if (a <= 255) {\n      entry = {\n        a,\n        layer,\n        viewports: [viewport]\n      };\n      byLayer.set(layer, entry);\n      byAlpha[a] = entry;\n    } else {\n      log.warn('Too many pickable layers, only picking the first 255')();\n      a = 0;\n    }\n  }\n  return [0, 0, 0, a / 255];\n}\n// Given a picked color, retrieve the corresponding layer and viewports from cache\nfunction decodeColor(encoded, pickedColor) {\n  const entry = encoded.byAlpha[pickedColor[3]];\n  return entry && {\n    pickedLayer: entry.layer,\n    pickedViewports: entry.viewports,\n    pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)\n  };\n}","map":{"version":3,"names":["LayersPass","log","PICKING_BLENDING","blendColorOperation","blendColorSrcFactor","blendColorDstFactor","blendAlphaOperation","blendAlphaSrcFactor","blendAlphaDstFactor","PickLayersPass","constructor","_colorEncoderState","render","props","_drawPickingBuffer","layers","layerFilter","views","viewports","onViewportActive","pickingFBO","deviceRect","x","y","width","height","cullRect","effects","pass","pickZ","shaderModuleProps","colorEncoderState","_resetColorEncoder","scissorRect","renderStatus","target","filter","e","useInPicking","isPicking","clearColor","colorMask","decodePickingColor","decodeColor","bind","stats","shouldDrawLayer","layer","pickable","operation","includes","getShaderModuleProps","otherShaderModuleProps","picking","isActive","isAttribute","lighting","enabled","getLayerParameters","layerIndex","viewport","pickParameters","parameters","blend","Object","assign","blendColor","encodeColor","byLayer","Map","byAlpha","encoded","a","entry","get","push","size","set","warn","pickedColor","pickedLayer","pickedViewports","pickedObjectIndex"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\passes\\pick-layers-pass.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport LayersPass, {LayersPassRenderOptions, RenderStats, Rect} from './layers-pass';\nimport type {Framebuffer, Parameters, RenderPipelineParameters} from '@luma.gl/core';\nimport log from '../utils/log';\n\nimport type {Effect} from '../lib/effect';\nimport type Viewport from '../viewports/viewport';\nimport type Layer from '../lib/layer';\n\nconst PICKING_BLENDING: RenderPipelineParameters = {\n  blendColorOperation: 'add',\n  blendColorSrcFactor: 'one',\n  blendColorDstFactor: 'zero',\n  blendAlphaOperation: 'add',\n  blendAlphaSrcFactor: 'constant-alpha',\n  blendAlphaDstFactor: 'zero'\n};\n\ntype PickLayersPassRenderOptions = LayersPassRenderOptions & {\n  pickingFBO: Framebuffer;\n  deviceRect: Rect;\n  pickZ: boolean;\n};\n\ntype EncodedPickingColors = {\n  a: number;\n  layer: Layer;\n  viewports: Viewport[];\n};\n\nexport type PickingColorDecoder = (pickedColor: number[] | Uint8Array) =>\n  | {\n      pickedLayer: Layer;\n      pickedViewports: Viewport[];\n      pickedObjectIndex: number;\n    }\n  | undefined;\n\nexport default class PickLayersPass extends LayersPass {\n  private pickZ?: boolean;\n  private _colorEncoderState: {\n    byLayer: Map<Layer, EncodedPickingColors>;\n    byAlpha: EncodedPickingColors[];\n  } | null = null;\n\n  render(props: LayersPassRenderOptions | PickLayersPassRenderOptions) {\n    if ('pickingFBO' in props) {\n      // When drawing into an off-screen buffer, use the alpha channel to encode layer index\n      return this._drawPickingBuffer(props);\n    }\n    // When drawing to screen (debug mode), do not use the alpha channel so that result is always visible\n    return super.render(props);\n  }\n\n  // Private\n  // Draws list of layers and viewports into the picking buffer\n  // Note: does not sample the buffer, that has to be done by the caller\n  _drawPickingBuffer({\n    layers,\n    layerFilter,\n    views,\n    viewports,\n    onViewportActive,\n    pickingFBO,\n    deviceRect: {x, y, width, height},\n    cullRect,\n    effects,\n    pass = 'picking',\n    pickZ,\n    shaderModuleProps\n  }: PickLayersPassRenderOptions): {\n    decodePickingColor: PickingColorDecoder | null;\n    stats: RenderStats;\n  } {\n    this.pickZ = pickZ;\n    const colorEncoderState = this._resetColorEncoder(pickZ);\n    const scissorRect = [x, y, width, height];\n\n    // Make sure we clear scissor test and fbo bindings in case of exceptions\n    // We are only interested in one pixel, no need to render anything else\n    // Note that the callback here is called synchronously.\n    // Set blend mode for picking\n    // always overwrite existing pixel with [r,g,b,layerIndex]\n    const renderStatus = super.render({\n      target: pickingFBO,\n      layers,\n      layerFilter,\n      views,\n      viewports,\n      onViewportActive,\n      cullRect,\n      effects: effects?.filter(e => e.useInPicking),\n      pass,\n      isPicking: true,\n      shaderModuleProps,\n      clearColor: [0, 0, 0, 0],\n      colorMask: 0xf,\n      scissorRect\n    });\n\n    // Clear the temp field\n    this._colorEncoderState = null;\n    const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);\n    return {decodePickingColor, stats: renderStatus};\n  }\n\n  shouldDrawLayer(layer: Layer): boolean {\n    const {pickable, operation} = layer.props;\n    return (\n      (pickable && operation.includes('draw')) ||\n      operation.includes('terrain') ||\n      operation.includes('mask')\n    );\n  }\n\n  protected getShaderModuleProps(\n    layer: Layer,\n    effects: Effect[] | undefined,\n    otherShaderModuleProps: Record<string, any>\n  ): any {\n    return {\n      picking: {\n        isActive: 1,\n        isAttribute: this.pickZ\n      },\n      lighting: {enabled: false}\n    };\n  }\n\n  protected getLayerParameters(layer: Layer, layerIndex: number, viewport: Viewport): Parameters {\n    // TODO use Parameters type\n    const pickParameters: any = {\n      ...layer.props.parameters\n    };\n    const {pickable, operation} = layer.props;\n\n    if (!this._colorEncoderState || operation.includes('terrain')) {\n      pickParameters.blend = false;\n    } else if (pickable && operation.includes('draw')) {\n      Object.assign(pickParameters, PICKING_BLENDING);\n      pickParameters.blend = true;\n      // TODO: blendColor no longer part of luma.gl API\n      pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);\n    }\n\n    return pickParameters;\n  }\n\n  protected _resetColorEncoder(pickZ: boolean) {\n    // Track encoded layer indices\n    this._colorEncoderState = pickZ\n      ? null\n      : {\n          byLayer: new Map<Layer, EncodedPickingColors>(),\n          byAlpha: []\n        };\n    // Temporarily store it on the instance so that it can be accessed by this.getLayerParameters\n    return this._colorEncoderState;\n  }\n}\n\n// Assign an unique alpha value for each pickable layer and track the encoding in the cache object\n// Returns normalized blend color\nfunction encodeColor(\n  encoded: {\n    byLayer: Map<Layer, EncodedPickingColors>;\n    byAlpha: EncodedPickingColors[];\n  },\n  layer: Layer,\n  viewport: Viewport\n): number[] {\n  const {byLayer, byAlpha} = encoded;\n  let a;\n\n  // Encode layerIndex in the alpha channel\n  // TODO - combine small layers to better utilize the picking color space\n  let entry = byLayer.get(layer);\n  if (entry) {\n    entry.viewports.push(viewport);\n    a = entry.a;\n  } else {\n    a = byLayer.size + 1;\n    if (a <= 255) {\n      entry = {a, layer, viewports: [viewport]};\n      byLayer.set(layer, entry);\n      byAlpha[a] = entry;\n    } else {\n      log.warn('Too many pickable layers, only picking the first 255')();\n      a = 0;\n    }\n  }\n  return [0, 0, 0, a / 255];\n}\n\n// Given a picked color, retrieve the corresponding layer and viewports from cache\nfunction decodeColor(\n  encoded: {\n    byLayer: Map<Layer, EncodedPickingColors>;\n    byAlpha: EncodedPickingColors[];\n  },\n  pickedColor: number[] | Uint8Array\n):\n  | {\n      pickedLayer: Layer;\n      pickedViewports: Viewport[];\n      pickedObjectIndex: number;\n    }\n  | undefined {\n  const entry = encoded.byAlpha[pickedColor[3]];\n  return (\n    entry && {\n      pickedLayer: entry.layer,\n      pickedViewports: entry.viewports,\n      pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)\n    }\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}