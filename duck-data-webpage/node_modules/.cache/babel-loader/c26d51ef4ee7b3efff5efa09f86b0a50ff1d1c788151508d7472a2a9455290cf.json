{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport AsyncQueue from \"../async-queue/async-queue.js\";\nimport WorkerBody from \"../worker-farm/worker-body.js\";\n// import {validateWorkerVersion} from './validate-worker-version';\n/** Counter for jobs */\nlet requestId = 0;\nlet inputBatches;\nlet options;\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n */\nexport async function createWorker(process, processInBatches) {\n  if (!(await WorkerBody.inWorkerThread())) {\n    return;\n  }\n  const context = {\n    process: processOnMainThread\n  };\n  // eslint-disable-next-line complexity\n  WorkerBody.onmessage = async (type, payload) => {\n    try {\n      switch (type) {\n        case 'process':\n          if (!process) {\n            throw new Error('Worker does not support atomic processing');\n          }\n          const result = await process(payload.input, payload.options || {}, context);\n          WorkerBody.postMessage('done', {\n            result\n          });\n          break;\n        case 'process-in-batches':\n          if (!processInBatches) {\n            throw new Error('Worker does not support batched processing');\n          }\n          inputBatches = new AsyncQueue();\n          options = payload.options || {};\n          const resultIterator = processInBatches(inputBatches, options, context);\n          for await (const batch of resultIterator) {\n            WorkerBody.postMessage('output-batch', {\n              result: batch\n            });\n          }\n          WorkerBody.postMessage('done', {});\n          break;\n        case 'input-batch':\n          inputBatches.push(payload.input);\n          break;\n        case 'input-done':\n          inputBatches.close();\n          break;\n        default:\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : '';\n      WorkerBody.postMessage('error', {\n        error: message\n      });\n    }\n  };\n}\nfunction processOnMainThread(arrayBuffer, options = {}) {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n    /**\n     */\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n        default:\n        // ignore\n      }\n    };\n    WorkerBody.addEventListener(onMessage);\n    // Ask the main thread to decode data\n    const payload = {\n      id,\n      input: arrayBuffer,\n      options\n    };\n    WorkerBody.postMessage('process', payload);\n  });\n}","map":{"version":3,"names":["AsyncQueue","WorkerBody","requestId","inputBatches","options","createWorker","process","processInBatches","inWorkerThread","context","processOnMainThread","onmessage","type","payload","Error","result","input","postMessage","resultIterator","batch","push","close","error","message","arrayBuffer","Promise","resolve","reject","id","onMessage","removeEventListener","addEventListener"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/create-worker.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport AsyncQueue from \"../async-queue/async-queue.js\";\nimport WorkerBody from \"../worker-farm/worker-body.js\";\n// import {validateWorkerVersion} from './validate-worker-version';\n/** Counter for jobs */\nlet requestId = 0;\nlet inputBatches;\nlet options;\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n */\nexport async function createWorker(process, processInBatches) {\n    if (!(await WorkerBody.inWorkerThread())) {\n        return;\n    }\n    const context = {\n        process: processOnMainThread\n    };\n    // eslint-disable-next-line complexity\n    WorkerBody.onmessage = async (type, payload) => {\n        try {\n            switch (type) {\n                case 'process':\n                    if (!process) {\n                        throw new Error('Worker does not support atomic processing');\n                    }\n                    const result = await process(payload.input, payload.options || {}, context);\n                    WorkerBody.postMessage('done', { result });\n                    break;\n                case 'process-in-batches':\n                    if (!processInBatches) {\n                        throw new Error('Worker does not support batched processing');\n                    }\n                    inputBatches = new AsyncQueue();\n                    options = payload.options || {};\n                    const resultIterator = processInBatches(inputBatches, options, context);\n                    for await (const batch of resultIterator) {\n                        WorkerBody.postMessage('output-batch', { result: batch });\n                    }\n                    WorkerBody.postMessage('done', {});\n                    break;\n                case 'input-batch':\n                    inputBatches.push(payload.input);\n                    break;\n                case 'input-done':\n                    inputBatches.close();\n                    break;\n                default:\n            }\n        }\n        catch (error) {\n            const message = error instanceof Error ? error.message : '';\n            WorkerBody.postMessage('error', { error: message });\n        }\n    };\n}\nfunction processOnMainThread(arrayBuffer, options = {}) {\n    return new Promise((resolve, reject) => {\n        const id = requestId++;\n        /**\n         */\n        const onMessage = (type, payload) => {\n            if (payload.id !== id) {\n                // not ours\n                return;\n            }\n            switch (type) {\n                case 'done':\n                    WorkerBody.removeEventListener(onMessage);\n                    resolve(payload.result);\n                    break;\n                case 'error':\n                    WorkerBody.removeEventListener(onMessage);\n                    reject(payload.error);\n                    break;\n                default:\n                // ignore\n            }\n        };\n        WorkerBody.addEventListener(onMessage);\n        // Ask the main thread to decode data\n        const payload = { id, input: arrayBuffer, options };\n        WorkerBody.postMessage('process', payload);\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}