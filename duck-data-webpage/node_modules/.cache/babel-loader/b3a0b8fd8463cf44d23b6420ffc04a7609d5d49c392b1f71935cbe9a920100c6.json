{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { parseWithWorker, canParseWithWorker, mergeLoaderOptions } from '@loaders.gl/loader-utils';\nimport { assert, validateWorkerVersion } from '@loaders.gl/worker-utils';\nimport { isLoaderObject } from \"../loader-utils/normalize-loader.js\";\nimport { isResponse } from \"../../javascript-utils/is-type.js\";\nimport { normalizeOptions } from \"../loader-utils/option-utils.js\";\nimport { getArrayBufferOrStringFromData } from \"../loader-utils/get-data.js\";\nimport { getLoaderContext, getLoadersFromContext } from \"../loader-utils/loader-context.js\";\nimport { getResourceUrl } from \"../utils/resource-utils.js\";\nimport { selectLoader } from \"./select-loader.js\";\n/**\n * Parses `data` using a specified loader\n * @param data\n * @param loaders\n * @param options\n * @param context\n */\n// implementation signature\nexport async function parse(data, loaders, options, context) {\n  // Signature: parse(data, options, context | url)\n  // Uses registered loaders\n  if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined; // context not supported in short signature\n    options = loaders;\n    loaders = undefined;\n  }\n  data = await data; // Resolve any promise\n  options = options || {}; // Could be invalid...\n  // Extract a url for auto detection\n  const url = getResourceUrl(data);\n  // Chooses a loader (and normalizes it)\n  // Also use any loaders in the context, new loaders take priority\n  const typedLoaders = loaders;\n  const candidateLoaders = getLoadersFromContext(typedLoaders, context);\n  // todo hacky type cast\n  const loader = await selectLoader(data, candidateLoaders, options);\n  // Note: if no loader was found, if so just return null\n  if (!loader) {\n    return null;\n  }\n  // Normalize options\n  // @ts-expect-error\n  options = normalizeOptions(options, loader, candidateLoaders, url); // Could be invalid...\n  // Get a context (if already present, will be unchanged)\n  context = getLoaderContext(\n  // @ts-expect-error\n  {\n    url,\n    _parse: parse,\n    loaders: candidateLoaders\n  }, options, context || null);\n  return await parseWithLoader(loader, data, options, context);\n}\n// TODO: support progress and abort\n// TODO - should accept loader.parseAsyncIterator and concatenate.\nasync function parseWithLoader(loader, data, options, context) {\n  validateWorkerVersion(loader);\n  options = mergeLoaderOptions(loader.options, options);\n  if (isResponse(data)) {\n    // Serialize to support passing the response to web worker\n    const response = data;\n    const {\n      ok,\n      redirected,\n      status,\n      statusText,\n      type,\n      url\n    } = response;\n    const headers = Object.fromEntries(response.headers.entries());\n    // @ts-expect-error TODO - fix this\n    context.response = {\n      headers,\n      ok,\n      redirected,\n      status,\n      statusText,\n      type,\n      url\n    };\n  }\n  data = await getArrayBufferOrStringFromData(data, loader, options);\n  const loaderWithParser = loader;\n  // First check for synchronous text parser, wrap results in promises\n  if (loaderWithParser.parseTextSync && typeof data === 'string') {\n    return loaderWithParser.parseTextSync(data, options, context);\n  }\n  // If we have a workerUrl and the loader can parse the given options efficiently in a worker\n  if (canParseWithWorker(loader, options)) {\n    return await parseWithWorker(loader, data, options, context, parse);\n  }\n  // Check for asynchronous parser\n  if (loaderWithParser.parseText && typeof data === 'string') {\n    return await loaderWithParser.parseText(data, options, context);\n  }\n  if (loaderWithParser.parse) {\n    return await loaderWithParser.parse(data, options, context);\n  }\n  // This should not happen, all sync loaders should also offer `parse` function\n  assert(!loaderWithParser.parseSync);\n  // TBD - If asynchronous parser not available, return null\n  throw new Error(`${loader.id} loader - no parser found and worker is disabled`);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}