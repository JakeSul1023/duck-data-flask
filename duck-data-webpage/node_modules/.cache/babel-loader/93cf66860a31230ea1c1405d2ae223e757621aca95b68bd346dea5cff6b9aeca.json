{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getHexbinCentroidGLSL } from \"./hexbin.js\";\nexport default /* glsl */`\\\n#version 300 es\n#define SHADER_NAME hexagon-cell-layer-vertex-shader\nin vec3 positions;\nin vec3 normals;\nin vec2 instancePositions;\nin float instanceElevationValues;\nin float instanceColorValues;\nin vec3 instancePickingColors;\nuniform sampler2D colorRange;\nout vec4 vColor;\n${getHexbinCentroidGLSL}\nfloat interp(float value, vec2 domain, vec2 range) {\nfloat r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);\nreturn mix(range.x, range.y, r);\n}\nvec4 interp(float value, vec2 domain, sampler2D range) {\nfloat r = (value - domain.x) / (domain.y - domain.x);\nreturn texture(range, vec2(r, 0.5));\n}\nvoid main(void) {\ngeometry.pickingColor = instancePickingColors;\nif (isnan(instanceColorValues) ||\ninstanceColorValues < hexagon.colorDomain.z ||\ninstanceColorValues > hexagon.colorDomain.w ||\ninstanceElevationValues < hexagon.elevationDomain.z ||\ninstanceElevationValues > hexagon.elevationDomain.w\n) {\ngl_Position = vec4(0.);\nreturn;\n}\nvec2 commonPosition = hexbinCentroid(instancePositions, column.radius) + (hexagon.originCommon - project.commonOrigin.xy);\ncommonPosition += positions.xy * column.radius * column.coverage;\ngeometry.position = vec4(commonPosition, 0.0, 1.0);\ngeometry.normal = project_normal(normals);\nfloat elevation = 0.0;\nif (column.extruded) {\nelevation = interp(instanceElevationValues, hexagon.elevationDomain.xy, hexagon.elevationRange);\nelevation = project_size(elevation);\ngeometry.position.z = (positions.z + 1.0) / 2.0 * elevation;\n}\ngl_Position = project_common_position_to_clipspace(geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nvColor = interp(instanceColorValues, hexagon.colorDomain.xy, colorRange);\nvColor.a *= layer.opacity;\nif (column.extruded) {\nvColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\n}\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;","map":{"version":3,"names":["getHexbinCentroidGLSL"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\aggregation-layers\\src\\hexagon-layer\\hexagon-cell-layer-vertex.glsl.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {getHexbinCentroidGLSL} from './hexbin';\n\nexport default /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME hexagon-cell-layer-vertex-shader\n\nin vec3 positions;\nin vec3 normals;\n\nin vec2 instancePositions;\nin float instanceElevationValues;\nin float instanceColorValues;\nin vec3 instancePickingColors;\n\nuniform sampler2D colorRange;\n\n// Result\nout vec4 vColor;\n\n${getHexbinCentroidGLSL}\n\nfloat interp(float value, vec2 domain, vec2 range) {\n  float r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);\n  return mix(range.x, range.y, r);\n}\n\nvec4 interp(float value, vec2 domain, sampler2D range) {\n  float r = (value - domain.x) / (domain.y - domain.x);\n  return texture(range, vec2(r, 0.5));\n}\n\nvoid main(void) {\n  geometry.pickingColor = instancePickingColors;\n\n  if (isnan(instanceColorValues) ||\n    instanceColorValues < hexagon.colorDomain.z ||\n    instanceColorValues > hexagon.colorDomain.w ||\n    instanceElevationValues < hexagon.elevationDomain.z ||\n    instanceElevationValues > hexagon.elevationDomain.w\n  ) {\n    gl_Position = vec4(0.);\n    return;\n  }\n  \n  vec2 commonPosition = hexbinCentroid(instancePositions, column.radius) + (hexagon.originCommon - project.commonOrigin.xy);\n  commonPosition += positions.xy * column.radius * column.coverage;\n  geometry.position = vec4(commonPosition, 0.0, 1.0);\n  geometry.normal = project_normal(normals);\n\n  // calculate z, if 3d not enabled set to 0\n  float elevation = 0.0;\n  if (column.extruded) {\n    elevation = interp(instanceElevationValues, hexagon.elevationDomain.xy, hexagon.elevationRange);\n    elevation = project_size(elevation);\n    // cylindar gemoetry height are between -1.0 to 1.0, transform it to between 0, 1\n    geometry.position.z = (positions.z + 1.0) / 2.0 * elevation;\n  }\n\n  gl_Position = project_common_position_to_clipspace(geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vColor = interp(instanceColorValues, hexagon.colorDomain.xy, colorRange);\n  vColor.a *= layer.opacity;\n  if (column.extruded) {\n    vColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n"],"mappings":"AAAA;AACA;AACA;AAEA,SAAQA,qBAAqB,QAAC;AAE9B,eAAe,UAAW;;;;;;;;;;;EAiBxBA,qBAAqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiDtB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}