{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from \"../utils/log.js\";\nimport { decodeShaderAttributeType } from \"../gpu-type-utils/decode-attribute-type.js\";\nimport { decodeVertexFormat } from \"../gpu-type-utils/decode-vertex-format.js\";\n/**\n * Map from \"attribute names\" to \"resolved attribute infos\"\n * containing information about both buffer layouts and shader attribute declarations\n */\nexport function getAttributeInfosFromLayouts(shaderLayout, bufferLayout) {\n  const attributeInfos = {};\n  for (const attribute of shaderLayout.attributes) {\n    const attributeInfo = getAttributeInfoFromLayouts(shaderLayout, bufferLayout, attribute.name);\n    if (attributeInfo) {\n      attributeInfos[attribute.name] = attributeInfo;\n    }\n  }\n  return attributeInfos;\n}\n/**\n * Array indexed by \"location\" holding \"resolved attribute infos\"\n */\nexport function getAttributeInfosByLocation(shaderLayout, bufferLayout, maxVertexAttributes = 16) {\n  const attributeInfos = getAttributeInfosFromLayouts(shaderLayout, bufferLayout);\n  const locationInfos = new Array(maxVertexAttributes).fill(null);\n  for (const attributeInfo of Object.values(attributeInfos)) {\n    locationInfos[attributeInfo.location] = attributeInfo;\n  }\n  return locationInfos;\n}\n/**\n * Get the combined information from a shader layout and a buffer layout for a specific attribute\n */\nfunction getAttributeInfoFromLayouts(shaderLayout, bufferLayout, name) {\n  const shaderDeclaration = getAttributeFromShaderLayout(shaderLayout, name);\n  const bufferMapping = getAttributeFromBufferLayout(bufferLayout, name);\n  // TODO should no longer happen\n  if (!shaderDeclaration) {\n    //  || !bufferMapping\n    return null;\n  }\n  const attributeTypeInfo = decodeShaderAttributeType(shaderDeclaration.type);\n  const vertexFormat = bufferMapping?.vertexFormat || attributeTypeInfo.defaultVertexFormat;\n  const vertexFormatInfo = decodeVertexFormat(vertexFormat);\n  return {\n    attributeName: bufferMapping?.attributeName || shaderDeclaration.name,\n    bufferName: bufferMapping?.bufferName || shaderDeclaration.name,\n    location: shaderDeclaration.location,\n    shaderType: shaderDeclaration.type,\n    shaderDataType: attributeTypeInfo.dataType,\n    shaderComponents: attributeTypeInfo.components,\n    vertexFormat,\n    bufferDataType: vertexFormatInfo.type,\n    bufferComponents: vertexFormatInfo.components,\n    // normalized is a property of the buffer's vertex format\n    normalized: vertexFormatInfo.normalized,\n    // integer is a property of the shader declaration\n    integer: attributeTypeInfo.integer,\n    stepMode: bufferMapping?.stepMode || shaderDeclaration.stepMode || 'vertex',\n    byteOffset: bufferMapping?.byteOffset || 0,\n    byteStride: bufferMapping?.byteStride || 0\n  };\n}\nfunction getAttributeFromShaderLayout(shaderLayout, name) {\n  const attribute = shaderLayout.attributes.find(attr => attr.name === name);\n  if (!attribute) {\n    log.warn(`shader layout attribute \"${name}\" not present in shader`);\n  }\n  return attribute || null;\n}\nfunction getAttributeFromBufferLayout(bufferLayouts, name) {\n  // Check that bufferLayouts are valid (each either has format or attribute)\n  checkBufferLayouts(bufferLayouts);\n  let bufferLayoutInfo = getAttributeFromShortHand(bufferLayouts, name);\n  if (bufferLayoutInfo) {\n    return bufferLayoutInfo;\n  }\n  bufferLayoutInfo = getAttributeFromAttributesList(bufferLayouts, name);\n  if (bufferLayoutInfo) {\n    return bufferLayoutInfo;\n  }\n  // Didn't find...\n  log.warn(`layout for attribute \"${name}\" not present in buffer layout`);\n  return null;\n}\n/** Check that bufferLayouts are valid (each either has format or attribute) */\nfunction checkBufferLayouts(bufferLayouts) {\n  for (const bufferLayout of bufferLayouts) {\n    if (bufferLayout.attributes && bufferLayout.format || !bufferLayout.attributes && !bufferLayout.format) {\n      log.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);\n    }\n  }\n}\n/** Get attribute from format shorthand if specified */\nfunction getAttributeFromShortHand(bufferLayouts, name) {\n  for (const bufferLayout of bufferLayouts) {\n    if (bufferLayout.format && bufferLayout.name === name) {\n      return {\n        attributeName: bufferLayout.name,\n        bufferName: name,\n        stepMode: bufferLayout.stepMode,\n        vertexFormat: bufferLayout.format,\n        // If offset is needed, use `attributes` field.\n        byteOffset: 0,\n        byteStride: bufferLayout.byteStride || 0\n      };\n    }\n  }\n  return null;\n}\n/**\n * Search attribute mappings (e.g. interleaved attributes) for buffer mapping.\n * Not the name of the buffer might be the same as one of the interleaved attributes.\n */\nfunction getAttributeFromAttributesList(bufferLayouts, name) {\n  for (const bufferLayout of bufferLayouts) {\n    let byteStride = bufferLayout.byteStride;\n    // Calculate a default byte stride if not provided\n    if (typeof bufferLayout.byteStride !== 'number') {\n      for (const attributeMapping of bufferLayout.attributes || []) {\n        const info = decodeVertexFormat(attributeMapping.format);\n        // @ts-ignore\n        byteStride += info.byteLength;\n      }\n    }\n    const attributeMapping = bufferLayout.attributes?.find(mapping => mapping.attribute === name);\n    if (attributeMapping) {\n      return {\n        attributeName: attributeMapping.attribute,\n        bufferName: bufferLayout.name,\n        stepMode: bufferLayout.stepMode,\n        vertexFormat: attributeMapping.format,\n        byteOffset: attributeMapping.byteOffset,\n        // @ts-ignore\n        byteStride\n      };\n    }\n  }\n  return null;\n}","map":{"version":3,"names":["log","decodeShaderAttributeType","decodeVertexFormat","getAttributeInfosFromLayouts","shaderLayout","bufferLayout","attributeInfos","attribute","attributes","attributeInfo","getAttributeInfoFromLayouts","name","getAttributeInfosByLocation","maxVertexAttributes","locationInfos","Array","fill","Object","values","location","shaderDeclaration","getAttributeFromShaderLayout","bufferMapping","getAttributeFromBufferLayout","attributeTypeInfo","type","vertexFormat","defaultVertexFormat","vertexFormatInfo","attributeName","bufferName","shaderType","shaderDataType","dataType","shaderComponents","components","bufferDataType","bufferComponents","normalized","integer","stepMode","byteOffset","byteStride","find","attr","warn","bufferLayouts","checkBufferLayouts","bufferLayoutInfo","getAttributeFromShortHand","getAttributeFromAttributesList","format","attributeMapping","info","byteLength","mapping"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\core\\src\\adapter-utils\\get-attribute-from-layouts.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {log} from '../utils/log';\nimport type {ShaderLayout, AttributeDeclaration} from '../adapter/types/shader-layout';\nimport type {BufferLayout} from '../adapter/types/buffer-layout';\nimport type {ShaderDataType, ShaderAttributeType} from '../gpu-type-utils/shader-types';\nimport {decodeShaderAttributeType} from '../gpu-type-utils/decode-attribute-type';\nimport type {VertexFormat, VertexType} from '../gpu-type-utils/vertex-formats';\nimport {decodeVertexFormat} from '../gpu-type-utils/decode-vertex-format';\n\n/** Resolved info for a buffer / attribute combination to help backend configure it correctly */\nexport type AttributeInfo = {\n  /** Attribute name */\n  attributeName: string;\n  /** Location in shader */\n  location: number;\n  /** Type / precision used in shader (buffer values may be converted) */\n  shaderType: ShaderAttributeType;\n  /** Calculations are done in this type in the shader's attribute declaration */\n  shaderDataType: ShaderDataType;\n  /** Components refer to the number of components in the shader's attribute declaration */\n  shaderComponents: 1 | 2 | 3 | 4;\n  /** It is the shader attribute declaration that determines whether GPU will process as integer or float */\n  integer: boolean;\n\n  /** BufferName */\n  bufferName: string;\n  /** Format of buffer data */\n  vertexFormat: VertexFormat;\n  /** Memory data type refers to the data type in the buffer */\n  bufferDataType: VertexType;\n  /** Components refer to the number of components in the buffer's vertex format */\n  bufferComponents: 1 | 2 | 3 | 4;\n  /** Normalization is encoded in the buffer layout's vertex format... */\n  normalized: boolean;\n\n  /** If not specified, the step mode is inferred from the attribute name in the shader (contains string instance) */\n  stepMode: 'vertex' | 'instance';\n\n  /** The byteOffset is encoded in or calculated from the buffer layout */\n  byteOffset: number;\n  /** The byteStride is encoded in or calculated from the buffer layout */\n  byteStride: number;\n};\n\ntype BufferAttributeInfo = {\n  attributeName: string;\n  bufferName: string;\n  stepMode?: 'vertex' | 'instance';\n  vertexFormat: VertexFormat;\n  byteOffset: number;\n  byteStride: number;\n};\n\n/**\n * Map from \"attribute names\" to \"resolved attribute infos\"\n * containing information about both buffer layouts and shader attribute declarations\n */\nexport function getAttributeInfosFromLayouts(\n  shaderLayout: ShaderLayout,\n  bufferLayout: BufferLayout[]\n): Record<string, AttributeInfo> {\n  const attributeInfos: Record<string, AttributeInfo> = {};\n  for (const attribute of shaderLayout.attributes) {\n    const attributeInfo = getAttributeInfoFromLayouts(shaderLayout, bufferLayout, attribute.name);\n    if (attributeInfo) {\n      attributeInfos[attribute.name] = attributeInfo;\n    }\n  }\n  return attributeInfos;\n}\n\n/**\n * Array indexed by \"location\" holding \"resolved attribute infos\"\n */\nexport function getAttributeInfosByLocation(\n  shaderLayout: ShaderLayout,\n  bufferLayout: BufferLayout[],\n  maxVertexAttributes: number = 16\n): AttributeInfo[] {\n  const attributeInfos = getAttributeInfosFromLayouts(shaderLayout, bufferLayout);\n  const locationInfos: AttributeInfo[] = new Array(maxVertexAttributes).fill(null);\n  for (const attributeInfo of Object.values(attributeInfos)) {\n    locationInfos[attributeInfo.location] = attributeInfo;\n  }\n  return locationInfos;\n}\n\n/**\n * Get the combined information from a shader layout and a buffer layout for a specific attribute\n */\nfunction getAttributeInfoFromLayouts(\n  shaderLayout: ShaderLayout,\n  bufferLayout: BufferLayout[],\n  name: string\n): AttributeInfo | null {\n  const shaderDeclaration = getAttributeFromShaderLayout(shaderLayout, name);\n  const bufferMapping: BufferAttributeInfo | null = getAttributeFromBufferLayout(\n    bufferLayout,\n    name\n  );\n\n  // TODO should no longer happen\n  if (!shaderDeclaration) {\n    //  || !bufferMapping\n    return null;\n  }\n\n  const attributeTypeInfo = decodeShaderAttributeType(shaderDeclaration.type);\n  const vertexFormat = bufferMapping?.vertexFormat || attributeTypeInfo.defaultVertexFormat;\n  const vertexFormatInfo = decodeVertexFormat(vertexFormat);\n\n  return {\n    attributeName: bufferMapping?.attributeName || shaderDeclaration.name,\n    bufferName: bufferMapping?.bufferName || shaderDeclaration.name,\n    location: shaderDeclaration.location,\n    shaderType: shaderDeclaration.type,\n    shaderDataType: attributeTypeInfo.dataType,\n    shaderComponents: attributeTypeInfo.components,\n    vertexFormat,\n    bufferDataType: vertexFormatInfo.type,\n    bufferComponents: vertexFormatInfo.components,\n    // normalized is a property of the buffer's vertex format\n    normalized: vertexFormatInfo.normalized,\n    // integer is a property of the shader declaration\n    integer: attributeTypeInfo.integer,\n    stepMode: bufferMapping?.stepMode || shaderDeclaration.stepMode || 'vertex',\n    byteOffset: bufferMapping?.byteOffset || 0,\n    byteStride: bufferMapping?.byteStride || 0\n  };\n}\n\nfunction getAttributeFromShaderLayout(\n  shaderLayout: ShaderLayout,\n  name: string\n): AttributeDeclaration | null {\n  const attribute = shaderLayout.attributes.find(attr => attr.name === name);\n  if (!attribute) {\n    log.warn(`shader layout attribute \"${name}\" not present in shader`);\n  }\n  return attribute || null;\n}\n\nfunction getAttributeFromBufferLayout(\n  bufferLayouts: BufferLayout[],\n  name: string\n): BufferAttributeInfo | null {\n  // Check that bufferLayouts are valid (each either has format or attribute)\n  checkBufferLayouts(bufferLayouts);\n\n  let bufferLayoutInfo = getAttributeFromShortHand(bufferLayouts, name);\n  if (bufferLayoutInfo) {\n    return bufferLayoutInfo;\n  }\n\n  bufferLayoutInfo = getAttributeFromAttributesList(bufferLayouts, name);\n  if (bufferLayoutInfo) {\n    return bufferLayoutInfo;\n  }\n\n  // Didn't find...\n  log.warn(`layout for attribute \"${name}\" not present in buffer layout`);\n  return null;\n}\n\n/** Check that bufferLayouts are valid (each either has format or attribute) */\nfunction checkBufferLayouts(bufferLayouts: BufferLayout[]) {\n  for (const bufferLayout of bufferLayouts) {\n    if (\n      (bufferLayout.attributes && bufferLayout.format) ||\n      (!bufferLayout.attributes && !bufferLayout.format)\n    ) {\n      log.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);\n    }\n  }\n}\n\n/** Get attribute from format shorthand if specified */\nfunction getAttributeFromShortHand(\n  bufferLayouts: BufferLayout[],\n  name: string\n): BufferAttributeInfo | null {\n  for (const bufferLayout of bufferLayouts) {\n    if (bufferLayout.format && bufferLayout.name === name) {\n      return {\n        attributeName: bufferLayout.name,\n        bufferName: name,\n        stepMode: bufferLayout.stepMode,\n        vertexFormat: bufferLayout.format,\n        // If offset is needed, use `attributes` field.\n        byteOffset: 0,\n        byteStride: bufferLayout.byteStride || 0\n      };\n    }\n  }\n  return null;\n}\n\n/**\n * Search attribute mappings (e.g. interleaved attributes) for buffer mapping.\n * Not the name of the buffer might be the same as one of the interleaved attributes.\n */\nfunction getAttributeFromAttributesList(\n  bufferLayouts: BufferLayout[],\n  name: string\n): BufferAttributeInfo | null {\n  for (const bufferLayout of bufferLayouts) {\n    let byteStride: number | undefined = bufferLayout.byteStride;\n\n    // Calculate a default byte stride if not provided\n    if (typeof bufferLayout.byteStride !== 'number') {\n      for (const attributeMapping of bufferLayout.attributes || []) {\n        const info = decodeVertexFormat(attributeMapping.format);\n        // @ts-ignore\n        byteStride += info.byteLength;\n      }\n    }\n\n    const attributeMapping = bufferLayout.attributes?.find(mapping => mapping.attribute === name);\n    if (attributeMapping) {\n      return {\n        attributeName: attributeMapping.attribute,\n        bufferName: bufferLayout.name,\n        stepMode: bufferLayout.stepMode,\n        vertexFormat: attributeMapping.format,\n        byteOffset: attributeMapping.byteOffset,\n        // @ts-ignore\n        byteStride\n      };\n    }\n  }\n\n  return null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}