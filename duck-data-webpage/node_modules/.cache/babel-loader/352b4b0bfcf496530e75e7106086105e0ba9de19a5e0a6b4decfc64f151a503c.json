{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport function unpackIndexedGeometry(geometry) {\n  const {\n    indices,\n    attributes\n  } = geometry;\n  if (!indices) {\n    return geometry;\n  }\n  const vertexCount = indices.value.length;\n  const unpackedAttributes = {};\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const {\n      constant,\n      value,\n      size\n    } = attribute;\n    if (constant || !size) {\n      continue; // eslint-disable-line\n    }\n    const unpackedValue = new value.constructor(vertexCount * size);\n    for (let x = 0; x < vertexCount; ++x) {\n      const index = indices.value[x];\n      for (let i = 0; i < size; i++) {\n        unpackedValue[x * size + i] = value[index * size + i];\n      }\n    }\n    unpackedAttributes[attributeName] = {\n      size,\n      value: unpackedValue\n    };\n  }\n  return {\n    attributes: Object.assign({}, attributes, unpackedAttributes)\n  };\n}\n// export function calculateVertexNormals(positions: Float32Array): Uint8Array {\n//   let normals = new Uint8Array(positions.length / 3);\n//   for (let i = 0; i < positions.length; i++) {\n//     const vec1 = new Vector3(positions.subarray(i * 3, i + 0, i + 3));\n//     const vec2 = new Vector3(positions.subarray(i + 3, i + 6));\n//     const vec3 = new Vector3(positions.subarray(i + 6, i + 9));\n//     const normal = new Vector3(vec1).cross(vec2).normalize();\n//     normals.set(normal[0], i + 4);\n//     normals.set(normal[1], i + 4 + 1);\n//     normals.set(normal[2], i + 2);\n//   }\n//   const normal = new Vector3(vec1).cross(vec2).normalize();\n// }\n//# sourceMappingURL=geometry-utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}