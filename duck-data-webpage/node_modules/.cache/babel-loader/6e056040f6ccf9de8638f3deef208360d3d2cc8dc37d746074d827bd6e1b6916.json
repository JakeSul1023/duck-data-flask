{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { lumaStats } from \"../utils/stats-manager.js\";\nimport { log } from \"../utils/log.js\";\nimport { uid } from \"../utils/uid.js\";\nimport { Buffer } from \"./resources/buffer.js\";\nimport { isTextureFormatCompressed } from \"../gpu-type-utils/decode-texture-format.js\";\nimport { getTextureFormatCapabilities } from \"../gpu-type-utils/texture-format-capabilities.js\";\n/** Limits for a device (max supported sizes of resources, max number of bindings etc) */\nexport class DeviceLimits {}\n/** Set-like class for features (lets apps check for WebGL / WebGPU extensions) */\nexport class DeviceFeatures {\n  features;\n  disabledFeatures;\n  constructor() {\n    let features = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let disabledFeatures = arguments.length > 1 ? arguments[1] : undefined;\n    this.features = new Set(features);\n    this.disabledFeatures = disabledFeatures || {};\n  }\n  *[Symbol.iterator]() {\n    yield* this.features;\n  }\n  has(feature) {\n    return !this.disabledFeatures?.[feature] && this.features.has(feature);\n  }\n}\n/**\n * WebGPU Device/WebGL context abstraction\n */\nexport class Device {\n  static defaultProps = (() => ({\n    id: null,\n    powerPreference: 'high-performance',\n    failIfMajorPerformanceCaveat: false,\n    createCanvasContext: undefined,\n    // Callbacks\n    onError: error => log.error(error.message)(),\n    // Experimental\n    _reuseDevices: false,\n    _requestMaxLimits: true,\n    _factoryDestroyPolicy: 'unused',\n    // TODO - Change these after confirming things work as expected\n    _initializeFeatures: true,\n    _disabledFeatures: {\n      'compilation-status-async-webgl': true\n    },\n    _resourceDefaults: {},\n    // WebGL specific\n    webgl: {},\n    debug: log.get('debug') || undefined,\n    debugShaders: log.get('debug-shaders') || undefined,\n    debugFramebuffers: Boolean(log.get('debug-framebuffers')),\n    debugWebGL: Boolean(log.get('debug-webgl')),\n    debugSpectorJS: undefined,\n    // Note: log setting is queried by the spector.js code\n    debugSpectorJSUrl: undefined,\n    // INTERNAL\n    _handle: undefined\n  }))();\n  get [Symbol.toStringTag]() {\n    return 'Device';\n  }\n  constructor(props) {\n    this.props = {\n      ...Device.defaultProps,\n      ...props\n    };\n    this.id = this.props.id || uid(this[Symbol.toStringTag].toLowerCase());\n  }\n  /** id of this device, primarily for debugging */\n  id;\n  /** A copy of the device props  */\n  props;\n  /** Available for the application to store data on the device */\n  userData = {};\n  /** stats */\n  statsManager = (() => lumaStats)();\n  /** An abstract timestamp used for change tracking */\n  timestamp = 0;\n  /** True if this device has been reused during device creation (app has multiple references) */\n  _reused = false;\n  /** Used by other luma.gl modules to store data on the device */\n  _lumaData = {};\n  /** Determines what operations are supported on a texture format, checking against supported device features */\n  getTextureFormatCapabilities(format) {\n    const genericCapabilities = getTextureFormatCapabilities(format);\n    // Check standard features\n    const checkFeature = featureOrBoolean => (typeof featureOrBoolean === 'string' ? this.features.has(featureOrBoolean) : featureOrBoolean) ?? true;\n    const supported = checkFeature(genericCapabilities.create);\n    const deviceCapabilities = {\n      format,\n      create: supported,\n      render: supported && checkFeature(genericCapabilities.render),\n      filter: supported && checkFeature(genericCapabilities.filter),\n      blend: supported && checkFeature(genericCapabilities.blend),\n      store: supported && checkFeature(genericCapabilities.store)\n    };\n    return this._getDeviceSpecificTextureFormatCapabilities(deviceCapabilities);\n  }\n  /** Check if device supports a specific texture format (creation and `nearest` sampling) */\n  isTextureFormatSupported(format, capabilities) {\n    return this.getTextureFormatCapabilities(format).create;\n  }\n  /** Check if linear filtering (sampler interpolation) is supported for a specific texture format */\n  isTextureFormatFilterable(format) {\n    return this.getTextureFormatCapabilities(format).filter;\n  }\n  /** Check if device supports rendering to a framebuffer color attachment of a specific texture format */\n  isTextureFormatRenderable(format) {\n    return this.getTextureFormatCapabilities(format).render;\n  }\n  /** Check if a specific texture format is GPU compressed */\n  isTextureFormatCompressed(format) {\n    return isTextureFormatCompressed(format);\n  }\n  /**\n   * Trigger device loss.\n   * @returns `true` if context loss could actually be triggered.\n   * @note primarily intended for testing how application reacts to device loss\n   */\n  loseDevice() {\n    return false;\n  }\n  /** Report error (normally called for unhandled device errors) */\n  reportError(error) {\n    this.props.onError(error);\n  }\n  /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */\n  getDefaultCanvasContext() {\n    if (!this.canvasContext) {\n      throw new Error('Device has no default CanvasContext. See props.createCanvasContext');\n    }\n    return this.canvasContext;\n  }\n  createCommandEncoder() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    throw new Error('not implemented');\n  }\n  /** A monotonic counter for tracking buffer and texture updates */\n  incrementTimestamp() {\n    return this.timestamp++;\n  }\n  // Error Handling\n  /** Report unhandled device errors */\n  onError(error) {\n    this.props.onError(error);\n  }\n  // DEPRECATED METHODS\n  /** @deprecated Use getDefaultCanvasContext() */\n  getCanvasContext() {\n    return this.getDefaultCanvasContext();\n  }\n  // WebGL specific HACKS - enables app to remove webgl import\n  // Use until we have a better way to handle these\n  /** @deprecated - will be removed - should use command encoder */\n  readPixelsToArrayWebGL(source, options) {\n    throw new Error('not implemented');\n  }\n  /** @deprecated - will be removed - should use command encoder */\n  readPixelsToBufferWebGL(source, options) {\n    throw new Error('not implemented');\n  }\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  setParametersWebGL(parameters) {\n    throw new Error('not implemented');\n  }\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  getParametersWebGL(parameters) {\n    throw new Error('not implemented');\n  }\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  withParametersWebGL(parameters, func) {\n    throw new Error('not implemented');\n  }\n  /** @deprecated - will be removed - should use clear arguments in RenderPass */\n  clearWebGL(options) {\n    throw new Error('not implemented');\n  }\n  /** @deprecated - will be removed - should use for debugging only */\n  resetWebGL() {\n    throw new Error('not implemented');\n  }\n  // IMPLEMENTATION\n  /** Helper to get the canvas context props */\n  static _getCanvasContextProps(props) {\n    return props.createCanvasContext === true ? {} : props.createCanvasContext;\n  }\n  /** Subclasses use this to support .createBuffer() overloads */\n  _normalizeBufferProps(props) {\n    if (props instanceof ArrayBuffer || ArrayBuffer.isView(props)) {\n      props = {\n        data: props\n      };\n    }\n    // TODO - fragile, as this is done before we merge with default options\n    // inside the Buffer constructor\n    const newProps = {\n      ...props\n    };\n    // Deduce indexType\n    if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {\n      if (props.data instanceof Uint32Array) {\n        newProps.indexType = 'uint32';\n      } else if (props.data instanceof Uint16Array) {\n        newProps.indexType = 'uint16';\n      } else {\n        log.warn('indices buffer content must be of integer type')();\n      }\n    }\n    return newProps;\n  }\n}\n//# sourceMappingURL=device.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}