{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/*\n * Helper function for padArray\n */\nfunction padArrayChunk(options) {\n  const {\n    source,\n    target,\n    start = 0,\n    size,\n    getData\n  } = options;\n  const end = options.end || target.length;\n  const sourceLength = source.length;\n  const targetLength = end - start;\n  if (sourceLength > targetLength) {\n    target.set(source.subarray(0, targetLength), start);\n    return;\n  }\n  target.set(source, start);\n  if (!getData) {\n    return;\n  }\n  // source is not large enough to fill target space, call `getData` to get filler data\n  let i = sourceLength;\n  while (i < targetLength) {\n    const datum = getData(i, source);\n    for (let j = 0; j < size; j++) {\n      target[start + i] = datum[j] || 0;\n      i++;\n    }\n  }\n}\n/*\n * The padArray function stretches a source array to the size of a target array.\n   The arrays can have internal structures (like the attributes of PathLayer and\n   SolidPolygonLayer), defined by the optional sourceStartIndices and targetStartIndices parameters.\n   If the target array is larger, the getData callback is used to fill in the blanks.\n */\nexport function padArray(_ref) {\n  let {\n    source,\n    target,\n    size,\n    getData,\n    sourceStartIndices,\n    targetStartIndices\n  } = _ref;\n  if (!sourceStartIndices || !targetStartIndices) {\n    // Flat arrays\n    padArrayChunk({\n      source,\n      target,\n      size,\n      getData\n    });\n    return target;\n  }\n  // Arrays have internal structure\n  let sourceIndex = 0;\n  let targetIndex = 0;\n  const getChunkData = getData && ((i, chunk) => getData(i + targetIndex, chunk));\n  const n = Math.min(sourceStartIndices.length, targetStartIndices.length);\n  for (let i = 1; i < n; i++) {\n    const nextSourceIndex = sourceStartIndices[i] * size;\n    const nextTargetIndex = targetStartIndices[i] * size;\n    padArrayChunk({\n      source: source.subarray(sourceIndex, nextSourceIndex),\n      target,\n      start: targetIndex,\n      end: nextTargetIndex,\n      size,\n      getData: getChunkData\n    });\n    sourceIndex = nextSourceIndex;\n    targetIndex = nextTargetIndex;\n  }\n  if (targetIndex < target.length) {\n    padArrayChunk({\n      // @ts-ignore\n      source: [],\n      target,\n      start: targetIndex,\n      size,\n      getData: getChunkData\n    });\n  }\n  return target;\n}\n//# sourceMappingURL=array-utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}