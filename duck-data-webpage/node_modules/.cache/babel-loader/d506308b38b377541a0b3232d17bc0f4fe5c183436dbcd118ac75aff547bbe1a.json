{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ImageLoader } from '@loaders.gl/images';\nimport { mergeLoaderOptions, ImageSource } from '@loaders.gl/loader-utils';\nimport { WMSCapabilitiesLoader } from \"../../wms-capabilities-loader.js\";\nimport { WMSFeatureInfoLoader } from \"../../wip/wms-feature-info-loader.js\";\nimport { WMSLayerDescriptionLoader } from \"../../wip/wms-layer-description-loader.js\";\nimport { WMSErrorLoader } from \"../../wms-error-loader.js\";\nexport const WMSSource = {\n  name: 'Web Map Service (OGC WMS)',\n  id: 'wms',\n  module: 'wms',\n  version: '0.0.0',\n  extensions: [],\n  mimeTypes: [],\n  options: {\n    wms: {\n      // TODO - add options here\n    }\n  },\n  type: 'wms',\n  fromUrl: true,\n  fromBlob: false,\n  testURL: url => url.toLowerCase().includes('wms'),\n  createDataSource: (url, props) => new WMSImageSource(url, props)\n};\n//\n/**\n * The WMSImageSource class provides\n * - provides type safe methods to form URLs to a WMS service\n * - provides type safe methods to query and parse results (and errors) from a WMS service\n * - implements the ImageSource interface\n * @note Only the URL parameter conversion is supported. XML posts are not supported.\n */\nexport class WMSImageSource extends ImageSource {\n  /** Base URL to the service */\n  url;\n  data;\n  /** In WMS 1.3.0, replaces references to EPSG:4326 with CRS:84. But not always supported. Default: false */\n  substituteCRS84;\n  /** In WMS 1.3.0, flips x,y (lng, lat) coordinates for the supplied coordinate systems. Default: ['ESPG:4326'] */\n  flipCRS;\n  /** Default static WMS parameters */\n  wmsParameters;\n  /** Default static vendor parameters */\n  vendorParameters;\n  capabilities = null;\n  /** Create a WMSImageSource */\n  constructor(url, props) {\n    super(props);\n    // TODO - defaults such as version, layers etc could be extracted from a base URL with parameters\n    // This would make pasting in any WMS URL more likely to make this class just work.\n    // const {baseUrl, parameters} = this._parseWMSUrl(props.url);\n    this.url = url;\n    this.data = url;\n    this.substituteCRS84 = props.wms?.substituteCRS84 ?? props.substituteCRS84 ?? false;\n    this.flipCRS = ['EPSG:4326'];\n    this.wmsParameters = {\n      layers: undefined,\n      query_layers: undefined,\n      styles: undefined,\n      version: '1.3.0',\n      crs: 'EPSG:4326',\n      format: 'image/png',\n      info_format: 'text/plain',\n      transparent: undefined,\n      time: undefined,\n      elevation: undefined,\n      ...props.wmsParameters,\n      // deprecated\n      ...props.wms?.wmsParameters\n    };\n    this.vendorParameters = props.wms?.vendorParameters || props.vendorParameters || {};\n  }\n  // ImageSource implementation\n  async getMetadata() {\n    const capabilities = await this.getCapabilities();\n    return this.normalizeMetadata(capabilities);\n  }\n  async getImage(parameters) {\n    // Replace the GetImage `boundingBox` parameter with the WMS flat `bbox` parameter.\n    const {\n      boundingBox,\n      bbox,\n      ...rest\n    } = parameters;\n    const wmsParameters = {\n      bbox: boundingBox ? [...boundingBox[0], ...boundingBox[1]] : bbox,\n      ...rest\n    };\n    return await this.getMap(wmsParameters);\n  }\n  normalizeMetadata(capabilities) {\n    return capabilities;\n  }\n  // WMS Service API Stubs\n  /** Get Capabilities */\n  async getCapabilities(wmsParameters, vendorParameters) {\n    const url = this.getCapabilitiesURL(wmsParameters, vendorParameters);\n    const response = await this.fetch(url);\n    const arrayBuffer = await response.arrayBuffer();\n    this._checkResponse(response, arrayBuffer);\n    const capabilities = await WMSCapabilitiesLoader.parse(arrayBuffer, this.loadOptions);\n    this.capabilities = capabilities;\n    return capabilities;\n  }\n  /** Get a map image */\n  async getMap(wmsParameters, vendorParameters) {\n    const url = this.getMapURL(wmsParameters, vendorParameters);\n    const response = await this.fetch(url);\n    const arrayBuffer = await response.arrayBuffer();\n    this._checkResponse(response, arrayBuffer);\n    try {\n      return await ImageLoader.parse(arrayBuffer, this.loadOptions);\n    } catch {\n      throw this._parseError(arrayBuffer);\n    }\n  }\n  /** Get Feature Info for a coordinate */\n  async getFeatureInfo(wmsParameters, vendorParameters) {\n    const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);\n    const response = await this.fetch(url);\n    const arrayBuffer = await response.arrayBuffer();\n    this._checkResponse(response, arrayBuffer);\n    return await WMSFeatureInfoLoader.parse(arrayBuffer, this.loadOptions);\n  }\n  /** Get Feature Info for a coordinate */\n  async getFeatureInfoText(wmsParameters, vendorParameters) {\n    const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);\n    const response = await this.fetch(url);\n    const arrayBuffer = await response.arrayBuffer();\n    this._checkResponse(response, arrayBuffer);\n    return new TextDecoder().decode(arrayBuffer);\n  }\n  /** Get more information about a layer */\n  async describeLayer(wmsParameters, vendorParameters) {\n    const url = this.describeLayerURL(wmsParameters, vendorParameters);\n    const response = await this.fetch(url);\n    const arrayBuffer = await response.arrayBuffer();\n    this._checkResponse(response, arrayBuffer);\n    return await WMSLayerDescriptionLoader.parse(arrayBuffer, this.loadOptions);\n  }\n  /** Get an image with a semantic legend */\n  async getLegendGraphic(wmsParameters, vendorParameters) {\n    const url = this.getLegendGraphicURL(wmsParameters, vendorParameters);\n    const response = await this.fetch(url);\n    const arrayBuffer = await response.arrayBuffer();\n    this._checkResponse(response, arrayBuffer);\n    try {\n      return await ImageLoader.parse(arrayBuffer, this.loadOptions);\n    } catch {\n      throw this._parseError(arrayBuffer);\n    }\n  }\n  // Typed URL creators\n  // For applications that want full control of fetching and parsing\n  /** Generate a URL for the GetCapabilities request */\n  getCapabilitiesURL(wmsParameters, vendorParameters) {\n    const options = {\n      version: this.wmsParameters.version,\n      ...wmsParameters\n    };\n    return this._getWMSUrl('GetCapabilities', options, vendorParameters);\n  }\n  /** Generate a URL for the GetMap request */\n  getMapURL(wmsParameters, vendorParameters) {\n    wmsParameters = this._getWMS130Parameters(wmsParameters);\n    const options = {\n      version: this.wmsParameters.version,\n      format: this.wmsParameters.format,\n      transparent: this.wmsParameters.transparent,\n      time: this.wmsParameters.time,\n      elevation: this.wmsParameters.elevation,\n      layers: this.wmsParameters.layers,\n      styles: this.wmsParameters.styles,\n      crs: this.wmsParameters.crs,\n      // bbox: [-77.87304, 40.78975, -77.85828, 40.80228],\n      // width: 1200,\n      // height: 900,\n      ...wmsParameters\n    };\n    return this._getWMSUrl('GetMap', options, vendorParameters);\n  }\n  /** Generate a URL for the GetFeatureInfo request */\n  getFeatureInfoURL(wmsParameters, vendorParameters) {\n    wmsParameters = this._getWMS130Parameters(wmsParameters);\n    // Replace the GetImage `boundingBox` parameter with the WMS flat `bbox` parameter.\n    const {\n      boundingBox,\n      bbox\n    } = wmsParameters;\n    wmsParameters.bbox = boundingBox ? [...boundingBox[0], ...boundingBox[1]] : bbox;\n    const options = {\n      version: this.wmsParameters.version,\n      // query_layers: [],\n      // format: this.wmsParameters.format,\n      info_format: this.wmsParameters.info_format,\n      layers: this.wmsParameters.layers,\n      query_layers: this.wmsParameters.query_layers,\n      styles: this.wmsParameters.styles,\n      crs: this.wmsParameters.crs,\n      // bbox: [-77.87304, 40.78975, -77.85828, 40.80228],\n      // width: 1200,\n      // height: 900,\n      // x: undefined!,\n      // y: undefined!,\n      ...wmsParameters\n    };\n    return this._getWMSUrl('GetFeatureInfo', options, vendorParameters);\n  }\n  /** Generate a URL for the GetFeatureInfo request */\n  describeLayerURL(wmsParameters, vendorParameters) {\n    const options = {\n      version: this.wmsParameters.version,\n      ...wmsParameters\n    };\n    return this._getWMSUrl('DescribeLayer', options, vendorParameters);\n  }\n  getLegendGraphicURL(wmsParameters, vendorParameters) {\n    const options = {\n      version: this.wmsParameters.version,\n      // format?\n      ...wmsParameters\n    };\n    return this._getWMSUrl('GetLegendGraphic', options, vendorParameters);\n  }\n  // INTERNAL METHODS\n  _parseWMSUrl(url) {\n    const [baseUrl, search] = url.split('?');\n    const searchParams = search.split('&');\n    const parameters = {};\n    for (const parameter of searchParams) {\n      const [key, value] = parameter.split('=');\n      parameters[key] = value;\n    }\n    return {\n      url: baseUrl,\n      parameters\n    };\n  }\n  /**\n   * Generate a URL with parameters\n   * @note case _getWMSUrl may need to be overridden to handle certain backends?\n   * @note at the moment, only URLs with parameters are supported (no XML payloads)\n   * */\n  _getWMSUrl(request, wmsParameters, vendorParameters) {\n    let url = this.url;\n    let first = true;\n    // Add any vendor searchParams\n    const allParameters = {\n      service: 'WMS',\n      version: wmsParameters.version,\n      request,\n      ...wmsParameters,\n      ...this.vendorParameters,\n      ...vendorParameters\n    };\n    // Encode the keys\n    const IGNORE_EMPTY_KEYS = ['transparent', 'time', 'elevation'];\n    for (const [key, value] of Object.entries(allParameters)) {\n      // hack to preserve test cases. Not super clear if keys should be included when values are undefined\n      if (!IGNORE_EMPTY_KEYS.includes(key) || value) {\n        url += first ? '?' : '&';\n        first = false;\n        url += this._getURLParameter(key, value, wmsParameters);\n      }\n    }\n    return encodeURI(url);\n  }\n  _getWMS130Parameters(wmsParameters) {\n    const newParameters = {\n      ...wmsParameters\n    };\n    if (newParameters.srs) {\n      newParameters.crs = newParameters.crs || newParameters.srs;\n      delete newParameters.srs;\n    }\n    return newParameters;\n  }\n  // eslint-disable-next-line complexity\n  _getURLParameter(key, value, wmsParameters) {\n    // Substitute by key\n    switch (key) {\n      case 'crs':\n        // CRS was called SRS before WMS 1.3.0\n        if (wmsParameters.version !== '1.3.0') {\n          key = 'srs';\n        } else if (this.substituteCRS84 && value === 'EPSG:4326') {\n          /** In 1.3.0, replaces references to 'EPSG:4326' with the new backwards compatible CRS:84 */\n          // Substitute by value\n          value = 'CRS:84';\n        }\n        break;\n      case 'srs':\n        // CRS was called SRS before WMS 1.3.0\n        if (wmsParameters.version === '1.3.0') {\n          key = 'crs';\n        }\n        break;\n      case 'bbox':\n        // Coordinate order is flipped for certain CRS in WMS 1.3.0\n        const bbox = this._flipBoundingBox(value, wmsParameters);\n        if (bbox) {\n          value = bbox;\n        }\n        break;\n      case 'x':\n        // i is the parameter used in WMS 1.3\n        // TODO - change parameter to `i` and convert to `x` if not 1.3\n        if (wmsParameters.version === '1.3.0') {\n          key = 'i';\n        }\n        break;\n      case 'y':\n        // j is the parameter used in WMS 1.3\n        // TODO - change parameter to `j` and convert to `y` if not 1.3\n        if (wmsParameters.version === '1.3.0') {\n          key = 'j';\n        }\n        break;\n      default:\n      // do nothing\n    }\n    key = key.toUpperCase();\n    return Array.isArray(value) ? `${key}=${value.join(',')}` : `${key}=${value ? String(value) : ''}`;\n  }\n  /** Coordinate order is flipped for certain CRS in WMS 1.3.0 */\n  _flipBoundingBox(bboxValue, wmsParameters) {\n    // Sanity checks\n    if (!Array.isArray(bboxValue) || bboxValue.length !== 4) {\n      return null;\n    }\n    const flipCoordinates =\n    // Only affects WMS 1.3.0\n    wmsParameters.version === '1.3.0' &&\n    // Flip if we are dealing with a CRS that was flipped in 1.3.0\n    this.flipCRS.includes(wmsParameters.crs || '') &&\n    // Don't flip if we are substituting EPSG:4326 with CRS:84\n    !(this.substituteCRS84 && wmsParameters.crs === 'EPSG:4326');\n    const bbox = bboxValue;\n    return flipCoordinates ? [bbox[1], bbox[0], bbox[3], bbox[2]] : bbox;\n  }\n  /** Fetches an array buffer and checks the response (boilerplate reduction) */\n  async _fetchArrayBuffer(url) {\n    const response = await this.fetch(url);\n    const arrayBuffer = await response.arrayBuffer();\n    this._checkResponse(response, arrayBuffer);\n    return arrayBuffer;\n  }\n  /** Checks for and parses a WMS XML formatted ServiceError and throws an exception */\n  _checkResponse(response, arrayBuffer) {\n    const contentType = response.headers['content-type'];\n    if (!response.ok || WMSErrorLoader.mimeTypes.includes(contentType)) {\n      // We want error responses to throw exceptions, the WMSErrorLoader can do this\n      const loadOptions = mergeLoaderOptions(this.loadOptions, {\n        wms: {\n          throwOnError: true\n        }\n      });\n      const error = WMSErrorLoader.parseSync?.(arrayBuffer, loadOptions);\n      throw new Error(error);\n    }\n  }\n  /** Error situation detected */\n  _parseError(arrayBuffer) {\n    const error = WMSErrorLoader.parseSync?.(arrayBuffer, this.loadOptions);\n    return new Error(error);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}