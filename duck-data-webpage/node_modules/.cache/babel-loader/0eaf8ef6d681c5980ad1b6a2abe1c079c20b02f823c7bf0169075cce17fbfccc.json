{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* eslint-disable complexity */\nimport DataColumn from \"./data-column.js\";\nimport assert from \"../../utils/assert.js\";\nimport { createIterable, getAccessorFromBuffer } from \"../../utils/iterable-utils.js\";\nimport { fillArray } from \"../../utils/flatten.js\";\nimport * as range from \"../../utils/range.js\";\nimport { bufferLayoutEqual } from \"./gl-utils.js\";\nimport { normalizeTransitionSettings } from \"./transition-settings.js\";\nexport default class Attribute extends DataColumn {\n  constructor(device, opts) {\n    super(device, opts, {\n      startIndices: null,\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      layoutChanged: false,\n      updateRanges: range.FULL\n    });\n    /** Legacy approach to set attribute value - read `isConstant` instead for attribute state */\n    this.constant = false;\n    // eslint-disable-next-line\n    this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : undefined);\n    Object.seal(this.settings);\n    Object.seal(this.state);\n    // Check all fields and generate helpful error messages\n    this._validateAttributeUpdaters();\n  }\n  get startIndices() {\n    return this.state.startIndices;\n  }\n  set startIndices(layout) {\n    this.state.startIndices = layout;\n  }\n  needsUpdate() {\n    return this.state.needsUpdate;\n  }\n  needsRedraw({\n    clearChangedFlags = false\n  } = {}) {\n    const needsRedraw = this.state.needsRedraw;\n    this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n    return needsRedraw;\n  }\n  layoutChanged() {\n    return this.state.layoutChanged;\n  }\n  setAccessor(accessor) {\n    var _a;\n    (_a = this.state).layoutChanged || (_a.layoutChanged = !bufferLayoutEqual(accessor, this.getAccessor()));\n    super.setAccessor(accessor);\n  }\n  getUpdateTriggers() {\n    const {\n      accessor\n    } = this.settings;\n    // Backards compatibility: allow attribute name to be used as update trigger key\n    return [this.id].concat(typeof accessor !== 'function' && accessor || []);\n  }\n  supportsTransition() {\n    return Boolean(this.settings.transition);\n  }\n  // Resolve transition settings object if transition is enabled, otherwise `null`\n  getTransitionSetting(opts) {\n    if (!opts || !this.supportsTransition()) {\n      return null;\n    }\n    const {\n      accessor\n    } = this.settings;\n    // TODO: have the layer resolve these transition settings itself?\n    const layerSettings = this.settings.transition;\n    // these are the transition settings passed in by the user\n    const userSettings = Array.isArray(accessor) ?\n    // @ts-ignore\n    opts[accessor.find(a => opts[a])] :\n    // @ts-ignore\n    opts[accessor];\n    // Shorthand: use duration instead of parameter object\n    return normalizeTransitionSettings(userSettings, layerSettings);\n  }\n  setNeedsUpdate(reason = this.id, dataRange) {\n    this.state.needsUpdate = this.state.needsUpdate || reason;\n    this.setNeedsRedraw(reason);\n    if (dataRange) {\n      const {\n        startRow = 0,\n        endRow = Infinity\n      } = dataRange;\n      this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n    } else {\n      this.state.updateRanges = range.FULL;\n    }\n  }\n  clearNeedsUpdate() {\n    this.state.needsUpdate = false;\n    this.state.updateRanges = range.EMPTY;\n  }\n  setNeedsRedraw(reason = this.id) {\n    this.state.needsRedraw = this.state.needsRedraw || reason;\n  }\n  allocate(numInstances) {\n    const {\n      state,\n      settings\n    } = this;\n    if (settings.noAlloc) {\n      // Data is provided through a Buffer object.\n      return false;\n    }\n    if (settings.update) {\n      super.allocate(numInstances, state.updateRanges !== range.FULL);\n      return true;\n    }\n    return false;\n  }\n  updateBuffer({\n    numInstances,\n    data,\n    props,\n    context\n  }) {\n    if (!this.needsUpdate()) {\n      return false;\n    }\n    const {\n      state: {\n        updateRanges\n      },\n      settings: {\n        update,\n        noAlloc\n      }\n    } = this;\n    let updated = true;\n    if (update) {\n      // Custom updater - typically for non-instanced layers\n      for (const [startRow, endRow] of updateRanges) {\n        update.call(context, this, {\n          data,\n          startRow,\n          endRow,\n          props,\n          numInstances\n        });\n      }\n      if (!this.value) {\n        // no value was assigned during update\n      } else if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {\n        this.setData({\n          value: this.value,\n          constant: this.constant\n        });\n        // Setting attribute.constant in updater is a legacy approach that interferes with allocation in the next cycle\n        // Respect it here but reset after use\n        this.constant = false;\n      } else {\n        for (const [startRow, endRow] of updateRanges) {\n          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n          const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;\n          super.updateSubBuffer({\n            startOffset,\n            endOffset\n          });\n        }\n      }\n      this._checkAttributeArray();\n    } else {\n      updated = false;\n    }\n    this.clearNeedsUpdate();\n    this.setNeedsRedraw();\n    return updated;\n  }\n  // Use generic value\n  // Returns true if successful\n  setConstantValue(value) {\n    // TODO(ibgreen): WebGPU does not support constant values\n    const isWebGPU = this.device.type === 'webgpu';\n    if (isWebGPU || value === undefined || typeof value === 'function') {\n      return false;\n    }\n    const hasChanged = this.setData({\n      constant: true,\n      value\n    });\n    if (hasChanged) {\n      this.setNeedsRedraw();\n    }\n    this.clearNeedsUpdate();\n    return true;\n  }\n  // Use external buffer\n  // Returns true if successful\n  // eslint-disable-next-line max-statements\n  setExternalBuffer(buffer) {\n    const {\n      state\n    } = this;\n    if (!buffer) {\n      state.lastExternalBuffer = null;\n      return false;\n    }\n    this.clearNeedsUpdate();\n    if (state.lastExternalBuffer === buffer) {\n      return true;\n    }\n    state.lastExternalBuffer = buffer;\n    this.setNeedsRedraw();\n    this.setData(buffer);\n    return true;\n  }\n  // Binary value is a typed array packed from mapping the source data with the accessor\n  // If the returned value from the accessor is the same as the attribute value, set it directly\n  // Otherwise use the auto updater for transform/normalization\n  setBinaryValue(buffer, startIndices = null) {\n    const {\n      state,\n      settings\n    } = this;\n    if (!buffer) {\n      state.binaryValue = null;\n      state.binaryAccessor = null;\n      return false;\n    }\n    if (settings.noAlloc) {\n      // Let the layer handle this\n      return false;\n    }\n    if (state.binaryValue === buffer) {\n      this.clearNeedsUpdate();\n      return true;\n    }\n    state.binaryValue = buffer;\n    this.setNeedsRedraw();\n    const needsUpdate = settings.transform || startIndices !== this.startIndices;\n    if (needsUpdate) {\n      if (ArrayBuffer.isView(buffer)) {\n        buffer = {\n          value: buffer\n        };\n      }\n      const binaryValue = buffer;\n      assert(ArrayBuffer.isView(binaryValue.value), `invalid ${settings.accessor}`);\n      const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;\n      state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {\n        size: binaryValue.size || this.size,\n        stride: binaryValue.stride,\n        offset: binaryValue.offset,\n        startIndices: startIndices,\n        nested: needsNormalize\n      });\n      // Fall through to auto updater\n      return false;\n    }\n    this.clearNeedsUpdate();\n    this.setData(buffer);\n    return true;\n  }\n  getVertexOffset(row) {\n    const {\n      startIndices\n    } = this;\n    const vertexIndex = startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row;\n    return vertexIndex * this.size;\n  }\n  getValue() {\n    const shaderAttributeDefs = this.settings.shaderAttributes;\n    const result = super.getValue();\n    if (!shaderAttributeDefs) {\n      return result;\n    }\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      Object.assign(result, super.getValue(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));\n    }\n    return result;\n  }\n  /** Generate WebGPU-style buffer layout descriptor from this attribute */\n  getBufferLayout(/** A luma.gl Model-shaped object that supplies additional hint to attribute resolution */\n  modelInfo) {\n    // Clear change flag\n    this.state.layoutChanged = false;\n    const shaderAttributeDefs = this.settings.shaderAttributes;\n    const result = super._getBufferLayout();\n    const {\n      stepMode\n    } = this.settings;\n    if (stepMode === 'dynamic') {\n      // If model info is provided, use isInstanced flag to determine step mode\n      // If no model info is provided, assume it's an instanced model (most common use case)\n      result.stepMode = modelInfo ? modelInfo.isInstanced ? 'instance' : 'vertex' : 'instance';\n    } else {\n      result.stepMode = stepMode ?? 'vertex';\n    }\n    if (!shaderAttributeDefs) {\n      return result;\n    }\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      const map = super._getBufferLayout(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]);\n      // @ts-ignore\n      result.attributes.push(...map.attributes);\n    }\n    return result;\n  }\n  /* eslint-disable max-depth, max-statements */\n  _autoUpdater(attribute, {\n    data,\n    startRow,\n    endRow,\n    props,\n    numInstances\n  }) {\n    if (attribute.constant) {\n      // @ts-ignore TODO(ibgreen) declare context?\n      if (this.context.device.type !== 'webgpu') {\n        return;\n      }\n    }\n    const {\n      settings,\n      state,\n      value,\n      size,\n      startIndices\n    } = attribute;\n    const {\n      accessor,\n      transform\n    } = settings;\n    let accessorFunc = state.binaryAccessor || (\n    // @ts-ignore\n    typeof accessor === 'function' ? accessor : props[accessor]);\n    // TODO(ibgreen) WebGPU needs buffers, generate an accessor function from a constant\n    if (typeof accessorFunc !== 'function') {\n      accessorFunc = () => accessorFunc;\n    }\n    assert(typeof accessorFunc === 'function', `accessor \"${accessor}\" is not a function`);\n    let i = attribute.getVertexOffset(startRow);\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      let objectValue = accessorFunc(object, objectInfo);\n      if (transform) {\n        // transform callbacks could be bound to a particular layer instance.\n        // always point `this` to the current layer.\n        objectValue = transform.call(this, objectValue);\n      }\n      if (startIndices) {\n        const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];\n        if (objectValue && Array.isArray(objectValue[0])) {\n          let startIndex = i;\n          for (const item of objectValue) {\n            attribute._normalizeValue(item, value, startIndex);\n            startIndex += size;\n          }\n        } else if (objectValue && objectValue.length > size) {\n          value.set(objectValue, i);\n        } else {\n          attribute._normalizeValue(objectValue, objectInfo.target, 0);\n          fillArray({\n            target: value,\n            source: objectInfo.target,\n            start: i,\n            count: numVertices\n          });\n        }\n        i += numVertices * size;\n      } else {\n        attribute._normalizeValue(objectValue, value, i);\n        i += size;\n      }\n    }\n  }\n  /* eslint-enable max-depth, max-statements */\n  // Validate deck.gl level fields\n  _validateAttributeUpdaters() {\n    const {\n      settings\n    } = this;\n    // Check that 'update' is a valid function\n    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n    if (!hasUpdater) {\n      throw new Error(`Attribute ${this.id} missing update or accessor`);\n    }\n  }\n  // check that the first few elements of the attribute are reasonable\n  /* eslint-disable no-fallthrough */\n  _checkAttributeArray() {\n    const {\n      value\n    } = this;\n    const limit = Math.min(4, this.size);\n    if (value && value.length >= limit) {\n      let valid = true;\n      switch (limit) {\n        case 4:\n          valid = valid && Number.isFinite(value[3]);\n        case 3:\n          valid = valid && Number.isFinite(value[2]);\n        case 2:\n          valid = valid && Number.isFinite(value[1]);\n        case 1:\n          valid = valid && Number.isFinite(value[0]);\n          break;\n        default:\n          valid = false;\n      }\n      if (!valid) {\n        throw new Error(`Illegal attribute generated for ${this.id}`);\n      }\n    }\n  }\n}\n//# sourceMappingURL=attribute.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}