{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log, createIterable, project32, Viewport } from '@deck.gl/core';\nimport { WebGLAggregator, CPUAggregator } from \"../common/aggregator/index.js\";\nimport AggregationLayer from \"../common/aggregation-layer.js\";\nimport { defaultColorRange } from \"../common/utils/color-utils.js\";\nimport { AttributeWithScale } from \"../common/utils/scale-utils.js\";\nimport { getBinIdRange } from \"../common/utils/bounds-utils.js\";\nimport HexagonCellLayer from \"./hexagon-cell-layer.js\";\nimport { pointToHexbin, HexbinVertices, getHexbinCentroid, pointToHexbinGLSL } from \"./hexbin.js\";\nimport { binOptionsUniforms } from \"./bin-options-uniforms.js\";\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\nconst defaultProps = {\n  gpuAggregation: true,\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorValue: {\n    type: 'accessor',\n    value: null\n  },\n  // default value is calculated from `getColorWeight` and `colorAggregation`\n  getColorWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  colorAggregation: 'SUM',\n  lowerPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 0\n  },\n  upperPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 100\n  },\n  colorScaleType: 'quantize',\n  onSetColorDomain: noop,\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationValue: {\n    type: 'accessor',\n    value: null\n  },\n  // default value is calculated from `getElevationWeight` and `elevationAggregation`\n  getElevationWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  elevationAggregation: 'SUM',\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  elevationLowerPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 0\n  },\n  elevationUpperPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 100\n  },\n  elevationScaleType: 'linear',\n  onSetElevationDomain: noop,\n  // hexbin\n  radius: {\n    type: 'number',\n    min: 1,\n    value: 1000\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  hexagonAggregator: {\n    type: 'function',\n    optional: true,\n    value: null\n  },\n  extruded: false,\n  // Optional material for 'lighting' shader module\n  material: true\n};\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\nclass HexagonLayer extends AggregationLayer {\n  getAggregatorType() {\n    const {\n      gpuAggregation,\n      hexagonAggregator,\n      getColorValue,\n      getElevationValue\n    } = this.props;\n    if (gpuAggregation && (hexagonAggregator || getColorValue || getElevationValue)) {\n      // If these features are desired by the app, the user should explicitly use CPU aggregation\n      log.warn('Features not supported by GPU aggregation, falling back to CPU')();\n      return 'cpu';\n    }\n    if (\n    // GPU aggregation is requested\n    gpuAggregation &&\n    // GPU aggregation is supported by the device\n    WebGLAggregator.isSupported(this.context.device)) {\n      return 'gpu';\n    }\n    return 'cpu';\n  }\n  createAggregator(type) {\n    if (type === 'cpu') {\n      const {\n        hexagonAggregator,\n        radius\n      } = this.props;\n      return new CPUAggregator({\n        dimensions: 2,\n        getBin: {\n          sources: ['positions'],\n          getValue: ({\n            positions\n          }, index, opts) => {\n            if (hexagonAggregator) {\n              return hexagonAggregator(positions, radius);\n            }\n            const viewport = this.state.aggregatorViewport;\n            // project to common space\n            const p = viewport.projectPosition(positions);\n            const {\n              radiusCommon,\n              hexOriginCommon\n            } = opts;\n            return pointToHexbin([p[0] - hexOriginCommon[0], p[1] - hexOriginCommon[1]], radiusCommon);\n          }\n        },\n        getValue: [{\n          sources: ['colorWeights'],\n          getValue: ({\n            colorWeights\n          }) => colorWeights\n        }, {\n          sources: ['elevationWeights'],\n          getValue: ({\n            elevationWeights\n          }) => elevationWeights\n        }]\n      });\n    }\n    return new WebGLAggregator(this.context.device, {\n      dimensions: 2,\n      channelCount: 2,\n      bufferLayout: this.getAttributeManager().getBufferLayouts({\n        isInstanced: false\n      }),\n      ...super.getShaders({\n        modules: [project32, binOptionsUniforms],\n        vs: /* glsl */`\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float colorWeights;\n  in float elevationWeights;\n  \n  ${pointToHexbinGLSL}\n\n  void getBin(out ivec2 binId) {\n    vec3 positionCommon = project_position(positions, positions64Low);\n    binId = pointToHexbin(positionCommon.xy, binOptions.radiusCommon);\n  }\n  void getValue(out vec2 value) {\n    value = vec2(colorWeights, elevationWeights);\n  }\n  `\n      })\n    });\n  }\n  initializeState() {\n    super.initializeState();\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 'float64',\n        fp64: this.use64bitPositions()\n      },\n      colorWeights: {\n        size: 1,\n        accessor: 'getColorWeight'\n      },\n      elevationWeights: {\n        size: 1,\n        accessor: 'getElevationWeight'\n      }\n    });\n  }\n  updateState(params) {\n    const aggregatorChanged = super.updateState(params);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const {\n      aggregator\n    } = this.state;\n    if ((changeFlags.dataChanged || !this.state.dataAsArray) && (props.getColorValue || props.getElevationValue)) {\n      // Convert data to array\n      this.state.dataAsArray = Array.from(createIterable(props.data).iterable);\n    }\n    if (aggregatorChanged || changeFlags.dataChanged || props.radius !== oldProps.radius || props.getColorValue !== oldProps.getColorValue || props.getElevationValue !== oldProps.getElevationValue || props.colorAggregation !== oldProps.colorAggregation || props.elevationAggregation !== oldProps.elevationAggregation) {\n      this._updateBinOptions();\n      const {\n        radiusCommon,\n        hexOriginCommon,\n        binIdRange,\n        dataAsArray\n      } = this.state;\n      aggregator.setProps({\n        // @ts-expect-error only used by GPUAggregator\n        binIdRange,\n        pointCount: this.getNumInstances(),\n        operations: [props.colorAggregation, props.elevationAggregation],\n        binOptions: {\n          radiusCommon,\n          hexOriginCommon\n        },\n        onUpdate: this._onAggregationUpdate.bind(this)\n      });\n      if (dataAsArray) {\n        const {\n          getColorValue,\n          getElevationValue\n        } = this.props;\n        aggregator.setProps({\n          // @ts-expect-error only used by CPUAggregator\n          customOperations: [getColorValue && (indices => getColorValue(indices.map(i => dataAsArray[i]), {\n            indices,\n            data: props.data\n          })), getElevationValue && (indices => getElevationValue(indices.map(i => dataAsArray[i]), {\n            indices,\n            data: props.data\n          }))]\n        });\n      }\n    }\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getColorValue) {\n      aggregator.setNeedsUpdate(0);\n    }\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getElevationValue) {\n      aggregator.setNeedsUpdate(1);\n    }\n    return aggregatorChanged;\n  }\n  _updateBinOptions() {\n    const bounds = this.getBounds();\n    let radiusCommon = 1;\n    let hexOriginCommon = [0, 0];\n    let binIdRange = [[0, 1], [0, 1]];\n    let viewport = this.context.viewport;\n    if (bounds && Number.isFinite(bounds[0][0])) {\n      let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];\n      const {\n        radius\n      } = this.props;\n      const {\n        unitsPerMeter\n      } = viewport.getDistanceScales(centroid);\n      radiusCommon = unitsPerMeter[0] * radius;\n      // Use the centroid of the hex at the center of the data\n      // This offsets the common space without changing the bins\n      const centerHex = pointToHexbin(viewport.projectFlat(centroid), radiusCommon);\n      centroid = viewport.unprojectFlat(getHexbinCentroid(centerHex, radiusCommon));\n      const ViewportType = viewport.constructor;\n      // We construct a viewport for the GPU aggregator's project module\n      // This viewport is determined by data\n      // removes arbitrary precision variance that depends on initial view state\n      viewport = viewport.isGeospatial ? new ViewportType({\n        longitude: centroid[0],\n        latitude: centroid[1],\n        zoom: 12\n      }) : new Viewport({\n        position: [centroid[0], centroid[1], 0],\n        zoom: 12\n      });\n      hexOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];\n      binIdRange = getBinIdRange({\n        dataBounds: bounds,\n        getBinId: p => {\n          const positionCommon = viewport.projectFlat(p);\n          positionCommon[0] -= hexOriginCommon[0];\n          positionCommon[1] -= hexOriginCommon[1];\n          return pointToHexbin(positionCommon, radiusCommon);\n        },\n        padding: 1\n      });\n    }\n    this.setState({\n      radiusCommon,\n      hexOriginCommon,\n      binIdRange,\n      aggregatorViewport: viewport\n    });\n  }\n  draw(opts) {\n    // Replaces render time viewport with our own\n    if (opts.shaderModuleProps.project) {\n      opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;\n    }\n    super.draw(opts);\n  }\n  _onAggregationUpdate({\n    channel\n  }) {\n    const props = this.getCurrentLayer().props;\n    const {\n      aggregator\n    } = this.state;\n    if (channel === 0) {\n      const result = aggregator.getResult(0);\n      this.setState({\n        colors: new AttributeWithScale(result, aggregator.binCount)\n      });\n      props.onSetColorDomain(aggregator.getResultDomain(0));\n    } else if (channel === 1) {\n      const result = aggregator.getResult(1);\n      this.setState({\n        elevations: new AttributeWithScale(result, aggregator.binCount)\n      });\n      props.onSetElevationDomain(aggregator.getResultDomain(1));\n    }\n  }\n  onAttributeChange(id) {\n    const {\n      aggregator\n    } = this.state;\n    switch (id) {\n      case 'positions':\n        aggregator.setNeedsUpdate();\n        this._updateBinOptions();\n        const {\n          radiusCommon,\n          hexOriginCommon,\n          binIdRange\n        } = this.state;\n        aggregator.setProps({\n          // @ts-expect-error only used by GPUAggregator\n          binIdRange,\n          binOptions: {\n            radiusCommon,\n            hexOriginCommon\n          }\n        });\n        break;\n      case 'colorWeights':\n        aggregator.setNeedsUpdate(0);\n        break;\n      case 'elevationWeights':\n        aggregator.setNeedsUpdate(1);\n        break;\n      default:\n      // This should not happen\n    }\n  }\n  renderLayers() {\n    const {\n      aggregator,\n      radiusCommon,\n      hexOriginCommon\n    } = this.state;\n    const {\n      elevationScale,\n      colorRange,\n      elevationRange,\n      extruded,\n      coverage,\n      material,\n      transitions,\n      colorScaleType,\n      lowerPercentile,\n      upperPercentile,\n      colorDomain,\n      elevationScaleType,\n      elevationLowerPercentile,\n      elevationUpperPercentile,\n      elevationDomain\n    } = this.props;\n    const CellLayerClass = this.getSubLayerClass('cells', HexagonCellLayer);\n    const binAttribute = aggregator.getBins();\n    const colors = this.state.colors?.update({\n      scaleType: colorScaleType,\n      lowerPercentile,\n      upperPercentile\n    });\n    const elevations = this.state.elevations?.update({\n      scaleType: elevationScaleType,\n      lowerPercentile: elevationLowerPercentile,\n      upperPercentile: elevationUpperPercentile\n    });\n    if (!colors || !elevations) {\n      return null;\n    }\n    return new CellLayerClass(this.getSubLayerProps({\n      id: 'cells'\n    }), {\n      data: {\n        length: aggregator.binCount,\n        attributes: {\n          getBin: binAttribute,\n          getColorValue: colors.attribute,\n          getElevationValue: elevations.attribute\n        }\n      },\n      // Data has changed shallowly, but we likely don't need to update the attributes\n      dataComparator: (data, oldData) => data.length === oldData.length,\n      updateTriggers: {\n        getBin: [binAttribute],\n        getColorValue: [colors.attribute],\n        getElevationValue: [elevations.attribute]\n      },\n      diskResolution: 6,\n      vertices: HexbinVertices,\n      radius: radiusCommon,\n      hexOriginCommon,\n      elevationScale,\n      colorRange,\n      colorScaleType,\n      elevationRange,\n      extruded,\n      coverage,\n      material,\n      colorDomain: colors.domain || colorDomain || aggregator.getResultDomain(0),\n      elevationDomain: elevations.domain || elevationDomain || aggregator.getResultDomain(1),\n      colorCutoff: colors.cutoff,\n      elevationCutoff: elevations.cutoff,\n      transitions: transitions && {\n        getFillColor: transitions.getColorValue || transitions.getColorWeight,\n        getElevation: transitions.getElevationValue || transitions.getElevationWeight\n      },\n      // Extensions are already handled by the GPUAggregator, do not pass it down\n      extensions: []\n    });\n  }\n  getPickingInfo(params) {\n    const info = params.info;\n    const {\n      index\n    } = info;\n    if (index >= 0) {\n      const bin = this.state.aggregator.getBin(index);\n      let object;\n      if (bin) {\n        const centroidCommon = getHexbinCentroid(bin.id, this.state.radiusCommon);\n        const centroid = this.context.viewport.unprojectFlat(centroidCommon);\n        object = {\n          col: bin.id[0],\n          row: bin.id[1],\n          position: centroid,\n          colorValue: bin.value[0],\n          elevationValue: bin.value[1],\n          count: bin.count\n        };\n        if (bin.pointIndices) {\n          object.pointIndices = bin.pointIndices;\n          object.points = Array.isArray(this.props.data) ? bin.pointIndices.map(i => this.props.data[i]) : [];\n        }\n      }\n      info.object = object;\n    }\n    return info;\n  }\n}\nHexagonLayer.layerName = 'HexagonLayer';\nHexagonLayer.defaultProps = defaultProps;\nexport default HexagonLayer;","map":{"version":3,"names":["log","createIterable","project32","Viewport","WebGLAggregator","CPUAggregator","AggregationLayer","defaultColorRange","AttributeWithScale","getBinIdRange","HexagonCellLayer","pointToHexbin","HexbinVertices","getHexbinCentroid","pointToHexbinGLSL","binOptionsUniforms","noop","defaultProps","gpuAggregation","colorDomain","colorRange","getColorValue","type","value","getColorWeight","colorAggregation","lowerPercentile","min","max","upperPercentile","colorScaleType","onSetColorDomain","elevationDomain","elevationRange","getElevationValue","getElevationWeight","elevationAggregation","elevationScale","elevationLowerPercentile","elevationUpperPercentile","elevationScaleType","onSetElevationDomain","radius","coverage","getPosition","x","position","hexagonAggregator","optional","extruded","material","HexagonLayer","getAggregatorType","props","warn","isSupported","context","device","createAggregator","dimensions","getBin","sources","getValue","positions","index","opts","viewport","state","aggregatorViewport","p","projectPosition","radiusCommon","hexOriginCommon","colorWeights","elevationWeights","channelCount","bufferLayout","getAttributeManager","getBufferLayouts","isInstanced","getShaders","modules","vs","initializeState","attributeManager","add","size","accessor","fp64","use64bitPositions","updateState","params","aggregatorChanged","oldProps","changeFlags","aggregator","dataChanged","dataAsArray","Array","from","data","iterable","_updateBinOptions","binIdRange","setProps","pointCount","getNumInstances","operations","binOptions","onUpdate","_onAggregationUpdate","bind","customOperations","indices","map","i","updateTriggersChanged","setNeedsUpdate","bounds","getBounds","Number","isFinite","centroid","unitsPerMeter","getDistanceScales","centerHex","projectFlat","unprojectFlat","ViewportType","constructor","isGeospatial","longitude","latitude","zoom","Math","fround","center","dataBounds","getBinId","positionCommon","padding","setState","draw","shaderModuleProps","project","channel","getCurrentLayer","result","getResult","colors","binCount","getResultDomain","elevations","onAttributeChange","id","renderLayers","transitions","CellLayerClass","getSubLayerClass","binAttribute","getBins","update","scaleType","getSubLayerProps","length","attributes","attribute","dataComparator","oldData","updateTriggers","diskResolution","vertices","domain","colorCutoff","cutoff","elevationCutoff","getFillColor","getElevation","extensions","getPickingInfo","info","bin","object","centroidCommon","col","row","colorValue","elevationValue","count","pointIndices","points","isArray","layerName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\aggregation-layers\\src\\hexagon-layer\\hexagon-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  log,\n  Accessor,\n  Color,\n  GetPickingInfoParams,\n  CompositeLayerProps,\n  createIterable,\n  Layer,\n  Material,\n  project32,\n  LayersList,\n  PickingInfo,\n  Position,\n  Viewport,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport {WebGLAggregator, CPUAggregator, AggregationOperation} from '../common/aggregator/index';\nimport AggregationLayer from '../common/aggregation-layer';\nimport {AggregateAccessor} from '../common/types';\nimport {defaultColorRange} from '../common/utils/color-utils';\nimport {AttributeWithScale} from '../common/utils/scale-utils';\nimport {getBinIdRange} from '../common/utils/bounds-utils';\n\nimport HexagonCellLayer from './hexagon-cell-layer';\nimport {pointToHexbin, HexbinVertices, getHexbinCentroid, pointToHexbinGLSL} from './hexbin';\nimport {BinOptions, binOptionsUniforms} from './bin-options-uniforms';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n\nconst defaultProps: DefaultProps<HexagonLayerProps> = {\n  gpuAggregation: true,\n\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorValue: {type: 'accessor', value: null}, // default value is calculated from `getColorWeight` and `colorAggregation`\n  getColorWeight: {type: 'accessor', value: 1},\n  colorAggregation: 'SUM',\n  lowerPercentile: {type: 'number', min: 0, max: 100, value: 0},\n  upperPercentile: {type: 'number', min: 0, max: 100, value: 100},\n  colorScaleType: 'quantize',\n  onSetColorDomain: noop,\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationValue: {type: 'accessor', value: null}, // default value is calculated from `getElevationWeight` and `elevationAggregation`\n  getElevationWeight: {type: 'accessor', value: 1},\n  elevationAggregation: 'SUM',\n  elevationScale: {type: 'number', min: 0, value: 1},\n  elevationLowerPercentile: {type: 'number', min: 0, max: 100, value: 0},\n  elevationUpperPercentile: {type: 'number', min: 0, max: 100, value: 100},\n  elevationScaleType: 'linear',\n  onSetElevationDomain: noop,\n\n  // hexbin\n  radius: {type: 'number', min: 1, value: 1000},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\n  hexagonAggregator: {type: 'function', optional: true, value: null},\n  extruded: false,\n\n  // Optional material for 'lighting' shader module\n  material: true\n};\n\n/** All properties supported by HexagonLayer. */\nexport type HexagonLayerProps<DataT = unknown> = _HexagonLayerProps<DataT> & CompositeLayerProps;\n\n/** Properties added by HexagonLayer. */\ntype _HexagonLayerProps<DataT> = {\n  /**\n   * Radius of hexagon bin in meters. The hexagons are pointy-topped (rather than flat-topped).\n   * @default 1000\n   */\n  radius?: number;\n\n  /**\n   * Custom accessor to retrieve a hexagonal bin index from each data object.\n   * Not supported by GPU aggregation.\n   * @default null\n   */\n  hexagonAggregator?: ((position: number[], radius: number) => [number, number]) | null;\n\n  /**\n   * Color scale domain, default is set to the extent of aggregated weights in each cell.\n   * @default [min(colorWeight), max(colorWeight)]\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Default: [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6) `6-class YlOrRd`\n   */\n  colorRange?: Color[];\n\n  /**\n   * Cell size multiplier, clamped between 0 - 1.\n   * @default 1\n   */\n  coverage?: number;\n\n  /**\n   * Elevation scale input domain, default is set to between 0 and the max of aggregated weights in each cell.\n   * @default [0, max(elevationWeight)]\n   */\n  elevationDomain?: [number, number] | null;\n\n  /**\n   * Elevation scale output range.\n   * @default [0, 1000]\n   */\n  elevationRange?: [number, number];\n\n  /**\n   * Cell elevation multiplier.\n   * @default 1\n   */\n  elevationScale?: number;\n\n  /**\n   * Whether to enable cell elevation. If set to false, all cell will be flat.\n   * @default true\n   */\n  extruded?: boolean;\n\n  /**\n   * Filter cells and re-calculate color by `upperPercentile`.\n   * Cells with value larger than the upperPercentile will be hidden.\n   * @default 100\n   */\n  upperPercentile?: number;\n\n  /**\n   * Filter cells and re-calculate color by `lowerPercentile`.\n   * Cells with value smaller than the lowerPercentile will be hidden.\n   * @default 0\n   */\n  lowerPercentile?: number;\n\n  /**\n   * Filter cells and re-calculate elevation by `elevationUpperPercentile`.\n   * Cells with elevation value larger than the `elevationUpperPercentile` will be hidden.\n   * @default 100\n   */\n  elevationUpperPercentile?: number;\n\n  /**\n   * Filter cells and re-calculate elevation by `elevationLowerPercentile`.\n   * Cells with elevation value larger than the `elevationLowerPercentile` will be hidden.\n   * @default 0\n   */\n  elevationLowerPercentile?: number;\n\n  /**\n   * Scaling function used to determine the color of the grid cell, default value is 'quantize'.\n   * Supported Values are 'quantize', 'linear', 'quantile' and 'ordinal'.\n   * @default 'quantize'\n   */\n  colorScaleType?: 'quantize' | 'linear' | 'quantile' | 'ordinal';\n\n  /**\n   * Scaling function used to determine the elevation of the grid cell, only supports 'linear'.\n   * Supported Values are 'linear' and 'quantile'.\n   * @default 'linear'\n   */\n  elevationScaleType?: 'linear';\n\n  /**\n   * Material settings for lighting effect. Applies if `extruded: true`.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's color value.\n   * Valid values are 'SUM', 'MEAN', 'MIN', 'MAX', 'COUNT'.\n   *\n   * @default 'SUM'\n   */\n  colorAggregation?: AggregationOperation;\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's elevation value.\n   * Valid values are 'SUM', 'MEAN', 'MIN', 'MAX', 'COUNT'.\n   *\n   * @default 'SUM'\n   */\n  elevationAggregation?: AggregationOperation;\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: Accessor<DataT, Position>;\n\n  /**\n   * The weight of a data object used to calculate the color value for a cell.\n   * @default 1\n   */\n  getColorWeight?: Accessor<DataT, number>;\n\n  /**\n   * After data objects are aggregated into cells, this accessor is called on each cell to get the value that its color is based on.\n   * Not supported by GPU aggregation.\n   * @default null\n   */\n  getColorValue?: AggregateAccessor<DataT> | null;\n\n  /**\n   * The weight of a data object used to calculate the elevation value for a cell.\n   * @default 1\n   */\n  getElevationWeight?: Accessor<DataT, number>;\n\n  /**\n   * After data objects are aggregated into cells, this accessor is called on each cell to get the value that its elevation is based on.\n   * Not supported by GPU aggregation.\n   * @default null\n   */\n  getElevationValue?: AggregateAccessor<DataT> | null;\n\n  /**\n   * This callback will be called when bin color domain has been calculated.\n   * @default () => {}\n   */\n  onSetColorDomain?: (minMax: [number, number]) => void;\n\n  /**\n   * This callback will be called when bin elevation domain has been calculated.\n   * @default () => {}\n   */\n  onSetElevationDomain?: (minMax: [number, number]) => void;\n\n  /**\n   * When set to true, aggregation is performed on GPU, provided other conditions are met.\n   * @default true\n   */\n  gpuAggregation?: boolean;\n};\n\nexport type HexagonLayerPickingInfo<DataT> = PickingInfo<{\n  /** Column index of the picked cell */\n  col: number;\n  /** Row index of the picked cell */\n  row: number;\n  /** Aggregated color value, as determined by `getColorWeight` and `colorAggregation` */\n  colorValue: number;\n  /** Aggregated elevation value, as determined by `getElevationWeight` and `elevationAggregation` */\n  elevationValue: number;\n  /** Number of data points in the picked cell */\n  count: number;\n  /** Centroid of the hexagon */\n  position: [number, number];\n  /** Indices of the data objects in the picked cell. Only available if using CPU aggregation. */\n  pointIndices?: number[];\n  /** The data objects in the picked cell. Only available if using CPU aggregation and layer data is an array. */\n  points?: DataT[];\n}>;\n\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\nexport default class HexagonLayer<\n  DataT = any,\n  ExtraPropsT extends {} = {}\n> extends AggregationLayer<DataT, ExtraPropsT & Required<_HexagonLayerProps<DataT>>> {\n  static layerName = 'HexagonLayer';\n  static defaultProps = defaultProps;\n\n  state!: AggregationLayer<DataT>['state'] &\n    BinOptions & {\n      // Needed if getColorValue, getElevationValue are used\n      dataAsArray?: DataT[];\n\n      colors?: AttributeWithScale;\n      elevations?: AttributeWithScale;\n\n      binIdRange: [number, number][];\n      aggregatorViewport: Viewport;\n    };\n\n  getAggregatorType(): string {\n    const {gpuAggregation, hexagonAggregator, getColorValue, getElevationValue} = this.props;\n    if (gpuAggregation && (hexagonAggregator || getColorValue || getElevationValue)) {\n      // If these features are desired by the app, the user should explicitly use CPU aggregation\n      log.warn('Features not supported by GPU aggregation, falling back to CPU')();\n      return 'cpu';\n    }\n\n    if (\n      // GPU aggregation is requested\n      gpuAggregation &&\n      // GPU aggregation is supported by the device\n      WebGLAggregator.isSupported(this.context.device)\n    ) {\n      return 'gpu';\n    }\n    return 'cpu';\n  }\n\n  createAggregator(type: string): WebGLAggregator | CPUAggregator {\n    if (type === 'cpu') {\n      const {hexagonAggregator, radius} = this.props;\n      return new CPUAggregator({\n        dimensions: 2,\n        getBin: {\n          sources: ['positions'],\n          getValue: ({positions}: {positions: number[]}, index: number, opts: BinOptions) => {\n            if (hexagonAggregator) {\n              return hexagonAggregator(positions, radius);\n            }\n            const viewport = this.state.aggregatorViewport;\n            // project to common space\n            const p = viewport.projectPosition(positions);\n            const {radiusCommon, hexOriginCommon} = opts;\n            return pointToHexbin(\n              [p[0] - hexOriginCommon[0], p[1] - hexOriginCommon[1]],\n              radiusCommon\n            );\n          }\n        },\n        getValue: [\n          {sources: ['colorWeights'], getValue: ({colorWeights}) => colorWeights},\n          {sources: ['elevationWeights'], getValue: ({elevationWeights}) => elevationWeights}\n        ]\n      });\n    }\n    return new WebGLAggregator(this.context.device, {\n      dimensions: 2,\n      channelCount: 2,\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts({isInstanced: false}),\n      ...super.getShaders({\n        modules: [project32, binOptionsUniforms],\n        vs: /* glsl */ `\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float colorWeights;\n  in float elevationWeights;\n  \n  ${pointToHexbinGLSL}\n\n  void getBin(out ivec2 binId) {\n    vec3 positionCommon = project_position(positions, positions64Low);\n    binId = pointToHexbin(positionCommon.xy, binOptions.radiusCommon);\n  }\n  void getValue(out vec2 value) {\n    value = vec2(colorWeights, elevationWeights);\n  }\n  `\n      })\n    });\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      positions: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 'float64',\n        fp64: this.use64bitPositions()\n      },\n      colorWeights: {size: 1, accessor: 'getColorWeight'},\n      elevationWeights: {size: 1, accessor: 'getElevationWeight'}\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    const aggregatorChanged = super.updateState(params);\n\n    const {props, oldProps, changeFlags} = params;\n    const {aggregator} = this.state;\n    if (\n      (changeFlags.dataChanged || !this.state.dataAsArray) &&\n      (props.getColorValue || props.getElevationValue)\n    ) {\n      // Convert data to array\n      this.state.dataAsArray = Array.from(createIterable(props.data).iterable);\n    }\n    if (\n      aggregatorChanged ||\n      changeFlags.dataChanged ||\n      props.radius !== oldProps.radius ||\n      props.getColorValue !== oldProps.getColorValue ||\n      props.getElevationValue !== oldProps.getElevationValue ||\n      props.colorAggregation !== oldProps.colorAggregation ||\n      props.elevationAggregation !== oldProps.elevationAggregation\n    ) {\n      this._updateBinOptions();\n      const {radiusCommon, hexOriginCommon, binIdRange, dataAsArray} = this.state;\n\n      aggregator.setProps({\n        // @ts-expect-error only used by GPUAggregator\n        binIdRange,\n        pointCount: this.getNumInstances(),\n        operations: [props.colorAggregation, props.elevationAggregation],\n        binOptions: {\n          radiusCommon,\n          hexOriginCommon\n        },\n        onUpdate: this._onAggregationUpdate.bind(this)\n      });\n\n      if (dataAsArray) {\n        const {getColorValue, getElevationValue} = this.props;\n        aggregator.setProps({\n          // @ts-expect-error only used by CPUAggregator\n          customOperations: [\n            getColorValue &&\n              ((indices: number[]) =>\n                getColorValue(\n                  indices.map(i => dataAsArray[i]),\n                  {indices, data: props.data}\n                )),\n            getElevationValue &&\n              ((indices: number[]) =>\n                getElevationValue(\n                  indices.map(i => dataAsArray[i]),\n                  {indices, data: props.data}\n                ))\n          ]\n        });\n      }\n    }\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getColorValue) {\n      aggregator.setNeedsUpdate(0);\n    }\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getElevationValue) {\n      aggregator.setNeedsUpdate(1);\n    }\n\n    return aggregatorChanged;\n  }\n\n  private _updateBinOptions() {\n    const bounds = this.getBounds();\n    let radiusCommon = 1;\n    let hexOriginCommon: [number, number] = [0, 0];\n    let binIdRange: [number, number][] = [\n      [0, 1],\n      [0, 1]\n    ];\n    let viewport = this.context.viewport;\n\n    if (bounds && Number.isFinite(bounds[0][0])) {\n      let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];\n      const {radius} = this.props;\n      const {unitsPerMeter} = viewport.getDistanceScales(centroid);\n      radiusCommon = unitsPerMeter[0] * radius;\n\n      // Use the centroid of the hex at the center of the data\n      // This offsets the common space without changing the bins\n      const centerHex = pointToHexbin(viewport.projectFlat(centroid), radiusCommon);\n      centroid = viewport.unprojectFlat(getHexbinCentroid(centerHex, radiusCommon));\n\n      const ViewportType = viewport.constructor as any;\n      // We construct a viewport for the GPU aggregator's project module\n      // This viewport is determined by data\n      // removes arbitrary precision variance that depends on initial view state\n      viewport = viewport.isGeospatial\n        ? new ViewportType({longitude: centroid[0], latitude: centroid[1], zoom: 12})\n        : new Viewport({position: [centroid[0], centroid[1], 0], zoom: 12});\n\n      hexOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];\n\n      binIdRange = getBinIdRange({\n        dataBounds: bounds,\n        getBinId: (p: number[]) => {\n          const positionCommon = viewport.projectFlat(p);\n          positionCommon[0] -= hexOriginCommon[0];\n          positionCommon[1] -= hexOriginCommon[1];\n          return pointToHexbin(positionCommon, radiusCommon);\n        },\n        padding: 1\n      });\n    }\n\n    this.setState({radiusCommon, hexOriginCommon, binIdRange, aggregatorViewport: viewport});\n  }\n\n  override draw(opts) {\n    // Replaces render time viewport with our own\n    if (opts.shaderModuleProps.project) {\n      opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;\n    }\n    super.draw(opts);\n  }\n\n  private _onAggregationUpdate({channel}: {channel: number}) {\n    const props = this.getCurrentLayer()!.props;\n    const {aggregator} = this.state;\n    if (channel === 0) {\n      const result = aggregator.getResult(0)!;\n      this.setState({\n        colors: new AttributeWithScale(result, aggregator.binCount)\n      });\n      props.onSetColorDomain(aggregator.getResultDomain(0));\n    } else if (channel === 1) {\n      const result = aggregator.getResult(1)!;\n      this.setState({\n        elevations: new AttributeWithScale(result, aggregator.binCount)\n      });\n      props.onSetElevationDomain(aggregator.getResultDomain(1));\n    }\n  }\n\n  onAttributeChange(id: string) {\n    const {aggregator} = this.state;\n    switch (id) {\n      case 'positions':\n        aggregator.setNeedsUpdate();\n\n        this._updateBinOptions();\n        const {radiusCommon, hexOriginCommon, binIdRange} = this.state;\n        aggregator.setProps({\n          // @ts-expect-error only used by GPUAggregator\n          binIdRange,\n          binOptions: {\n            radiusCommon,\n            hexOriginCommon\n          }\n        });\n        break;\n\n      case 'colorWeights':\n        aggregator.setNeedsUpdate(0);\n        break;\n\n      case 'elevationWeights':\n        aggregator.setNeedsUpdate(1);\n        break;\n\n      default:\n      // This should not happen\n    }\n  }\n\n  renderLayers(): LayersList | Layer | null {\n    const {aggregator, radiusCommon, hexOriginCommon} = this.state;\n    const {\n      elevationScale,\n      colorRange,\n      elevationRange,\n      extruded,\n      coverage,\n      material,\n      transitions,\n      colorScaleType,\n      lowerPercentile,\n      upperPercentile,\n      colorDomain,\n      elevationScaleType,\n      elevationLowerPercentile,\n      elevationUpperPercentile,\n      elevationDomain\n    } = this.props;\n    const CellLayerClass = this.getSubLayerClass('cells', HexagonCellLayer);\n    const binAttribute = aggregator.getBins();\n\n    const colors = this.state.colors?.update({\n      scaleType: colorScaleType,\n      lowerPercentile,\n      upperPercentile\n    });\n    const elevations = this.state.elevations?.update({\n      scaleType: elevationScaleType,\n      lowerPercentile: elevationLowerPercentile,\n      upperPercentile: elevationUpperPercentile\n    });\n\n    if (!colors || !elevations) {\n      return null;\n    }\n\n    return new CellLayerClass(\n      this.getSubLayerProps({\n        id: 'cells'\n      }),\n      {\n        data: {\n          length: aggregator.binCount,\n          attributes: {\n            getBin: binAttribute,\n            getColorValue: colors.attribute,\n            getElevationValue: elevations.attribute\n          }\n        },\n        // Data has changed shallowly, but we likely don't need to update the attributes\n        dataComparator: (data, oldData) => data.length === oldData.length,\n        updateTriggers: {\n          getBin: [binAttribute],\n          getColorValue: [colors.attribute],\n          getElevationValue: [elevations.attribute]\n        },\n        diskResolution: 6,\n        vertices: HexbinVertices,\n        radius: radiusCommon,\n        hexOriginCommon,\n        elevationScale,\n        colorRange,\n        colorScaleType,\n        elevationRange,\n        extruded,\n        coverage,\n        material,\n        colorDomain: colors.domain || colorDomain || aggregator.getResultDomain(0),\n        elevationDomain: elevations.domain || elevationDomain || aggregator.getResultDomain(1),\n        colorCutoff: colors.cutoff,\n        elevationCutoff: elevations.cutoff,\n        transitions: transitions && {\n          getFillColor: transitions.getColorValue || transitions.getColorWeight,\n          getElevation: transitions.getElevationValue || transitions.getElevationWeight\n        },\n        // Extensions are already handled by the GPUAggregator, do not pass it down\n        extensions: []\n      }\n    );\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): HexagonLayerPickingInfo<DataT> {\n    const info: HexagonLayerPickingInfo<DataT> = params.info;\n    const {index} = info;\n    if (index >= 0) {\n      const bin = this.state.aggregator.getBin(index);\n      let object: HexagonLayerPickingInfo<DataT>['object'];\n      if (bin) {\n        const centroidCommon = getHexbinCentroid(\n          bin.id as [number, number],\n          this.state.radiusCommon\n        );\n        const centroid = this.context.viewport.unprojectFlat(centroidCommon);\n\n        object = {\n          col: bin.id[0],\n          row: bin.id[1],\n          position: centroid,\n          colorValue: bin.value[0],\n          elevationValue: bin.value[1],\n          count: bin.count\n        };\n        if (bin.pointIndices) {\n          object.pointIndices = bin.pointIndices;\n          object.points = Array.isArray(this.props.data)\n            ? bin.pointIndices.map(i => (this.props.data as DataT[])[i])\n            : [];\n        }\n      }\n      info.object = object;\n    }\n\n    return info;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}