{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n/* eslint-disable */\nimport { Vector3, equals, assert } from '@math.gl/core';\nconst scratchPosition = new Vector3();\nconst scratchNormal = new Vector3();\n// A plane in Hessian Normal Form\nexport class Plane {\n  constructor(normal = [0, 0, 1], distance = 0) {\n    this.normal = new Vector3();\n    this.distance = -0;\n    this.fromNormalDistance(normal, distance);\n  }\n  /** Creates a plane from a normal and a distance from the origin. */\n  fromNormalDistance(normal, distance) {\n    assert(Number.isFinite(distance));\n    this.normal.from(normal).normalize();\n    this.distance = distance;\n    return this;\n  }\n  /** Creates a plane from a normal and a point on the plane. */\n  fromPointNormal(point, normal) {\n    point = scratchPosition.from(point);\n    this.normal.from(normal).normalize();\n    const distance = -this.normal.dot(point);\n    this.distance = distance;\n    return this;\n  }\n  /** Creates a plane from the general equation */\n  fromCoefficients(a, b, c, d) {\n    this.normal.set(a, b, c);\n    assert(equals(this.normal.len(), 1));\n    this.distance = d;\n    return this;\n  }\n  /** Duplicates a Plane instance. */\n  clone() {\n    return new Plane(this.normal, this.distance);\n  }\n  /** Compares the provided Planes by normal and distance */\n  equals(right) {\n    return equals(this.distance, right.distance) && equals(this.normal, right.normal);\n  }\n  /** Computes the signed shortest distance of a point to a plane.\n   * The sign of the distance determines which side of the plane the point is on.\n   */\n  getPointDistance(point) {\n    return this.normal.dot(point) + this.distance;\n  }\n  /** Transforms the plane by the given transformation matrix. */\n  transform(matrix4) {\n    const normal = scratchNormal.copy(this.normal).transformAsVector(matrix4).normalize();\n    const point = this.normal.scale(-this.distance).transform(matrix4);\n    return this.fromPointNormal(point, normal);\n  }\n  projectPointOntoPlane(point, result = [0, 0, 0]) {\n    const scratchPoint = scratchPosition.from(point);\n    // projectedPoint = point - (normal.point + scale) * normal\n    const pointDistance = this.getPointDistance(scratchPoint);\n    const scaledNormal = scratchNormal.copy(this.normal).scale(pointDistance);\n    return scratchPoint.subtract(scaledNormal).to(result);\n  }\n}","map":{"version":3,"names":["Vector3","equals","assert","scratchPosition","scratchNormal","Plane","constructor","normal","distance","fromNormalDistance","Number","isFinite","from","normalize","fromPointNormal","point","dot","fromCoefficients","a","b","c","d","set","len","clone","right","getPointDistance","transform","matrix4","copy","transformAsVector","scale","projectPointOntoPlane","result","scratchPoint","pointDistance","scaledNormal","subtract","to"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\culling\\src\\lib\\plane.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, equals, assert, NumericArray} from '@math.gl/core';\n\nconst scratchPosition = new Vector3();\nconst scratchNormal = new Vector3();\n\n// A plane in Hessian Normal Form\nexport class Plane {\n  readonly normal: Vector3;\n  distance: number;\n\n  constructor(normal: Readonly<NumericArray> = [0, 0, 1], distance: number = 0) {\n    this.normal = new Vector3();\n    this.distance = -0;\n    this.fromNormalDistance(normal, distance);\n  }\n\n  /** Creates a plane from a normal and a distance from the origin. */\n  fromNormalDistance(normal: Readonly<NumericArray>, distance: number): this {\n    assert(Number.isFinite(distance));\n    this.normal.from(normal).normalize();\n    this.distance = distance;\n    return this;\n  }\n\n  /** Creates a plane from a normal and a point on the plane. */\n  fromPointNormal(point: Readonly<NumericArray>, normal: Readonly<NumericArray>): this {\n    point = scratchPosition.from(point);\n    this.normal.from(normal).normalize();\n    const distance = -this.normal.dot(point);\n    this.distance = distance;\n    return this;\n  }\n\n  /** Creates a plane from the general equation */\n  fromCoefficients(a: number, b: number, c: number, d: number): this {\n    this.normal.set(a, b, c);\n    assert(equals(this.normal.len(), 1));\n    this.distance = d;\n    return this;\n  }\n\n  /** Duplicates a Plane instance. */\n  clone(): Plane {\n    return new Plane(this.normal, this.distance);\n  }\n\n  /** Compares the provided Planes by normal and distance */\n  equals(right: Plane): boolean {\n    return equals(this.distance, right.distance) && equals(this.normal, right.normal);\n  }\n\n  /** Computes the signed shortest distance of a point to a plane.\n   * The sign of the distance determines which side of the plane the point is on.\n   */\n  getPointDistance(point: Readonly<NumericArray>): number {\n    return this.normal.dot(point) + this.distance;\n  }\n\n  /** Transforms the plane by the given transformation matrix. */\n  transform(matrix4: Readonly<NumericArray>): this {\n    const normal = scratchNormal.copy(this.normal).transformAsVector(matrix4).normalize();\n    const point = this.normal.scale(-this.distance).transform(matrix4);\n    return this.fromPointNormal(point, normal);\n  }\n\n  /** Projects a point onto the plane. */\n  projectPointOntoPlane(point: Readonly<NumericArray>, result: Vector3): Vector3;\n  projectPointOntoPlane(\n    point: Readonly<NumericArray>,\n    result?: readonly number[]\n  ): readonly number[];\n\n  projectPointOntoPlane(point: Readonly<NumericArray>, result = [0, 0, 0]) {\n    const scratchPoint = scratchPosition.from(point);\n    // projectedPoint = point - (normal.point + scale) * normal\n    const pointDistance = this.getPointDistance(scratchPoint);\n    const scaledNormal = scratchNormal.copy(this.normal).scale(pointDistance);\n\n    return scratchPoint.subtract(scaledNormal).to(result);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}