{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT and ISC\n// Copyright (c) vis.gl contributors\n/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\nimport { equals } from '@math.gl/core';\nexport const WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n};\n/**\n * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n * Note: points are modified in-place.\n * @param points An array that represents points of the polygon.\n * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n * @param options Parameters of the polygon.\n * @return Returns true if the winding direction was changed.\n */\nexport function modifyPolygonWindingDirection(points, direction, options = {}) {\n  const windingDirection = getPolygonWindingDirection(points, options);\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n  return false;\n}\n/**\n * Returns winding direction of the polygon.\n * @param points An array that represents points of the polygon.\n * @param options Parameters of the polygon.\n * @returns Winding direction of the polygon.\n */\nexport function getPolygonWindingDirection(points, options = {}) {\n  return Math.sign(getPolygonSignedArea(points, options));\n}\nexport const DimIndex = {\n  x: 0,\n  y: 1,\n  z: 2\n};\n/**\n * Returns signed area of the polygon.\n * @param points An array that represents points of the polygon.\n * @param options Parameters of the polygon.\n * @returns Signed area of the polygon.\n * https://en.wikipedia.org/wiki/Shoelace_formula\n */\nexport function getPolygonSignedArea(points, options = {}) {\n  const {\n    start = 0,\n    end = points.length,\n    plane = 'xy'\n  } = options;\n  const dim = options.size || 2;\n  let area = 0;\n  const i0 = DimIndex[plane[0]];\n  const i1 = DimIndex[plane[1]];\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    area += (points[i + i0] - points[j + i0]) * (points[i + i1] + points[j + i1]);\n    j = i;\n  }\n  return area / 2;\n}\n/**\n * Calls the visitor callback for each segment in the polygon.\n * @param points An array that represents points of the polygon\n * @param visitor A callback to call for each segment.\n * @param options Parameters of the polygon.\n */\nexport function forEachSegmentInPolygon(points, visitor, options = {}) {\n  const {\n    start = 0,\n    end = points.length,\n    size = 2,\n    isClosed\n  } = options;\n  const numPoints = (end - start) / size;\n  for (let i = 0; i < numPoints - 1; ++i) {\n    visitor(points[start + i * size], points[start + i * size + 1], points[start + (i + 1) * size], points[start + (i + 1) * size + 1], i, i + 1);\n  }\n  const endPointIndex = start + (numPoints - 1) * size;\n  const isClosedEx = isClosed || equals(points[start], points[endPointIndex]) && equals(points[start + 1], points[endPointIndex + 1]);\n  if (!isClosedEx) {\n    visitor(points[endPointIndex], points[endPointIndex + 1], points[start], points[start + 1], numPoints - 1, 0);\n  }\n}\nfunction reversePolygon(points, options) {\n  const {\n    start = 0,\n    end = points.length,\n    size = 2\n  } = options;\n  const numPoints = (end - start) / size;\n  const numSwaps = Math.floor(numPoints / 2);\n  for (let i = 0; i < numSwaps; ++i) {\n    const b1 = start + i * size;\n    const b2 = start + (numPoints - 1 - i) * size;\n    for (let j = 0; j < size; ++j) {\n      const tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n/**\n * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n * Note: points are modified in-place.\n * @param points Array of points that represent the polygon.\n * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n * @param options Parameters of the polygon.\n * @return Returns true if the winding direction was changed.\n */\nexport function modifyPolygonWindingDirectionPoints(points, direction, options = {}) {\n  const currentDirection = getPolygonWindingDirectionPoints(points, options);\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n  return false;\n}\n/**\n * Returns winding direction of the polygon.\n * @param points Array of points that represent the polygon.\n * @param options Parameters of the polygon.\n * @returns Winding direction of the polygon.\n */\nexport function getPolygonWindingDirectionPoints(points, options = {}) {\n  return Math.sign(getPolygonSignedAreaPoints(points, options));\n}\n/**\n * Returns signed area of the polygon.\n * @param points Array of points that represent the polygon.\n * @param options Parameters of the polygon.\n * @returns Signed area of the polygon.\n */\nexport function getPolygonSignedAreaPoints(points, options = {}) {\n  // https://en.wikipedia.org/wiki/Shoelace_formula\n  const {\n    start = 0,\n    end = points.length,\n    plane = 'xy'\n  } = options;\n  let area = 0;\n  const i0 = DimIndex[plane[0]];\n  const i1 = DimIndex[plane[1]];\n  for (let i = start, j = end - 1; i < end; ++i) {\n    area += (points[i][i0] - points[j][i0]) * (points[i][i1] + points[j][i1]);\n    j = i;\n  }\n  return area / 2;\n}\n/**\n * Calls visitor callback for each segment in the polygon.\n * @param points Array of points that represent the polygon.\n * @param visitor A callback to call for each segment.\n * @param options Parameters of the polygon.\n */\nexport function forEachSegmentInPolygonPoints(points, visitor, options = {}) {\n  const {\n    start = 0,\n    end = points.length,\n    isClosed\n  } = options;\n  for (let i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n  const isClosedEx = isClosed || equals(points[end - 1], points[0]);\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}","map":{"version":3,"names":["equals","WINDING","CLOCKWISE","COUNTER_CLOCKWISE","modifyPolygonWindingDirection","points","direction","options","windingDirection","getPolygonWindingDirection","reversePolygon","Math","sign","getPolygonSignedArea","DimIndex","x","y","z","start","end","length","plane","dim","size","area","i0","i1","i","j","forEachSegmentInPolygon","visitor","isClosed","numPoints","endPointIndex","isClosedEx","numSwaps","floor","b1","b2","tmp","modifyPolygonWindingDirectionPoints","currentDirection","getPolygonWindingDirectionPoints","reverse","getPolygonSignedAreaPoints","forEachSegmentInPolygonPoints"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\polygon\\src\\polygon-utils.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT and ISC\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\n\nimport {equals} from '@math.gl/core';\nimport type {NumericArray} from '@math.gl/core';\n\nexport const WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n} as const;\n\n/** Polygon representation where each point is represented as a separate array of positions. */\ntype PointsArray = NumericArray[];\n\n/** Segment visitor callback type for polygons defined with flat arrays, */\ntype SegmentVisitorFlat = (\n  p1x: number,\n  p1y: number,\n  p2x: number,\n  p2y: number,\n  i1: number,\n  i2: number\n) => void;\n\n/** Segment visitor callback type for polygons defined with array of points. */\nexport type SegmentVisitorPoints = (\n  p1: NumericArray,\n  p2: NumericArray,\n  i1: number,\n  i2: number\n) => void;\n\nexport type Plane2D = 'xy' | 'yz' | 'xz';\n\n/** Parameters of a polygon. */\ntype PolygonParams = {\n  /**\n   * Start index of the polygon in the array of positions.\n   * @default `0`\n   */\n  start?: number;\n  /**\n   * End index of the polygon in the array of positions.\n   * @default number of positions\n   */\n  end?: number;\n  /**\n   * Size of a point, 2 (XZ) or 3 (XYZ). Affects only polygons stored in flat arrays.\n   * @default `2`\n   */\n  size?: number;\n  /**\n   * Indicates that the first point of the polygon is equal to the last point, and additional checks should be ommited.\n   */\n  isClosed?: boolean;\n  /**\n   * The 2D projection plane on which to calculate the area of a 3D polygon.\n   * @default `'xy'`\n   */\n  plane?: Plane2D;\n};\n\n/**\n * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n * Note: points are modified in-place.\n * @param points An array that represents points of the polygon.\n * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n * @param options Parameters of the polygon.\n * @return Returns true if the winding direction was changed.\n */\nexport function modifyPolygonWindingDirection(\n  points: NumericArray,\n  direction: number,\n  options: PolygonParams = {}\n): boolean {\n  const windingDirection = getPolygonWindingDirection(points, options);\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns winding direction of the polygon.\n * @param points An array that represents points of the polygon.\n * @param options Parameters of the polygon.\n * @returns Winding direction of the polygon.\n */\nexport function getPolygonWindingDirection(\n  points: NumericArray,\n  options: PolygonParams = {}\n): number {\n  return Math.sign(getPolygonSignedArea(points, options));\n}\n\nexport const DimIndex: Record<string, number> = {\n  x: 0,\n  y: 1,\n  z: 2\n} as const;\n\n/**\n * Returns signed area of the polygon.\n * @param points An array that represents points of the polygon.\n * @param options Parameters of the polygon.\n * @returns Signed area of the polygon.\n * https://en.wikipedia.org/wiki/Shoelace_formula\n */\nexport function getPolygonSignedArea(points: NumericArray, options: PolygonParams = {}): number {\n  const {start = 0, end = points.length, plane = 'xy'} = options;\n  const dim = options.size || 2;\n  let area = 0;\n  const i0 = DimIndex[plane[0]];\n  const i1 = DimIndex[plane[1]];\n\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    area += (points[i + i0] - points[j + i0]) * (points[i + i1] + points[j + i1]);\n    j = i;\n  }\n  return area / 2;\n}\n\n/**\n * Calls the visitor callback for each segment in the polygon.\n * @param points An array that represents points of the polygon\n * @param visitor A callback to call for each segment.\n * @param options Parameters of the polygon.\n */\nexport function forEachSegmentInPolygon(\n  points: NumericArray,\n  visitor: SegmentVisitorFlat,\n  options: PolygonParams = {}\n): void {\n  const {start = 0, end = points.length, size = 2, isClosed} = options;\n\n  const numPoints = (end - start) / size;\n  for (let i = 0; i < numPoints - 1; ++i) {\n    visitor(\n      points[start + i * size],\n      points[start + i * size + 1],\n      points[start + (i + 1) * size],\n      points[start + (i + 1) * size + 1],\n      i,\n      i + 1\n    );\n  }\n\n  const endPointIndex = start + (numPoints - 1) * size;\n  const isClosedEx =\n    isClosed ||\n    (equals(points[start], points[endPointIndex]) &&\n      equals(points[start + 1], points[endPointIndex + 1]));\n\n  if (!isClosedEx) {\n    visitor(\n      points[endPointIndex],\n      points[endPointIndex + 1],\n      points[start],\n      points[start + 1],\n      numPoints - 1,\n      0\n    );\n  }\n}\n\nfunction reversePolygon(\n  points: NumericArray,\n  options: {start?: number; end?: number; size?: number}\n): void {\n  const {start = 0, end = points.length, size = 2} = options;\n\n  const numPoints = (end - start) / size;\n  const numSwaps = Math.floor(numPoints / 2);\n  for (let i = 0; i < numSwaps; ++i) {\n    const b1 = start + i * size;\n    const b2 = start + (numPoints - 1 - i) * size;\n    for (let j = 0; j < size; ++j) {\n      const tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n\n/**\n * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n * Note: points are modified in-place.\n * @param points Array of points that represent the polygon.\n * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n * @param options Parameters of the polygon.\n * @return Returns true if the winding direction was changed.\n */\nexport function modifyPolygonWindingDirectionPoints(\n  points: PointsArray,\n  direction: number,\n  options: PolygonParams = {}\n): boolean {\n  const currentDirection = getPolygonWindingDirectionPoints(points, options);\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns winding direction of the polygon.\n * @param points Array of points that represent the polygon.\n * @param options Parameters of the polygon.\n * @returns Winding direction of the polygon.\n */\nexport function getPolygonWindingDirectionPoints(\n  points: PointsArray,\n  options: PolygonParams = {}\n): number {\n  return Math.sign(getPolygonSignedAreaPoints(points, options));\n}\n\n/**\n * Returns signed area of the polygon.\n * @param points Array of points that represent the polygon.\n * @param options Parameters of the polygon.\n * @returns Signed area of the polygon.\n */\nexport function getPolygonSignedAreaPoints(\n  points: PointsArray,\n  options: PolygonParams = {}\n): number {\n  // https://en.wikipedia.org/wiki/Shoelace_formula\n  const {start = 0, end = points.length, plane = 'xy'} = options;\n  let area = 0;\n  const i0 = DimIndex[plane[0]];\n  const i1 = DimIndex[plane[1]];\n\n  for (let i = start, j = end - 1; i < end; ++i) {\n    area += (points[i][i0] - points[j][i0]) * (points[i][i1] + points[j][i1]);\n    j = i;\n  }\n  return area / 2;\n}\n\n/**\n * Calls visitor callback for each segment in the polygon.\n * @param points Array of points that represent the polygon.\n * @param visitor A callback to call for each segment.\n * @param options Parameters of the polygon.\n */\nexport function forEachSegmentInPolygonPoints(\n  points: PointsArray,\n  visitor: SegmentVisitorPoints,\n  options: PolygonParams = {}\n): void {\n  const {start = 0, end = points.length, isClosed} = options;\n  for (let i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n\n  const isClosedEx = isClosed || equals(points[end - 1], points[0]);\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA;AAEA,SAAQA,MAAM,QAAO,eAAe;AAGpC,OAAO,MAAMC,OAAO,GAAG;EACrBC,SAAS,EAAE,CAAC;EACZC,iBAAiB,EAAE,CAAC;CACZ;AAqDV;;;;;;;;AAQA,OAAM,SAAUC,6BAA6BA,CAC3CC,MAAoB,EACpBC,SAAiB,EACjBC,OAAA,GAAyB,EAAE;EAE3B,MAAMC,gBAAgB,GAAGC,0BAA0B,CAACJ,MAAM,EAAEE,OAAO,CAAC;EACpE,IAAIC,gBAAgB,KAAKF,SAAS,EAAE;IAClCI,cAAc,CAACL,MAAM,EAAEE,OAAO,CAAC;IAC/B,OAAO,IAAI;EACb;EACA,OAAO,KAAK;AACd;AAEA;;;;;;AAMA,OAAM,SAAUE,0BAA0BA,CACxCJ,MAAoB,EACpBE,OAAA,GAAyB,EAAE;EAE3B,OAAOI,IAAI,CAACC,IAAI,CAACC,oBAAoB,CAACR,MAAM,EAAEE,OAAO,CAAC,CAAC;AACzD;AAEA,OAAO,MAAMO,QAAQ,GAA2B;EAC9CC,CAAC,EAAE,CAAC;EACJC,CAAC,EAAE,CAAC;EACJC,CAAC,EAAE;CACK;AAEV;;;;;;;AAOA,OAAM,SAAUJ,oBAAoBA,CAACR,MAAoB,EAAEE,OAAA,GAAyB,EAAE;EACpF,MAAM;IAACW,KAAK,GAAG,CAAC;IAAEC,GAAG,GAAGd,MAAM,CAACe,MAAM;IAAEC,KAAK,GAAG;EAAI,CAAC,GAAGd,OAAO;EAC9D,MAAMe,GAAG,GAAGf,OAAO,CAACgB,IAAI,IAAI,CAAC;EAC7B,IAAIC,IAAI,GAAG,CAAC;EACZ,MAAMC,EAAE,GAAGX,QAAQ,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC;EAC7B,MAAMK,EAAE,GAAGZ,QAAQ,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC;EAE7B,KAAK,IAAIM,CAAC,GAAGT,KAAK,EAAEU,CAAC,GAAGT,GAAG,GAAGG,GAAG,EAAEK,CAAC,GAAGR,GAAG,EAAEQ,CAAC,IAAIL,GAAG,EAAE;IACpDE,IAAI,IAAI,CAACnB,MAAM,CAACsB,CAAC,GAAGF,EAAE,CAAC,GAAGpB,MAAM,CAACuB,CAAC,GAAGH,EAAE,CAAC,KAAKpB,MAAM,CAACsB,CAAC,GAAGD,EAAE,CAAC,GAAGrB,MAAM,CAACuB,CAAC,GAAGF,EAAE,CAAC,CAAC;IAC7EE,CAAC,GAAGD,CAAC;EACP;EACA,OAAOH,IAAI,GAAG,CAAC;AACjB;AAEA;;;;;;AAMA,OAAM,SAAUK,uBAAuBA,CACrCxB,MAAoB,EACpByB,OAA2B,EAC3BvB,OAAA,GAAyB,EAAE;EAE3B,MAAM;IAACW,KAAK,GAAG,CAAC;IAAEC,GAAG,GAAGd,MAAM,CAACe,MAAM;IAAEG,IAAI,GAAG,CAAC;IAAEQ;EAAQ,CAAC,GAAGxB,OAAO;EAEpE,MAAMyB,SAAS,GAAG,CAACb,GAAG,GAAGD,KAAK,IAAIK,IAAI;EACtC,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,SAAS,GAAG,CAAC,EAAE,EAAEL,CAAC,EAAE;IACtCG,OAAO,CACLzB,MAAM,CAACa,KAAK,GAAGS,CAAC,GAAGJ,IAAI,CAAC,EACxBlB,MAAM,CAACa,KAAK,GAAGS,CAAC,GAAGJ,IAAI,GAAG,CAAC,CAAC,EAC5BlB,MAAM,CAACa,KAAK,GAAG,CAACS,CAAC,GAAG,CAAC,IAAIJ,IAAI,CAAC,EAC9BlB,MAAM,CAACa,KAAK,GAAG,CAACS,CAAC,GAAG,CAAC,IAAIJ,IAAI,GAAG,CAAC,CAAC,EAClCI,CAAC,EACDA,CAAC,GAAG,CAAC,CACN;EACH;EAEA,MAAMM,aAAa,GAAGf,KAAK,GAAG,CAACc,SAAS,GAAG,CAAC,IAAIT,IAAI;EACpD,MAAMW,UAAU,GACdH,QAAQ,IACP/B,MAAM,CAACK,MAAM,CAACa,KAAK,CAAC,EAAEb,MAAM,CAAC4B,aAAa,CAAC,CAAC,IAC3CjC,MAAM,CAACK,MAAM,CAACa,KAAK,GAAG,CAAC,CAAC,EAAEb,MAAM,CAAC4B,aAAa,GAAG,CAAC,CAAC,CAAE;EAEzD,IAAI,CAACC,UAAU,EAAE;IACfJ,OAAO,CACLzB,MAAM,CAAC4B,aAAa,CAAC,EACrB5B,MAAM,CAAC4B,aAAa,GAAG,CAAC,CAAC,EACzB5B,MAAM,CAACa,KAAK,CAAC,EACbb,MAAM,CAACa,KAAK,GAAG,CAAC,CAAC,EACjBc,SAAS,GAAG,CAAC,EACb,CAAC,CACF;EACH;AACF;AAEA,SAAStB,cAAcA,CACrBL,MAAoB,EACpBE,OAAsD;EAEtD,MAAM;IAACW,KAAK,GAAG,CAAC;IAAEC,GAAG,GAAGd,MAAM,CAACe,MAAM;IAAEG,IAAI,GAAG;EAAC,CAAC,GAAGhB,OAAO;EAE1D,MAAMyB,SAAS,GAAG,CAACb,GAAG,GAAGD,KAAK,IAAIK,IAAI;EACtC,MAAMY,QAAQ,GAAGxB,IAAI,CAACyB,KAAK,CAACJ,SAAS,GAAG,CAAC,CAAC;EAC1C,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,QAAQ,EAAE,EAAER,CAAC,EAAE;IACjC,MAAMU,EAAE,GAAGnB,KAAK,GAAGS,CAAC,GAAGJ,IAAI;IAC3B,MAAMe,EAAE,GAAGpB,KAAK,GAAG,CAACc,SAAS,GAAG,CAAC,GAAGL,CAAC,IAAIJ,IAAI;IAC7C,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,IAAI,EAAE,EAAEK,CAAC,EAAE;MAC7B,MAAMW,GAAG,GAAGlC,MAAM,CAACgC,EAAE,GAAGT,CAAC,CAAC;MAC1BvB,MAAM,CAACgC,EAAE,GAAGT,CAAC,CAAC,GAAGvB,MAAM,CAACiC,EAAE,GAAGV,CAAC,CAAC;MAC/BvB,MAAM,CAACiC,EAAE,GAAGV,CAAC,CAAC,GAAGW,GAAG;IACtB;EACF;AACF;AAEA;;;;;;;;AAQA,OAAM,SAAUC,mCAAmCA,CACjDnC,MAAmB,EACnBC,SAAiB,EACjBC,OAAA,GAAyB,EAAE;EAE3B,MAAMkC,gBAAgB,GAAGC,gCAAgC,CAACrC,MAAM,EAAEE,OAAO,CAAC;EAC1E,IAAIkC,gBAAgB,KAAKnC,SAAS,EAAE;IAClCD,MAAM,CAACsC,OAAO,EAAE;IAChB,OAAO,IAAI;EACb;EACA,OAAO,KAAK;AACd;AAEA;;;;;;AAMA,OAAM,SAAUD,gCAAgCA,CAC9CrC,MAAmB,EACnBE,OAAA,GAAyB,EAAE;EAE3B,OAAOI,IAAI,CAACC,IAAI,CAACgC,0BAA0B,CAACvC,MAAM,EAAEE,OAAO,CAAC,CAAC;AAC/D;AAEA;;;;;;AAMA,OAAM,SAAUqC,0BAA0BA,CACxCvC,MAAmB,EACnBE,OAAA,GAAyB,EAAE;EAE3B;EACA,MAAM;IAACW,KAAK,GAAG,CAAC;IAAEC,GAAG,GAAGd,MAAM,CAACe,MAAM;IAAEC,KAAK,GAAG;EAAI,CAAC,GAAGd,OAAO;EAC9D,IAAIiB,IAAI,GAAG,CAAC;EACZ,MAAMC,EAAE,GAAGX,QAAQ,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC;EAC7B,MAAMK,EAAE,GAAGZ,QAAQ,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC;EAE7B,KAAK,IAAIM,CAAC,GAAGT,KAAK,EAAEU,CAAC,GAAGT,GAAG,GAAG,CAAC,EAAEQ,CAAC,GAAGR,GAAG,EAAE,EAAEQ,CAAC,EAAE;IAC7CH,IAAI,IAAI,CAACnB,MAAM,CAACsB,CAAC,CAAC,CAACF,EAAE,CAAC,GAAGpB,MAAM,CAACuB,CAAC,CAAC,CAACH,EAAE,CAAC,KAAKpB,MAAM,CAACsB,CAAC,CAAC,CAACD,EAAE,CAAC,GAAGrB,MAAM,CAACuB,CAAC,CAAC,CAACF,EAAE,CAAC,CAAC;IACzEE,CAAC,GAAGD,CAAC;EACP;EACA,OAAOH,IAAI,GAAG,CAAC;AACjB;AAEA;;;;;;AAMA,OAAM,SAAUqB,6BAA6BA,CAC3CxC,MAAmB,EACnByB,OAA6B,EAC7BvB,OAAA,GAAyB,EAAE;EAE3B,MAAM;IAACW,KAAK,GAAG,CAAC;IAAEC,GAAG,GAAGd,MAAM,CAACe,MAAM;IAAEW;EAAQ,CAAC,GAAGxB,OAAO;EAC1D,KAAK,IAAIoB,CAAC,GAAGT,KAAK,EAAES,CAAC,GAAGR,GAAG,GAAG,CAAC,EAAE,EAAEQ,CAAC,EAAE;IACpCG,OAAO,CAACzB,MAAM,CAACsB,CAAC,CAAC,EAAEtB,MAAM,CAACsB,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;EAC7C;EAEA,MAAMO,UAAU,GAAGH,QAAQ,IAAI/B,MAAM,CAACK,MAAM,CAACc,GAAG,GAAG,CAAC,CAAC,EAAEd,MAAM,CAAC,CAAC,CAAC,CAAC;EACjE,IAAI,CAAC6B,UAAU,EAAE;IACfJ,OAAO,CAACzB,MAAM,CAACc,GAAG,GAAG,CAAC,CAAC,EAAEd,MAAM,CAAC,CAAC,CAAC,EAAEc,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC;EACjD;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}