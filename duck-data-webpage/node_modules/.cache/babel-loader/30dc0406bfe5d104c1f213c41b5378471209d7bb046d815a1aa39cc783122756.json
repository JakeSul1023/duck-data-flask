{"ast":null,"code":"import { GLTFScenegraph } from \"../../api/gltf-scenegraph.js\";\nimport { convertRawBufferToMetadataArray, getPrimitiveTextureData, primitivePropertyDataToAttributes, getArrayElementByteSize, getOffsetsForProperty, parseVariableLengthArrayNumeric, parseFixedLengthArrayNumeric, getPropertyDataString } from \"../utils/3d-tiles-utils.js\";\n/** Extension name */\nconst EXT_FEATURE_METADATA_NAME = 'EXT_feature_metadata';\nexport const name = EXT_FEATURE_METADATA_NAME;\nexport async function decode(gltfData, options) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  decodeExtFeatureMetadata(scenegraph, options);\n}\n/**\n * Decodes feature metadata from extension.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param options - GLTFLoader options.\n */\nfunction decodeExtFeatureMetadata(scenegraph, options) {\n  // Decoding metadata involves buffers processing.\n  // So, if buffers have not been loaded, there is no reason to process metadata.\n  if (!options.gltf?.loadBuffers) {\n    return;\n  }\n  const extension = scenegraph.getExtension(EXT_FEATURE_METADATA_NAME);\n  if (!extension) {\n    return;\n  }\n  if (options.gltf?.loadImages) {\n    decodePropertyTextures(scenegraph, extension);\n  }\n  decodePropertyTables(scenegraph, extension);\n}\n/**\n * Processes the data stored in the textures\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param extension - Top-level extension.\n */\nfunction decodePropertyTextures(scenegraph, extension) {\n  const schema = extension.schema;\n  if (!schema) {\n    return;\n  }\n  const schemaClasses = schema.classes;\n  const {\n    featureTextures\n  } = extension;\n  if (schemaClasses && featureTextures) {\n    for (const schemaName in schemaClasses) {\n      const schemaClass = schemaClasses[schemaName];\n      const featureTexture = findFeatureTextureByClass(featureTextures, schemaName);\n      if (featureTexture) {\n        handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass);\n      }\n    }\n  }\n}\n/**\n * Processes the data stored in the property tables.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param extension - Top-level extension.\n */\nfunction decodePropertyTables(scenegraph, extension) {\n  const schema = extension.schema;\n  if (!schema) {\n    return;\n  }\n  const schemaClasses = schema.classes;\n  const propertyTables = extension.featureTables;\n  if (schemaClasses && propertyTables) {\n    for (const schemaName in schemaClasses) {\n      const propertyTable = findPropertyTableByClass(propertyTables, schemaName);\n      if (propertyTable) {\n        processPropertyTable(scenegraph, schema, propertyTable);\n      }\n    }\n  }\n}\n/**\n * Finds the property table by class name.\n * @param propertyTables - propertyTable definition taken from the top-level extension.\n * @param schemaClassName - class name in the extension schema.\n */\nfunction findPropertyTableByClass(propertyTables, schemaClassName) {\n  for (const propertyTableName in propertyTables) {\n    const propertyTable = propertyTables[propertyTableName];\n    if (propertyTable.class === schemaClassName) {\n      return propertyTable;\n    }\n  }\n  return null;\n}\nfunction findFeatureTextureByClass(featureTextures, schemaClassName) {\n  for (const featureTexturesName in featureTextures) {\n    const featureTable = featureTextures[featureTexturesName];\n    if (featureTable.class === schemaClassName) {\n      return featureTable;\n    }\n  }\n  return null;\n}\n/**\n * Navigates through all properies in the property table, gets properties data,\n * and put the data to `propertyTable.data` as an array.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param schema - schema object.\n * @param propertyTable - propertyTable definition taken from the top-level extension.\n */\nfunction processPropertyTable(scenegraph, schema, propertyTable) {\n  // Though 'class' is not required by spec, it doesn't make any scence when it's not provided.\n  // So, bale out here.\n  if (!propertyTable.class) {\n    return;\n  }\n  const schemaClass = schema.classes?.[propertyTable.class];\n  if (!schemaClass) {\n    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);\n  }\n  const numberOfElements = propertyTable.count; // `propertyTable.count` is a number of elements in each property array.\n  for (const propertyName in schemaClass.properties) {\n    const classProperty = schemaClass.properties[propertyName];\n    const propertyTableProperty = propertyTable.properties?.[propertyName];\n    if (propertyTableProperty) {\n      // Getting all elements (`numberOfElements`) of the array in the `propertyTableProperty`\n      const data = getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);\n      propertyTableProperty.data = data;\n    }\n  }\n}\n/**\n * Navigates through all properies in feature texture and gets properties data.\n * Data will be stored in featureTexture.properties[propertyName].data.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param featureTexture\n * @param schemaClass\n */\nfunction handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass) {\n  const attributeName = featureTexture.class;\n  for (const propertyName in schemaClass.properties) {\n    const featureTextureProperty = featureTexture?.properties?.[propertyName];\n    if (featureTextureProperty) {\n      const data = getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName);\n      featureTextureProperty.data = data;\n    }\n  }\n}\n/**\n * Decodes properties from binary sourse based on property type.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param schemaProperty\n * @param numberOfFeatures\n * @param featureTableProperty\n */\nfunction getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfFeatures, featureTableProperty) {\n  let data = [];\n  const bufferView = featureTableProperty.bufferView;\n  const dataArray = scenegraph.getTypedArrayForBufferView(bufferView);\n  const arrayOffsets = getArrayOffsetsForProperty(scenegraph, classProperty, featureTableProperty, numberOfFeatures);\n  const stringOffsets = getStringOffsetsForProperty(scenegraph, classProperty, featureTableProperty, numberOfFeatures);\n  if (classProperty.type === 'STRING' || classProperty.componentType === 'STRING') {\n    data = getPropertyDataString(numberOfFeatures, dataArray, arrayOffsets, stringOffsets);\n  } else if (isNumericProperty(classProperty)) {\n    data = getPropertyDataNumeric(classProperty, numberOfFeatures, dataArray, arrayOffsets);\n  }\n  return data;\n}\n/**\n * Parses propertyTable.property.arrayOffsets that are offsets of sub-arrays in a flatten array of values.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param classProperty - class property object.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @returns Typed array with offset values.\n * @see https://github.com/CesiumGS/glTF/blob/2976f1183343a47a29e4059a70961371cd2fcee8/extensions/2.0/Vendor/EXT_structural_metadata/schema/propertyTable.property.schema.json#L21\n */\nfunction getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements) {\n  /*\n   If ARRAY is used, then componentType must also be specified.\n   ARRAY is a fixed-length array when componentCount is defined, and variable-length otherwise.\n  */\n  if (classProperty.type === 'ARRAY' &&\n  // `componentCount` is a number of fixed-length array elements.\n  // If `componentCount` is NOT defined, it's a VARIABLE-length array\n  typeof classProperty.componentCount === 'undefined' &&\n  // `arrayOffsetBufferView` is an index of the buffer view containing offsets for variable-length arrays.\n  typeof propertyTableProperty.arrayOffsetBufferView !== 'undefined') {\n    // Data are in a VARIABLE-length array\n    return getOffsetsForProperty(scenegraph, propertyTableProperty.arrayOffsetBufferView, propertyTableProperty.offsetType || 'UINT32',\n    // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView\n    numberOfElements);\n  }\n  return null;\n}\n/**\n * Parses featureTable.property.stringOffsetBufferView.\n * String offsets is an array of offsets of strings in the united array of characters.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @returns Typed array of offset values. The number of offsets in the array is equal to `numberOfElements` plus one.\n * @see https://github.com/CesiumGS/glTF/blob/c38f7f37e894004353c15cd0481bc5b7381ce841/extensions/2.0/Vendor/EXT_feature_metadata/schema/featureTable.property.schema.json#L50C10-L50C32\n */\nfunction getStringOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements) {\n  if (typeof propertyTableProperty.stringOffsetBufferView !== 'undefined' // `stringOffsetBufferView` is an index of the buffer view containing offsets for strings.\n  ) {\n    // Data are in a FIXED-length array\n    return getOffsetsForProperty(scenegraph, propertyTableProperty.stringOffsetBufferView, propertyTableProperty.offsetType || 'UINT32',\n    // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView\n    numberOfElements);\n  }\n  return null;\n}\n/**\n * Checks if the feature table property is of numeric type.\n * @param schemaPropertyType - feature table property\n * @returns true if property is numeric, else - false\n */\nfunction isNumericProperty(schemaProperty) {\n  const types = ['UINT8', 'INT16', 'UINT16', 'INT32', 'UINT32', 'INT64', 'UINT64', 'FLOAT32', 'FLOAT64'];\n  return types.includes(schemaProperty.type) || typeof schemaProperty.componentType !== 'undefined' && types.includes(schemaProperty.componentType);\n}\n/**\n * Decodes properties of numeric types from binary sourse.\n * @param classProperty - class property object.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param valuesDataBytes - Data taken from values property of the property table property.\n * @param arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @returns Property values in a typed array or in an array of typed arrays.\n */\nfunction getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {\n  const isArray = classProperty.type === 'ARRAY';\n  const arrayCount = classProperty.componentCount;\n  /*\n  We are getting Numeric data. So,\n    the component type can be one of NumericComponentType,\n    the attribute type should be 'SCALAR'\n  */\n  const attributeType = 'SCALAR';\n  const componentType = classProperty.componentType || classProperty.type;\n  const elementSize = getArrayElementByteSize(attributeType, componentType);\n  const elementCount = valuesDataBytes.byteLength / elementSize;\n  const valuesData = convertRawBufferToMetadataArray(valuesDataBytes, attributeType, componentType, elementCount);\n  if (isArray) {\n    if (arrayOffsets) {\n      // VARIABLE-length array\n      return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);\n    }\n    if (arrayCount) {\n      // FIXED-length array\n      return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);\n    }\n    return [];\n  }\n  return valuesData;\n}\n/**\n * Gets properties from texture associated with all mesh primitives.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param featureTextureProperty\n * @param attributeName\n * @returns Feature texture data\n */\nfunction getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName) {\n  const json = scenegraph.gltf.json;\n  if (!json.meshes) {\n    return [];\n  }\n  const featureTextureTable = [];\n  for (const mesh of json.meshes) {\n    for (const primitive of mesh.primitives) {\n      processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive);\n    }\n  }\n  return featureTextureTable;\n}\n/**\n * Processes data encoded in the texture associated with the primitive. This data will be accessible through the attributes.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param attributeName\n * @param featureTextureProperty\n * @param featureTextureTable\n * @param primitive\n */\nfunction processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive) {\n  const textureInfoTopLevel = {\n    channels: featureTextureProperty.channels,\n    ...featureTextureProperty.texture\n  };\n  const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);\n  if (!propertyData) {\n    return;\n  }\n  primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);\n}","map":{"version":3,"names":["GLTFScenegraph","convertRawBufferToMetadataArray","getPrimitiveTextureData","primitivePropertyDataToAttributes","getArrayElementByteSize","getOffsetsForProperty","parseVariableLengthArrayNumeric","parseFixedLengthArrayNumeric","getPropertyDataString","EXT_FEATURE_METADATA_NAME","name","decode","gltfData","options","scenegraph","decodeExtFeatureMetadata","gltf","loadBuffers","extension","getExtension","loadImages","decodePropertyTextures","decodePropertyTables","schema","schemaClasses","classes","featureTextures","schemaName","schemaClass","featureTexture","findFeatureTextureByClass","handleFeatureTextureProperties","propertyTables","featureTables","propertyTable","findPropertyTableByClass","processPropertyTable","schemaClassName","propertyTableName","class","featureTexturesName","featureTable","Error","numberOfElements","count","propertyName","properties","classProperty","propertyTableProperty","data","getPropertyDataFromBinarySource","attributeName","featureTextureProperty","getPropertyDataFromTexture","numberOfFeatures","featureTableProperty","bufferView","dataArray","getTypedArrayForBufferView","arrayOffsets","getArrayOffsetsForProperty","stringOffsets","getStringOffsetsForProperty","type","componentType","isNumericProperty","getPropertyDataNumeric","componentCount","arrayOffsetBufferView","offsetType","stringOffsetBufferView","schemaProperty","types","includes","valuesDataBytes","isArray","arrayCount","attributeType","elementSize","elementCount","byteLength","valuesData","length","json","meshes","featureTextureTable","mesh","primitive","primitives","processPrimitiveTextures","textureInfoTopLevel","channels","texture","propertyData"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/EXT_feature_metadata.js"],"sourcesContent":["import { GLTFScenegraph } from \"../../api/gltf-scenegraph.js\";\nimport { convertRawBufferToMetadataArray, getPrimitiveTextureData, primitivePropertyDataToAttributes, getArrayElementByteSize, getOffsetsForProperty, parseVariableLengthArrayNumeric, parseFixedLengthArrayNumeric, getPropertyDataString } from \"../utils/3d-tiles-utils.js\";\n/** Extension name */\nconst EXT_FEATURE_METADATA_NAME = 'EXT_feature_metadata';\nexport const name = EXT_FEATURE_METADATA_NAME;\nexport async function decode(gltfData, options) {\n    const scenegraph = new GLTFScenegraph(gltfData);\n    decodeExtFeatureMetadata(scenegraph, options);\n}\n/**\n * Decodes feature metadata from extension.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param options - GLTFLoader options.\n */\nfunction decodeExtFeatureMetadata(scenegraph, options) {\n    // Decoding metadata involves buffers processing.\n    // So, if buffers have not been loaded, there is no reason to process metadata.\n    if (!options.gltf?.loadBuffers) {\n        return;\n    }\n    const extension = scenegraph.getExtension(EXT_FEATURE_METADATA_NAME);\n    if (!extension) {\n        return;\n    }\n    if (options.gltf?.loadImages) {\n        decodePropertyTextures(scenegraph, extension);\n    }\n    decodePropertyTables(scenegraph, extension);\n}\n/**\n * Processes the data stored in the textures\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param extension - Top-level extension.\n */\nfunction decodePropertyTextures(scenegraph, extension) {\n    const schema = extension.schema;\n    if (!schema) {\n        return;\n    }\n    const schemaClasses = schema.classes;\n    const { featureTextures } = extension;\n    if (schemaClasses && featureTextures) {\n        for (const schemaName in schemaClasses) {\n            const schemaClass = schemaClasses[schemaName];\n            const featureTexture = findFeatureTextureByClass(featureTextures, schemaName);\n            if (featureTexture) {\n                handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass);\n            }\n        }\n    }\n}\n/**\n * Processes the data stored in the property tables.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param extension - Top-level extension.\n */\nfunction decodePropertyTables(scenegraph, extension) {\n    const schema = extension.schema;\n    if (!schema) {\n        return;\n    }\n    const schemaClasses = schema.classes;\n    const propertyTables = extension.featureTables;\n    if (schemaClasses && propertyTables) {\n        for (const schemaName in schemaClasses) {\n            const propertyTable = findPropertyTableByClass(propertyTables, schemaName);\n            if (propertyTable) {\n                processPropertyTable(scenegraph, schema, propertyTable);\n            }\n        }\n    }\n}\n/**\n * Finds the property table by class name.\n * @param propertyTables - propertyTable definition taken from the top-level extension.\n * @param schemaClassName - class name in the extension schema.\n */\nfunction findPropertyTableByClass(propertyTables, schemaClassName) {\n    for (const propertyTableName in propertyTables) {\n        const propertyTable = propertyTables[propertyTableName];\n        if (propertyTable.class === schemaClassName) {\n            return propertyTable;\n        }\n    }\n    return null;\n}\nfunction findFeatureTextureByClass(featureTextures, schemaClassName) {\n    for (const featureTexturesName in featureTextures) {\n        const featureTable = featureTextures[featureTexturesName];\n        if (featureTable.class === schemaClassName) {\n            return featureTable;\n        }\n    }\n    return null;\n}\n/**\n * Navigates through all properies in the property table, gets properties data,\n * and put the data to `propertyTable.data` as an array.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param schema - schema object.\n * @param propertyTable - propertyTable definition taken from the top-level extension.\n */\nfunction processPropertyTable(scenegraph, schema, propertyTable) {\n    // Though 'class' is not required by spec, it doesn't make any scence when it's not provided.\n    // So, bale out here.\n    if (!propertyTable.class) {\n        return;\n    }\n    const schemaClass = schema.classes?.[propertyTable.class];\n    if (!schemaClass) {\n        throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);\n    }\n    const numberOfElements = propertyTable.count; // `propertyTable.count` is a number of elements in each property array.\n    for (const propertyName in schemaClass.properties) {\n        const classProperty = schemaClass.properties[propertyName];\n        const propertyTableProperty = propertyTable.properties?.[propertyName];\n        if (propertyTableProperty) {\n            // Getting all elements (`numberOfElements`) of the array in the `propertyTableProperty`\n            const data = getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);\n            propertyTableProperty.data = data;\n        }\n    }\n}\n/**\n * Navigates through all properies in feature texture and gets properties data.\n * Data will be stored in featureTexture.properties[propertyName].data.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param featureTexture\n * @param schemaClass\n */\nfunction handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass) {\n    const attributeName = featureTexture.class;\n    for (const propertyName in schemaClass.properties) {\n        const featureTextureProperty = featureTexture?.properties?.[propertyName];\n        if (featureTextureProperty) {\n            const data = getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName);\n            featureTextureProperty.data = data;\n        }\n    }\n}\n/**\n * Decodes properties from binary sourse based on property type.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param schemaProperty\n * @param numberOfFeatures\n * @param featureTableProperty\n */\nfunction getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfFeatures, featureTableProperty) {\n    let data = [];\n    const bufferView = featureTableProperty.bufferView;\n    const dataArray = scenegraph.getTypedArrayForBufferView(bufferView);\n    const arrayOffsets = getArrayOffsetsForProperty(scenegraph, classProperty, featureTableProperty, numberOfFeatures);\n    const stringOffsets = getStringOffsetsForProperty(scenegraph, classProperty, featureTableProperty, numberOfFeatures);\n    if (classProperty.type === 'STRING' || classProperty.componentType === 'STRING') {\n        data = getPropertyDataString(numberOfFeatures, dataArray, arrayOffsets, stringOffsets);\n    }\n    else if (isNumericProperty(classProperty)) {\n        data = getPropertyDataNumeric(classProperty, numberOfFeatures, dataArray, arrayOffsets);\n    }\n    return data;\n}\n/**\n * Parses propertyTable.property.arrayOffsets that are offsets of sub-arrays in a flatten array of values.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param classProperty - class property object.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @returns Typed array with offset values.\n * @see https://github.com/CesiumGS/glTF/blob/2976f1183343a47a29e4059a70961371cd2fcee8/extensions/2.0/Vendor/EXT_structural_metadata/schema/propertyTable.property.schema.json#L21\n */\nfunction getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements) {\n    /*\n     If ARRAY is used, then componentType must also be specified.\n     ARRAY is a fixed-length array when componentCount is defined, and variable-length otherwise.\n  */\n    if (classProperty.type === 'ARRAY' &&\n        // `componentCount` is a number of fixed-length array elements.\n        // If `componentCount` is NOT defined, it's a VARIABLE-length array\n        typeof classProperty.componentCount === 'undefined' &&\n        // `arrayOffsetBufferView` is an index of the buffer view containing offsets for variable-length arrays.\n        typeof propertyTableProperty.arrayOffsetBufferView !== 'undefined') {\n        // Data are in a VARIABLE-length array\n        return getOffsetsForProperty(scenegraph, propertyTableProperty.arrayOffsetBufferView, propertyTableProperty.offsetType || 'UINT32', // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView\n        numberOfElements);\n    }\n    return null;\n}\n/**\n * Parses featureTable.property.stringOffsetBufferView.\n * String offsets is an array of offsets of strings in the united array of characters.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @returns Typed array of offset values. The number of offsets in the array is equal to `numberOfElements` plus one.\n * @see https://github.com/CesiumGS/glTF/blob/c38f7f37e894004353c15cd0481bc5b7381ce841/extensions/2.0/Vendor/EXT_feature_metadata/schema/featureTable.property.schema.json#L50C10-L50C32\n */\nfunction getStringOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements) {\n    if (typeof propertyTableProperty.stringOffsetBufferView !== 'undefined' // `stringOffsetBufferView` is an index of the buffer view containing offsets for strings.\n    ) {\n        // Data are in a FIXED-length array\n        return getOffsetsForProperty(scenegraph, propertyTableProperty.stringOffsetBufferView, propertyTableProperty.offsetType || 'UINT32', // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView\n        numberOfElements);\n    }\n    return null;\n}\n/**\n * Checks if the feature table property is of numeric type.\n * @param schemaPropertyType - feature table property\n * @returns true if property is numeric, else - false\n */\nfunction isNumericProperty(schemaProperty) {\n    const types = [\n        'UINT8',\n        'INT16',\n        'UINT16',\n        'INT32',\n        'UINT32',\n        'INT64',\n        'UINT64',\n        'FLOAT32',\n        'FLOAT64'\n    ];\n    return (types.includes(schemaProperty.type) ||\n        (typeof schemaProperty.componentType !== 'undefined' &&\n            types.includes(schemaProperty.componentType)));\n}\n/**\n * Decodes properties of numeric types from binary sourse.\n * @param classProperty - class property object.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param valuesDataBytes - Data taken from values property of the property table property.\n * @param arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @returns Property values in a typed array or in an array of typed arrays.\n */\nfunction getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {\n    const isArray = classProperty.type === 'ARRAY';\n    const arrayCount = classProperty.componentCount;\n    /*\n    We are getting Numeric data. So,\n      the component type can be one of NumericComponentType,\n      the attribute type should be 'SCALAR'\n    */\n    const attributeType = 'SCALAR';\n    const componentType = classProperty.componentType || classProperty.type;\n    const elementSize = getArrayElementByteSize(attributeType, componentType);\n    const elementCount = valuesDataBytes.byteLength / elementSize;\n    const valuesData = convertRawBufferToMetadataArray(valuesDataBytes, attributeType, componentType, elementCount);\n    if (isArray) {\n        if (arrayOffsets) {\n            // VARIABLE-length array\n            return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);\n        }\n        if (arrayCount) {\n            // FIXED-length array\n            return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);\n        }\n        return [];\n    }\n    return valuesData;\n}\n/**\n * Gets properties from texture associated with all mesh primitives.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param featureTextureProperty\n * @param attributeName\n * @returns Feature texture data\n */\nfunction getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName) {\n    const json = scenegraph.gltf.json;\n    if (!json.meshes) {\n        return [];\n    }\n    const featureTextureTable = [];\n    for (const mesh of json.meshes) {\n        for (const primitive of mesh.primitives) {\n            processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive);\n        }\n    }\n    return featureTextureTable;\n}\n/**\n * Processes data encoded in the texture associated with the primitive. This data will be accessible through the attributes.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param attributeName\n * @param featureTextureProperty\n * @param featureTextureTable\n * @param primitive\n */\nfunction processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive) {\n    const textureInfoTopLevel = {\n        channels: featureTextureProperty.channels,\n        ...featureTextureProperty.texture\n    };\n    const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);\n    if (!propertyData) {\n        return;\n    }\n    primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}