{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * `btoa()` polyfill as defined by the HTML and Infra specs, which mostly just references\n * RFC 4648.\n */\nexport function asciiToBase64(string) {\n  // String conversion as required by Web IDL.\n  string = `${string}`;\n  // \"The btoa() method must throw an \"InvalidCharacterError\" DOMException if\n  // data contains any character whose code point is greater than U+00FF.\"\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return null;\n    }\n  }\n  let out = '';\n  for (let i = 0; i < string.length; i += 3) {\n    /** @type {Array[4]} */\n    const groupsOfSix = [undefined, undefined, undefined, undefined];\n    groupsOfSix[0] = string.charCodeAt(i) >> 2;\n    groupsOfSix[1] = (string.charCodeAt(i) & 0x03) << 4;\n    if (string.length > i + 1) {\n      groupsOfSix[1] |= string.charCodeAt(i + 1) >> 4;\n      groupsOfSix[2] = (string.charCodeAt(i + 1) & 0x0f) << 2;\n    }\n    if (string.length > i + 2) {\n      // @ts-expect-error\n      groupsOfSix[2] |= string.charCodeAt(i + 2) >> 6;\n      groupsOfSix[3] = string.charCodeAt(i + 2) & 0x3f;\n    }\n    for (let j = 0; j < groupsOfSix.length; j++) {\n      if (typeof groupsOfSix[j] === 'undefined') {\n        out += '=';\n      } else {\n        out += btoaLookup(groupsOfSix[j]);\n      }\n    }\n  }\n  return out;\n}\n/**\n * Implementation of atob() according to the HTML and Infra specs, except that\n * instead of throwing INVALID_CHARACTER_ERR we return null.\n *\n * @note Forked from https://github.com/jsdom/abab under BSD 3 clause license\n */\nexport function base64ToAscii(data) {\n  // Web IDL requires DOMStrings to just be converted using ECMAScript\n  // ToString, which in our case amounts to using a template literal.\n  data = `${data}`;\n  // \"Remove all ASCII whitespace from data.\"\n  data = data.replace(/[ \\t\\n\\f\\r]/g, '');\n  // \"If data's code point length divides by 4 leaving no remainder, then: if data ends\n  // with one or two U+003D (=) code points, then remove them from data.\"\n  if (data.length % 4 === 0) {\n    data = data.replace(/[=]=?$/, '');\n  }\n  // \"If data's code point length divides by 4 leaving a remainder of 1, then return\n  // failure.\"\n  //\n  // \"If data contains a code point that is not one of\n  //\n  // U+002B (+)\n  // U+002F (/)\n  // ASCII alphanumeric\n  //\n  // then return failure.\"\n  if (data.length % 4 === 1 || /[^+/0-9A-Za-z]/.test(data)) {\n    return '';\n  }\n  // \"Let output be an empty byte sequence.\"\n  let output = '';\n  // \"Let buffer be an empty buffer that can have bits appended to it.\"\n  //\n  // We append bits via left-shift and or.  accumulatedBits is used to track\n  // when we've gotten to 24 bits.\n  let buffer = 0;\n  let accumulatedBits = 0;\n  // \"Let position be a position variable for data, initially pointing at the\n  // start of data.\"\n  //\n  // \"While position does not point past the end of data:\"\n  for (let i = 0; i < data.length; i++) {\n    // \"Find the code point pointed to by position in the second column of\n    // Table 1: The Base 64 Alphabet of RFC 4648. Let n be the number given in\n    // the first cell of the same row.\n    //\n    // \"Append to buffer the six bits corresponding to n, most significant bit\n    // first.\"\n    //\n    // atobLookup() implements the table from RFC 4648.\n    buffer <<= 6;\n    // @ts-expect-error\n    buffer |= atobLookup(data[i]);\n    accumulatedBits += 6;\n    // \"If buffer has accumulated 24 bits, interpret them as three 8-bit\n    // big-endian numbers. Append three bytes with values equal to those\n    // numbers to output, in the same order, and then empty buffer.\"\n    if (accumulatedBits === 24) {\n      output += String.fromCharCode((buffer & 0xff0000) >> 16);\n      output += String.fromCharCode((buffer & 0xff00) >> 8);\n      output += String.fromCharCode(buffer & 0xff);\n      buffer = accumulatedBits = 0;\n    }\n    // \"Advance position by 1.\"\n  }\n  // \"If buffer is not empty, it contains either 12 or 18 bits. If it contains\n  // 12 bits, then discard the last four and interpret the remaining eight as\n  // an 8-bit big-endian number. If it contains 18 bits, then discard the last\n  // two and interpret the remaining 16 as two 8-bit big-endian numbers. Append\n  // the one or two bytes with values equal to those one or two numbers to\n  // output, in the same order.\"\n  if (accumulatedBits === 12) {\n    buffer >>= 4;\n    output += String.fromCharCode(buffer);\n  } else if (accumulatedBits === 18) {\n    buffer >>= 2;\n    output += String.fromCharCode((buffer & 0xff00) >> 8);\n    output += String.fromCharCode(buffer & 0xff);\n  }\n  // \"Return output.\"\n  return output;\n}\n/**\n * A lookup table for atob(), which converts an ASCII character to the\n * corresponding six-bit number.\n */\nconst keystr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfunction atobLookup(chr) {\n  const index = keystr.indexOf(chr);\n  // Throw exception if character is not in the lookup string; should not be hit in tests\n  return index < 0 ? undefined : index;\n}\n/**\n * Lookup table for btoa(), which converts a six-bit number into the\n * corresponding ASCII character.\n */\nfunction btoaLookup(idx) {\n  if (idx < 26) {\n    return String.fromCharCode(idx + 'A'.charCodeAt(0));\n  }\n  if (idx < 52) {\n    return String.fromCharCode(idx - 26 + 'a'.charCodeAt(0));\n  }\n  if (idx < 62) {\n    return String.fromCharCode(idx - 52 + '0'.charCodeAt(0));\n  }\n  if (idx === 62) {\n    return '+';\n  }\n  if (idx === 63) {\n    return '/';\n  }\n  // Throw INVALID_CHARACTER_ERR exception here -- won't be hit in the teststring.\n  return undefined;\n}","map":{"version":3,"names":["asciiToBase64","string","i","length","charCodeAt","out","groupsOfSix","undefined","j","btoaLookup","base64ToAscii","data","replace","test","output","buffer","accumulatedBits","atobLookup","String","fromCharCode","keystr","chr","index","indexOf","idx"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/crypto/dist/lib/utils/base64-utils.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * `btoa()` polyfill as defined by the HTML and Infra specs, which mostly just references\n * RFC 4648.\n */\nexport function asciiToBase64(string) {\n    // String conversion as required by Web IDL.\n    string = `${string}`;\n    // \"The btoa() method must throw an \"InvalidCharacterError\" DOMException if\n    // data contains any character whose code point is greater than U+00FF.\"\n    for (let i = 0; i < string.length; i++) {\n        if (string.charCodeAt(i) > 255) {\n            return null;\n        }\n    }\n    let out = '';\n    for (let i = 0; i < string.length; i += 3) {\n        /** @type {Array[4]} */\n        const groupsOfSix = [undefined, undefined, undefined, undefined];\n        groupsOfSix[0] = string.charCodeAt(i) >> 2;\n        groupsOfSix[1] = (string.charCodeAt(i) & 0x03) << 4;\n        if (string.length > i + 1) {\n            groupsOfSix[1] |= string.charCodeAt(i + 1) >> 4;\n            groupsOfSix[2] = (string.charCodeAt(i + 1) & 0x0f) << 2;\n        }\n        if (string.length > i + 2) {\n            // @ts-expect-error\n            groupsOfSix[2] |= string.charCodeAt(i + 2) >> 6;\n            groupsOfSix[3] = string.charCodeAt(i + 2) & 0x3f;\n        }\n        for (let j = 0; j < groupsOfSix.length; j++) {\n            if (typeof groupsOfSix[j] === 'undefined') {\n                out += '=';\n            }\n            else {\n                out += btoaLookup(groupsOfSix[j]);\n            }\n        }\n    }\n    return out;\n}\n/**\n * Implementation of atob() according to the HTML and Infra specs, except that\n * instead of throwing INVALID_CHARACTER_ERR we return null.\n *\n * @note Forked from https://github.com/jsdom/abab under BSD 3 clause license\n */\nexport function base64ToAscii(data) {\n    // Web IDL requires DOMStrings to just be converted using ECMAScript\n    // ToString, which in our case amounts to using a template literal.\n    data = `${data}`;\n    // \"Remove all ASCII whitespace from data.\"\n    data = data.replace(/[ \\t\\n\\f\\r]/g, '');\n    // \"If data's code point length divides by 4 leaving no remainder, then: if data ends\n    // with one or two U+003D (=) code points, then remove them from data.\"\n    if (data.length % 4 === 0) {\n        data = data.replace(/[=]=?$/, '');\n    }\n    // \"If data's code point length divides by 4 leaving a remainder of 1, then return\n    // failure.\"\n    //\n    // \"If data contains a code point that is not one of\n    //\n    // U+002B (+)\n    // U+002F (/)\n    // ASCII alphanumeric\n    //\n    // then return failure.\"\n    if (data.length % 4 === 1 || /[^+/0-9A-Za-z]/.test(data)) {\n        return '';\n    }\n    // \"Let output be an empty byte sequence.\"\n    let output = '';\n    // \"Let buffer be an empty buffer that can have bits appended to it.\"\n    //\n    // We append bits via left-shift and or.  accumulatedBits is used to track\n    // when we've gotten to 24 bits.\n    let buffer = 0;\n    let accumulatedBits = 0;\n    // \"Let position be a position variable for data, initially pointing at the\n    // start of data.\"\n    //\n    // \"While position does not point past the end of data:\"\n    for (let i = 0; i < data.length; i++) {\n        // \"Find the code point pointed to by position in the second column of\n        // Table 1: The Base 64 Alphabet of RFC 4648. Let n be the number given in\n        // the first cell of the same row.\n        //\n        // \"Append to buffer the six bits corresponding to n, most significant bit\n        // first.\"\n        //\n        // atobLookup() implements the table from RFC 4648.\n        buffer <<= 6;\n        // @ts-expect-error\n        buffer |= atobLookup(data[i]);\n        accumulatedBits += 6;\n        // \"If buffer has accumulated 24 bits, interpret them as three 8-bit\n        // big-endian numbers. Append three bytes with values equal to those\n        // numbers to output, in the same order, and then empty buffer.\"\n        if (accumulatedBits === 24) {\n            output += String.fromCharCode((buffer & 0xff0000) >> 16);\n            output += String.fromCharCode((buffer & 0xff00) >> 8);\n            output += String.fromCharCode(buffer & 0xff);\n            buffer = accumulatedBits = 0;\n        }\n        // \"Advance position by 1.\"\n    }\n    // \"If buffer is not empty, it contains either 12 or 18 bits. If it contains\n    // 12 bits, then discard the last four and interpret the remaining eight as\n    // an 8-bit big-endian number. If it contains 18 bits, then discard the last\n    // two and interpret the remaining 16 as two 8-bit big-endian numbers. Append\n    // the one or two bytes with values equal to those one or two numbers to\n    // output, in the same order.\"\n    if (accumulatedBits === 12) {\n        buffer >>= 4;\n        output += String.fromCharCode(buffer);\n    }\n    else if (accumulatedBits === 18) {\n        buffer >>= 2;\n        output += String.fromCharCode((buffer & 0xff00) >> 8);\n        output += String.fromCharCode(buffer & 0xff);\n    }\n    // \"Return output.\"\n    return output;\n}\n/**\n * A lookup table for atob(), which converts an ASCII character to the\n * corresponding six-bit number.\n */\nconst keystr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfunction atobLookup(chr) {\n    const index = keystr.indexOf(chr);\n    // Throw exception if character is not in the lookup string; should not be hit in tests\n    return index < 0 ? undefined : index;\n}\n/**\n * Lookup table for btoa(), which converts a six-bit number into the\n * corresponding ASCII character.\n */\nfunction btoaLookup(idx) {\n    if (idx < 26) {\n        return String.fromCharCode(idx + 'A'.charCodeAt(0));\n    }\n    if (idx < 52) {\n        return String.fromCharCode(idx - 26 + 'a'.charCodeAt(0));\n    }\n    if (idx < 62) {\n        return String.fromCharCode(idx - 52 + '0'.charCodeAt(0));\n    }\n    if (idx === 62) {\n        return '+';\n    }\n    if (idx === 63) {\n        return '/';\n    }\n    // Throw INVALID_CHARACTER_ERR exception here -- won't be hit in the teststring.\n    return undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}