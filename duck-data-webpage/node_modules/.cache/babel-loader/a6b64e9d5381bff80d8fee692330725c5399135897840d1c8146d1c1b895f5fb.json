{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Copyright (c) 2017 Uber Technologies, Inc.\nimport { Vector3 } from \"./vector3.js\";\nimport { formatValue, equals, config, degrees, radians, clamp } from \"../lib/common.js\";\n// @ts-ignore gl-matrix types...\nimport * as vec3 from \"../gl-matrix/vec3.js\";\n// TODO - import epsilon\nconst EPSILON = 0.000001;\nconst EARTH_RADIUS_METERS = 6371000;\n/**\n * The poles (phi) are at the positive and negative y axis.\n * The equator starts at positive z.\n * @link https://en.wikipedia.org/wiki/Spherical_coordinate_system\n */\nexport class SphericalCoordinates {\n  // bearing: number;\n  // pitch: number;\n  // altitude: number;\n  // lnglatZ coordinates\n  // longitude: number;\n  // latitude: number;\n  // lng: number;\n  // lat: number;\n  // z: number;\n  /**\n   * Creates a new SphericalCoordinates object\n   * @param options\n   * @param [options.phi] =0 - rotation around X (latitude)\n   * @param [options.theta] =0 - rotation around Y (longitude)\n   * @param [options.radius] =1 - Distance from center\n   * @param [options.bearing]\n   * @param [options.pitch]\n   * @param [options.altitude]\n   * @param [options.radiusScale] =1\n   */\n  // eslint-disable-next-line complexity\n  constructor({\n    phi = 0,\n    theta = 0,\n    radius = 1,\n    bearing,\n    pitch,\n    altitude,\n    radiusScale = EARTH_RADIUS_METERS\n  } = {}) {\n    this.phi = phi;\n    this.theta = theta;\n    // TODO - silently accepts illegal 0\n    this.radius = radius || altitude || 1; // radial distance from center\n    this.radiusScale = radiusScale || 1; // Used by lngLatZ\n    if (bearing !== undefined) {\n      this.bearing = bearing; // up / down towards top and bottom pole\n    }\n    if (pitch !== undefined) {\n      this.pitch = pitch; // around the equator of the sphere\n    }\n    this.check();\n  }\n  toString() {\n    return this.formatString(config);\n  }\n  formatString({\n    printTypes = false\n  }) {\n    const f = formatValue;\n    return `${printTypes ? 'Spherical' : ''}\\\n[rho:${f(this.radius)},theta:${f(this.theta)},phi:${f(this.phi)}]`;\n  }\n  equals(other) {\n    return equals(this.radius, other.radius) && equals(this.theta, other.theta) && equals(this.phi, other.phi);\n  }\n  exactEquals(other) {\n    return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;\n  }\n  /* eslint-disable brace-style */\n  // Cartographic (bearing 0 north, pitch 0 look from above)\n  get bearing() {\n    return 180 - degrees(this.phi);\n  }\n  set bearing(v) {\n    this.phi = Math.PI - radians(v);\n  }\n  get pitch() {\n    return degrees(this.theta);\n  }\n  set pitch(v) {\n    this.theta = radians(v);\n  }\n  // get pitch() { return 90 - degrees(this.phi); }\n  // set pitch(v) { this.phi = radians(v) + Math.PI / 2; }\n  // get altitude() { return this.radius - 1; } // relative altitude\n  // lnglatZ coordinates\n  get longitude() {\n    return degrees(this.phi);\n  }\n  get latitude() {\n    return degrees(this.theta);\n  }\n  get lng() {\n    return degrees(this.phi);\n  }\n  get lat() {\n    return degrees(this.theta);\n  }\n  get z() {\n    return (this.radius - 1) * this.radiusScale;\n  }\n  /* eslint-enable brace-style */\n  set(radius, phi, theta) {\n    this.radius = radius;\n    this.phi = phi;\n    this.theta = theta;\n    return this.check();\n  }\n  clone() {\n    return new SphericalCoordinates().copy(this);\n  }\n  copy(other) {\n    this.radius = other.radius;\n    this.phi = other.phi;\n    this.theta = other.theta;\n    return this.check();\n  }\n  fromLngLatZ([lng, lat, z]) {\n    this.radius = 1 + z / this.radiusScale;\n    this.phi = radians(lat);\n    this.theta = radians(lng);\n    return this.check();\n  }\n  fromVector3(v) {\n    this.radius = vec3.length(v);\n    if (this.radius > 0) {\n      this.theta = Math.atan2(v[0], v[1]); // equator angle around y-up axis\n      this.phi = Math.acos(clamp(v[2] / this.radius, -1, 1)); // polar angle\n    }\n    return this.check();\n  }\n  toVector3() {\n    return new Vector3(0, 0, this.radius).rotateX({\n      radians: this.theta\n    }).rotateZ({\n      radians: this.phi\n    });\n  }\n  // restrict phi to be betwee EPS and PI-EPS\n  makeSafe() {\n    this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));\n    return this;\n  }\n  check() {\n    // this.makeSafe();\n    if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {\n      throw new Error('SphericalCoordinates: some fields set to invalid numbers');\n    }\n    return this;\n  }\n}","map":{"version":3,"names":["Vector3","formatValue","equals","config","degrees","radians","clamp","vec3","EPSILON","EARTH_RADIUS_METERS","SphericalCoordinates","constructor","phi","theta","radius","bearing","pitch","altitude","radiusScale","undefined","check","toString","formatString","printTypes","f","other","exactEquals","v","Math","PI","longitude","latitude","lng","lat","z","set","clone","copy","fromLngLatZ","fromVector3","length","atan2","acos","toVector3","rotateX","rotateZ","makeSafe","max","min","Number","isFinite","Error"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\core\\src\\classes\\spherical-coordinates.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Copyright (c) 2017 Uber Technologies, Inc.\n\n// Adaptation of THREE.js Spherical class, under MIT license\nimport {NumericArray} from '@math.gl/types';\nimport {Vector3} from './vector3';\nimport {formatValue, equals, config, degrees, radians, clamp} from '../lib/common';\n// @ts-ignore gl-matrix types...\nimport * as vec3 from '../gl-matrix/vec3';\n\ntype SphericalCoordinatesOptions = {\n  phi?: number;\n  theta?: number;\n  radius?: number;\n  bearing?: number;\n  pitch?: number;\n  altitude?: number;\n  radiusScale?: number;\n};\n\ntype FormatOptions = {\n  printTypes?: boolean;\n};\n\n// TODO - import epsilon\nconst EPSILON = 0.000001;\nconst EARTH_RADIUS_METERS = 6371000;\n\n/**\n * The poles (phi) are at the positive and negative y axis.\n * The equator starts at positive z.\n * @link https://en.wikipedia.org/wiki/Spherical_coordinate_system\n */\nexport class SphericalCoordinates {\n  phi: number;\n  theta: number;\n  radius: number;\n  radiusScale: number;\n  // bearing: number;\n  // pitch: number;\n  // altitude: number;\n\n  // lnglatZ coordinates\n  // longitude: number;\n  // latitude: number;\n  // lng: number;\n  // lat: number;\n  // z: number;\n\n  /**\n   * Creates a new SphericalCoordinates object\n   * @param options\n   * @param [options.phi] =0 - rotation around X (latitude)\n   * @param [options.theta] =0 - rotation around Y (longitude)\n   * @param [options.radius] =1 - Distance from center\n   * @param [options.bearing]\n   * @param [options.pitch]\n   * @param [options.altitude]\n   * @param [options.radiusScale] =1\n   */\n  // eslint-disable-next-line complexity\n  constructor({\n    phi = 0,\n    theta = 0,\n    radius = 1,\n    bearing,\n    pitch,\n    altitude,\n    radiusScale = EARTH_RADIUS_METERS\n  }: SphericalCoordinatesOptions = {}) {\n    this.phi = phi;\n    this.theta = theta;\n    // TODO - silently accepts illegal 0\n    this.radius = radius || altitude || 1; // radial distance from center\n    this.radiusScale = radiusScale || 1; // Used by lngLatZ\n    if (bearing !== undefined) {\n      this.bearing = bearing; // up / down towards top and bottom pole\n    }\n    if (pitch !== undefined) {\n      this.pitch = pitch; // around the equator of the sphere\n    }\n    this.check();\n  }\n\n  toString(): string {\n    return this.formatString(config);\n  }\n\n  formatString({printTypes = false}: FormatOptions): string {\n    const f = formatValue;\n    return `${printTypes ? 'Spherical' : ''}\\\n[rho:${f(this.radius)},theta:${f(this.theta)},phi:${f(this.phi)}]`;\n  }\n\n  equals(other: SphericalCoordinates): boolean {\n    return (\n      equals(this.radius, other.radius) &&\n      equals(this.theta, other.theta) &&\n      equals(this.phi, other.phi)\n    );\n  }\n\n  exactEquals(other: SphericalCoordinates): boolean {\n    return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;\n  }\n\n  /* eslint-disable brace-style */\n  // Cartographic (bearing 0 north, pitch 0 look from above)\n  get bearing(): number {\n    return 180 - degrees(this.phi);\n  }\n\n  set bearing(v: number) {\n    this.phi = Math.PI - radians(v);\n  }\n\n  get pitch(): number {\n    return degrees(this.theta);\n  }\n\n  set pitch(v: number) {\n    this.theta = radians(v);\n  }\n\n  // get pitch() { return 90 - degrees(this.phi); }\n  // set pitch(v) { this.phi = radians(v) + Math.PI / 2; }\n  // get altitude() { return this.radius - 1; } // relative altitude\n  // lnglatZ coordinates\n  get longitude(): number {\n    return degrees(this.phi);\n  }\n\n  get latitude(): number {\n    return degrees(this.theta);\n  }\n\n  get lng(): number {\n    return degrees(this.phi);\n  }\n\n  get lat(): number {\n    return degrees(this.theta);\n  }\n\n  get z(): number {\n    return (this.radius - 1) * this.radiusScale;\n  }\n\n  /* eslint-enable brace-style */\n  set(radius: number, phi: number, theta: number): this {\n    this.radius = radius;\n    this.phi = phi;\n    this.theta = theta;\n    return this.check();\n  }\n\n  clone(): SphericalCoordinates {\n    return new SphericalCoordinates().copy(this);\n  }\n\n  copy(other: SphericalCoordinates): this {\n    this.radius = other.radius;\n    this.phi = other.phi;\n    this.theta = other.theta;\n    return this.check();\n  }\n\n  fromLngLatZ([lng, lat, z]: [number, number, number]): this {\n    this.radius = 1 + z / this.radiusScale;\n    this.phi = radians(lat);\n    this.theta = radians(lng);\n    return this.check();\n  }\n\n  fromVector3(v: Readonly<NumericArray>): this {\n    this.radius = vec3.length(v);\n    if (this.radius > 0) {\n      this.theta = Math.atan2(v[0], v[1]); // equator angle around y-up axis\n      this.phi = Math.acos(clamp(v[2] / this.radius, -1, 1)); // polar angle\n    }\n    return this.check();\n  }\n\n  toVector3(): Vector3 {\n    return new Vector3(0, 0, this.radius)\n      .rotateX({radians: this.theta})\n      .rotateZ({radians: this.phi});\n  }\n\n  // restrict phi to be betwee EPS and PI-EPS\n  makeSafe(): this {\n    this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));\n    return this;\n  }\n\n  check(): this {\n    // this.makeSafe();\n    if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {\n      throw new Error('SphericalCoordinates: some fields set to invalid numbers');\n    }\n    return this;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}