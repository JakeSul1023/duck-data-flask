{"ast":null,"code":"import { assert } from \"../utils/assert.js\";\nimport { BYTES, COMPONENTS } from \"../gltf-utils/gltf-constants.js\";\n/**\n * Memory needed to store texture and all mipmap levels 1 + 1/4 + 1/16 + 1/64 + ...\n * Minimum 1.33, but due to GPU layout may be 1.5\n */\nconst MIPMAP_FACTOR = 1.33;\nconst TYPES = ['SCALAR', 'VEC2', 'VEC3', 'VEC4'];\nconst ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]];\nconst ARRAY_TO_COMPONENT_TYPE = new Map(ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT);\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\nconst ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nexport function getAccessorTypeFromSize(size) {\n  const type = TYPES[size - 1];\n  return type || TYPES[0];\n}\nexport function getComponentTypeFromArray(typedArray) {\n  const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);\n  if (!componentType) {\n    throw new Error('Illegal typed array');\n  }\n  return componentType;\n}\nexport function getAccessorArrayTypeAndLength(accessor, bufferView) {\n  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n  const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n  const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];\n  const length = accessor.count * components;\n  const byteLength = accessor.count * components * bytesPerComponent;\n  assert(byteLength >= 0 && byteLength <= bufferView.byteLength);\n  const componentByteSize = BYTES[accessor.componentType];\n  const numberOfComponentsInElement = COMPONENTS[accessor.type];\n  return {\n    ArrayType,\n    length,\n    byteLength,\n    componentByteSize,\n    numberOfComponentsInElement\n  };\n}\n/**\n * Calculate the GPU memory used by a GLTF tile, for both buffer and texture memory\n * @param gltf - the gltf content of a GLTF tile\n * @returns - total memory usage in bytes\n */\nexport function getMemoryUsageGLTF(gltf) {\n  let {\n    images,\n    bufferViews\n  } = gltf;\n  images = images || [];\n  bufferViews = bufferViews || [];\n  const imageBufferViews = images.map(i => i.bufferView);\n  bufferViews = bufferViews.filter(view => !imageBufferViews.includes(view));\n  const bufferMemory = bufferViews.reduce((acc, view) => acc + view.byteLength, 0);\n  // Assume each pixel of the texture is 4 channel with mimmaps (which add 33%)\n  // TODO correctly handle compressed textures\n  const pixelCount = images.reduce((acc, image) => {\n    // @ts-ignore\n    const {\n      width,\n      height\n    } = image.image;\n    return acc + width * height;\n  }, 0);\n  return bufferMemory + Math.ceil(4 * pixelCount * MIPMAP_FACTOR);\n}","map":{"version":3,"names":["assert","BYTES","COMPONENTS","MIPMAP_FACTOR","TYPES","ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT","Int8Array","Uint8Array","Int16Array","Uint16Array","Uint32Array","Float32Array","Float64Array","ARRAY_TO_COMPONENT_TYPE","Map","ATTRIBUTE_TYPE_TO_COMPONENTS","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE","ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY","getAccessorTypeFromSize","size","type","getComponentTypeFromArray","typedArray","componentType","get","constructor","Error","getAccessorArrayTypeAndLength","accessor","bufferView","ArrayType","components","bytesPerComponent","length","count","byteLength","componentByteSize","numberOfComponentsInElement","getMemoryUsageGLTF","gltf","images","bufferViews","imageBufferViews","map","i","filter","view","includes","bufferMemory","reduce","acc","pixelCount","image","width","height","Math","ceil"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/gltf-utils.js"],"sourcesContent":["import { assert } from \"../utils/assert.js\";\nimport { BYTES, COMPONENTS } from \"../gltf-utils/gltf-constants.js\";\n/**\n * Memory needed to store texture and all mipmap levels 1 + 1/4 + 1/16 + 1/64 + ...\n * Minimum 1.33, but due to GPU layout may be 1.5\n */\nconst MIPMAP_FACTOR = 1.33;\nconst TYPES = ['SCALAR', 'VEC2', 'VEC3', 'VEC4'];\nconst ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT = [\n    [Int8Array, 5120],\n    [Uint8Array, 5121],\n    [Int16Array, 5122],\n    [Uint16Array, 5123],\n    [Uint32Array, 5125],\n    [Float32Array, 5126],\n    [Float64Array, 5130]\n];\nconst ARRAY_TO_COMPONENT_TYPE = new Map(ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT);\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16\n};\nconst ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {\n    5120: 1,\n    5121: 1,\n    5122: 2,\n    5123: 2,\n    5125: 4,\n    5126: 4\n};\nconst ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n};\nexport function getAccessorTypeFromSize(size) {\n    const type = TYPES[size - 1];\n    return type || TYPES[0];\n}\nexport function getComponentTypeFromArray(typedArray) {\n    const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);\n    if (!componentType) {\n        throw new Error('Illegal typed array');\n    }\n    return componentType;\n}\nexport function getAccessorArrayTypeAndLength(accessor, bufferView) {\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];\n    const length = accessor.count * components;\n    const byteLength = accessor.count * components * bytesPerComponent;\n    assert(byteLength >= 0 && byteLength <= bufferView.byteLength);\n    const componentByteSize = BYTES[accessor.componentType];\n    const numberOfComponentsInElement = COMPONENTS[accessor.type];\n    return { ArrayType, length, byteLength, componentByteSize, numberOfComponentsInElement };\n}\n/**\n * Calculate the GPU memory used by a GLTF tile, for both buffer and texture memory\n * @param gltf - the gltf content of a GLTF tile\n * @returns - total memory usage in bytes\n */\nexport function getMemoryUsageGLTF(gltf) {\n    let { images, bufferViews } = gltf;\n    images = images || [];\n    bufferViews = bufferViews || [];\n    const imageBufferViews = images.map((i) => i.bufferView);\n    bufferViews = bufferViews.filter((view) => !imageBufferViews.includes(view));\n    const bufferMemory = bufferViews.reduce((acc, view) => acc + view.byteLength, 0);\n    // Assume each pixel of the texture is 4 channel with mimmaps (which add 33%)\n    // TODO correctly handle compressed textures\n    const pixelCount = images.reduce((acc, image) => {\n        // @ts-ignore\n        const { width, height } = image.image;\n        return acc + width * height;\n    }, 0);\n    return bufferMemory + Math.ceil(4 * pixelCount * MIPMAP_FACTOR);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}