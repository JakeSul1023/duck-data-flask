{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default `\\\nin vec4 fillColors;\nin vec4 lineColors;\nin vec3 pickingColors;\nout vec4 vColor;\nstruct PolygonProps {\nvec3 positions;\nvec3 positions64Low;\nvec3 normal;\nfloat elevations;\n};\nvec3 project_offset_normal(vec3 vector) {\nif (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\nproject.coordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\nreturn normalize(vector * project.commonUnitsPerWorldUnit);\n}\nreturn project_normal(vector);\n}\nvoid calculatePosition(PolygonProps props) {\nvec3 pos = props.positions;\nvec3 pos64Low = props.positions64Low;\nvec3 normal = props.normal;\nvec4 colors = solidPolygon.isWireframe ? lineColors : fillColors;\ngeometry.worldPosition = props.positions;\ngeometry.pickingColor = pickingColors;\nif (solidPolygon.extruded) {\npos.z += props.elevations * solidPolygon.elevationScale;\n}\ngl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nif (solidPolygon.extruded) {\n#ifdef IS_SIDE_VERTEX\nnormal = project_offset_normal(normal);\n#else\nnormal = project_normal(normal);\n#endif\ngeometry.normal = normal;\nvec3 lightColor = lighting_getLightColor(colors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\nvColor = vec4(lightColor, colors.a * layer.opacity);\n} else {\nvColor = vec4(colors.rgb, colors.a * layer.opacity);\n}\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;","map":{"version":3,"names":[],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\layers\\src\\solid-polygon-layer\\solid-polygon-layer-vertex-main.glsl.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `\\\n\nin vec4 fillColors;\nin vec4 lineColors;\nin vec3 pickingColors;\n\nout vec4 vColor;\n\nstruct PolygonProps {\n  vec3 positions;\n  vec3 positions64Low;\n  vec3 normal;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    // normals generated by the polygon tesselator are in lnglat offsets instead of meters\n    return normalize(vector * project.commonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n  vec3 pos = props.positions;\n  vec3 pos64Low = props.positions64Low;\n  vec3 normal = props.normal;\n  vec4 colors = solidPolygon.isWireframe ? lineColors : fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.pickingColor = pickingColors;\n\n  if (solidPolygon.extruded) {\n    pos.z += props.elevations * solidPolygon.elevationScale;\n  }\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (solidPolygon.extruded) {\n  #ifdef IS_SIDE_VERTEX\n    normal = project_offset_normal(normal);\n  #else\n    normal = project_normal(normal);\n  #endif\n    geometry.normal = normal;\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\n    vColor = vec4(lightColor, colors.a * layer.opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * layer.opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n"],"mappings":"AAAA;AACA;AACA;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}