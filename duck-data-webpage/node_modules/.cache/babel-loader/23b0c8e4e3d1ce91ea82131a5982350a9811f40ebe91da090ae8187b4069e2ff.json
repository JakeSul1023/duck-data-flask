{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { parseWithWorker, canParseWithWorker, mergeLoaderOptions } from '@loaders.gl/loader-utils';\nimport { assert, validateWorkerVersion } from '@loaders.gl/worker-utils';\nimport { isLoaderObject } from \"../loader-utils/normalize-loader.js\";\nimport { isResponse } from \"../../javascript-utils/is-type.js\";\nimport { normalizeOptions } from \"../loader-utils/option-utils.js\";\nimport { getArrayBufferOrStringFromData } from \"../loader-utils/get-data.js\";\nimport { getLoaderContext, getLoadersFromContext } from \"../loader-utils/loader-context.js\";\nimport { getResourceUrl } from \"../utils/resource-utils.js\";\nimport { selectLoader } from \"./select-loader.js\";\n/**\n * Parses `data` using a specified loader\n * @param data\n * @param loaders\n * @param options\n * @param context\n */\n// implementation signature\nexport async function parse(data, loaders, options, context) {\n  // Signature: parse(data, options, context | url)\n  // Uses registered loaders\n  if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined; // context not supported in short signature\n    options = loaders;\n    loaders = undefined;\n  }\n  data = await data; // Resolve any promise\n  options = options || {}; // Could be invalid...\n  // Extract a url for auto detection\n  const url = getResourceUrl(data);\n  // Chooses a loader (and normalizes it)\n  // Also use any loaders in the context, new loaders take priority\n  const typedLoaders = loaders;\n  const candidateLoaders = getLoadersFromContext(typedLoaders, context);\n  // todo hacky type cast\n  const loader = await selectLoader(data, candidateLoaders, options);\n  // Note: if no loader was found, if so just return null\n  if (!loader) {\n    return null;\n  }\n  // Normalize options\n  // @ts-expect-error\n  options = normalizeOptions(options, loader, candidateLoaders, url); // Could be invalid...\n  // Get a context (if already present, will be unchanged)\n  context = getLoaderContext(\n  // @ts-expect-error\n  {\n    url,\n    _parse: parse,\n    loaders: candidateLoaders\n  }, options, context || null);\n  return await parseWithLoader(loader, data, options, context);\n}\n// TODO: support progress and abort\n// TODO - should accept loader.parseAsyncIterator and concatenate.\nasync function parseWithLoader(loader, data, options, context) {\n  validateWorkerVersion(loader);\n  options = mergeLoaderOptions(loader.options, options);\n  if (isResponse(data)) {\n    // Serialize to support passing the response to web worker\n    const response = data;\n    const {\n      ok,\n      redirected,\n      status,\n      statusText,\n      type,\n      url\n    } = response;\n    const headers = Object.fromEntries(response.headers.entries());\n    // @ts-expect-error TODO - fix this\n    context.response = {\n      headers,\n      ok,\n      redirected,\n      status,\n      statusText,\n      type,\n      url\n    };\n  }\n  data = await getArrayBufferOrStringFromData(data, loader, options);\n  const loaderWithParser = loader;\n  // First check for synchronous text parser, wrap results in promises\n  if (loaderWithParser.parseTextSync && typeof data === 'string') {\n    return loaderWithParser.parseTextSync(data, options, context);\n  }\n  // If we have a workerUrl and the loader can parse the given options efficiently in a worker\n  if (canParseWithWorker(loader, options)) {\n    return await parseWithWorker(loader, data, options, context, parse);\n  }\n  // Check for asynchronous parser\n  if (loaderWithParser.parseText && typeof data === 'string') {\n    return await loaderWithParser.parseText(data, options, context);\n  }\n  if (loaderWithParser.parse) {\n    return await loaderWithParser.parse(data, options, context);\n  }\n  // This should not happen, all sync loaders should also offer `parse` function\n  assert(!loaderWithParser.parseSync);\n  // TBD - If asynchronous parser not available, return null\n  throw new Error(`${loader.id} loader - no parser found and worker is disabled`);\n}","map":{"version":3,"names":["parseWithWorker","canParseWithWorker","mergeLoaderOptions","assert","validateWorkerVersion","isLoaderObject","isResponse","normalizeOptions","getArrayBufferOrStringFromData","getLoaderContext","getLoadersFromContext","getResourceUrl","selectLoader","parse","data","loaders","options","context","Array","isArray","undefined","url","typedLoaders","candidateLoaders","loader","_parse","parseWithLoader","response","ok","redirected","status","statusText","type","headers","Object","fromEntries","entries","loaderWithParser","parseTextSync","parseText","parseSync","Error","id"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/core/dist/lib/api/parse.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { parseWithWorker, canParseWithWorker, mergeLoaderOptions } from '@loaders.gl/loader-utils';\nimport { assert, validateWorkerVersion } from '@loaders.gl/worker-utils';\nimport { isLoaderObject } from \"../loader-utils/normalize-loader.js\";\nimport { isResponse } from \"../../javascript-utils/is-type.js\";\nimport { normalizeOptions } from \"../loader-utils/option-utils.js\";\nimport { getArrayBufferOrStringFromData } from \"../loader-utils/get-data.js\";\nimport { getLoaderContext, getLoadersFromContext } from \"../loader-utils/loader-context.js\";\nimport { getResourceUrl } from \"../utils/resource-utils.js\";\nimport { selectLoader } from \"./select-loader.js\";\n/**\n * Parses `data` using a specified loader\n * @param data\n * @param loaders\n * @param options\n * @param context\n */\n// implementation signature\nexport async function parse(data, loaders, options, context) {\n    // Signature: parse(data, options, context | url)\n    // Uses registered loaders\n    if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {\n        context = undefined; // context not supported in short signature\n        options = loaders;\n        loaders = undefined;\n    }\n    data = await data; // Resolve any promise\n    options = options || {}; // Could be invalid...\n    // Extract a url for auto detection\n    const url = getResourceUrl(data);\n    // Chooses a loader (and normalizes it)\n    // Also use any loaders in the context, new loaders take priority\n    const typedLoaders = loaders;\n    const candidateLoaders = getLoadersFromContext(typedLoaders, context);\n    // todo hacky type cast\n    const loader = await selectLoader(data, candidateLoaders, options);\n    // Note: if no loader was found, if so just return null\n    if (!loader) {\n        return null;\n    }\n    // Normalize options\n    // @ts-expect-error\n    options = normalizeOptions(options, loader, candidateLoaders, url); // Could be invalid...\n    // Get a context (if already present, will be unchanged)\n    context = getLoaderContext(\n    // @ts-expect-error\n    { url, _parse: parse, loaders: candidateLoaders }, options, context || null);\n    return await parseWithLoader(loader, data, options, context);\n}\n// TODO: support progress and abort\n// TODO - should accept loader.parseAsyncIterator and concatenate.\nasync function parseWithLoader(loader, data, options, context) {\n    validateWorkerVersion(loader);\n    options = mergeLoaderOptions(loader.options, options);\n    if (isResponse(data)) {\n        // Serialize to support passing the response to web worker\n        const response = data;\n        const { ok, redirected, status, statusText, type, url } = response;\n        const headers = Object.fromEntries(response.headers.entries());\n        // @ts-expect-error TODO - fix this\n        context.response = { headers, ok, redirected, status, statusText, type, url };\n    }\n    data = await getArrayBufferOrStringFromData(data, loader, options);\n    const loaderWithParser = loader;\n    // First check for synchronous text parser, wrap results in promises\n    if (loaderWithParser.parseTextSync && typeof data === 'string') {\n        return loaderWithParser.parseTextSync(data, options, context);\n    }\n    // If we have a workerUrl and the loader can parse the given options efficiently in a worker\n    if (canParseWithWorker(loader, options)) {\n        return await parseWithWorker(loader, data, options, context, parse);\n    }\n    // Check for asynchronous parser\n    if (loaderWithParser.parseText && typeof data === 'string') {\n        return await loaderWithParser.parseText(data, options, context);\n    }\n    if (loaderWithParser.parse) {\n        return await loaderWithParser.parse(data, options, context);\n    }\n    // This should not happen, all sync loaders should also offer `parse` function\n    assert(!loaderWithParser.parseSync);\n    // TBD - If asynchronous parser not available, return null\n    throw new Error(`${loader.id} loader - no parser found and worker is disabled`);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}