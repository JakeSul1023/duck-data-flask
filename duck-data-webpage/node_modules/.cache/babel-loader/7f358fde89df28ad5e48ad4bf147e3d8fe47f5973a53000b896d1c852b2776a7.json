{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** Generate hook source code */\nexport function getShaderHooks(hookFunctions, hookInjections) {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a, b) => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n  return result;\n}\n/**\n * Parse string based hook functions\n * And split per shader\n */\nexport function normalizeShaderHooks(hookFunctions) {\n  const result = {\n    vertex: {},\n    fragment: {}\n  };\n  for (const hookFunction of hookFunctions) {\n    let opts;\n    let hook;\n    if (typeof hookFunction !== 'string') {\n      opts = hookFunction;\n      hook = opts.hook;\n    } else {\n      opts = {};\n      hook = hookFunction;\n    }\n    hook = hook.trim();\n    const [shaderStage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    const normalizedHook = Object.assign(opts, {\n      signature\n    });\n    switch (shaderStage) {\n      case 'vs':\n        result.vertex[name] = normalizedHook;\n        break;\n      case 'fs':\n        result.fragment[name] = normalizedHook;\n        break;\n      default:\n        throw new Error(shaderStage);\n    }\n  }\n  return result;\n}\n//# sourceMappingURL=shader-hooks.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}