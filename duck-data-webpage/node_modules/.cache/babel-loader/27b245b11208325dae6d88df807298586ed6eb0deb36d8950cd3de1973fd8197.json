{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Buffer, getVertexFormatFromAttribute } from '@luma.gl/core';\nimport { uid } from \"../utils/uid.js\";\nexport class GPUGeometry {\n  id;\n  userData = {};\n  /** Determines how vertices are read from the 'vertex' attributes */\n  topology;\n  bufferLayout = [];\n  vertexCount;\n  indices;\n  attributes;\n  constructor(props) {\n    this.id = props.id || uid('geometry');\n    this.topology = props.topology;\n    this.indices = props.indices || null;\n    this.attributes = props.attributes;\n    this.vertexCount = props.vertexCount;\n    this.bufferLayout = props.bufferLayout || [];\n    if (this.indices) {\n      if (!(this.indices.usage & Buffer.INDEX)) {\n        throw new Error('Index buffer must have INDEX usage');\n      }\n    }\n  }\n  destroy() {\n    this.indices?.destroy();\n    for (const attribute of Object.values(this.attributes)) {\n      attribute.destroy();\n    }\n  }\n  getVertexCount() {\n    return this.vertexCount;\n  }\n  getAttributes() {\n    return this.attributes;\n  }\n  getIndexes() {\n    return this.indices || null;\n  }\n  _calculateVertexCount(positions) {\n    // Assume that positions is a fully packed float32x3 buffer\n    const vertexCount = positions.byteLength / 12;\n    return vertexCount;\n  }\n}\nexport function makeGPUGeometry(device, geometry) {\n  if (geometry instanceof GPUGeometry) {\n    return geometry;\n  }\n  const indices = getIndexBufferFromGeometry(device, geometry);\n  const {\n    attributes,\n    bufferLayout\n  } = getAttributeBuffersFromGeometry(device, geometry);\n  return new GPUGeometry({\n    topology: geometry.topology || 'triangle-list',\n    bufferLayout,\n    vertexCount: geometry.vertexCount,\n    indices,\n    attributes\n  });\n}\nexport function getIndexBufferFromGeometry(device, geometry) {\n  if (!geometry.indices) {\n    return undefined;\n  }\n  const data = geometry.indices.value;\n  return device.createBuffer({\n    usage: Buffer.INDEX,\n    data\n  });\n}\nexport function getAttributeBuffersFromGeometry(device, geometry) {\n  const bufferLayout = [];\n  const attributes = {};\n  for (const [attributeName, attribute] of Object.entries(geometry.attributes)) {\n    let name = attributeName;\n    // TODO Map some GLTF attribute names (is this still needed?)\n    switch (attributeName) {\n      case 'POSITION':\n        name = 'positions';\n        break;\n      case 'NORMAL':\n        name = 'normals';\n        break;\n      case 'TEXCOORD_0':\n        name = 'texCoords';\n        break;\n      case 'COLOR_0':\n        name = 'colors';\n        break;\n    }\n    if (attribute) {\n      attributes[name] = device.createBuffer({\n        data: attribute.value,\n        id: `${attributeName}-buffer`\n      });\n      const {\n        value,\n        size,\n        normalized\n      } = attribute;\n      // @ts-expect-error\n      bufferLayout.push({\n        name,\n        format: getVertexFormatFromAttribute(value, size, normalized)\n      });\n    }\n  }\n  const vertexCount = geometry._calculateVertexCount(geometry.attributes, geometry.indices);\n  return {\n    attributes,\n    bufferLayout,\n    vertexCount\n  };\n}","map":{"version":3,"names":["Buffer","getVertexFormatFromAttribute","uid","GPUGeometry","id","userData","topology","bufferLayout","vertexCount","indices","attributes","constructor","props","usage","INDEX","Error","destroy","attribute","Object","values","getVertexCount","getAttributes","getIndexes","_calculateVertexCount","positions","byteLength","makeGPUGeometry","device","geometry","getIndexBufferFromGeometry","getAttributeBuffersFromGeometry","undefined","data","value","createBuffer","attributeName","entries","name","size","normalized","push","format"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\engine\\src\\geometry\\gpu-geometry.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {PrimitiveTopology, BufferLayout} from '@luma.gl/core';\nimport {Device, Buffer, getVertexFormatFromAttribute} from '@luma.gl/core';\nimport type {Geometry} from '../geometry/geometry';\nimport {uid} from '../utils/uid';\n\nexport type GPUGeometryProps = {\n  id?: string;\n  /** Determines how vertices are read from the 'vertex' attributes */\n  topology: 'point-list' | 'line-list' | 'line-strip' | 'triangle-list' | 'triangle-strip';\n  /** Auto calculated from attributes if not provided */\n  vertexCount: number;\n  bufferLayout: BufferLayout[];\n  indices?: Buffer | null;\n  attributes: Record<string, Buffer>;\n};\n\nexport class GPUGeometry {\n  readonly id: string;\n  userData: Record<string, unknown> = {};\n\n  /** Determines how vertices are read from the 'vertex' attributes */\n  readonly topology?: PrimitiveTopology;\n  readonly bufferLayout: BufferLayout[] = [];\n\n  readonly vertexCount: number;\n  readonly indices?: Buffer | null;\n  readonly attributes: Record<string, Buffer>;\n\n  constructor(props: GPUGeometryProps) {\n    this.id = props.id || uid('geometry');\n    this.topology = props.topology;\n    this.indices = props.indices || null;\n    this.attributes = props.attributes;\n\n    this.vertexCount = props.vertexCount;\n\n    this.bufferLayout = props.bufferLayout || [];\n\n    if (this.indices) {\n      if (!(this.indices.usage & Buffer.INDEX)) {\n        throw new Error('Index buffer must have INDEX usage');\n      }\n    }\n  }\n\n  destroy(): void {\n    this.indices?.destroy();\n    for (const attribute of Object.values(this.attributes)) {\n      attribute.destroy();\n    }\n  }\n\n  getVertexCount(): number {\n    return this.vertexCount;\n  }\n\n  getAttributes(): Record<string, Buffer> {\n    return this.attributes;\n  }\n\n  getIndexes(): Buffer | null {\n    return this.indices || null;\n  }\n\n  _calculateVertexCount(positions: Buffer): number {\n    // Assume that positions is a fully packed float32x3 buffer\n    const vertexCount = positions.byteLength / 12;\n    return vertexCount;\n  }\n}\n\nexport function makeGPUGeometry(device: Device, geometry: Geometry | GPUGeometry): GPUGeometry {\n  if (geometry instanceof GPUGeometry) {\n    return geometry;\n  }\n\n  const indices = getIndexBufferFromGeometry(device, geometry);\n  const {attributes, bufferLayout} = getAttributeBuffersFromGeometry(device, geometry);\n  return new GPUGeometry({\n    topology: geometry.topology || 'triangle-list',\n    bufferLayout,\n    vertexCount: geometry.vertexCount,\n    indices,\n    attributes\n  });\n}\n\nexport function getIndexBufferFromGeometry(device: Device, geometry: Geometry): Buffer | undefined {\n  if (!geometry.indices) {\n    return undefined;\n  }\n  const data = geometry.indices.value;\n  return device.createBuffer({usage: Buffer.INDEX, data});\n}\n\nexport function getAttributeBuffersFromGeometry(\n  device: Device,\n  geometry: Geometry\n): {attributes: Record<string, Buffer>; bufferLayout: BufferLayout[]; vertexCount: number} {\n  const bufferLayout: BufferLayout[] = [];\n\n  const attributes: Record<string, Buffer> = {};\n  for (const [attributeName, attribute] of Object.entries(geometry.attributes)) {\n    let name: string = attributeName;\n    // TODO Map some GLTF attribute names (is this still needed?)\n    switch (attributeName) {\n      case 'POSITION':\n        name = 'positions';\n        break;\n      case 'NORMAL':\n        name = 'normals';\n        break;\n      case 'TEXCOORD_0':\n        name = 'texCoords';\n        break;\n      case 'COLOR_0':\n        name = 'colors';\n        break;\n    }\n    if (attribute) {\n      attributes[name] = device.createBuffer({\n        data: attribute.value,\n        id: `${attributeName}-buffer`\n      });\n      const {value, size, normalized} = attribute;\n      // @ts-expect-error\n      bufferLayout.push({name, format: getVertexFormatFromAttribute(value, size, normalized)});\n    }\n  }\n\n  const vertexCount = geometry._calculateVertexCount(geometry.attributes, geometry.indices);\n\n  return {attributes, bufferLayout, vertexCount};\n}\n"],"mappings":"AAAA;AACA;AACA;AAGA,SAAgBA,MAAM,EAAEC,4BAA4B,QAAO,eAAe;AAE1E,SAAQC,GAAG,QAAC;AAaZ,OAAM,MAAOC,WAAW;EACbC,EAAE;EACXC,QAAQ,GAA4B,EAAE;EAEtC;EACSC,QAAQ;EACRC,YAAY,GAAmB,EAAE;EAEjCC,WAAW;EACXC,OAAO;EACPC,UAAU;EAEnBC,YAAYC,KAAuB;IACjC,IAAI,CAACR,EAAE,GAAGQ,KAAK,CAACR,EAAE,IAAIF,GAAG,CAAC,UAAU,CAAC;IACrC,IAAI,CAACI,QAAQ,GAAGM,KAAK,CAACN,QAAQ;IAC9B,IAAI,CAACG,OAAO,GAAGG,KAAK,CAACH,OAAO,IAAI,IAAI;IACpC,IAAI,CAACC,UAAU,GAAGE,KAAK,CAACF,UAAU;IAElC,IAAI,CAACF,WAAW,GAAGI,KAAK,CAACJ,WAAW;IAEpC,IAAI,CAACD,YAAY,GAAGK,KAAK,CAACL,YAAY,IAAI,EAAE;IAE5C,IAAI,IAAI,CAACE,OAAO,EAAE;MAChB,IAAI,EAAE,IAAI,CAACA,OAAO,CAACI,KAAK,GAAGb,MAAM,CAACc,KAAK,CAAC,EAAE;QACxC,MAAM,IAAIC,KAAK,CAAC,oCAAoC,CAAC;MACvD;IACF;EACF;EAEAC,OAAOA,CAAA;IACL,IAAI,CAACP,OAAO,EAAEO,OAAO,EAAE;IACvB,KAAK,MAAMC,SAAS,IAAIC,MAAM,CAACC,MAAM,CAAC,IAAI,CAACT,UAAU,CAAC,EAAE;MACtDO,SAAS,CAACD,OAAO,EAAE;IACrB;EACF;EAEAI,cAAcA,CAAA;IACZ,OAAO,IAAI,CAACZ,WAAW;EACzB;EAEAa,aAAaA,CAAA;IACX,OAAO,IAAI,CAACX,UAAU;EACxB;EAEAY,UAAUA,CAAA;IACR,OAAO,IAAI,CAACb,OAAO,IAAI,IAAI;EAC7B;EAEAc,qBAAqBA,CAACC,SAAiB;IACrC;IACA,MAAMhB,WAAW,GAAGgB,SAAS,CAACC,UAAU,GAAG,EAAE;IAC7C,OAAOjB,WAAW;EACpB;;AAGF,OAAM,SAAUkB,eAAeA,CAACC,MAAc,EAAEC,QAAgC;EAC9E,IAAIA,QAAQ,YAAYzB,WAAW,EAAE;IACnC,OAAOyB,QAAQ;EACjB;EAEA,MAAMnB,OAAO,GAAGoB,0BAA0B,CAACF,MAAM,EAAEC,QAAQ,CAAC;EAC5D,MAAM;IAAClB,UAAU;IAAEH;EAAY,CAAC,GAAGuB,+BAA+B,CAACH,MAAM,EAAEC,QAAQ,CAAC;EACpF,OAAO,IAAIzB,WAAW,CAAC;IACrBG,QAAQ,EAAEsB,QAAQ,CAACtB,QAAQ,IAAI,eAAe;IAC9CC,YAAY;IACZC,WAAW,EAAEoB,QAAQ,CAACpB,WAAW;IACjCC,OAAO;IACPC;GACD,CAAC;AACJ;AAEA,OAAM,SAAUmB,0BAA0BA,CAACF,MAAc,EAAEC,QAAkB;EAC3E,IAAI,CAACA,QAAQ,CAACnB,OAAO,EAAE;IACrB,OAAOsB,SAAS;EAClB;EACA,MAAMC,IAAI,GAAGJ,QAAQ,CAACnB,OAAO,CAACwB,KAAK;EACnC,OAAON,MAAM,CAACO,YAAY,CAAC;IAACrB,KAAK,EAAEb,MAAM,CAACc,KAAK;IAAEkB;EAAI,CAAC,CAAC;AACzD;AAEA,OAAM,SAAUF,+BAA+BA,CAC7CH,MAAc,EACdC,QAAkB;EAElB,MAAMrB,YAAY,GAAmB,EAAE;EAEvC,MAAMG,UAAU,GAA2B,EAAE;EAC7C,KAAK,MAAM,CAACyB,aAAa,EAAElB,SAAS,CAAC,IAAIC,MAAM,CAACkB,OAAO,CAACR,QAAQ,CAAClB,UAAU,CAAC,EAAE;IAC5E,IAAI2B,IAAI,GAAWF,aAAa;IAChC;IACA,QAAQA,aAAa;MACnB,KAAK,UAAU;QACbE,IAAI,GAAG,WAAW;QAClB;MACF,KAAK,QAAQ;QACXA,IAAI,GAAG,SAAS;QAChB;MACF,KAAK,YAAY;QACfA,IAAI,GAAG,WAAW;QAClB;MACF,KAAK,SAAS;QACZA,IAAI,GAAG,QAAQ;QACf;IACJ;IACA,IAAIpB,SAAS,EAAE;MACbP,UAAU,CAAC2B,IAAI,CAAC,GAAGV,MAAM,CAACO,YAAY,CAAC;QACrCF,IAAI,EAAEf,SAAS,CAACgB,KAAK;QACrB7B,EAAE,EAAE,GAAG+B,aAAa;OACrB,CAAC;MACF,MAAM;QAACF,KAAK;QAAEK,IAAI;QAAEC;MAAU,CAAC,GAAGtB,SAAS;MAC3C;MACAV,YAAY,CAACiC,IAAI,CAAC;QAACH,IAAI;QAAEI,MAAM,EAAExC,4BAA4B,CAACgC,KAAK,EAAEK,IAAI,EAAEC,UAAU;MAAC,CAAC,CAAC;IAC1F;EACF;EAEA,MAAM/B,WAAW,GAAGoB,QAAQ,CAACL,qBAAqB,CAACK,QAAQ,CAAClB,UAAU,EAAEkB,QAAQ,CAACnB,OAAO,CAAC;EAEzF,OAAO;IAACC,UAAU;IAAEH,YAAY;IAAEC;EAAW,CAAC;AAChD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}