{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { assert } from '@loaders.gl/loader-utils';\nimport { GL_EXTENSIONS_CONSTANTS } from \"../gl-extensions.js\";\nimport { extractMipmapImages } from \"../utils/extract-mipmap-images.js\";\nconst DDS_CONSTANTS = {\n  MAGIC_NUMBER: 0x20534444,\n  HEADER_LENGTH: 31,\n  MAGIC_NUMBER_INDEX: 0,\n  HEADER_SIZE_INDEX: 1,\n  HEADER_FLAGS_INDEX: 2,\n  HEADER_HEIGHT_INDEX: 3,\n  HEADER_WIDTH_INDEX: 4,\n  MIPMAPCOUNT_INDEX: 7,\n  HEADER_PF_FLAGS_INDEX: 20,\n  HEADER_PF_FOURCC_INDEX: 21,\n  DDSD_MIPMAPCOUNT: 0x20000,\n  DDPF_FOURCC: 0x4\n};\nconst DDS_PIXEL_FORMATS = {\n  DXT1: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,\n  DXT3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n  DXT5: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n  'ATC ': GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ATC_WEBGL,\n  ATCA: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,\n  ATCI: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\n};\nconst getATCLevelSize = getDxt1LevelSize;\nconst getATCALevelSize = getDxtXLevelSize;\nconst getATCILevelSize = getDxtXLevelSize;\nconst DDS_SIZE_FUNCTIONS = {\n  DXT1: getDxt1LevelSize,\n  DXT3: getDxtXLevelSize,\n  DXT5: getDxtXLevelSize,\n  'ATC ': getATCLevelSize,\n  ATCA: getATCALevelSize,\n  ATCI: getATCILevelSize\n};\n/**\n * Check if data is in \"DDS\" format by its magic number\n * @param data - binary data of compressed texture\n * @returns true - data in \"DDS\" format, else - false\n */\nexport function isDDS(data) {\n  const header = new Uint32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);\n  const magic = header[DDS_CONSTANTS.MAGIC_NUMBER_INDEX];\n  return magic === DDS_CONSTANTS.MAGIC_NUMBER;\n}\n/**\n * Parse texture data as \"DDS\" format\n * @param data - binary data of compressed texture\n * @returns Array of the texture levels\n */\nexport function parseDDS(data) {\n  const header = new Int32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);\n  const pixelFormatNumber = header[DDS_CONSTANTS.HEADER_PF_FOURCC_INDEX];\n  assert(Boolean(header[DDS_CONSTANTS.HEADER_PF_FLAGS_INDEX] & DDS_CONSTANTS.DDPF_FOURCC), 'DDS: Unsupported format, must contain a FourCC code');\n  const fourCC = int32ToFourCC(pixelFormatNumber);\n  const internalFormat = DDS_PIXEL_FORMATS[fourCC];\n  const sizeFunction = DDS_SIZE_FUNCTIONS[fourCC];\n  assert(internalFormat && sizeFunction, `DDS: Unknown pixel format ${pixelFormatNumber}`);\n  let mipMapLevels = 1;\n  if (header[DDS_CONSTANTS.HEADER_FLAGS_INDEX] & DDS_CONSTANTS.DDSD_MIPMAPCOUNT) {\n    mipMapLevels = Math.max(1, header[DDS_CONSTANTS.MIPMAPCOUNT_INDEX]);\n  }\n  const width = header[DDS_CONSTANTS.HEADER_WIDTH_INDEX];\n  const height = header[DDS_CONSTANTS.HEADER_HEIGHT_INDEX];\n  const dataOffset = header[DDS_CONSTANTS.HEADER_SIZE_INDEX] + 4;\n  const image = new Uint8Array(data, dataOffset);\n  return extractMipmapImages(image, {\n    mipMapLevels,\n    width,\n    height,\n    sizeFunction,\n    internalFormat\n  });\n}\n/**\n * DXT1 applicable function to calculate level size\n * @param width - level width\n * @param height - level height\n * @returns level size in bytes\n */\nexport function getDxt1LevelSize(width, height) {\n  return (width + 3 >> 2) * (height + 3 >> 2) * 8;\n}\n/**\n * DXT3 & DXT5 applicable function to calculate level size\n * @param width - level width\n * @param height - level height\n * @returns level size in bytes\n */\nexport function getDxtXLevelSize(width, height) {\n  return (width + 3 >> 2) * (height + 3 >> 2) * 16;\n}\n/**\n * Convert every byte of Int32 value to char\n * @param value - Int32 number\n * @returns string of 4 characters\n */\nfunction int32ToFourCC(value) {\n  return String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);\n}","map":{"version":3,"names":["assert","GL_EXTENSIONS_CONSTANTS","extractMipmapImages","DDS_CONSTANTS","MAGIC_NUMBER","HEADER_LENGTH","MAGIC_NUMBER_INDEX","HEADER_SIZE_INDEX","HEADER_FLAGS_INDEX","HEADER_HEIGHT_INDEX","HEADER_WIDTH_INDEX","MIPMAPCOUNT_INDEX","HEADER_PF_FLAGS_INDEX","HEADER_PF_FOURCC_INDEX","DDSD_MIPMAPCOUNT","DDPF_FOURCC","DDS_PIXEL_FORMATS","DXT1","COMPRESSED_RGB_S3TC_DXT1_EXT","DXT3","COMPRESSED_RGBA_S3TC_DXT3_EXT","DXT5","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_ATC_WEBGL","ATCA","COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL","ATCI","COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL","getATCLevelSize","getDxt1LevelSize","getATCALevelSize","getDxtXLevelSize","getATCILevelSize","DDS_SIZE_FUNCTIONS","isDDS","data","header","Uint32Array","magic","parseDDS","Int32Array","pixelFormatNumber","Boolean","fourCC","int32ToFourCC","internalFormat","sizeFunction","mipMapLevels","Math","max","width","height","dataOffset","image","Uint8Array","value","String","fromCharCode"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/textures/dist/lib/parsers/parse-dds.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { assert } from '@loaders.gl/loader-utils';\nimport { GL_EXTENSIONS_CONSTANTS } from \"../gl-extensions.js\";\nimport { extractMipmapImages } from \"../utils/extract-mipmap-images.js\";\nconst DDS_CONSTANTS = {\n    MAGIC_NUMBER: 0x20534444,\n    HEADER_LENGTH: 31,\n    MAGIC_NUMBER_INDEX: 0,\n    HEADER_SIZE_INDEX: 1,\n    HEADER_FLAGS_INDEX: 2,\n    HEADER_HEIGHT_INDEX: 3,\n    HEADER_WIDTH_INDEX: 4,\n    MIPMAPCOUNT_INDEX: 7,\n    HEADER_PF_FLAGS_INDEX: 20,\n    HEADER_PF_FOURCC_INDEX: 21,\n    DDSD_MIPMAPCOUNT: 0x20000,\n    DDPF_FOURCC: 0x4\n};\nconst DDS_PIXEL_FORMATS = {\n    DXT1: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,\n    DXT3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n    DXT5: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n    'ATC ': GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ATC_WEBGL,\n    ATCA: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,\n    ATCI: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\n};\nconst getATCLevelSize = getDxt1LevelSize;\nconst getATCALevelSize = getDxtXLevelSize;\nconst getATCILevelSize = getDxtXLevelSize;\nconst DDS_SIZE_FUNCTIONS = {\n    DXT1: getDxt1LevelSize,\n    DXT3: getDxtXLevelSize,\n    DXT5: getDxtXLevelSize,\n    'ATC ': getATCLevelSize,\n    ATCA: getATCALevelSize,\n    ATCI: getATCILevelSize\n};\n/**\n * Check if data is in \"DDS\" format by its magic number\n * @param data - binary data of compressed texture\n * @returns true - data in \"DDS\" format, else - false\n */\nexport function isDDS(data) {\n    const header = new Uint32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);\n    const magic = header[DDS_CONSTANTS.MAGIC_NUMBER_INDEX];\n    return magic === DDS_CONSTANTS.MAGIC_NUMBER;\n}\n/**\n * Parse texture data as \"DDS\" format\n * @param data - binary data of compressed texture\n * @returns Array of the texture levels\n */\nexport function parseDDS(data) {\n    const header = new Int32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);\n    const pixelFormatNumber = header[DDS_CONSTANTS.HEADER_PF_FOURCC_INDEX];\n    assert(Boolean(header[DDS_CONSTANTS.HEADER_PF_FLAGS_INDEX] & DDS_CONSTANTS.DDPF_FOURCC), 'DDS: Unsupported format, must contain a FourCC code');\n    const fourCC = int32ToFourCC(pixelFormatNumber);\n    const internalFormat = DDS_PIXEL_FORMATS[fourCC];\n    const sizeFunction = DDS_SIZE_FUNCTIONS[fourCC];\n    assert(internalFormat && sizeFunction, `DDS: Unknown pixel format ${pixelFormatNumber}`);\n    let mipMapLevels = 1;\n    if (header[DDS_CONSTANTS.HEADER_FLAGS_INDEX] & DDS_CONSTANTS.DDSD_MIPMAPCOUNT) {\n        mipMapLevels = Math.max(1, header[DDS_CONSTANTS.MIPMAPCOUNT_INDEX]);\n    }\n    const width = header[DDS_CONSTANTS.HEADER_WIDTH_INDEX];\n    const height = header[DDS_CONSTANTS.HEADER_HEIGHT_INDEX];\n    const dataOffset = header[DDS_CONSTANTS.HEADER_SIZE_INDEX] + 4;\n    const image = new Uint8Array(data, dataOffset);\n    return extractMipmapImages(image, {\n        mipMapLevels,\n        width,\n        height,\n        sizeFunction,\n        internalFormat\n    });\n}\n/**\n * DXT1 applicable function to calculate level size\n * @param width - level width\n * @param height - level height\n * @returns level size in bytes\n */\nexport function getDxt1LevelSize(width, height) {\n    return ((width + 3) >> 2) * ((height + 3) >> 2) * 8;\n}\n/**\n * DXT3 & DXT5 applicable function to calculate level size\n * @param width - level width\n * @param height - level height\n * @returns level size in bytes\n */\nexport function getDxtXLevelSize(width, height) {\n    return ((width + 3) >> 2) * ((height + 3) >> 2) * 16;\n}\n/**\n * Convert every byte of Int32 value to char\n * @param value - Int32 number\n * @returns string of 4 characters\n */\nfunction int32ToFourCC(value) {\n    return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}