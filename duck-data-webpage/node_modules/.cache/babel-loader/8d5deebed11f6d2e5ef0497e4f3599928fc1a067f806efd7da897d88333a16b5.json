{"ast":null,"code":"// View and Projection Matrix calculations for mapbox-js style map view properties\nimport { createMat4 } from \"./math-utils.js\";\nimport { zoomToScale, pixelsToWorld, lngLatToWorld, worldToLngLat, worldToPixels, altitudeToFovy, fovyToAltitude, DEFAULT_ALTITUDE, getProjectionMatrix, getDistanceScales, getViewMatrix } from \"./web-mercator-utils.js\";\nimport { fitBounds } from \"./fit-bounds.js\";\nimport { getBounds } from \"./get-bounds.js\";\nimport { mat4, vec2, vec3 } from '@math.gl/core';\n/**\n * The WebMercatorViewport class creates\n * - view/projection matrices\n * - \"uniform values\" (for shaders) from mercator params\n *\n * Note: Instances are immutable in the sense that they only have accessors.\n * A new viewport instance should be created if any parameters have changed.\n */\nexport class WebMercatorViewport {\n  /**\n   * @classdesc\n   * Creates view/projection matrices from mercator params\n   * Note: The Viewport is immutable in the sense that it only has accessors.\n   * A new viewport instance should be created if any parameters have changed.\n   */\n  // eslint-disable-next-line max-statements\n  constructor(props = {\n    width: 1,\n    height: 1\n  }) {\n    /** Two viewports are equal if width and height are identical, and if\n     * their view and projection matrices are (approximately) equal.\n     */\n    this.equals = viewport => {\n      if (!(viewport instanceof WebMercatorViewport)) {\n        return false;\n      }\n      return viewport.width === this.width && viewport.height === this.height && mat4.equals(viewport.projectionMatrix, this.projectionMatrix) && mat4.equals(viewport.viewMatrix, this.viewMatrix);\n    };\n    /**\n     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n     * using viewport projection parameters\n     * - [longitude, latitude] to [x, y]\n     * - [longitude, latitude, Z] => [x, y, z]\n     * Note: By default, returns top-left coordinates for canvas/SVG type render\n     *\n     * @param lngLatZ - [lng, lat] or [lng, lat, Z]\n     * @param options - options\n     * @param options.topLeft=true - Whether projected coords are top left\n     * @return - screen coordinates [x, y] or [x, y, z], z as pixel depth\n     */\n    this.project = (lngLatZ, options = {}) => {\n      const {\n        topLeft = true\n      } = options;\n      const worldPosition = this.projectPosition(lngLatZ);\n      const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n      const [x, y] = coord;\n      const y2 = topLeft ? y : this.height - y;\n      return lngLatZ.length === 2 ? [x, y2] : [x, y2, coord[2]];\n    };\n    /**\n     * Unproject pixel coordinates on screen onto world coordinates, possibly `[lon, lat]` on map.\n     *\n     * - [x, y] => [lng, lat]\n     * - [x, y, z] => [lng, lat, Z]\n     *\n     * @param xyz - screen coordinates, z as pixel depth\n     * @param options - options\n     * @param options.topLeft=true - Whether projected coords are top left\n     * @param options.targetZ=0 - If pixel depth is unknown, targetZ is used as\n     *   the elevation plane to unproject onto\n     * @return - [lng, lat, Z] or [X, Y, Z]\n     */\n    this.unproject = (xyz, options = {}) => {\n      const {\n        topLeft = true,\n        targetZ = undefined\n      } = options;\n      const [x, y, z] = xyz;\n      const y2 = topLeft ? y : this.height - y;\n      const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n      const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n      const [X, Y, Z] = this.unprojectPosition(coord);\n      if (Number.isFinite(z)) {\n        return [X, Y, Z];\n      }\n      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n    };\n    // NON_LINEAR PROJECTION HOOKS\n    // Used for web meractor projection\n    this.projectPosition = xyz => {\n      const [X, Y] = lngLatToWorld(xyz);\n      const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n      return [X, Y, Z];\n    };\n    this.unprojectPosition = xyz => {\n      const [X, Y] = worldToLngLat(xyz);\n      const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n      return [X, Y, Z];\n    };\n    let {\n      // Map state\n      width,\n      height,\n      altitude = null,\n      fovy = null\n    } = props;\n    const {\n      latitude = 0,\n      longitude = 0,\n      zoom = 0,\n      pitch = 0,\n      bearing = 0,\n      position = null,\n      nearZMultiplier = 0.02,\n      farZMultiplier = 1.01\n    } = props;\n    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc\n    width = width || 1;\n    height = height || 1;\n    // `fovy` & `altitude` are independent parameters, one for the\n    // projection and the latter for the view matrix. In the past,\n    // the `fovy` was always derived from the `altitude`\n    if (fovy === null && altitude === null) {\n      altitude = DEFAULT_ALTITUDE;\n      fovy = altitudeToFovy(altitude);\n    } else if (fovy === null) {\n      fovy = altitudeToFovy(altitude);\n    } else if (altitude === null) {\n      altitude = fovyToAltitude(fovy);\n    }\n    const scale = zoomToScale(zoom);\n    // Altitude - prevent division by 0\n    // TODO - just throw an Error instead?\n    altitude = Math.max(0.75, altitude);\n    const distanceScales = getDistanceScales({\n      longitude,\n      latitude\n    });\n    const center = lngLatToWorld([longitude, latitude]);\n    center.push(0);\n    if (position) {\n      vec3.add(center, center, vec3.mul([], position, distanceScales.unitsPerMeter));\n    }\n    this.projectionMatrix = getProjectionMatrix({\n      width,\n      height,\n      scale,\n      center,\n      pitch,\n      fovy,\n      nearZMultiplier,\n      farZMultiplier\n    });\n    this.viewMatrix = getViewMatrix({\n      height,\n      scale,\n      center,\n      pitch,\n      bearing,\n      altitude\n    });\n    // Save parameters\n    this.width = width;\n    this.height = height;\n    this.scale = scale;\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.zoom = zoom;\n    this.pitch = pitch;\n    this.bearing = bearing;\n    this.altitude = altitude;\n    this.fovy = fovy;\n    this.center = center;\n    this.meterOffset = position || [0, 0, 0];\n    this.distanceScales = distanceScales;\n    this._initMatrices();\n    Object.freeze(this);\n  }\n  _initMatrices() {\n    const {\n      width,\n      height,\n      projectionMatrix,\n      viewMatrix\n    } = this;\n    // Note: As usual, matrix operations should be applied in \"reverse\" order\n    // since vectors will be multiplied in from the right during transformation\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, projectionMatrix);\n    mat4.multiply(vpm, vpm, viewMatrix);\n    this.viewProjectionMatrix = vpm;\n    // Calculate matrices and scales needed for projection\n    /**\n     * Builds matrices that converts preprojected lngLats to screen pixels\n     * and vice versa.\n     * Note: Currently returns bottom-left coordinates!\n     * Note: Starts with the GL projection matrix and adds steps to the\n     *       scale and translate that matrix onto the window.\n     * Note: WebGL controls clip space to screen projection with gl.viewport\n     *       and does not need this step.\n     */\n    const m = createMat4();\n    // matrix for conversion from location to screen coordinates\n    mat4.scale(m, m, [width / 2, -height / 2, 1]);\n    mat4.translate(m, m, [1, -1, 0]);\n    mat4.multiply(m, m, vpm);\n    const mInverse = mat4.invert(createMat4(), m);\n    if (!mInverse) {\n      throw new Error('Pixel project matrix not invertible');\n    }\n    this.pixelProjectionMatrix = m;\n    this.pixelUnprojectionMatrix = mInverse;\n  }\n  /**\n   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n   * Performs the nonlinear part of the web mercator projection.\n   * Remaining projection is done with 4x4 matrices which also handles\n   * perspective.\n   *\n   * @param lngLat - [lng, lat] coordinates\n   *   Specifies a point on the sphere to project onto the map.\n   * @return [x,y] coordinates.\n   */\n  projectFlat(lngLat) {\n    return lngLatToWorld(lngLat);\n  }\n  /**\n   * Unproject world point [x,y] on map onto {lat, lon} on sphere\n   *\n   * @param xy - array with [x,y] members\n   *  representing point on projected map plane\n   * @return - array with [lat,lon] of point on sphere.\n   *   Has toArray method if you need a GeoJSON Array.\n   *   Per cartographic tradition, lat and lon are specified as degrees.\n   */\n  unprojectFlat(xy) {\n    return worldToLngLat(xy);\n  }\n  /**\n   * Get the map center that place a given [lng, lat] coordinate at screen point [x, y]\n   * @param opt\n   * @param opt.lngLat - [lng,lat] coordinates\n   *   Specifies a point on the sphere.\n   * @param opt.pos - [x,y] coordinates\n   *   Specifies a point on the screen.\n   * @return [lng,lat] new map center.\n   */\n  getMapCenterByLngLatPosition({\n    lngLat,\n    pos\n  }) {\n    const fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);\n    const toLocation = lngLatToWorld(lngLat);\n    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));\n    const newCenter = vec2.add([], this.center, translate);\n    return worldToLngLat(newCenter);\n  }\n  /**\n   * Returns a new viewport that fit around the given rectangle.\n   * Only supports non-perspective mode.\n   * @param bounds - [[lon, lat], [lon, lat]]\n   * @param [options]\n   * @param [options.padding] - The amount of padding in pixels to add to the given bounds.\n   * @param [options.offset] - The center of the given bounds relative to the map's center,\n   *    [x, y] measured in pixels.\n   * @returns {WebMercatorViewport}\n   */\n  fitBounds(bounds, options = {}) {\n    const {\n      width,\n      height\n    } = this;\n    const {\n      longitude,\n      latitude,\n      zoom\n    } = fitBounds(Object.assign({\n      width,\n      height,\n      bounds\n    }, options));\n    return new WebMercatorViewport({\n      width,\n      height,\n      longitude,\n      latitude,\n      zoom\n    });\n  }\n  /**\n   * Returns the bounding box of the viewport.\n   * @param [options]\n   * @param [options.z] - The altitude at which the bounds should be calculated.\n   * @returns {Array} bounds - [[lon, lat], [lon, lat]]\n   */\n  getBounds(options) {\n    const corners = this.getBoundingRegion(options);\n    const west = Math.min(...corners.map(p => p[0]));\n    const east = Math.max(...corners.map(p => p[0]));\n    const south = Math.min(...corners.map(p => p[1]));\n    const north = Math.max(...corners.map(p => p[1]));\n    return [[west, south], [east, north]];\n  }\n  /**\n   * Returns the bounding box of the viewport.\n   * @param [options]\n   * @param [options.z] - The altitude at which the bounds should be calculated.\n   * @returns {Array} an array of 4 points that define the visible region\n   */\n  getBoundingRegion(options = {}) {\n    return getBounds(this, options.z || 0);\n  }\n  // DEPRECATED\n  /** @deprecated Legacy method name */\n  getLocationAtPoint({\n    lngLat,\n    pos\n  }) {\n    return this.getMapCenterByLngLatPosition({\n      lngLat,\n      pos\n    });\n  }\n}","map":{"version":3,"names":["createMat4","zoomToScale","pixelsToWorld","lngLatToWorld","worldToLngLat","worldToPixels","altitudeToFovy","fovyToAltitude","DEFAULT_ALTITUDE","getProjectionMatrix","getDistanceScales","getViewMatrix","fitBounds","getBounds","mat4","vec2","vec3","WebMercatorViewport","constructor","props","width","height","equals","viewport","projectionMatrix","viewMatrix","project","lngLatZ","options","topLeft","worldPosition","projectPosition","coord","pixelProjectionMatrix","x","y","y2","length","unproject","xyz","targetZ","undefined","z","targetZWorld","distanceScales","unitsPerMeter","pixelUnprojectionMatrix","X","Y","Z","unprojectPosition","Number","isFinite","metersPerUnit","altitude","fovy","latitude","longitude","zoom","pitch","bearing","position","nearZMultiplier","farZMultiplier","scale","Math","max","center","push","add","mul","meterOffset","_initMatrices","Object","freeze","vpm","multiply","viewProjectionMatrix","m","translate","mInverse","invert","Error","projectFlat","lngLat","unprojectFlat","xy","getMapCenterByLngLatPosition","pos","fromLocation","toLocation","negate","newCenter","bounds","assign","corners","getBoundingRegion","west","min","map","p","east","south","north","getLocationAtPoint"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\web-mercator\\src\\web-mercator-viewport.ts"],"sourcesContent":["// View and Projection Matrix calculations for mapbox-js style map view properties\nimport {createMat4} from './math-utils';\n\nimport {\n  zoomToScale,\n  pixelsToWorld,\n  lngLatToWorld,\n  worldToLngLat,\n  worldToPixels,\n  altitudeToFovy,\n  fovyToAltitude,\n  DEFAULT_ALTITUDE,\n  getProjectionMatrix,\n  getDistanceScales,\n  getViewMatrix,\n  DistanceScales\n} from './web-mercator-utils';\nimport {fitBounds} from './fit-bounds';\nimport {getBounds} from './get-bounds';\nimport type {FitBoundsOptions} from './fit-bounds';\n\nimport {mat4, vec2, vec3} from '@math.gl/core';\n\n/**\n   * @param width=1 - Width of \"viewport\" or window\n   * @param height=1 - Height of \"viewport\" or window\n   * @param scale=1 - Either use scale or zoom\n   * @param pitch=0 - Camera angle in degrees (0 is straight down)\n   * @param bearing=0 - Map rotation in degrees (0 means north is up)\n   * @param fovy= - Field of view of camera in degrees\n   * @param altitude= - Altitude of camera in screen units                                                               \n   *\n   * Web mercator projection short-hand parameters\n   * @param latitude - Center of viewport on map\n   * @param longitude - Center of viewport on map\n   * @param zoom - Scale = Math.pow(2,zoom) on map\n\n   * Notes:\n   *  - Only one of center or [latitude, longitude] can be specified\n   *  - [latitude, longitude] can only be specified when \"mercator\" is true\n   *  - Altitude has a default value that matches assumptions in mapbox-gl\n   *  - Field of view is independent from altitude, provide `altitudeToFovy(1.5)` (default value) to match assumptions in mapbox-gl\n   *  - width and height are forced to 1 if supplied as 0, to avoid\n   *    division by zero. This is intended to reduce the burden of apps to\n   *    to check values before instantiating a Viewport.\n */\nexport type WebMercatorViewportProps = {\n  // Map state\n  width: number;\n  height: number;\n  latitude?: number;\n  longitude?: number;\n  position?: number[];\n  zoom?: number;\n  pitch?: number;\n  bearing?: number;\n  altitude?: number;\n  fovy?: number;\n  nearZMultiplier?: number;\n  farZMultiplier?: number;\n};\n\n/**\n * The WebMercatorViewport class creates\n * - view/projection matrices\n * - \"uniform values\" (for shaders) from mercator params\n *\n * Note: Instances are immutable in the sense that they only have accessors.\n * A new viewport instance should be created if any parameters have changed.\n */\nexport class WebMercatorViewport {\n  readonly latitude: number;\n  readonly longitude: number;\n  readonly zoom: number;\n  readonly pitch: number;\n  readonly bearing: number;\n  readonly altitude: number;\n  readonly fovy: number;\n\n  readonly meterOffset: number[];\n  readonly center: number[];\n\n  readonly width: number;\n  readonly height: number;\n  readonly scale: number;\n  readonly distanceScales: DistanceScales;\n\n  readonly viewMatrix: number[];\n  readonly projectionMatrix: number[];\n\n  viewProjectionMatrix: number[];\n  pixelProjectionMatrix: number[];\n  pixelUnprojectionMatrix: number[];\n\n  /**\n   * @classdesc\n   * Creates view/projection matrices from mercator params\n   * Note: The Viewport is immutable in the sense that it only has accessors.\n   * A new viewport instance should be created if any parameters have changed.\n   */\n  // eslint-disable-next-line max-statements\n  constructor(props: WebMercatorViewportProps = {width: 1, height: 1}) {\n    let {\n      // Map state\n      width,\n      height,\n      altitude = null,\n      fovy = null\n    } = props;\n    const {\n      latitude = 0,\n      longitude = 0,\n      zoom = 0,\n      pitch = 0,\n      bearing = 0,\n      position = null,\n      nearZMultiplier = 0.02,\n      farZMultiplier = 1.01\n    } = props;\n\n    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc\n    width = width || 1;\n    height = height || 1;\n\n    // `fovy` & `altitude` are independent parameters, one for the\n    // projection and the latter for the view matrix. In the past,\n    // the `fovy` was always derived from the `altitude`\n    if (fovy === null && altitude === null) {\n      altitude = DEFAULT_ALTITUDE;\n      fovy = altitudeToFovy(altitude);\n    } else if (fovy === null) {\n      fovy = altitudeToFovy(altitude);\n    } else if (altitude === null) {\n      altitude = fovyToAltitude(fovy);\n    }\n\n    const scale = zoomToScale(zoom);\n    // Altitude - prevent division by 0\n    // TODO - just throw an Error instead?\n    altitude = Math.max(0.75, altitude);\n\n    const distanceScales = getDistanceScales({longitude, latitude});\n\n    const center: number[] = lngLatToWorld([longitude, latitude]);\n    center.push(0);\n\n    if (position) {\n      vec3.add(center, center, vec3.mul([], position, distanceScales.unitsPerMeter));\n    }\n\n    this.projectionMatrix = getProjectionMatrix({\n      width,\n      height,\n      scale,\n      center,\n      pitch,\n      fovy,\n      nearZMultiplier,\n      farZMultiplier\n    });\n\n    this.viewMatrix = getViewMatrix({\n      height,\n      scale,\n      center,\n      pitch,\n      bearing,\n      altitude\n    });\n\n    // Save parameters\n    this.width = width;\n    this.height = height;\n    this.scale = scale;\n\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.zoom = zoom;\n    this.pitch = pitch;\n    this.bearing = bearing;\n    this.altitude = altitude;\n    this.fovy = fovy;\n    this.center = center;\n    this.meterOffset = position || [0, 0, 0];\n\n    this.distanceScales = distanceScales;\n\n    this._initMatrices();\n\n    Object.freeze(this);\n  }\n\n  _initMatrices(): void {\n    const {width, height, projectionMatrix, viewMatrix} = this;\n\n    // Note: As usual, matrix operations should be applied in \"reverse\" order\n    // since vectors will be multiplied in from the right during transformation\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, projectionMatrix);\n    mat4.multiply(vpm, vpm, viewMatrix);\n    this.viewProjectionMatrix = vpm;\n\n    // Calculate matrices and scales needed for projection\n    /**\n     * Builds matrices that converts preprojected lngLats to screen pixels\n     * and vice versa.\n     * Note: Currently returns bottom-left coordinates!\n     * Note: Starts with the GL projection matrix and adds steps to the\n     *       scale and translate that matrix onto the window.\n     * Note: WebGL controls clip space to screen projection with gl.viewport\n     *       and does not need this step.\n     */\n    const m = createMat4();\n\n    // matrix for conversion from location to screen coordinates\n    mat4.scale(m, m, [width / 2, -height / 2, 1]);\n    mat4.translate(m, m, [1, -1, 0]);\n    mat4.multiply(m, m, vpm);\n\n    const mInverse = mat4.invert(createMat4(), m);\n    if (!mInverse) {\n      throw new Error('Pixel project matrix not invertible');\n    }\n\n    this.pixelProjectionMatrix = m;\n    this.pixelUnprojectionMatrix = mInverse;\n  }\n\n  /** Two viewports are equal if width and height are identical, and if\n   * their view and projection matrices are (approximately) equal.\n   */\n  equals = (viewport: WebMercatorViewport | null): boolean => {\n    if (!(viewport instanceof WebMercatorViewport)) {\n      return false;\n    }\n\n    return (\n      viewport.width === this.width &&\n      viewport.height === this.height &&\n      mat4.equals(viewport.projectionMatrix, this.projectionMatrix) &&\n      mat4.equals(viewport.viewMatrix, this.viewMatrix)\n    );\n  };\n\n  /**\n   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n   * using viewport projection parameters\n   * - [longitude, latitude] to [x, y]\n   * - [longitude, latitude, Z] => [x, y, z]\n   * Note: By default, returns top-left coordinates for canvas/SVG type render\n   *\n   * @param lngLatZ - [lng, lat] or [lng, lat, Z]\n   * @param options - options\n   * @param options.topLeft=true - Whether projected coords are top left\n   * @return - screen coordinates [x, y] or [x, y, z], z as pixel depth\n   */\n  project = (lngLatZ: number[], options: {topLeft?: boolean} = {}): number[] => {\n    const {topLeft = true} = options;\n    const worldPosition = this.projectPosition(lngLatZ);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return lngLatZ.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  };\n\n  /**\n   * Unproject pixel coordinates on screen onto world coordinates, possibly `[lon, lat]` on map.\n   *\n   * - [x, y] => [lng, lat]\n   * - [x, y, z] => [lng, lat, Z]\n   *\n   * @param xyz - screen coordinates, z as pixel depth\n   * @param options - options\n   * @param options.topLeft=true - Whether projected coords are top left\n   * @param options.targetZ=0 - If pixel depth is unknown, targetZ is used as\n   *   the elevation plane to unproject onto\n   * @return - [lng, lat, Z] or [X, Y, Z]\n   */\n  unproject = (xyz: number[], options: {topLeft?: boolean; targetZ?: number} = {}): number[] => {\n    const {topLeft = true, targetZ = undefined} = options;\n    const [x, y, z] = xyz;\n\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  };\n\n  // NON_LINEAR PROJECTION HOOKS\n  // Used for web meractor projection\n\n  projectPosition = (xyz: number[]): [number, number, number] => {\n    const [X, Y] = lngLatToWorld(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n    return [X, Y, Z];\n  };\n\n  unprojectPosition = (xyz: number[]): [number, number, number] => {\n    const [X, Y] = worldToLngLat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n    return [X, Y, Z];\n  };\n\n  /**\n   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n   * Performs the nonlinear part of the web mercator projection.\n   * Remaining projection is done with 4x4 matrices which also handles\n   * perspective.\n   *\n   * @param lngLat - [lng, lat] coordinates\n   *   Specifies a point on the sphere to project onto the map.\n   * @return [x,y] coordinates.\n   */\n  projectFlat(lngLat: number[]): number[] {\n    return lngLatToWorld(lngLat);\n  }\n\n  /**\n   * Unproject world point [x,y] on map onto {lat, lon} on sphere\n   *\n   * @param xy - array with [x,y] members\n   *  representing point on projected map plane\n   * @return - array with [lat,lon] of point on sphere.\n   *   Has toArray method if you need a GeoJSON Array.\n   *   Per cartographic tradition, lat and lon are specified as degrees.\n   */\n  unprojectFlat(xy: number[]): number[] {\n    return worldToLngLat(xy);\n  }\n\n  /**\n   * Get the map center that place a given [lng, lat] coordinate at screen point [x, y]\n   * @param opt\n   * @param opt.lngLat - [lng,lat] coordinates\n   *   Specifies a point on the sphere.\n   * @param opt.pos - [x,y] coordinates\n   *   Specifies a point on the screen.\n   * @return [lng,lat] new map center.\n   */\n  getMapCenterByLngLatPosition({lngLat, pos}: {lngLat: number[]; pos: number[]}): number[] {\n    const fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);\n    const toLocation = lngLatToWorld(lngLat);\n    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));\n    const newCenter = vec2.add([], this.center, translate);\n    return worldToLngLat(newCenter);\n  }\n\n  /**\n   * Returns a new viewport that fit around the given rectangle.\n   * Only supports non-perspective mode.\n   * @param bounds - [[lon, lat], [lon, lat]]\n   * @param [options]\n   * @param [options.padding] - The amount of padding in pixels to add to the given bounds.\n   * @param [options.offset] - The center of the given bounds relative to the map's center,\n   *    [x, y] measured in pixels.\n   * @returns {WebMercatorViewport}\n   */\n  fitBounds(\n    bounds: [[number, number], [number, number]],\n    options: Omit<FitBoundsOptions, 'width' | 'height' | 'bounds'> = {}\n  ): WebMercatorViewport {\n    const {width, height} = this;\n    const {longitude, latitude, zoom} = fitBounds(Object.assign({width, height, bounds}, options));\n    return new WebMercatorViewport({width, height, longitude, latitude, zoom});\n  }\n\n  /**\n   * Returns the bounding box of the viewport.\n   * @param [options]\n   * @param [options.z] - The altitude at which the bounds should be calculated.\n   * @returns {Array} bounds - [[lon, lat], [lon, lat]]\n   */\n  getBounds(options?: {z?: number}): number[][] {\n    const corners = this.getBoundingRegion(options);\n\n    const west = Math.min(...corners.map((p) => p[0]));\n    const east = Math.max(...corners.map((p) => p[0]));\n    const south = Math.min(...corners.map((p) => p[1]));\n    const north = Math.max(...corners.map((p) => p[1]));\n    return [\n      [west, south],\n      [east, north]\n    ];\n  }\n\n  /**\n   * Returns the bounding box of the viewport.\n   * @param [options]\n   * @param [options.z] - The altitude at which the bounds should be calculated.\n   * @returns {Array} an array of 4 points that define the visible region\n   */\n  getBoundingRegion(options: {z?: number} = {}): number[][] {\n    return getBounds(this, options.z || 0);\n  }\n\n  // DEPRECATED\n\n  /** @deprecated Legacy method name */\n  getLocationAtPoint({lngLat, pos}: {lngLat: number[]; pos: number[]}): number[] {\n    return this.getMapCenterByLngLatPosition({lngLat, pos});\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}