{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@luma.gl/core';\nimport { pbrMaterial } from '@luma.gl/shadertools';\nimport { Model, ModelNode } from '@luma.gl/engine';\nimport { parsePBRMaterial } from \"../pbr/parse-pbr-material.js\";\nconst SHADER = /* WGSL */`\nlayout(0) positions: vec4; // in vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    in vec4 normals; // in vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    in vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    // in vec2 TEXCOORD_0;\n    in vec2 texCoords;\n  #endif\n\n@vertex\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = normals;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = texCoords;\n    #endif\n\n    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * positions;\n  }\n\n@fragment\n  out vec4 fragmentColor;\n\n  void main(void) {\n    vec3 pos = pbr_vPosition;\n    fragmentColor = pbr_filterColor(vec4(1.0));\n  }\n`;\n// TODO rename attributes to POSITION/NORMAL etc\n// See gpu-geometry.ts: getAttributeBuffersFromGeometry()\nconst vs = /* glsl */`\\\n#version 300 es\n\n  // in vec4 POSITION;\n  in vec4 positions;\n\n  #ifdef HAS_NORMALS\n    // in vec4 NORMAL;\n    in vec4 normals;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    in vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    // in vec2 TEXCOORD_0;\n    in vec2 texCoords;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = normals;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = texCoords;\n    #endif\n\n    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = pbrProjection.modelViewProjectionMatrix * positions;\n  }\n`;\nconst fs = /* glsl */`\\\n#version 300 es\n  out vec4 fragmentColor;\n\n  void main(void) {\n    vec3 pos = pbr_vPosition;\n    fragmentColor = pbr_filterColor(vec4(1.0));\n  }\n`;\nexport function createGLTFModel(device, options) {\n  const {\n    id,\n    geometry,\n    material,\n    vertexCount,\n    materialOptions,\n    modelOptions\n  } = options;\n  const parsedMaterial = parsePBRMaterial(device, material, geometry.attributes, materialOptions);\n  log.info(4, 'createGLTFModel defines: ', parsedMaterial.defines)();\n  // Calculate managedResources\n  // TODO: Implement resource management logic that will\n  // not deallocate resources/textures/buffers that are shared\n  const managedResources = [];\n  // managedResources.push(...parsedMaterial.generatedTextures);\n  // managedResources.push(...Object.values(attributes).map((attribute) => attribute.buffer));\n  const parameters = {\n    depthWriteEnabled: true,\n    depthCompare: 'less',\n    depthFormat: 'depth24plus',\n    cullMode: 'back'\n  };\n  const modelProps = {\n    id,\n    source: SHADER,\n    vs,\n    fs,\n    geometry,\n    topology: geometry.topology,\n    vertexCount,\n    modules: [pbrMaterial],\n    ...modelOptions,\n    defines: {\n      ...parsedMaterial.defines,\n      ...modelOptions.defines\n    },\n    parameters: {\n      ...parameters,\n      ...parsedMaterial.parameters,\n      ...modelOptions.parameters\n    }\n  };\n  const model = new Model(device, modelProps);\n  const {\n    camera,\n    ...pbrMaterialProps\n  } = {\n    ...parsedMaterial.uniforms,\n    ...modelOptions.uniforms,\n    ...parsedMaterial.bindings,\n    ...modelOptions.bindings\n  };\n  model.shaderInputs.setProps({\n    pbrMaterial: pbrMaterialProps,\n    pbrProjection: {\n      camera\n    }\n  });\n  return new ModelNode({\n    managedResources,\n    model\n  });\n}","map":{"version":3,"names":["log","pbrMaterial","Model","ModelNode","parsePBRMaterial","SHADER","vs","fs","createGLTFModel","device","options","id","geometry","material","vertexCount","materialOptions","modelOptions","parsedMaterial","attributes","info","defines","managedResources","parameters","depthWriteEnabled","depthCompare","depthFormat","cullMode","modelProps","source","topology","modules","model","camera","pbrMaterialProps","uniforms","bindings","shaderInputs","setProps","pbrProjection"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\gltf\\src\\gltf\\create-gltf-model.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, RenderPipelineParameters, log} from '@luma.gl/core';\nimport {pbrMaterial, ShaderModule} from '@luma.gl/shadertools';\nimport {Geometry, Model, ModelNode, ModelProps} from '@luma.gl/engine';\nimport {ParsePBRMaterialOptions, parsePBRMaterial} from '../pbr/parse-pbr-material';\n\nconst SHADER = /* WGSL */ `\nlayout(0) positions: vec4; // in vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    in vec4 normals; // in vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    in vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    // in vec2 TEXCOORD_0;\n    in vec2 texCoords;\n  #endif\n\n@vertex\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = normals;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = texCoords;\n    #endif\n\n    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * positions;\n  }\n\n@fragment\n  out vec4 fragmentColor;\n\n  void main(void) {\n    vec3 pos = pbr_vPosition;\n    fragmentColor = pbr_filterColor(vec4(1.0));\n  }\n`;\n\n// TODO rename attributes to POSITION/NORMAL etc\n// See gpu-geometry.ts: getAttributeBuffersFromGeometry()\nconst vs = /* glsl */ `\\\n#version 300 es\n\n  // in vec4 POSITION;\n  in vec4 positions;\n\n  #ifdef HAS_NORMALS\n    // in vec4 NORMAL;\n    in vec4 normals;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    in vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    // in vec2 TEXCOORD_0;\n    in vec2 texCoords;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = normals;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = texCoords;\n    #endif\n\n    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = pbrProjection.modelViewProjectionMatrix * positions;\n  }\n`;\n\nconst fs = /* glsl */ `\\\n#version 300 es\n  out vec4 fragmentColor;\n\n  void main(void) {\n    vec3 pos = pbr_vPosition;\n    fragmentColor = pbr_filterColor(vec4(1.0));\n  }\n`;\n\nexport type CreateGLTFModelOptions = {\n  id?: string;\n  vertexCount?: number;\n  geometry: Geometry;\n  material: any;\n  materialOptions: ParsePBRMaterialOptions;\n  modelOptions?: Partial<ModelProps>;\n};\n\nexport function createGLTFModel(device: Device, options: CreateGLTFModelOptions): ModelNode {\n  const {id, geometry, material, vertexCount, materialOptions, modelOptions} = options;\n\n  const parsedMaterial = parsePBRMaterial(device, material, geometry.attributes, materialOptions);\n  log.info(4, 'createGLTFModel defines: ', parsedMaterial.defines)();\n\n  // Calculate managedResources\n  // TODO: Implement resource management logic that will\n  // not deallocate resources/textures/buffers that are shared\n  const managedResources = [];\n  // managedResources.push(...parsedMaterial.generatedTextures);\n  // managedResources.push(...Object.values(attributes).map((attribute) => attribute.buffer));\n\n  const parameters: RenderPipelineParameters = {\n    depthWriteEnabled: true,\n    depthCompare: 'less',\n    depthFormat: 'depth24plus',\n    cullMode: 'back'\n  };\n\n  const modelProps: ModelProps = {\n    id,\n    source: SHADER,\n    vs,\n    fs,\n    geometry,\n    topology: geometry.topology,\n    vertexCount,\n    modules: [pbrMaterial as unknown as ShaderModule],\n    ...modelOptions,\n\n    defines: {...parsedMaterial.defines, ...modelOptions.defines},\n    parameters: {...parameters, ...parsedMaterial.parameters, ...modelOptions.parameters}\n  };\n\n  const model = new Model(device, modelProps);\n\n  const {camera, ...pbrMaterialProps} = {\n    ...parsedMaterial.uniforms,\n    ...modelOptions.uniforms,\n    ...parsedMaterial.bindings,\n    ...modelOptions.bindings\n  };\n\n  model.shaderInputs.setProps({pbrMaterial: pbrMaterialProps, pbrProjection: {camera}});\n  return new ModelNode({managedResources, model});\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA,SAA0CA,GAAG,QAAO,eAAe;AACnE,SAAQC,WAAW,QAAqB,sBAAsB;AAC9D,SAAkBC,KAAK,EAAEC,SAAS,QAAmB,iBAAiB;AACtE,SAAiCC,gBAAgB,QAAC;AAElD,MAAMC,MAAM,GAAG,UAAW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6CzB;AAED;AACA;AACA,MAAMC,EAAE,GAAG,UAAW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwCrB;AAED,MAAMC,EAAE,GAAG,UAAW;;;;;;;;CAQrB;AAWD,OAAM,SAAUC,eAAeA,CAACC,MAAc,EAAEC,OAA+B;EAC7E,MAAM;IAACC,EAAE;IAAEC,QAAQ;IAAEC,QAAQ;IAAEC,WAAW;IAAEC,eAAe;IAAEC;EAAY,CAAC,GAAGN,OAAO;EAEpF,MAAMO,cAAc,GAAGb,gBAAgB,CAACK,MAAM,EAAEI,QAAQ,EAAED,QAAQ,CAACM,UAAU,EAAEH,eAAe,CAAC;EAC/Ff,GAAG,CAACmB,IAAI,CAAC,CAAC,EAAE,2BAA2B,EAAEF,cAAc,CAACG,OAAO,CAAC,EAAE;EAElE;EACA;EACA;EACA,MAAMC,gBAAgB,GAAG,EAAE;EAC3B;EACA;EAEA,MAAMC,UAAU,GAA6B;IAC3CC,iBAAiB,EAAE,IAAI;IACvBC,YAAY,EAAE,MAAM;IACpBC,WAAW,EAAE,aAAa;IAC1BC,QAAQ,EAAE;GACX;EAED,MAAMC,UAAU,GAAe;IAC7BhB,EAAE;IACFiB,MAAM,EAAEvB,MAAM;IACdC,EAAE;IACFC,EAAE;IACFK,QAAQ;IACRiB,QAAQ,EAAEjB,QAAQ,CAACiB,QAAQ;IAC3Bf,WAAW;IACXgB,OAAO,EAAE,CAAC7B,WAAsC,CAAC;IACjD,GAAGe,YAAY;IAEfI,OAAO,EAAE;MAAC,GAAGH,cAAc,CAACG,OAAO;MAAE,GAAGJ,YAAY,CAACI;IAAO,CAAC;IAC7DE,UAAU,EAAE;MAAC,GAAGA,UAAU;MAAE,GAAGL,cAAc,CAACK,UAAU;MAAE,GAAGN,YAAY,CAACM;IAAU;GACrF;EAED,MAAMS,KAAK,GAAG,IAAI7B,KAAK,CAACO,MAAM,EAAEkB,UAAU,CAAC;EAE3C,MAAM;IAACK,MAAM;IAAE,GAAGC;EAAgB,CAAC,GAAG;IACpC,GAAGhB,cAAc,CAACiB,QAAQ;IAC1B,GAAGlB,YAAY,CAACkB,QAAQ;IACxB,GAAGjB,cAAc,CAACkB,QAAQ;IAC1B,GAAGnB,YAAY,CAACmB;GACjB;EAEDJ,KAAK,CAACK,YAAY,CAACC,QAAQ,CAAC;IAACpC,WAAW,EAAEgC,gBAAgB;IAAEK,aAAa,EAAE;MAACN;IAAM;EAAC,CAAC,CAAC;EACrF,OAAO,IAAI7B,SAAS,CAAC;IAACkB,gBAAgB;IAAEU;EAAK,CAAC,CAAC;AACjD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}