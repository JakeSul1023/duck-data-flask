{"ast":null,"code":"import { getPolygonSignedArea } from '@math.gl/polygon';\n/**\n * Convert GeoJSON features to Flat GeoJSON features\n *\n * @param features\n * @param options\n * @returns an Array of Flat GeoJSON features\n */\nexport function geojsonToFlatGeojson(features) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    coordLength: 2,\n    fixRingWinding: true\n  };\n  return features.map(feature => flattenFeature(feature, options));\n}\n/**\n * Helper function to copy Point values from `coordinates` into `data` & `indices`\n *\n * @param coordinates\n * @param data\n * @param indices\n * @param options\n */\nfunction flattenPoint(coordinates, data, indices, options) {\n  indices.push(data.length);\n  data.push(...coordinates);\n  // Pad up to coordLength\n  for (let i = coordinates.length; i < options.coordLength; i++) {\n    data.push(0);\n  }\n}\n/**\n * Helper function to copy LineString values from `coordinates` into `data` & `indices`\n *\n * @param coordinates\n * @param data\n * @param indices\n * @param options\n */\nfunction flattenLineString(coordinates, data, indices, options) {\n  indices.push(data.length);\n  for (const c of coordinates) {\n    data.push(...c);\n    // Pad up to coordLength\n    for (let i = c.length; i < options.coordLength; i++) {\n      data.push(0);\n    }\n  }\n}\n/**\n * Helper function to copy Polygon values from `coordinates` into `data` & `indices` & `areas`\n *\n * @param coordinates\n * @param data\n * @param indices\n * @param areas\n * @param options\n */\nfunction flattenPolygon(coordinates, data, indices, areas, options) {\n  let count = 0;\n  const ringAreas = [];\n  const polygons = [];\n  for (const lineString of coordinates) {\n    const lineString2d = lineString.map(p => p.slice(0, 2));\n    let area = getPolygonSignedArea(lineString2d.flat());\n    const ccw = area < 0;\n    // Exterior ring must be CCW and interior rings CW\n    if (options.fixRingWinding && (count === 0 && !ccw || count > 0 && ccw)) {\n      lineString.reverse();\n      area = -area;\n    }\n    ringAreas.push(area);\n    flattenLineString(lineString, data, polygons, options);\n    count++;\n  }\n  if (count > 0) {\n    areas.push(ringAreas);\n    indices.push(polygons);\n  }\n}\n/**\n * Flatten single GeoJSON feature into Flat GeoJSON\n *\n * @param feature\n * @param options\n * @returns A Flat GeoJSON feature\n */\nfunction flattenFeature(feature, options) {\n  const {\n    geometry\n  } = feature;\n  if (geometry.type === 'GeometryCollection') {\n    throw new Error('GeometryCollection type not supported');\n  }\n  const data = [];\n  const indices = [];\n  let areas;\n  let type;\n  switch (geometry.type) {\n    case 'Point':\n      type = 'Point';\n      flattenPoint(geometry.coordinates, data, indices, options);\n      break;\n    case 'MultiPoint':\n      type = 'Point';\n      geometry.coordinates.map(c => flattenPoint(c, data, indices, options));\n      break;\n    case 'LineString':\n      type = 'LineString';\n      flattenLineString(geometry.coordinates, data, indices, options);\n      break;\n    case 'MultiLineString':\n      type = 'LineString';\n      geometry.coordinates.map(c => flattenLineString(c, data, indices, options));\n      break;\n    case 'Polygon':\n      type = 'Polygon';\n      areas = [];\n      flattenPolygon(geometry.coordinates, data, indices, areas, options);\n      break;\n    case 'MultiPolygon':\n      type = 'Polygon';\n      areas = [];\n      geometry.coordinates.map(c => flattenPolygon(c, data, indices, areas, options));\n      break;\n    default:\n      throw new Error(`Unknown type: ${type}`);\n  }\n  return {\n    ...feature,\n    geometry: {\n      type,\n      indices,\n      data,\n      areas\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}