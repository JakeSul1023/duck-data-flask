{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getResolution, cellToLatLng, latLngToCell, isPentagon, gridDistance, getHexagonEdgeLengthAvg } from 'h3-js';\nimport { CompositeLayer, createIterable } from '@deck.gl/core';\nimport { ColumnLayer, PolygonLayer } from '@deck.gl/layers';\nimport { flattenPolygon, getHexagonCentroid, h3ToPolygon } from \"./h3-utils.js\";\n// There is a cost to updating the instanced geometries when using highPrecision: false\n// This constant defines the distance between two hexagons that leads to \"significant\n// distortion.\" Smaller value makes the column layer more sensitive to viewport change.\nconst UPDATE_THRESHOLD_KM = 10;\nfunction mergeTriggers(getHexagon, coverage) {\n  let trigger;\n  if (getHexagon === undefined || getHexagon === null) {\n    trigger = coverage;\n  } else if (typeof getHexagon === 'object') {\n    trigger = {\n      ...getHexagon,\n      coverage\n    };\n  } else {\n    trigger = {\n      getHexagon,\n      coverage\n    };\n  }\n  return trigger;\n}\nconst defaultProps = {\n  ...PolygonLayer.defaultProps,\n  highPrecision: 'auto',\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  centerHexagon: null,\n  getHexagon: {\n    type: 'accessor',\n    value: x => x.hexagon\n  },\n  extruded: true\n};\n/**\n * Render hexagons from the [H3](https://h3geo.org/) geospatial indexing system.\n */\nclass H3HexagonLayer extends CompositeLayer {\n  initializeState() {\n    H3HexagonLayer._checkH3Lib();\n    this.state = {\n      edgeLengthKM: 0,\n      resolution: -1\n    };\n  }\n  shouldUpdateState({\n    changeFlags\n  }) {\n    return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;\n  }\n  updateState({\n    props,\n    changeFlags\n  }) {\n    if (props.highPrecision !== true && (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagon)) {\n      const dataProps = this._calculateH3DataProps();\n      this.setState(dataProps);\n    }\n    this._updateVertices(this.context.viewport);\n  }\n  _calculateH3DataProps() {\n    let resolution = -1;\n    let hasPentagon = false;\n    let hasMultipleRes = false;\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(this.props.data);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const hexId = this.props.getHexagon(object, objectInfo);\n      // Take the resolution of the first hex\n      const hexResolution = getResolution(hexId);\n      if (resolution < 0) {\n        resolution = hexResolution;\n        if (!this.props.highPrecision) break;\n      } else if (resolution !== hexResolution) {\n        hasMultipleRes = true;\n        break;\n      }\n      if (isPentagon(hexId)) {\n        hasPentagon = true;\n        break;\n      }\n    }\n    return {\n      resolution,\n      edgeLengthKM: resolution >= 0 ? getHexagonEdgeLengthAvg(resolution, 'km') : 0,\n      hasMultipleRes,\n      hasPentagon\n    };\n  }\n  _shouldUseHighPrecision() {\n    if (this.props.highPrecision === 'auto') {\n      const {\n        resolution,\n        hasPentagon,\n        hasMultipleRes\n      } = this.state;\n      const {\n        viewport\n      } = this.context;\n      return Boolean(viewport?.resolution) || hasMultipleRes || hasPentagon || resolution >= 0 && resolution <= 5;\n    }\n    return this.props.highPrecision;\n  }\n  _updateVertices(viewport) {\n    if (this._shouldUseHighPrecision()) {\n      return;\n    }\n    const {\n      resolution,\n      edgeLengthKM,\n      centerHex\n    } = this.state;\n    if (resolution < 0) {\n      return;\n    }\n    const hex = this.props.centerHexagon || latLngToCell(viewport.latitude, viewport.longitude, resolution);\n    if (centerHex === hex) {\n      return;\n    }\n    if (centerHex) {\n      try {\n        const distance = gridDistance(centerHex, hex);\n        if (distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {\n          return;\n        }\n      } catch {\n        // gridDistance throws if the distance could not be computed\n        // due to the two indexes very far apart or on opposite sides of a pentagon.\n      }\n    }\n    const {\n      unitsPerMeter\n    } = viewport.distanceScales;\n    let vertices = h3ToPolygon(hex);\n    const [centerLat, centerLng] = cellToLatLng(hex);\n    const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);\n    vertices = vertices.map(p => {\n      const worldPosition = viewport.projectFlat(p);\n      return [(worldPosition[0] - centerX) / unitsPerMeter[0], (worldPosition[1] - centerY) / unitsPerMeter[1]];\n    });\n    this.setState({\n      centerHex: hex,\n      vertices\n    });\n  }\n  renderLayers() {\n    return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();\n  }\n  _getForwardProps() {\n    const {\n      elevationScale,\n      material,\n      coverage,\n      extruded,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      getFillColor,\n      getElevation,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers\n    } = this.props;\n    return {\n      elevationScale,\n      extruded,\n      coverage,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      material,\n      getElevation,\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers: {\n        getFillColor: updateTriggers.getFillColor,\n        getElevation: updateTriggers.getElevation,\n        getLineColor: updateTriggers.getLineColor,\n        getLineWidth: updateTriggers.getLineWidth\n      }\n    };\n  }\n  _renderPolygonLayer() {\n    const {\n      data,\n      getHexagon,\n      updateTriggers,\n      coverage\n    } = this.props;\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell-hifi', PolygonLayer);\n    const forwardProps = this._getForwardProps();\n    forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);\n    return new SubLayerClass(forwardProps, this.getSubLayerProps({\n      id: 'hexagon-cell-hifi',\n      updateTriggers: forwardProps.updateTriggers\n    }), {\n      data,\n      _normalize: false,\n      _windingOrder: 'CCW',\n      positionFormat: 'XY',\n      getPolygon: (object, objectInfo) => {\n        const hexagonId = getHexagon(object, objectInfo);\n        return flattenPolygon(h3ToPolygon(hexagonId, coverage));\n      }\n    });\n  }\n  _renderColumnLayer() {\n    const {\n      data,\n      getHexagon,\n      updateTriggers\n    } = this.props;\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n    const forwardProps = this._getForwardProps();\n    forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;\n    return new SubLayerClass(forwardProps, this.getSubLayerProps({\n      id: 'hexagon-cell',\n      flatShading: true,\n      updateTriggers: forwardProps.updateTriggers\n    }), {\n      data,\n      diskResolution: 6,\n      // generate an extruded hexagon as the base geometry\n      radius: 1,\n      vertices: this.state.vertices,\n      getPosition: getHexagonCentroid.bind(null, getHexagon)\n    });\n  }\n}\nH3HexagonLayer.defaultProps = defaultProps;\nH3HexagonLayer.layerName = 'H3HexagonLayer';\n// See `main/bundle.ts`\nH3HexagonLayer._checkH3Lib = () => {};\nexport default H3HexagonLayer;","map":{"version":3,"names":["getResolution","cellToLatLng","latLngToCell","isPentagon","gridDistance","getHexagonEdgeLengthAvg","CompositeLayer","createIterable","ColumnLayer","PolygonLayer","flattenPolygon","getHexagonCentroid","h3ToPolygon","UPDATE_THRESHOLD_KM","mergeTriggers","getHexagon","coverage","trigger","undefined","defaultProps","highPrecision","type","min","max","value","centerHexagon","x","hexagon","extruded","H3HexagonLayer","initializeState","_checkH3Lib","state","edgeLengthKM","resolution","shouldUpdateState","changeFlags","_shouldUseHighPrecision","propsOrDataChanged","somethingChanged","updateState","props","dataChanged","updateTriggersChanged","dataProps","_calculateH3DataProps","setState","_updateVertices","context","viewport","hasPentagon","hasMultipleRes","iterable","objectInfo","data","object","index","hexId","hexResolution","Boolean","centerHex","hex","latitude","longitude","distance","unitsPerMeter","distanceScales","vertices","centerLat","centerLng","centerX","centerY","projectFlat","map","p","worldPosition","renderLayers","_renderPolygonLayer","_renderColumnLayer","_getForwardProps","elevationScale","material","wireframe","stroked","filled","lineWidthUnits","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","getFillColor","getElevation","getLineColor","getLineWidth","transitions","updateTriggers","SubLayerClass","getSubLayerClass","forwardProps","getPolygon","getSubLayerProps","id","_normalize","_windingOrder","positionFormat","hexagonId","getPosition","flatShading","diskResolution","radius","bind","layerName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\geo-layers\\src\\h3-layers\\h3-hexagon-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  getResolution,\n  cellToLatLng,\n  latLngToCell,\n  isPentagon,\n  gridDistance,\n  getHexagonEdgeLengthAvg,\n  H3Index\n} from 'h3-js';\nimport {\n  AccessorFunction,\n  CompositeLayer,\n  createIterable,\n  Layer,\n  LayersList,\n  UpdateParameters,\n  WebMercatorViewport,\n  DefaultProps\n} from '@deck.gl/core';\nimport {ColumnLayer, PolygonLayer, PolygonLayerProps} from '@deck.gl/layers';\nimport {flattenPolygon, getHexagonCentroid, h3ToPolygon} from './h3-utils';\n\n// There is a cost to updating the instanced geometries when using highPrecision: false\n// This constant defines the distance between two hexagons that leads to \"significant\n// distortion.\" Smaller value makes the column layer more sensitive to viewport change.\nconst UPDATE_THRESHOLD_KM = 10;\n\nfunction mergeTriggers(getHexagon, coverage) {\n  let trigger;\n  if (getHexagon === undefined || getHexagon === null) {\n    trigger = coverage;\n  } else if (typeof getHexagon === 'object') {\n    trigger = {...getHexagon, coverage};\n  } else {\n    trigger = {getHexagon, coverage};\n  }\n  return trigger;\n}\n\nconst defaultProps: DefaultProps<H3HexagonLayerProps> = {\n  ...PolygonLayer.defaultProps,\n  highPrecision: 'auto',\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  centerHexagon: null,\n  getHexagon: {type: 'accessor', value: (x: any) => x.hexagon},\n  extruded: true\n};\n\n/** All properties supported by H3HexagonLayer */\nexport type H3HexagonLayerProps<DataT = unknown> = _H3HexagonLayerProps<DataT> &\n  PolygonLayerProps<DataT>;\n\n/** Props added by the H3HexagonLayer */\ntype _H3HexagonLayerProps<DataT> = {\n  /**\n   * Whether or not draw hexagons with high precision.\n   * @default 'auto'\n   */\n  highPrecision?: boolean | 'auto';\n  /**\n   * Coverage of hexagon in cell.\n   * @default 1\n   */\n  coverage?: number;\n  /**\n   * Center hexagon that best represents the shape of the set. If not specified, the hexagon closest to the center of the viewport is used.\n   */\n  centerHexagon?: H3Index | null;\n  /**\n   * Called for each data object to retrieve the quadkey string identifier.\n   *\n   * By default, it reads `hexagon` property of data object.\n   */\n  getHexagon?: AccessorFunction<DataT, string>;\n  /**\n   * Whether to extrude polygons.\n   * @default true\n   */\n  extruded?: boolean;\n};\n\n/**\n * Render hexagons from the [H3](https://h3geo.org/) geospatial indexing system.\n */\nexport default class H3HexagonLayer<\n  DataT = any,\n  ExtraPropsT extends {} = {}\n> extends CompositeLayer<ExtraPropsT & Required<H3HexagonLayerProps<DataT>>> {\n  static defaultProps = defaultProps;\n  static layerName = 'H3HexagonLayer';\n\n  // See `main/bundle.ts`\n  static _checkH3Lib = () => {};\n\n  initializeState() {\n    H3HexagonLayer._checkH3Lib();\n    this.state = {\n      edgeLengthKM: 0,\n      resolution: -1\n    };\n  }\n\n  state!: {\n    centerHex?: H3Index;\n    edgeLengthKM: number;\n    hasMultipleRes?: boolean;\n    hasPentagon?: boolean;\n    resolution: number;\n    vertices?: number[][];\n  };\n\n  shouldUpdateState({changeFlags}: UpdateParameters<this>): boolean {\n    return this._shouldUseHighPrecision()\n      ? changeFlags.propsOrDataChanged\n      : changeFlags.somethingChanged;\n  }\n\n  updateState({props, changeFlags}: UpdateParameters<this>): void {\n    if (\n      props.highPrecision !== true &&\n      (changeFlags.dataChanged ||\n        (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagon))\n    ) {\n      const dataProps = this._calculateH3DataProps();\n      this.setState(dataProps);\n    }\n\n    this._updateVertices(this.context.viewport as WebMercatorViewport);\n  }\n\n  private _calculateH3DataProps() {\n    let resolution = -1;\n    let hasPentagon = false;\n    let hasMultipleRes = false;\n\n    const {iterable, objectInfo} = createIterable(this.props.data);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const hexId = this.props.getHexagon(object, objectInfo);\n      // Take the resolution of the first hex\n      const hexResolution = getResolution(hexId);\n      if (resolution < 0) {\n        resolution = hexResolution;\n        if (!this.props.highPrecision) break;\n      } else if (resolution !== hexResolution) {\n        hasMultipleRes = true;\n        break;\n      }\n      if (isPentagon(hexId)) {\n        hasPentagon = true;\n        break;\n      }\n    }\n\n    return {\n      resolution,\n      edgeLengthKM: resolution >= 0 ? getHexagonEdgeLengthAvg(resolution, 'km') : 0,\n      hasMultipleRes,\n      hasPentagon\n    };\n  }\n\n  private _shouldUseHighPrecision(): boolean {\n    if (this.props.highPrecision === 'auto') {\n      const {resolution, hasPentagon, hasMultipleRes} = this.state;\n      const {viewport} = this.context;\n      return (\n        Boolean(viewport?.resolution) ||\n        hasMultipleRes ||\n        hasPentagon ||\n        (resolution >= 0 && resolution <= 5)\n      );\n    }\n\n    return this.props.highPrecision;\n  }\n\n  private _updateVertices(viewport: WebMercatorViewport): void {\n    if (this._shouldUseHighPrecision()) {\n      return;\n    }\n    const {resolution, edgeLengthKM, centerHex} = this.state;\n    if (resolution < 0) {\n      return;\n    }\n    const hex =\n      this.props.centerHexagon || latLngToCell(viewport.latitude, viewport.longitude, resolution);\n    if (centerHex === hex) {\n      return;\n    }\n    if (centerHex) {\n      try {\n        const distance = gridDistance(centerHex, hex);\n        if (distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {\n          return;\n        }\n      } catch {\n        // gridDistance throws if the distance could not be computed\n        // due to the two indexes very far apart or on opposite sides of a pentagon.\n      }\n    }\n\n    const {unitsPerMeter} = viewport.distanceScales;\n\n    let vertices = h3ToPolygon(hex);\n    const [centerLat, centerLng] = cellToLatLng(hex);\n\n    const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);\n    vertices = vertices.map(p => {\n      const worldPosition = viewport.projectFlat(p);\n      return [\n        (worldPosition[0] - centerX) / unitsPerMeter[0],\n        (worldPosition[1] - centerY) / unitsPerMeter[1]\n      ];\n    });\n\n    this.setState({centerHex: hex, vertices});\n  }\n\n  renderLayers(): Layer | null | LayersList {\n    return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();\n  }\n\n  private _getForwardProps() {\n    const {\n      elevationScale,\n      material,\n      coverage,\n      extruded,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      getFillColor,\n      getElevation,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers\n    } = this.props;\n\n    return {\n      elevationScale,\n      extruded,\n      coverage,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      material,\n      getElevation,\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers: {\n        getFillColor: updateTriggers.getFillColor,\n        getElevation: updateTriggers.getElevation,\n        getLineColor: updateTriggers.getLineColor,\n        getLineWidth: updateTriggers.getLineWidth\n      } as {\n        getFillColor: any;\n        getElevation: any;\n        getLineColor: any;\n        getLineWidth: any;\n        getPolygon?: any;\n        getPosition?: any;\n      }\n    };\n  }\n\n  private _renderPolygonLayer(): PolygonLayer {\n    const {data, getHexagon, updateTriggers, coverage} = this.props;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell-hifi', PolygonLayer);\n    const forwardProps = this._getForwardProps();\n    forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);\n\n    return new SubLayerClass(\n      forwardProps,\n      this.getSubLayerProps({\n        id: 'hexagon-cell-hifi',\n        updateTriggers: forwardProps.updateTriggers\n      }),\n      {\n        data,\n        _normalize: false,\n        _windingOrder: 'CCW',\n        positionFormat: 'XY',\n        getPolygon: (object, objectInfo) => {\n          const hexagonId = getHexagon(object, objectInfo);\n          return flattenPolygon(h3ToPolygon(hexagonId, coverage));\n        }\n      }\n    );\n  }\n\n  private _renderColumnLayer(): ColumnLayer {\n    const {data, getHexagon, updateTriggers} = this.props;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n    const forwardProps = this._getForwardProps();\n    forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;\n\n    return new SubLayerClass(\n      forwardProps,\n      this.getSubLayerProps({\n        id: 'hexagon-cell',\n        flatShading: true,\n        updateTriggers: forwardProps.updateTriggers\n      }),\n      {\n        data,\n        diskResolution: 6, // generate an extruded hexagon as the base geometry\n        radius: 1,\n        vertices: this.state.vertices,\n        getPosition: getHexagonCentroid.bind(null, getHexagon)\n      }\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}