{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { VertexArray, getScratchArray } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\nimport { getBrowser } from '@probe.gl/env';\nimport { getGLFromVertexType } from \"../converters/vertex-formats.js\";\nimport { fillArray } from \"../../utils/fill-array.js\";\n/** VertexArrayObject wrapper */\nexport class WEBGLVertexArray extends VertexArray {\n  get [Symbol.toStringTag]() {\n    return 'VertexArray';\n  }\n  device;\n  handle;\n  /** Attribute 0 buffer constant */\n  buffer = null;\n  bufferValue = null;\n  /** * Attribute 0 can not be disable on most desktop OpenGL based browsers */\n  static isConstantAttributeZeroSupported(device) {\n    return getBrowser() === 'Chrome';\n  }\n  // Create a VertexArray\n  constructor(device, props) {\n    super(device, props);\n    this.device = device;\n    this.handle = this.device.gl.createVertexArray();\n  }\n  destroy() {\n    super.destroy();\n    if (this.buffer) {\n      this.buffer?.destroy();\n    }\n    if (this.handle) {\n      this.device.gl.deleteVertexArray(this.handle);\n      // @ts-expect-error read-only/undefined\n      this.handle = undefined;\n    }\n    // Auto-delete elements?\n    // return [this.elements];\n  }\n  /**\n  // Set (bind/unbind) an elements buffer, for indexed rendering.\n  // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER or null. Constants not supported\n   *\n   * @param elementBuffer\n   */\n  setIndexBuffer(indexBuffer) {\n    const buffer = indexBuffer;\n    // Explicitly allow `null` to support clearing the index buffer\n    if (buffer && buffer.glTarget !== 34963) {\n      throw new Error('Use .setBuffer()');\n    }\n    // In WebGL The GL.ELEMENT_ARRAY_BUFFER_BINDING is stored on the VertexArrayObject\n    this.device.gl.bindVertexArray(this.handle);\n    this.device.gl.bindBuffer(34963, buffer ? buffer.handle : null);\n    this.indexBuffer = buffer;\n    // Unbind to prevent unintended changes to the VAO.\n    this.device.gl.bindVertexArray(null);\n  }\n  /** Set a location in vertex attributes array to a buffer, enables the location, sets divisor */\n  setBuffer(location, attributeBuffer) {\n    const buffer = attributeBuffer;\n    // Sanity check target\n    if (buffer.glTarget === 34963) {\n      throw new Error('Use .setIndexBuffer()');\n    }\n    const {\n      size,\n      type,\n      stride,\n      offset,\n      normalized,\n      integer,\n      divisor\n    } = this._getAccessor(location);\n    this.device.gl.bindVertexArray(this.handle);\n    // A non-zero buffer object must be bound to the GL_ARRAY_BUFFER target\n    this.device.gl.bindBuffer(34962, buffer.handle);\n    // WebGL2 supports *integer* data formats, i.e. GPU will see integer values\n    if (integer) {\n      this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);\n    } else {\n      // Attaches ARRAY_BUFFER with specified buffer format to location\n      this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);\n    }\n    // Clear binding - keeping it may cause [.WebGL-0x12804417100]\n    // GL_INVALID_OPERATION: A transform feedback buffer that would be written to is also bound to a non-transform-feedback target\n    this.device.gl.bindBuffer(34962, null);\n    // Mark as non-constant\n    this.device.gl.enableVertexAttribArray(location);\n    // Set the step mode 0=vertex, 1=instance\n    this.device.gl.vertexAttribDivisor(location, divisor || 0);\n    this.attributes[location] = buffer;\n    // Unbind to prevent unintended changes to the VAO.\n    this.device.gl.bindVertexArray(null);\n  }\n  /** Set a location in vertex attributes array to a constant value, disables the location */\n  setConstantWebGL(location, value) {\n    this._enable(location, false);\n    this.attributes[location] = value;\n  }\n  bindBeforeRender() {\n    this.device.gl.bindVertexArray(this.handle);\n    this._applyConstantAttributes();\n  }\n  unbindAfterRender() {\n    // Unbind to prevent unintended changes to the VAO.\n    this.device.gl.bindVertexArray(null);\n  }\n  // Internal methods\n  /**\n   * Constant attributes need to be reset before every draw call\n   * Any attribute that is disabled in the current vertex array object\n   * is read from the context's global constant value for that attribute location.\n   * @note Constant attributes are only supported in WebGL, not in WebGPU\n   */\n  _applyConstantAttributes() {\n    for (let location = 0; location < this.maxVertexAttributes; ++location) {\n      const constant = this.attributes[location];\n      // A typed array means this is a constant\n      if (ArrayBuffer.isView(constant)) {\n        this.device.setConstantAttributeWebGL(location, constant);\n      }\n    }\n  }\n  /**\n   * Set a location in vertex attributes array to a buffer, enables the location, sets divisor\n   * @note requires vertex array to be bound\n   */\n  // protected _setAttributeLayout(location: number): void {\n  //   const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);\n  //   // WebGL2 supports *integer* data formats, i.e. GPU will see integer values\n  //   if (integer) {\n  //     this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);\n  //   } else {\n  //     // Attaches ARRAY_BUFFER with specified buffer format to location\n  //     this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);\n  //   }\n  //   this.device.gl.vertexAttribDivisor(location, divisor || 0);\n  // }\n  /** Get an accessor from the  */\n  _getAccessor(location) {\n    const attributeInfo = this.attributeInfos[location];\n    if (!attributeInfo) {\n      throw new Error(`Unknown attribute location ${location}`);\n    }\n    const glType = getGLFromVertexType(attributeInfo.bufferDataType);\n    return {\n      size: attributeInfo.bufferComponents,\n      type: glType,\n      stride: attributeInfo.byteStride,\n      offset: attributeInfo.byteOffset,\n      normalized: attributeInfo.normalized,\n      // it is the shader attribute declaration, not the vertex memory format,\n      // that determines if the data in the buffer will be treated as integers.\n      //\n      // Also note that WebGL supports assigning non-normalized integer data to floating point attributes,\n      // but as far as we can tell, WebGPU does not.\n      integer: attributeInfo.integer,\n      divisor: attributeInfo.stepMode === 'instance' ? 1 : 0\n    };\n  }\n  /**\n   * Enabling an attribute location makes it reference the currently bound buffer\n   * Disabling an attribute location makes it reference the global constant value\n   * TODO - handle single values for size 1 attributes?\n   * TODO - convert classic arrays based on known type?\n   */\n  _enable(location, enable = true) {\n    // Attribute 0 cannot be disabled in most desktop OpenGL based browsers...\n    const canDisableAttributeZero = WEBGLVertexArray.isConstantAttributeZeroSupported(this.device);\n    const canDisableAttribute = canDisableAttributeZero || location !== 0;\n    if (enable || canDisableAttribute) {\n      location = Number(location);\n      this.device.gl.bindVertexArray(this.handle);\n      if (enable) {\n        this.device.gl.enableVertexAttribArray(location);\n      } else {\n        this.device.gl.disableVertexAttribArray(location);\n      }\n      this.device.gl.bindVertexArray(null);\n    }\n  }\n  /**\n   * Provide a means to create a buffer that is equivalent to a constant.\n   * NOTE: Desktop OpenGL cannot disable attribute 0.\n   * https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-\n   * this-has-significant-performance-penalty\n   */\n  getConstantBuffer(elementCount, value) {\n    // Create buffer only when needed, and reuse it (avoids inflating buffer creation statistics)\n    const constantValue = normalizeConstantArrayValue(value);\n    const byteLength = constantValue.byteLength * elementCount;\n    const length = constantValue.length * elementCount;\n    if (this.buffer && byteLength !== this.buffer.byteLength) {\n      throw new Error(`Buffer size is immutable, byte length ${byteLength} !== ${this.buffer.byteLength}.`);\n    }\n    let updateNeeded = !this.buffer;\n    this.buffer = this.buffer || this.device.createBuffer({\n      byteLength\n    });\n    // Reallocate and update contents if needed\n    updateNeeded = updateNeeded || !compareConstantArrayValues(constantValue, this.bufferValue);\n    if (updateNeeded) {\n      // Create a typed array that is big enough, and fill it with the required data\n      const typedArray = getScratchArray(value.constructor, length);\n      fillArray({\n        target: typedArray,\n        source: constantValue,\n        start: 0,\n        count: length\n      });\n      this.buffer.write(typedArray);\n      this.bufferValue = value;\n    }\n    return this.buffer;\n  }\n}\n// HELPER FUNCTIONS\n/**\n * TODO - convert Arrays based on known type? (read type from accessor, don't assume Float32Array)\n * TODO - handle single values for size 1 attributes?\n */\nfunction normalizeConstantArrayValue(arrayValue) {\n  if (Array.isArray(arrayValue)) {\n    return new Float32Array(arrayValue);\n  }\n  return arrayValue;\n}\n/**\n *\n */\nfunction compareConstantArrayValues(v1, v2) {\n  if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {\n    return false;\n  }\n  for (let i = 0; i < v1.length; ++i) {\n    if (v1[i] !== v2[i]) {\n      return false;\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["VertexArray","getScratchArray","GL","getBrowser","getGLFromVertexType","fillArray","WEBGLVertexArray","Symbol","toStringTag","device","handle","buffer","bufferValue","isConstantAttributeZeroSupported","constructor","props","gl","createVertexArray","destroy","deleteVertexArray","undefined","setIndexBuffer","indexBuffer","glTarget","Error","bindVertexArray","bindBuffer","setBuffer","location","attributeBuffer","size","type","stride","offset","normalized","integer","divisor","_getAccessor","vertexAttribIPointer","vertexAttribPointer","enableVertexAttribArray","vertexAttribDivisor","attributes","setConstantWebGL","value","_enable","bindBeforeRender","_applyConstantAttributes","unbindAfterRender","maxVertexAttributes","constant","ArrayBuffer","isView","setConstantAttributeWebGL","attributeInfo","attributeInfos","glType","bufferDataType","bufferComponents","byteStride","byteOffset","stepMode","enable","canDisableAttributeZero","canDisableAttribute","Number","disableVertexAttribArray","getConstantBuffer","elementCount","constantValue","normalizeConstantArrayValue","byteLength","length","updateNeeded","createBuffer","compareConstantArrayValues","typedArray","target","source","start","count","write","arrayValue","Array","isArray","Float32Array","v1","v2","i"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\webgl\\src\\adapter\\resources\\webgl-vertex-array.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {TypedArray, NumericArray} from '@math.gl/types';\nimport type {Device, Buffer, VertexArrayProps} from '@luma.gl/core';\nimport {VertexArray, getScratchArray} from '@luma.gl/core';\nimport {GL} from '@luma.gl/constants';\nimport {getBrowser} from '@probe.gl/env';\n\nimport {WebGLDevice} from '../webgl-device';\nimport {WEBGLBuffer} from '../resources/webgl-buffer';\n\nimport {getGLFromVertexType} from '../converters/vertex-formats';\nimport {fillArray} from '../../utils/fill-array';\n\n/** VertexArrayObject wrapper */\nexport class WEBGLVertexArray extends VertexArray {\n  override get [Symbol.toStringTag](): string {\n    return 'VertexArray';\n  }\n\n  readonly device: WebGLDevice;\n  readonly handle: WebGLVertexArrayObject;\n\n  /** Attribute 0 buffer constant */\n  private buffer: WEBGLBuffer | null = null;\n  private bufferValue = null;\n\n  /** * Attribute 0 can not be disable on most desktop OpenGL based browsers */\n  static isConstantAttributeZeroSupported(device: Device): boolean {\n    return getBrowser() === 'Chrome';\n  }\n\n  // Create a VertexArray\n  constructor(device: WebGLDevice, props: VertexArrayProps) {\n    super(device, props);\n    this.device = device;\n    this.handle = this.device.gl.createVertexArray()!;\n  }\n\n  override destroy(): void {\n    super.destroy();\n    if (this.buffer) {\n      this.buffer?.destroy();\n    }\n    if (this.handle) {\n      this.device.gl.deleteVertexArray(this.handle);\n      // @ts-expect-error read-only/undefined\n      this.handle = undefined!;\n    }\n\n    // Auto-delete elements?\n    // return [this.elements];\n  }\n\n  /**\n  // Set (bind/unbind) an elements buffer, for indexed rendering.\n  // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER or null. Constants not supported\n   *\n   * @param elementBuffer\n   */\n  setIndexBuffer(indexBuffer: Buffer | null): void {\n    const buffer = indexBuffer as WEBGLBuffer;\n    // Explicitly allow `null` to support clearing the index buffer\n    if (buffer && buffer.glTarget !== GL.ELEMENT_ARRAY_BUFFER) {\n      throw new Error('Use .setBuffer()');\n    }\n    // In WebGL The GL.ELEMENT_ARRAY_BUFFER_BINDING is stored on the VertexArrayObject\n    this.device.gl.bindVertexArray(this.handle);\n    this.device.gl.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, buffer ? buffer.handle : null);\n\n    this.indexBuffer = buffer;\n\n    // Unbind to prevent unintended changes to the VAO.\n    this.device.gl.bindVertexArray(null);\n  }\n\n  /** Set a location in vertex attributes array to a buffer, enables the location, sets divisor */\n  setBuffer(location: number, attributeBuffer: Buffer): void {\n    const buffer = attributeBuffer as WEBGLBuffer;\n    // Sanity check target\n    if (buffer.glTarget === GL.ELEMENT_ARRAY_BUFFER) {\n      throw new Error('Use .setIndexBuffer()');\n    }\n\n    const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);\n\n    this.device.gl.bindVertexArray(this.handle);\n    // A non-zero buffer object must be bound to the GL_ARRAY_BUFFER target\n    this.device.gl.bindBuffer(GL.ARRAY_BUFFER, buffer.handle);\n\n    // WebGL2 supports *integer* data formats, i.e. GPU will see integer values\n    if (integer) {\n      this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);\n    } else {\n      // Attaches ARRAY_BUFFER with specified buffer format to location\n      this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);\n    }\n    // Clear binding - keeping it may cause [.WebGL-0x12804417100]\n    // GL_INVALID_OPERATION: A transform feedback buffer that would be written to is also bound to a non-transform-feedback target\n    this.device.gl.bindBuffer(GL.ARRAY_BUFFER, null);\n\n    // Mark as non-constant\n    this.device.gl.enableVertexAttribArray(location);\n    // Set the step mode 0=vertex, 1=instance\n    this.device.gl.vertexAttribDivisor(location, divisor || 0);\n\n    this.attributes[location] = buffer;\n\n    // Unbind to prevent unintended changes to the VAO.\n    this.device.gl.bindVertexArray(null);\n  }\n\n  /** Set a location in vertex attributes array to a constant value, disables the location */\n  override setConstantWebGL(location: number, value: TypedArray): void {\n    this._enable(location, false);\n    this.attributes[location] = value;\n  }\n\n  override bindBeforeRender(): void {\n    this.device.gl.bindVertexArray(this.handle);\n    this._applyConstantAttributes();\n  }\n\n  override unbindAfterRender(): void {\n    // Unbind to prevent unintended changes to the VAO.\n    this.device.gl.bindVertexArray(null);\n  }\n\n  // Internal methods\n\n  /**\n   * Constant attributes need to be reset before every draw call\n   * Any attribute that is disabled in the current vertex array object\n   * is read from the context's global constant value for that attribute location.\n   * @note Constant attributes are only supported in WebGL, not in WebGPU\n   */\n  protected _applyConstantAttributes(): void {\n    for (let location = 0; location < this.maxVertexAttributes; ++location) {\n      const constant = this.attributes[location];\n      // A typed array means this is a constant\n      if (ArrayBuffer.isView(constant)) {\n        this.device.setConstantAttributeWebGL(location, constant);\n      }\n    }\n  }\n\n  /**\n   * Set a location in vertex attributes array to a buffer, enables the location, sets divisor\n   * @note requires vertex array to be bound\n   */\n  // protected _setAttributeLayout(location: number): void {\n  //   const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);\n\n  //   // WebGL2 supports *integer* data formats, i.e. GPU will see integer values\n  //   if (integer) {\n  //     this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);\n  //   } else {\n  //     // Attaches ARRAY_BUFFER with specified buffer format to location\n  //     this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);\n  //   }\n  //   this.device.gl.vertexAttribDivisor(location, divisor || 0);\n  // }\n\n  /** Get an accessor from the  */\n  protected _getAccessor(location: number) {\n    const attributeInfo = this.attributeInfos[location];\n    if (!attributeInfo) {\n      throw new Error(`Unknown attribute location ${location}`);\n    }\n    const glType = getGLFromVertexType(attributeInfo.bufferDataType);\n    return {\n      size: attributeInfo.bufferComponents,\n      type: glType,\n      stride: attributeInfo.byteStride,\n      offset: attributeInfo.byteOffset,\n      normalized: attributeInfo.normalized,\n      // it is the shader attribute declaration, not the vertex memory format,\n      // that determines if the data in the buffer will be treated as integers.\n      //\n      // Also note that WebGL supports assigning non-normalized integer data to floating point attributes,\n      // but as far as we can tell, WebGPU does not.\n      integer: attributeInfo.integer,\n      divisor: attributeInfo.stepMode === 'instance' ? 1 : 0\n    };\n  }\n\n  /**\n   * Enabling an attribute location makes it reference the currently bound buffer\n   * Disabling an attribute location makes it reference the global constant value\n   * TODO - handle single values for size 1 attributes?\n   * TODO - convert classic arrays based on known type?\n   */\n  protected _enable(location: number, enable = true): void {\n    // Attribute 0 cannot be disabled in most desktop OpenGL based browsers...\n    const canDisableAttributeZero = WEBGLVertexArray.isConstantAttributeZeroSupported(this.device);\n    const canDisableAttribute = canDisableAttributeZero || location !== 0;\n\n    if (enable || canDisableAttribute) {\n      location = Number(location);\n      this.device.gl.bindVertexArray(this.handle);\n      if (enable) {\n        this.device.gl.enableVertexAttribArray(location);\n      } else {\n        this.device.gl.disableVertexAttribArray(location);\n      }\n      this.device.gl.bindVertexArray(null);\n    }\n  }\n\n  /**\n   * Provide a means to create a buffer that is equivalent to a constant.\n   * NOTE: Desktop OpenGL cannot disable attribute 0.\n   * https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-\n   * this-has-significant-performance-penalty\n   */\n  getConstantBuffer(elementCount: number, value: TypedArray): Buffer {\n    // Create buffer only when needed, and reuse it (avoids inflating buffer creation statistics)\n\n    const constantValue = normalizeConstantArrayValue(value);\n\n    const byteLength = constantValue.byteLength * elementCount;\n    const length = constantValue.length * elementCount;\n\n    if (this.buffer && byteLength !== this.buffer.byteLength) {\n      throw new Error(\n        `Buffer size is immutable, byte length ${byteLength} !== ${this.buffer.byteLength}.`\n      );\n    }\n    let updateNeeded = !this.buffer;\n\n    this.buffer = this.buffer || this.device.createBuffer({byteLength});\n\n    // Reallocate and update contents if needed\n    updateNeeded = updateNeeded || !compareConstantArrayValues(constantValue, this.bufferValue);\n\n    if (updateNeeded) {\n      // Create a typed array that is big enough, and fill it with the required data\n      const typedArray = getScratchArray(value.constructor, length);\n      fillArray({target: typedArray, source: constantValue, start: 0, count: length});\n      this.buffer.write(typedArray);\n      this.bufferValue = value;\n    }\n\n    return this.buffer;\n  }\n}\n\n// HELPER FUNCTIONS\n\n/**\n * TODO - convert Arrays based on known type? (read type from accessor, don't assume Float32Array)\n * TODO - handle single values for size 1 attributes?\n */\nfunction normalizeConstantArrayValue(arrayValue: NumericArray) {\n  if (Array.isArray(arrayValue)) {\n    return new Float32Array(arrayValue);\n  }\n  return arrayValue;\n}\n\n/**\n *\n */\nfunction compareConstantArrayValues(v1: NumericArray, v2: NumericArray): boolean {\n  if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {\n    return false;\n  }\n  for (let i = 0; i < v1.length; ++i) {\n    if (v1[i] !== v2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}