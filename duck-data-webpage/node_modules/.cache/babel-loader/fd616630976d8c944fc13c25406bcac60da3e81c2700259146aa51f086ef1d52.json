{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isMobile, isBrowser } from \"../env-utils/globals.js\";\nimport WorkerThread from \"./worker-thread.js\";\nimport WorkerJob from \"./worker-job.js\";\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  name = 'unnamed';\n  source; // | Function;\n  url;\n  maxConcurrency = 1;\n  maxMobileConcurrency = 1;\n  onDebug = () => {};\n  reuseWorkers = true;\n  props = {};\n  jobQueue = [];\n  idleQueue = [];\n  count = 0;\n  isDestroyed = false;\n  /** Checks if workers are supported on this platform */\n  static isSupported() {\n    return WorkerThread.isSupported();\n  }\n  /**\n   * @param processor - worker function\n   * @param maxConcurrency - max count of workers\n   */\n  constructor(props) {\n    this.source = props.source;\n    this.url = props.url;\n    this.setProps(props);\n  }\n  /**\n   * Terminates all workers in the pool\n   * @note Can free up significant memory\n   */\n  destroy() {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach(worker => worker.destroy());\n    this.isDestroyed = true;\n  }\n  setProps(props) {\n    this.props = {\n      ...this.props,\n      ...props\n    };\n    if (props.name !== undefined) {\n      this.name = props.name;\n    }\n    if (props.maxConcurrency !== undefined) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n    if (props.maxMobileConcurrency !== undefined) {\n      this.maxMobileConcurrency = props.maxMobileConcurrency;\n    }\n    if (props.reuseWorkers !== undefined) {\n      this.reuseWorkers = props.reuseWorkers;\n    }\n    if (props.onDebug !== undefined) {\n      this.onDebug = props.onDebug;\n    }\n  }\n  async startJob(name, onMessage = (job, type, data) => job.done(data), onError = (job, error) => job.error(error)) {\n    // Promise resolves when thread starts working on this job\n    const startPromise = new Promise(onStart => {\n      // Promise resolves when thread completes or fails working on this job\n      this.jobQueue.push({\n        name,\n        onMessage,\n        onError,\n        onStart\n      });\n      return this;\n    });\n    this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    return await startPromise;\n  }\n  // PRIVATE\n  /**\n   * Starts first queued job if worker is available or can be created\n   * Called when job is started and whenever a worker returns to the idleQueue\n   */\n  async _startQueuedJob() {\n    if (!this.jobQueue.length) {\n      return;\n    }\n    const workerThread = this._getAvailableWorker();\n    if (!workerThread) {\n      return;\n    }\n    // We have a worker, dequeue and start the job\n    const queuedJob = this.jobQueue.shift();\n    if (queuedJob) {\n      // Emit a debug event\n      // @ts-ignore\n      this.onDebug({\n        message: 'Starting job',\n        name: queuedJob.name,\n        workerThread,\n        backlog: this.jobQueue.length\n      });\n      // Create a worker job to let the app access thread and manage job completion\n      const job = new WorkerJob(queuedJob.name, workerThread);\n      // Set the worker thread's message handlers\n      workerThread.onMessage = data => queuedJob.onMessage(job, data.type, data.payload);\n      workerThread.onError = error => queuedJob.onError(job, error);\n      // Resolve the start promise so that the app can start sending messages to worker\n      queuedJob.onStart(job);\n      // Wait for the app to signal that the job is complete, then return worker to queue\n      try {\n        await job.result;\n      } catch (error) {\n        // eslint-disable-next-line no-console\n        console.error(`Worker exception: ${error}`);\n      } finally {\n        this.returnWorkerToQueue(workerThread);\n      }\n    }\n  }\n  /**\n   * Returns a worker to the idle queue\n   * Destroys the worker if\n   *  - pool is destroyed\n   *  - if this pool doesn't reuse workers\n   *  - if maxConcurrency has been lowered\n   * @param worker\n   */\n  returnWorkerToQueue(worker) {\n    const shouldDestroyWorker =\n    // Workers on Node.js prevent the process from exiting.\n    // Until we figure out how to close them before exit, we always destroy them\n    !isBrowser ||\n    // If the pool is destroyed, there is no reason to keep the worker around\n    this.isDestroyed ||\n    // If the app has disabled worker reuse, any completed workers should be destroyed\n    !this.reuseWorkers ||\n    // If concurrency has been lowered, this worker might be surplus to requirements\n    this.count > this._getMaxConcurrency();\n    if (shouldDestroyWorker) {\n      worker.destroy();\n      this.count--;\n    } else {\n      this.idleQueue.push(worker);\n    }\n    if (!this.isDestroyed) {\n      this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    }\n  }\n  /**\n   * Returns idle worker or creates new worker if maxConcurrency has not been reached\n   */\n  _getAvailableWorker() {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift() || null;\n    }\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new WorkerThread({\n        name,\n        source: this.source,\n        url: this.url\n      });\n    }\n    // No worker available, have to wait\n    return null;\n  }\n  _getMaxConcurrency() {\n    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}