{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { cutPolylineByGrid, cutPolylineByMercatorBounds } from '@math.gl/polygon';\n/**\n * Flattens a nested path object\n * Cut the feature if needed (globe projection, wrap longitude, etc.)\n * Returns a flat array of path positions, or a list of flat arrays representing multiple paths\n */\nexport function normalizePath(path, size, gridResolution, wrapLongitude) {\n  let flatPath;\n  if (Array.isArray(path[0])) {\n    const length = path.length * size;\n    flatPath = new Array(length);\n    for (let i = 0; i < path.length; i++) {\n      for (let j = 0; j < size; j++) {\n        flatPath[i * size + j] = path[i][j] || 0;\n      }\n    }\n  } else {\n    flatPath = path;\n  }\n  if (gridResolution) {\n    return cutPolylineByGrid(flatPath, {\n      size,\n      gridResolution\n    });\n  }\n  if (wrapLongitude) {\n    return cutPolylineByMercatorBounds(flatPath, {\n      size\n    });\n  }\n  return flatPath;\n}","map":{"version":3,"names":["cutPolylineByGrid","cutPolylineByMercatorBounds","normalizePath","path","size","gridResolution","wrapLongitude","flatPath","Array","isArray","length","i","j"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\layers\\src\\path-layer\\path.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {cutPolylineByGrid, cutPolylineByMercatorBounds} from '@math.gl/polygon';\n\nimport type {NumericArray} from '@math.gl/core';\nimport type {Position} from '@deck.gl/core';\n\nexport type NestedPathGeometry = Position[];\nexport type FlatPathGeometry = NumericArray;\nexport type PathGeometry = NestedPathGeometry | FlatPathGeometry;\nexport type NormalizedPathGeometry = FlatPathGeometry[] | FlatPathGeometry;\n\n/**\n * Flattens a nested path object\n * Cut the feature if needed (globe projection, wrap longitude, etc.)\n * Returns a flat array of path positions, or a list of flat arrays representing multiple paths\n */\nexport function normalizePath(\n  path: PathGeometry,\n  size: number,\n  gridResolution?: number,\n  wrapLongitude?: boolean\n): number[][] | NumericArray {\n  let flatPath: NumericArray;\n  if (Array.isArray(path[0])) {\n    const length = path.length * size;\n    flatPath = new Array(length);\n    for (let i = 0; i < path.length; i++) {\n      for (let j = 0; j < size; j++) {\n        flatPath[i * size + j] = path[i][j] || 0;\n      }\n    }\n  } else {\n    flatPath = path as NumericArray;\n  }\n  if (gridResolution) {\n    return cutPolylineByGrid(flatPath, {size, gridResolution});\n  }\n  if (wrapLongitude) {\n    return cutPolylineByMercatorBounds(flatPath, {size});\n  }\n  return flatPath;\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA,SAAQA,iBAAiB,EAAEC,2BAA2B,QAAO,kBAAkB;AAU/E;;;;;AAKA,OAAM,SAAUC,aAAaA,CAC3BC,IAAkB,EAClBC,IAAY,EACZC,cAAuB,EACvBC,aAAuB;EAEvB,IAAIC,QAAsB;EAC1B,IAAIC,KAAK,CAACC,OAAO,CAACN,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;IAC1B,MAAMO,MAAM,GAAGP,IAAI,CAACO,MAAM,GAAGN,IAAI;IACjCG,QAAQ,GAAG,IAAIC,KAAK,CAACE,MAAM,CAAC;IAC5B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,IAAI,CAACO,MAAM,EAAEC,CAAC,EAAE,EAAE;MACpC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,IAAI,EAAEQ,CAAC,EAAE,EAAE;QAC7BL,QAAQ,CAACI,CAAC,GAAGP,IAAI,GAAGQ,CAAC,CAAC,GAAGT,IAAI,CAACQ,CAAC,CAAC,CAACC,CAAC,CAAC,IAAI,CAAC;MAC1C;IACF;EACF,CAAC,MAAM;IACLL,QAAQ,GAAGJ,IAAoB;EACjC;EACA,IAAIE,cAAc,EAAE;IAClB,OAAOL,iBAAiB,CAACO,QAAQ,EAAE;MAACH,IAAI;MAAEC;IAAc,CAAC,CAAC;EAC5D;EACA,IAAIC,aAAa,EAAE;IACjB,OAAOL,2BAA2B,CAACM,QAAQ,EAAE;MAACH;IAAI,CAAC,CAAC;EACtD;EACA,OAAOG,QAAQ;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}