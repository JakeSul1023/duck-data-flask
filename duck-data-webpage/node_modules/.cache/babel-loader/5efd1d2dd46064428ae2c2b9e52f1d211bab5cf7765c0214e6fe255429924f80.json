{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { WebMercatorViewport, _GlobeViewport } from '@deck.gl/core';\nimport { CullingVolume, Plane, AxisAlignedBoundingBox, makeOrientedBoundingBoxFromPoints } from '@math.gl/culling';\nimport { lngLatToWorld } from '@math.gl/web-mercator';\nimport { osmTile2lngLat } from \"./utils.js\";\nconst TILE_SIZE = 512;\n// number of world copies to check\nconst MAX_MAPS = 3;\n// for calculating bounding volume of a tile in a non-web-mercator viewport\nconst REF_POINTS_5 = [[0.5, 0.5], [0, 0], [0, 1], [1, 0], [1, 1]]; // 4 corners and center\nconst REF_POINTS_9 = REF_POINTS_5.concat([[0, 0.5], [0.5, 0], [1, 0.5], [0.5, 1]]); // 4 corners, center and 4 mid points\nconst REF_POINTS_11 = REF_POINTS_9.concat([[0.25, 0.5], [0.75, 0.5]]); // 2 additional points on equator for top tile\nclass OSMNode {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  get children() {\n    if (!this._children) {\n      const x = this.x * 2;\n      const y = this.y * 2;\n      const z = this.z + 1;\n      this._children = [new OSMNode(x, y, z), new OSMNode(x, y + 1, z), new OSMNode(x + 1, y, z), new OSMNode(x + 1, y + 1, z)];\n    }\n    return this._children;\n  }\n  // eslint-disable-next-line complexity\n  update(params) {\n    const {\n      viewport,\n      cullingVolume,\n      elevationBounds,\n      minZ,\n      maxZ,\n      bounds,\n      offset,\n      project\n    } = params;\n    const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project);\n    // First, check if this tile is visible\n    if (bounds && !this.insideBounds(bounds)) {\n      return false;\n    }\n    const isInside = cullingVolume.computeVisibility(boundingVolume);\n    if (isInside < 0) {\n      return false;\n    }\n    // Avoid loading overlapping tiles - if a descendant is requested, do not request the ancester\n    if (!this.childVisible) {\n      let {\n        z\n      } = this;\n      if (z < maxZ && z >= minZ) {\n        // Adjust LOD\n        // If the tile is far enough from the camera, accept a lower zoom level\n        const distance = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;\n        z += Math.floor(Math.log2(distance));\n      }\n      if (z >= maxZ) {\n        // LOD is acceptable\n        this.selected = true;\n        return true;\n      }\n    }\n    // LOD is not enough, recursively test child tiles\n    this.selected = false;\n    this.childVisible = true;\n    for (const child of this.children) {\n      child.update(params);\n    }\n    return true;\n  }\n  getSelected(result = []) {\n    if (this.selected) {\n      result.push(this);\n    }\n    if (this._children) {\n      for (const node of this._children) {\n        node.getSelected(result);\n      }\n    }\n    return result;\n  }\n  insideBounds([minX, minY, maxX, maxY]) {\n    const scale = Math.pow(2, this.z);\n    const extent = TILE_SIZE / scale;\n    return this.x * extent < maxX && this.y * extent < maxY && (this.x + 1) * extent > minX && (this.y + 1) * extent > minY;\n  }\n  getBoundingVolume(zRange, worldOffset, project) {\n    if (project) {\n      // Custom projection\n      // Estimate bounding box from sample points\n      // At low zoom level we need more samples to calculate the bounding volume correctly\n      const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;\n      // Convert from tile-relative coordinates to common space\n      const refPointPositions = [];\n      for (const p of refPoints) {\n        const lngLat = osmTile2lngLat(this.x + p[0], this.y + p[1], this.z);\n        lngLat[2] = zRange[0];\n        refPointPositions.push(project(lngLat));\n        if (zRange[0] !== zRange[1]) {\n          // Account for the elevation volume\n          lngLat[2] = zRange[1];\n          refPointPositions.push(project(lngLat));\n        }\n      }\n      return makeOrientedBoundingBoxFromPoints(refPointPositions);\n    }\n    // Use WebMercator projection\n    const scale = Math.pow(2, this.z);\n    const extent = TILE_SIZE / scale;\n    const originX = this.x * extent + worldOffset * TILE_SIZE;\n    // deck's common space is y-flipped\n    const originY = TILE_SIZE - (this.y + 1) * extent;\n    return new AxisAlignedBoundingBox([originX, originY, zRange[0]], [originX + extent, originY + extent, zRange[1]]);\n  }\n}\n// eslint-disable-next-line complexity\nexport function getOSMTileIndices(viewport, maxZ, zRange, bounds) {\n  const project = viewport instanceof _GlobeViewport && viewport.resolution ?\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  viewport.projectPosition : null;\n  // Get the culling volume of the current camera\n  const planes = Object.values(viewport.getFrustumPlanes()).map(({\n    normal,\n    distance\n  }) => new Plane(normal.clone().negate(), distance));\n  const cullingVolume = new CullingVolume(planes);\n  // Project zRange from meters to common space\n  const unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];\n  const elevationMin = zRange && zRange[0] * unitsPerMeter || 0;\n  const elevationMax = zRange && zRange[1] * unitsPerMeter || 0;\n  // Always load at the current zoom level if pitch is small\n  const minZ = viewport instanceof WebMercatorViewport && viewport.pitch <= 60 ? maxZ : 0;\n  // Map extent to OSM position\n  if (bounds) {\n    const [minLng, minLat, maxLng, maxLat] = bounds;\n    const topLeft = lngLatToWorld([minLng, maxLat]);\n    const bottomRight = lngLatToWorld([maxLng, minLat]);\n    bounds = [topLeft[0], TILE_SIZE - topLeft[1], bottomRight[0], TILE_SIZE - bottomRight[1]];\n  }\n  const root = new OSMNode(0, 0, 0);\n  const traversalParams = {\n    viewport,\n    project,\n    cullingVolume,\n    elevationBounds: [elevationMin, elevationMax],\n    minZ,\n    maxZ,\n    bounds,\n    // num. of worlds from the center. For repeated maps\n    offset: 0\n  };\n  root.update(traversalParams);\n  if (viewport instanceof WebMercatorViewport && viewport.subViewports && viewport.subViewports.length > 1) {\n    // Check worlds in repeated maps\n    traversalParams.offset = -1;\n    while (root.update(traversalParams)) {\n      if (--traversalParams.offset < -MAX_MAPS) {\n        break;\n      }\n    }\n    traversalParams.offset = 1;\n    while (root.update(traversalParams)) {\n      if (++traversalParams.offset > MAX_MAPS) {\n        break;\n      }\n    }\n  }\n  return root.getSelected();\n}\n//# sourceMappingURL=tile-2d-traversal.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}