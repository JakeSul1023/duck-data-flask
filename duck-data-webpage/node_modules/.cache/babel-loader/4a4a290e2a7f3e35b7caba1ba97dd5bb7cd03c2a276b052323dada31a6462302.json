{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { XMLLoader } from '@loaders.gl/xml';\nimport { getXMLArray, getXMLStringArray, getXMLInteger, getXMLFloat, getXMLBoolean } from \"../xml/parse-xml-helpers.js\";\n/**\n * Parses a typed data structure from raw XML for `GetCapabilities` response\n * @note Error handlings is fairly weak\n */\nexport function parseWMSCapabilities(xmlText, options) {\n  const parsedXML = XMLLoader.parseTextSync?.(xmlText, options);\n  const xmlCapabilities = parsedXML.WMT_MS_Capabilities || parsedXML.WMS_Capabilities || parsedXML;\n  const capabilities = extractCapabilities(xmlCapabilities);\n  // In case the processed, normalized capabilities do not contain everything,\n  // the user can get the parsed XML structure.\n  if (options?.inheritedLayerProps) {\n    // Traverse layers and inject missing props from parents\n    for (const layer of capabilities.layers) {\n      addInheritedLayerProps(layer, null);\n    }\n    // Not yet implemented\n  }\n  if (options?.includeRawJSON) {\n    capabilities.json = xmlCapabilities;\n  }\n  if (options?.includeXMLText) {\n    capabilities.xml = xmlText;\n  }\n  return capabilities;\n}\n/** Extract typed capability data from XML */\nfunction extractCapabilities(xml) {\n  const capabilities = {\n    version: String(xml.version || ''),\n    name: String(xml.Service?.Name || 'unnamed'),\n    title: xml.Service?.Title ? String(xml.Service?.Title) : undefined,\n    abstract: xml.Service?.Abstract ? String(xml.Service?.Abstract) : undefined,\n    keywords: getXMLStringArray(xml.Service?.KeywordList?.Keyword),\n    fees: xml.Service?.Fees ? JSON.stringify(xml.Service?.Fees) : undefined,\n    accessConstraints: xml.Service?.AccessConstraints ? JSON.stringify(xml.Service?.AccessConstraints) : undefined,\n    layerLimit: getXMLInteger(xml.Service?.LayerLimit),\n    maxWidth: getXMLInteger(xml.Service?.maxWidth),\n    maxHeight: getXMLInteger(xml.Service?.maxHeight),\n    layers: [],\n    requests: extractRequests(xml.Capability?.Request),\n    exceptions: extractExceptions(xml.Exception)\n    // contact field is a mess of largely irrelevant information, put it last\n    // contact: xml.Service?.Contact ? JSON.stringify(xml.Service?.Contact) : undefined,\n  };\n  // LAYERS\n  const xmlLayers = getXMLArray(xml.Capability?.Layer);\n  for (const xmlSubLayer of xmlLayers) {\n    capabilities.layers.push(extractLayer(xmlSubLayer));\n  }\n  // Clean up object\n  for (const [key, value] of Object.entries(capabilities)) {\n    if (value === undefined) {\n      delete capabilities[key];\n    }\n  }\n  return capabilities;\n}\n/** Extract typed request metadata from XML requests field */\nfunction extractRequests(xmlRequests) {\n  const requests = {};\n  for (const [name, xmlRequest] of Object.entries(xmlRequests || {})) {\n    const mimeTypes = getXMLStringArray(xmlRequest?.Format);\n    requests[name] = {\n      mimeTypes\n    };\n  }\n  return requests;\n}\nfunction extractExceptions(xmlException) {\n  const xmlExceptionFormats = getXMLArray(xmlException?.Format);\n  if (xmlExceptionFormats.length > 0) {\n    return {\n      mimeTypes: getXMLStringArray(xmlException)\n    };\n  }\n  return undefined;\n}\n/** Extract request data */\n// eslint-disable-next-line complexity, max-statements\nfunction extractLayer(xmlLayer) {\n  const layer = {\n    // All layers must have a title\n    title: String(xmlLayer?.Title || ''),\n    // Name is required only if renderable\n    name: xmlLayer?.Name && String(xmlLayer?.Name),\n    abstract: xmlLayer?.Name && String(xmlLayer?.Abstract),\n    keywords: getXMLStringArray(xmlLayer.KeywordList?.Keyword)\n  };\n  // WMS 1.3.0 changes SRS to CRS\n  const crs = xmlLayer?.CRS || xmlLayer?.SRS;\n  if (crs && Array.isArray(crs) && crs.every(_ => typeof _ === 'string')) {\n    layer.crs = crs;\n  }\n  // v1.3.0 extract simple geographic bounding box\n  let geographicBoundingBox = xmlLayer?.EX_GeographicBoundingBox && extractEXBoundingBox(xmlLayer?.EX_GeographicBoundingBox);\n  if (geographicBoundingBox) {\n    layer.geographicBoundingBox = geographicBoundingBox;\n  }\n  // v1.1.1 extract simple geographic bounding box\n  geographicBoundingBox = xmlLayer?.LatLonBoundingBox && extractLatLonBoundingBox(xmlLayer?.LatLonBoundingBox);\n  if (geographicBoundingBox) {\n    layer.geographicBoundingBox = geographicBoundingBox;\n  }\n  // Extract per-CRS bounding boxes\n  const boundingBoxes = xmlLayer?.BoundingBox && extractWMSBoundingBoxes(xmlLayer?.BoundingBox);\n  if (boundingBoxes && boundingBoxes.length > 0) {\n    layer.boundingBoxes = boundingBoxes;\n  }\n  // Extract dimensions\n  const xmlDimensions = getXMLArray(xmlLayer?.Dimension);\n  const dimensions = xmlDimensions.map(xml => extractDimension(xml));\n  if (dimensions.length) {\n    layer.dimensions = dimensions;\n  }\n  if (xmlLayer?.opaque) {\n    layer.opaque = getXMLBoolean(xmlLayer?.opaque);\n  }\n  if (xmlLayer?.cascaded) {\n    layer.cascaded = getXMLBoolean(xmlLayer?.cascaded);\n  }\n  if (xmlLayer?.queryable) {\n    layer.queryable = getXMLBoolean(xmlLayer?.queryable);\n  }\n  // Single layer is not represented as array in XML\n  const xmlLayers = getXMLArray(xmlLayer?.Layer);\n  const layers = [];\n  for (const xmlSubLayer of xmlLayers) {\n    layers.push(extractLayer(xmlSubLayer));\n  }\n  if (layers.length > 0) {\n    layer.layers = layers;\n  }\n  // Clean up object\n  for (const [key, value] of Object.entries(layer)) {\n    if (value === undefined) {\n      delete layer[key];\n    }\n  }\n  return layer;\n}\n/** WMS 1.3.0 Loosely defined geospatial bounding box in unspecified CRS for quick content searches */\nfunction extractEXBoundingBox(xmlBoundingBox) {\n  const {\n    westBoundLongitude: w,\n    northBoundLatitude: n,\n    eastBoundLongitude: e,\n    southBoundLatitude: s\n  } = xmlBoundingBox;\n  return [[w, s], [e, n]];\n}\n/** WMS 1.1.1 Loosely defined geospatial bounding box in unspecified CRS for quick content searches */\nfunction extractLatLonBoundingBox(xmlBoundingBox) {\n  const {\n    minx,\n    miny,\n    maxx,\n    maxy\n  } = xmlBoundingBox;\n  return [[minx, miny], [maxx, maxy]];\n}\n/** Loosely defined geospatial bounding box in unspecified CRS for quick content searches */\nfunction extractWMSBoundingBoxes(xmlBoundingBoxes) {\n  const xmlBoxes = getXMLArray(xmlBoundingBoxes);\n  return xmlBoxes.map(xmlBox => extractWMSBoundingBox(xmlBox));\n}\n/** Loosely defined geospatial bounding box in unspecified CRS for quick content searches */\nfunction extractWMSBoundingBox(xmlBoundingBox) {\n  const {\n    CRS,\n    SRS,\n    minx,\n    miny,\n    maxx,\n    maxy,\n    resx,\n    resy\n  } = xmlBoundingBox;\n  const boundingBox = {\n    // CRS in 1.3.0, SRS in 1.1.1\n    crs: CRS || SRS,\n    boundingBox: [[getXMLFloat(minx), getXMLFloat(miny)], [getXMLFloat(maxx), getXMLFloat(maxy)]]\n  };\n  if (resx) {\n    boundingBox.xResolution = resx;\n  }\n  if (resy) {\n    boundingBox.yResolution = resy;\n  }\n  return boundingBox;\n}\n/**\n * Extracts optional WMS Dimension layer field\n * @param xmlDimension\n * @example <Dimension name=\"time\" units=\"ISO8601\" default=\"2018-01-01\" nearestValue=\"0\">2001-01-01/2018-01-01/P1Y</Dimension>\n * @see https://mapserver.org/ogc/wms_dimension.html\n */\nfunction extractDimension(xmlDimension) {\n  const {\n    name,\n    units,\n    value: extent\n  } = xmlDimension;\n  const dimension = {\n    name,\n    units,\n    extent\n  };\n  if (xmlDimension.unitSymbol) {\n    dimension.unitSymbol = xmlDimension.unitSymbol;\n  }\n  if (xmlDimension.default) {\n    dimension.defaultValue = xmlDimension.default;\n  }\n  if (xmlDimension.multipleValues) {\n    dimension.multipleValues = getXMLBoolean(xmlDimension.multipleValues);\n  }\n  if (xmlDimension.nearestValue) {\n    dimension.nearestValue = getXMLBoolean(xmlDimension.nearestValue);\n  }\n  if (xmlDimension.current) {\n    dimension.current = getXMLBoolean(xmlDimension.current);\n  }\n  return dimension;\n}\n/** Traverse layers and inject missing props from parents */\n// eslint-disable-next-line complexity\nfunction addInheritedLayerProps(layer, parent) {\n  if (parent?.geographicBoundingBox && !layer.geographicBoundingBox) {\n    layer.geographicBoundingBox = [...parent.geographicBoundingBox];\n  }\n  if (parent?.crs && !layer.crs) {\n    layer.crs = [...parent.crs];\n  }\n  if (parent?.boundingBoxes && !layer.boundingBoxes) {\n    layer.boundingBoxes = [...parent.boundingBoxes];\n  }\n  if (parent?.dimensions && !layer.dimensions) {\n    layer.dimensions = [...parent.dimensions];\n  }\n  for (const subLayer of layer.layers || []) {\n    addInheritedLayerProps(subLayer, layer);\n  }\n}","map":{"version":3,"names":["XMLLoader","getXMLArray","getXMLStringArray","getXMLInteger","getXMLFloat","getXMLBoolean","parseWMSCapabilities","xmlText","options","parsedXML","parseTextSync","xmlCapabilities","WMT_MS_Capabilities","WMS_Capabilities","capabilities","extractCapabilities","inheritedLayerProps","layer","layers","addInheritedLayerProps","includeRawJSON","json","includeXMLText","xml","version","String","name","Service","Name","title","Title","undefined","abstract","Abstract","keywords","KeywordList","Keyword","fees","Fees","JSON","stringify","accessConstraints","AccessConstraints","layerLimit","LayerLimit","maxWidth","maxHeight","requests","extractRequests","Capability","Request","exceptions","extractExceptions","Exception","xmlLayers","Layer","xmlSubLayer","push","extractLayer","key","value","Object","entries","xmlRequests","xmlRequest","mimeTypes","Format","xmlException","xmlExceptionFormats","length","xmlLayer","crs","CRS","SRS","Array","isArray","every","_","geographicBoundingBox","EX_GeographicBoundingBox","extractEXBoundingBox","LatLonBoundingBox","extractLatLonBoundingBox","boundingBoxes","BoundingBox","extractWMSBoundingBoxes","xmlDimensions","Dimension","dimensions","map","extractDimension","opaque","cascaded","queryable","xmlBoundingBox","westBoundLongitude","w","northBoundLatitude","n","eastBoundLongitude","e","southBoundLatitude","s","minx","miny","maxx","maxy","xmlBoundingBoxes","xmlBoxes","xmlBox","extractWMSBoundingBox","resx","resy","boundingBox","xResolution","yResolution","xmlDimension","units","extent","dimension","unitSymbol","default","defaultValue","multipleValues","nearestValue","current","parent","subLayer"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-capabilities.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { XMLLoader } from '@loaders.gl/xml';\nimport { getXMLArray, getXMLStringArray, getXMLInteger, getXMLFloat, getXMLBoolean } from \"../xml/parse-xml-helpers.js\";\n/**\n * Parses a typed data structure from raw XML for `GetCapabilities` response\n * @note Error handlings is fairly weak\n */\nexport function parseWMSCapabilities(xmlText, options) {\n    const parsedXML = XMLLoader.parseTextSync?.(xmlText, options);\n    const xmlCapabilities = parsedXML.WMT_MS_Capabilities || parsedXML.WMS_Capabilities || parsedXML;\n    const capabilities = extractCapabilities(xmlCapabilities);\n    // In case the processed, normalized capabilities do not contain everything,\n    // the user can get the parsed XML structure.\n    if (options?.inheritedLayerProps) {\n        // Traverse layers and inject missing props from parents\n        for (const layer of capabilities.layers) {\n            addInheritedLayerProps(layer, null);\n        }\n        // Not yet implemented\n    }\n    if (options?.includeRawJSON) {\n        capabilities.json = xmlCapabilities;\n    }\n    if (options?.includeXMLText) {\n        capabilities.xml = xmlText;\n    }\n    return capabilities;\n}\n/** Extract typed capability data from XML */\nfunction extractCapabilities(xml) {\n    const capabilities = {\n        version: String(xml.version || ''),\n        name: String(xml.Service?.Name || 'unnamed'),\n        title: xml.Service?.Title ? String(xml.Service?.Title) : undefined,\n        abstract: xml.Service?.Abstract ? String(xml.Service?.Abstract) : undefined,\n        keywords: getXMLStringArray(xml.Service?.KeywordList?.Keyword),\n        fees: xml.Service?.Fees ? JSON.stringify(xml.Service?.Fees) : undefined,\n        accessConstraints: xml.Service?.AccessConstraints\n            ? JSON.stringify(xml.Service?.AccessConstraints)\n            : undefined,\n        layerLimit: getXMLInteger(xml.Service?.LayerLimit),\n        maxWidth: getXMLInteger(xml.Service?.maxWidth),\n        maxHeight: getXMLInteger(xml.Service?.maxHeight),\n        layers: [],\n        requests: extractRequests(xml.Capability?.Request),\n        exceptions: extractExceptions(xml.Exception)\n        // contact field is a mess of largely irrelevant information, put it last\n        // contact: xml.Service?.Contact ? JSON.stringify(xml.Service?.Contact) : undefined,\n    };\n    // LAYERS\n    const xmlLayers = getXMLArray(xml.Capability?.Layer);\n    for (const xmlSubLayer of xmlLayers) {\n        capabilities.layers.push(extractLayer(xmlSubLayer));\n    }\n    // Clean up object\n    for (const [key, value] of Object.entries(capabilities)) {\n        if (value === undefined) {\n            delete capabilities[key];\n        }\n    }\n    return capabilities;\n}\n/** Extract typed request metadata from XML requests field */\nfunction extractRequests(xmlRequests) {\n    const requests = {};\n    for (const [name, xmlRequest] of Object.entries(xmlRequests || {})) {\n        const mimeTypes = getXMLStringArray(xmlRequest?.Format);\n        requests[name] = { mimeTypes };\n    }\n    return requests;\n}\nfunction extractExceptions(xmlException) {\n    const xmlExceptionFormats = getXMLArray(xmlException?.Format);\n    if (xmlExceptionFormats.length > 0) {\n        return {\n            mimeTypes: getXMLStringArray(xmlException)\n        };\n    }\n    return undefined;\n}\n/** Extract request data */\n// eslint-disable-next-line complexity, max-statements\nfunction extractLayer(xmlLayer) {\n    const layer = {\n        // All layers must have a title\n        title: String(xmlLayer?.Title || ''),\n        // Name is required only if renderable\n        name: xmlLayer?.Name && String(xmlLayer?.Name),\n        abstract: xmlLayer?.Name && String(xmlLayer?.Abstract),\n        keywords: getXMLStringArray(xmlLayer.KeywordList?.Keyword)\n    };\n    // WMS 1.3.0 changes SRS to CRS\n    const crs = xmlLayer?.CRS || xmlLayer?.SRS;\n    if (crs && Array.isArray(crs) && crs.every((_) => typeof _ === 'string')) {\n        layer.crs = crs;\n    }\n    // v1.3.0 extract simple geographic bounding box\n    let geographicBoundingBox = xmlLayer?.EX_GeographicBoundingBox && extractEXBoundingBox(xmlLayer?.EX_GeographicBoundingBox);\n    if (geographicBoundingBox) {\n        layer.geographicBoundingBox = geographicBoundingBox;\n    }\n    // v1.1.1 extract simple geographic bounding box\n    geographicBoundingBox =\n        xmlLayer?.LatLonBoundingBox && extractLatLonBoundingBox(xmlLayer?.LatLonBoundingBox);\n    if (geographicBoundingBox) {\n        layer.geographicBoundingBox = geographicBoundingBox;\n    }\n    // Extract per-CRS bounding boxes\n    const boundingBoxes = xmlLayer?.BoundingBox && extractWMSBoundingBoxes(xmlLayer?.BoundingBox);\n    if (boundingBoxes && boundingBoxes.length > 0) {\n        layer.boundingBoxes = boundingBoxes;\n    }\n    // Extract dimensions\n    const xmlDimensions = getXMLArray(xmlLayer?.Dimension);\n    const dimensions = xmlDimensions.map((xml) => extractDimension(xml));\n    if (dimensions.length) {\n        layer.dimensions = dimensions;\n    }\n    if (xmlLayer?.opaque) {\n        layer.opaque = getXMLBoolean(xmlLayer?.opaque);\n    }\n    if (xmlLayer?.cascaded) {\n        layer.cascaded = getXMLBoolean(xmlLayer?.cascaded);\n    }\n    if (xmlLayer?.queryable) {\n        layer.queryable = getXMLBoolean(xmlLayer?.queryable);\n    }\n    // Single layer is not represented as array in XML\n    const xmlLayers = getXMLArray(xmlLayer?.Layer);\n    const layers = [];\n    for (const xmlSubLayer of xmlLayers) {\n        layers.push(extractLayer(xmlSubLayer));\n    }\n    if (layers.length > 0) {\n        layer.layers = layers;\n    }\n    // Clean up object\n    for (const [key, value] of Object.entries(layer)) {\n        if (value === undefined) {\n            delete layer[key];\n        }\n    }\n    return layer;\n}\n/** WMS 1.3.0 Loosely defined geospatial bounding box in unspecified CRS for quick content searches */\nfunction extractEXBoundingBox(xmlBoundingBox) {\n    const { westBoundLongitude: w, northBoundLatitude: n, eastBoundLongitude: e, southBoundLatitude: s } = xmlBoundingBox;\n    return [\n        [w, s],\n        [e, n]\n    ];\n}\n/** WMS 1.1.1 Loosely defined geospatial bounding box in unspecified CRS for quick content searches */\nfunction extractLatLonBoundingBox(xmlBoundingBox) {\n    const { minx, miny, maxx, maxy } = xmlBoundingBox;\n    return [\n        [minx, miny],\n        [maxx, maxy]\n    ];\n}\n/** Loosely defined geospatial bounding box in unspecified CRS for quick content searches */\nfunction extractWMSBoundingBoxes(xmlBoundingBoxes) {\n    const xmlBoxes = getXMLArray(xmlBoundingBoxes);\n    return xmlBoxes.map((xmlBox) => extractWMSBoundingBox(xmlBox));\n}\n/** Loosely defined geospatial bounding box in unspecified CRS for quick content searches */\nfunction extractWMSBoundingBox(xmlBoundingBox) {\n    const { CRS, SRS, minx, miny, maxx, maxy, resx, resy } = xmlBoundingBox;\n    const boundingBox = {\n        // CRS in 1.3.0, SRS in 1.1.1\n        crs: CRS || SRS,\n        boundingBox: [\n            [getXMLFloat(minx), getXMLFloat(miny)],\n            [getXMLFloat(maxx), getXMLFloat(maxy)]\n        ]\n    };\n    if (resx) {\n        boundingBox.xResolution = resx;\n    }\n    if (resy) {\n        boundingBox.yResolution = resy;\n    }\n    return boundingBox;\n}\n/**\n * Extracts optional WMS Dimension layer field\n * @param xmlDimension\n * @example <Dimension name=\"time\" units=\"ISO8601\" default=\"2018-01-01\" nearestValue=\"0\">2001-01-01/2018-01-01/P1Y</Dimension>\n * @see https://mapserver.org/ogc/wms_dimension.html\n */\nfunction extractDimension(xmlDimension) {\n    const { name, units, value: extent } = xmlDimension;\n    const dimension = { name, units, extent };\n    if (xmlDimension.unitSymbol) {\n        dimension.unitSymbol = xmlDimension.unitSymbol;\n    }\n    if (xmlDimension.default) {\n        dimension.defaultValue = xmlDimension.default;\n    }\n    if (xmlDimension.multipleValues) {\n        dimension.multipleValues = getXMLBoolean(xmlDimension.multipleValues);\n    }\n    if (xmlDimension.nearestValue) {\n        dimension.nearestValue = getXMLBoolean(xmlDimension.nearestValue);\n    }\n    if (xmlDimension.current) {\n        dimension.current = getXMLBoolean(xmlDimension.current);\n    }\n    return dimension;\n}\n/** Traverse layers and inject missing props from parents */\n// eslint-disable-next-line complexity\nfunction addInheritedLayerProps(layer, parent) {\n    if (parent?.geographicBoundingBox && !layer.geographicBoundingBox) {\n        layer.geographicBoundingBox = [...parent.geographicBoundingBox];\n    }\n    if (parent?.crs && !layer.crs) {\n        layer.crs = [...parent.crs];\n    }\n    if (parent?.boundingBoxes && !layer.boundingBoxes) {\n        layer.boundingBoxes = [...parent.boundingBoxes];\n    }\n    if (parent?.dimensions && !layer.dimensions) {\n        layer.dimensions = [...parent.dimensions];\n    }\n    for (const subLayer of layer.layers || []) {\n        addInheritedLayerProps(subLayer, layer);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}