{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { getStringFromArrayBuffer } from \"./parse-utils.js\";\nconst SIZEOF_UINT32 = 4;\nconst DEPRECATION_WARNING = 'b3dm tile in legacy format.';\n// eslint-disable-next-line max-statements\nexport function parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset) {\n  const view = new DataView(arrayBuffer);\n  let batchLength;\n  tile.header = tile.header || {};\n  let featureTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n  let featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n  let batchTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n  let batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n  // First legacy header format - [batchLength] [batchTableByteLength] ('batchTableJsonByteLength': JSON starts with a quotation mark or the glTF magic)\n  // Second legacy format - [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength] (Second legacy format is similar as first but here we check 'batchTableBinaryByteLength' instead)\n  // Current header format - [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength]\n  // First byte will be 0x22 or 0x67. The minimum uint32 expected is 0x22000000 = 570425344 = 570MB.\n  if (batchTableJsonByteLength >= 570425344) {\n    byteOffset -= SIZEOF_UINT32 * 2;\n    batchLength = featureTableJsonByteLength;\n    batchTableJsonByteLength = featureTableBinaryByteLength;\n    batchTableBinaryByteLength = 0;\n    featureTableJsonByteLength = 0;\n    featureTableBinaryByteLength = 0;\n    console.warn(DEPRECATION_WARNING); // eslint-disable-line\n  } else if (batchTableBinaryByteLength >= 570425344) {\n    byteOffset -= SIZEOF_UINT32;\n    batchLength = batchTableJsonByteLength;\n    batchTableJsonByteLength = featureTableJsonByteLength;\n    batchTableBinaryByteLength = featureTableBinaryByteLength;\n    featureTableJsonByteLength = 0;\n    featureTableBinaryByteLength = 0;\n    console.warn(DEPRECATION_WARNING); // eslint-disable-line\n  }\n  tile.header.featureTableJsonByteLength = featureTableJsonByteLength;\n  tile.header.featureTableBinaryByteLength = featureTableBinaryByteLength;\n  tile.header.batchTableJsonByteLength = batchTableJsonByteLength;\n  tile.header.batchTableBinaryByteLength = batchTableBinaryByteLength;\n  tile.header.batchLength = batchLength;\n  return byteOffset;\n}\nexport function parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options) {\n  byteOffset = parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options);\n  byteOffset = parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options);\n  return byteOffset;\n}\nfunction parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options) {\n  const {\n    featureTableJsonByteLength,\n    featureTableBinaryByteLength,\n    batchLength\n  } = tile.header || {};\n  tile.featureTableJson = {\n    BATCH_LENGTH: batchLength || 0\n  };\n  if (featureTableJsonByteLength && featureTableJsonByteLength > 0) {\n    const featureTableString = getStringFromArrayBuffer(arrayBuffer, byteOffset, featureTableJsonByteLength);\n    tile.featureTableJson = JSON.parse(featureTableString);\n  }\n  byteOffset += featureTableJsonByteLength || 0;\n  tile.featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);\n  byteOffset += featureTableBinaryByteLength || 0;\n  /*\n  const featureTable = parseFeatureTable(featureTableJson, featureTableBinary);\n     const batchLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n  featureTable.featuresLength = batchLength;\n  */\n  return byteOffset;\n}\nfunction parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options) {\n  const {\n    batchTableJsonByteLength,\n    batchTableBinaryByteLength\n  } = tile.header || {};\n  if (batchTableJsonByteLength && batchTableJsonByteLength > 0) {\n    const batchTableString = getStringFromArrayBuffer(arrayBuffer, byteOffset, batchTableJsonByteLength);\n    tile.batchTableJson = JSON.parse(batchTableString);\n    byteOffset += batchTableJsonByteLength;\n    if (batchTableBinaryByteLength && batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      tile.batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength);\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      tile.batchTableBinary = new Uint8Array(tile.batchTableBinary);\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n  return byteOffset;\n}","map":{"version":3,"names":["getStringFromArrayBuffer","SIZEOF_UINT32","DEPRECATION_WARNING","parse3DTileTablesHeaderSync","tile","arrayBuffer","byteOffset","view","DataView","batchLength","header","featureTableJsonByteLength","getUint32","featureTableBinaryByteLength","batchTableJsonByteLength","batchTableBinaryByteLength","console","warn","parse3DTileTablesSync","options","parse3DTileFeatureTable","parse3DTileBatchTable","featureTableJson","BATCH_LENGTH","featureTableString","JSON","parse","featureTableBinary","Uint8Array","batchTableString","batchTableJson","batchTableBinary"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-tile-tables.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { getStringFromArrayBuffer } from \"./parse-utils.js\";\nconst SIZEOF_UINT32 = 4;\nconst DEPRECATION_WARNING = 'b3dm tile in legacy format.';\n// eslint-disable-next-line max-statements\nexport function parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset) {\n    const view = new DataView(arrayBuffer);\n    let batchLength;\n    tile.header = tile.header || {};\n    let featureTableJsonByteLength = view.getUint32(byteOffset, true);\n    byteOffset += SIZEOF_UINT32;\n    let featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n    byteOffset += SIZEOF_UINT32;\n    let batchTableJsonByteLength = view.getUint32(byteOffset, true);\n    byteOffset += SIZEOF_UINT32;\n    let batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n    byteOffset += SIZEOF_UINT32;\n    // First legacy header format - [batchLength] [batchTableByteLength] ('batchTableJsonByteLength': JSON starts with a quotation mark or the glTF magic)\n    // Second legacy format - [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength] (Second legacy format is similar as first but here we check 'batchTableBinaryByteLength' instead)\n    // Current header format - [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength]\n    // First byte will be 0x22 or 0x67. The minimum uint32 expected is 0x22000000 = 570425344 = 570MB.\n    if (batchTableJsonByteLength >= 570425344) {\n        byteOffset -= SIZEOF_UINT32 * 2;\n        batchLength = featureTableJsonByteLength;\n        batchTableJsonByteLength = featureTableBinaryByteLength;\n        batchTableBinaryByteLength = 0;\n        featureTableJsonByteLength = 0;\n        featureTableBinaryByteLength = 0;\n        console.warn(DEPRECATION_WARNING); // eslint-disable-line\n    }\n    else if (batchTableBinaryByteLength >= 570425344) {\n        byteOffset -= SIZEOF_UINT32;\n        batchLength = batchTableJsonByteLength;\n        batchTableJsonByteLength = featureTableJsonByteLength;\n        batchTableBinaryByteLength = featureTableBinaryByteLength;\n        featureTableJsonByteLength = 0;\n        featureTableBinaryByteLength = 0;\n        console.warn(DEPRECATION_WARNING); // eslint-disable-line\n    }\n    tile.header.featureTableJsonByteLength = featureTableJsonByteLength;\n    tile.header.featureTableBinaryByteLength = featureTableBinaryByteLength;\n    tile.header.batchTableJsonByteLength = batchTableJsonByteLength;\n    tile.header.batchTableBinaryByteLength = batchTableBinaryByteLength;\n    tile.header.batchLength = batchLength;\n    return byteOffset;\n}\nexport function parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options) {\n    byteOffset = parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options);\n    byteOffset = parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options);\n    return byteOffset;\n}\nfunction parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options) {\n    const { featureTableJsonByteLength, featureTableBinaryByteLength, batchLength } = tile.header || {};\n    tile.featureTableJson = {\n        BATCH_LENGTH: batchLength || 0\n    };\n    if (featureTableJsonByteLength && featureTableJsonByteLength > 0) {\n        const featureTableString = getStringFromArrayBuffer(arrayBuffer, byteOffset, featureTableJsonByteLength);\n        tile.featureTableJson = JSON.parse(featureTableString);\n    }\n    byteOffset += featureTableJsonByteLength || 0;\n    tile.featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);\n    byteOffset += featureTableBinaryByteLength || 0;\n    /*\n    const featureTable = parseFeatureTable(featureTableJson, featureTableBinary);\n  \n    const batchLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n    featureTable.featuresLength = batchLength;\n    */\n    return byteOffset;\n}\nfunction parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options) {\n    const { batchTableJsonByteLength, batchTableBinaryByteLength } = tile.header || {};\n    if (batchTableJsonByteLength && batchTableJsonByteLength > 0) {\n        const batchTableString = getStringFromArrayBuffer(arrayBuffer, byteOffset, batchTableJsonByteLength);\n        tile.batchTableJson = JSON.parse(batchTableString);\n        byteOffset += batchTableJsonByteLength;\n        if (batchTableBinaryByteLength && batchTableBinaryByteLength > 0) {\n            // Has a batch table binary\n            tile.batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength);\n            // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n            tile.batchTableBinary = new Uint8Array(tile.batchTableBinary);\n            byteOffset += batchTableBinaryByteLength;\n        }\n    }\n    return byteOffset;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}