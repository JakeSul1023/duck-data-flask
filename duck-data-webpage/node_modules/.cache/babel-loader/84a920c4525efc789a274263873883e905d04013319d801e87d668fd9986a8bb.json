{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { LayerExtension, _mergeShaders as mergeShaders } from '@deck.gl/core';\nimport { vec3 } from '@math.gl/core';\nimport { dashShaders, offsetShaders } from \"./shaders.glsl.js\";\nconst defaultProps = {\n  getDashArray: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  getOffset: {\n    type: 'accessor',\n    value: 0\n  },\n  dashJustified: false,\n  dashGapPickable: false\n};\n/** Adds selected features to the `PathLayer` and composite layers that render the `PathLayer`. */\nclass PathStyleExtension extends LayerExtension {\n  constructor() {\n    let {\n      dash = false,\n      offset = false,\n      highPrecisionDash = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      dash: dash || highPrecisionDash,\n      offset,\n      highPrecisionDash\n    });\n  }\n  isEnabled(layer) {\n    return 'pathTesselator' in layer.state;\n  }\n  getShaders(extension) {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n    // Merge shader injection\n    let result = {};\n    if (extension.opts.dash) {\n      result = mergeShaders(result, dashShaders);\n    }\n    if (extension.opts.offset) {\n      result = mergeShaders(result, offsetShaders);\n    }\n    const {\n      inject\n    } = result;\n    const pathStyle = {\n      name: 'pathStyle',\n      inject,\n      uniformTypes: {\n        dashAlignMode: 'f32',\n        dashGapPickable: 'i32'\n      }\n    };\n    return {\n      modules: [pathStyle]\n    };\n  }\n  initializeState(context, extension) {\n    const attributeManager = this.getAttributeManager();\n    if (!attributeManager || !extension.isEnabled(this)) {\n      // This extension only works with the PathLayer\n      return;\n    }\n    if (extension.opts.dash) {\n      attributeManager.addInstanced({\n        instanceDashArrays: {\n          size: 2,\n          accessor: 'getDashArray'\n        },\n        instanceDashOffsets: extension.opts.highPrecisionDash ? {\n          size: 1,\n          accessor: 'getPath',\n          transform: extension.getDashOffsets.bind(this)\n        } : {\n          size: 1,\n          update: attribute => {\n            attribute.constant = true;\n            attribute.value = [0];\n          }\n        }\n      });\n    }\n    if (extension.opts.offset) {\n      attributeManager.addInstanced({\n        instanceOffsets: {\n          size: 1,\n          accessor: 'getOffset'\n        }\n      });\n    }\n  }\n  updateState(params, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n    if (extension.opts.dash) {\n      const pathStyleProps = {\n        dashAlignMode: this.props.dashJustified ? 1 : 0,\n        dashGapPickable: Boolean(this.props.dashGapPickable)\n      };\n      this.setShaderModuleProps({\n        pathStyle: pathStyleProps\n      });\n    }\n  }\n  getDashOffsets(path) {\n    const result = [0];\n    const positionSize = this.props.positionFormat === 'XY' ? 2 : 3;\n    const isNested = Array.isArray(path[0]);\n    const geometrySize = isNested ? path.length : path.length / positionSize;\n    let p;\n    let prevP;\n    for (let i = 0; i < geometrySize - 1; i++) {\n      p = isNested ? path[i] : path.slice(i * positionSize, i * positionSize + positionSize);\n      p = this.projectPosition(p);\n      if (i > 0) {\n        result[i] = result[i - 1] + vec3.dist(prevP, p);\n      }\n      prevP = p;\n    }\n    result[geometrySize - 1] = 0;\n    return result;\n  }\n}\nPathStyleExtension.defaultProps = defaultProps;\nPathStyleExtension.extensionName = 'PathStyleExtension';\nexport default PathStyleExtension;\n//# sourceMappingURL=path-style-extension.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}