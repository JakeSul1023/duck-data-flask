{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Layer, project32, picking, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/engine';\nimport { gouraudMaterial } from '@luma.gl/shadertools';\n// Polygon geometry generation is managed by the polygon tesselator\nimport PolygonTesselator from \"./polygon-tesselator.js\";\nimport { solidPolygonUniforms } from \"./solid-polygon-layer-uniforms.js\";\nimport vsTop from \"./solid-polygon-layer-vertex-top.glsl.js\";\nimport vsSide from \"./solid-polygon-layer-vertex-side.glsl.js\";\nimport fs from \"./solid-polygon-layer-fragment.glsl.js\";\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  _normalize: true,\n  _windingOrder: 'CW',\n  _full3d: false,\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  getPolygon: {\n    type: 'accessor',\n    value: f => f.polygon\n  },\n  getElevation: {\n    type: 'accessor',\n    value: 1000\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  material: true\n};\nconst ATTRIBUTE_TRANSITION = {\n  enter: (value, chunk) => {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\nclass SolidPolygonLayer extends Layer {\n  getShaders(type) {\n    return super.getShaders({\n      vs: type === 'top' ? vsTop : vsSide,\n      fs,\n      defines: {\n        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === 'CCW' ? 0 : 1\n      },\n      modules: [project32, gouraudMaterial, picking, solidPolygonUniforms]\n    });\n  }\n  get wrapLongitude() {\n    return false;\n  }\n  getBounds() {\n    return this.getAttributeManager()?.getBounds(['vertexPositions']);\n  }\n  initializeState() {\n    const {\n      viewport\n    } = this.context;\n    let {\n      coordinateSystem\n    } = this.props;\n    const {\n      _full3d\n    } = this.props;\n    if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n      coordinateSystem = COORDINATE_SYSTEM.LNGLAT;\n    }\n    let preproject;\n    if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n      if (_full3d) {\n        preproject = viewport.projectPosition.bind(viewport);\n      } else {\n        preproject = viewport.projectFlat.bind(viewport);\n      }\n    }\n    this.setState({\n      numInstances: 0,\n      polygonTesselator: new PolygonTesselator({\n        // Lnglat coordinates are usually projected non-linearly, which affects tesselation results\n        // Provide a preproject function if the coordinates are in lnglat\n        preproject,\n        fp64: this.use64bitPositions(),\n        IndexType: Uint32Array\n      })\n    });\n    const attributeManager = this.getAttributeManager();\n    const noAlloc = true;\n    attributeManager.remove(['instancePickingColors']);\n    /* eslint-disable max-len */\n    attributeManager.add({\n      indices: {\n        size: 1,\n        isIndexed: true,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        update: this.calculateIndices,\n        noAlloc\n      },\n      vertexPositions: {\n        size: 3,\n        type: 'float64',\n        stepMode: 'dynamic',\n        fp64: this.use64bitPositions(),\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getPolygon',\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        update: this.calculatePositions,\n        noAlloc,\n        shaderAttributes: {\n          nextVertexPositions: {\n            vertexOffset: 1\n          }\n        }\n      },\n      instanceVertexValid: {\n        size: 1,\n        type: 'uint16',\n        stepMode: 'instance',\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        update: this.calculateVertexValid,\n        noAlloc\n      },\n      elevations: {\n        size: 1,\n        stepMode: 'dynamic',\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getElevation'\n      },\n      fillColors: {\n        size: this.props.colorFormat.length,\n        type: 'unorm8',\n        stepMode: 'dynamic',\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getFillColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      lineColors: {\n        size: this.props.colorFormat.length,\n        type: 'unorm8',\n        stepMode: 'dynamic',\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getLineColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      pickingColors: {\n        size: 4,\n        type: 'uint8',\n        stepMode: 'dynamic',\n        accessor: (object, _ref) => {\n          let {\n            index,\n            target: value\n          } = _ref;\n          return this.encodePickingColor(object && object.__source ? object.__source.index : index, value);\n        }\n      }\n    });\n    /* eslint-enable max-len */\n  }\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {\n      index\n    } = info;\n    const data = this.props.data;\n    // Check if data comes from a composite layer, wrapped with getSubLayerRow\n    if (data[0] && data[0].__source) {\n      // index decoded from picking color refers to the source index\n      info.object = data.find(d => d.__source.index === index);\n    }\n    return info;\n  }\n  disablePickingIndex(objectIndex) {\n    const data = this.props.data;\n    // Check if data comes from a composite layer, wrapped with getSubLayerRow\n    if (data[0] && data[0].__source) {\n      // index decoded from picking color refers to the source index\n      for (let i = 0; i < data.length; i++) {\n        if (data[i].__source.index === objectIndex) {\n          this._disablePickingIndex(i);\n        }\n      }\n    } else {\n      super.disablePickingIndex(objectIndex);\n    }\n  }\n  draw(_ref2) {\n    let {\n      uniforms\n    } = _ref2;\n    const {\n      extruded,\n      filled,\n      wireframe,\n      elevationScale\n    } = this.props;\n    const {\n      topModel,\n      sideModel,\n      wireframeModel,\n      polygonTesselator\n    } = this.state;\n    const renderUniforms = {\n      extruded: Boolean(extruded),\n      elevationScale,\n      isWireframe: false\n    };\n    // Note - the order is important\n    if (wireframeModel && wireframe) {\n      wireframeModel.setInstanceCount(polygonTesselator.instanceCount - 1);\n      wireframeModel.shaderInputs.setProps({\n        solidPolygon: {\n          ...renderUniforms,\n          isWireframe: true\n        }\n      });\n      wireframeModel.draw(this.context.renderPass);\n    }\n    if (sideModel && filled) {\n      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);\n      sideModel.shaderInputs.setProps({\n        solidPolygon: renderUniforms\n      });\n      sideModel.draw(this.context.renderPass);\n    }\n    if (topModel && filled) {\n      topModel.setVertexCount(polygonTesselator.vertexCount);\n      topModel.shaderInputs.setProps({\n        solidPolygon: renderUniforms\n      });\n      topModel.draw(this.context.renderPass);\n    }\n  }\n  updateState(updateParams) {\n    super.updateState(updateParams);\n    this.updateGeometry(updateParams);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = updateParams;\n    const attributeManager = this.getAttributeManager();\n    const regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;\n    if (regenerateModels) {\n      this.state.models?.forEach(model => model.destroy());\n      this.setState(this._getModels());\n      attributeManager.invalidateAll();\n    }\n  }\n  updateGeometry(_ref3) {\n    let {\n      props,\n      oldProps,\n      changeFlags\n    } = _ref3;\n    const geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);\n    // When the geometry config  or the data is changed,\n    // tessellator needs to be invoked\n    if (geometryConfigChanged) {\n      const {\n        polygonTesselator\n      } = this.state;\n      const buffers = props.data.attributes || {};\n      polygonTesselator.updateGeometry({\n        data: props.data,\n        normalize: props._normalize,\n        geometryBuffer: buffers.getPolygon,\n        buffers,\n        getGeometry: props.getPolygon,\n        positionFormat: props.positionFormat,\n        wrapLongitude: props.wrapLongitude,\n        // TODO - move the flag out of the viewport\n        resolution: this.context.viewport.resolution,\n        fp64: this.use64bitPositions(),\n        dataChanged: changeFlags.dataChanged,\n        full3d: props._full3d\n      });\n      this.setState({\n        numInstances: polygonTesselator.instanceCount,\n        startIndices: polygonTesselator.vertexStarts\n      });\n      if (!changeFlags.dataChanged) {\n        // Base `layer.updateState` only invalidates all attributes on data change\n        // Cover the rest of the scenarios here\n        this.getAttributeManager().invalidateAll();\n      }\n    }\n  }\n  _getModels() {\n    const {\n      id,\n      filled,\n      extruded\n    } = this.props;\n    let topModel;\n    let sideModel;\n    let wireframeModel;\n    if (filled) {\n      const shaders = this.getShaders('top');\n      shaders.defines.NON_INSTANCED_MODEL = 1;\n      const bufferLayout = this.getAttributeManager().getBufferLayouts({\n        isInstanced: false\n      });\n      topModel = new Model(this.context.device, {\n        ...shaders,\n        id: `${id}-top`,\n        topology: 'triangle-list',\n        bufferLayout,\n        isIndexed: true,\n        userData: {\n          excludeAttributes: {\n            instanceVertexValid: true\n          }\n        }\n      });\n    }\n    if (extruded) {\n      const bufferLayout = this.getAttributeManager().getBufferLayouts({\n        isInstanced: true\n      });\n      sideModel = new Model(this.context.device, {\n        ...this.getShaders('side'),\n        id: `${id}-side`,\n        bufferLayout,\n        geometry: new Geometry({\n          topology: 'triangle-strip',\n          attributes: {\n            // top right - top left - bottom right - bottom left\n            positions: {\n              size: 2,\n              value: new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])\n            }\n          }\n        }),\n        isInstanced: true,\n        userData: {\n          excludeAttributes: {\n            indices: true\n          }\n        }\n      });\n      wireframeModel = new Model(this.context.device, {\n        ...this.getShaders('side'),\n        id: `${id}-wireframe`,\n        bufferLayout,\n        geometry: new Geometry({\n          topology: 'line-strip',\n          attributes: {\n            // top right - top left - bottom left - bottom right\n            positions: {\n              size: 2,\n              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])\n            }\n          }\n        }),\n        isInstanced: true,\n        userData: {\n          excludeAttributes: {\n            indices: true\n          }\n        }\n      });\n    }\n    return {\n      models: [sideModel, wireframeModel, topModel].filter(Boolean),\n      topModel,\n      sideModel,\n      wireframeModel\n    };\n  }\n  calculateIndices(attribute) {\n    const {\n      polygonTesselator\n    } = this.state;\n    attribute.startIndices = polygonTesselator.indexStarts;\n    attribute.value = polygonTesselator.get('indices');\n  }\n  calculatePositions(attribute) {\n    const {\n      polygonTesselator\n    } = this.state;\n    attribute.startIndices = polygonTesselator.vertexStarts;\n    attribute.value = polygonTesselator.get('positions');\n  }\n  calculateVertexValid(attribute) {\n    attribute.value = this.state.polygonTesselator.get('vertexValid');\n  }\n}\nSolidPolygonLayer.defaultProps = defaultProps;\nSolidPolygonLayer.layerName = 'SolidPolygonLayer';\nexport default SolidPolygonLayer;\n//# sourceMappingURL=solid-polygon-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}