{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Texture } from '@luma.gl/core';\n/**\n * Helper class for working with repeated transformations / computations\n * Primarily intended for GPU buffers `Swap<Buffer>` or textures `Swap<Texture>`)\n * @note the two resources are expected to be structurally identical (same size, length, format, etc)\n * @note the two resources can be destroyed by calling `destroy()`\n */\nexport class Swap {\n  /** The current resource - usually the source for renders or computations */\n  current;\n  /** The next resource - usually the target/destination for transforms / computations */\n  next;\n  constructor(props) {\n    this.current = props.current;\n    this.next = props.next;\n  }\n  /** Destroys the two managed resources */\n  destroy() {\n    this.current?.destroy();\n    this.next?.destroy();\n  }\n  /** Make the next resource into the current resource, and reuse the current resource as the next resource */\n  swap() {\n    const current = this.current;\n    this.current = this.next;\n    this.next = current;\n  }\n}\n/** Helper for managing double-buffered framebuffers */\nexport class SwapFramebuffers extends Swap {\n  constructor(device, props) {\n    props = {\n      ...props\n    };\n    let colorAttachments = props.colorAttachments?.map(colorAttachment => typeof colorAttachment !== 'string' ? colorAttachment : device.createTexture({\n      format: colorAttachment,\n      usage: Texture.COPY_DST | Texture.RENDER_ATTACHMENT\n    }));\n    const current = device.createFramebuffer({\n      ...props,\n      colorAttachments\n    });\n    colorAttachments = props.colorAttachments?.map(colorAttachment => typeof colorAttachment !== 'string' ? colorAttachment : device.createTexture({\n      format: colorAttachment,\n      usage: Texture.COPY_DST | Texture.RENDER_ATTACHMENT\n    }));\n    const next = device.createFramebuffer({\n      ...props,\n      colorAttachments\n    });\n    super({\n      current,\n      next\n    });\n  }\n  /**\n   * Resizes the Framebuffers.\n   * @returns true if the size changed, otherwise exiting framebuffers were preserved\n   * @note any contents are not preserved!\n   */\n  resize(size) {\n    if (size.width === this.current.width && size.height === this.current.height) {\n      return false;\n    }\n    const {\n      current,\n      next\n    } = this;\n    this.current = current.clone(size);\n    current.destroy();\n    this.next = next.clone(size);\n    next.destroy();\n    return true;\n  }\n}\n/** Helper for managing double-buffered GPU buffers */\nexport class SwapBuffers extends Swap {\n  constructor(device, props) {\n    super({\n      current: device.createBuffer(props),\n      next: device.createBuffer(props)\n    });\n  }\n  /**\n   * Resizes the Buffers.\n   * @returns true if the size changed, otherwise exiting buffers were preserved.\n   * @note any contents are not preserved!\n   */\n  resize(props) {\n    if (props.byteLength === this.current.byteLength) {\n      return false;\n    }\n    const {\n      current,\n      next\n    } = this;\n    this.current = current.clone(props);\n    current.destroy();\n    this.next = next.clone(props);\n    next.destroy();\n    return true;\n  }\n}","map":{"version":3,"names":["Texture","Swap","current","next","constructor","props","destroy","swap","SwapFramebuffers","device","colorAttachments","map","colorAttachment","createTexture","format","usage","COPY_DST","RENDER_ATTACHMENT","createFramebuffer","resize","size","width","height","clone","SwapBuffers","createBuffer","byteLength"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\engine\\src\\compute\\swap.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {BufferProps, FramebufferProps} from '@luma.gl/core';\nimport {Device, Resource, Buffer, Framebuffer, Texture} from '@luma.gl/core';\n\n/**\n * Helper class for working with repeated transformations / computations\n * Primarily intended for GPU buffers `Swap<Buffer>` or textures `Swap<Texture>`)\n * @note the two resources are expected to be structurally identical (same size, length, format, etc)\n * @note the two resources can be destroyed by calling `destroy()`\n */\nexport class Swap<T extends Resource<any>> {\n  /** The current resource - usually the source for renders or computations */\n  current: T;\n  /** The next resource - usually the target/destination for transforms / computations */\n  next: T;\n\n  constructor(props: {current: T; next: T}) {\n    this.current = props.current;\n    this.next = props.next;\n  }\n\n  /** Destroys the two managed resources */\n  destroy() {\n    this.current?.destroy();\n    this.next?.destroy();\n  }\n\n  /** Make the next resource into the current resource, and reuse the current resource as the next resource */\n  swap() {\n    const current = this.current;\n    this.current = this.next;\n    this.next = current;\n  }\n}\n\n/** Helper for managing double-buffered framebuffers */\nexport class SwapFramebuffers extends Swap<Framebuffer> {\n  constructor(device: Device, props: FramebufferProps) {\n    props = {...props};\n\n    let colorAttachments = props.colorAttachments?.map(colorAttachment =>\n      typeof colorAttachment !== 'string'\n        ? colorAttachment\n        : device.createTexture({\n            format: colorAttachment,\n            usage: Texture.COPY_DST | Texture.RENDER_ATTACHMENT\n          })\n    );\n\n    const current = device.createFramebuffer({...props, colorAttachments});\n\n    colorAttachments = props.colorAttachments?.map(colorAttachment =>\n      typeof colorAttachment !== 'string'\n        ? colorAttachment\n        : device.createTexture({\n            format: colorAttachment,\n            usage: Texture.COPY_DST | Texture.RENDER_ATTACHMENT\n          })\n    );\n\n    const next = device.createFramebuffer({...props, colorAttachments});\n\n    super({current, next});\n  }\n\n  /**\n   * Resizes the Framebuffers.\n   * @returns true if the size changed, otherwise exiting framebuffers were preserved\n   * @note any contents are not preserved!\n   */\n  resize(size: {width: number; height: number}): boolean {\n    if (size.width === this.current.width && size.height === this.current.height) {\n      return false;\n    }\n    const {current, next} = this;\n\n    this.current = current.clone(size);\n    current.destroy();\n\n    this.next = next.clone(size);\n    next.destroy();\n\n    return true;\n  }\n}\n\n/** Helper for managing double-buffered GPU buffers */\nexport class SwapBuffers extends Swap<Buffer> {\n  constructor(device: Device, props: BufferProps) {\n    super({current: device.createBuffer(props), next: device.createBuffer(props)});\n  }\n\n  /**\n   * Resizes the Buffers.\n   * @returns true if the size changed, otherwise exiting buffers were preserved.\n   * @note any contents are not preserved!\n   */\n  resize(props: {byteLength: number}) {\n    if (props.byteLength === this.current.byteLength) {\n      return false;\n    }\n\n    const {current, next} = this;\n\n    this.current = current.clone(props);\n    current.destroy();\n\n    this.next = next.clone(props);\n    next.destroy();\n\n    return true;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}