{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getMeshBoundingBox } from '@loaders.gl/schema';\nimport decode, { DECODING_STEPS } from \"./decode-quantized-mesh.js\";\nimport { addSkirt } from \"./helpers/skirt.js\";\nexport function parseQuantizedMesh(arrayBuffer, options = {}) {\n  const {\n    bounds\n  } = options;\n  // Don't parse edge indices or format extensions\n  const {\n    header,\n    vertexData,\n    triangleIndices: originalTriangleIndices,\n    westIndices,\n    northIndices,\n    eastIndices,\n    southIndices\n  } = decode(arrayBuffer, DECODING_STEPS.triangleIndices);\n  let triangleIndices = originalTriangleIndices;\n  let attributes = getMeshAttributes(vertexData, header, bounds);\n  // Compute bounding box before adding skirt so that z values are not skewed\n  // TODO: Find bounding box from header, instead of doing extra pass over\n  // vertices.\n  const boundingBox = getMeshBoundingBox(attributes);\n  if (options?.skirtHeight) {\n    const {\n      attributes: newAttributes,\n      triangles: newTriangles\n    } = addSkirt(attributes, triangleIndices, options.skirtHeight, {\n      westIndices,\n      northIndices,\n      eastIndices,\n      southIndices\n    });\n    attributes = newAttributes;\n    triangleIndices = newTriangles;\n  }\n  return {\n    // Data return by this loader implementation\n    loaderData: {\n      header: {}\n    },\n    header: {\n      // @ts-ignore\n      vertexCount: triangleIndices.length,\n      boundingBox\n    },\n    // TODO\n    schema: undefined,\n    topology: 'triangle-list',\n    mode: 4,\n    // TRIANGLES\n    indices: {\n      value: triangleIndices,\n      size: 1\n    },\n    attributes\n  };\n}\nfunction getMeshAttributes(vertexData, header, bounds) {\n  const {\n    minHeight,\n    maxHeight\n  } = header;\n  const [minX, minY, maxX, maxY] = bounds || [0, 0, 1, 1];\n  const xScale = maxX - minX;\n  const yScale = maxY - minY;\n  const zScale = maxHeight - minHeight;\n  const nCoords = vertexData.length / 3;\n  // vec3. x, y defined by bounds, z in meters\n  const positions = new Float32Array(nCoords * 3);\n  // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n  const texCoords = new Float32Array(nCoords * 2);\n  // Data is not interleaved; all u, then all v, then all heights\n  for (let i = 0; i < nCoords; i++) {\n    const x = vertexData[i] / 32767;\n    const y = vertexData[i + nCoords] / 32767;\n    const z = vertexData[i + nCoords * 2] / 32767;\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = y * yScale + minY;\n    positions[3 * i + 2] = z * zScale + minHeight;\n    texCoords[2 * i + 0] = x;\n    texCoords[2 * i + 1] = y;\n  }\n  return {\n    POSITION: {\n      value: positions,\n      size: 3\n    },\n    TEXCOORD_0: {\n      value: texCoords,\n      size: 2\n    }\n    // TODO: Parse normals if they exist in the file\n    // NORMAL: {}, - optional, but creates the high poly look with lighting\n  };\n}","map":{"version":3,"names":["getMeshBoundingBox","decode","DECODING_STEPS","addSkirt","parseQuantizedMesh","arrayBuffer","options","bounds","header","vertexData","triangleIndices","originalTriangleIndices","westIndices","northIndices","eastIndices","southIndices","attributes","getMeshAttributes","boundingBox","skirtHeight","newAttributes","triangles","newTriangles","loaderData","vertexCount","length","schema","undefined","topology","mode","indices","value","size","minHeight","maxHeight","minX","minY","maxX","maxY","xScale","yScale","zScale","nCoords","positions","Float32Array","texCoords","i","x","y","z","POSITION","TEXCOORD_0"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/terrain/dist/lib/parse-quantized-mesh.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getMeshBoundingBox } from '@loaders.gl/schema';\nimport decode, { DECODING_STEPS } from \"./decode-quantized-mesh.js\";\nimport { addSkirt } from \"./helpers/skirt.js\";\nexport function parseQuantizedMesh(arrayBuffer, options = {}) {\n    const { bounds } = options;\n    // Don't parse edge indices or format extensions\n    const { header, vertexData, triangleIndices: originalTriangleIndices, westIndices, northIndices, eastIndices, southIndices } = decode(arrayBuffer, DECODING_STEPS.triangleIndices);\n    let triangleIndices = originalTriangleIndices;\n    let attributes = getMeshAttributes(vertexData, header, bounds);\n    // Compute bounding box before adding skirt so that z values are not skewed\n    // TODO: Find bounding box from header, instead of doing extra pass over\n    // vertices.\n    const boundingBox = getMeshBoundingBox(attributes);\n    if (options?.skirtHeight) {\n        const { attributes: newAttributes, triangles: newTriangles } = addSkirt(attributes, triangleIndices, options.skirtHeight, {\n            westIndices,\n            northIndices,\n            eastIndices,\n            southIndices\n        });\n        attributes = newAttributes;\n        triangleIndices = newTriangles;\n    }\n    return {\n        // Data return by this loader implementation\n        loaderData: {\n            header: {}\n        },\n        header: {\n            // @ts-ignore\n            vertexCount: triangleIndices.length,\n            boundingBox\n        },\n        // TODO\n        schema: undefined,\n        topology: 'triangle-list',\n        mode: 4, // TRIANGLES\n        indices: { value: triangleIndices, size: 1 },\n        attributes\n    };\n}\nfunction getMeshAttributes(vertexData, header, bounds) {\n    const { minHeight, maxHeight } = header;\n    const [minX, minY, maxX, maxY] = bounds || [0, 0, 1, 1];\n    const xScale = maxX - minX;\n    const yScale = maxY - minY;\n    const zScale = maxHeight - minHeight;\n    const nCoords = vertexData.length / 3;\n    // vec3. x, y defined by bounds, z in meters\n    const positions = new Float32Array(nCoords * 3);\n    // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n    const texCoords = new Float32Array(nCoords * 2);\n    // Data is not interleaved; all u, then all v, then all heights\n    for (let i = 0; i < nCoords; i++) {\n        const x = vertexData[i] / 32767;\n        const y = vertexData[i + nCoords] / 32767;\n        const z = vertexData[i + nCoords * 2] / 32767;\n        positions[3 * i + 0] = x * xScale + minX;\n        positions[3 * i + 1] = y * yScale + minY;\n        positions[3 * i + 2] = z * zScale + minHeight;\n        texCoords[2 * i + 0] = x;\n        texCoords[2 * i + 1] = y;\n    }\n    return {\n        POSITION: { value: positions, size: 3 },\n        TEXCOORD_0: { value: texCoords, size: 2 }\n        // TODO: Parse normals if they exist in the file\n        // NORMAL: {}, - optional, but creates the high poly look with lighting\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}