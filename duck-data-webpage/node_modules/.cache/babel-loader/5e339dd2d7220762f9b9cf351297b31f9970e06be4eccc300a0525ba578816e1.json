{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { MD5Hash } from '@loaders.gl/crypto';\nimport { concatenateArrayBuffers, concatenateArrayBuffersFromArray } from '@loaders.gl/loader-utils';\nimport { makeZipCDHeaderIterator } from \"./parse-zip/cd-file-header.js\";\n/**\n * Reads hash file from buffer and returns it in ready-to-use form\n * @param arrayBuffer - buffer containing hash file\n * @returns Map containing hash and offset\n */\nexport function parseHashTable(arrayBuffer) {\n  const dataView = new DataView(arrayBuffer);\n  const hashMap = {};\n  for (let i = 0; i < arrayBuffer.byteLength; i = i + 24) {\n    const offset = dataView.getBigUint64(i + 16, true);\n    const hash = bufferToHex(arrayBuffer, i, 16);\n    hashMap[hash] = offset;\n  }\n  return hashMap;\n}\nfunction bufferToHex(buffer, start, length) {\n  // buffer is an ArrayBuffer\n  return [...new Uint8Array(buffer, start, length)].map(x => x.toString(16).padStart(2, '0')).join('');\n}\n/**\n * generates hash info from zip files \"central directory\"\n * @param fileProvider - provider of the archive\n * @returns ready to use hash info\n */\nexport async function makeHashTableFromZipHeaders(fileProvider) {\n  const zipCDIterator = makeZipCDHeaderIterator(fileProvider);\n  return getHashTable(zipCDIterator);\n}\n/**\n * creates hash table from file offset iterator\n * @param zipCDIterator iterator to use\n * @returns hash table\n */\nexport async function getHashTable(zipCDIterator) {\n  const md5Hash = new MD5Hash();\n  const textEncoder = new TextEncoder();\n  const hashTable = {};\n  for await (const cdHeader of zipCDIterator) {\n    const filename = cdHeader.fileName.split('\\\\').join('/').toLocaleLowerCase();\n    const arrayBuffer = textEncoder.encode(filename).buffer;\n    const md5 = await md5Hash.hash(arrayBuffer, 'hex');\n    hashTable[md5] = cdHeader.localHeaderOffset;\n  }\n  return hashTable;\n}\n/**\n * creates hash file that later can be added to the SLPK archive\n * @param zipCDIterator iterator to use\n * @returns ArrayBuffer containing hash file\n */\nexport async function composeHashFile(zipCDIterator) {\n  const md5Hash = new MD5Hash();\n  const textEncoder = new TextEncoder();\n  const hashArray = [];\n  for await (const cdHeader of zipCDIterator) {\n    let filename = cdHeader.fileName.split('\\\\').join('/');\n    // I3S edge case. All files should be lower case by spec. However, ArcGIS\n    // and official i3s_converter https://github.com/Esri/i3s-spec/blob/master/i3s_converter/i3s_converter_ReadMe.md\n    // expect `3dSceneLayer.json.gz` in camel case\n    if (filename !== '3dSceneLayer.json.gz') {\n      filename = filename.toLocaleLowerCase();\n    }\n    const arrayBuffer = textEncoder.encode(filename).buffer;\n    const md5 = await md5Hash.hash(arrayBuffer, 'hex');\n    hashArray.push(concatenateArrayBuffers(hexStringToBuffer(md5), bigintToBuffer(cdHeader.localHeaderOffset)));\n  }\n  const bufferArray = hashArray.sort(compareHashes);\n  return concatenateArrayBuffersFromArray(bufferArray);\n}\n/**\n * Function to compare md5 hashes according to https://github.com/Esri/i3s-spec/blob/master/docs/2.0/slpk_hashtable.pcsl.md\n * @param arrA first hash to compare\n * @param arrB second hash to compare\n * @returns 0 if equal, negative number if a<b, pozitive if a>b\n */\nfunction compareHashes(arrA, arrB) {\n  const a = new BigUint64Array(arrA);\n  const b = new BigUint64Array(arrB);\n  return Number(a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]);\n}\n/**\n * converts hex string to buffer\n * @param str hex string to convert\n * @returns conversion result\n */\nfunction hexStringToBuffer(str) {\n  const byteArray = str.match(/../g)?.map(h => parseInt(h, 16));\n  return new Uint8Array(byteArray ?? new Array(16)).buffer;\n}\n/**\n * converts bigint to buffer\n * @param n bigint to convert\n * @returns convertion result\n */\nfunction bigintToBuffer(n) {\n  return new BigUint64Array([n]).buffer;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}