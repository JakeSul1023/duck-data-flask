{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* eslint-disable max-statements, max-params, complexity, max-depth */\n// TODO merge with icon-layer/icon-manager\nimport { log } from '@deck.gl/core';\nconst MISSING_CHAR_WIDTH = 32;\nconst SINGLE_LINE = [];\nexport function nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n/**\n * Generate character mapping table or update from an existing mapping table\n */\nexport function buildMapping({\n  characterSet,\n  getFontWidth,\n  fontHeight,\n  buffer,\n  maxCanvasWidth,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0\n}) {\n  let row = 0;\n  // continue from x position of last character in the old mapping\n  let x = xOffset;\n  const rowHeight = fontHeight + buffer * 2;\n  for (const char of characterSet) {\n    if (!mapping[char]) {\n      // measure texts\n      // TODO - use Advanced text metrics when they are adopted:\n      // https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics\n      const width = getFontWidth(char);\n      if (x + width + buffer * 2 > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n      mapping[char] = {\n        x: x + buffer,\n        y: yOffset + row * rowHeight + buffer,\n        width,\n        height: rowHeight,\n        layoutWidth: width,\n        layoutHeight: fontHeight\n      };\n      x += width + buffer * 2;\n    }\n  }\n  return {\n    mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)\n  };\n}\nfunction getTextWidth(text, startIndex, endIndex, mapping) {\n  let width = 0;\n  for (let i = startIndex; i < endIndex; i++) {\n    const character = text[i];\n    width += mapping[character]?.layoutWidth || 0;\n  }\n  return width;\n}\nfunction breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  let rowStartCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n  for (let i = startIndex; i < endIndex; i++) {\n    // 2. figure out where to break lines\n    const textWidth = getTextWidth(text, i, i + 1, iconMapping);\n    if (rowOffsetLeft + textWidth > maxWidth) {\n      if (rowStartCharIndex < i) {\n        target.push(i);\n      }\n      rowStartCharIndex = i;\n      rowOffsetLeft = 0;\n    }\n    rowOffsetLeft += textWidth;\n  }\n  return rowOffsetLeft;\n}\nfunction breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  let rowStartCharIndex = startIndex;\n  let groupStartCharIndex = startIndex;\n  let groupEndCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n  for (let i = startIndex; i < endIndex; i++) {\n    // 1. break text into word groups\n    //  - if current char is white space\n    //  - else if next char is white space\n    //  - else if reach last char\n    if (text[i] === ' ') {\n      groupEndCharIndex = i + 1;\n    } else if (text[i + 1] === ' ' || i + 1 === endIndex) {\n      groupEndCharIndex = i + 1;\n    }\n    if (groupEndCharIndex > groupStartCharIndex) {\n      // 2. break text into next row at maxWidth\n      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);\n      if (rowOffsetLeft + groupWidth > maxWidth) {\n        if (rowStartCharIndex < groupStartCharIndex) {\n          target.push(groupStartCharIndex);\n          rowStartCharIndex = groupStartCharIndex;\n          rowOffsetLeft = 0;\n        }\n        // if a single text group is bigger than maxWidth, then `break-all`\n        if (groupWidth > maxWidth) {\n          groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);\n          // move reference to last row\n          rowStartCharIndex = target[target.length - 1];\n        }\n      }\n      groupStartCharIndex = groupEndCharIndex;\n      rowOffsetLeft += groupWidth;\n    }\n  }\n  return rowOffsetLeft;\n}\n/**\n * Wrap the given text so that each line does not exceed the given max width.\n * Returns a list of indices where line breaks should be inserted.\n */\nexport function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {\n  if (endIndex === undefined) {\n    endIndex = text.length;\n  }\n  const result = [];\n  if (wordBreak === 'break-all') {\n    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  } else {\n    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  }\n  return result;\n}\nfunction transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {\n  let x = 0;\n  let rowHeight = 0;\n  for (let i = startIndex; i < endIndex; i++) {\n    const character = line[i];\n    const frame = iconMapping[character];\n    if (frame) {\n      if (!rowHeight) {\n        // frame.height should be a constant\n        rowHeight = frame.layoutHeight;\n      }\n      leftOffsets[i] = x + frame.layoutWidth / 2;\n      x += frame.layoutWidth;\n    } else {\n      log.warn(`Missing character: ${character} (${character.codePointAt(0)})`)();\n      leftOffsets[i] = x;\n      x += MISSING_CHAR_WIDTH;\n    }\n  }\n  rowSize[0] = x;\n  rowSize[1] = rowHeight;\n}\n/**\n * Transform a text paragraph to an array of characters, each character contains\n */\nexport function transformParagraph(paragraph, /** CSS line-height */\nlineHeight, /** CSS word-break option */\nwordBreak, /** CSS max-width */\nmaxWidth, /** character mapping table for retrieving a character from font atlas */\niconMapping) {\n  // Break into an array of characters\n  // When dealing with double-length unicode characters, `str.length` or `str[i]` do not work\n  const characters = Array.from(paragraph);\n  const numCharacters = characters.length;\n  const x = new Array(numCharacters);\n  const y = new Array(numCharacters);\n  const rowWidth = new Array(numCharacters);\n  const autoWrappingEnabled = (wordBreak === 'break-word' || wordBreak === 'break-all') && isFinite(maxWidth) && maxWidth > 0;\n  // maxWidth and height of the paragraph\n  const size = [0, 0];\n  const rowSize = [0, 0];\n  let rowOffsetTop = 0;\n  let lineStartIndex = 0;\n  let lineEndIndex = 0;\n  for (let i = 0; i <= numCharacters; i++) {\n    const char = characters[i];\n    if (char === '\\n' || i === numCharacters) {\n      lineEndIndex = i;\n    }\n    if (lineEndIndex > lineStartIndex) {\n      const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;\n      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {\n        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];\n        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;\n        transformRow(characters, rowStart, rowEnd, iconMapping, x, rowSize);\n        for (let j = rowStart; j < rowEnd; j++) {\n          const char = characters[j];\n          const layoutOffsetY = iconMapping[char]?.layoutOffsetY || 0;\n          y[j] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;\n          rowWidth[j] = rowSize[0];\n        }\n        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;\n        size[0] = Math.max(size[0], rowSize[0]);\n      }\n      lineStartIndex = lineEndIndex;\n    }\n    if (char === '\\n') {\n      // Make sure result.length matches paragraph.length\n      x[lineStartIndex] = 0;\n      y[lineStartIndex] = 0;\n      rowWidth[lineStartIndex] = 0;\n      lineStartIndex++;\n    }\n  }\n  // last row\n  size[1] = rowOffsetTop;\n  return {\n    x,\n    y,\n    rowWidth,\n    size\n  };\n}\nexport function getTextFromBuffer({\n  value,\n  length,\n  stride,\n  offset,\n  startIndices,\n  characterSet\n}) {\n  const bytesPerElement = value.BYTES_PER_ELEMENT;\n  const elementStride = stride ? stride / bytesPerElement : 1;\n  const elementOffset = offset ? offset / bytesPerElement : 0;\n  const characterCount = startIndices[length] || Math.ceil((value.length - elementOffset) / elementStride);\n  const autoCharacterSet = characterSet && new Set();\n  const texts = new Array(length);\n  let codes = value;\n  if (elementStride > 1 || elementOffset > 0) {\n    const ArrayType = value.constructor;\n    codes = new ArrayType(characterCount);\n    for (let i = 0; i < characterCount; i++) {\n      codes[i] = value[i * elementStride + elementOffset];\n    }\n  }\n  for (let index = 0; index < length; index++) {\n    const startIndex = startIndices[index];\n    const endIndex = startIndices[index + 1] || characterCount;\n    const codesAtIndex = codes.subarray(startIndex, endIndex);\n    // @ts-ignore TS wants the argument to be number[] but typed array works too\n    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);\n    if (autoCharacterSet) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);\n    }\n  }\n  if (autoCharacterSet) {\n    for (const charCode of autoCharacterSet) {\n      characterSet.add(String.fromCodePoint(charCode));\n    }\n  }\n  return {\n    texts,\n    characterCount\n  };\n}","map":{"version":3,"names":["log","MISSING_CHAR_WIDTH","SINGLE_LINE","nextPowOfTwo","number","Math","pow","ceil","log2","buildMapping","characterSet","getFontWidth","fontHeight","buffer","maxCanvasWidth","mapping","xOffset","yOffset","row","x","rowHeight","char","width","y","height","layoutWidth","layoutHeight","canvasHeight","getTextWidth","text","startIndex","endIndex","i","character","breakAll","maxWidth","iconMapping","target","rowStartCharIndex","rowOffsetLeft","textWidth","push","breakWord","groupStartCharIndex","groupEndCharIndex","groupWidth","length","autoWrapping","wordBreak","undefined","result","transformRow","line","leftOffsets","rowSize","frame","warn","codePointAt","transformParagraph","paragraph","lineHeight","characters","Array","from","numCharacters","rowWidth","autoWrappingEnabled","isFinite","size","rowOffsetTop","lineStartIndex","lineEndIndex","rows","rowIndex","rowStart","rowEnd","j","layoutOffsetY","max","getTextFromBuffer","value","stride","offset","startIndices","bytesPerElement","BYTES_PER_ELEMENT","elementStride","elementOffset","characterCount","autoCharacterSet","Set","texts","codes","ArrayType","constructor","index","codesAtIndex","subarray","String","fromCodePoint","apply","forEach","add","charCode"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\layers\\src\\text-layer\\utils.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable max-statements, max-params, complexity, max-depth */\n// TODO merge with icon-layer/icon-manager\nimport {log} from '@deck.gl/core';\nimport type {NumericArray} from '@math.gl/core';\n\nconst MISSING_CHAR_WIDTH = 32;\nconst SINGLE_LINE = [];\n\nexport type Character = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  layoutWidth: number;\n  layoutHeight: number;\n  layoutOffsetY?: number;\n};\n\nexport type CharacterMapping = Record<string, Character>;\n\nexport function nextPowOfTwo(number: number): number {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\n/**\n * Generate character mapping table or update from an existing mapping table\n */\nexport function buildMapping({\n  characterSet,\n  getFontWidth,\n  fontHeight,\n  buffer,\n  maxCanvasWidth,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0\n}: {\n  /** list of characters */\n  characterSet: Set<string>;\n  /** function to get width of each character */\n  getFontWidth: (char: string) => number;\n  /** height of font */\n  fontHeight: number;\n  /** bleeding buffer surround each character */\n  buffer: number;\n  /** max width of font atlas */\n  maxCanvasWidth: number;\n  /** cached mapping table */\n  mapping?: CharacterMapping;\n  /** x position of last character in the existing mapping table */\n  xOffset?: number;\n  /** y position of last character in the existing mapping table */\n  yOffset?: number;\n}): {\n  /** new mapping table */\n  mapping: CharacterMapping;\n  /** x position of last character in the new mapping table */\n  xOffset: number;\n  /** y position of last character in the new mapping table */\n  yOffset: number;\n  /** height of the font atlas canvas, power of 2 */\n  canvasHeight: number;\n} {\n  let row = 0;\n  // continue from x position of last character in the old mapping\n  let x = xOffset;\n  const rowHeight = fontHeight + buffer * 2;\n\n  for (const char of characterSet) {\n    if (!mapping[char]) {\n      // measure texts\n      // TODO - use Advanced text metrics when they are adopted:\n      // https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics\n      const width = getFontWidth(char);\n\n      if (x + width + buffer * 2 > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n      mapping[char] = {\n        x: x + buffer,\n        y: yOffset + row * rowHeight + buffer,\n        width,\n        height: rowHeight,\n        layoutWidth: width,\n        layoutHeight: fontHeight\n      };\n      x += width + buffer * 2;\n    }\n  }\n\n  return {\n    mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)\n  };\n}\n\nfunction getTextWidth(\n  text: string[],\n  startIndex: number,\n  endIndex: number,\n  mapping: CharacterMapping\n): number {\n  let width = 0;\n  for (let i = startIndex; i < endIndex; i++) {\n    const character = text[i];\n    width += mapping[character]?.layoutWidth || 0;\n  }\n\n  return width;\n}\n\nfunction breakAll(\n  text: string[],\n  startIndex: number,\n  endIndex: number,\n  maxWidth: number,\n  iconMapping: CharacterMapping,\n  target: number[]\n): number {\n  let rowStartCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    // 2. figure out where to break lines\n    const textWidth = getTextWidth(text, i, i + 1, iconMapping);\n    if (rowOffsetLeft + textWidth > maxWidth) {\n      if (rowStartCharIndex < i) {\n        target.push(i);\n      }\n      rowStartCharIndex = i;\n      rowOffsetLeft = 0;\n    }\n    rowOffsetLeft += textWidth;\n  }\n\n  return rowOffsetLeft;\n}\n\nfunction breakWord(\n  text: string[],\n  startIndex: number,\n  endIndex: number,\n  maxWidth: number,\n  iconMapping: CharacterMapping,\n  target: number[]\n): number {\n  let rowStartCharIndex = startIndex;\n  let groupStartCharIndex = startIndex;\n  let groupEndCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    // 1. break text into word groups\n    //  - if current char is white space\n    //  - else if next char is white space\n    //  - else if reach last char\n    if (text[i] === ' ') {\n      groupEndCharIndex = i + 1;\n    } else if (text[i + 1] === ' ' || i + 1 === endIndex) {\n      groupEndCharIndex = i + 1;\n    }\n\n    if (groupEndCharIndex > groupStartCharIndex) {\n      // 2. break text into next row at maxWidth\n      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);\n      if (rowOffsetLeft + groupWidth > maxWidth) {\n        if (rowStartCharIndex < groupStartCharIndex) {\n          target.push(groupStartCharIndex);\n          rowStartCharIndex = groupStartCharIndex;\n          rowOffsetLeft = 0;\n        }\n\n        // if a single text group is bigger than maxWidth, then `break-all`\n        if (groupWidth > maxWidth) {\n          groupWidth = breakAll(\n            text,\n            groupStartCharIndex,\n            groupEndCharIndex,\n            maxWidth,\n            iconMapping,\n            target\n          );\n          // move reference to last row\n          rowStartCharIndex = target[target.length - 1];\n        }\n      }\n      groupStartCharIndex = groupEndCharIndex;\n      rowOffsetLeft += groupWidth;\n    }\n  }\n\n  return rowOffsetLeft;\n}\n\n/**\n * Wrap the given text so that each line does not exceed the given max width.\n * Returns a list of indices where line breaks should be inserted.\n */\nexport function autoWrapping(\n  text: string[],\n  wordBreak: 'break-all' | 'break-word',\n  maxWidth: number,\n  iconMapping: CharacterMapping,\n  startIndex: number = 0,\n  endIndex: number\n): number[] {\n  if (endIndex === undefined) {\n    endIndex = text.length;\n  }\n  const result = [];\n  if (wordBreak === 'break-all') {\n    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  } else {\n    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  }\n  return result;\n}\n\nfunction transformRow(\n  line: string[],\n  startIndex: number,\n  endIndex: number,\n  iconMapping: CharacterMapping,\n  leftOffsets: number[],\n  rowSize: [number, number]\n) {\n  let x = 0;\n  let rowHeight = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    const character = line[i];\n    const frame = iconMapping[character];\n    if (frame) {\n      if (!rowHeight) {\n        // frame.height should be a constant\n        rowHeight = frame.layoutHeight;\n      }\n      leftOffsets[i] = x + frame.layoutWidth / 2;\n      x += frame.layoutWidth;\n    } else {\n      log.warn(`Missing character: ${character} (${character.codePointAt(0)})`)();\n      leftOffsets[i] = x;\n      x += MISSING_CHAR_WIDTH;\n    }\n  }\n\n  rowSize[0] = x;\n  rowSize[1] = rowHeight;\n}\n\n/**\n * Transform a text paragraph to an array of characters, each character contains\n */\nexport function transformParagraph(\n  paragraph: string,\n  /** CSS line-height */\n  lineHeight: number,\n  /** CSS word-break option */\n  wordBreak: 'break-word' | 'break-all',\n  /** CSS max-width */\n  maxWidth: number,\n  /** character mapping table for retrieving a character from font atlas */\n  iconMapping: CharacterMapping\n): {\n  /** x position of each character */\n  x: number[];\n  /** y position of each character */\n  y: number[];\n  /** the current row width of each character */\n  rowWidth: number[];\n  /** the width and height of the paragraph */\n  size: [number, number];\n} {\n  // Break into an array of characters\n  // When dealing with double-length unicode characters, `str.length` or `str[i]` do not work\n  const characters = Array.from(paragraph);\n  const numCharacters = characters.length;\n  const x = new Array(numCharacters) as number[];\n  const y = new Array(numCharacters) as number[];\n  const rowWidth = new Array(numCharacters) as number[];\n  const autoWrappingEnabled =\n    (wordBreak === 'break-word' || wordBreak === 'break-all') && isFinite(maxWidth) && maxWidth > 0;\n\n  // maxWidth and height of the paragraph\n  const size: [number, number] = [0, 0];\n  const rowSize: [number, number] = [0, 0];\n  let rowOffsetTop = 0;\n  let lineStartIndex = 0;\n  let lineEndIndex = 0;\n\n  for (let i = 0; i <= numCharacters; i++) {\n    const char = characters[i];\n    if (char === '\\n' || i === numCharacters) {\n      lineEndIndex = i;\n    }\n\n    if (lineEndIndex > lineStartIndex) {\n      const rows = autoWrappingEnabled\n        ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex)\n        : SINGLE_LINE;\n\n      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {\n        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];\n        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;\n\n        transformRow(characters, rowStart, rowEnd, iconMapping, x, rowSize);\n        for (let j = rowStart; j < rowEnd; j++) {\n          const char = characters[j];\n          const layoutOffsetY = iconMapping[char]?.layoutOffsetY || 0;\n          y[j] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;\n          rowWidth[j] = rowSize[0];\n        }\n\n        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;\n        size[0] = Math.max(size[0], rowSize[0]);\n      }\n      lineStartIndex = lineEndIndex;\n    }\n\n    if (char === '\\n') {\n      // Make sure result.length matches paragraph.length\n      x[lineStartIndex] = 0;\n      y[lineStartIndex] = 0;\n      rowWidth[lineStartIndex] = 0;\n      lineStartIndex++;\n    }\n  }\n\n  // last row\n  size[1] = rowOffsetTop;\n  return {x, y, rowWidth, size};\n}\n\nexport function getTextFromBuffer({\n  value,\n  length,\n  stride,\n  offset,\n  startIndices,\n  characterSet\n}: {\n  value: Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array;\n  length: number;\n  stride?: number;\n  offset?: number;\n  startIndices: NumericArray;\n  characterSet?: Set<string>;\n}): {\n  texts: string[];\n  characterCount: number;\n} {\n  const bytesPerElement = value.BYTES_PER_ELEMENT;\n  const elementStride = stride ? stride / bytesPerElement : 1;\n  const elementOffset = offset ? offset / bytesPerElement : 0;\n  const characterCount =\n    startIndices[length] || Math.ceil((value.length - elementOffset) / elementStride);\n  const autoCharacterSet = characterSet && new Set<number>();\n\n  const texts = new Array(length);\n\n  let codes = value;\n  if (elementStride > 1 || elementOffset > 0) {\n    const ArrayType = value.constructor as\n      | Uint8ArrayConstructor\n      | Uint8ClampedArrayConstructor\n      | Uint16ArrayConstructor\n      | Uint32ArrayConstructor;\n    codes = new ArrayType(characterCount);\n    for (let i = 0; i < characterCount; i++) {\n      codes[i] = value[i * elementStride + elementOffset];\n    }\n  }\n\n  for (let index = 0; index < length; index++) {\n    const startIndex = startIndices[index];\n    const endIndex = startIndices[index + 1] || characterCount;\n    const codesAtIndex = codes.subarray(startIndex, endIndex);\n    // @ts-ignore TS wants the argument to be number[] but typed array works too\n    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);\n    if (autoCharacterSet) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);\n    }\n  }\n\n  if (autoCharacterSet) {\n    for (const charCode of autoCharacterSet) {\n      characterSet.add(String.fromCodePoint(charCode));\n    }\n  }\n\n  return {texts, characterCount};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}