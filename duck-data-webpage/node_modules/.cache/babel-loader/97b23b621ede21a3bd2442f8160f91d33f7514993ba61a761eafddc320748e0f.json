{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport { Ellipsoid } from '@math.gl/geospatial';\nconst cameraPositionCartesian = new Vector3();\nconst toEye = new Vector3();\nconst cameraPositionEnu = new Vector3();\nconst extraVertexEnu = new Vector3();\nconst projectedOriginVector = new Vector3();\nconst enuToCartesianMatrix = new Matrix4();\nconst cartesianToEnuMatrix = new Matrix4();\n/**\n * For the maxScreenThreshold error metric, maxError means that you should replace the node with it's children\n   as soon as the nodes bounding sphere has a screen radius larger than maxError pixels.\n   In this sense a value of 0 means you should always load it's children,\n   or if it's a leaf node, you should always display it.\n * @param tile\n * @param frameState\n * @returns\n */\nexport function getLodStatus(tile, frameState) {\n  if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {\n    return 'DIG';\n  }\n  const screenSize = 2 * getProjectedRadius(tile, frameState);\n  if (screenSize < 2) {\n    return 'OUT';\n  }\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n  return 'OUT';\n}\n/**\n * Calculate size of MBS radius projected on the screen plane\n * @param tile\n * @param frameState\n * @returns\n */\n// eslint-disable-next-line max-statements\nexport function getProjectedRadius(tile, frameState) {\n  const {\n    topDownViewport: viewport\n  } = frameState;\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n  const mbsCenterCartesian = [...tile.boundingVolume.center];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, cameraPositionCartesian);\n  // ---------------------------\n  // Calculate mbs border vertex\n  // ---------------------------\n  toEye.copy(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();\n  // Add extra vector to form plane\n  Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);\n  cartesianToEnuMatrix.copy(enuToCartesianMatrix).invert();\n  cameraPositionEnu.copy(cameraPositionCartesian).transform(cartesianToEnuMatrix);\n  // Mean Proportionals in Right Triangles - Altitude rule\n  // https://mathbitsnotebook.com/Geometry/RightTriangles/RTmeanRight.html\n  const projection = Math.sqrt(cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]);\n  const extraZ = projection * projection / cameraPositionEnu[2];\n  extraVertexEnu.copy([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);\n  const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);\n  const extraVectorCartesian = extraVertexCartesian.subtract(mbsCenterCartesian).normalize();\n  // We need radius vector orthogonal to toEye vector\n  const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);\n  const sphereMbsBorderVertexCartesian = radiusVector.add(mbsCenterCartesian);\n  const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(sphereMbsBorderVertexCartesian);\n  // ---------------------------\n  // Project center vertex and border vertex and calculate projected radius of MBS\n  const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);\n  const projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);\n  const projectedRadius = projectedOriginVector.copy(projectedOrigin).subtract(projectedMbsBorderVertex).magnitude();\n  return projectedRadius;\n}","map":{"version":3,"names":["Matrix4","Vector3","Ellipsoid","cameraPositionCartesian","toEye","cameraPositionEnu","extraVertexEnu","projectedOriginVector","enuToCartesianMatrix","cartesianToEnuMatrix","getLodStatus","tile","frameState","lodMetricValue","isNaN","screenSize","getProjectedRadius","header","children","topDownViewport","viewport","mbsLat","mbs","mbsLon","mbsZ","mbsR","mbsCenterCartesian","boundingVolume","center","cameraPositionCartographic","unprojectPosition","cameraPosition","WGS84","cartographicToCartesian","copy","subtract","normalize","eastNorthUpToFixedFrame","invert","transform","projection","Math","sqrt","extraZ","extraVertexCartesian","extraVectorCartesian","radiusVector","cross","scale","sphereMbsBorderVertexCartesian","add","sphereMbsBorderVertexCartographic","cartesianToCartographic","projectedOrigin","project","projectedMbsBorderVertex","projectedRadius","magnitude"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/tiles/dist/tileset/helpers/i3s-lod.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport { Ellipsoid } from '@math.gl/geospatial';\nconst cameraPositionCartesian = new Vector3();\nconst toEye = new Vector3();\nconst cameraPositionEnu = new Vector3();\nconst extraVertexEnu = new Vector3();\nconst projectedOriginVector = new Vector3();\nconst enuToCartesianMatrix = new Matrix4();\nconst cartesianToEnuMatrix = new Matrix4();\n/**\n * For the maxScreenThreshold error metric, maxError means that you should replace the node with it's children\n   as soon as the nodes bounding sphere has a screen radius larger than maxError pixels.\n   In this sense a value of 0 means you should always load it's children,\n   or if it's a leaf node, you should always display it.\n * @param tile\n * @param frameState\n * @returns\n */\nexport function getLodStatus(tile, frameState) {\n    if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {\n        return 'DIG';\n    }\n    const screenSize = 2 * getProjectedRadius(tile, frameState);\n    if (screenSize < 2) {\n        return 'OUT';\n    }\n    if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n        return 'DRAW';\n    }\n    else if (tile.header.children) {\n        return 'DIG';\n    }\n    return 'OUT';\n}\n/**\n * Calculate size of MBS radius projected on the screen plane\n * @param tile\n * @param frameState\n * @returns\n */\n// eslint-disable-next-line max-statements\nexport function getProjectedRadius(tile, frameState) {\n    const { topDownViewport: viewport } = frameState;\n    const mbsLat = tile.header.mbs[1];\n    const mbsLon = tile.header.mbs[0];\n    const mbsZ = tile.header.mbs[2];\n    const mbsR = tile.header.mbs[3];\n    const mbsCenterCartesian = [...tile.boundingVolume.center];\n    const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n    Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, cameraPositionCartesian);\n    // ---------------------------\n    // Calculate mbs border vertex\n    // ---------------------------\n    toEye.copy(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();\n    // Add extra vector to form plane\n    Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);\n    cartesianToEnuMatrix.copy(enuToCartesianMatrix).invert();\n    cameraPositionEnu.copy(cameraPositionCartesian).transform(cartesianToEnuMatrix);\n    // Mean Proportionals in Right Triangles - Altitude rule\n    // https://mathbitsnotebook.com/Geometry/RightTriangles/RTmeanRight.html\n    const projection = Math.sqrt(cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]);\n    const extraZ = (projection * projection) / cameraPositionEnu[2];\n    extraVertexEnu.copy([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);\n    const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);\n    const extraVectorCartesian = extraVertexCartesian.subtract(mbsCenterCartesian).normalize();\n    // We need radius vector orthogonal to toEye vector\n    const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);\n    const sphereMbsBorderVertexCartesian = radiusVector.add(mbsCenterCartesian);\n    const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(sphereMbsBorderVertexCartesian);\n    // ---------------------------\n    // Project center vertex and border vertex and calculate projected radius of MBS\n    const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);\n    const projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);\n    const projectedRadius = projectedOriginVector\n        .copy(projectedOrigin)\n        .subtract(projectedMbsBorderVertex)\n        .magnitude();\n    return projectedRadius;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}