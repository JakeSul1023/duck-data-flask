{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isMobile, isBrowser } from \"../env-utils/globals.js\";\nimport WorkerThread from \"./worker-thread.js\";\nimport WorkerJob from \"./worker-job.js\";\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  name = 'unnamed';\n  source; // | Function;\n  url;\n  maxConcurrency = 1;\n  maxMobileConcurrency = 1;\n  onDebug = () => {};\n  reuseWorkers = true;\n  props = {};\n  jobQueue = [];\n  idleQueue = [];\n  count = 0;\n  isDestroyed = false;\n  /** Checks if workers are supported on this platform */\n  static isSupported() {\n    return WorkerThread.isSupported();\n  }\n  /**\n   * @param processor - worker function\n   * @param maxConcurrency - max count of workers\n   */\n  constructor(props) {\n    this.source = props.source;\n    this.url = props.url;\n    this.setProps(props);\n  }\n  /**\n   * Terminates all workers in the pool\n   * @note Can free up significant memory\n   */\n  destroy() {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach(worker => worker.destroy());\n    this.isDestroyed = true;\n  }\n  setProps(props) {\n    this.props = {\n      ...this.props,\n      ...props\n    };\n    if (props.name !== undefined) {\n      this.name = props.name;\n    }\n    if (props.maxConcurrency !== undefined) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n    if (props.maxMobileConcurrency !== undefined) {\n      this.maxMobileConcurrency = props.maxMobileConcurrency;\n    }\n    if (props.reuseWorkers !== undefined) {\n      this.reuseWorkers = props.reuseWorkers;\n    }\n    if (props.onDebug !== undefined) {\n      this.onDebug = props.onDebug;\n    }\n  }\n  async startJob(name, onMessage = (job, type, data) => job.done(data), onError = (job, error) => job.error(error)) {\n    // Promise resolves when thread starts working on this job\n    const startPromise = new Promise(onStart => {\n      // Promise resolves when thread completes or fails working on this job\n      this.jobQueue.push({\n        name,\n        onMessage,\n        onError,\n        onStart\n      });\n      return this;\n    });\n    this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    return await startPromise;\n  }\n  // PRIVATE\n  /**\n   * Starts first queued job if worker is available or can be created\n   * Called when job is started and whenever a worker returns to the idleQueue\n   */\n  async _startQueuedJob() {\n    if (!this.jobQueue.length) {\n      return;\n    }\n    const workerThread = this._getAvailableWorker();\n    if (!workerThread) {\n      return;\n    }\n    // We have a worker, dequeue and start the job\n    const queuedJob = this.jobQueue.shift();\n    if (queuedJob) {\n      // Emit a debug event\n      // @ts-ignore\n      this.onDebug({\n        message: 'Starting job',\n        name: queuedJob.name,\n        workerThread,\n        backlog: this.jobQueue.length\n      });\n      // Create a worker job to let the app access thread and manage job completion\n      const job = new WorkerJob(queuedJob.name, workerThread);\n      // Set the worker thread's message handlers\n      workerThread.onMessage = data => queuedJob.onMessage(job, data.type, data.payload);\n      workerThread.onError = error => queuedJob.onError(job, error);\n      // Resolve the start promise so that the app can start sending messages to worker\n      queuedJob.onStart(job);\n      // Wait for the app to signal that the job is complete, then return worker to queue\n      try {\n        await job.result;\n      } catch (error) {\n        // eslint-disable-next-line no-console\n        console.error(`Worker exception: ${error}`);\n      } finally {\n        this.returnWorkerToQueue(workerThread);\n      }\n    }\n  }\n  /**\n   * Returns a worker to the idle queue\n   * Destroys the worker if\n   *  - pool is destroyed\n   *  - if this pool doesn't reuse workers\n   *  - if maxConcurrency has been lowered\n   * @param worker\n   */\n  returnWorkerToQueue(worker) {\n    const shouldDestroyWorker =\n    // Workers on Node.js prevent the process from exiting.\n    // Until we figure out how to close them before exit, we always destroy them\n    !isBrowser ||\n    // If the pool is destroyed, there is no reason to keep the worker around\n    this.isDestroyed ||\n    // If the app has disabled worker reuse, any completed workers should be destroyed\n    !this.reuseWorkers ||\n    // If concurrency has been lowered, this worker might be surplus to requirements\n    this.count > this._getMaxConcurrency();\n    if (shouldDestroyWorker) {\n      worker.destroy();\n      this.count--;\n    } else {\n      this.idleQueue.push(worker);\n    }\n    if (!this.isDestroyed) {\n      this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    }\n  }\n  /**\n   * Returns idle worker or creates new worker if maxConcurrency has not been reached\n   */\n  _getAvailableWorker() {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift() || null;\n    }\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new WorkerThread({\n        name,\n        source: this.source,\n        url: this.url\n      });\n    }\n    // No worker available, have to wait\n    return null;\n  }\n  _getMaxConcurrency() {\n    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n}","map":{"version":3,"names":["isMobile","isBrowser","WorkerThread","WorkerJob","WorkerPool","name","source","url","maxConcurrency","maxMobileConcurrency","onDebug","reuseWorkers","props","jobQueue","idleQueue","count","isDestroyed","isSupported","constructor","setProps","destroy","forEach","worker","undefined","startJob","onMessage","job","type","data","done","onError","error","startPromise","Promise","onStart","push","_startQueuedJob","length","workerThread","_getAvailableWorker","queuedJob","shift","message","backlog","payload","result","console","returnWorkerToQueue","shouldDestroyWorker","_getMaxConcurrency","toLowerCase"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isMobile, isBrowser } from \"../env-utils/globals.js\";\nimport WorkerThread from \"./worker-thread.js\";\nimport WorkerJob from \"./worker-job.js\";\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n    name = 'unnamed';\n    source; // | Function;\n    url;\n    maxConcurrency = 1;\n    maxMobileConcurrency = 1;\n    onDebug = () => { };\n    reuseWorkers = true;\n    props = {};\n    jobQueue = [];\n    idleQueue = [];\n    count = 0;\n    isDestroyed = false;\n    /** Checks if workers are supported on this platform */\n    static isSupported() {\n        return WorkerThread.isSupported();\n    }\n    /**\n     * @param processor - worker function\n     * @param maxConcurrency - max count of workers\n     */\n    constructor(props) {\n        this.source = props.source;\n        this.url = props.url;\n        this.setProps(props);\n    }\n    /**\n     * Terminates all workers in the pool\n     * @note Can free up significant memory\n     */\n    destroy() {\n        // Destroy idle workers, active Workers will be destroyed on completion\n        this.idleQueue.forEach((worker) => worker.destroy());\n        this.isDestroyed = true;\n    }\n    setProps(props) {\n        this.props = { ...this.props, ...props };\n        if (props.name !== undefined) {\n            this.name = props.name;\n        }\n        if (props.maxConcurrency !== undefined) {\n            this.maxConcurrency = props.maxConcurrency;\n        }\n        if (props.maxMobileConcurrency !== undefined) {\n            this.maxMobileConcurrency = props.maxMobileConcurrency;\n        }\n        if (props.reuseWorkers !== undefined) {\n            this.reuseWorkers = props.reuseWorkers;\n        }\n        if (props.onDebug !== undefined) {\n            this.onDebug = props.onDebug;\n        }\n    }\n    async startJob(name, onMessage = (job, type, data) => job.done(data), onError = (job, error) => job.error(error)) {\n        // Promise resolves when thread starts working on this job\n        const startPromise = new Promise((onStart) => {\n            // Promise resolves when thread completes or fails working on this job\n            this.jobQueue.push({ name, onMessage, onError, onStart });\n            return this;\n        });\n        this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n        return await startPromise;\n    }\n    // PRIVATE\n    /**\n     * Starts first queued job if worker is available or can be created\n     * Called when job is started and whenever a worker returns to the idleQueue\n     */\n    async _startQueuedJob() {\n        if (!this.jobQueue.length) {\n            return;\n        }\n        const workerThread = this._getAvailableWorker();\n        if (!workerThread) {\n            return;\n        }\n        // We have a worker, dequeue and start the job\n        const queuedJob = this.jobQueue.shift();\n        if (queuedJob) {\n            // Emit a debug event\n            // @ts-ignore\n            this.onDebug({\n                message: 'Starting job',\n                name: queuedJob.name,\n                workerThread,\n                backlog: this.jobQueue.length\n            });\n            // Create a worker job to let the app access thread and manage job completion\n            const job = new WorkerJob(queuedJob.name, workerThread);\n            // Set the worker thread's message handlers\n            workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);\n            workerThread.onError = (error) => queuedJob.onError(job, error);\n            // Resolve the start promise so that the app can start sending messages to worker\n            queuedJob.onStart(job);\n            // Wait for the app to signal that the job is complete, then return worker to queue\n            try {\n                await job.result;\n            }\n            catch (error) {\n                // eslint-disable-next-line no-console\n                console.error(`Worker exception: ${error}`);\n            }\n            finally {\n                this.returnWorkerToQueue(workerThread);\n            }\n        }\n    }\n    /**\n     * Returns a worker to the idle queue\n     * Destroys the worker if\n     *  - pool is destroyed\n     *  - if this pool doesn't reuse workers\n     *  - if maxConcurrency has been lowered\n     * @param worker\n     */\n    returnWorkerToQueue(worker) {\n        const shouldDestroyWorker = \n        // Workers on Node.js prevent the process from exiting.\n        // Until we figure out how to close them before exit, we always destroy them\n        !isBrowser ||\n            // If the pool is destroyed, there is no reason to keep the worker around\n            this.isDestroyed ||\n            // If the app has disabled worker reuse, any completed workers should be destroyed\n            !this.reuseWorkers ||\n            // If concurrency has been lowered, this worker might be surplus to requirements\n            this.count > this._getMaxConcurrency();\n        if (shouldDestroyWorker) {\n            worker.destroy();\n            this.count--;\n        }\n        else {\n            this.idleQueue.push(worker);\n        }\n        if (!this.isDestroyed) {\n            this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n        }\n    }\n    /**\n     * Returns idle worker or creates new worker if maxConcurrency has not been reached\n     */\n    _getAvailableWorker() {\n        // If a worker has completed and returned to the queue, it can be used\n        if (this.idleQueue.length > 0) {\n            return this.idleQueue.shift() || null;\n        }\n        // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n        if (this.count < this._getMaxConcurrency()) {\n            this.count++;\n            const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n            return new WorkerThread({ name, source: this.source, url: this.url });\n        }\n        // No worker available, have to wait\n        return null;\n    }\n    _getMaxConcurrency() {\n        return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}