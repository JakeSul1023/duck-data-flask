{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Shader, log } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\nimport { parseShaderCompilerLog } from \"../helpers/parse-shader-compiler-log.js\";\n/**\n * An immutable compiled shader program that execute portions of the GPU Pipeline\n */\nexport class WEBGLShader extends Shader {\n  device;\n  handle;\n  constructor(device, props) {\n    super(device, props);\n    this.device = device;\n    switch (this.props.stage) {\n      case 'vertex':\n        this.handle = this.props.handle || this.device.gl.createShader(35633);\n        break;\n      case 'fragment':\n        this.handle = this.props.handle || this.device.gl.createShader(35632);\n        break;\n      default:\n        throw new Error(this.props.stage);\n    }\n    this._compile(this.source);\n  }\n  destroy() {\n    if (this.handle) {\n      this.removeStats();\n      this.device.gl.deleteShader(this.handle);\n      // this.handle = null;\n      this.destroyed = true;\n    }\n  }\n  get asyncCompilationStatus() {\n    return this._waitForCompilationComplete().then(() => this.compilationStatus);\n  }\n  async getCompilationInfo() {\n    await this._waitForCompilationComplete();\n    return this.getCompilationInfoSync();\n  }\n  getCompilationInfoSync() {\n    const shaderLog = this.device.gl.getShaderInfoLog(this.handle);\n    return shaderLog ? parseShaderCompilerLog(shaderLog) : [];\n  }\n  getTranslatedSource() {\n    const extensions = this.device.getExtension('WEBGL_debug_shaders');\n    const ext = extensions.WEBGL_debug_shaders;\n    return ext?.getTranslatedShaderSource(this.handle) || null;\n  }\n  // PRIVATE METHODS\n  /** Compile a shader and get compilation status */\n  async _compile(source) {\n    source = source.startsWith('#version ') ? source : `#version 300 es\\n${source}`;\n    const {\n      gl\n    } = this.device;\n    gl.shaderSource(this.handle, source);\n    gl.compileShader(this.handle);\n    // For performance reasons, avoid checking shader compilation errors on production\n    if (!this.device.props.debug) {\n      this.compilationStatus = 'pending';\n      return;\n    }\n    // Sync case - slower, but advantage is that it throws in the constructor, making break on error more useful\n    if (!this.device.features.has('compilation-status-async-webgl')) {\n      this._getCompilationStatus();\n      // The `Shader` base class will determine if debug window should be opened based on this.compilationStatus\n      this.debugShader();\n      if (this.compilationStatus === 'error') {\n        throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);\n      }\n      return;\n    }\n    // async case\n    log.once(1, 'Shader compilation is asynchronous')();\n    await this._waitForCompilationComplete();\n    log.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)();\n    this._getCompilationStatus();\n    // The `Shader` base class will determine if debug window should be opened based on this.compilationStatus\n    this.debugShader();\n  }\n  /** Use KHR_parallel_shader_compile extension if available */\n  async _waitForCompilationComplete() {\n    const waitMs = async ms => await new Promise(resolve => setTimeout(resolve, ms));\n    const DELAY_MS = 10; // Shader compilation is typically quite fast (with some exceptions)\n    // If status polling is not available, we can't wait for completion. Just wait a little to minimize blocking\n    if (!this.device.features.has('compilation-status-async-webgl')) {\n      await waitMs(DELAY_MS);\n      return;\n    }\n    const {\n      gl\n    } = this.device;\n    for (;;) {\n      const complete = gl.getShaderParameter(this.handle, 37297);\n      if (complete) {\n        return;\n      }\n      await waitMs(DELAY_MS);\n    }\n  }\n  /**\n   * Get the shader compilation status\n   * TODO - Load log even when no error reported, to catch warnings?\n   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings\n   */\n  _getCompilationStatus() {\n    this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? 'success' : 'error';\n  }\n}\n// TODO - Original code from luma.gl v8 - keep until new debug functionality has matured\n// if (!compilationSuccess) {\n//   const parsedLog = shaderLog ? parseShaderCompilerLog(shaderLog) : [];\n//   const messages = parsedLog.filter(message => message.type === 'error');\n//   const formattedLog = formatCompilerLog(messages, source, {showSourceCode: 'all', html: true});\n//   const shaderDescription = `${this.stage} shader ${shaderName}`;\n//   log.error(`GLSL compilation errors in ${shaderDescription}\\n${formattedLog}`)();\n//   displayShaderLog(parsedLog, source, shaderName);\n// }","map":{"version":3,"names":["Shader","log","GL","parseShaderCompilerLog","WEBGLShader","device","handle","constructor","props","stage","gl","createShader","Error","_compile","source","destroy","removeStats","deleteShader","destroyed","asyncCompilationStatus","_waitForCompilationComplete","then","compilationStatus","getCompilationInfo","getCompilationInfoSync","shaderLog","getShaderInfoLog","getTranslatedSource","extensions","getExtension","ext","WEBGL_debug_shaders","getTranslatedShaderSource","startsWith","shaderSource","compileShader","debug","features","has","_getCompilationStatus","debugShader","id","once","info","waitMs","ms","Promise","resolve","setTimeout","DELAY_MS","complete","getShaderParameter"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\webgl\\src\\adapter\\resources\\webgl-shader.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Shader, ShaderProps, CompilerMessage, log} from '@luma.gl/core';\nimport {GL} from '@luma.gl/constants';\nimport {parseShaderCompilerLog} from '../helpers/parse-shader-compiler-log';\nimport {WebGLDevice} from '../webgl-device';\n\n/**\n * An immutable compiled shader program that execute portions of the GPU Pipeline\n */\nexport class WEBGLShader extends Shader {\n  readonly device: WebGLDevice;\n  readonly handle: WebGLShader;\n\n  constructor(device: WebGLDevice, props: ShaderProps) {\n    super(device, props);\n    this.device = device;\n    switch (this.props.stage) {\n      case 'vertex':\n        this.handle = this.props.handle || this.device.gl.createShader(GL.VERTEX_SHADER);\n        break;\n      case 'fragment':\n        this.handle = this.props.handle || this.device.gl.createShader(GL.FRAGMENT_SHADER);\n        break;\n      default:\n        throw new Error(this.props.stage);\n    }\n    this._compile(this.source);\n  }\n\n  override destroy(): void {\n    if (this.handle) {\n      this.removeStats();\n      this.device.gl.deleteShader(this.handle);\n      // this.handle = null;\n      this.destroyed = true;\n    }\n  }\n\n  get asyncCompilationStatus(): Promise<'pending' | 'success' | 'error'> {\n    return this._waitForCompilationComplete().then(() => this.compilationStatus);\n  }\n\n  override async getCompilationInfo(): Promise<readonly CompilerMessage[]> {\n    await this._waitForCompilationComplete();\n    return this.getCompilationInfoSync();\n  }\n\n  override getCompilationInfoSync(): readonly CompilerMessage[] {\n    const shaderLog = this.device.gl.getShaderInfoLog(this.handle);\n    return shaderLog ? parseShaderCompilerLog(shaderLog) : [];\n  }\n\n  override getTranslatedSource(): string | null {\n    const extensions = this.device.getExtension('WEBGL_debug_shaders');\n    const ext = extensions.WEBGL_debug_shaders;\n    return ext?.getTranslatedShaderSource(this.handle) || null;\n  }\n\n  // PRIVATE METHODS\n\n  /** Compile a shader and get compilation status */\n  protected async _compile(source: string): Promise<void> {\n    source = source.startsWith('#version ') ? source : `#version 300 es\\n${source}`;\n\n    const {gl} = this.device;\n    gl.shaderSource(this.handle, source);\n    gl.compileShader(this.handle);\n\n    // For performance reasons, avoid checking shader compilation errors on production\n    if (!this.device.props.debug) {\n      this.compilationStatus = 'pending';\n      return;\n    }\n\n    // Sync case - slower, but advantage is that it throws in the constructor, making break on error more useful\n    if (!this.device.features.has('compilation-status-async-webgl')) {\n      this._getCompilationStatus();\n      // The `Shader` base class will determine if debug window should be opened based on this.compilationStatus\n      this.debugShader();\n      if (this.compilationStatus === 'error') {\n        throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);\n      }\n      return;\n    }\n\n    // async case\n    log.once(1, 'Shader compilation is asynchronous')();\n    await this._waitForCompilationComplete();\n    log.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)();\n    this._getCompilationStatus();\n\n    // The `Shader` base class will determine if debug window should be opened based on this.compilationStatus\n    this.debugShader();\n  }\n\n  /** Use KHR_parallel_shader_compile extension if available */\n  protected async _waitForCompilationComplete(): Promise<void> {\n    const waitMs = async (ms: number) => await new Promise(resolve => setTimeout(resolve, ms));\n    const DELAY_MS = 10; // Shader compilation is typically quite fast (with some exceptions)\n\n    // If status polling is not available, we can't wait for completion. Just wait a little to minimize blocking\n    if (!this.device.features.has('compilation-status-async-webgl')) {\n      await waitMs(DELAY_MS);\n      return;\n    }\n\n    const {gl} = this.device;\n    for (;;) {\n      const complete = gl.getShaderParameter(this.handle, GL.COMPLETION_STATUS_KHR);\n      if (complete) {\n        return;\n      }\n      await waitMs(DELAY_MS);\n    }\n  }\n\n  /**\n   * Get the shader compilation status\n   * TODO - Load log even when no error reported, to catch warnings?\n   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings\n   */\n  protected _getCompilationStatus() {\n    this.compilationStatus = this.device.gl.getShaderParameter(this.handle, GL.COMPILE_STATUS)\n      ? 'success'\n      : 'error';\n  }\n}\n\n// TODO - Original code from luma.gl v8 - keep until new debug functionality has matured\n// if (!compilationSuccess) {\n//   const parsedLog = shaderLog ? parseShaderCompilerLog(shaderLog) : [];\n//   const messages = parsedLog.filter(message => message.type === 'error');\n//   const formattedLog = formatCompilerLog(messages, source, {showSourceCode: 'all', html: true});\n//   const shaderDescription = `${this.stage} shader ${shaderName}`;\n//   log.error(`GLSL compilation errors in ${shaderDescription}\\n${formattedLog}`)();\n//   displayShaderLog(parsedLog, source, shaderName);\n// }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}