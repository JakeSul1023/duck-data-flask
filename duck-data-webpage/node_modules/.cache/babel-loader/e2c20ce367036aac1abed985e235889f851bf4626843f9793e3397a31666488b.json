{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/*\n * Helper function for padArray\n */\nfunction padArrayChunk(options) {\n  const {\n    source,\n    target,\n    start = 0,\n    size,\n    getData\n  } = options;\n  const end = options.end || target.length;\n  const sourceLength = source.length;\n  const targetLength = end - start;\n  if (sourceLength > targetLength) {\n    target.set(source.subarray(0, targetLength), start);\n    return;\n  }\n  target.set(source, start);\n  if (!getData) {\n    return;\n  }\n  // source is not large enough to fill target space, call `getData` to get filler data\n  let i = sourceLength;\n  while (i < targetLength) {\n    const datum = getData(i, source);\n    for (let j = 0; j < size; j++) {\n      target[start + i] = datum[j] || 0;\n      i++;\n    }\n  }\n}\n/*\n * The padArray function stretches a source array to the size of a target array.\n   The arrays can have internal structures (like the attributes of PathLayer and\n   SolidPolygonLayer), defined by the optional sourceStartIndices and targetStartIndices parameters.\n   If the target array is larger, the getData callback is used to fill in the blanks.\n */\nexport function padArray({\n  source,\n  target,\n  size,\n  getData,\n  sourceStartIndices,\n  targetStartIndices\n}) {\n  if (!sourceStartIndices || !targetStartIndices) {\n    // Flat arrays\n    padArrayChunk({\n      source,\n      target,\n      size,\n      getData\n    });\n    return target;\n  }\n  // Arrays have internal structure\n  let sourceIndex = 0;\n  let targetIndex = 0;\n  const getChunkData = getData && ((i, chunk) => getData(i + targetIndex, chunk));\n  const n = Math.min(sourceStartIndices.length, targetStartIndices.length);\n  for (let i = 1; i < n; i++) {\n    const nextSourceIndex = sourceStartIndices[i] * size;\n    const nextTargetIndex = targetStartIndices[i] * size;\n    padArrayChunk({\n      source: source.subarray(sourceIndex, nextSourceIndex),\n      target,\n      start: targetIndex,\n      end: nextTargetIndex,\n      size,\n      getData: getChunkData\n    });\n    sourceIndex = nextSourceIndex;\n    targetIndex = nextTargetIndex;\n  }\n  if (targetIndex < target.length) {\n    padArrayChunk({\n      // @ts-ignore\n      source: [],\n      target,\n      start: targetIndex,\n      size,\n      getData: getChunkData\n    });\n  }\n  return target;\n}","map":{"version":3,"names":["padArrayChunk","options","source","target","start","size","getData","end","length","sourceLength","targetLength","set","subarray","i","datum","j","padArray","sourceStartIndices","targetStartIndices","sourceIndex","targetIndex","getChunkData","chunk","n","Math","min","nextSourceIndex","nextTargetIndex"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\utils\\array-utils.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {NumericArray, TypedArray} from '../types/types';\n\n/*\n * Helper function for padArray\n */\nfunction padArrayChunk(options: {\n  /** original data */\n  source: TypedArray;\n  /** output data */\n  target: TypedArray;\n  /** length per datum */\n  size: number;\n  /** callback to get new data when source is short */\n  getData: (index: number, context: NumericArray) => NumericArray;\n  /** start index */\n  start?: number;\n  /** end index */\n  end?: number;\n}): void {\n  const {source, target, start = 0, size, getData} = options;\n  const end = options.end || target.length;\n\n  const sourceLength = source.length;\n  const targetLength = end - start;\n\n  if (sourceLength > targetLength) {\n    target.set(source.subarray(0, targetLength), start);\n    return;\n  }\n\n  target.set(source, start);\n\n  if (!getData) {\n    return;\n  }\n\n  // source is not large enough to fill target space, call `getData` to get filler data\n  let i = sourceLength;\n  while (i < targetLength) {\n    const datum = getData(i, source);\n    for (let j = 0; j < size; j++) {\n      target[start + i] = datum[j] || 0;\n      i++;\n    }\n  }\n}\n\n/*\n * The padArray function stretches a source array to the size of a target array.\n   The arrays can have internal structures (like the attributes of PathLayer and\n   SolidPolygonLayer), defined by the optional sourceStartIndices and targetStartIndices parameters.\n   If the target array is larger, the getData callback is used to fill in the blanks.\n */\nexport function padArray({\n  source,\n  target,\n  size,\n  getData,\n  sourceStartIndices,\n  targetStartIndices\n}: {\n  /** original data */\n  source: TypedArray;\n  /** output data */\n  target: TypedArray;\n  /** length per datum */\n  size: number;\n  /** callback to get new data when source is short */\n  getData: (index: number, context: NumericArray) => NumericArray;\n  /** subdivision of the original data in [object0StartIndex, object1StartIndex, ...] */\n  sourceStartIndices?: NumericArray | null;\n  /** subdivision of the output data in [object0StartIndex, object1StartIndex, ...] */\n  targetStartIndices?: NumericArray | null;\n}): TypedArray {\n  if (!sourceStartIndices || !targetStartIndices) {\n    // Flat arrays\n    padArrayChunk({\n      source,\n      target,\n      size,\n      getData\n    });\n    return target;\n  }\n\n  // Arrays have internal structure\n  let sourceIndex = 0;\n  let targetIndex = 0;\n  const getChunkData = getData && ((i, chunk) => getData(i + targetIndex, chunk));\n\n  const n = Math.min(sourceStartIndices.length, targetStartIndices.length);\n\n  for (let i = 1; i < n; i++) {\n    const nextSourceIndex = sourceStartIndices[i] * size;\n    const nextTargetIndex = targetStartIndices[i] * size;\n\n    padArrayChunk({\n      source: source.subarray(sourceIndex, nextSourceIndex),\n      target,\n      start: targetIndex,\n      end: nextTargetIndex,\n      size,\n      getData: getChunkData\n    });\n\n    sourceIndex = nextSourceIndex;\n    targetIndex = nextTargetIndex;\n  }\n\n  if (targetIndex < target.length) {\n    padArrayChunk({\n      // @ts-ignore\n      source: [],\n      target,\n      start: targetIndex,\n      size,\n      getData: getChunkData\n    });\n  }\n\n  return target;\n}\n"],"mappings":"AAAA;AACA;AACA;AAIA;;;AAGA,SAASA,aAAaA,CAACC,OAatB;EACC,MAAM;IAACC,MAAM;IAAEC,MAAM;IAAEC,KAAK,GAAG,CAAC;IAAEC,IAAI;IAAEC;EAAO,CAAC,GAAGL,OAAO;EAC1D,MAAMM,GAAG,GAAGN,OAAO,CAACM,GAAG,IAAIJ,MAAM,CAACK,MAAM;EAExC,MAAMC,YAAY,GAAGP,MAAM,CAACM,MAAM;EAClC,MAAME,YAAY,GAAGH,GAAG,GAAGH,KAAK;EAEhC,IAAIK,YAAY,GAAGC,YAAY,EAAE;IAC/BP,MAAM,CAACQ,GAAG,CAACT,MAAM,CAACU,QAAQ,CAAC,CAAC,EAAEF,YAAY,CAAC,EAAEN,KAAK,CAAC;IACnD;EACF;EAEAD,MAAM,CAACQ,GAAG,CAACT,MAAM,EAAEE,KAAK,CAAC;EAEzB,IAAI,CAACE,OAAO,EAAE;IACZ;EACF;EAEA;EACA,IAAIO,CAAC,GAAGJ,YAAY;EACpB,OAAOI,CAAC,GAAGH,YAAY,EAAE;IACvB,MAAMI,KAAK,GAAGR,OAAO,CAACO,CAAC,EAAEX,MAAM,CAAC;IAChC,KAAK,IAAIa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,IAAI,EAAEU,CAAC,EAAE,EAAE;MAC7BZ,MAAM,CAACC,KAAK,GAAGS,CAAC,CAAC,GAAGC,KAAK,CAACC,CAAC,CAAC,IAAI,CAAC;MACjCF,CAAC,EAAE;IACL;EACF;AACF;AAEA;;;;;;AAMA,OAAM,SAAUG,QAAQA,CAAC;EACvBd,MAAM;EACNC,MAAM;EACNE,IAAI;EACJC,OAAO;EACPW,kBAAkB;EAClBC;AAAkB,CAcnB;EACC,IAAI,CAACD,kBAAkB,IAAI,CAACC,kBAAkB,EAAE;IAC9C;IACAlB,aAAa,CAAC;MACZE,MAAM;MACNC,MAAM;MACNE,IAAI;MACJC;KACD,CAAC;IACF,OAAOH,MAAM;EACf;EAEA;EACA,IAAIgB,WAAW,GAAG,CAAC;EACnB,IAAIC,WAAW,GAAG,CAAC;EACnB,MAAMC,YAAY,GAAGf,OAAO,KAAK,CAACO,CAAC,EAAES,KAAK,KAAKhB,OAAO,CAACO,CAAC,GAAGO,WAAW,EAAEE,KAAK,CAAC,CAAC;EAE/E,MAAMC,CAAC,GAAGC,IAAI,CAACC,GAAG,CAACR,kBAAkB,CAACT,MAAM,EAAEU,kBAAkB,CAACV,MAAM,CAAC;EAExE,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGU,CAAC,EAAEV,CAAC,EAAE,EAAE;IAC1B,MAAMa,eAAe,GAAGT,kBAAkB,CAACJ,CAAC,CAAC,GAAGR,IAAI;IACpD,MAAMsB,eAAe,GAAGT,kBAAkB,CAACL,CAAC,CAAC,GAAGR,IAAI;IAEpDL,aAAa,CAAC;MACZE,MAAM,EAAEA,MAAM,CAACU,QAAQ,CAACO,WAAW,EAAEO,eAAe,CAAC;MACrDvB,MAAM;MACNC,KAAK,EAAEgB,WAAW;MAClBb,GAAG,EAAEoB,eAAe;MACpBtB,IAAI;MACJC,OAAO,EAAEe;KACV,CAAC;IAEFF,WAAW,GAAGO,eAAe;IAC7BN,WAAW,GAAGO,eAAe;EAC/B;EAEA,IAAIP,WAAW,GAAGjB,MAAM,CAACK,MAAM,EAAE;IAC/BR,aAAa,CAAC;MACZ;MACAE,MAAM,EAAE,EAAE;MACVC,MAAM;MACNC,KAAK,EAAEgB,WAAW;MAClBf,IAAI;MACJC,OAAO,EAAEe;KACV,CAAC;EACJ;EAEA,OAAOlB,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}