{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { GL } from '@luma.gl/constants';\n/** Check is uniform is of sampler type */\nexport function isSamplerUniform(type) {\n  return SAMPLER_TYPES.includes(type);\n}\nconst SAMPLER_TYPES = [35678, 35680, 35679, 35682, 36289, 36292, 36293, 36298, 36299, 36300, 36303, 36306, 36307, 36308, 36311];\n// Composite types table\nconst COMPOSITE_GL_TYPES = {\n  [5126]: [5126, 1, 'float', 'f32', 'float32'],\n  [35664]: [5126, 2, 'vec2', 'vec2<f32>', 'float32x2'],\n  [35665]: [5126, 3, 'vec3', 'vec3<f32>', 'float32x3'],\n  [35666]: [5126, 4, 'vec4', 'vec4<f32>', 'float32x4'],\n  [5124]: [5124, 1, 'int', 'i32', 'sint32'],\n  [35667]: [5124, 2, 'ivec2', 'vec2<i32>', 'sint32x2'],\n  [35668]: [5124, 3, 'ivec3', 'vec3<i32>', 'sint32x3'],\n  [35669]: [5124, 4, 'ivec4', 'vec4<i32>', 'sint32x4'],\n  [5125]: [5125, 1, 'uint', 'u32', 'uint32'],\n  [36294]: [5125, 2, 'uvec2', 'vec2<u32>', 'uint32x2'],\n  [36295]: [5125, 3, 'uvec3', 'vec3<u32>', 'uint32x3'],\n  [36296]: [5125, 4, 'uvec4', 'vec4<u32>', 'uint32x4'],\n  [35670]: [5126, 1, 'bool', 'f32', 'float32'],\n  [35671]: [5126, 2, 'bvec2', 'vec2<f32>', 'float32x2'],\n  [35672]: [5126, 3, 'bvec3', 'vec3<f32>', 'float32x3'],\n  [35673]: [5126, 4, 'bvec4', 'vec4<f32>', 'float32x4'],\n  // TODO - are sizes/components below correct?\n  [35674]: [5126, 8, 'mat2', 'mat2x2<f32>'],\n  // 4\n  [35685]: [5126, 8, 'mat2x3', 'mat2x3<f32>'],\n  // 6\n  [35686]: [5126, 8, 'mat2x4', 'mat2x4<f32>'],\n  // 8\n  [35687]: [5126, 12, 'mat3x2', 'mat3x2<f32>'],\n  // 6\n  [35675]: [5126, 12, 'mat3', 'mat3x3<f32>'],\n  // 9\n  [35688]: [5126, 12, 'mat3x4', 'mat3x4<f32>'],\n  // 12\n  [35689]: [5126, 16, 'mat4x2', 'mat4x2<f32>'],\n  // 8\n  [35690]: [5126, 16, 'mat4x3', 'mat4x3<f32>'],\n  // 12\n  [35676]: [5126, 16, 'mat4', 'mat4x4<f32>'] // 16\n};\n/** Decomposes a composite type (GL.VEC3) into a basic type (GL.FLOAT) and components (3) */\nexport function decodeGLUniformType(glUniformType) {\n  const typeAndSize = COMPOSITE_GL_TYPES[glUniformType];\n  if (!typeAndSize) {\n    throw new Error('uniform');\n  }\n  const [glType, components,, format] = typeAndSize;\n  return {\n    format,\n    components,\n    glType\n  };\n}\n/** Decomposes a composite type (GL.VEC3) into a basic type (GL.FLOAT) and components (3) */\nexport function decodeGLAttributeType(glAttributeType) {\n  const typeAndSize = COMPOSITE_GL_TYPES[glAttributeType];\n  if (!typeAndSize) {\n    throw new Error('attribute');\n  }\n  const [, components,, shaderType, vertexFormat] = typeAndSize;\n  // TODO sanity - if (shaderType.startsWith('mat' ...))\n  const attributeType = shaderType;\n  return {\n    attributeType,\n    vertexFormat,\n    components\n  }; // , glType};\n}\n/** Decomposes a composite type GL.VEC3 into a basic type (GL.FLOAT) and components (3) */\nexport function decomposeCompositeGLDataType(compositeGLDataType) {\n  const typeAndSize = COMPOSITE_GL_TYPES[compositeGLDataType];\n  if (!typeAndSize) {\n    return null;\n  }\n  const [type, components] = typeAndSize;\n  return {\n    type,\n    components\n  };\n}\nexport function getCompositeGLDataType(type, components) {\n  switch (type) {\n    case 5120:\n    case 5121:\n    case 5122:\n    case 5123:\n      type = 5126;\n      break;\n    default:\n  }\n  for (const glType in COMPOSITE_GL_TYPES) {\n    const [compType, compComponents, name] = COMPOSITE_GL_TYPES[glType];\n    if (compType === type && compComponents === components) {\n      return {\n        glType: Number(glType),\n        name\n      };\n    }\n  }\n  return null;\n}\n//# sourceMappingURL=decode-webgl-types.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}