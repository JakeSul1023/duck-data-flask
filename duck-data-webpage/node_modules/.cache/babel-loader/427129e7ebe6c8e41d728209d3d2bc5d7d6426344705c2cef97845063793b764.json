{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { createTexture, destroyTexture } from \"../utils/texture.js\";\nimport { deepEqual } from \"../utils/deep-equal.js\";\nconst TYPE_DEFINITIONS = {\n  boolean: {\n    validate(value, propType) {\n      return true;\n    },\n    equal(value1, value2, propType) {\n      return Boolean(value1) === Boolean(value2);\n    }\n  },\n  number: {\n    validate(value, propType) {\n      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);\n    }\n  },\n  color: {\n    validate(value, propType) {\n      return propType.optional && !value || isArray(value) && (value.length === 3 || value.length === 4);\n    },\n    equal(value1, value2, propType) {\n      return deepEqual(value1, value2, 1);\n    }\n  },\n  accessor: {\n    validate(value, propType) {\n      const valueType = getTypeOf(value);\n      return valueType === 'function' || valueType === getTypeOf(propType.value);\n    },\n    equal(value1, value2, propType) {\n      if (typeof value2 === 'function') {\n        return true;\n      }\n      return deepEqual(value1, value2, 1);\n    }\n  },\n  array: {\n    validate(value, propType) {\n      return propType.optional && !value || isArray(value);\n    },\n    equal(value1, value2, propType) {\n      const {\n        compare\n      } = propType;\n      const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;\n      return compare ? deepEqual(value1, value2, depth) : value1 === value2;\n    }\n  },\n  object: {\n    equal(value1, value2, propType) {\n      if (propType.ignore) {\n        return true;\n      }\n      const {\n        compare\n      } = propType;\n      const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;\n      return compare ? deepEqual(value1, value2, depth) : value1 === value2;\n    }\n  },\n  function: {\n    validate(value, propType) {\n      return propType.optional && !value || typeof value === 'function';\n    },\n    equal(value1, value2, propType) {\n      // Backward compatibility - {compare: true} and {ignore: false} are equivalent\n      const shouldIgnore = !propType.compare && propType.ignore !== false;\n      return shouldIgnore || value1 === value2;\n    }\n  },\n  data: {\n    transform: (value, propType, component) => {\n      if (!value) {\n        return value;\n      }\n      const {\n        dataTransform\n      } = component.props;\n      if (dataTransform) {\n        return dataTransform(value);\n      }\n      // Detect loaders.gl v4 table format\n      if (typeof value.shape === 'string' && value.shape.endsWith('-table') && Array.isArray(value.data)) {\n        return value.data;\n      }\n      return value;\n    }\n  },\n  image: {\n    transform: (value, propType, component) => {\n      const context = component.context;\n      if (!context || !context.device) {\n        return null;\n      }\n      return createTexture(component.id, context.device, value, {\n        ...propType.parameters,\n        ...component.props.textureParameters\n      });\n    },\n    release: (value, propType, component) => {\n      destroyTexture(component.id, value);\n    }\n  }\n};\nexport function parsePropTypes(propDefs) {\n  const propTypes = {};\n  const defaultProps = {};\n  const deprecatedProps = {};\n  for (const [propName, propDef] of Object.entries(propDefs)) {\n    const deprecated = propDef?.deprecatedFor;\n    if (deprecated) {\n      deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];\n    } else {\n      const propType = parsePropType(propName, propDef);\n      propTypes[propName] = propType;\n      defaultProps[propName] = propType.value;\n    }\n  }\n  return {\n    propTypes,\n    defaultProps,\n    deprecatedProps\n  };\n}\n// Parses one property definition entry. Either contains:\n// * a valid prop type object ({type, ...})\n// * or just a default value, in which case type and name inference is used\nfunction parsePropType(name, propDef) {\n  switch (getTypeOf(propDef)) {\n    case 'object':\n      return normalizePropDefinition(name, propDef);\n    case 'array':\n      return normalizePropDefinition(name, {\n        type: 'array',\n        value: propDef,\n        compare: false\n      });\n    case 'boolean':\n      return normalizePropDefinition(name, {\n        type: 'boolean',\n        value: propDef\n      });\n    case 'number':\n      return normalizePropDefinition(name, {\n        type: 'number',\n        value: propDef\n      });\n    case 'function':\n      // return guessFunctionType(name, propDef);\n      return normalizePropDefinition(name, {\n        type: 'function',\n        value: propDef,\n        compare: true\n      });\n    default:\n      return {\n        name,\n        type: 'unknown',\n        value: propDef\n      };\n  }\n}\nfunction normalizePropDefinition(name, propDef) {\n  if (!('type' in propDef)) {\n    if (!('value' in propDef)) {\n      // If no type and value this object is likely the value\n      return {\n        name,\n        type: 'object',\n        value: propDef\n      };\n    }\n    return {\n      name,\n      type: getTypeOf(propDef.value),\n      ...propDef\n    };\n  }\n  return {\n    name,\n    ...TYPE_DEFINITIONS[propDef.type],\n    ...propDef\n  };\n}\nfunction isArray(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value);\n}\n// improved version of javascript typeof that can distinguish arrays and null values\nfunction getTypeOf(value) {\n  if (isArray(value)) {\n    return 'array';\n  }\n  if (value === null) {\n    return 'null';\n  }\n  return typeof value;\n}","map":{"version":3,"names":["createTexture","destroyTexture","deepEqual","TYPE_DEFINITIONS","boolean","validate","value","propType","equal","value1","value2","Boolean","number","Number","isFinite","max","min","color","optional","isArray","length","accessor","valueType","getTypeOf","array","compare","depth","isInteger","object","ignore","function","shouldIgnore","data","transform","component","dataTransform","props","shape","endsWith","Array","image","context","device","id","parameters","textureParameters","release","parsePropTypes","propDefs","propTypes","defaultProps","deprecatedProps","propName","propDef","Object","entries","deprecated","deprecatedFor","parsePropType","name","normalizePropDefinition","type","ArrayBuffer","isView"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\lifecycle\\prop-types.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {createTexture, destroyTexture} from '../utils/texture';\nimport {deepEqual} from '../utils/deep-equal';\n\nimport type Component from './component';\nimport type {Color, TextureSource} from '../types/layer-props';\nimport type Layer from '../lib/layer';\nimport type {SamplerProps} from '@luma.gl/core';\n\ntype BasePropType<ValueT> = {\n  value: ValueT;\n  async?: boolean;\n  validate?: (value: any, propType: PropType) => boolean;\n  equal?: (value1: ValueT, value2: ValueT, propType: PropType) => boolean;\n};\n\n/**\n * Normalized prop type definition\n */\nexport type PropType = BasePropType<any> & {\n  type: string;\n  name: string;\n  transform?: (value: any, propType: PropType, component: Component<any>) => any;\n  release?: (value: any, propType: PropType, component: Component<any>) => void;\n};\n\ntype DefaultProp<T> =\n  | T\n  | DeprecatedProp\n  | BooleanPropType\n  | NumberPropType\n  | ColorPropType\n  | ImagePropType\n  | DataPropType<T>\n  | ArrayPropType<T>\n  | ObjectPropType<T>\n  | AccessorPropType<T>\n  | FunctionPropType<T>;\n\nexport type DefaultProps<PropsT extends {} = {}> = {\n  [propName in keyof PropsT]?: DefaultProp<Required<PropsT>[propName]>;\n};\n\ntype BooleanPropType = BasePropType<boolean> & {\n  type: 'boolean';\n};\ntype NumberPropType = BasePropType<number> & {\n  type: 'number';\n  min?: number;\n  max?: number;\n};\ntype ColorPropType = BasePropType<Color | null> & {\n  type: 'color';\n  optional?: boolean;\n};\ntype ArrayPropType<T = any[]> = BasePropType<T> & {\n  type: 'array';\n  optional?: boolean;\n  /** Ignore change in the prop value.\n   * @default false\n   */\n  ignore?: boolean;\n  /** Deep-compare two prop values. Only used if `ignore: false`.\n   * When a number is supplied, used as the depth of deep-comparison. 0 is equivalent to shallow comparison, -1 is infinite depth\n   * When a boolean is supplied, `true` is equivalent to `1` (shallow compare all child fields)\n   * @default false\n   */\n  compare?: boolean | number;\n};\ntype AccessorPropType<T = any> = BasePropType<T> & {\n  type: 'accessor';\n};\ntype FunctionPropType<T = Function> = BasePropType<T> & {\n  type: 'function';\n  optional?: boolean;\n  /** @deprecated use `ignore` instead */\n  compare?: boolean;\n  /** Ignore change in the prop value.\n   * @default true\n   */\n  ignore?: boolean;\n};\ntype DataPropType<T = any> = BasePropType<T> & {\n  type: 'data';\n};\ntype ImagePropType = BasePropType<TextureSource | null> & {\n  type: 'image';\n  parameters?: SamplerProps;\n};\ntype ObjectPropType<T = any> = BasePropType<T> & {\n  type: 'object';\n  optional?: boolean;\n  /** Ignore change in the prop value.\n   * @default false\n   */\n  ignore?: boolean;\n  /** Deep-compare two prop values. Only used if `ignore: false`.\n   * When a number is supplied, used as the depth of deep-comparison. 0 is equivalent to shallow comparison, -1 is infinite depth\n   * When a boolean is supplied, `true` is equivalent to `1` (shallow compare all child fields)\n   * @default false\n   */\n  compare?: boolean | number;\n};\ntype DeprecatedProp = {\n  deprecatedFor?: string | string[];\n};\ntype PropTypeDef =\n  | DeprecatedProp\n  | boolean\n  | BooleanPropType\n  | number\n  | NumberPropType\n  | string\n  | DataPropType\n  | number[]\n  | ColorPropType\n  | ArrayPropType\n  | AccessorPropType\n  | FunctionPropType\n  | ImagePropType\n  | ObjectPropType\n  | null;\n\nconst TYPE_DEFINITIONS = {\n  boolean: {\n    validate(value, propType: BooleanPropType) {\n      return true;\n    },\n    equal(value1, value2, propType: BooleanPropType) {\n      return Boolean(value1) === Boolean(value2);\n    }\n  },\n  number: {\n    validate(value, propType: NumberPropType) {\n      return (\n        Number.isFinite(value) &&\n        (!('max' in propType) || value <= propType.max!) &&\n        (!('min' in propType) || value >= propType.min!)\n      );\n    }\n  },\n  color: {\n    validate(value, propType: ColorPropType) {\n      return (\n        (propType.optional && !value) ||\n        (isArray(value) && (value.length === 3 || value.length === 4))\n      );\n    },\n    equal(value1, value2, propType: ColorPropType) {\n      return deepEqual(value1, value2, 1);\n    }\n  },\n  accessor: {\n    validate(value, propType: AccessorPropType) {\n      const valueType = getTypeOf(value);\n      return valueType === 'function' || valueType === getTypeOf(propType.value);\n    },\n    equal(value1, value2, propType: AccessorPropType) {\n      if (typeof value2 === 'function') {\n        return true;\n      }\n      return deepEqual(value1, value2, 1);\n    }\n  },\n  array: {\n    validate(value, propType: ArrayPropType) {\n      return (propType.optional && !value) || isArray(value);\n    },\n    equal(value1, value2, propType: ArrayPropType) {\n      const {compare} = propType;\n      const depth = Number.isInteger(compare as unknown) ? (compare as number) : compare ? 1 : 0;\n      return compare ? deepEqual(value1, value2, depth) : value1 === value2;\n    }\n  },\n  object: {\n    equal(value1, value2, propType: ObjectPropType) {\n      if (propType.ignore) {\n        return true;\n      }\n      const {compare} = propType;\n      const depth = Number.isInteger(compare as unknown) ? (compare as number) : compare ? 1 : 0;\n      return compare ? deepEqual(value1, value2, depth) : value1 === value2;\n    }\n  },\n  function: {\n    validate(value, propType: FunctionPropType) {\n      return (propType.optional && !value) || typeof value === 'function';\n    },\n    equal(value1, value2, propType: FunctionPropType) {\n      // Backward compatibility - {compare: true} and {ignore: false} are equivalent\n      const shouldIgnore = !propType.compare && propType.ignore !== false;\n      return shouldIgnore || value1 === value2;\n    }\n  },\n  data: {\n    transform: (value, propType: DataPropType, component) => {\n      if (!value) {\n        return value;\n      }\n      const {dataTransform} = component.props;\n      if (dataTransform) {\n        return dataTransform(value);\n      }\n      // Detect loaders.gl v4 table format\n      if (\n        typeof value.shape === 'string' &&\n        value.shape.endsWith('-table') &&\n        Array.isArray(value.data)\n      ) {\n        return value.data;\n      }\n      return value;\n    }\n  },\n  image: {\n    transform: (value, propType: ImagePropType, component) => {\n      const context = (component as Layer).context;\n      if (!context || !context.device) {\n        return null;\n      }\n      return createTexture(component.id, context.device, value, {\n        ...propType.parameters,\n        ...component.props.textureParameters\n      });\n    },\n    release: (value, propType: ImagePropType, component) => {\n      destroyTexture(component.id, value);\n    }\n  }\n} as const;\n\nexport function parsePropTypes(propDefs: Record<string, PropTypeDef>): {\n  propTypes: Record<string, PropType>;\n  defaultProps: Record<string, any>;\n  deprecatedProps: Record<string, string[]>;\n} {\n  const propTypes = {};\n  const defaultProps = {};\n  const deprecatedProps = {};\n\n  for (const [propName, propDef] of Object.entries(propDefs)) {\n    const deprecated = (propDef as DeprecatedProp)?.deprecatedFor;\n    if (deprecated) {\n      deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];\n    } else {\n      const propType = parsePropType(propName, propDef);\n      propTypes[propName] = propType;\n      defaultProps[propName] = propType.value;\n    }\n  }\n  return {propTypes, defaultProps, deprecatedProps};\n}\n\n// Parses one property definition entry. Either contains:\n// * a valid prop type object ({type, ...})\n// * or just a default value, in which case type and name inference is used\nfunction parsePropType(name: string, propDef: PropTypeDef): PropType {\n  switch (getTypeOf(propDef)) {\n    case 'object':\n      return normalizePropDefinition(name, propDef);\n\n    case 'array':\n      return normalizePropDefinition(name, {type: 'array', value: propDef, compare: false});\n\n    case 'boolean':\n      return normalizePropDefinition(name, {type: 'boolean', value: propDef});\n\n    case 'number':\n      return normalizePropDefinition(name, {type: 'number', value: propDef});\n\n    case 'function':\n      // return guessFunctionType(name, propDef);\n      return normalizePropDefinition(name, {type: 'function', value: propDef, compare: true});\n\n    default:\n      return {name, type: 'unknown', value: propDef};\n  }\n}\n\nfunction normalizePropDefinition(name, propDef): PropType {\n  if (!('type' in propDef)) {\n    if (!('value' in propDef)) {\n      // If no type and value this object is likely the value\n      return {name, type: 'object', value: propDef};\n    }\n    return {name, type: getTypeOf(propDef.value), ...propDef};\n  }\n  return {name, ...TYPE_DEFINITIONS[propDef.type], ...propDef};\n}\n\nfunction isArray(value: any): boolean {\n  return Array.isArray(value) || ArrayBuffer.isView(value);\n}\n\n// improved version of javascript typeof that can distinguish arrays and null values\nfunction getTypeOf(value: any): string {\n  if (isArray(value)) {\n    return 'array';\n  }\n  if (value === null) {\n    return 'null';\n  }\n  return typeof value;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}