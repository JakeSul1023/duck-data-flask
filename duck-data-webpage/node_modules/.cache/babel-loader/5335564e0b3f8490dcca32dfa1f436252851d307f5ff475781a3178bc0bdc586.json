{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n/* eslint-disable */\nimport { Vector3, assert } from '@math.gl/core';\nimport { INTERSECTION } from \"../constants.js\";\nimport { Plane } from \"./plane.js\";\n// X, Y, Z Unit vectors\nconst faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];\nconst scratchPlaneCenter = new Vector3();\nconst scratchPlaneNormal = new Vector3();\n// const scratchPlane = new Plane(new Vector3(1.0, 0.0, 0.0), 0.0);\n/** A culling volume defined by planes. */\nexport class CullingVolume {\n  /**\n   * Create a new `CullingVolume` bounded by an array of clipping planed\n   * @param planes Array of clipping planes.\n   * */\n  constructor(planes = []) {\n    this.planes = planes;\n  }\n  /**\n   * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\n   * The planes are aligned to the x, y, and z axes in world coordinates.\n   */\n  fromBoundingSphere(boundingSphere) {\n    this.planes.length = 2 * faces.length;\n    const center = boundingSphere.center;\n    const radius = boundingSphere.radius;\n    let planeIndex = 0;\n    for (const faceNormal of faces) {\n      let plane0 = this.planes[planeIndex];\n      let plane1 = this.planes[planeIndex + 1];\n      if (!plane0) {\n        plane0 = this.planes[planeIndex] = new Plane();\n      }\n      if (!plane1) {\n        plane1 = this.planes[planeIndex + 1] = new Plane();\n      }\n      const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);\n      // const plane0Distance = -faceNormal.dot(plane0Center);\n      plane0.fromPointNormal(plane0Center, faceNormal);\n      const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);\n      const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();\n      // const plane1Distance = -negatedFaceNormal.dot(plane1Center);\n      plane1.fromPointNormal(plane1Center, negatedFaceNormal);\n      planeIndex += 2;\n    }\n    return this;\n  }\n  /** Determines whether a bounding volume intersects the culling volume. */\n  computeVisibility(boundingVolume) {\n    // const planes = this.planes;\n    let intersect = INTERSECTION.INSIDE;\n    for (const plane of this.planes) {\n      const result = boundingVolume.intersectPlane(plane);\n      switch (result) {\n        case INTERSECTION.OUTSIDE:\n          // We are done\n          return INTERSECTION.OUTSIDE;\n        case INTERSECTION.INTERSECTING:\n          // If no other intersection is outside, return INTERSECTING\n          intersect = INTERSECTION.INTERSECTING;\n          break;\n        default:\n      }\n    }\n    return intersect;\n  }\n  /**\n   * Determines whether a bounding volume intersects the culling volume.\n   *\n   * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\n   *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\n   *   the parent (and therefore this) volume is completely inside plane[planeIndex]\n   *   and that plane check can be skipped.\n   */\n  computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {\n    assert(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');\n    if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {\n      // parent is completely outside or completely inside, so this child is as well.\n      return parentPlaneMask;\n    }\n    // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n    // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n    let mask = CullingVolume.MASK_INSIDE;\n    const planes = this.planes;\n    for (let k = 0; k < this.planes.length; ++k) {\n      // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n      const flag = k < 31 ? 1 << k : 0;\n      if (k < 31 && (parentPlaneMask & flag) === 0) {\n        // boundingVolume is known to be INSIDE this plane.\n        continue;\n      }\n      const plane = planes[k];\n      const result = boundingVolume.intersectPlane(plane);\n      if (result === INTERSECTION.OUTSIDE) {\n        return CullingVolume.MASK_OUTSIDE;\n      } else if (result === INTERSECTION.INTERSECTING) {\n        mask |= flag;\n      }\n    }\n    return mask;\n  }\n}\n/**\n * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\n * represents the case where the object bounding volume is entirely outside the culling volume.\n */\nCullingVolume.MASK_OUTSIDE = 0xffffffff;\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume is entirely inside the culling volume.\n */\nCullingVolume.MASK_INSIDE = 0x00000000;\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume (may) intersect all planes of the culling volume.\n */\nCullingVolume.MASK_INDETERMINATE = 0x7fffffff;","map":{"version":3,"names":["Vector3","assert","INTERSECTION","Plane","faces","scratchPlaneCenter","scratchPlaneNormal","CullingVolume","constructor","planes","fromBoundingSphere","boundingSphere","length","center","radius","planeIndex","faceNormal","plane0","plane1","plane0Center","copy","scale","add","fromPointNormal","plane1Center","negatedFaceNormal","negate","computeVisibility","boundingVolume","intersect","INSIDE","plane","result","intersectPlane","OUTSIDE","INTERSECTING","computeVisibilityWithPlaneMask","parentPlaneMask","Number","isFinite","MASK_OUTSIDE","MASK_INSIDE","mask","k","flag","MASK_INDETERMINATE"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\culling\\src\\lib\\culling-volume.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, assert} from '@math.gl/core';\nimport {INTERSECTION} from '../constants';\nimport {Plane} from './plane';\nimport type {BoundingVolume} from './bounding-volumes/bounding-volume';\nimport type {BoundingSphere} from './bounding-volumes/bounding-sphere';\n\n// X, Y, Z Unit vectors\nconst faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];\n\nconst scratchPlaneCenter = new Vector3();\nconst scratchPlaneNormal = new Vector3();\n// const scratchPlane = new Plane(new Vector3(1.0, 0.0, 0.0), 0.0);\n\n/** A culling volume defined by planes. */\nexport class CullingVolume {\n  /**\n   * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\n   * represents the case where the object bounding volume is entirely outside the culling volume.\n   */\n  static MASK_OUTSIDE = 0xffffffff;\n\n  /**\n   * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n   * represents the case where the object bounding volume is entirely inside the culling volume.\n   */\n  static MASK_INSIDE = 0x00000000;\n\n  /**\n   * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n   * represents the case where the object bounding volume (may) intersect all planes of the culling volume.\n   */\n  static MASK_INDETERMINATE = 0x7fffffff;\n\n  /** Array of clipping planes. */\n  readonly planes: Plane[];\n\n  /**\n   * Create a new `CullingVolume` bounded by an array of clipping planed\n   * @param planes Array of clipping planes.\n   * */\n  constructor(planes: Plane[] = []) {\n    this.planes = planes;\n  }\n\n  /**\n   * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\n   * The planes are aligned to the x, y, and z axes in world coordinates.\n   */\n  fromBoundingSphere(boundingSphere: BoundingSphere): CullingVolume {\n    this.planes.length = 2 * faces.length;\n\n    const center = boundingSphere.center;\n    const radius = boundingSphere.radius;\n\n    let planeIndex = 0;\n\n    for (const faceNormal of faces) {\n      let plane0 = this.planes[planeIndex];\n      let plane1 = this.planes[planeIndex + 1];\n\n      if (!plane0) {\n        plane0 = this.planes[planeIndex] = new Plane();\n      }\n      if (!plane1) {\n        plane1 = this.planes[planeIndex + 1] = new Plane();\n      }\n\n      const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);\n      // const plane0Distance = -faceNormal.dot(plane0Center);\n\n      plane0.fromPointNormal(plane0Center, faceNormal);\n\n      const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);\n\n      const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();\n\n      // const plane1Distance = -negatedFaceNormal.dot(plane1Center);\n\n      plane1.fromPointNormal(plane1Center, negatedFaceNormal);\n\n      planeIndex += 2;\n    }\n\n    return this;\n  }\n\n  /** Determines whether a bounding volume intersects the culling volume. */\n  computeVisibility(boundingVolume: BoundingVolume): number {\n    // const planes = this.planes;\n    let intersect: number = INTERSECTION.INSIDE;\n    for (const plane of this.planes) {\n      const result = boundingVolume.intersectPlane(plane);\n      switch (result) {\n        case INTERSECTION.OUTSIDE:\n          // We are done\n          return INTERSECTION.OUTSIDE;\n\n        case INTERSECTION.INTERSECTING:\n          // If no other intersection is outside, return INTERSECTING\n          intersect = INTERSECTION.INTERSECTING;\n          break;\n\n        default:\n      }\n    }\n\n    return intersect;\n  }\n\n  /**\n   * Determines whether a bounding volume intersects the culling volume.\n   *\n   * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\n   *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\n   *   the parent (and therefore this) volume is completely inside plane[planeIndex]\n   *   and that plane check can be skipped.\n   */\n  computeVisibilityWithPlaneMask(boundingVolume: BoundingVolume, parentPlaneMask: number): number {\n    assert(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');\n\n    if (\n      parentPlaneMask === CullingVolume.MASK_OUTSIDE ||\n      parentPlaneMask === CullingVolume.MASK_INSIDE\n    ) {\n      // parent is completely outside or completely inside, so this child is as well.\n      return parentPlaneMask;\n    }\n\n    // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n    // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n    let mask = CullingVolume.MASK_INSIDE;\n\n    const planes = this.planes;\n    for (let k = 0; k < this.planes.length; ++k) {\n      // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n      const flag = k < 31 ? 1 << k : 0;\n      if (k < 31 && (parentPlaneMask & flag) === 0) {\n        // boundingVolume is known to be INSIDE this plane.\n        continue;\n      }\n\n      const plane = planes[k];\n      const result = boundingVolume.intersectPlane(plane);\n      if (result === INTERSECTION.OUTSIDE) {\n        return CullingVolume.MASK_OUTSIDE;\n      } else if (result === INTERSECTION.INTERSECTING) {\n        mask |= flag;\n      }\n    }\n\n    return mask;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}