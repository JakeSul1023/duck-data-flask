{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getResolution, cellToLatLng, latLngToCell, isPentagon, gridDistance, getHexagonEdgeLengthAvg } from 'h3-js';\nimport { CompositeLayer, createIterable } from '@deck.gl/core';\nimport { ColumnLayer, PolygonLayer } from '@deck.gl/layers';\nimport { flattenPolygon, getHexagonCentroid, h3ToPolygon } from \"./h3-utils.js\";\n// There is a cost to updating the instanced geometries when using highPrecision: false\n// This constant defines the distance between two hexagons that leads to \"significant\n// distortion.\" Smaller value makes the column layer more sensitive to viewport change.\nconst UPDATE_THRESHOLD_KM = 10;\nfunction mergeTriggers(getHexagon, coverage) {\n  let trigger;\n  if (getHexagon === undefined || getHexagon === null) {\n    trigger = coverage;\n  } else if (typeof getHexagon === 'object') {\n    trigger = {\n      ...getHexagon,\n      coverage\n    };\n  } else {\n    trigger = {\n      getHexagon,\n      coverage\n    };\n  }\n  return trigger;\n}\nconst defaultProps = {\n  ...PolygonLayer.defaultProps,\n  highPrecision: 'auto',\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  centerHexagon: null,\n  getHexagon: {\n    type: 'accessor',\n    value: x => x.hexagon\n  },\n  extruded: true\n};\n/**\n * Render hexagons from the [H3](https://h3geo.org/) geospatial indexing system.\n */\nclass H3HexagonLayer extends CompositeLayer {\n  initializeState() {\n    H3HexagonLayer._checkH3Lib();\n    this.state = {\n      edgeLengthKM: 0,\n      resolution: -1\n    };\n  }\n  shouldUpdateState(_ref) {\n    let {\n      changeFlags\n    } = _ref;\n    return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;\n  }\n  updateState(_ref2) {\n    let {\n      props,\n      changeFlags\n    } = _ref2;\n    if (props.highPrecision !== true && (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagon)) {\n      const dataProps = this._calculateH3DataProps();\n      this.setState(dataProps);\n    }\n    this._updateVertices(this.context.viewport);\n  }\n  _calculateH3DataProps() {\n    let resolution = -1;\n    let hasPentagon = false;\n    let hasMultipleRes = false;\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(this.props.data);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const hexId = this.props.getHexagon(object, objectInfo);\n      // Take the resolution of the first hex\n      const hexResolution = getResolution(hexId);\n      if (resolution < 0) {\n        resolution = hexResolution;\n        if (!this.props.highPrecision) break;\n      } else if (resolution !== hexResolution) {\n        hasMultipleRes = true;\n        break;\n      }\n      if (isPentagon(hexId)) {\n        hasPentagon = true;\n        break;\n      }\n    }\n    return {\n      resolution,\n      edgeLengthKM: resolution >= 0 ? getHexagonEdgeLengthAvg(resolution, 'km') : 0,\n      hasMultipleRes,\n      hasPentagon\n    };\n  }\n  _shouldUseHighPrecision() {\n    if (this.props.highPrecision === 'auto') {\n      const {\n        resolution,\n        hasPentagon,\n        hasMultipleRes\n      } = this.state;\n      const {\n        viewport\n      } = this.context;\n      return Boolean(viewport?.resolution) || hasMultipleRes || hasPentagon || resolution >= 0 && resolution <= 5;\n    }\n    return this.props.highPrecision;\n  }\n  _updateVertices(viewport) {\n    if (this._shouldUseHighPrecision()) {\n      return;\n    }\n    const {\n      resolution,\n      edgeLengthKM,\n      centerHex\n    } = this.state;\n    if (resolution < 0) {\n      return;\n    }\n    const hex = this.props.centerHexagon || latLngToCell(viewport.latitude, viewport.longitude, resolution);\n    if (centerHex === hex) {\n      return;\n    }\n    if (centerHex) {\n      try {\n        const distance = gridDistance(centerHex, hex);\n        if (distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {\n          return;\n        }\n      } catch {\n        // gridDistance throws if the distance could not be computed\n        // due to the two indexes very far apart or on opposite sides of a pentagon.\n      }\n    }\n    const {\n      unitsPerMeter\n    } = viewport.distanceScales;\n    let vertices = h3ToPolygon(hex);\n    const [centerLat, centerLng] = cellToLatLng(hex);\n    const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);\n    vertices = vertices.map(p => {\n      const worldPosition = viewport.projectFlat(p);\n      return [(worldPosition[0] - centerX) / unitsPerMeter[0], (worldPosition[1] - centerY) / unitsPerMeter[1]];\n    });\n    this.setState({\n      centerHex: hex,\n      vertices\n    });\n  }\n  renderLayers() {\n    return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();\n  }\n  _getForwardProps() {\n    const {\n      elevationScale,\n      material,\n      coverage,\n      extruded,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      getFillColor,\n      getElevation,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers\n    } = this.props;\n    return {\n      elevationScale,\n      extruded,\n      coverage,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      material,\n      getElevation,\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers: {\n        getFillColor: updateTriggers.getFillColor,\n        getElevation: updateTriggers.getElevation,\n        getLineColor: updateTriggers.getLineColor,\n        getLineWidth: updateTriggers.getLineWidth\n      }\n    };\n  }\n  _renderPolygonLayer() {\n    const {\n      data,\n      getHexagon,\n      updateTriggers,\n      coverage\n    } = this.props;\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell-hifi', PolygonLayer);\n    const forwardProps = this._getForwardProps();\n    forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);\n    return new SubLayerClass(forwardProps, this.getSubLayerProps({\n      id: 'hexagon-cell-hifi',\n      updateTriggers: forwardProps.updateTriggers\n    }), {\n      data,\n      _normalize: false,\n      _windingOrder: 'CCW',\n      positionFormat: 'XY',\n      getPolygon: (object, objectInfo) => {\n        const hexagonId = getHexagon(object, objectInfo);\n        return flattenPolygon(h3ToPolygon(hexagonId, coverage));\n      }\n    });\n  }\n  _renderColumnLayer() {\n    const {\n      data,\n      getHexagon,\n      updateTriggers\n    } = this.props;\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n    const forwardProps = this._getForwardProps();\n    forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;\n    return new SubLayerClass(forwardProps, this.getSubLayerProps({\n      id: 'hexagon-cell',\n      flatShading: true,\n      updateTriggers: forwardProps.updateTriggers\n    }), {\n      data,\n      diskResolution: 6,\n      // generate an extruded hexagon as the base geometry\n      radius: 1,\n      vertices: this.state.vertices,\n      getPosition: getHexagonCentroid.bind(null, getHexagon)\n    });\n  }\n}\nH3HexagonLayer.defaultProps = defaultProps;\nH3HexagonLayer.layerName = 'H3HexagonLayer';\n// See `main/bundle.ts`\nH3HexagonLayer._checkH3Lib = () => {};\nexport default H3HexagonLayer;\n//# sourceMappingURL=h3-hexagon-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}