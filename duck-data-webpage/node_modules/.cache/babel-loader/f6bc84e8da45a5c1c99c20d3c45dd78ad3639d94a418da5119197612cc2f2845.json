{"ast":null,"code":"// luma.gl, MIT license\n// Copyright (c) vis.gl contributors\nimport { loadImageBitmap } from \"../application-utils/load-file.js\";\nimport { uid } from \"../utils/uid.js\";\n/**\n * It is very convenient to be able to initialize textures with promises\n * This can add considerable complexity to the Texture class, and doesn't\n * fit with the immutable nature of WebGPU resources.\n * Instead, luma.gl offers async textures as a separate class.\n */\nexport class AsyncTexture {\n  device;\n  id;\n  // TODO - should we type these as possibly `null`? It will make usage harder?\n  // @ts-expect-error\n  texture;\n  // @ts-expect-error\n  sampler;\n  // @ts-expect-error\n  view;\n  ready;\n  isReady = false;\n  destroyed = false;\n  resolveReady = () => {};\n  rejectReady = () => {};\n  get [Symbol.toStringTag]() {\n    return 'AsyncTexture';\n  }\n  toString() {\n    return `AsyncTexture:\"${this.id}\"(${this.isReady ? 'ready' : 'loading'})`;\n  }\n  constructor(device, props) {\n    this.device = device;\n    this.id = props.id || uid('async-texture');\n    // this.id = typeof props?.data === 'string' ? props.data.slice(-20) : uid('async-texture');\n    // Signature: new AsyncTexture(device, {data: url})\n    if (typeof props?.data === 'string' && props.dimension === '2d') {\n      props = {\n        ...props,\n        data: loadImageBitmap(props.data)\n      };\n    }\n    this.ready = new Promise((resolve, reject) => {\n      this.resolveReady = () => {\n        this.isReady = true;\n        resolve();\n      };\n      this.rejectReady = reject;\n    });\n    this.initAsync(props);\n  }\n  async initAsync(props) {\n    let resolveReady;\n    let rejectReady;\n    const asyncData = props.data;\n    const data = await awaitAllPromises(asyncData).then(resolveReady, rejectReady);\n    // Check that we haven't been destroyed while waiting for texture data to load\n    if (this.destroyed) {\n      return;\n    }\n    // Now we can actually create the texture\n    // @ts-expect-error Discriminated union\n    const syncProps = {\n      ...props,\n      data\n    };\n    this.texture = this.device.createTexture(syncProps);\n    this.sampler = this.texture.sampler;\n    this.view = this.texture.view;\n    this.isReady = true;\n  }\n  destroy() {\n    if (this.texture) {\n      this.texture.destroy();\n      // @ts-expect-error\n      this.texture = null;\n    }\n    this.destroyed = true;\n  }\n  /**\n   * Textures are immutable and cannot be resized after creation,\n   * but we can create a similar texture with the same parameters but a new size.\n   * @note Does not copy contents of the texture\n   * @todo Abort pending promise and create a texture with the new size?\n   */\n  resize(size) {\n    if (!this.isReady) {\n      throw new Error('Cannot resize texture before it is ready');\n    }\n    if (size.width === this.texture.width && size.height === this.texture.height) {\n      return false;\n    }\n    if (this.texture) {\n      const texture = this.texture;\n      this.texture = texture.clone(size);\n      texture.destroy();\n    }\n    return true;\n  }\n}\n// HELPERS\n/** Resolve all promises in a nested data structure */\nasync function awaitAllPromises(x) {\n  x = await x;\n  if (Array.isArray(x)) {\n    return await Promise.all(x.map(awaitAllPromises));\n  }\n  if (x && typeof x === 'object' && x.constructor === Object) {\n    const object = x;\n    const values = await Promise.all(Object.values(object));\n    const keys = Object.keys(object);\n    const resolvedObject = {};\n    for (let i = 0; i < keys.length; i++) {\n      resolvedObject[keys[i]] = values[i];\n    }\n    return resolvedObject;\n  }\n  return x;\n}\n//# sourceMappingURL=async-texture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}