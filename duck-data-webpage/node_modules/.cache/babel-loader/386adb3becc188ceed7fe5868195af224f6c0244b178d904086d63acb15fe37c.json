{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { compareArrayBuffers, concatenateArrayBuffers } from '@loaders.gl/loader-utils';\nimport { createZip64Info, setFieldToNumber } from \"./zip64-info-generation.js\";\n// offsets accroding to https://en.wikipedia.org/wiki/ZIP_(file_format)\nconst COMPRESSION_METHOD_OFFSET = 8;\nconst COMPRESSED_SIZE_OFFSET = 18;\nconst UNCOMPRESSED_SIZE_OFFSET = 22;\nconst FILE_NAME_LENGTH_OFFSET = 26;\nconst EXTRA_FIELD_LENGTH_OFFSET = 28;\nconst FILE_NAME_OFFSET = 30n;\nexport const signature = new Uint8Array([0x50, 0x4b, 0x03, 0x04]);\n/**\n * Parses local file header of zip file\n * @param headerOffset - offset in the archive where header starts\n * @param buffer - buffer containing whole array\n * @returns Info from the header\n */\nexport const parseZipLocalFileHeader = async (headerOffset, file) => {\n  const mainHeader = new DataView(await file.slice(headerOffset, headerOffset + FILE_NAME_OFFSET));\n  const magicBytes = mainHeader.buffer.slice(0, 4);\n  if (!compareArrayBuffers(magicBytes, signature)) {\n    return null;\n  }\n  const fileNameLength = mainHeader.getUint16(FILE_NAME_LENGTH_OFFSET, true);\n  const extraFieldLength = mainHeader.getUint16(EXTRA_FIELD_LENGTH_OFFSET, true);\n  const additionalHeader = await file.slice(headerOffset + FILE_NAME_OFFSET, headerOffset + FILE_NAME_OFFSET + BigInt(fileNameLength + extraFieldLength));\n  const fileNameBuffer = additionalHeader.slice(0, fileNameLength);\n  const extraDataBuffer = new DataView(additionalHeader.slice(fileNameLength, additionalHeader.byteLength));\n  const fileName = new TextDecoder().decode(fileNameBuffer).split('\\\\').join('/');\n  let fileDataOffset = headerOffset + FILE_NAME_OFFSET + BigInt(fileNameLength + extraFieldLength);\n  const compressionMethod = mainHeader.getUint16(COMPRESSION_METHOD_OFFSET, true);\n  let compressedSize = BigInt(mainHeader.getUint32(COMPRESSED_SIZE_OFFSET, true)); // add zip 64 logic\n  let uncompressedSize = BigInt(mainHeader.getUint32(UNCOMPRESSED_SIZE_OFFSET, true)); // add zip 64 logic\n  let offsetInZip64Data = 4;\n  // looking for info that might be also be in zip64 extra field\n  if (uncompressedSize === BigInt(0xffffffff)) {\n    uncompressedSize = extraDataBuffer.getBigUint64(offsetInZip64Data, true);\n    offsetInZip64Data += 8;\n  }\n  if (compressedSize === BigInt(0xffffffff)) {\n    compressedSize = extraDataBuffer.getBigUint64(offsetInZip64Data, true);\n    offsetInZip64Data += 8;\n  }\n  if (fileDataOffset === BigInt(0xffffffff)) {\n    fileDataOffset = extraDataBuffer.getBigUint64(offsetInZip64Data, true); // setting it to the one from zip64\n  }\n  return {\n    fileNameLength,\n    fileName,\n    extraFieldLength,\n    fileDataOffset,\n    compressedSize,\n    compressionMethod\n  };\n};\n/**\n * generates local header for the file\n * @param options info that can be placed into local header\n * @returns buffer with header\n */\nexport function generateLocalHeader(options) {\n  const optionsToUse = {\n    ...options,\n    extraLength: 0,\n    fnlength: options.fileName.length\n  };\n  let zip64header = new ArrayBuffer(0);\n  const optionsToZip64 = {};\n  if (optionsToUse.length >= 0xffffffff) {\n    optionsToZip64.size = optionsToUse.length;\n    optionsToUse.length = 0xffffffff;\n  }\n  if (Object.keys(optionsToZip64).length) {\n    zip64header = createZip64Info(optionsToZip64);\n    optionsToUse.extraLength = zip64header.byteLength;\n  }\n  // base length without file name and extra info is static\n  const header = new DataView(new ArrayBuffer(Number(FILE_NAME_OFFSET)));\n  for (const field of ZIP_HEADER_FIELDS) {\n    setFieldToNumber(header, field.size, field.offset, optionsToUse[field.name ?? ''] ?? field.default ?? 0);\n  }\n  const encodedName = new TextEncoder().encode(optionsToUse.fileName);\n  const resHeader = concatenateArrayBuffers(header.buffer, encodedName, zip64header);\n  return resHeader;\n}\nconst ZIP_HEADER_FIELDS = [\n// Local file header signature = 0x04034b50\n{\n  offset: 0,\n  size: 4,\n  default: new DataView(signature.buffer).getUint32(0, true)\n},\n// Version needed to extract (minimum)\n{\n  offset: 4,\n  size: 2,\n  default: 45\n},\n// General purpose bit flag\n{\n  offset: 6,\n  size: 2,\n  default: 0\n},\n// Compression method\n{\n  offset: 8,\n  size: 2,\n  default: 0\n},\n// File last modification time\n{\n  offset: 10,\n  size: 2,\n  default: 0\n},\n// File last modification date\n{\n  offset: 12,\n  size: 2,\n  default: 0\n},\n// CRC-32 of uncompressed data\n{\n  offset: 14,\n  size: 4,\n  name: 'crc32'\n},\n// Compressed size (or 0xffffffff for ZIP64)\n{\n  offset: 18,\n  size: 4,\n  name: 'length'\n},\n// Uncompressed size (or 0xffffffff for ZIP64)\n{\n  offset: 22,\n  size: 4,\n  name: 'length'\n},\n// File name length (n)\n{\n  offset: 26,\n  size: 2,\n  name: 'fnlength'\n},\n// Extra field length (m)\n{\n  offset: 28,\n  size: 2,\n  default: 0,\n  name: 'extraLength'\n}];","map":{"version":3,"names":["compareArrayBuffers","concatenateArrayBuffers","createZip64Info","setFieldToNumber","COMPRESSION_METHOD_OFFSET","COMPRESSED_SIZE_OFFSET","UNCOMPRESSED_SIZE_OFFSET","FILE_NAME_LENGTH_OFFSET","EXTRA_FIELD_LENGTH_OFFSET","FILE_NAME_OFFSET","signature","Uint8Array","parseZipLocalFileHeader","headerOffset","file","mainHeader","DataView","slice","magicBytes","buffer","fileNameLength","getUint16","extraFieldLength","additionalHeader","BigInt","fileNameBuffer","extraDataBuffer","byteLength","fileName","TextDecoder","decode","split","join","fileDataOffset","compressionMethod","compressedSize","getUint32","uncompressedSize","offsetInZip64Data","getBigUint64","generateLocalHeader","options","optionsToUse","extraLength","fnlength","length","zip64header","ArrayBuffer","optionsToZip64","size","Object","keys","header","Number","field","ZIP_HEADER_FIELDS","offset","name","default","encodedName","TextEncoder","encode","resHeader"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/zip/dist/parse-zip/local-file-header.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { compareArrayBuffers, concatenateArrayBuffers } from '@loaders.gl/loader-utils';\nimport { createZip64Info, setFieldToNumber } from \"./zip64-info-generation.js\";\n// offsets accroding to https://en.wikipedia.org/wiki/ZIP_(file_format)\nconst COMPRESSION_METHOD_OFFSET = 8;\nconst COMPRESSED_SIZE_OFFSET = 18;\nconst UNCOMPRESSED_SIZE_OFFSET = 22;\nconst FILE_NAME_LENGTH_OFFSET = 26;\nconst EXTRA_FIELD_LENGTH_OFFSET = 28;\nconst FILE_NAME_OFFSET = 30n;\nexport const signature = new Uint8Array([0x50, 0x4b, 0x03, 0x04]);\n/**\n * Parses local file header of zip file\n * @param headerOffset - offset in the archive where header starts\n * @param buffer - buffer containing whole array\n * @returns Info from the header\n */\nexport const parseZipLocalFileHeader = async (headerOffset, file) => {\n    const mainHeader = new DataView(await file.slice(headerOffset, headerOffset + FILE_NAME_OFFSET));\n    const magicBytes = mainHeader.buffer.slice(0, 4);\n    if (!compareArrayBuffers(magicBytes, signature)) {\n        return null;\n    }\n    const fileNameLength = mainHeader.getUint16(FILE_NAME_LENGTH_OFFSET, true);\n    const extraFieldLength = mainHeader.getUint16(EXTRA_FIELD_LENGTH_OFFSET, true);\n    const additionalHeader = await file.slice(headerOffset + FILE_NAME_OFFSET, headerOffset + FILE_NAME_OFFSET + BigInt(fileNameLength + extraFieldLength));\n    const fileNameBuffer = additionalHeader.slice(0, fileNameLength);\n    const extraDataBuffer = new DataView(additionalHeader.slice(fileNameLength, additionalHeader.byteLength));\n    const fileName = new TextDecoder().decode(fileNameBuffer).split('\\\\').join('/');\n    let fileDataOffset = headerOffset + FILE_NAME_OFFSET + BigInt(fileNameLength + extraFieldLength);\n    const compressionMethod = mainHeader.getUint16(COMPRESSION_METHOD_OFFSET, true);\n    let compressedSize = BigInt(mainHeader.getUint32(COMPRESSED_SIZE_OFFSET, true)); // add zip 64 logic\n    let uncompressedSize = BigInt(mainHeader.getUint32(UNCOMPRESSED_SIZE_OFFSET, true)); // add zip 64 logic\n    let offsetInZip64Data = 4;\n    // looking for info that might be also be in zip64 extra field\n    if (uncompressedSize === BigInt(0xffffffff)) {\n        uncompressedSize = extraDataBuffer.getBigUint64(offsetInZip64Data, true);\n        offsetInZip64Data += 8;\n    }\n    if (compressedSize === BigInt(0xffffffff)) {\n        compressedSize = extraDataBuffer.getBigUint64(offsetInZip64Data, true);\n        offsetInZip64Data += 8;\n    }\n    if (fileDataOffset === BigInt(0xffffffff)) {\n        fileDataOffset = extraDataBuffer.getBigUint64(offsetInZip64Data, true); // setting it to the one from zip64\n    }\n    return {\n        fileNameLength,\n        fileName,\n        extraFieldLength,\n        fileDataOffset,\n        compressedSize,\n        compressionMethod\n    };\n};\n/**\n * generates local header for the file\n * @param options info that can be placed into local header\n * @returns buffer with header\n */\nexport function generateLocalHeader(options) {\n    const optionsToUse = {\n        ...options,\n        extraLength: 0,\n        fnlength: options.fileName.length\n    };\n    let zip64header = new ArrayBuffer(0);\n    const optionsToZip64 = {};\n    if (optionsToUse.length >= 0xffffffff) {\n        optionsToZip64.size = optionsToUse.length;\n        optionsToUse.length = 0xffffffff;\n    }\n    if (Object.keys(optionsToZip64).length) {\n        zip64header = createZip64Info(optionsToZip64);\n        optionsToUse.extraLength = zip64header.byteLength;\n    }\n    // base length without file name and extra info is static\n    const header = new DataView(new ArrayBuffer(Number(FILE_NAME_OFFSET)));\n    for (const field of ZIP_HEADER_FIELDS) {\n        setFieldToNumber(header, field.size, field.offset, optionsToUse[field.name ?? ''] ?? field.default ?? 0);\n    }\n    const encodedName = new TextEncoder().encode(optionsToUse.fileName);\n    const resHeader = concatenateArrayBuffers(header.buffer, encodedName, zip64header);\n    return resHeader;\n}\nconst ZIP_HEADER_FIELDS = [\n    // Local file header signature = 0x04034b50\n    {\n        offset: 0,\n        size: 4,\n        default: new DataView(signature.buffer).getUint32(0, true)\n    },\n    // Version needed to extract (minimum)\n    {\n        offset: 4,\n        size: 2,\n        default: 45\n    },\n    // General purpose bit flag\n    {\n        offset: 6,\n        size: 2,\n        default: 0\n    },\n    // Compression method\n    {\n        offset: 8,\n        size: 2,\n        default: 0\n    },\n    // File last modification time\n    {\n        offset: 10,\n        size: 2,\n        default: 0\n    },\n    // File last modification date\n    {\n        offset: 12,\n        size: 2,\n        default: 0\n    },\n    // CRC-32 of uncompressed data\n    {\n        offset: 14,\n        size: 4,\n        name: 'crc32'\n    },\n    // Compressed size (or 0xffffffff for ZIP64)\n    {\n        offset: 18,\n        size: 4,\n        name: 'length'\n    },\n    // Uncompressed size (or 0xffffffff for ZIP64)\n    {\n        offset: 22,\n        size: 4,\n        name: 'length'\n    },\n    // File name length (n)\n    {\n        offset: 26,\n        size: 2,\n        name: 'fnlength'\n    },\n    // Extra field length (m)\n    {\n        offset: 28,\n        size: 2,\n        default: 0,\n        name: 'extraLength'\n    }\n];\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}