{"ast":null,"code":"import { getImageSize } from \"../category-api/parsed-image-api.js\";\n// @ts-ignore TS2339: Property does not exist on type\nconst encodeImageNode = globalThis.loaders?.encodeImageNode;\n/**\n * Returns data bytes representing a compressed image in PNG or JPG format,\n * This data can be saved using file system (f) methods or used in a request.\n * @param image - ImageBitmap Image or Canvas\n * @param options\n * param opt.type='png' - png, jpg or image/png, image/jpg are valid\n * param mimeType= - Whether to include a data URI header\n */\nexport async function encodeImage(image, options) {\n  options = options || {};\n  options.image = options.image || {};\n  return encodeImageNode ? encodeImageNode(image, {\n    type: options.image.mimeType\n  }) : encodeImageInBrowser(image, options);\n}\n// In case we get exceptions from canvas.toBlob(resolve, type, quality)\nlet qualityParamSupported = true;\n/**\n *\n * @param image\n * @param options\n * @note Based on canvas.toBlob\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob\n */\nasync function encodeImageInBrowser(image, options) {\n  const {\n    mimeType,\n    jpegQuality\n  } = options.image;\n  const {\n    width,\n    height\n  } = getImageSize(image);\n  // create a canvas and resize it to the size of our image\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  drawImageToCanvas(image, canvas);\n  // The actual encoding is done asynchronously with `canvas.toBlob()`\n  const blob = await new Promise(resolve => {\n    // get it back as a Blob\n    if (jpegQuality && qualityParamSupported) {\n      try {\n        canvas.toBlob(resolve, mimeType, jpegQuality);\n        return;\n      } catch (error) {\n        qualityParamSupported = false;\n      }\n    }\n    canvas.toBlob(resolve, mimeType);\n  });\n  if (!blob) {\n    throw new Error('image encoding failed');\n  }\n  return await blob.arrayBuffer();\n}\nfunction drawImageToCanvas(image, canvas, x = 0, y = 0) {\n  // Try optimized path for ImageBitmaps via bitmaprenderer context\n  if (x === 0 && y === 0 && typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    const context = canvas.getContext('bitmaprenderer');\n    if (context) {\n      // transfer the ImageBitmap to it\n      context.transferFromImageBitmap(image);\n      return canvas;\n    }\n  }\n  // Available on most platforms, except IE11 and Andriod WebViews...\n  const context = canvas.getContext('2d');\n  if (image.data) {\n    // ImageData constructor expects clamped array even though getImageData does not return a clamped array...\n    const clampedArray = new Uint8ClampedArray(image.data);\n    const imageData = new ImageData(clampedArray, image.width, image.height);\n    context.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n  // Fall back to generic image/image bitmap rendering path\n  context.drawImage(image, 0, 0);\n  return canvas;\n}","map":{"version":3,"names":["getImageSize","encodeImageNode","globalThis","loaders","encodeImage","image","options","type","mimeType","encodeImageInBrowser","qualityParamSupported","jpegQuality","width","height","canvas","document","createElement","drawImageToCanvas","blob","Promise","resolve","toBlob","error","Error","arrayBuffer","x","y","ImageBitmap","context","getContext","transferFromImageBitmap","data","clampedArray","Uint8ClampedArray","imageData","ImageData","putImageData","drawImage"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/images/dist/lib/encoders/encode-image.js"],"sourcesContent":["import { getImageSize } from \"../category-api/parsed-image-api.js\";\n// @ts-ignore TS2339: Property does not exist on type\nconst encodeImageNode = globalThis.loaders?.encodeImageNode;\n/**\n * Returns data bytes representing a compressed image in PNG or JPG format,\n * This data can be saved using file system (f) methods or used in a request.\n * @param image - ImageBitmap Image or Canvas\n * @param options\n * param opt.type='png' - png, jpg or image/png, image/jpg are valid\n * param mimeType= - Whether to include a data URI header\n */\nexport async function encodeImage(image, options) {\n    options = options || {};\n    options.image = options.image || {};\n    return encodeImageNode\n        ? encodeImageNode(image, { type: options.image.mimeType })\n        : encodeImageInBrowser(image, options);\n}\n// In case we get exceptions from canvas.toBlob(resolve, type, quality)\nlet qualityParamSupported = true;\n/**\n *\n * @param image\n * @param options\n * @note Based on canvas.toBlob\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob\n */\nasync function encodeImageInBrowser(image, options) {\n    const { mimeType, jpegQuality } = options.image;\n    const { width, height } = getImageSize(image);\n    // create a canvas and resize it to the size of our image\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    drawImageToCanvas(image, canvas);\n    // The actual encoding is done asynchronously with `canvas.toBlob()`\n    const blob = await new Promise((resolve) => {\n        // get it back as a Blob\n        if (jpegQuality && qualityParamSupported) {\n            try {\n                canvas.toBlob(resolve, mimeType, jpegQuality);\n                return;\n            }\n            catch (error) {\n                qualityParamSupported = false;\n            }\n        }\n        canvas.toBlob(resolve, mimeType);\n    });\n    if (!blob) {\n        throw new Error('image encoding failed');\n    }\n    return await blob.arrayBuffer();\n}\nfunction drawImageToCanvas(image, canvas, x = 0, y = 0) {\n    // Try optimized path for ImageBitmaps via bitmaprenderer context\n    if (x === 0 && y === 0 && typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n        const context = canvas.getContext('bitmaprenderer');\n        if (context) {\n            // transfer the ImageBitmap to it\n            context.transferFromImageBitmap(image);\n            return canvas;\n        }\n    }\n    // Available on most platforms, except IE11 and Andriod WebViews...\n    const context = canvas.getContext('2d');\n    if (image.data) {\n        // ImageData constructor expects clamped array even though getImageData does not return a clamped array...\n        const clampedArray = new Uint8ClampedArray(image.data);\n        const imageData = new ImageData(clampedArray, image.width, image.height);\n        context.putImageData(imageData, 0, 0);\n        return canvas;\n    }\n    // Fall back to generic image/image bitmap rendering path\n    context.drawImage(image, 0, 0);\n    return canvas;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}