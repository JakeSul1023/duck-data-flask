{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { project } from '@deck.gl/core';\n/** A model can have one of the following modes */\nexport const TERRAIN_MODE = {\n  NONE: 0,\n  /** A terrain layer rendering encoded ground elevation into the height map */\n  WRITE_HEIGHT_MAP: 1,\n  /** An offset layer reading encoded ground elevation from the height map */\n  USE_HEIGHT_MAP: 2,\n  /** A terrain layer rendering to screen, using the cover fbo overlaid with its own texture */\n  USE_COVER: 3,\n  /** A terrain layer rendering to screen, using the cover fbo as texture */\n  USE_COVER_ONLY: 4,\n  /** Draped layer is rendered into a texture, and never to screen */\n  SKIP: 5\n};\nconst TERRAIN_MODE_CONSTANTS = Object.keys(TERRAIN_MODE).map(key => `const float TERRAIN_MODE_${key} = ${TERRAIN_MODE[key]}.0;`).join('\\n');\nconst uniformBlock =\n// eslint-disable-next-line prefer-template\nTERRAIN_MODE_CONSTANTS + /* glsl */`\nuniform terrainUniforms {\n  float mode;\n  vec4 bounds;\n} terrain;\n\nuniform sampler2D terrain_map;\n`;\nexport const terrainModule = {\n  name: 'terrain',\n  dependencies: [project],\n  // eslint-disable-next-line prefer-template\n  vs: uniformBlock + /* glsl */'out vec3 commonPos;',\n  // eslint-disable-next-line prefer-template\n  fs: uniformBlock + /* glsl */'in vec3 commonPos;',\n  inject: {\n    'vs:#main-start': /* glsl */`\nif (terrain.mode == TERRAIN_MODE_SKIP) {\n  gl_Position = vec4(0.0);\n  return;\n}\n`,\n    'vs:DECKGL_FILTER_GL_POSITION': /* glsl */`\ncommonPos = geometry.position.xyz;\nif (terrain.mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  vec2 texCoords = (commonPos.xy - terrain.bounds.xy) / terrain.bounds.zw;\n  position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);\n  commonPos.z += project.commonOrigin.z;\n}\nif (terrain.mode == TERRAIN_MODE_USE_HEIGHT_MAP) {\n  vec3 anchor = geometry.worldPosition;\n  anchor.z = 0.0;\n  vec3 anchorCommon = project_position(anchor);\n  vec2 texCoords = (anchorCommon.xy - terrain.bounds.xy) / terrain.bounds.zw;\n  if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {\n    float terrainZ = texture(terrain_map, texCoords).r;\n    geometry.position.z += terrainZ;\n    position = project_common_position_to_clipspace(geometry.position);\n  }\n}\n    `,\n    'fs:#main-start': /* glsl */`\nif (terrain.mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\n  fragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);\n  return;\n}\n    `,\n    'fs:DECKGL_FILTER_COLOR': /* glsl */`\nif ((terrain.mode == TERRAIN_MODE_USE_COVER) || (terrain.mode == TERRAIN_MODE_USE_COVER_ONLY)) {\n  vec2 texCoords = (commonPos.xy - terrain.bounds.xy) / terrain.bounds.zw;\n  vec4 pixel = texture(terrain_map, texCoords);\n  if (terrain.mode == TERRAIN_MODE_USE_COVER_ONLY) {\n    color = pixel;\n  } else {\n    // pixel is premultiplied\n    color = pixel + color * (1.0 - pixel.a);\n  }\n  return;\n}\n    `\n  },\n  // eslint-disable-next-line complexity\n  getUniforms: (opts = {}) => {\n    if ('dummyHeightMap' in opts) {\n      const {\n        drawToTerrainHeightMap,\n        heightMap,\n        heightMapBounds,\n        dummyHeightMap,\n        terrainCover,\n        useTerrainHeightMap,\n        terrainSkipRender\n      } = opts;\n      const projectUniforms = project.getUniforms(opts.project);\n      const {\n        commonOrigin\n      } = projectUniforms;\n      let mode = terrainSkipRender ? TERRAIN_MODE.SKIP : TERRAIN_MODE.NONE;\n      // height map if case USE_HEIGHT_MAP, terrain cover if USE_COVER, otherwise empty\n      let sampler = dummyHeightMap;\n      // height map bounds if case USE_HEIGHT_MAP, terrain cover bounds if USE_COVER, otherwise null\n      let bounds = null;\n      if (drawToTerrainHeightMap) {\n        mode = TERRAIN_MODE.WRITE_HEIGHT_MAP;\n        bounds = heightMapBounds;\n      } else if (useTerrainHeightMap && heightMap) {\n        mode = TERRAIN_MODE.USE_HEIGHT_MAP;\n        sampler = heightMap;\n        bounds = heightMapBounds;\n      } else if (terrainCover) {\n        // This is a terrain layer\n        const fbo = opts.isPicking ? terrainCover.getPickingFramebuffer() : terrainCover.getRenderFramebuffer();\n        sampler = fbo?.colorAttachments[0].texture;\n        if (opts.isPicking) {\n          // Never render the layer itself in picking pass\n          mode = TERRAIN_MODE.SKIP;\n        }\n        if (sampler) {\n          mode = mode === TERRAIN_MODE.SKIP ? TERRAIN_MODE.USE_COVER_ONLY : TERRAIN_MODE.USE_COVER;\n          bounds = terrainCover.bounds;\n        } else {\n          sampler = dummyHeightMap;\n        }\n      }\n      /* eslint-disable camelcase */\n      return {\n        mode,\n        terrain_map: sampler,\n        // Convert bounds to the common space, as [minX, minY, width, height]\n        bounds: bounds ? [bounds[0] - commonOrigin[0], bounds[1] - commonOrigin[1], bounds[2] - bounds[0], bounds[3] - bounds[1]] : [0, 0, 0, 0]\n      };\n    }\n    return {};\n  },\n  uniformTypes: {\n    mode: 'f32',\n    bounds: 'vec4<f32>'\n  }\n};\n//# sourceMappingURL=shader-module.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}