{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport LayersPass from \"./layers-pass.js\";\nimport log from \"../utils/log.js\";\nconst PICKING_BLENDING = {\n  blendColorOperation: 'add',\n  blendColorSrcFactor: 'one',\n  blendColorDstFactor: 'zero',\n  blendAlphaOperation: 'add',\n  blendAlphaSrcFactor: 'constant-alpha',\n  blendAlphaDstFactor: 'zero'\n};\nexport default class PickLayersPass extends LayersPass {\n  constructor() {\n    super(...arguments);\n    this._colorEncoderState = null;\n  }\n  render(props) {\n    if ('pickingFBO' in props) {\n      // When drawing into an off-screen buffer, use the alpha channel to encode layer index\n      return this._drawPickingBuffer(props);\n    }\n    // When drawing to screen (debug mode), do not use the alpha channel so that result is always visible\n    return super.render(props);\n  }\n  // Private\n  // Draws list of layers and viewports into the picking buffer\n  // Note: does not sample the buffer, that has to be done by the caller\n  _drawPickingBuffer({\n    layers,\n    layerFilter,\n    views,\n    viewports,\n    onViewportActive,\n    pickingFBO,\n    deviceRect: {\n      x,\n      y,\n      width,\n      height\n    },\n    cullRect,\n    effects,\n    pass = 'picking',\n    pickZ,\n    shaderModuleProps\n  }) {\n    this.pickZ = pickZ;\n    const colorEncoderState = this._resetColorEncoder(pickZ);\n    const scissorRect = [x, y, width, height];\n    // Make sure we clear scissor test and fbo bindings in case of exceptions\n    // We are only interested in one pixel, no need to render anything else\n    // Note that the callback here is called synchronously.\n    // Set blend mode for picking\n    // always overwrite existing pixel with [r,g,b,layerIndex]\n    const renderStatus = super.render({\n      target: pickingFBO,\n      layers,\n      layerFilter,\n      views,\n      viewports,\n      onViewportActive,\n      cullRect,\n      effects: effects?.filter(e => e.useInPicking),\n      pass,\n      isPicking: true,\n      shaderModuleProps,\n      clearColor: [0, 0, 0, 0],\n      colorMask: 0xf,\n      scissorRect\n    });\n    // Clear the temp field\n    this._colorEncoderState = null;\n    const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);\n    return {\n      decodePickingColor,\n      stats: renderStatus\n    };\n  }\n  shouldDrawLayer(layer) {\n    const {\n      pickable,\n      operation\n    } = layer.props;\n    return pickable && operation.includes('draw') || operation.includes('terrain') || operation.includes('mask');\n  }\n  getShaderModuleProps(layer, effects, otherShaderModuleProps) {\n    return {\n      picking: {\n        isActive: 1,\n        isAttribute: this.pickZ\n      },\n      lighting: {\n        enabled: false\n      }\n    };\n  }\n  getLayerParameters(layer, layerIndex, viewport) {\n    // TODO use Parameters type\n    const pickParameters = {\n      ...layer.props.parameters\n    };\n    const {\n      pickable,\n      operation\n    } = layer.props;\n    if (!this._colorEncoderState || operation.includes('terrain')) {\n      pickParameters.blend = false;\n    } else if (pickable && operation.includes('draw')) {\n      Object.assign(pickParameters, PICKING_BLENDING);\n      pickParameters.blend = true;\n      // TODO: blendColor no longer part of luma.gl API\n      pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);\n    }\n    return pickParameters;\n  }\n  _resetColorEncoder(pickZ) {\n    // Track encoded layer indices\n    this._colorEncoderState = pickZ ? null : {\n      byLayer: new Map(),\n      byAlpha: []\n    };\n    // Temporarily store it on the instance so that it can be accessed by this.getLayerParameters\n    return this._colorEncoderState;\n  }\n}\n// Assign an unique alpha value for each pickable layer and track the encoding in the cache object\n// Returns normalized blend color\nfunction encodeColor(encoded, layer, viewport) {\n  const {\n    byLayer,\n    byAlpha\n  } = encoded;\n  let a;\n  // Encode layerIndex in the alpha channel\n  // TODO - combine small layers to better utilize the picking color space\n  let entry = byLayer.get(layer);\n  if (entry) {\n    entry.viewports.push(viewport);\n    a = entry.a;\n  } else {\n    a = byLayer.size + 1;\n    if (a <= 255) {\n      entry = {\n        a,\n        layer,\n        viewports: [viewport]\n      };\n      byLayer.set(layer, entry);\n      byAlpha[a] = entry;\n    } else {\n      log.warn('Too many pickable layers, only picking the first 255')();\n      a = 0;\n    }\n  }\n  return [0, 0, 0, a / 255];\n}\n// Given a picked color, retrieve the corresponding layer and viewports from cache\nfunction decodeColor(encoded, pickedColor) {\n  const entry = encoded.byAlpha[pickedColor[3]];\n  return entry && {\n    pickedLayer: entry.layer,\n    pickedViewports: entry.viewports,\n    pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)\n  };\n}\n//# sourceMappingURL=pick-layers-pass.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}