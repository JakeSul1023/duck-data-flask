{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Buffer } from '@luma.gl/core';\nimport { typedArrayFromDataType, getBufferAttributeLayout, getStride, dataTypeFromTypedArray } from \"./gl-utils.js\";\nimport typedArrayManager from \"../../utils/typed-array-manager.js\";\nimport { toDoublePrecisionArray } from \"../../utils/math-utils.js\";\nimport log from \"../../utils/log.js\";\nfunction resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {\n  if (shaderAttributeOptions.offset) {\n    log.removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();\n  }\n  // All shader attributes share the parent's stride\n  const stride = getStride(baseAccessor);\n  // `vertexOffset` is used to access the neighboring vertex's value\n  // e.g. `nextPositions` in polygon\n  const vertexOffset = shaderAttributeOptions.vertexOffset !== undefined ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;\n  // `elementOffset` is defined when shader attribute's size is smaller than the parent's\n  // e.g. `translations` in transform matrix\n  const elementOffset = shaderAttributeOptions.elementOffset || 0;\n  const offset =\n  // offsets defined by the attribute\n  vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (\n  // offsets defined by external buffers if any\n  baseAccessor.offset || 0);\n  return {\n    ...shaderAttributeOptions,\n    offset,\n    stride\n  };\n}\nfunction resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {\n  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);\n  return {\n    high: resolvedOptions,\n    low: {\n      ...resolvedOptions,\n      offset: resolvedOptions.offset + baseAccessor.size * 4\n    }\n  };\n}\nexport default class DataColumn {\n  /* eslint-disable max-statements */\n  constructor(device, opts, state) {\n    this._buffer = null;\n    this.device = device;\n    this.id = opts.id || '';\n    this.size = opts.size || 1;\n    const logicalType = opts.logicalType || opts.type;\n    const doublePrecision = logicalType === 'float64';\n    let {\n      defaultValue\n    } = opts;\n    defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);\n    let bufferType;\n    if (doublePrecision) {\n      bufferType = 'float32';\n    } else if (!logicalType && opts.isIndexed) {\n      bufferType = 'uint32';\n    } else {\n      bufferType = logicalType || 'float32';\n    }\n    // This is the attribute type defined by the layer\n    // If an external buffer is provided, this.type may be overwritten\n    // But we always want to use defaultType for allocation\n    let defaultType = typedArrayFromDataType(logicalType || bufferType);\n    this.doublePrecision = doublePrecision;\n    // `fp64: false` tells a double-precision attribute to allocate Float32Arrays\n    // by default when using auto-packing. This is more efficient in use cases where\n    // high precision is unnecessary, but the `64Low` attribute is still required\n    // by the shader.\n    if (doublePrecision && opts.fp64 === false) {\n      defaultType = Float32Array;\n    }\n    this.value = null;\n    this.settings = {\n      ...opts,\n      defaultType,\n      defaultValue: defaultValue,\n      logicalType,\n      type: bufferType,\n      normalized: bufferType.includes('norm'),\n      size: this.size,\n      bytesPerElement: defaultType.BYTES_PER_ELEMENT\n    };\n    this.state = {\n      ...state,\n      externalBuffer: null,\n      bufferAccessor: this.settings,\n      allocatedValue: null,\n      numInstances: 0,\n      bounds: null,\n      constant: false\n    };\n  }\n  /* eslint-enable max-statements */\n  get isConstant() {\n    return this.state.constant;\n  }\n  get buffer() {\n    return this._buffer;\n  }\n  get byteOffset() {\n    const accessor = this.getAccessor();\n    if (accessor.vertexOffset) {\n      return accessor.vertexOffset * getStride(accessor);\n    }\n    return 0;\n  }\n  get numInstances() {\n    return this.state.numInstances;\n  }\n  set numInstances(n) {\n    this.state.numInstances = n;\n  }\n  delete() {\n    if (this._buffer) {\n      this._buffer.delete();\n      this._buffer = null;\n    }\n    typedArrayManager.release(this.state.allocatedValue);\n  }\n  getBuffer() {\n    if (this.state.constant) {\n      return null;\n    }\n    return this.state.externalBuffer || this._buffer;\n  }\n  getValue() {\n    let attributeName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const result = {};\n    if (this.state.constant) {\n      const value = this.value;\n      if (options) {\n        const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);\n        const offset = shaderAttributeDef.offset / value.BYTES_PER_ELEMENT;\n        const size = shaderAttributeDef.size || this.size;\n        result[attributeName] = value.subarray(offset, offset + size);\n      } else {\n        result[attributeName] = value;\n      }\n    } else {\n      result[attributeName] = this.getBuffer();\n    }\n    if (this.doublePrecision) {\n      if (this.value instanceof Float64Array) {\n        result[`${attributeName}64Low`] = result[attributeName];\n      } else {\n        // Disable fp64 low part\n        result[`${attributeName}64Low`] = new Float32Array(this.size);\n      }\n    }\n    return result;\n  }\n  _getBufferLayout() {\n    let attributeName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const accessor = this.getAccessor();\n    const attributes = [];\n    const result = {\n      name: this.id,\n      byteStride: getStride(accessor),\n      attributes\n    };\n    if (this.doublePrecision) {\n      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(accessor, options || {});\n      attributes.push(getBufferAttributeLayout(attributeName, {\n        ...accessor,\n        ...doubleShaderAttributeDefs.high\n      }, this.device.type), getBufferAttributeLayout(`${attributeName}64Low`, {\n        ...accessor,\n        ...doubleShaderAttributeDefs.low\n      }, this.device.type));\n    } else if (options) {\n      const shaderAttributeDef = resolveShaderAttribute(accessor, options);\n      attributes.push(getBufferAttributeLayout(attributeName, {\n        ...accessor,\n        ...shaderAttributeDef\n      }, this.device.type));\n    } else {\n      attributes.push(getBufferAttributeLayout(attributeName, accessor, this.device.type));\n    }\n    return result;\n  }\n  setAccessor(accessor) {\n    this.state.bufferAccessor = accessor;\n  }\n  getAccessor() {\n    return this.state.bufferAccessor;\n  }\n  // Returns [min: Array(size), max: Array(size)]\n  /* eslint-disable max-depth */\n  getBounds() {\n    if (this.state.bounds) {\n      return this.state.bounds;\n    }\n    let result = null;\n    if (this.state.constant && this.value) {\n      const min = Array.from(this.value);\n      result = [min, min];\n    } else {\n      const {\n        value,\n        numInstances,\n        size\n      } = this;\n      const len = numInstances * size;\n      if (value && len && value.length >= len) {\n        const min = new Array(size).fill(Infinity);\n        const max = new Array(size).fill(-Infinity);\n        for (let i = 0; i < len;) {\n          for (let j = 0; j < size; j++) {\n            const v = value[i++];\n            if (v < min[j]) min[j] = v;\n            if (v > max[j]) max[j] = v;\n          }\n        }\n        result = [min, max];\n      }\n    }\n    this.state.bounds = result;\n    return result;\n  }\n  // returns true if success\n  // eslint-disable-next-line max-statements\n  setData(data) {\n    const {\n      state\n    } = this;\n    let opts;\n    if (ArrayBuffer.isView(data)) {\n      opts = {\n        value: data\n      };\n    } else if (data instanceof Buffer) {\n      opts = {\n        buffer: data\n      };\n    } else {\n      opts = data;\n    }\n    const accessor = {\n      ...this.settings,\n      ...opts\n    };\n    if (ArrayBuffer.isView(opts.value)) {\n      if (!opts.type) {\n        // Deduce data type\n        const is64Bit = this.doublePrecision && opts.value instanceof Float64Array;\n        if (is64Bit) {\n          accessor.type = 'float32';\n        } else {\n          const type = dataTypeFromTypedArray(opts.value);\n          accessor.type = accessor.normalized ? type.replace('int', 'norm') : type;\n        }\n      }\n      accessor.bytesPerElement = opts.value.BYTES_PER_ELEMENT;\n      accessor.stride = getStride(accessor);\n    }\n    state.bounds = null; // clear cached bounds\n    if (opts.constant) {\n      // set constant\n      let value = opts.value;\n      value = this._normalizeValue(value, [], 0);\n      if (this.settings.normalized) {\n        value = this.normalizeConstant(value);\n      }\n      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);\n      if (!hasChanged) {\n        return false;\n      }\n      state.externalBuffer = null;\n      state.constant = true;\n      this.value = ArrayBuffer.isView(value) ? value : new Float32Array(value);\n    } else if (opts.buffer) {\n      const buffer = opts.buffer;\n      state.externalBuffer = buffer;\n      state.constant = false;\n      this.value = opts.value || null;\n    } else if (opts.value) {\n      this._checkExternalBuffer(opts);\n      let value = opts.value;\n      state.externalBuffer = null;\n      state.constant = false;\n      this.value = value;\n      let {\n        buffer\n      } = this;\n      const stride = getStride(accessor);\n      const byteOffset = (accessor.vertexOffset || 0) * stride;\n      if (this.doublePrecision && value instanceof Float64Array) {\n        value = toDoublePrecisionArray(value, accessor);\n      }\n      if (this.settings.isIndexed) {\n        const ArrayType = this.settings.defaultType;\n        if (value.constructor !== ArrayType) {\n          // Cast the index buffer to expected type\n          value = new ArrayType(value);\n        }\n      }\n      // A small over allocation is used as safety margin\n      // Shader attributes may try to access this buffer with bigger offsets\n      const requiredBufferSize = value.byteLength + byteOffset + stride * 2;\n      if (!buffer || buffer.byteLength < requiredBufferSize) {\n        buffer = this._createBuffer(requiredBufferSize);\n      }\n      buffer.write(value, byteOffset);\n    }\n    this.setAccessor(accessor);\n    return true;\n  }\n  updateSubBuffer() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.state.bounds = null; // clear cached bounds\n    const value = this.value;\n    const {\n      startOffset = 0,\n      endOffset\n    } = opts;\n    this.buffer.write(this.doublePrecision && value instanceof Float64Array ? toDoublePrecisionArray(value, {\n      size: this.size,\n      startIndex: startOffset,\n      endIndex: endOffset\n    }) : value.subarray(startOffset, endOffset), startOffset * value.BYTES_PER_ELEMENT + this.byteOffset);\n  }\n  allocate(numInstances) {\n    let copy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      state\n    } = this;\n    const oldValue = state.allocatedValue;\n    // Allocate at least one element to ensure a valid buffer\n    const value = typedArrayManager.allocate(oldValue, numInstances + 1, {\n      size: this.size,\n      type: this.settings.defaultType,\n      copy\n    });\n    this.value = value;\n    const {\n      byteOffset\n    } = this;\n    let {\n      buffer\n    } = this;\n    if (!buffer || buffer.byteLength < value.byteLength + byteOffset) {\n      buffer = this._createBuffer(value.byteLength + byteOffset);\n      if (copy && oldValue) {\n        // Upload the full existing attribute value to the GPU, so that updateBuffer\n        // can choose to only update a partial range.\n        // TODO - copy old buffer to new buffer on the GPU\n        buffer.write(oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue, byteOffset);\n      }\n    }\n    state.allocatedValue = value;\n    state.constant = false;\n    state.externalBuffer = null;\n    this.setAccessor(this.settings);\n    return true;\n  }\n  // PRIVATE HELPER METHODS\n  _checkExternalBuffer(opts) {\n    const {\n      value\n    } = opts;\n    if (!ArrayBuffer.isView(value)) {\n      throw new Error(`Attribute ${this.id} value is not TypedArray`);\n    }\n    const ArrayType = this.settings.defaultType;\n    let illegalArrayType = false;\n    if (this.doublePrecision) {\n      // not 32bit or 64bit\n      illegalArrayType = value.BYTES_PER_ELEMENT < 4;\n    }\n    if (illegalArrayType) {\n      throw new Error(`Attribute ${this.id} does not support ${value.constructor.name}`);\n    }\n    if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {\n      log.warn(`Attribute ${this.id} is normalized`)();\n    }\n  }\n  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n  normalizeConstant(value) {\n    /* eslint-disable complexity */\n    switch (this.settings.type) {\n      case 'snorm8':\n        // normalize [-128, 127] to [-1, 1]\n        return new Float32Array(value).map(x => (x + 128) / 255 * 2 - 1);\n      case 'snorm16':\n        // normalize [-32768, 32767] to [-1, 1]\n        return new Float32Array(value).map(x => (x + 32768) / 65535 * 2 - 1);\n      case 'unorm8':\n        // normalize [0, 255] to [0, 1]\n        return new Float32Array(value).map(x => x / 255);\n      case 'unorm16':\n        // normalize [0, 65535] to [0, 1]\n        return new Float32Array(value).map(x => x / 65535);\n      default:\n        // No normalization for gl.FLOAT and gl.HALF_FLOAT\n        return value;\n    }\n  }\n  /* check user supplied values and apply fallback */\n  _normalizeValue(value, out, start) {\n    const {\n      defaultValue,\n      size\n    } = this.settings;\n    if (Number.isFinite(value)) {\n      out[start] = value;\n      return out;\n    }\n    if (!value) {\n      let i = size;\n      while (--i >= 0) {\n        out[start + i] = defaultValue[i];\n      }\n      return out;\n    }\n    // Important - switch cases are 5x more performant than a for loop!\n    /* eslint-disable no-fallthrough, default-case */\n    switch (size) {\n      case 4:\n        out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];\n      case 3:\n        out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];\n      case 2:\n        out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];\n      case 1:\n        out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];\n        break;\n      default:\n        // In the rare case where the attribute size > 4, do it the slow way\n        // This is used for e.g. transform matrices\n        let i = size;\n        while (--i >= 0) {\n          out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];\n        }\n    }\n    return out;\n  }\n  _areValuesEqual(value1, value2) {\n    if (!value1 || !value2) {\n      return false;\n    }\n    const {\n      size\n    } = this;\n    for (let i = 0; i < size; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _createBuffer(byteLength) {\n    if (this._buffer) {\n      this._buffer.destroy();\n    }\n    const {\n      isIndexed,\n      type\n    } = this.settings;\n    this._buffer = this.device.createBuffer({\n      ...this._buffer?.props,\n      id: this.id,\n      // TODO(ibgreen) - WebGPU requires COPY_DST and COPY_SRC to allow write / read\n      usage: (isIndexed ? Buffer.INDEX : Buffer.VERTEX) | Buffer.COPY_DST,\n      indexType: isIndexed ? type : undefined,\n      byteLength\n    });\n    return this._buffer;\n  }\n}\n//# sourceMappingURL=data-column.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}