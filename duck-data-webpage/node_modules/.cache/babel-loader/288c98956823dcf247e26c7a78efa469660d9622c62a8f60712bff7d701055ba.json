{"ast":null,"code":"import { Vector3 } from '@math.gl/core';\nimport { GL } from \"../constants.js\";\nimport { assert } from \"../utils/assert.js\";\nimport { makePrimitiveIterator } from \"../iterators/primitive-iterator.js\";\nimport { getPrimitiveModeType } from \"../primitives/modes.js\";\nimport { getPositions } from \"./get-attribute-from-geometry.js\";\n/**\n * Computes vertex normals for a geometry\n * @param param0\n * @returns\n */\n// eslint-disable-next-line max-statements\nexport function computeVertexNormals(geometry) {\n  // Only support GL.TRIANGLES, GL.TRIANGLE_STRIP, GL.TRIANGLE_FAN\n  assert(getPrimitiveModeType(geometry.mode) === GL.TRIANGLES, 'TRIANGLES required');\n  const {\n    values: positions\n  } = getPositions(geometry);\n  const normals = new Float32Array(positions.length);\n  const vectorA = new Vector3();\n  const vectorB = new Vector3();\n  const vectorC = new Vector3();\n  const vectorCB = new Vector3();\n  const vectorAB = new Vector3();\n  for (const primitive of makePrimitiveIterator(geometry)) {\n    vectorA.fromArray(positions, primitive.i1 * 3);\n    vectorB.fromArray(positions, primitive.i2 * 3 + 3);\n    vectorC.fromArray(positions, primitive.i3 * 3 + 6);\n    vectorCB.subVectors(vectorC, vectorB);\n    vectorAB.subVectors(vectorA, vectorB);\n    const normal = vectorCB.cross(vectorAB);\n    normal.normalize();\n    // @ts-ignore\n    const {\n      primitiveIndex\n    } = primitive;\n    normals[primitiveIndex * 9 + 0] = normal.x;\n    normals[primitiveIndex * 9 + 1] = normal.y;\n    normals[primitiveIndex * 9 + 2] = normal.z;\n    normals[primitiveIndex * 9 + 3] = normal.x;\n    normals[primitiveIndex * 9 + 4] = normal.y;\n    normals[primitiveIndex * 9 + 5] = normal.z;\n    normals[primitiveIndex * 9 + 6] = normal.x;\n    normals[primitiveIndex * 9 + 7] = normal.y;\n    normals[primitiveIndex * 9 + 8] = normal.z;\n  }\n  return normals;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}