{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { concatenateArrayBuffersAsync } from '@loaders.gl/loader-utils';\nimport { isResponse, isReadableStream, isAsyncIterable, isIterable, isIterator, isBlob, isBuffer } from \"../../javascript-utils/is-type.js\";\nimport { makeIterator } from \"../../iterators/make-iterator/make-iterator.js\";\nimport { checkResponse, makeResponse } from \"../utils/response-utils.js\";\nconst ERR_DATA = 'Cannot convert supplied data type';\n// eslint-disable-next-line complexity\nexport function getArrayBufferOrStringFromDataSync(data, loader, options) {\n  if (loader.text && typeof data === 'string') {\n    return data;\n  }\n  if (isBuffer(data)) {\n    // @ts-ignore\n    data = data.buffer;\n  }\n  if (data instanceof ArrayBuffer) {\n    const arrayBuffer = data;\n    if (loader.text && !loader.binary) {\n      const textDecoder = new TextDecoder('utf8');\n      return textDecoder.decode(arrayBuffer);\n    }\n    return arrayBuffer;\n  }\n  // We may need to handle offsets\n  if (ArrayBuffer.isView(data)) {\n    // TextDecoder is invoked on typed arrays and will handle offsets\n    if (loader.text && !loader.binary) {\n      const textDecoder = new TextDecoder('utf8');\n      return textDecoder.decode(data);\n    }\n    let arrayBuffer = data.buffer;\n    // Since we are returning the underlying arrayBuffer, we must create a new copy\n    // if this typed array / Buffer is a partial view into the ArryayBuffer\n    // TODO - this is a potentially unnecessary copy\n    const byteLength = data.byteLength || data.length;\n    if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {\n      // console.warn(`loaders.gl copying arraybuffer of length ${byteLength}`);\n      arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);\n    }\n    return arrayBuffer;\n  }\n  throw new Error(ERR_DATA);\n}\n// Convert async iterator to a promise\nexport async function getArrayBufferOrStringFromData(data, loader, options) {\n  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);\n  if (typeof data === 'string' || isArrayBuffer) {\n    return getArrayBufferOrStringFromDataSync(data, loader, options);\n  }\n  // Blobs and files are FileReader compatible\n  if (isBlob(data)) {\n    data = await makeResponse(data);\n  }\n  if (isResponse(data)) {\n    const response = data;\n    await checkResponse(response);\n    return loader.binary ? await response.arrayBuffer() : await response.text();\n  }\n  if (isReadableStream(data)) {\n    // @ts-expect-error TS2559 options type\n    data = makeIterator(data, options);\n  }\n  if (isIterable(data) || isAsyncIterable(data)) {\n    // Assume arrayBuffer iterator - attempt to concatenate\n    return concatenateArrayBuffersAsync(data);\n  }\n  throw new Error(ERR_DATA);\n}\nexport async function getAsyncIterableFromData(data, options) {\n  if (isIterator(data)) {\n    return data;\n  }\n  if (isResponse(data)) {\n    const response = data;\n    // Note Since this function is not async, we currently can't load error message, just status\n    await checkResponse(response);\n    // TODO - bug in polyfill, body can be a Promise under Node.js\n    // eslint-disable-next-line @typescript-eslint/await-thenable\n    const body = await response.body;\n    // TODO - body can be null?\n    return makeIterator(body, options);\n  }\n  if (isBlob(data) || isReadableStream(data)) {\n    return makeIterator(data, options);\n  }\n  if (isAsyncIterable(data)) {\n    return data;\n  }\n  return getIterableFromData(data);\n}\nexport async function getReadableStream(data) {\n  if (isReadableStream(data)) {\n    return data;\n  }\n  if (isResponse(data)) {\n    // @ts-ignore\n    return data.body;\n  }\n  const response = await makeResponse(data);\n  // @ts-ignore\n  return response.body;\n}\n// HELPERS\nfunction getIterableFromData(data) {\n  // generate an iterator that emits a single chunk\n  if (ArrayBuffer.isView(data)) {\n    return function* oneChunk() {\n      yield data.buffer;\n    }();\n  }\n  if (data instanceof ArrayBuffer) {\n    return function* oneChunk() {\n      yield data;\n    }();\n  }\n  if (isIterator(data)) {\n    return data;\n  }\n  if (isIterable(data)) {\n    return data[Symbol.iterator]();\n  }\n  throw new Error(ERR_DATA);\n}","map":{"version":3,"names":["concatenateArrayBuffersAsync","isResponse","isReadableStream","isAsyncIterable","isIterable","isIterator","isBlob","isBuffer","makeIterator","checkResponse","makeResponse","ERR_DATA","getArrayBufferOrStringFromDataSync","data","loader","options","text","buffer","ArrayBuffer","arrayBuffer","binary","textDecoder","TextDecoder","decode","isView","byteLength","length","byteOffset","slice","Error","getArrayBufferOrStringFromData","isArrayBuffer","response","getAsyncIterableFromData","body","getIterableFromData","getReadableStream","oneChunk","Symbol","iterator"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/core/dist/lib/loader-utils/get-data.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { concatenateArrayBuffersAsync } from '@loaders.gl/loader-utils';\nimport { isResponse, isReadableStream, isAsyncIterable, isIterable, isIterator, isBlob, isBuffer } from \"../../javascript-utils/is-type.js\";\nimport { makeIterator } from \"../../iterators/make-iterator/make-iterator.js\";\nimport { checkResponse, makeResponse } from \"../utils/response-utils.js\";\nconst ERR_DATA = 'Cannot convert supplied data type';\n// eslint-disable-next-line complexity\nexport function getArrayBufferOrStringFromDataSync(data, loader, options) {\n    if (loader.text && typeof data === 'string') {\n        return data;\n    }\n    if (isBuffer(data)) {\n        // @ts-ignore\n        data = data.buffer;\n    }\n    if (data instanceof ArrayBuffer) {\n        const arrayBuffer = data;\n        if (loader.text && !loader.binary) {\n            const textDecoder = new TextDecoder('utf8');\n            return textDecoder.decode(arrayBuffer);\n        }\n        return arrayBuffer;\n    }\n    // We may need to handle offsets\n    if (ArrayBuffer.isView(data)) {\n        // TextDecoder is invoked on typed arrays and will handle offsets\n        if (loader.text && !loader.binary) {\n            const textDecoder = new TextDecoder('utf8');\n            return textDecoder.decode(data);\n        }\n        let arrayBuffer = data.buffer;\n        // Since we are returning the underlying arrayBuffer, we must create a new copy\n        // if this typed array / Buffer is a partial view into the ArryayBuffer\n        // TODO - this is a potentially unnecessary copy\n        const byteLength = data.byteLength || data.length;\n        if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {\n            // console.warn(`loaders.gl copying arraybuffer of length ${byteLength}`);\n            arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);\n        }\n        return arrayBuffer;\n    }\n    throw new Error(ERR_DATA);\n}\n// Convert async iterator to a promise\nexport async function getArrayBufferOrStringFromData(data, loader, options) {\n    const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);\n    if (typeof data === 'string' || isArrayBuffer) {\n        return getArrayBufferOrStringFromDataSync(data, loader, options);\n    }\n    // Blobs and files are FileReader compatible\n    if (isBlob(data)) {\n        data = await makeResponse(data);\n    }\n    if (isResponse(data)) {\n        const response = data;\n        await checkResponse(response);\n        return loader.binary ? await response.arrayBuffer() : await response.text();\n    }\n    if (isReadableStream(data)) {\n        // @ts-expect-error TS2559 options type\n        data = makeIterator(data, options);\n    }\n    if (isIterable(data) || isAsyncIterable(data)) {\n        // Assume arrayBuffer iterator - attempt to concatenate\n        return concatenateArrayBuffersAsync(data);\n    }\n    throw new Error(ERR_DATA);\n}\nexport async function getAsyncIterableFromData(data, options) {\n    if (isIterator(data)) {\n        return data;\n    }\n    if (isResponse(data)) {\n        const response = data;\n        // Note Since this function is not async, we currently can't load error message, just status\n        await checkResponse(response);\n        // TODO - bug in polyfill, body can be a Promise under Node.js\n        // eslint-disable-next-line @typescript-eslint/await-thenable\n        const body = await response.body;\n        // TODO - body can be null?\n        return makeIterator(body, options);\n    }\n    if (isBlob(data) || isReadableStream(data)) {\n        return makeIterator(data, options);\n    }\n    if (isAsyncIterable(data)) {\n        return data;\n    }\n    return getIterableFromData(data);\n}\nexport async function getReadableStream(data) {\n    if (isReadableStream(data)) {\n        return data;\n    }\n    if (isResponse(data)) {\n        // @ts-ignore\n        return data.body;\n    }\n    const response = await makeResponse(data);\n    // @ts-ignore\n    return response.body;\n}\n// HELPERS\nfunction getIterableFromData(data) {\n    // generate an iterator that emits a single chunk\n    if (ArrayBuffer.isView(data)) {\n        return (function* oneChunk() {\n            yield data.buffer;\n        })();\n    }\n    if (data instanceof ArrayBuffer) {\n        return (function* oneChunk() {\n            yield data;\n        })();\n    }\n    if (isIterator(data)) {\n        return data;\n    }\n    if (isIterable(data)) {\n        return data[Symbol.iterator]();\n    }\n    throw new Error(ERR_DATA);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}