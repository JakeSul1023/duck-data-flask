{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@luma.gl/core';\n// Rename constant to prevent inlining. We need the full set of constants for generating debug strings.\nimport { GL as GLEnum } from '@luma.gl/constants';\nimport { isBrowser } from '@probe.gl/env';\nimport { loadScript } from \"../../utils/load-script.js\";\nconst WEBGL_DEBUG_CDN_URL = 'https://unpkg.com/webgl-debug@2.0.1/index.js';\n// Helper to get shared context data\nfunction getWebGLContextData(gl) {\n  gl.luma = gl.luma || {};\n  return gl.luma;\n}\n/**\n * Loads Khronos WebGLDeveloperTools from CDN if not already installed\n * const WebGLDebugUtils = require('webgl-debug');\n * @see https://github.com/KhronosGroup/WebGLDeveloperTools\n * @see https://github.com/vorg/webgl-debug\n */\nexport async function loadWebGLDeveloperTools() {\n  if (isBrowser() && !globalThis.WebGLDebugUtils) {\n    globalThis.global = globalThis.global || globalThis;\n    // @ts-expect-error Developer tools expects global to be set\n    globalThis.global.module = {};\n    await loadScript(WEBGL_DEBUG_CDN_URL);\n  }\n}\n// Returns (a potentially new) context with debug instrumentation turned off or on.\n// Note that this actually returns a new context\nexport function makeDebugContext(gl, props = {}) {\n  return props.debugWebGL || props.traceWebGL ? getDebugContext(gl, props) : getRealContext(gl);\n}\n// Returns the real context from either of the real/debug contexts\nfunction getRealContext(gl) {\n  const data = getWebGLContextData(gl);\n  // If the context has a realContext member, it is a debug context so return the realContext\n  return data.realContext ? data.realContext : gl;\n}\n// Returns the debug context from either of the real/debug contexts\nfunction getDebugContext(gl, props) {\n  if (!globalThis.WebGLDebugUtils) {\n    log.warn('webgl-debug not loaded')();\n    return gl;\n  }\n  const data = getWebGLContextData(gl);\n  // If this already has a debug context, return it.\n  if (data.debugContext) {\n    return data.debugContext;\n  }\n  // Create a new debug context\n  globalThis.WebGLDebugUtils.init({\n    ...GLEnum,\n    ...gl\n  });\n  const glDebug = globalThis.WebGLDebugUtils.makeDebugContext(gl, onGLError.bind(null, props), onValidateGLFunc.bind(null, props));\n  // Make sure we have all WebGL2 and extension constants (todo dynamic import to circumvent minification?)\n  for (const key in GLEnum) {\n    if (!(key in glDebug) && typeof GLEnum[key] === 'number') {\n      glDebug[key] = GLEnum[key];\n    }\n  }\n  // Ensure we have a clean prototype on the instrumented object\n  // Note: setPrototypeOf does come with perf warnings, but we already take a bigger perf reduction\n  // by synchronizing the WebGL errors after each WebGL call.\n  class WebGLDebugContext {}\n  Object.setPrototypeOf(glDebug, Object.getPrototypeOf(gl));\n  Object.setPrototypeOf(WebGLDebugContext, glDebug);\n  const debugContext = Object.create(WebGLDebugContext);\n  // Store the debug context\n  data.realContext = gl;\n  data.debugContext = debugContext;\n  debugContext.debug = true;\n  // Return it\n  return debugContext;\n}\n// DEBUG TRACING\nfunction getFunctionString(functionName, functionArgs) {\n  // Cover bug in webgl-debug-tools\n  functionArgs = Array.from(functionArgs).map(arg => arg === undefined ? 'undefined' : arg);\n  let args = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, functionArgs);\n  args = `${args.slice(0, 100)}${args.length > 100 ? '...' : ''}`;\n  return `gl.${functionName}(${args})`;\n}\nfunction onGLError(props, err, functionName, args) {\n  // Cover bug in webgl-debug-tools\n  args = Array.from(args).map(arg => arg === undefined ? 'undefined' : arg);\n  const errorMessage = globalThis.WebGLDebugUtils.glEnumToString(err);\n  const functionArgs = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, args);\n  const message = `${errorMessage} in gl.${functionName}(${functionArgs})`;\n  log.error(message)();\n  debugger; // eslint-disable-line\n  // throw new Error(message);\n}\n// Don't generate function string until it is needed\nfunction onValidateGLFunc(props, functionName, functionArgs) {\n  let functionString = '';\n  if (log.level >= 1) {\n    functionString = getFunctionString(functionName, functionArgs);\n    if (props.traceWebGL) {\n      log.log(1, functionString)();\n    }\n  }\n  for (const arg of functionArgs) {\n    if (arg === undefined) {\n      functionString = functionString || getFunctionString(functionName, functionArgs);\n      debugger; // eslint-disable-line\n      // throw new Error(`Undefined argument: ${functionString}`);\n    }\n  }\n}\n//# sourceMappingURL=webgl-developer-tools.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}