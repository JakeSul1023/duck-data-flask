{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* global document */\nimport TinySDF from '@mapbox/tiny-sdf';\nimport { log } from '@deck.gl/core';\nimport { buildMapping } from \"./utils.js\";\nimport LRUCache from \"./lru-cache.js\";\n// import type {Texture} from '@deck.gl/core';\nfunction getDefaultCharacterSet() {\n  const charSet = [];\n  for (let i = 32; i < 128; i++) {\n    charSet.push(String.fromCharCode(i));\n  }\n  return charSet;\n}\nexport const DEFAULT_FONT_SETTINGS = {\n  fontFamily: 'Monaco, monospace',\n  fontWeight: 'normal',\n  characterSet: getDefaultCharacterSet(),\n  fontSize: 64,\n  buffer: 4,\n  sdf: false,\n  cutoff: 0.25,\n  radius: 12,\n  smoothing: 0.1\n};\nconst MAX_CANVAS_WIDTH = 1024;\nconst BASELINE_SCALE = 0.9;\nconst HEIGHT_SCALE = 1.2;\n// only preserve latest three fontAtlas\nconst CACHE_LIMIT = 3;\nlet cache = new LRUCache(CACHE_LIMIT);\n/**\n * get all the chars not in cache\n * @returns chars not in cache\n */\nfunction getNewChars(cacheKey, characterSet) {\n  let newCharSet;\n  if (typeof characterSet === 'string') {\n    newCharSet = new Set(Array.from(characterSet));\n  } else {\n    newCharSet = new Set(characterSet);\n  }\n  const cachedFontAtlas = cache.get(cacheKey);\n  if (!cachedFontAtlas) {\n    return newCharSet;\n  }\n  for (const char in cachedFontAtlas.mapping) {\n    if (newCharSet.has(char)) {\n      newCharSet.delete(char);\n    }\n  }\n  return newCharSet;\n}\nfunction populateAlphaChannel(alphaChannel, imageData) {\n  // populate distance value from tinySDF to image alpha channel\n  for (let i = 0; i < alphaChannel.length; i++) {\n    imageData.data[4 * i + 3] = alphaChannel[i];\n  }\n}\nfunction setTextStyle(ctx, fontFamily, fontSize, fontWeight) {\n  ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;\n  ctx.fillStyle = '#000';\n  ctx.textBaseline = 'alphabetic';\n  ctx.textAlign = 'left';\n}\n/**\n * Sets the Font Atlas LRU Cache Limit\n * @param {number} limit LRU Cache limit\n */\nexport function setFontAtlasCacheLimit(limit) {\n  log.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, 'Invalid cache limit');\n  cache = new LRUCache(limit);\n}\nexport default class FontAtlasManager {\n  constructor() {\n    /** Font settings */\n    this.props = {\n      ...DEFAULT_FONT_SETTINGS\n    };\n  }\n  get atlas() {\n    return this._atlas;\n  }\n  // TODO - cut during v9 porting as types reveal this is not correct\n  // get texture(): Texture | undefined {\n  //   return this._atlas;\n  // }\n  get mapping() {\n    return this._atlas && this._atlas.mapping;\n  }\n  get scale() {\n    const {\n      fontSize,\n      buffer\n    } = this.props;\n    return (fontSize * HEIGHT_SCALE + buffer * 2) / fontSize;\n  }\n  setProps(props = {}) {\n    Object.assign(this.props, props);\n    // update cache key\n    this._key = this._getKey();\n    const charSet = getNewChars(this._key, this.props.characterSet);\n    const cachedFontAtlas = cache.get(this._key);\n    // if a fontAtlas associated with the new settings is cached and\n    // there are no new chars\n    if (cachedFontAtlas && charSet.size === 0) {\n      // update texture with cached fontAtlas\n      if (this._atlas !== cachedFontAtlas) {\n        this._atlas = cachedFontAtlas;\n      }\n      return;\n    }\n    // update fontAtlas with new settings\n    const fontAtlas = this._generateFontAtlas(charSet, cachedFontAtlas);\n    this._atlas = fontAtlas;\n    // update cache\n    cache.set(this._key, fontAtlas);\n  }\n  // eslint-disable-next-line max-statements\n  _generateFontAtlas(characterSet, cachedFontAtlas) {\n    const {\n      fontFamily,\n      fontWeight,\n      fontSize,\n      buffer,\n      sdf,\n      radius,\n      cutoff\n    } = this.props;\n    let canvas = cachedFontAtlas && cachedFontAtlas.data;\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      canvas.width = MAX_CANVAS_WIDTH;\n    }\n    const ctx = canvas.getContext('2d', {\n      willReadFrequently: true\n    });\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n    // 1. build mapping\n    const {\n      mapping,\n      canvasHeight,\n      xOffset,\n      yOffset\n    } = buildMapping({\n      getFontWidth: char => ctx.measureText(char).width,\n      fontHeight: fontSize * HEIGHT_SCALE,\n      buffer,\n      characterSet,\n      maxCanvasWidth: MAX_CANVAS_WIDTH,\n      ...(cachedFontAtlas && {\n        mapping: cachedFontAtlas.mapping,\n        xOffset: cachedFontAtlas.xOffset,\n        yOffset: cachedFontAtlas.yOffset\n      })\n    });\n    // 2. update canvas\n    // copy old canvas data to new canvas only when height changed\n    if (canvas.height !== canvasHeight) {\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      canvas.height = canvasHeight;\n      ctx.putImageData(imageData, 0, 0);\n    }\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n    // 3. layout characters\n    if (sdf) {\n      const tinySDF = new TinySDF({\n        fontSize,\n        buffer,\n        radius,\n        cutoff,\n        fontFamily,\n        fontWeight: `${fontWeight}`\n      });\n      for (const char of characterSet) {\n        const {\n          data,\n          width,\n          height,\n          glyphTop\n        } = tinySDF.draw(char);\n        mapping[char].width = width;\n        mapping[char].layoutOffsetY = fontSize * BASELINE_SCALE - glyphTop;\n        const imageData = ctx.createImageData(width, height);\n        populateAlphaChannel(data, imageData);\n        ctx.putImageData(imageData, mapping[char].x, mapping[char].y);\n      }\n    } else {\n      for (const char of characterSet) {\n        ctx.fillText(char, mapping[char].x, mapping[char].y + buffer + fontSize * BASELINE_SCALE);\n      }\n    }\n    return {\n      xOffset,\n      yOffset,\n      mapping,\n      data: canvas,\n      width: canvas.width,\n      height: canvas.height\n    };\n  }\n  _getKey() {\n    const {\n      fontFamily,\n      fontWeight,\n      fontSize,\n      buffer,\n      sdf,\n      radius,\n      cutoff\n    } = this.props;\n    if (sdf) {\n      return `${fontFamily} ${fontWeight} ${fontSize} ${buffer} ${radius} ${cutoff}`;\n    }\n    return `${fontFamily} ${fontWeight} ${fontSize} ${buffer}`;\n  }\n}","map":{"version":3,"names":["TinySDF","log","buildMapping","LRUCache","getDefaultCharacterSet","charSet","i","push","String","fromCharCode","DEFAULT_FONT_SETTINGS","fontFamily","fontWeight","characterSet","fontSize","buffer","sdf","cutoff","radius","smoothing","MAX_CANVAS_WIDTH","BASELINE_SCALE","HEIGHT_SCALE","CACHE_LIMIT","cache","getNewChars","cacheKey","newCharSet","Set","Array","from","cachedFontAtlas","get","char","mapping","has","delete","populateAlphaChannel","alphaChannel","imageData","length","data","setTextStyle","ctx","font","fillStyle","textBaseline","textAlign","setFontAtlasCacheLimit","limit","assert","Number","isFinite","FontAtlasManager","constructor","props","atlas","_atlas","scale","setProps","Object","assign","_key","_getKey","size","fontAtlas","_generateFontAtlas","set","canvas","document","createElement","width","getContext","willReadFrequently","canvasHeight","xOffset","yOffset","getFontWidth","measureText","fontHeight","maxCanvasWidth","height","getImageData","putImageData","tinySDF","glyphTop","draw","layoutOffsetY","createImageData","x","y","fillText"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\layers\\src\\text-layer\\font-atlas-manager.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* global document */\nimport TinySDF from '@mapbox/tiny-sdf';\n\nimport {log} from '@deck.gl/core';\n\nimport {buildMapping, CharacterMapping} from './utils';\nimport LRUCache from './lru-cache';\n\n// import type {Texture} from '@deck.gl/core';\n\nfunction getDefaultCharacterSet() {\n  const charSet: string[] = [];\n  for (let i = 32; i < 128; i++) {\n    charSet.push(String.fromCharCode(i));\n  }\n  return charSet;\n}\n\nexport type FontSettings = {\n  /** CSS font family\n   * @default 'Monaco, monospace'\n   */\n  fontFamily?: string;\n  /** CSS font weight\n   * @default 'normal'\n   */\n  fontWeight?: string | number;\n  /** Specifies a list of characters to include in the font.\n   * @default (ASCII characters 32-128)\n   */\n  characterSet?: Set<string> | string[] | string;\n  /** Font size in pixels. This option is only applied for generating `fontAtlas`, it does not impact the size of displayed text labels. Larger `fontSize` will give you a sharper look when rendering text labels with very large font sizes. But larger `fontSize` requires more time and space to generate the `fontAtlas`.\n   * @default 64\n   */\n  fontSize?: number;\n  /** Whitespace buffer around each side of the character. In general, bigger `fontSize` requires bigger `buffer`. Increase `buffer` will add more space between each character when layout `characterSet` in `fontAtlas`. This option could be tuned to provide sufficient space for drawing each character and avoiding overlapping of neighboring characters.\n   * @default 4\n   */\n  buffer?: number;\n  /** Flag to enable / disable `sdf`. [`sdf` (Signed Distance Fields)](http://cs.brown.edu/people/pfelzens/papers/dt-final.pdf) will provide a sharper look when rendering with very large or small font sizes. `TextLayer` integrates with [`TinySDF`](https://github.com/mapbox/tiny-sdf) which implements the `sdf` algorithm.\n   * @default false\n   */\n  sdf?: boolean;\n  /** How much of the radius (relative) is used for the inside part the glyph. Bigger `cutoff` makes character thinner. Smaller `cutoff` makes character look thicker. Only applies when `sdf: true`.\n   * @default 0.25\n   */\n  cutoff?: number;\n  /** How many pixels around the glyph shape to use for encoding distance. Bigger radius yields higher quality outcome. Only applies when `sdf: true`.\n   * @default 12\n   */\n  radius?: number;\n  /** How much smoothing to apply to the text edges. Only applies when `sdf: true`.\n   * @default 0.1\n   */\n  smoothing?: number;\n};\n\nexport const DEFAULT_FONT_SETTINGS: Required<FontSettings> = {\n  fontFamily: 'Monaco, monospace',\n  fontWeight: 'normal',\n  characterSet: getDefaultCharacterSet(),\n  fontSize: 64,\n  buffer: 4,\n  sdf: false,\n  cutoff: 0.25,\n  radius: 12,\n  smoothing: 0.1\n};\n\nconst MAX_CANVAS_WIDTH = 1024;\n\nconst BASELINE_SCALE = 0.9;\nconst HEIGHT_SCALE = 1.2;\n\n// only preserve latest three fontAtlas\nconst CACHE_LIMIT = 3;\n\ntype FontAtlas = {\n  /** x position of last character in mapping */\n  xOffset: number;\n  /** y position of last character in mapping */\n  yOffset: number;\n  /** bounding box of each character in the texture */\n  mapping: CharacterMapping;\n  /** packed texture */\n  data: HTMLCanvasElement;\n  /** texture width */\n  width: number;\n  /** texture height */\n  height: number;\n};\n\nlet cache = new LRUCache<FontAtlas>(CACHE_LIMIT);\n\n/**\n * get all the chars not in cache\n * @returns chars not in cache\n */\nfunction getNewChars(cacheKey: string, characterSet: Set<string> | string[] | string): Set<string> {\n  let newCharSet: Set<string>;\n  if (typeof characterSet === 'string') {\n    newCharSet = new Set(Array.from(characterSet));\n  } else {\n    newCharSet = new Set(characterSet);\n  }\n\n  const cachedFontAtlas = cache.get(cacheKey);\n  if (!cachedFontAtlas) {\n    return newCharSet;\n  }\n\n  for (const char in cachedFontAtlas.mapping) {\n    if (newCharSet.has(char)) {\n      newCharSet.delete(char);\n    }\n  }\n  return newCharSet;\n}\n\nfunction populateAlphaChannel(alphaChannel: Uint8ClampedArray, imageData: ImageData): void {\n  // populate distance value from tinySDF to image alpha channel\n  for (let i = 0; i < alphaChannel.length; i++) {\n    imageData.data[4 * i + 3] = alphaChannel[i];\n  }\n}\n\nfunction setTextStyle(\n  ctx: CanvasRenderingContext2D,\n  fontFamily: string,\n  fontSize: number,\n  fontWeight: string | number\n): void {\n  ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;\n  ctx.fillStyle = '#000';\n  ctx.textBaseline = 'alphabetic';\n  ctx.textAlign = 'left';\n}\n\n/**\n * Sets the Font Atlas LRU Cache Limit\n * @param {number} limit LRU Cache limit\n */\nexport function setFontAtlasCacheLimit(limit: number): void {\n  log.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, 'Invalid cache limit');\n\n  cache = new LRUCache(limit);\n}\n\nexport default class FontAtlasManager {\n  /** Font settings */\n  props: Required<FontSettings> = {...DEFAULT_FONT_SETTINGS};\n\n  /** Cache key of the current font atlas */\n  private _key?: string;\n  /** The current font atlas */\n  private _atlas?: FontAtlas;\n\n  get atlas(): Readonly<FontAtlas> | undefined {\n    return this._atlas;\n  }\n\n  // TODO - cut during v9 porting as types reveal this is not correct\n  // get texture(): Texture | undefined {\n  //   return this._atlas;\n  // }\n\n  get mapping(): CharacterMapping | undefined {\n    return this._atlas && this._atlas.mapping;\n  }\n\n  get scale(): number {\n    const {fontSize, buffer} = this.props;\n    return (fontSize * HEIGHT_SCALE + buffer * 2) / fontSize;\n  }\n\n  setProps(props: FontSettings = {}) {\n    Object.assign(this.props, props);\n\n    // update cache key\n    this._key = this._getKey();\n\n    const charSet = getNewChars(this._key, this.props.characterSet);\n    const cachedFontAtlas = cache.get(this._key);\n\n    // if a fontAtlas associated with the new settings is cached and\n    // there are no new chars\n    if (cachedFontAtlas && charSet.size === 0) {\n      // update texture with cached fontAtlas\n      if (this._atlas !== cachedFontAtlas) {\n        this._atlas = cachedFontAtlas;\n      }\n      return;\n    }\n\n    // update fontAtlas with new settings\n    const fontAtlas = this._generateFontAtlas(charSet, cachedFontAtlas);\n    this._atlas = fontAtlas;\n\n    // update cache\n    cache.set(this._key, fontAtlas);\n  }\n\n  // eslint-disable-next-line max-statements\n  private _generateFontAtlas(characterSet: Set<string>, cachedFontAtlas?: FontAtlas): FontAtlas {\n    const {fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff} = this.props;\n    let canvas = cachedFontAtlas && cachedFontAtlas.data;\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      canvas.width = MAX_CANVAS_WIDTH;\n    }\n    const ctx = canvas.getContext('2d', {willReadFrequently: true})!;\n\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    // 1. build mapping\n    const {mapping, canvasHeight, xOffset, yOffset} = buildMapping({\n      getFontWidth: char => ctx.measureText(char).width,\n      fontHeight: fontSize * HEIGHT_SCALE,\n      buffer,\n      characterSet,\n      maxCanvasWidth: MAX_CANVAS_WIDTH,\n      ...(cachedFontAtlas && {\n        mapping: cachedFontAtlas.mapping,\n        xOffset: cachedFontAtlas.xOffset,\n        yOffset: cachedFontAtlas.yOffset\n      })\n    });\n\n    // 2. update canvas\n    // copy old canvas data to new canvas only when height changed\n    if (canvas.height !== canvasHeight) {\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      canvas.height = canvasHeight;\n      ctx.putImageData(imageData, 0, 0);\n    }\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    // 3. layout characters\n    if (sdf) {\n      const tinySDF = new TinySDF({\n        fontSize,\n        buffer,\n        radius,\n        cutoff,\n        fontFamily,\n        fontWeight: `${fontWeight}`\n      });\n\n      for (const char of characterSet) {\n        const {data, width, height, glyphTop} = tinySDF.draw(char);\n        mapping[char].width = width;\n        mapping[char].layoutOffsetY = fontSize * BASELINE_SCALE - glyphTop;\n\n        const imageData = ctx.createImageData(width, height);\n        populateAlphaChannel(data, imageData);\n        ctx.putImageData(imageData, mapping[char].x, mapping[char].y);\n      }\n    } else {\n      for (const char of characterSet) {\n        ctx.fillText(char, mapping[char].x, mapping[char].y + buffer + fontSize * BASELINE_SCALE);\n      }\n    }\n\n    return {\n      xOffset,\n      yOffset,\n      mapping,\n      data: canvas,\n      width: canvas.width,\n      height: canvas.height\n    };\n  }\n\n  private _getKey(): string {\n    const {fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff} = this.props;\n    if (sdf) {\n      return `${fontFamily} ${fontWeight} ${fontSize} ${buffer} ${radius} ${cutoff}`;\n    }\n    return `${fontFamily} ${fontWeight} ${fontSize} ${buffer}`;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}