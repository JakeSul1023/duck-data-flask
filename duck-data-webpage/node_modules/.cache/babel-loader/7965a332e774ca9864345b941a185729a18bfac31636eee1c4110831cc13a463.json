{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Copyright (C) 2018-2019 HERE Europe B.V.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nconst QUANTIZED_MESH_HEADER = new Map([['centerX', Float64Array.BYTES_PER_ELEMENT], ['centerY', Float64Array.BYTES_PER_ELEMENT], ['centerZ', Float64Array.BYTES_PER_ELEMENT], ['minHeight', Float32Array.BYTES_PER_ELEMENT], ['maxHeight', Float32Array.BYTES_PER_ELEMENT], ['boundingSphereCenterX', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereCenterY', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereCenterZ', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereRadius', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointX', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointY', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointZ', Float64Array.BYTES_PER_ELEMENT]]);\nfunction decodeZigZag(value) {\n  return value >> 1 ^ -(value & 1);\n}\nfunction decodeHeader(dataView) {\n  let position = 0;\n  const header = {};\n  for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {\n    const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;\n    header[key] = getter.call(dataView, position, true);\n    position += bytesCount;\n  }\n  return {\n    header,\n    headerEndPosition: position\n  };\n}\nfunction decodeVertexData(dataView, headerEndPosition) {\n  let position = headerEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = dataView.getUint32(position, true);\n  const vertexData = new Uint16Array(vertexCount * elementsPerVertex);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;\n  const elementArrayLength = vertexCount * bytesPerArrayElement;\n  const uArrayStartPosition = position;\n  const vArrayStartPosition = uArrayStartPosition + elementArrayLength;\n  const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;\n  let u = 0;\n  let v = 0;\n  let height = 0;\n  for (let i = 0; i < vertexCount; i++) {\n    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));\n    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));\n    height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true));\n    vertexData[i] = u;\n    vertexData[i + vertexCount] = v;\n    vertexData[i + vertexCount * 2] = height;\n  }\n  position += elementArrayLength * 3;\n  return {\n    vertexData,\n    vertexDataEndPosition: position\n  };\n}\nfunction decodeIndex(buffer, position, indicesCount, bytesPerIndex, encoded = true) {\n  let indices;\n  if (bytesPerIndex === 2) {\n    indices = new Uint16Array(buffer, position, indicesCount);\n  } else {\n    indices = new Uint32Array(buffer, position, indicesCount);\n  }\n  if (!encoded) {\n    return indices;\n  }\n  let highest = 0;\n  for (let i = 0; i < indices.length; ++i) {\n    const code = indices[i];\n    indices[i] = highest - code;\n    if (code === 0) {\n      ++highest;\n    }\n  }\n  return indices;\n}\nfunction decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {\n  let position = vertexDataEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n  if (position % bytesPerIndex !== 0) {\n    position += bytesPerIndex - position % bytesPerIndex;\n  }\n  const triangleCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  const triangleIndicesCount = triangleCount * 3;\n  const triangleIndices = decodeIndex(dataView.buffer, position, triangleIndicesCount, bytesPerIndex);\n  position += triangleIndicesCount * bytesPerIndex;\n  return {\n    triangleIndicesEndPosition: position,\n    triangleIndices\n  };\n}\nfunction decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {\n  let position = triangleIndicesEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n  const westVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);\n  position += westVertexCount * bytesPerIndex;\n  const southVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  const southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false);\n  position += southVertexCount * bytesPerIndex;\n  const eastVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);\n  position += eastVertexCount * bytesPerIndex;\n  const northVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  const northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false);\n  position += northVertexCount * bytesPerIndex;\n  return {\n    edgeIndicesEndPosition: position,\n    westIndices,\n    southIndices,\n    eastIndices,\n    northIndices\n  };\n}\nfunction decodeVertexNormalsExtension(extensionDataView) {\n  return new Uint8Array(extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength);\n}\nfunction decodeWaterMaskExtension(extensionDataView) {\n  return extensionDataView.buffer.slice(extensionDataView.byteOffset, extensionDataView.byteOffset + extensionDataView.byteLength);\n}\nfunction decodeExtensions(dataView, indicesEndPosition) {\n  const extensions = {};\n  if (dataView.byteLength <= indicesEndPosition) {\n    return {\n      extensions,\n      extensionsEndPosition: indicesEndPosition\n    };\n  }\n  let position = indicesEndPosition;\n  while (position < dataView.byteLength) {\n    const extensionId = dataView.getUint8(position, true);\n    position += Uint8Array.BYTES_PER_ELEMENT;\n    const extensionLength = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    const extensionView = new DataView(dataView.buffer, position, extensionLength);\n    switch (extensionId) {\n      case 1:\n        {\n          extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);\n          break;\n        }\n      case 2:\n        {\n          extensions.waterMask = decodeWaterMaskExtension(extensionView);\n          break;\n        }\n      default:\n        {\n          // console.warn(`Unknown extension with id ${extensionId}`)\n        }\n    }\n    position += extensionLength;\n  }\n  return {\n    extensions,\n    extensionsEndPosition: position\n  };\n}\nexport const DECODING_STEPS = {\n  header: 0,\n  vertices: 1,\n  triangleIndices: 2,\n  edgeIndices: 3,\n  extensions: 4\n};\nconst DEFAULT_OPTIONS = {\n  maxDecodingStep: DECODING_STEPS.extensions\n};\nexport default function decode(data, userOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, userOptions);\n  const view = new DataView(data);\n  const {\n    header,\n    headerEndPosition\n  } = decodeHeader(view);\n  if (options.maxDecodingStep < DECODING_STEPS.vertices) {\n    return {\n      header\n    };\n  }\n  const {\n    vertexData,\n    vertexDataEndPosition\n  } = decodeVertexData(view, headerEndPosition);\n  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {\n    return {\n      header,\n      vertexData\n    };\n  }\n  const {\n    triangleIndices,\n    triangleIndicesEndPosition\n  } = decodeTriangleIndices(view, vertexData, vertexDataEndPosition);\n  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {\n    return {\n      header,\n      vertexData,\n      triangleIndices\n    };\n  }\n  const {\n    westIndices,\n    southIndices,\n    eastIndices,\n    northIndices,\n    edgeIndicesEndPosition\n  } = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);\n  if (options.maxDecodingStep < DECODING_STEPS.extensions) {\n    return {\n      header,\n      vertexData,\n      triangleIndices,\n      westIndices,\n      northIndices,\n      eastIndices,\n      southIndices\n    };\n  }\n  const {\n    extensions\n  } = decodeExtensions(view, edgeIndicesEndPosition);\n  return {\n    header,\n    vertexData,\n    triangleIndices,\n    westIndices,\n    northIndices,\n    eastIndices,\n    southIndices,\n    extensions\n  };\n}","map":{"version":3,"names":["QUANTIZED_MESH_HEADER","Map","Float64Array","BYTES_PER_ELEMENT","Float32Array","decodeZigZag","value","decodeHeader","dataView","position","header","key","bytesCount","getter","getFloat64","getFloat32","call","headerEndPosition","decodeVertexData","elementsPerVertex","vertexCount","getUint32","vertexData","Uint16Array","Uint32Array","bytesPerArrayElement","elementArrayLength","uArrayStartPosition","vArrayStartPosition","heightArrayStartPosition","u","v","height","i","getUint16","vertexDataEndPosition","decodeIndex","buffer","indicesCount","bytesPerIndex","encoded","indices","highest","length","code","decodeTriangleIndices","triangleCount","triangleIndicesCount","triangleIndices","triangleIndicesEndPosition","decodeEdgeIndices","westVertexCount","westIndices","southVertexCount","southIndices","eastVertexCount","eastIndices","northVertexCount","northIndices","edgeIndicesEndPosition","decodeVertexNormalsExtension","extensionDataView","Uint8Array","byteOffset","byteLength","decodeWaterMaskExtension","slice","decodeExtensions","indicesEndPosition","extensions","extensionsEndPosition","extensionId","getUint8","extensionLength","extensionView","DataView","vertexNormals","waterMask","DECODING_STEPS","vertices","edgeIndices","DEFAULT_OPTIONS","maxDecodingStep","decode","data","userOptions","options","Object","assign","view"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/terrain/dist/lib/decode-quantized-mesh.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Copyright (C) 2018-2019 HERE Europe B.V.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nconst QUANTIZED_MESH_HEADER = new Map([\n    ['centerX', Float64Array.BYTES_PER_ELEMENT],\n    ['centerY', Float64Array.BYTES_PER_ELEMENT],\n    ['centerZ', Float64Array.BYTES_PER_ELEMENT],\n    ['minHeight', Float32Array.BYTES_PER_ELEMENT],\n    ['maxHeight', Float32Array.BYTES_PER_ELEMENT],\n    ['boundingSphereCenterX', Float64Array.BYTES_PER_ELEMENT],\n    ['boundingSphereCenterY', Float64Array.BYTES_PER_ELEMENT],\n    ['boundingSphereCenterZ', Float64Array.BYTES_PER_ELEMENT],\n    ['boundingSphereRadius', Float64Array.BYTES_PER_ELEMENT],\n    ['horizonOcclusionPointX', Float64Array.BYTES_PER_ELEMENT],\n    ['horizonOcclusionPointY', Float64Array.BYTES_PER_ELEMENT],\n    ['horizonOcclusionPointZ', Float64Array.BYTES_PER_ELEMENT]\n]);\nfunction decodeZigZag(value) {\n    return (value >> 1) ^ -(value & 1);\n}\nfunction decodeHeader(dataView) {\n    let position = 0;\n    const header = {};\n    for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {\n        const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;\n        header[key] = getter.call(dataView, position, true);\n        position += bytesCount;\n    }\n    return { header, headerEndPosition: position };\n}\nfunction decodeVertexData(dataView, headerEndPosition) {\n    let position = headerEndPosition;\n    const elementsPerVertex = 3;\n    const vertexCount = dataView.getUint32(position, true);\n    const vertexData = new Uint16Array(vertexCount * elementsPerVertex);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;\n    const elementArrayLength = vertexCount * bytesPerArrayElement;\n    const uArrayStartPosition = position;\n    const vArrayStartPosition = uArrayStartPosition + elementArrayLength;\n    const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;\n    let u = 0;\n    let v = 0;\n    let height = 0;\n    for (let i = 0; i < vertexCount; i++) {\n        u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));\n        v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));\n        height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true));\n        vertexData[i] = u;\n        vertexData[i + vertexCount] = v;\n        vertexData[i + vertexCount * 2] = height;\n    }\n    position += elementArrayLength * 3;\n    return { vertexData, vertexDataEndPosition: position };\n}\nfunction decodeIndex(buffer, position, indicesCount, bytesPerIndex, encoded = true) {\n    let indices;\n    if (bytesPerIndex === 2) {\n        indices = new Uint16Array(buffer, position, indicesCount);\n    }\n    else {\n        indices = new Uint32Array(buffer, position, indicesCount);\n    }\n    if (!encoded) {\n        return indices;\n    }\n    let highest = 0;\n    for (let i = 0; i < indices.length; ++i) {\n        const code = indices[i];\n        indices[i] = highest - code;\n        if (code === 0) {\n            ++highest;\n        }\n    }\n    return indices;\n}\nfunction decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {\n    let position = vertexDataEndPosition;\n    const elementsPerVertex = 3;\n    const vertexCount = vertexData.length / elementsPerVertex;\n    const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n    if (position % bytesPerIndex !== 0) {\n        position += bytesPerIndex - (position % bytesPerIndex);\n    }\n    const triangleCount = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    const triangleIndicesCount = triangleCount * 3;\n    const triangleIndices = decodeIndex(dataView.buffer, position, triangleIndicesCount, bytesPerIndex);\n    position += triangleIndicesCount * bytesPerIndex;\n    return {\n        triangleIndicesEndPosition: position,\n        triangleIndices\n    };\n}\nfunction decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {\n    let position = triangleIndicesEndPosition;\n    const elementsPerVertex = 3;\n    const vertexCount = vertexData.length / elementsPerVertex;\n    const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n    const westVertexCount = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);\n    position += westVertexCount * bytesPerIndex;\n    const southVertexCount = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    const southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false);\n    position += southVertexCount * bytesPerIndex;\n    const eastVertexCount = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);\n    position += eastVertexCount * bytesPerIndex;\n    const northVertexCount = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    const northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false);\n    position += northVertexCount * bytesPerIndex;\n    return {\n        edgeIndicesEndPosition: position,\n        westIndices,\n        southIndices,\n        eastIndices,\n        northIndices\n    };\n}\nfunction decodeVertexNormalsExtension(extensionDataView) {\n    return new Uint8Array(extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength);\n}\nfunction decodeWaterMaskExtension(extensionDataView) {\n    return extensionDataView.buffer.slice(extensionDataView.byteOffset, extensionDataView.byteOffset + extensionDataView.byteLength);\n}\nfunction decodeExtensions(dataView, indicesEndPosition) {\n    const extensions = {};\n    if (dataView.byteLength <= indicesEndPosition) {\n        return { extensions, extensionsEndPosition: indicesEndPosition };\n    }\n    let position = indicesEndPosition;\n    while (position < dataView.byteLength) {\n        const extensionId = dataView.getUint8(position, true);\n        position += Uint8Array.BYTES_PER_ELEMENT;\n        const extensionLength = dataView.getUint32(position, true);\n        position += Uint32Array.BYTES_PER_ELEMENT;\n        const extensionView = new DataView(dataView.buffer, position, extensionLength);\n        switch (extensionId) {\n            case 1: {\n                extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);\n                break;\n            }\n            case 2: {\n                extensions.waterMask = decodeWaterMaskExtension(extensionView);\n                break;\n            }\n            default: {\n                // console.warn(`Unknown extension with id ${extensionId}`)\n            }\n        }\n        position += extensionLength;\n    }\n    return { extensions, extensionsEndPosition: position };\n}\nexport const DECODING_STEPS = {\n    header: 0,\n    vertices: 1,\n    triangleIndices: 2,\n    edgeIndices: 3,\n    extensions: 4\n};\nconst DEFAULT_OPTIONS = {\n    maxDecodingStep: DECODING_STEPS.extensions\n};\nexport default function decode(data, userOptions) {\n    const options = Object.assign({}, DEFAULT_OPTIONS, userOptions);\n    const view = new DataView(data);\n    const { header, headerEndPosition } = decodeHeader(view);\n    if (options.maxDecodingStep < DECODING_STEPS.vertices) {\n        return { header };\n    }\n    const { vertexData, vertexDataEndPosition } = decodeVertexData(view, headerEndPosition);\n    if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {\n        return { header, vertexData };\n    }\n    const { triangleIndices, triangleIndicesEndPosition } = decodeTriangleIndices(view, vertexData, vertexDataEndPosition);\n    if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {\n        return { header, vertexData, triangleIndices };\n    }\n    const { westIndices, southIndices, eastIndices, northIndices, edgeIndicesEndPosition } = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);\n    if (options.maxDecodingStep < DECODING_STEPS.extensions) {\n        return {\n            header,\n            vertexData,\n            triangleIndices,\n            westIndices,\n            northIndices,\n            eastIndices,\n            southIndices\n        };\n    }\n    const { extensions } = decodeExtensions(view, edgeIndicesEndPosition);\n    return {\n        header,\n        vertexData,\n        triangleIndices,\n        westIndices,\n        northIndices,\n        eastIndices,\n        southIndices,\n        extensions\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}