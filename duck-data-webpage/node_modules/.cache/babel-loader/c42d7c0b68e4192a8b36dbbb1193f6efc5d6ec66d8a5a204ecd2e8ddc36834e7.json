{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@deck.gl/core';\nimport { equals } from '@math.gl/core';\nimport MaskPass from \"./mask-pass.js\";\nimport { joinLayerBounds, getRenderBounds, makeViewport } from \"../utils/projection-utils.js\";\n// Class to manage mask effect\nexport default class MaskEffect {\n  constructor() {\n    this.id = 'mask-effect';\n    this.props = null;\n    this.useInPicking = true;\n    this.order = 0;\n    this.channels = [];\n    this.masks = null;\n  }\n  setup({\n    device\n  }) {\n    this.dummyMaskMap = device.createTexture({\n      width: 1,\n      height: 1\n    });\n    this.maskPass = new MaskPass(device, {\n      id: 'default-mask'\n    });\n    this.maskMap = this.maskPass.maskMap;\n  }\n  preRender({\n    layers,\n    layerFilter,\n    viewports,\n    onViewportActive,\n    views,\n    isPicking\n  }) {\n    let didRender = false;\n    if (isPicking) {\n      // Do not update on picking pass\n      return {\n        didRender\n      };\n    }\n    const maskLayers = layers.filter(l => l.props.visible && l.props.operation.includes('mask'));\n    if (maskLayers.length === 0) {\n      this.masks = null;\n      this.channels.length = 0;\n      return {\n        didRender\n      };\n    }\n    this.masks = {};\n    // Map layers to channels\n    const channelMap = this._sortMaskChannels(maskLayers);\n    // TODO - support multiple views\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n    if (viewport.resolution !== undefined) {\n      log.warn('MaskExtension is not supported in GlobeView')();\n      return {\n        didRender\n      };\n    }\n    for (const maskId in channelMap) {\n      const result = this._renderChannel(channelMap[maskId], {\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n      didRender || (didRender = result);\n    }\n    // debugFBO(this.maskMap, {opaque: true});\n    return {\n      didRender\n    };\n  }\n  /* eslint-disable-next-line complexity */\n  _renderChannel(channelInfo, {\n    layerFilter,\n    onViewportActive,\n    views,\n    viewport,\n    viewportChanged\n  }) {\n    let didRender = false;\n    const oldChannelInfo = this.channels[channelInfo.index];\n    if (!oldChannelInfo) {\n      return didRender;\n    }\n    const maskChanged =\n    // If a channel is new\n    channelInfo === oldChannelInfo ||\n    // If sublayers have changed\n    channelInfo.layers.length !== oldChannelInfo.layers.length || channelInfo.layers.some((layer, i) =>\n    // Layer instance is updated\n    // Layer props might have changed\n    // Undetermined props could have an effect on the output geometry of a mask layer,\n    // for example getRadius+updateTriggers, radiusScale, modelMatrix\n    layer !== oldChannelInfo.layers[i] ||\n    // Some prop is in transition\n    layer.props.transitions) ||\n    // If a sublayer's positions have been updated, the cached bounds will change shallowly\n    channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);\n    channelInfo.bounds = oldChannelInfo.bounds;\n    channelInfo.maskBounds = oldChannelInfo.maskBounds;\n    this.channels[channelInfo.index] = channelInfo;\n    if (maskChanged || viewportChanged) {\n      // Recalculate mask bounds\n      this.lastViewport = viewport;\n      const layerBounds = joinLayerBounds(channelInfo.layers, viewport);\n      channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);\n      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n        // Rerender mask FBO\n        const {\n          maskPass,\n          maskMap\n        } = this;\n        const maskViewport = layerBounds && makeViewport({\n          bounds: channelInfo.bounds,\n          viewport,\n          width: maskMap.width,\n          height: maskMap.height,\n          border: 1\n        });\n        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n        // @ts-ignore (2532) This method is only called from preRender where maskPass is defined\n        maskPass.render({\n          pass: 'mask',\n          channel: channelInfo.index,\n          layers: channelInfo.layers,\n          layerFilter,\n          viewports: maskViewport ? [maskViewport] : [],\n          onViewportActive,\n          views,\n          shaderModuleProps: {\n            project: {\n              devicePixelRatio: 1\n            }\n          }\n        });\n        didRender = true;\n      }\n    }\n    // @ts-ignore (2532) This method is only called from preRender where masks is defined\n    this.masks[channelInfo.id] = {\n      index: channelInfo.index,\n      bounds: channelInfo.maskBounds,\n      coordinateOrigin: channelInfo.coordinateOrigin,\n      coordinateSystem: channelInfo.coordinateSystem\n    };\n    return didRender;\n  }\n  /**\n   * Find a channel to render each mask into\n   * If a maskId already exists, diff and update the existing channel\n   * Otherwise replace a removed mask\n   * Otherwise create a new channel\n   * Returns a map from mask layer id to channel info\n   */\n  _sortMaskChannels(maskLayers) {\n    const channelMap = {};\n    let channelCount = 0;\n    for (const layer of maskLayers) {\n      const {\n        id\n      } = layer.root;\n      let channelInfo = channelMap[id];\n      if (!channelInfo) {\n        if (++channelCount > 4) {\n          log.warn('Too many mask layers. The max supported is 4')();\n          continue; // eslint-disable-line no-continue\n        }\n        channelInfo = {\n          id,\n          index: this.channels.findIndex(c => c?.id === id),\n          layers: [],\n          layerBounds: [],\n          coordinateOrigin: layer.root.props.coordinateOrigin,\n          coordinateSystem: layer.root.props.coordinateSystem\n        };\n        channelMap[id] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n    }\n    for (let i = 0; i < 4; i++) {\n      const channelInfo = this.channels[i];\n      if (!channelInfo || !(channelInfo.id in channelMap)) {\n        // The mask id at this channel no longer exists\n        this.channels[i] = null;\n      }\n    }\n    for (const maskId in channelMap) {\n      const channelInfo = channelMap[maskId];\n      if (channelInfo.index < 0) {\n        channelInfo.index = this.channels.findIndex(c => !c);\n        this.channels[channelInfo.index] = channelInfo;\n      }\n    }\n    return channelMap;\n  }\n  getShaderModuleProps() {\n    return {\n      mask: {\n        maskMap: this.masks ? this.maskMap : this.dummyMaskMap,\n        maskChannels: this.masks\n      }\n    };\n  }\n  cleanup() {\n    if (this.dummyMaskMap) {\n      this.dummyMaskMap.delete();\n      this.dummyMaskMap = undefined;\n    }\n    if (this.maskPass) {\n      this.maskPass.delete();\n      this.maskPass = undefined;\n      this.maskMap = undefined;\n    }\n    this.lastViewport = undefined;\n    this.masks = null;\n    this.channels.length = 0;\n  }\n}","map":{"version":3,"names":["log","equals","MaskPass","joinLayerBounds","getRenderBounds","makeViewport","MaskEffect","constructor","id","props","useInPicking","order","channels","masks","setup","device","dummyMaskMap","createTexture","width","height","maskPass","maskMap","preRender","layers","layerFilter","viewports","onViewportActive","views","isPicking","didRender","maskLayers","filter","l","visible","operation","includes","length","channelMap","_sortMaskChannels","viewport","viewportChanged","lastViewport","resolution","undefined","warn","maskId","result","_renderChannel","channelInfo","oldChannelInfo","index","maskChanged","some","layer","i","transitions","layerBounds","b","bounds","maskBounds","maskViewport","border","getBounds","render","pass","channel","shaderModuleProps","project","devicePixelRatio","coordinateOrigin","coordinateSystem","channelCount","root","findIndex","c","push","getShaderModuleProps","mask","maskChannels","cleanup","delete"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\extensions\\src\\mask\\mask-effect.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  Layer,\n  Viewport,\n  Effect,\n  EffectContext,\n  PreRenderOptions,\n  CoordinateSystem,\n  log\n} from '@deck.gl/core';\nimport type {Texture} from '@luma.gl/core';\nimport {equals} from '@math.gl/core';\nimport MaskPass from './mask-pass';\nimport {joinLayerBounds, getRenderBounds, makeViewport, Bounds} from '../utils/projection-utils';\n// import {debugFBO} from '../utils/debug';\n\ntype Mask = {\n  /** The channel index */\n  index: 0 | 1 | 2 | 3;\n  bounds: Bounds;\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\ntype Channel = {\n  id: string;\n  index: 0 | 1 | 2 | 3;\n  layers: Layer[];\n  bounds: Bounds | null;\n  maskBounds: Bounds;\n  layerBounds: Bounds[];\n  coordinateOrigin: [number, number, number];\n  coordinateSystem: CoordinateSystem;\n};\n\nexport type MaskPreRenderStats = {\n  didRender: boolean;\n};\n\n// Class to manage mask effect\nexport default class MaskEffect implements Effect {\n  id = 'mask-effect';\n  props = null;\n  useInPicking = true;\n  order = 0;\n\n  private dummyMaskMap?: Texture;\n  private channels: (Channel | null)[] = [];\n  private masks: Record<string, Mask> | null = null;\n  private maskPass?: MaskPass;\n  private maskMap?: Texture;\n  private lastViewport?: Viewport;\n\n  setup({device}: EffectContext) {\n    this.dummyMaskMap = device.createTexture({\n      width: 1,\n      height: 1\n    });\n\n    this.maskPass = new MaskPass(device, {id: 'default-mask'});\n    this.maskMap = this.maskPass.maskMap;\n  }\n\n  preRender({\n    layers,\n    layerFilter,\n    viewports,\n    onViewportActive,\n    views,\n    isPicking\n  }: PreRenderOptions): MaskPreRenderStats {\n    let didRender = false;\n\n    if (isPicking) {\n      // Do not update on picking pass\n      return {didRender};\n    }\n\n    const maskLayers = layers.filter(l => l.props.visible && l.props.operation.includes('mask'));\n    if (maskLayers.length === 0) {\n      this.masks = null;\n      this.channels.length = 0;\n      return {didRender};\n    }\n    this.masks = {};\n\n    // Map layers to channels\n    const channelMap = this._sortMaskChannels(maskLayers);\n    // TODO - support multiple views\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n\n    if (viewport.resolution !== undefined) {\n      log.warn('MaskExtension is not supported in GlobeView')();\n      return {didRender};\n    }\n\n    for (const maskId in channelMap) {\n      const result = this._renderChannel(channelMap[maskId], {\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n      didRender ||= result;\n    }\n\n    // debugFBO(this.maskMap, {opaque: true});\n    return {didRender};\n  }\n\n  /* eslint-disable-next-line complexity */\n  private _renderChannel(\n    channelInfo: Channel,\n    {\n      layerFilter,\n      onViewportActive,\n      views,\n      viewport,\n      viewportChanged\n    }: {\n      layerFilter: PreRenderOptions['layerFilter'];\n      onViewportActive: PreRenderOptions['onViewportActive'];\n      views: PreRenderOptions['views'];\n      viewport: Viewport;\n      viewportChanged: boolean;\n    }\n  ): boolean {\n    let didRender = false;\n    const oldChannelInfo = this.channels[channelInfo.index];\n    if (!oldChannelInfo) {\n      return didRender;\n    }\n\n    const maskChanged =\n      // If a channel is new\n      channelInfo === oldChannelInfo ||\n      // If sublayers have changed\n      channelInfo.layers.length !== oldChannelInfo.layers.length ||\n      channelInfo.layers.some(\n        (layer, i) =>\n          // Layer instance is updated\n          // Layer props might have changed\n          // Undetermined props could have an effect on the output geometry of a mask layer,\n          // for example getRadius+updateTriggers, radiusScale, modelMatrix\n          layer !== oldChannelInfo.layers[i] ||\n          // Some prop is in transition\n          layer.props.transitions\n      ) ||\n      // If a sublayer's positions have been updated, the cached bounds will change shallowly\n      channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);\n\n    channelInfo.bounds = oldChannelInfo.bounds;\n    channelInfo.maskBounds = oldChannelInfo.maskBounds;\n    this.channels[channelInfo.index] = channelInfo;\n\n    if (maskChanged || viewportChanged) {\n      // Recalculate mask bounds\n      this.lastViewport = viewport;\n\n      const layerBounds = joinLayerBounds(channelInfo.layers, viewport);\n      channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);\n\n      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n        // Rerender mask FBO\n        const {maskPass, maskMap} = this;\n\n        const maskViewport =\n          layerBounds &&\n          makeViewport({\n            bounds: channelInfo.bounds!,\n            viewport,\n            width: maskMap!.width,\n            height: maskMap!.height,\n            border: 1\n          });\n\n        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n\n        // @ts-ignore (2532) This method is only called from preRender where maskPass is defined\n        maskPass.render({\n          pass: 'mask',\n          channel: channelInfo.index,\n          layers: channelInfo.layers,\n          layerFilter,\n          viewports: maskViewport ? [maskViewport] : [],\n          onViewportActive,\n          views,\n          shaderModuleProps: {\n            project: {\n              devicePixelRatio: 1\n            }\n          }\n        });\n\n        didRender = true;\n      }\n    }\n\n    // @ts-ignore (2532) This method is only called from preRender where masks is defined\n    this.masks[channelInfo.id] = {\n      index: channelInfo.index,\n      bounds: channelInfo.maskBounds,\n      coordinateOrigin: channelInfo.coordinateOrigin,\n      coordinateSystem: channelInfo.coordinateSystem\n    };\n\n    return didRender;\n  }\n\n  /**\n   * Find a channel to render each mask into\n   * If a maskId already exists, diff and update the existing channel\n   * Otherwise replace a removed mask\n   * Otherwise create a new channel\n   * Returns a map from mask layer id to channel info\n   */\n  private _sortMaskChannels(maskLayers: Layer[]): Record<string, Channel> {\n    const channelMap = {};\n    let channelCount = 0;\n    for (const layer of maskLayers) {\n      const {id} = layer.root;\n      let channelInfo = channelMap[id];\n      if (!channelInfo) {\n        if (++channelCount > 4) {\n          log.warn('Too many mask layers. The max supported is 4')();\n          continue; // eslint-disable-line no-continue\n        }\n        channelInfo = {\n          id,\n          index: this.channels.findIndex(c => c?.id === id),\n          layers: [],\n          layerBounds: [],\n          coordinateOrigin: layer.root.props.coordinateOrigin,\n          coordinateSystem: layer.root.props.coordinateSystem\n        };\n        channelMap[id] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n    }\n\n    for (let i = 0; i < 4; i++) {\n      const channelInfo = this.channels[i];\n      if (!channelInfo || !(channelInfo.id in channelMap)) {\n        // The mask id at this channel no longer exists\n        this.channels[i] = null;\n      }\n    }\n\n    for (const maskId in channelMap) {\n      const channelInfo = channelMap[maskId];\n\n      if (channelInfo.index < 0) {\n        channelInfo.index = this.channels.findIndex(c => !c);\n        this.channels[channelInfo.index] = channelInfo;\n      }\n    }\n    return channelMap;\n  }\n\n  getShaderModuleProps(): {\n    mask: {\n      maskMap: Texture;\n      maskChannels: Record<string, Mask> | null;\n    };\n  } {\n    return {\n      mask: {\n        maskMap: this.masks ? this.maskMap! : this.dummyMaskMap!,\n        maskChannels: this.masks\n      }\n    };\n  }\n\n  cleanup(): void {\n    if (this.dummyMaskMap) {\n      this.dummyMaskMap.delete();\n      this.dummyMaskMap = undefined;\n    }\n\n    if (this.maskPass) {\n      this.maskPass.delete();\n      this.maskPass = undefined;\n      this.maskMap = undefined;\n    }\n\n    this.lastViewport = undefined;\n    this.masks = null;\n    this.channels.length = 0;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}