{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ManagedArray } from \"../utils/managed-array.js\";\nimport { TILE_REFINEMENT } from \"../constants.js\";\nexport const DEFAULT_PROPS = {\n  loadSiblings: false,\n  skipLevelOfDetail: false,\n  updateTransforms: true,\n  onTraversalEnd: () => {},\n  viewportTraversersMap: {},\n  basePath: ''\n};\nexport class TilesetTraverser {\n  options;\n  // fulfill in traverse call\n  root = null;\n  // tiles should be rendered\n  selectedTiles = {};\n  // tiles should be loaded from server\n  requestedTiles = {};\n  // tiles does not have render content\n  emptyTiles = {};\n  lastUpdate = new Date().getTime();\n  updateDebounceTime = 1000;\n  /** temporary storage to hold the traversed tiles during a traversal */\n  _traversalStack = new ManagedArray();\n  _emptyTraversalStack = new ManagedArray();\n  /** set in every traverse cycle */\n  _frameNumber = null;\n  // RESULT\n  traversalFinished(frameState) {\n    return true;\n  }\n  // TODO nested props\n  constructor(options) {\n    this.options = {\n      ...DEFAULT_PROPS,\n      ...options\n    };\n  }\n  // tiles should be visible\n  traverse(root, frameState, options) {\n    this.root = root; // for root screen space error\n    this.options = {\n      ...this.options,\n      ...options\n    };\n    // reset result\n    this.reset();\n    // update tile (visibility and expiration)\n    this.updateTile(root, frameState);\n    this._frameNumber = frameState.frameNumber;\n    this.executeTraversal(root, frameState);\n  }\n  reset() {\n    this.requestedTiles = {};\n    this.selectedTiles = {};\n    this.emptyTiles = {};\n    this._traversalStack.reset();\n    this._emptyTraversalStack.reset();\n  }\n  /**\n   * Execute traverse\n   * Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n   * If skipLevelOfDetail is off then a tile does not refine until all children are loaded.\n   * This is the traditional replacement refinement approach and is called the base traversal.\n   * Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n   * all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n   * and rendering children and parent tiles simultaneously.\n   */\n  /* eslint-disable-next-line complexity, max-statements */\n  executeTraversal(root, frameState) {\n    // stack to store traversed tiles, only visible tiles should be added to stack\n    // visible: visible in the current view frustum\n    const stack = this._traversalStack;\n    root._selectionDepth = 1;\n    stack.push(root);\n    while (stack.length > 0) {\n      // 1. pop tile\n      const tile = stack.pop();\n      // 2. check if tile needs to be refine, needs refine if a tile's LoD is not sufficient and tile has available children (available content)\n      let shouldRefine = false;\n      if (this.canTraverse(tile, frameState)) {\n        this.updateChildTiles(tile, frameState);\n        shouldRefine = this.updateAndPushChildren(tile, frameState, stack, tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth);\n      }\n      // 3. decide if should render (select) this tile\n      //   - tile does not have render content\n      //   - tile has render content and tile is `add` type (pointcloud)\n      //   - tile has render content and tile is `replace` type (photogrammetry) and can't refine any further\n      const parent = tile.parent;\n      const parentRefines = Boolean(!parent || parent._shouldRefine);\n      const stoppedRefining = !shouldRefine;\n      if (!tile.hasRenderContent) {\n        this.emptyTiles[tile.id] = tile;\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n        // additive tiles\n      } else if (tile.refine === TILE_REFINEMENT.ADD) {\n        // Additive tiles are always loaded and selected\n        this.loadTile(tile, frameState);\n        this.selectTile(tile, frameState);\n        // replace tiles\n      } else if (tile.refine === TILE_REFINEMENT.REPLACE) {\n        // Always load tiles in the base traversal\n        // Select tiles that can't refine further\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n      }\n      // 3. update cache, most recent touched tiles have higher priority to be fetched from server\n      this.touchTile(tile, frameState);\n      // 4. update tile refine prop and parent refinement status to trickle down to the descendants\n      tile._shouldRefine = shouldRefine && parentRefines;\n    }\n    const newTime = new Date().getTime();\n    if (this.traversalFinished(frameState) || newTime - this.lastUpdate > this.updateDebounceTime) {\n      this.lastUpdate = newTime;\n      this.options.onTraversalEnd(frameState);\n    }\n  }\n  updateChildTiles(tile, frameState) {\n    const children = tile.children;\n    for (const child of children) {\n      this.updateTile(child, frameState);\n    }\n  }\n  /* eslint-disable complexity, max-statements */\n  updateAndPushChildren(tile, frameState, stack, depth) {\n    const {\n      loadSiblings,\n      skipLevelOfDetail\n    } = this.options;\n    const children = tile.children;\n    // sort children tiles\n    children.sort(this.compareDistanceToCamera.bind(this));\n    // For traditional replacement refinement only refine if all children are loaded.\n    // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.\n    const checkRefines = tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;\n    let hasVisibleChild = false;\n    let refines = true;\n    for (const child of children) {\n      child._selectionDepth = depth;\n      if (child.isVisibleAndInRequestVolume) {\n        if (stack.find(child)) {\n          stack.delete(child);\n        }\n        stack.push(child);\n        hasVisibleChild = true;\n      } else if (checkRefines || loadSiblings) {\n        // Keep non-visible children loaded since they are still needed before the parent can refine.\n        // Or loadSiblings is true so always load tiles regardless of visibility.\n        this.loadTile(child, frameState);\n        this.touchTile(child, frameState);\n      }\n      if (checkRefines) {\n        let childRefines;\n        if (!child._inRequestVolume) {\n          childRefines = false;\n        } else if (!child.hasRenderContent) {\n          childRefines = this.executeEmptyTraversal(child, frameState);\n        } else {\n          childRefines = child.contentAvailable;\n        }\n        refines = refines && childRefines;\n        if (!refines) {\n          return false;\n        }\n      }\n    }\n    if (!hasVisibleChild) {\n      refines = false;\n    }\n    return refines;\n  }\n  /* eslint-enable complexity, max-statements */\n  updateTile(tile, frameState) {\n    this.updateTileVisibility(tile, frameState);\n  }\n  // tile to render in the browser\n  selectTile(tile, frameState) {\n    if (this.shouldSelectTile(tile)) {\n      // The tile can be selected right away and does not require traverseAndSelect\n      tile._selectedFrame = frameState.frameNumber;\n      this.selectedTiles[tile.id] = tile;\n    }\n  }\n  // tile to load from server\n  loadTile(tile, frameState) {\n    if (this.shouldLoadTile(tile)) {\n      tile._requestedFrame = frameState.frameNumber;\n      tile._priority = tile._getPriority();\n      this.requestedTiles[tile.id] = tile;\n    }\n  }\n  // cache tile\n  touchTile(tile, frameState) {\n    tile.tileset._cache.touch(tile);\n    tile._touchedFrame = frameState.frameNumber;\n  }\n  // tile should be visible\n  // tile should have children\n  // tile LoD (level of detail) is not sufficient under current viewport\n  canTraverse(tile, frameState) {\n    if (!tile.hasChildren) {\n      return false;\n    }\n    // cesium specific\n    if (tile.hasTilesetContent) {\n      // Traverse external this to visit its root tile\n      // Don't traverse if the subtree is expired because it will be destroyed\n      return !tile.contentExpired;\n    }\n    return this.shouldRefine(tile, frameState);\n  }\n  shouldLoadTile(tile) {\n    // if request tile is in current frame\n    // and has unexpired render content\n    return tile.hasUnloadedContent || tile.contentExpired;\n  }\n  shouldSelectTile(tile) {\n    // if select tile is in current frame\n    // and content available\n    return tile.contentAvailable && !this.options.skipLevelOfDetail;\n  }\n  /** Decide if tile LoD (level of detail) is not sufficient under current viewport */\n  shouldRefine(tile, frameState, useParentMetric = false) {\n    let screenSpaceError = tile._screenSpaceError;\n    if (useParentMetric) {\n      screenSpaceError = tile.getScreenSpaceError(frameState, true);\n    }\n    return screenSpaceError > tile.tileset.memoryAdjustedScreenSpaceError;\n  }\n  updateTileVisibility(tile, frameState) {\n    const viewportIds = [];\n    if (this.options.viewportTraversersMap) {\n      for (const key in this.options.viewportTraversersMap) {\n        const value = this.options.viewportTraversersMap[key];\n        if (value === frameState.viewport.id) {\n          viewportIds.push(key);\n        }\n      }\n    } else {\n      viewportIds.push(frameState.viewport.id);\n    }\n    tile.updateVisibility(frameState, viewportIds);\n  }\n  // UTILITIES\n  compareDistanceToCamera(b, a) {\n    return b._distanceToCamera - a._distanceToCamera;\n  }\n  anyChildrenVisible(tile, frameState) {\n    let anyVisible = false;\n    for (const child of tile.children) {\n      // @ts-expect-error\n      child.updateVisibility(frameState);\n      // @ts-expect-error\n      anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n    }\n    return anyVisible;\n  }\n  // Depth-first traversal that checks if all nearest descendants with content are loaded.\n  // Ignores visibility.\n  executeEmptyTraversal(root, frameState) {\n    let allDescendantsLoaded = true;\n    const stack = this._emptyTraversalStack;\n    stack.push(root);\n    while (stack.length > 0) {\n      const tile = stack.pop();\n      const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState);\n      const emptyLeaf = !tile.hasRenderContent && tile.children.length === 0;\n      // Traversal stops but the tile does not have content yet\n      // There will be holes if the parent tries to refine to its children, so don't refine\n      // One exception: a parent may refine even if one of its descendants is an empty leaf\n      if (!traverse && !tile.contentAvailable && !emptyLeaf) {\n        allDescendantsLoaded = false;\n      }\n      this.updateTile(tile, frameState);\n      if (!tile.isVisibleAndInRequestVolume) {\n        this.loadTile(tile, frameState);\n        this.touchTile(tile, frameState);\n      }\n      if (traverse) {\n        const children = tile.children;\n        for (const child of children) {\n          stack.push(child);\n        }\n      }\n    }\n    return allDescendantsLoaded;\n  }\n}","map":{"version":3,"names":["ManagedArray","TILE_REFINEMENT","DEFAULT_PROPS","loadSiblings","skipLevelOfDetail","updateTransforms","onTraversalEnd","viewportTraversersMap","basePath","TilesetTraverser","options","root","selectedTiles","requestedTiles","emptyTiles","lastUpdate","Date","getTime","updateDebounceTime","_traversalStack","_emptyTraversalStack","_frameNumber","traversalFinished","frameState","constructor","traverse","reset","updateTile","frameNumber","executeTraversal","stack","_selectionDepth","push","length","tile","pop","shouldRefine","canTraverse","updateChildTiles","updateAndPushChildren","hasRenderContent","parent","parentRefines","Boolean","_shouldRefine","stoppedRefining","id","loadTile","selectTile","refine","ADD","REPLACE","touchTile","newTime","children","child","depth","sort","compareDistanceToCamera","bind","checkRefines","hasVisibleChild","refines","isVisibleAndInRequestVolume","find","delete","childRefines","_inRequestVolume","executeEmptyTraversal","contentAvailable","updateTileVisibility","shouldSelectTile","_selectedFrame","shouldLoadTile","_requestedFrame","_priority","_getPriority","tileset","_cache","touch","_touchedFrame","hasChildren","hasTilesetContent","contentExpired","hasUnloadedContent","useParentMetric","screenSpaceError","_screenSpaceError","getScreenSpaceError","memoryAdjustedScreenSpaceError","viewportIds","key","value","viewport","updateVisibility","b","a","_distanceToCamera","anyChildrenVisible","anyVisible","allDescendantsLoaded","emptyLeaf"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/tiles/dist/tileset/tileset-traverser.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ManagedArray } from \"../utils/managed-array.js\";\nimport { TILE_REFINEMENT } from \"../constants.js\";\nexport const DEFAULT_PROPS = {\n    loadSiblings: false,\n    skipLevelOfDetail: false,\n    updateTransforms: true,\n    onTraversalEnd: () => { },\n    viewportTraversersMap: {},\n    basePath: ''\n};\nexport class TilesetTraverser {\n    options;\n    // fulfill in traverse call\n    root = null;\n    // tiles should be rendered\n    selectedTiles = {};\n    // tiles should be loaded from server\n    requestedTiles = {};\n    // tiles does not have render content\n    emptyTiles = {};\n    lastUpdate = new Date().getTime();\n    updateDebounceTime = 1000;\n    /** temporary storage to hold the traversed tiles during a traversal */\n    _traversalStack = new ManagedArray();\n    _emptyTraversalStack = new ManagedArray();\n    /** set in every traverse cycle */\n    _frameNumber = null;\n    // RESULT\n    traversalFinished(frameState) {\n        return true;\n    }\n    // TODO nested props\n    constructor(options) {\n        this.options = { ...DEFAULT_PROPS, ...options };\n    }\n    // tiles should be visible\n    traverse(root, frameState, options) {\n        this.root = root; // for root screen space error\n        this.options = { ...this.options, ...options };\n        // reset result\n        this.reset();\n        // update tile (visibility and expiration)\n        this.updateTile(root, frameState);\n        this._frameNumber = frameState.frameNumber;\n        this.executeTraversal(root, frameState);\n    }\n    reset() {\n        this.requestedTiles = {};\n        this.selectedTiles = {};\n        this.emptyTiles = {};\n        this._traversalStack.reset();\n        this._emptyTraversalStack.reset();\n    }\n    /**\n     * Execute traverse\n     * Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n     * If skipLevelOfDetail is off then a tile does not refine until all children are loaded.\n     * This is the traditional replacement refinement approach and is called the base traversal.\n     * Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n     * all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n     * and rendering children and parent tiles simultaneously.\n     */\n    /* eslint-disable-next-line complexity, max-statements */\n    executeTraversal(root, frameState) {\n        // stack to store traversed tiles, only visible tiles should be added to stack\n        // visible: visible in the current view frustum\n        const stack = this._traversalStack;\n        root._selectionDepth = 1;\n        stack.push(root);\n        while (stack.length > 0) {\n            // 1. pop tile\n            const tile = stack.pop();\n            // 2. check if tile needs to be refine, needs refine if a tile's LoD is not sufficient and tile has available children (available content)\n            let shouldRefine = false;\n            if (this.canTraverse(tile, frameState)) {\n                this.updateChildTiles(tile, frameState);\n                shouldRefine = this.updateAndPushChildren(tile, frameState, stack, tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth);\n            }\n            // 3. decide if should render (select) this tile\n            //   - tile does not have render content\n            //   - tile has render content and tile is `add` type (pointcloud)\n            //   - tile has render content and tile is `replace` type (photogrammetry) and can't refine any further\n            const parent = tile.parent;\n            const parentRefines = Boolean(!parent || parent._shouldRefine);\n            const stoppedRefining = !shouldRefine;\n            if (!tile.hasRenderContent) {\n                this.emptyTiles[tile.id] = tile;\n                this.loadTile(tile, frameState);\n                if (stoppedRefining) {\n                    this.selectTile(tile, frameState);\n                }\n                // additive tiles\n            }\n            else if (tile.refine === TILE_REFINEMENT.ADD) {\n                // Additive tiles are always loaded and selected\n                this.loadTile(tile, frameState);\n                this.selectTile(tile, frameState);\n                // replace tiles\n            }\n            else if (tile.refine === TILE_REFINEMENT.REPLACE) {\n                // Always load tiles in the base traversal\n                // Select tiles that can't refine further\n                this.loadTile(tile, frameState);\n                if (stoppedRefining) {\n                    this.selectTile(tile, frameState);\n                }\n            }\n            // 3. update cache, most recent touched tiles have higher priority to be fetched from server\n            this.touchTile(tile, frameState);\n            // 4. update tile refine prop and parent refinement status to trickle down to the descendants\n            tile._shouldRefine = shouldRefine && parentRefines;\n        }\n        const newTime = new Date().getTime();\n        if (this.traversalFinished(frameState) || newTime - this.lastUpdate > this.updateDebounceTime) {\n            this.lastUpdate = newTime;\n            this.options.onTraversalEnd(frameState);\n        }\n    }\n    updateChildTiles(tile, frameState) {\n        const children = tile.children;\n        for (const child of children) {\n            this.updateTile(child, frameState);\n        }\n    }\n    /* eslint-disable complexity, max-statements */\n    updateAndPushChildren(tile, frameState, stack, depth) {\n        const { loadSiblings, skipLevelOfDetail } = this.options;\n        const children = tile.children;\n        // sort children tiles\n        children.sort(this.compareDistanceToCamera.bind(this));\n        // For traditional replacement refinement only refine if all children are loaded.\n        // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.\n        const checkRefines = tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;\n        let hasVisibleChild = false;\n        let refines = true;\n        for (const child of children) {\n            child._selectionDepth = depth;\n            if (child.isVisibleAndInRequestVolume) {\n                if (stack.find(child)) {\n                    stack.delete(child);\n                }\n                stack.push(child);\n                hasVisibleChild = true;\n            }\n            else if (checkRefines || loadSiblings) {\n                // Keep non-visible children loaded since they are still needed before the parent can refine.\n                // Or loadSiblings is true so always load tiles regardless of visibility.\n                this.loadTile(child, frameState);\n                this.touchTile(child, frameState);\n            }\n            if (checkRefines) {\n                let childRefines;\n                if (!child._inRequestVolume) {\n                    childRefines = false;\n                }\n                else if (!child.hasRenderContent) {\n                    childRefines = this.executeEmptyTraversal(child, frameState);\n                }\n                else {\n                    childRefines = child.contentAvailable;\n                }\n                refines = refines && childRefines;\n                if (!refines) {\n                    return false;\n                }\n            }\n        }\n        if (!hasVisibleChild) {\n            refines = false;\n        }\n        return refines;\n    }\n    /* eslint-enable complexity, max-statements */\n    updateTile(tile, frameState) {\n        this.updateTileVisibility(tile, frameState);\n    }\n    // tile to render in the browser\n    selectTile(tile, frameState) {\n        if (this.shouldSelectTile(tile)) {\n            // The tile can be selected right away and does not require traverseAndSelect\n            tile._selectedFrame = frameState.frameNumber;\n            this.selectedTiles[tile.id] = tile;\n        }\n    }\n    // tile to load from server\n    loadTile(tile, frameState) {\n        if (this.shouldLoadTile(tile)) {\n            tile._requestedFrame = frameState.frameNumber;\n            tile._priority = tile._getPriority();\n            this.requestedTiles[tile.id] = tile;\n        }\n    }\n    // cache tile\n    touchTile(tile, frameState) {\n        tile.tileset._cache.touch(tile);\n        tile._touchedFrame = frameState.frameNumber;\n    }\n    // tile should be visible\n    // tile should have children\n    // tile LoD (level of detail) is not sufficient under current viewport\n    canTraverse(tile, frameState) {\n        if (!tile.hasChildren) {\n            return false;\n        }\n        // cesium specific\n        if (tile.hasTilesetContent) {\n            // Traverse external this to visit its root tile\n            // Don't traverse if the subtree is expired because it will be destroyed\n            return !tile.contentExpired;\n        }\n        return this.shouldRefine(tile, frameState);\n    }\n    shouldLoadTile(tile) {\n        // if request tile is in current frame\n        // and has unexpired render content\n        return tile.hasUnloadedContent || tile.contentExpired;\n    }\n    shouldSelectTile(tile) {\n        // if select tile is in current frame\n        // and content available\n        return tile.contentAvailable && !this.options.skipLevelOfDetail;\n    }\n    /** Decide if tile LoD (level of detail) is not sufficient under current viewport */\n    shouldRefine(tile, frameState, useParentMetric = false) {\n        let screenSpaceError = tile._screenSpaceError;\n        if (useParentMetric) {\n            screenSpaceError = tile.getScreenSpaceError(frameState, true);\n        }\n        return screenSpaceError > tile.tileset.memoryAdjustedScreenSpaceError;\n    }\n    updateTileVisibility(tile, frameState) {\n        const viewportIds = [];\n        if (this.options.viewportTraversersMap) {\n            for (const key in this.options.viewportTraversersMap) {\n                const value = this.options.viewportTraversersMap[key];\n                if (value === frameState.viewport.id) {\n                    viewportIds.push(key);\n                }\n            }\n        }\n        else {\n            viewportIds.push(frameState.viewport.id);\n        }\n        tile.updateVisibility(frameState, viewportIds);\n    }\n    // UTILITIES\n    compareDistanceToCamera(b, a) {\n        return b._distanceToCamera - a._distanceToCamera;\n    }\n    anyChildrenVisible(tile, frameState) {\n        let anyVisible = false;\n        for (const child of tile.children) {\n            // @ts-expect-error\n            child.updateVisibility(frameState);\n            // @ts-expect-error\n            anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n        }\n        return anyVisible;\n    }\n    // Depth-first traversal that checks if all nearest descendants with content are loaded.\n    // Ignores visibility.\n    executeEmptyTraversal(root, frameState) {\n        let allDescendantsLoaded = true;\n        const stack = this._emptyTraversalStack;\n        stack.push(root);\n        while (stack.length > 0) {\n            const tile = stack.pop();\n            const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState);\n            const emptyLeaf = !tile.hasRenderContent && tile.children.length === 0;\n            // Traversal stops but the tile does not have content yet\n            // There will be holes if the parent tries to refine to its children, so don't refine\n            // One exception: a parent may refine even if one of its descendants is an empty leaf\n            if (!traverse && !tile.contentAvailable && !emptyLeaf) {\n                allDescendantsLoaded = false;\n            }\n            this.updateTile(tile, frameState);\n            if (!tile.isVisibleAndInRequestVolume) {\n                this.loadTile(tile, frameState);\n                this.touchTile(tile, frameState);\n            }\n            if (traverse) {\n                const children = tile.children;\n                for (const child of children) {\n                    stack.push(child);\n                }\n            }\n        }\n        return allDescendantsLoaded;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}