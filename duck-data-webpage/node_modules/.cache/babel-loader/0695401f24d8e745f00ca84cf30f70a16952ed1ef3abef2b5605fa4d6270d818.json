{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport Controller from \"./controller.js\";\nimport ViewState from \"./view-state.js\";\nimport { mod } from \"../utils/math-utils.js\";\nimport LinearInterpolator from \"../transitions/linear-interpolator.js\";\nimport { Vector3, _SphericalCoordinates as SphericalCoordinates, clamp } from '@math.gl/core';\nconst MOVEMENT_SPEED = 20;\nconst PAN_SPEED = 500;\nclass FirstPersonState extends ViewState {\n  constructor(options) {\n    const {\n      /* Viewport arguments */\n      width,\n      // Width of viewport\n      height,\n      // Height of viewport\n      // Position and orientation\n      position = [0, 0, 0],\n      // typically in meters from anchor point\n      bearing = 0,\n      // Rotation around y axis\n      pitch = 0,\n      // Rotation around x axis\n      // Geospatial anchor\n      longitude = null,\n      latitude = null,\n      maxPitch = 90,\n      minPitch = -90,\n      // Model state when the rotate operation first started\n      startRotatePos,\n      startBearing,\n      startPitch,\n      startZoomPosition,\n      startPanPos,\n      startPanPosition\n    } = options;\n    super({\n      width,\n      height,\n      position,\n      bearing,\n      pitch,\n      longitude,\n      latitude,\n      maxPitch,\n      minPitch\n    }, {\n      startRotatePos,\n      startBearing,\n      startPitch,\n      startZoomPosition,\n      startPanPos,\n      startPanPosition\n    });\n    this.makeViewport = options.makeViewport;\n  }\n  /* Public API */\n  /**\n   * Start panning\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  panStart({\n    pos\n  }) {\n    const {\n      position\n    } = this.getViewportProps();\n    return this._getUpdatedState({\n      startPanPos: pos,\n      startPanPosition: position\n    });\n  }\n  /**\n   * Pan\n   * @param {[Number, Number]} pos - position on screen where the pointer is\n   */\n  pan({\n    pos\n  }) {\n    if (!pos) {\n      return this;\n    }\n    const {\n      startPanPos = [0, 0],\n      startPanPosition = [0, 0]\n    } = this.getState();\n    const {\n      width,\n      height,\n      bearing,\n      pitch\n    } = this.getViewportProps();\n    const deltaScaleX = PAN_SPEED * (pos[0] - startPanPos[0]) / width;\n    const deltaScaleY = PAN_SPEED * (pos[1] - startPanPos[1]) / height;\n    const up = new SphericalCoordinates({\n      bearing,\n      pitch\n    });\n    const forward = new SphericalCoordinates({\n      bearing,\n      pitch: -90\n    });\n    const yDirection = up.toVector3().normalize();\n    const xDirection = forward.toVector3().cross(yDirection).normalize();\n    return this._getUpdatedState({\n      position: new Vector3(startPanPosition).add(xDirection.scale(deltaScaleX)).add(yDirection.scale(deltaScaleY))\n    });\n  }\n  /**\n   * End panning\n   * Must call if `panStart()` was called\n   */\n  panEnd() {\n    return this._getUpdatedState({\n      startPanPos: null,\n      startPanPosition: null\n    });\n  }\n  /**\n   * Start rotating\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  rotateStart({\n    pos\n  }) {\n    return this._getUpdatedState({\n      startRotatePos: pos,\n      startBearing: this.getViewportProps().bearing,\n      startPitch: this.getViewportProps().pitch\n    });\n  }\n  /**\n   * Rotate\n   * @param {[Number, Number]} pos - position on screen where the pointer is\n   */\n  rotate({\n    pos,\n    deltaAngleX = 0,\n    deltaAngleY = 0\n  }) {\n    const {\n      startRotatePos,\n      startBearing,\n      startPitch\n    } = this.getState();\n    const {\n      width,\n      height\n    } = this.getViewportProps();\n    if (!startRotatePos || startBearing === undefined || startPitch === undefined) {\n      return this;\n    }\n    let newRotation;\n    if (pos) {\n      const deltaScaleX = (pos[0] - startRotatePos[0]) / width;\n      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;\n      newRotation = {\n        bearing: startBearing - deltaScaleX * 180,\n        pitch: startPitch - deltaScaleY * 90\n      };\n    } else {\n      newRotation = {\n        bearing: startBearing - deltaAngleX,\n        pitch: startPitch - deltaAngleY\n      };\n    }\n    return this._getUpdatedState(newRotation);\n  }\n  /**\n   * End rotating\n   * Must call if `rotateStart()` was called\n   */\n  rotateEnd() {\n    return this._getUpdatedState({\n      startRotatePos: null,\n      startBearing: null,\n      startPitch: null\n    });\n  }\n  /**\n   * Start zooming\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  zoomStart() {\n    return this._getUpdatedState({\n      startZoomPosition: this.getViewportProps().position\n    });\n  }\n  /**\n   * Zoom\n   * @param {[Number, Number]} pos - position on screen where the current center is\n   * @param {[Number, Number]} startPos - the center position at\n   *   the start of the operation. Must be supplied of `zoomStart()` was not called\n   * @param {Number} scale - a number between [0, 1] specifying the accumulated\n   *   relative scale.\n   */\n  zoom({\n    pos,\n    scale\n  }) {\n    const viewportProps = this.getViewportProps();\n    const startZoomPosition = this.getState().startZoomPosition || viewportProps.position;\n    const viewport = this.makeViewport(viewportProps);\n    const {\n      projectionMatrix,\n      width\n    } = viewport;\n    const fovxRadians = 2.0 * Math.atan(1.0 / projectionMatrix[0]);\n    const angle = fovxRadians * (pos[0] / width - 0.5);\n    const direction = this.getDirection(true);\n    return this._move(direction.rotateZ({\n      radians: -angle\n    }), Math.log2(scale) * MOVEMENT_SPEED, startZoomPosition);\n  }\n  /**\n   * End zooming\n   * Must call if `zoomStart()` was called\n   */\n  zoomEnd() {\n    return this._getUpdatedState({\n      startZoomPosition: null\n    });\n  }\n  moveLeft(speed = MOVEMENT_SPEED) {\n    const direction = this.getDirection(true);\n    return this._move(direction.rotateZ({\n      radians: Math.PI / 2\n    }), speed);\n  }\n  moveRight(speed = MOVEMENT_SPEED) {\n    const direction = this.getDirection(true);\n    return this._move(direction.rotateZ({\n      radians: -Math.PI / 2\n    }), speed);\n  }\n  // forward\n  moveUp(speed = MOVEMENT_SPEED) {\n    const direction = this.getDirection(true);\n    return this._move(direction, speed);\n  }\n  // backward\n  moveDown(speed = MOVEMENT_SPEED) {\n    const direction = this.getDirection(true);\n    return this._move(direction.negate(), speed);\n  }\n  rotateLeft(speed = 15) {\n    return this._getUpdatedState({\n      bearing: this.getViewportProps().bearing - speed\n    });\n  }\n  rotateRight(speed = 15) {\n    return this._getUpdatedState({\n      bearing: this.getViewportProps().bearing + speed\n    });\n  }\n  rotateUp(speed = 10) {\n    return this._getUpdatedState({\n      pitch: this.getViewportProps().pitch + speed\n    });\n  }\n  rotateDown(speed = 10) {\n    return this._getUpdatedState({\n      pitch: this.getViewportProps().pitch - speed\n    });\n  }\n  zoomIn(speed = MOVEMENT_SPEED) {\n    return this._move(new Vector3(0, 0, 1), speed);\n  }\n  zoomOut(speed = MOVEMENT_SPEED) {\n    return this._move(new Vector3(0, 0, -1), speed);\n  }\n  // shortest path between two view states\n  shortestPathFrom(viewState) {\n    const fromProps = viewState.getViewportProps();\n    const props = {\n      ...this.getViewportProps()\n    };\n    const {\n      bearing,\n      longitude\n    } = props;\n    if (Math.abs(bearing - fromProps.bearing) > 180) {\n      props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;\n    }\n    if (longitude !== null && fromProps.longitude !== null && Math.abs(longitude - fromProps.longitude) > 180) {\n      props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;\n    }\n    return props;\n  }\n  /* Private methods */\n  _move(direction, speed, fromPosition = this.getViewportProps().position) {\n    const delta = direction.scale(speed);\n    return this._getUpdatedState({\n      position: new Vector3(fromPosition).add(delta)\n    });\n  }\n  getDirection(use2D = false) {\n    const spherical = new SphericalCoordinates({\n      bearing: this.getViewportProps().bearing,\n      pitch: use2D ? 90 : 90 + this.getViewportProps().pitch\n    });\n    const direction = spherical.toVector3().normalize();\n    return direction;\n  }\n  _getUpdatedState(newProps) {\n    // Update _viewportProps\n    return new FirstPersonState({\n      makeViewport: this.makeViewport,\n      ...this.getViewportProps(),\n      ...this.getState(),\n      ...newProps\n    });\n  }\n  // Apply any constraints (mathematical or defined by _viewportProps) to map state\n  applyConstraints(props) {\n    // Ensure pitch and zoom are within specified range\n    const {\n      pitch,\n      maxPitch,\n      minPitch,\n      longitude,\n      bearing\n    } = props;\n    props.pitch = clamp(pitch, minPitch, maxPitch);\n    // Normalize degrees\n    if (longitude !== null && (longitude < -180 || longitude > 180)) {\n      props.longitude = mod(longitude + 180, 360) - 180;\n    }\n    if (bearing < -180 || bearing > 180) {\n      props.bearing = mod(bearing + 180, 360) - 180;\n    }\n    return props;\n  }\n}\nexport default class FirstPersonController extends Controller {\n  constructor() {\n    super(...arguments);\n    this.ControllerState = FirstPersonState;\n    this.transition = {\n      transitionDuration: 300,\n      transitionInterpolator: new LinearInterpolator(['position', 'pitch', 'bearing'])\n    };\n  }\n}","map":{"version":3,"names":["Controller","ViewState","mod","LinearInterpolator","Vector3","_SphericalCoordinates","SphericalCoordinates","clamp","MOVEMENT_SPEED","PAN_SPEED","FirstPersonState","constructor","options","width","height","position","bearing","pitch","longitude","latitude","maxPitch","minPitch","startRotatePos","startBearing","startPitch","startZoomPosition","startPanPos","startPanPosition","makeViewport","panStart","pos","getViewportProps","_getUpdatedState","pan","getState","deltaScaleX","deltaScaleY","up","forward","yDirection","toVector3","normalize","xDirection","cross","add","scale","panEnd","rotateStart","rotate","deltaAngleX","deltaAngleY","undefined","newRotation","rotateEnd","zoomStart","zoom","viewportProps","viewport","projectionMatrix","fovxRadians","Math","atan","angle","direction","getDirection","_move","rotateZ","radians","log2","zoomEnd","moveLeft","speed","PI","moveRight","moveUp","moveDown","negate","rotateLeft","rotateRight","rotateUp","rotateDown","zoomIn","zoomOut","shortestPathFrom","viewState","fromProps","props","abs","fromPosition","delta","use2D","spherical","newProps","applyConstraints","FirstPersonController","ControllerState","transition","transitionDuration","transitionInterpolator"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\controllers\\first-person-controller.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport Controller from './controller';\nimport ViewState from './view-state';\nimport {mod} from '../utils/math-utils';\nimport type Viewport from '../viewports/viewport';\nimport LinearInterpolator from '../transitions/linear-interpolator';\n\nimport {Vector3, _SphericalCoordinates as SphericalCoordinates, clamp} from '@math.gl/core';\n\nconst MOVEMENT_SPEED = 20;\nconst PAN_SPEED = 500;\n\ntype FirstPersonStateProps = {\n  width: number;\n  height: number;\n\n  position?: number[];\n  bearing?: number;\n  pitch?: number;\n\n  // Geospatial anchor\n  longitude?: number | null;\n  latitude?: number | null;\n\n  maxPitch?: number;\n  minPitch?: number;\n};\n\ntype FirstPersonStateInternal = {\n  startRotatePos?: [number, number];\n  startBearing?: number;\n  startPitch?: number;\n  startZoomPosition?: number[];\n  startPanPos?: [number, number];\n  startPanPosition?: number[];\n};\n\nclass FirstPersonState extends ViewState<\n  FirstPersonState,\n  FirstPersonStateProps,\n  FirstPersonStateInternal\n> {\n  makeViewport: (props: Record<string, any>) => Viewport;\n\n  constructor(\n    options: FirstPersonStateProps &\n      FirstPersonStateInternal & {\n        makeViewport: (props: Record<string, any>) => Viewport;\n      }\n  ) {\n    const {\n      /* Viewport arguments */\n      width, // Width of viewport\n      height, // Height of viewport\n\n      // Position and orientation\n      position = [0, 0, 0], // typically in meters from anchor point\n\n      bearing = 0, // Rotation around y axis\n      pitch = 0, // Rotation around x axis\n\n      // Geospatial anchor\n      longitude = null,\n      latitude = null,\n\n      maxPitch = 90,\n      minPitch = -90,\n\n      // Model state when the rotate operation first started\n      startRotatePos,\n      startBearing,\n      startPitch,\n      startZoomPosition,\n      startPanPos,\n      startPanPosition\n    } = options;\n\n    super(\n      {\n        width,\n        height,\n        position,\n        bearing,\n        pitch,\n        longitude,\n        latitude,\n        maxPitch,\n        minPitch\n      },\n      {\n        startRotatePos,\n        startBearing,\n        startPitch,\n        startZoomPosition,\n        startPanPos,\n        startPanPosition\n      }\n    );\n\n    this.makeViewport = options.makeViewport;\n  }\n\n  /* Public API */\n\n  /**\n   * Start panning\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  panStart({pos}): FirstPersonState {\n    const {position} = this.getViewportProps();\n    return this._getUpdatedState({\n      startPanPos: pos,\n      startPanPosition: position\n    });\n  }\n\n  /**\n   * Pan\n   * @param {[Number, Number]} pos - position on screen where the pointer is\n   */\n  pan({pos}): FirstPersonState {\n    if (!pos) {\n      return this;\n    }\n    const {startPanPos = [0, 0], startPanPosition = [0, 0]} = this.getState();\n    const {width, height, bearing, pitch} = this.getViewportProps();\n    const deltaScaleX = (PAN_SPEED * (pos[0] - startPanPos[0])) / width;\n    const deltaScaleY = (PAN_SPEED * (pos[1] - startPanPos[1])) / height;\n\n    const up = new SphericalCoordinates({bearing, pitch});\n    const forward = new SphericalCoordinates({bearing, pitch: -90});\n    const yDirection = up.toVector3().normalize();\n    const xDirection = forward.toVector3().cross(yDirection).normalize();\n\n    return this._getUpdatedState({\n      position: new Vector3(startPanPosition)\n        .add(xDirection.scale(deltaScaleX))\n        .add(yDirection.scale(deltaScaleY))\n    });\n  }\n\n  /**\n   * End panning\n   * Must call if `panStart()` was called\n   */\n  panEnd(): FirstPersonState {\n    return this._getUpdatedState({\n      startPanPos: null,\n      startPanPosition: null\n    });\n  }\n\n  /**\n   * Start rotating\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  rotateStart({pos}: {pos: [number, number]}): FirstPersonState {\n    return this._getUpdatedState({\n      startRotatePos: pos,\n      startBearing: this.getViewportProps().bearing,\n      startPitch: this.getViewportProps().pitch\n    });\n  }\n\n  /**\n   * Rotate\n   * @param {[Number, Number]} pos - position on screen where the pointer is\n   */\n  rotate({\n    pos,\n    deltaAngleX = 0,\n    deltaAngleY = 0\n  }: {\n    pos?: [number, number];\n    deltaAngleX?: number;\n    deltaAngleY: number;\n  }): FirstPersonState {\n    const {startRotatePos, startBearing, startPitch} = this.getState();\n    const {width, height} = this.getViewportProps();\n\n    if (!startRotatePos || startBearing === undefined || startPitch === undefined) {\n      return this;\n    }\n\n    let newRotation;\n    if (pos) {\n      const deltaScaleX = (pos[0] - startRotatePos[0]) / width;\n      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;\n      newRotation = {\n        bearing: startBearing - deltaScaleX * 180,\n        pitch: startPitch - deltaScaleY * 90\n      };\n    } else {\n      newRotation = {\n        bearing: startBearing - deltaAngleX,\n        pitch: startPitch - deltaAngleY\n      };\n    }\n\n    return this._getUpdatedState(newRotation);\n  }\n\n  /**\n   * End rotating\n   * Must call if `rotateStart()` was called\n   */\n  rotateEnd(): FirstPersonState {\n    return this._getUpdatedState({\n      startRotatePos: null,\n      startBearing: null,\n      startPitch: null\n    });\n  }\n\n  /**\n   * Start zooming\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  zoomStart(): FirstPersonState {\n    return this._getUpdatedState({\n      startZoomPosition: this.getViewportProps().position\n    });\n  }\n\n  /**\n   * Zoom\n   * @param {[Number, Number]} pos - position on screen where the current center is\n   * @param {[Number, Number]} startPos - the center position at\n   *   the start of the operation. Must be supplied of `zoomStart()` was not called\n   * @param {Number} scale - a number between [0, 1] specifying the accumulated\n   *   relative scale.\n   */\n  zoom({pos, scale}: {pos: [number, number]; scale: number}): FirstPersonState {\n    const viewportProps = this.getViewportProps();\n    const startZoomPosition = this.getState().startZoomPosition || viewportProps.position;\n    const viewport = this.makeViewport(viewportProps);\n    const {projectionMatrix, width} = viewport;\n    const fovxRadians = 2.0 * Math.atan(1.0 / projectionMatrix[0]);\n    const angle = fovxRadians * (pos[0] / width - 0.5);\n\n    const direction = this.getDirection(true);\n    return this._move(\n      direction.rotateZ({radians: -angle}),\n      Math.log2(scale) * MOVEMENT_SPEED,\n      startZoomPosition\n    );\n  }\n\n  /**\n   * End zooming\n   * Must call if `zoomStart()` was called\n   */\n  zoomEnd(): FirstPersonState {\n    return this._getUpdatedState({\n      startZoomPosition: null\n    });\n  }\n\n  moveLeft(speed: number = MOVEMENT_SPEED): FirstPersonState {\n    const direction = this.getDirection(true);\n    return this._move(direction.rotateZ({radians: Math.PI / 2}), speed);\n  }\n\n  moveRight(speed: number = MOVEMENT_SPEED): FirstPersonState {\n    const direction = this.getDirection(true);\n    return this._move(direction.rotateZ({radians: -Math.PI / 2}), speed);\n  }\n\n  // forward\n  moveUp(speed: number = MOVEMENT_SPEED): FirstPersonState {\n    const direction = this.getDirection(true);\n    return this._move(direction, speed);\n  }\n\n  // backward\n  moveDown(speed: number = MOVEMENT_SPEED): FirstPersonState {\n    const direction = this.getDirection(true);\n    return this._move(direction.negate(), speed);\n  }\n\n  rotateLeft(speed: number = 15): FirstPersonState {\n    return this._getUpdatedState({\n      bearing: this.getViewportProps().bearing - speed\n    });\n  }\n\n  rotateRight(speed: number = 15): FirstPersonState {\n    return this._getUpdatedState({\n      bearing: this.getViewportProps().bearing + speed\n    });\n  }\n\n  rotateUp(speed: number = 10): FirstPersonState {\n    return this._getUpdatedState({\n      pitch: this.getViewportProps().pitch + speed\n    });\n  }\n\n  rotateDown(speed: number = 10): FirstPersonState {\n    return this._getUpdatedState({\n      pitch: this.getViewportProps().pitch - speed\n    });\n  }\n\n  zoomIn(speed: number = MOVEMENT_SPEED): FirstPersonState {\n    return this._move(new Vector3(0, 0, 1), speed);\n  }\n\n  zoomOut(speed: number = MOVEMENT_SPEED): FirstPersonState {\n    return this._move(new Vector3(0, 0, -1), speed);\n  }\n\n  // shortest path between two view states\n  shortestPathFrom(viewState: FirstPersonState) {\n    const fromProps = viewState.getViewportProps();\n    const props = {...this.getViewportProps()};\n    const {bearing, longitude} = props;\n\n    if (Math.abs(bearing - fromProps.bearing) > 180) {\n      props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;\n    }\n    if (\n      longitude !== null &&\n      fromProps.longitude !== null &&\n      Math.abs(longitude - fromProps.longitude) > 180\n    ) {\n      props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;\n    }\n    return props;\n  }\n\n  /* Private methods */\n  _move(\n    direction: Vector3,\n    speed: number,\n    fromPosition: number[] = this.getViewportProps().position\n  ) {\n    const delta = direction.scale(speed);\n    return this._getUpdatedState({\n      position: new Vector3(fromPosition).add(delta)\n    });\n  }\n\n  getDirection(use2D: boolean = false): Vector3 {\n    const spherical = new SphericalCoordinates({\n      bearing: this.getViewportProps().bearing,\n      pitch: use2D ? 90 : 90 + this.getViewportProps().pitch\n    });\n    const direction = spherical.toVector3().normalize();\n    return direction;\n  }\n\n  _getUpdatedState(newProps: Record<string, any>): FirstPersonState {\n    // Update _viewportProps\n    return new FirstPersonState({\n      makeViewport: this.makeViewport,\n      ...this.getViewportProps(),\n      ...this.getState(),\n      ...newProps\n    });\n  }\n\n  // Apply any constraints (mathematical or defined by _viewportProps) to map state\n  applyConstraints(props: Required<FirstPersonStateProps>): Required<FirstPersonStateProps> {\n    // Ensure pitch and zoom are within specified range\n    const {pitch, maxPitch, minPitch, longitude, bearing} = props;\n    props.pitch = clamp(pitch, minPitch, maxPitch);\n\n    // Normalize degrees\n    if (longitude !== null && (longitude < -180 || longitude > 180)) {\n      props.longitude = mod(longitude + 180, 360) - 180;\n    }\n    if (bearing < -180 || bearing > 180) {\n      props.bearing = mod(bearing + 180, 360) - 180;\n    }\n\n    return props;\n  }\n}\n\nexport default class FirstPersonController extends Controller<FirstPersonState> {\n  ControllerState = FirstPersonState;\n\n  transition = {\n    transitionDuration: 300,\n    transitionInterpolator: new LinearInterpolator(['position', 'pitch', 'bearing'])\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}