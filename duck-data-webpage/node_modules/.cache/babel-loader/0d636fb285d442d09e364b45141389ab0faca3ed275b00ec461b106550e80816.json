{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { selectLoaderSync } from \"./select-loader.js\";\nimport { isLoaderObject } from \"../loader-utils/normalize-loader.js\";\nimport { normalizeOptions } from \"../loader-utils/option-utils.js\";\nimport { getArrayBufferOrStringFromDataSync } from \"../loader-utils/get-data.js\";\nimport { getLoaderContext, getLoadersFromContext } from \"../loader-utils/loader-context.js\";\nimport { getResourceUrl } from \"../utils/resource-utils.js\";\n/**\n * Parses `data` synchronously using a specified loader\n */\nexport function parseSync(data, loaders, options, context) {\n  // Signature: parseSync(data, options)\n  // Uses registered loaders\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined; // context not supported in short signature\n    options = loaders;\n    loaders = undefined;\n  }\n  options = options || {};\n  // Chooses a loader (and normalizes it)\n  // Also use any loaders in the context, new loaders take priority\n  const typedLoaders = loaders;\n  const candidateLoaders = getLoadersFromContext(typedLoaders, context);\n  const loader = selectLoaderSync(data, candidateLoaders, options);\n  // Note: if nothrow option was set, it is possible that no loader was found, if so just return null\n  if (!loader) {\n    return null;\n  }\n  // Normalize options\n  options = normalizeOptions(options, loader, candidateLoaders);\n  // Extract a url for auto detection\n  const url = getResourceUrl(data);\n  const parse = () => {\n    throw new Error('parseSync called parse (which is async');\n  };\n  context = getLoaderContext({\n    url,\n    _parseSync: parse,\n    _parse: parse,\n    loaders: loaders\n  }, options, context || null);\n  return parseWithLoaderSync(loader, data, options, context);\n}\n// TODO - should accept loader.parseSync/parse and generate 1 chunk asyncIterator\nfunction parseWithLoaderSync(loader, data, options, context) {\n  data = getArrayBufferOrStringFromDataSync(data, loader, options);\n  if (loader.parseTextSync && typeof data === 'string') {\n    return loader.parseTextSync(data, options); // , context, loader);\n  }\n  if (loader.parseSync && data instanceof ArrayBuffer) {\n    return loader.parseSync(data, options, context); // , loader);\n  }\n  // TBD - If synchronous parser not available, return null\n  throw new Error(`${loader.name} loader: 'parseSync' not supported by this loader, use 'parse' instead. ${context.url || ''}`);\n}","map":{"version":3,"names":["selectLoaderSync","isLoaderObject","normalizeOptions","getArrayBufferOrStringFromDataSync","getLoaderContext","getLoadersFromContext","getResourceUrl","parseSync","data","loaders","options","context","Array","isArray","undefined","typedLoaders","candidateLoaders","loader","url","parse","Error","_parseSync","_parse","parseWithLoaderSync","parseTextSync","ArrayBuffer","name"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/core/dist/lib/api/parse-sync.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { selectLoaderSync } from \"./select-loader.js\";\nimport { isLoaderObject } from \"../loader-utils/normalize-loader.js\";\nimport { normalizeOptions } from \"../loader-utils/option-utils.js\";\nimport { getArrayBufferOrStringFromDataSync } from \"../loader-utils/get-data.js\";\nimport { getLoaderContext, getLoadersFromContext } from \"../loader-utils/loader-context.js\";\nimport { getResourceUrl } from \"../utils/resource-utils.js\";\n/**\n * Parses `data` synchronously using a specified loader\n */\nexport function parseSync(data, loaders, options, context) {\n    // Signature: parseSync(data, options)\n    // Uses registered loaders\n    if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n        context = undefined; // context not supported in short signature\n        options = loaders;\n        loaders = undefined;\n    }\n    options = options || {};\n    // Chooses a loader (and normalizes it)\n    // Also use any loaders in the context, new loaders take priority\n    const typedLoaders = loaders;\n    const candidateLoaders = getLoadersFromContext(typedLoaders, context);\n    const loader = selectLoaderSync(data, candidateLoaders, options);\n    // Note: if nothrow option was set, it is possible that no loader was found, if so just return null\n    if (!loader) {\n        return null;\n    }\n    // Normalize options\n    options = normalizeOptions(options, loader, candidateLoaders);\n    // Extract a url for auto detection\n    const url = getResourceUrl(data);\n    const parse = () => {\n        throw new Error('parseSync called parse (which is async');\n    };\n    context = getLoaderContext({ url, _parseSync: parse, _parse: parse, loaders: loaders }, options, context || null);\n    return parseWithLoaderSync(loader, data, options, context);\n}\n// TODO - should accept loader.parseSync/parse and generate 1 chunk asyncIterator\nfunction parseWithLoaderSync(loader, data, options, context) {\n    data = getArrayBufferOrStringFromDataSync(data, loader, options);\n    if (loader.parseTextSync && typeof data === 'string') {\n        return loader.parseTextSync(data, options); // , context, loader);\n    }\n    if (loader.parseSync && data instanceof ArrayBuffer) {\n        return loader.parseSync(data, options, context); // , loader);\n    }\n    // TBD - If synchronous parser not available, return null\n    throw new Error(`${loader.name} loader: 'parseSync' not supported by this loader, use 'parse' instead. ${context.url || ''}`);\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,gBAAgB,QAAQ,oBAAoB;AACrD,SAASC,cAAc,QAAQ,qCAAqC;AACpE,SAASC,gBAAgB,QAAQ,iCAAiC;AAClE,SAASC,kCAAkC,QAAQ,6BAA6B;AAChF,SAASC,gBAAgB,EAAEC,qBAAqB,QAAQ,mCAAmC;AAC3F,SAASC,cAAc,QAAQ,4BAA4B;AAC3D;AACA;AACA;AACA,OAAO,SAASC,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAEC,OAAO,EAAEC,OAAO,EAAE;EACvD;EACA;EACA,IAAI,CAACC,KAAK,CAACC,OAAO,CAACJ,OAAO,CAAC,IAAI,CAACR,cAAc,CAACQ,OAAO,CAAC,EAAE;IACrDE,OAAO,GAAGG,SAAS,CAAC,CAAC;IACrBJ,OAAO,GAAGD,OAAO;IACjBA,OAAO,GAAGK,SAAS;EACvB;EACAJ,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB;EACA;EACA,MAAMK,YAAY,GAAGN,OAAO;EAC5B,MAAMO,gBAAgB,GAAGX,qBAAqB,CAACU,YAAY,EAAEJ,OAAO,CAAC;EACrE,MAAMM,MAAM,GAAGjB,gBAAgB,CAACQ,IAAI,EAAEQ,gBAAgB,EAAEN,OAAO,CAAC;EAChE;EACA,IAAI,CAACO,MAAM,EAAE;IACT,OAAO,IAAI;EACf;EACA;EACAP,OAAO,GAAGR,gBAAgB,CAACQ,OAAO,EAAEO,MAAM,EAAED,gBAAgB,CAAC;EAC7D;EACA,MAAME,GAAG,GAAGZ,cAAc,CAACE,IAAI,CAAC;EAChC,MAAMW,KAAK,GAAGA,CAAA,KAAM;IAChB,MAAM,IAAIC,KAAK,CAAC,wCAAwC,CAAC;EAC7D,CAAC;EACDT,OAAO,GAAGP,gBAAgB,CAAC;IAAEc,GAAG;IAAEG,UAAU,EAAEF,KAAK;IAAEG,MAAM,EAAEH,KAAK;IAAEV,OAAO,EAAEA;EAAQ,CAAC,EAAEC,OAAO,EAAEC,OAAO,IAAI,IAAI,CAAC;EACjH,OAAOY,mBAAmB,CAACN,MAAM,EAAET,IAAI,EAAEE,OAAO,EAAEC,OAAO,CAAC;AAC9D;AACA;AACA,SAASY,mBAAmBA,CAACN,MAAM,EAAET,IAAI,EAAEE,OAAO,EAAEC,OAAO,EAAE;EACzDH,IAAI,GAAGL,kCAAkC,CAACK,IAAI,EAAES,MAAM,EAAEP,OAAO,CAAC;EAChE,IAAIO,MAAM,CAACO,aAAa,IAAI,OAAOhB,IAAI,KAAK,QAAQ,EAAE;IAClD,OAAOS,MAAM,CAACO,aAAa,CAAChB,IAAI,EAAEE,OAAO,CAAC,CAAC,CAAC;EAChD;EACA,IAAIO,MAAM,CAACV,SAAS,IAAIC,IAAI,YAAYiB,WAAW,EAAE;IACjD,OAAOR,MAAM,CAACV,SAAS,CAACC,IAAI,EAAEE,OAAO,EAAEC,OAAO,CAAC,CAAC,CAAC;EACrD;EACA;EACA,MAAM,IAAIS,KAAK,CAAC,GAAGH,MAAM,CAACS,IAAI,2EAA2Ef,OAAO,CAACO,GAAG,IAAI,EAAE,EAAE,CAAC;AACjI","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}