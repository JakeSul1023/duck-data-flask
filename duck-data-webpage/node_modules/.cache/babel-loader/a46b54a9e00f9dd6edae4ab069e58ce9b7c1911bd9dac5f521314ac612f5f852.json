{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { COORDINATE_SYSTEM, createIterable } from '@deck.gl/core';\n/* eslint-disable max-statements, complexity, camelcase */\nconst RADIAN_PER_DEGREE = Math.PI / 180;\nconst modelMatrix = new Float32Array(16);\nconst valueArray = new Float32Array(12);\nfunction calculateTransformMatrix(targetMatrix, orientation, scale) {\n  const pitch = orientation[0] * RADIAN_PER_DEGREE;\n  const yaw = orientation[1] * RADIAN_PER_DEGREE;\n  const roll = orientation[2] * RADIAN_PER_DEGREE;\n  const sr = Math.sin(roll);\n  const sp = Math.sin(pitch);\n  const sw = Math.sin(yaw);\n  const cr = Math.cos(roll);\n  const cp = Math.cos(pitch);\n  const cw = Math.cos(yaw);\n  const scx = scale[0];\n  const scy = scale[1];\n  const scz = scale[2];\n  targetMatrix[0] = scx * cw * cp; // 0,0\n  targetMatrix[1] = scx * sw * cp; // 1,0\n  targetMatrix[2] = scx * -sp; // 2,0\n  targetMatrix[3] = scy * (-sw * cr + cw * sp * sr); // 0,1\n  targetMatrix[4] = scy * (cw * cr + sw * sp * sr); // 1,1\n  targetMatrix[5] = scy * cp * sr; // 2,1\n  targetMatrix[6] = scz * (sw * sr + cw * sp * cr); // 0,2\n  targetMatrix[7] = scz * (-cw * sr + sw * sp * cr); // 1,2\n  targetMatrix[8] = scz * cp * cr; // 2,2\n}\nfunction getExtendedMat3FromMat4(mat4) {\n  mat4[0] = mat4[0];\n  mat4[1] = mat4[1];\n  mat4[2] = mat4[2];\n  mat4[3] = mat4[4];\n  mat4[4] = mat4[5];\n  mat4[5] = mat4[6];\n  mat4[6] = mat4[8];\n  mat4[7] = mat4[9];\n  mat4[8] = mat4[10];\n  mat4[9] = mat4[12];\n  mat4[10] = mat4[13];\n  mat4[11] = mat4[14];\n  return mat4.subarray(0, 12);\n}\nexport const MATRIX_ATTRIBUTES = {\n  size: 12,\n  accessor: ['getOrientation', 'getScale', 'getTranslation', 'getTransformMatrix'],\n  shaderAttributes: {\n    instanceModelMatrixCol0: {\n      size: 3,\n      elementOffset: 0\n    },\n    instanceModelMatrixCol1: {\n      size: 3,\n      elementOffset: 3\n    },\n    instanceModelMatrixCol2: {\n      size: 3,\n      elementOffset: 6\n    },\n    instanceTranslation: {\n      size: 3,\n      elementOffset: 9\n    }\n  },\n  update(attribute, {\n    startRow,\n    endRow\n  }) {\n    // @ts-expect-error: \"this\" will be bound to a layer when this  function is called\n    const {\n      data,\n      getOrientation,\n      getScale,\n      getTranslation,\n      getTransformMatrix\n    } = this.props;\n    const arrayMatrix = Array.isArray(getTransformMatrix);\n    const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;\n    const constantScale = Array.isArray(getScale);\n    const constantOrientation = Array.isArray(getOrientation);\n    const constantTranslation = Array.isArray(getTranslation);\n    const hasMatrix = constantMatrix || !arrayMatrix && Boolean(getTransformMatrix(data[0]));\n    if (hasMatrix) {\n      attribute.constant = constantMatrix;\n    } else {\n      attribute.constant = constantOrientation && constantScale && constantTranslation;\n    }\n    const instanceModelMatrixData = attribute.value;\n    if (attribute.constant) {\n      let matrix;\n      if (hasMatrix) {\n        modelMatrix.set(getTransformMatrix);\n        matrix = getExtendedMat3FromMat4(modelMatrix);\n      } else {\n        matrix = valueArray;\n        const orientation = getOrientation;\n        const scale = getScale;\n        calculateTransformMatrix(matrix, orientation, scale);\n        matrix.set(getTranslation, 9);\n      }\n      attribute.value = new Float32Array(matrix);\n    } else {\n      let i = startRow * attribute.size;\n      const {\n        iterable,\n        objectInfo\n      } = createIterable(data, startRow, endRow);\n      for (const object of iterable) {\n        objectInfo.index++;\n        let matrix;\n        if (hasMatrix) {\n          modelMatrix.set(constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo));\n          matrix = getExtendedMat3FromMat4(modelMatrix);\n        } else {\n          matrix = valueArray;\n          const orientation = constantOrientation ? getOrientation : getOrientation(object, objectInfo);\n          const scale = constantScale ? getScale : getScale(object, objectInfo);\n          calculateTransformMatrix(matrix, orientation, scale);\n          matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);\n        }\n        instanceModelMatrixData[i++] = matrix[0];\n        instanceModelMatrixData[i++] = matrix[1];\n        instanceModelMatrixData[i++] = matrix[2];\n        instanceModelMatrixData[i++] = matrix[3];\n        instanceModelMatrixData[i++] = matrix[4];\n        instanceModelMatrixData[i++] = matrix[5];\n        instanceModelMatrixData[i++] = matrix[6];\n        instanceModelMatrixData[i++] = matrix[7];\n        instanceModelMatrixData[i++] = matrix[8];\n        instanceModelMatrixData[i++] = matrix[9];\n        instanceModelMatrixData[i++] = matrix[10];\n        instanceModelMatrixData[i++] = matrix[11];\n      }\n    }\n  }\n};\n// only apply composeModelMatrix when in cartesian or meter_offsets coordinate system\n// with `composeModelMatrix` enabled, the rotation part of the layer's modelMatrix will be composed to instance's transformations\n// since rotating latitude and longitude can not provide meaningful results, hence `composeModelMatrix` is disabled\n// when in LNGLAT and LNGLAT_OFFSET coordinates.\nexport function shouldComposeModelMatrix(viewport, coordinateSystem) {\n  return coordinateSystem === COORDINATE_SYSTEM.CARTESIAN || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial;\n}","map":{"version":3,"names":["COORDINATE_SYSTEM","createIterable","RADIAN_PER_DEGREE","Math","PI","modelMatrix","Float32Array","valueArray","calculateTransformMatrix","targetMatrix","orientation","scale","pitch","yaw","roll","sr","sin","sp","sw","cr","cos","cp","cw","scx","scy","scz","getExtendedMat3FromMat4","mat4","subarray","MATRIX_ATTRIBUTES","size","accessor","shaderAttributes","instanceModelMatrixCol0","elementOffset","instanceModelMatrixCol1","instanceModelMatrixCol2","instanceTranslation","update","attribute","startRow","endRow","data","getOrientation","getScale","getTranslation","getTransformMatrix","props","arrayMatrix","Array","isArray","constantMatrix","length","constantScale","constantOrientation","constantTranslation","hasMatrix","Boolean","constant","instanceModelMatrixData","value","matrix","set","i","iterable","objectInfo","object","index","shouldComposeModelMatrix","viewport","coordinateSystem","CARTESIAN","METER_OFFSETS","DEFAULT","isGeospatial"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\mesh-layers\\src\\utils\\matrix.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {COORDINATE_SYSTEM, createIterable} from '@deck.gl/core';\n\n/* eslint-disable max-statements, complexity, camelcase */\nconst RADIAN_PER_DEGREE = Math.PI / 180;\nconst modelMatrix = new Float32Array(16);\nconst valueArray = new Float32Array(12);\n\nfunction calculateTransformMatrix(targetMatrix, orientation, scale) {\n  const pitch = orientation[0] * RADIAN_PER_DEGREE;\n  const yaw = orientation[1] * RADIAN_PER_DEGREE;\n  const roll = orientation[2] * RADIAN_PER_DEGREE;\n\n  const sr = Math.sin(roll);\n  const sp = Math.sin(pitch);\n  const sw = Math.sin(yaw);\n\n  const cr = Math.cos(roll);\n  const cp = Math.cos(pitch);\n  const cw = Math.cos(yaw);\n\n  const scx = scale[0];\n  const scy = scale[1];\n  const scz = scale[2];\n\n  targetMatrix[0] = scx * cw * cp; // 0,0\n  targetMatrix[1] = scx * sw * cp; // 1,0\n  targetMatrix[2] = scx * -sp; // 2,0\n  targetMatrix[3] = scy * (-sw * cr + cw * sp * sr); // 0,1\n  targetMatrix[4] = scy * (cw * cr + sw * sp * sr); // 1,1\n  targetMatrix[5] = scy * cp * sr; // 2,1\n  targetMatrix[6] = scz * (sw * sr + cw * sp * cr); // 0,2\n  targetMatrix[7] = scz * (-cw * sr + sw * sp * cr); // 1,2\n  targetMatrix[8] = scz * cp * cr; // 2,2\n}\n\nfunction getExtendedMat3FromMat4(mat4) {\n  mat4[0] = mat4[0];\n  mat4[1] = mat4[1];\n  mat4[2] = mat4[2];\n  mat4[3] = mat4[4];\n  mat4[4] = mat4[5];\n  mat4[5] = mat4[6];\n  mat4[6] = mat4[8];\n  mat4[7] = mat4[9];\n  mat4[8] = mat4[10];\n  mat4[9] = mat4[12];\n  mat4[10] = mat4[13];\n  mat4[11] = mat4[14];\n\n  return mat4.subarray(0, 12);\n}\n\nexport const MATRIX_ATTRIBUTES = {\n  size: 12,\n  accessor: ['getOrientation', 'getScale', 'getTranslation', 'getTransformMatrix'],\n  shaderAttributes: {\n    instanceModelMatrixCol0: {\n      size: 3,\n      elementOffset: 0\n    },\n    instanceModelMatrixCol1: {\n      size: 3,\n      elementOffset: 3\n    },\n    instanceModelMatrixCol2: {\n      size: 3,\n      elementOffset: 6\n    },\n    instanceTranslation: {\n      size: 3,\n      elementOffset: 9\n    }\n  } as const,\n\n  update(attribute, {startRow, endRow}) {\n    // @ts-expect-error: \"this\" will be bound to a layer when this  function is called\n    const {data, getOrientation, getScale, getTranslation, getTransformMatrix} = this.props;\n\n    const arrayMatrix = Array.isArray(getTransformMatrix);\n    const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;\n    const constantScale = Array.isArray(getScale);\n    const constantOrientation = Array.isArray(getOrientation);\n    const constantTranslation = Array.isArray(getTranslation);\n\n    const hasMatrix = constantMatrix || (!arrayMatrix && Boolean(getTransformMatrix(data[0])));\n\n    if (hasMatrix) {\n      attribute.constant = constantMatrix;\n    } else {\n      attribute.constant = constantOrientation && constantScale && constantTranslation;\n    }\n\n    const instanceModelMatrixData = attribute.value;\n\n    if (attribute.constant) {\n      let matrix;\n\n      if (hasMatrix) {\n        modelMatrix.set(getTransformMatrix);\n        matrix = getExtendedMat3FromMat4(modelMatrix);\n      } else {\n        matrix = valueArray;\n\n        const orientation = getOrientation;\n        const scale = getScale;\n\n        calculateTransformMatrix(matrix, orientation, scale);\n        matrix.set(getTranslation, 9);\n      }\n\n      attribute.value = new Float32Array(matrix);\n    } else {\n      let i = startRow * attribute.size;\n      const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n      for (const object of iterable) {\n        objectInfo.index++;\n        let matrix;\n\n        if (hasMatrix) {\n          modelMatrix.set(\n            constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo)\n          );\n          matrix = getExtendedMat3FromMat4(modelMatrix);\n        } else {\n          matrix = valueArray;\n\n          const orientation = constantOrientation\n            ? getOrientation\n            : getOrientation(object, objectInfo);\n          const scale = constantScale ? getScale : getScale(object, objectInfo);\n\n          calculateTransformMatrix(matrix, orientation, scale);\n          matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);\n        }\n\n        instanceModelMatrixData[i++] = matrix[0];\n        instanceModelMatrixData[i++] = matrix[1];\n        instanceModelMatrixData[i++] = matrix[2];\n        instanceModelMatrixData[i++] = matrix[3];\n        instanceModelMatrixData[i++] = matrix[4];\n        instanceModelMatrixData[i++] = matrix[5];\n        instanceModelMatrixData[i++] = matrix[6];\n        instanceModelMatrixData[i++] = matrix[7];\n        instanceModelMatrixData[i++] = matrix[8];\n        instanceModelMatrixData[i++] = matrix[9];\n        instanceModelMatrixData[i++] = matrix[10];\n        instanceModelMatrixData[i++] = matrix[11];\n      }\n    }\n  }\n};\n\n// only apply composeModelMatrix when in cartesian or meter_offsets coordinate system\n// with `composeModelMatrix` enabled, the rotation part of the layer's modelMatrix will be composed to instance's transformations\n// since rotating latitude and longitude can not provide meaningful results, hence `composeModelMatrix` is disabled\n// when in LNGLAT and LNGLAT_OFFSET coordinates.\nexport function shouldComposeModelMatrix(viewport, coordinateSystem) {\n  return (\n    coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ||\n    coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS ||\n    (coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial)\n  );\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA,SAAQA,iBAAiB,EAAEC,cAAc,QAAO,eAAe;AAE/D;AACA,MAAMC,iBAAiB,GAAGC,IAAI,CAACC,EAAE,GAAG,GAAG;AACvC,MAAMC,WAAW,GAAG,IAAIC,YAAY,CAAC,EAAE,CAAC;AACxC,MAAMC,UAAU,GAAG,IAAID,YAAY,CAAC,EAAE,CAAC;AAEvC,SAASE,wBAAwBA,CAACC,YAAY,EAAEC,WAAW,EAAEC,KAAK;EAChE,MAAMC,KAAK,GAAGF,WAAW,CAAC,CAAC,CAAC,GAAGR,iBAAiB;EAChD,MAAMW,GAAG,GAAGH,WAAW,CAAC,CAAC,CAAC,GAAGR,iBAAiB;EAC9C,MAAMY,IAAI,GAAGJ,WAAW,CAAC,CAAC,CAAC,GAAGR,iBAAiB;EAE/C,MAAMa,EAAE,GAAGZ,IAAI,CAACa,GAAG,CAACF,IAAI,CAAC;EACzB,MAAMG,EAAE,GAAGd,IAAI,CAACa,GAAG,CAACJ,KAAK,CAAC;EAC1B,MAAMM,EAAE,GAAGf,IAAI,CAACa,GAAG,CAACH,GAAG,CAAC;EAExB,MAAMM,EAAE,GAAGhB,IAAI,CAACiB,GAAG,CAACN,IAAI,CAAC;EACzB,MAAMO,EAAE,GAAGlB,IAAI,CAACiB,GAAG,CAACR,KAAK,CAAC;EAC1B,MAAMU,EAAE,GAAGnB,IAAI,CAACiB,GAAG,CAACP,GAAG,CAAC;EAExB,MAAMU,GAAG,GAAGZ,KAAK,CAAC,CAAC,CAAC;EACpB,MAAMa,GAAG,GAAGb,KAAK,CAAC,CAAC,CAAC;EACpB,MAAMc,GAAG,GAAGd,KAAK,CAAC,CAAC,CAAC;EAEpBF,YAAY,CAAC,CAAC,CAAC,GAAGc,GAAG,GAAGD,EAAE,GAAGD,EAAE,CAAC,CAAC;EACjCZ,YAAY,CAAC,CAAC,CAAC,GAAGc,GAAG,GAAGL,EAAE,GAAGG,EAAE,CAAC,CAAC;EACjCZ,YAAY,CAAC,CAAC,CAAC,GAAGc,GAAG,GAAG,CAACN,EAAE,CAAC,CAAC;EAC7BR,YAAY,CAAC,CAAC,CAAC,GAAGe,GAAG,IAAI,CAACN,EAAE,GAAGC,EAAE,GAAGG,EAAE,GAAGL,EAAE,GAAGF,EAAE,CAAC,CAAC,CAAC;EACnDN,YAAY,CAAC,CAAC,CAAC,GAAGe,GAAG,IAAIF,EAAE,GAAGH,EAAE,GAAGD,EAAE,GAAGD,EAAE,GAAGF,EAAE,CAAC,CAAC,CAAC;EAClDN,YAAY,CAAC,CAAC,CAAC,GAAGe,GAAG,GAAGH,EAAE,GAAGN,EAAE,CAAC,CAAC;EACjCN,YAAY,CAAC,CAAC,CAAC,GAAGgB,GAAG,IAAIP,EAAE,GAAGH,EAAE,GAAGO,EAAE,GAAGL,EAAE,GAAGE,EAAE,CAAC,CAAC,CAAC;EAClDV,YAAY,CAAC,CAAC,CAAC,GAAGgB,GAAG,IAAI,CAACH,EAAE,GAAGP,EAAE,GAAGG,EAAE,GAAGD,EAAE,GAAGE,EAAE,CAAC,CAAC,CAAC;EACnDV,YAAY,CAAC,CAAC,CAAC,GAAGgB,GAAG,GAAGJ,EAAE,GAAGF,EAAE,CAAC,CAAC;AACnC;AAEA,SAASO,uBAAuBA,CAACC,IAAI;EACnCA,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;EACjBA,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;EACjBA,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;EACjBA,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;EACjBA,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;EACjBA,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;EACjBA,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;EACjBA,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC;EACjBA,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,EAAE,CAAC;EAClBA,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,EAAE,CAAC;EAClBA,IAAI,CAAC,EAAE,CAAC,GAAGA,IAAI,CAAC,EAAE,CAAC;EACnBA,IAAI,CAAC,EAAE,CAAC,GAAGA,IAAI,CAAC,EAAE,CAAC;EAEnB,OAAOA,IAAI,CAACC,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC;AAC7B;AAEA,OAAO,MAAMC,iBAAiB,GAAG;EAC/BC,IAAI,EAAE,EAAE;EACRC,QAAQ,EAAE,CAAC,gBAAgB,EAAE,UAAU,EAAE,gBAAgB,EAAE,oBAAoB,CAAC;EAChFC,gBAAgB,EAAE;IAChBC,uBAAuB,EAAE;MACvBH,IAAI,EAAE,CAAC;MACPI,aAAa,EAAE;KAChB;IACDC,uBAAuB,EAAE;MACvBL,IAAI,EAAE,CAAC;MACPI,aAAa,EAAE;KAChB;IACDE,uBAAuB,EAAE;MACvBN,IAAI,EAAE,CAAC;MACPI,aAAa,EAAE;KAChB;IACDG,mBAAmB,EAAE;MACnBP,IAAI,EAAE,CAAC;MACPI,aAAa,EAAE;;GAET;EAEVI,MAAMA,CAACC,SAAS,EAAE;IAACC,QAAQ;IAAEC;EAAM,CAAC;IAClC;IACA,MAAM;MAACC,IAAI;MAAEC,cAAc;MAAEC,QAAQ;MAAEC,cAAc;MAAEC;IAAkB,CAAC,GAAG,IAAI,CAACC,KAAK;IAEvF,MAAMC,WAAW,GAAGC,KAAK,CAACC,OAAO,CAACJ,kBAAkB,CAAC;IACrD,MAAMK,cAAc,GAAGH,WAAW,IAAIF,kBAAkB,CAACM,MAAM,KAAK,EAAE;IACtE,MAAMC,aAAa,GAAGJ,KAAK,CAACC,OAAO,CAACN,QAAQ,CAAC;IAC7C,MAAMU,mBAAmB,GAAGL,KAAK,CAACC,OAAO,CAACP,cAAc,CAAC;IACzD,MAAMY,mBAAmB,GAAGN,KAAK,CAACC,OAAO,CAACL,cAAc,CAAC;IAEzD,MAAMW,SAAS,GAAGL,cAAc,IAAK,CAACH,WAAW,IAAIS,OAAO,CAACX,kBAAkB,CAACJ,IAAI,CAAC,CAAC,CAAC,CAAC,CAAE;IAE1F,IAAIc,SAAS,EAAE;MACbjB,SAAS,CAACmB,QAAQ,GAAGP,cAAc;IACrC,CAAC,MAAM;MACLZ,SAAS,CAACmB,QAAQ,GAAGJ,mBAAmB,IAAID,aAAa,IAAIE,mBAAmB;IAClF;IAEA,MAAMI,uBAAuB,GAAGpB,SAAS,CAACqB,KAAK;IAE/C,IAAIrB,SAAS,CAACmB,QAAQ,EAAE;MACtB,IAAIG,MAAM;MAEV,IAAIL,SAAS,EAAE;QACbnD,WAAW,CAACyD,GAAG,CAAChB,kBAAkB,CAAC;QACnCe,MAAM,GAAGnC,uBAAuB,CAACrB,WAAW,CAAC;MAC/C,CAAC,MAAM;QACLwD,MAAM,GAAGtD,UAAU;QAEnB,MAAMG,WAAW,GAAGiC,cAAc;QAClC,MAAMhC,KAAK,GAAGiC,QAAQ;QAEtBpC,wBAAwB,CAACqD,MAAM,EAAEnD,WAAW,EAAEC,KAAK,CAAC;QACpDkD,MAAM,CAACC,GAAG,CAACjB,cAAc,EAAE,CAAC,CAAC;MAC/B;MAEAN,SAAS,CAACqB,KAAK,GAAG,IAAItD,YAAY,CAACuD,MAAM,CAAC;IAC5C,CAAC,MAAM;MACL,IAAIE,CAAC,GAAGvB,QAAQ,GAAGD,SAAS,CAACT,IAAI;MACjC,MAAM;QAACkC,QAAQ;QAAEC;MAAU,CAAC,GAAGhE,cAAc,CAACyC,IAAI,EAAEF,QAAQ,EAAEC,MAAM,CAAC;MACrE,KAAK,MAAMyB,MAAM,IAAIF,QAAQ,EAAE;QAC7BC,UAAU,CAACE,KAAK,EAAE;QAClB,IAAIN,MAAM;QAEV,IAAIL,SAAS,EAAE;UACbnD,WAAW,CAACyD,GAAG,CACbX,cAAc,GAAGL,kBAAkB,GAAGA,kBAAkB,CAACoB,MAAM,EAAED,UAAU,CAAC,CAC7E;UACDJ,MAAM,GAAGnC,uBAAuB,CAACrB,WAAW,CAAC;QAC/C,CAAC,MAAM;UACLwD,MAAM,GAAGtD,UAAU;UAEnB,MAAMG,WAAW,GAAG4C,mBAAmB,GACnCX,cAAc,GACdA,cAAc,CAACuB,MAAM,EAAED,UAAU,CAAC;UACtC,MAAMtD,KAAK,GAAG0C,aAAa,GAAGT,QAAQ,GAAGA,QAAQ,CAACsB,MAAM,EAAED,UAAU,CAAC;UAErEzD,wBAAwB,CAACqD,MAAM,EAAEnD,WAAW,EAAEC,KAAK,CAAC;UACpDkD,MAAM,CAACC,GAAG,CAACP,mBAAmB,GAAGV,cAAc,GAAGA,cAAc,CAACqB,MAAM,EAAED,UAAU,CAAC,EAAE,CAAC,CAAC;QAC1F;QAEAN,uBAAuB,CAACI,CAAC,EAAE,CAAC,GAAGF,MAAM,CAAC,CAAC,CAAC;QACxCF,uBAAuB,CAACI,CAAC,EAAE,CAAC,GAAGF,MAAM,CAAC,CAAC,CAAC;QACxCF,uBAAuB,CAACI,CAAC,EAAE,CAAC,GAAGF,MAAM,CAAC,CAAC,CAAC;QACxCF,uBAAuB,CAACI,CAAC,EAAE,CAAC,GAAGF,MAAM,CAAC,CAAC,CAAC;QACxCF,uBAAuB,CAACI,CAAC,EAAE,CAAC,GAAGF,MAAM,CAAC,CAAC,CAAC;QACxCF,uBAAuB,CAACI,CAAC,EAAE,CAAC,GAAGF,MAAM,CAAC,CAAC,CAAC;QACxCF,uBAAuB,CAACI,CAAC,EAAE,CAAC,GAAGF,MAAM,CAAC,CAAC,CAAC;QACxCF,uBAAuB,CAACI,CAAC,EAAE,CAAC,GAAGF,MAAM,CAAC,CAAC,CAAC;QACxCF,uBAAuB,CAACI,CAAC,EAAE,CAAC,GAAGF,MAAM,CAAC,CAAC,CAAC;QACxCF,uBAAuB,CAACI,CAAC,EAAE,CAAC,GAAGF,MAAM,CAAC,CAAC,CAAC;QACxCF,uBAAuB,CAACI,CAAC,EAAE,CAAC,GAAGF,MAAM,CAAC,EAAE,CAAC;QACzCF,uBAAuB,CAACI,CAAC,EAAE,CAAC,GAAGF,MAAM,CAAC,EAAE,CAAC;MAC3C;IACF;EACF;CACD;AAED;AACA;AACA;AACA;AACA,OAAM,SAAUO,wBAAwBA,CAACC,QAAQ,EAAEC,gBAAgB;EACjE,OACEA,gBAAgB,KAAKtE,iBAAiB,CAACuE,SAAS,IAChDD,gBAAgB,KAAKtE,iBAAiB,CAACwE,aAAa,IACnDF,gBAAgB,KAAKtE,iBAAiB,CAACyE,OAAO,IAAI,CAACJ,QAAQ,CAACK,YAAa;AAE9E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}