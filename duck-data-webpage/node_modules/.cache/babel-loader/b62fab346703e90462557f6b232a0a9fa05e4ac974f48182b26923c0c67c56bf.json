{"ast":null,"code":"import { assert } from \"./assert.js\";\nimport { log2, clamp } from \"./math-utils.js\";\nimport { MAX_LATITUDE, lngLatToWorld, worldToLngLat } from \"./web-mercator-utils.js\";\n/**\n * Returns map settings {latitude, longitude, zoom}\n * that will contain the provided corners within the provided width.\n *\n * > _Note: Only supports non-perspective mode._\n *\n * @param options fit bounds parameters\n * @returns - latitude, longitude and zoom\n */\nexport function fitBounds(options) {\n  const {\n    width,\n    height,\n    bounds,\n    minExtent = 0,\n    // 0.01 would be about 1000 meters (degree is ~110KM)\n    maxZoom = 24,\n    // ~x4,000,000 => About 10 meter extents\n    offset = [0, 0]\n  } = options;\n  const [[west, south], [east, north]] = bounds;\n  const padding = getPaddingObject(options.padding);\n  const nw = lngLatToWorld([west, clamp(north, -MAX_LATITUDE, MAX_LATITUDE)]);\n  const se = lngLatToWorld([east, clamp(south, -MAX_LATITUDE, MAX_LATITUDE)]);\n  // width/height on the Web Mercator plane\n  const size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];\n  const targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];\n  assert(targetSize[0] > 0 && targetSize[1] > 0);\n  // scale = screen pixels per unit on the Web Mercator plane\n  const scaleX = targetSize[0] / size[0];\n  const scaleY = targetSize[1] / size[1];\n  // Find how much we need to shift the center\n  const offsetX = (padding.right - padding.left) / 2 / scaleX;\n  const offsetY = (padding.top - padding.bottom) / 2 / scaleY;\n  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n  const centerLngLat = worldToLngLat(center);\n  const zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));\n  assert(Number.isFinite(zoom));\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom\n  };\n}\n// Helpers\nfunction getPaddingObject(padding = 0) {\n  if (typeof padding === 'number') {\n    return {\n      top: padding,\n      bottom: padding,\n      left: padding,\n      right: padding\n    };\n  }\n  // Make sure all the required properties are set\n  assert(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));\n  return padding;\n}","map":{"version":3,"names":["assert","log2","clamp","MAX_LATITUDE","lngLatToWorld","worldToLngLat","fitBounds","options","width","height","bounds","minExtent","maxZoom","offset","west","south","east","north","padding","getPaddingObject","nw","se","size","Math","max","abs","targetSize","left","right","top","bottom","scaleX","scaleY","offsetX","offsetY","center","centerLngLat","zoom","min","Number","isFinite","longitude","latitude"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\web-mercator\\src\\fit-bounds.ts"],"sourcesContent":["import {assert} from './assert';\nimport {log2, clamp} from './math-utils';\nimport {MAX_LATITUDE, lngLatToWorld, worldToLngLat} from './web-mercator-utils';\n\n/**\n * Options for fitBounds\n */\nexport type FitBoundsOptions = {\n  /**  viewport width  */\n  width: number;\n  /**  viewport height  */\n  height: number;\n  /**  [[lon, lat], [lon, lat]]  */\n  bounds: [[number, number], [number, number]];\n  /**  The width/height of the bounded area will never be smaller than this. 0.01 would be about 1000 meters (degree is ~110KM)  */\n  minExtent?: number;\n  /**  The maximum zoom level to fit the bounds within. */\n  maxZoom?: number; // ~x4,000,000 => About 10 meter extents\n  /**\n   * padding - The amount of padding in pixels to add to the given bounds.\n   * Can also be an object with top, bottom, left and right properties defining the padding.\n   */\n  padding?: number | Padding;\n  /** The center of the given bounds relative to the map's center,  */\n  offset?: number[];\n};\n\n/**\n * An object describing the padding to add to the bounds.\n */\nexport type Padding = {\n  /** Padding from top in pixels to add to the given bounds */\n  top: number;\n  /** Padding from bottom in pixels to add to the given bounds */\n  bottom: number;\n  /** Padding from left in pixels to add to the given bounds */\n  left: number;\n  /** Padding from right in pixels to add to the given bounds */\n  right: number;\n};\n\ntype ViewportProps = {\n  longitude: number;\n  latitude: number;\n  zoom: number;\n};\n\n/**\n * Returns map settings {latitude, longitude, zoom}\n * that will contain the provided corners within the provided width.\n *\n * > _Note: Only supports non-perspective mode._\n *\n * @param options fit bounds parameters\n * @returns - latitude, longitude and zoom\n */\nexport function fitBounds(options: FitBoundsOptions): ViewportProps {\n  const {\n    width,\n    height,\n    bounds,\n    minExtent = 0, // 0.01 would be about 1000 meters (degree is ~110KM)\n    maxZoom = 24, // ~x4,000,000 => About 10 meter extents\n    offset = [0, 0]\n  } = options;\n\n  const [[west, south], [east, north]] = bounds;\n  const padding = getPaddingObject(options.padding);\n\n  const nw = lngLatToWorld([west, clamp(north, -MAX_LATITUDE, MAX_LATITUDE)]);\n  const se = lngLatToWorld([east, clamp(south, -MAX_LATITUDE, MAX_LATITUDE)]);\n\n  // width/height on the Web Mercator plane\n  const size = [\n    Math.max(Math.abs(se[0] - nw[0]), minExtent),\n    Math.max(Math.abs(se[1] - nw[1]), minExtent)\n  ];\n\n  const targetSize = [\n    width - padding.left - padding.right - Math.abs(offset[0]) * 2,\n    height - padding.top - padding.bottom - Math.abs(offset[1]) * 2\n  ];\n\n  assert(targetSize[0] > 0 && targetSize[1] > 0);\n\n  // scale = screen pixels per unit on the Web Mercator plane\n  const scaleX = targetSize[0] / size[0];\n  const scaleY = targetSize[1] / size[1];\n\n  // Find how much we need to shift the center\n  const offsetX = (padding.right - padding.left) / 2 / scaleX;\n  const offsetY = (padding.top - padding.bottom) / 2 / scaleY;\n\n  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n\n  const centerLngLat = worldToLngLat(center);\n  const zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));\n\n  assert(Number.isFinite(zoom));\n\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom\n  };\n}\n\n// Helpers\nfunction getPaddingObject(padding: number | Padding = 0): Padding {\n  if (typeof padding === 'number') {\n    return {\n      top: padding,\n      bottom: padding,\n      left: padding,\n      right: padding\n    };\n  }\n\n  // Make sure all the required properties are set\n  assert(\n    Number.isFinite(padding.top) &&\n      Number.isFinite(padding.bottom) &&\n      Number.isFinite(padding.left) &&\n      Number.isFinite(padding.right)\n  );\n\n  return padding;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}