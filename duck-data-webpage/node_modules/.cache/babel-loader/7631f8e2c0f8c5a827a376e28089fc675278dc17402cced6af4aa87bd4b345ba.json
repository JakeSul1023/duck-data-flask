{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { arrayEqual, arrayCopy } from \"../utils/array-equal.js\";\n/**\n * A uniform block holds values of the of uniform values for one uniform block / buffer.\n * It also does some book keeping on what has changed, to minimize unnecessary writes to uniform buffers.\n */\nexport class UniformBlock {\n  name;\n  uniforms = {};\n  modifiedUniforms = {};\n  modified = true;\n  bindingLayout = {};\n  needsRedraw = 'initialized';\n  constructor(props) {\n    this.name = props?.name || 'unnamed';\n    // TODO - Extract uniform layout from the shaderLayout object\n    if (props?.name && props?.shaderLayout) {\n      const binding = props?.shaderLayout.bindings?.find(binding_ => binding_.type === 'uniform' && binding_.name === props?.name);\n      if (!binding) {\n        throw new Error(props?.name);\n      }\n      const uniformBlock = binding;\n      for (const uniform of uniformBlock.uniforms || []) {\n        this.bindingLayout[uniform.name] = uniform;\n      }\n    }\n  }\n  /** Set a map of uniforms */\n  setUniforms(uniforms) {\n    for (const [key, value] of Object.entries(uniforms)) {\n      this._setUniform(key, value);\n      if (!this.needsRedraw) {\n        this.setNeedsRedraw(`${this.name}.${key}=${value}`);\n      }\n    }\n  }\n  setNeedsRedraw(reason) {\n    this.needsRedraw = this.needsRedraw || reason;\n  }\n  /** Returns all uniforms */\n  getAllUniforms() {\n    // @ts-expect-error\n    this.modifiedUniforms = {};\n    this.needsRedraw = false;\n    return this.uniforms || {};\n  }\n  /** Set a single uniform */\n  _setUniform(key, value) {\n    if (arrayEqual(this.uniforms[key], value)) {\n      return;\n    }\n    this.uniforms[key] = arrayCopy(value);\n    this.modifiedUniforms[key] = true;\n    this.modified = true;\n  }\n}","map":{"version":3,"names":["arrayEqual","arrayCopy","UniformBlock","name","uniforms","modifiedUniforms","modified","bindingLayout","needsRedraw","constructor","props","shaderLayout","binding","bindings","find","binding_","type","Error","uniformBlock","uniform","setUniforms","key","value","Object","entries","_setUniform","setNeedsRedraw","reason","getAllUniforms"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\core\\src\\portable\\uniform-block.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderUniformType} from '../gpu-type-utils/shader-types';\nimport type {UniformValue} from '../adapter/types/uniforms';\nimport {\n  ShaderLayout,\n  UniformInfo,\n  UniformBufferBindingLayout\n} from '../adapter/types/shader-layout';\nimport {arrayEqual, arrayCopy} from '../utils/array-equal';\n\n/**\n * A uniform block holds values of the of uniform values for one uniform block / buffer.\n * It also does some book keeping on what has changed, to minimize unnecessary writes to uniform buffers.\n */\nexport class UniformBlock<\n  TUniforms extends Record<string, UniformValue> = Record<string, UniformValue>\n> {\n  name: string;\n\n  uniforms: Record<keyof TUniforms, UniformValue> = {} as Record<keyof TUniforms, UniformValue>;\n  modifiedUniforms: Record<keyof TUniforms, boolean> = {} as Record<keyof TUniforms, boolean>;\n  modified: boolean = true;\n\n  readonly bindingLayout: Record<string, UniformInfo> = {};\n  needsRedraw: string | false = 'initialized';\n\n  constructor(props?: {\n    name?: string;\n    shaderLayout?: ShaderLayout;\n    uniformTypes?: Record<keyof TUniforms, Record<string, ShaderUniformType>>;\n  }) {\n    this.name = props?.name || 'unnamed';\n\n    // TODO - Extract uniform layout from the shaderLayout object\n    if (props?.name && props?.shaderLayout) {\n      const binding = props?.shaderLayout.bindings?.find(\n        binding_ => binding_.type === 'uniform' && binding_.name === props?.name\n      );\n      if (!binding) {\n        throw new Error(props?.name);\n      }\n\n      const uniformBlock = binding as UniformBufferBindingLayout;\n      for (const uniform of uniformBlock.uniforms || []) {\n        this.bindingLayout[uniform.name] = uniform;\n      }\n    }\n  }\n\n  /** Set a map of uniforms */\n  setUniforms(uniforms: Partial<TUniforms>): void {\n    for (const [key, value] of Object.entries(uniforms)) {\n      this._setUniform(key, value);\n      if (!this.needsRedraw) {\n        this.setNeedsRedraw(`${this.name}.${key}=${value}`);\n      }\n    }\n  }\n\n  setNeedsRedraw(reason: string): void {\n    this.needsRedraw = this.needsRedraw || reason;\n  }\n\n  /** Returns all uniforms */\n  getAllUniforms(): Record<string, UniformValue> {\n    // @ts-expect-error\n    this.modifiedUniforms = {};\n    this.needsRedraw = false;\n    return (this.uniforms || {}) as Record<string, UniformValue>;\n  }\n\n  /** Set a single uniform */\n  private _setUniform(key: keyof TUniforms, value: UniformValue) {\n    if (arrayEqual(this.uniforms[key], value)) {\n      return;\n    }\n    this.uniforms[key] = arrayCopy(value);\n    this.modifiedUniforms[key] = true;\n    this.modified = true;\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AASA,SAAQA,UAAU,EAAEC,SAAS,QAAC;AAE9B;;;;AAIA,OAAM,MAAOC,YAAY;EAGvBC,IAAI;EAEJC,QAAQ,GAA0C,EAA2C;EAC7FC,gBAAgB,GAAqC,EAAsC;EAC3FC,QAAQ,GAAY,IAAI;EAEfC,aAAa,GAAgC,EAAE;EACxDC,WAAW,GAAmB,aAAa;EAE3CC,YAAYC,KAIX;IACC,IAAI,CAACP,IAAI,GAAGO,KAAK,EAAEP,IAAI,IAAI,SAAS;IAEpC;IACA,IAAIO,KAAK,EAAEP,IAAI,IAAIO,KAAK,EAAEC,YAAY,EAAE;MACtC,MAAMC,OAAO,GAAGF,KAAK,EAAEC,YAAY,CAACE,QAAQ,EAAEC,IAAI,CAChDC,QAAQ,IAAIA,QAAQ,CAACC,IAAI,KAAK,SAAS,IAAID,QAAQ,CAACZ,IAAI,KAAKO,KAAK,EAAEP,IAAI,CACzE;MACD,IAAI,CAACS,OAAO,EAAE;QACZ,MAAM,IAAIK,KAAK,CAACP,KAAK,EAAEP,IAAI,CAAC;MAC9B;MAEA,MAAMe,YAAY,GAAGN,OAAqC;MAC1D,KAAK,MAAMO,OAAO,IAAID,YAAY,CAACd,QAAQ,IAAI,EAAE,EAAE;QACjD,IAAI,CAACG,aAAa,CAACY,OAAO,CAAChB,IAAI,CAAC,GAAGgB,OAAO;MAC5C;IACF;EACF;EAEA;EACAC,WAAWA,CAAChB,QAA4B;IACtC,KAAK,MAAM,CAACiB,GAAG,EAAEC,KAAK,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACpB,QAAQ,CAAC,EAAE;MACnD,IAAI,CAACqB,WAAW,CAACJ,GAAG,EAAEC,KAAK,CAAC;MAC5B,IAAI,CAAC,IAAI,CAACd,WAAW,EAAE;QACrB,IAAI,CAACkB,cAAc,CAAC,GAAG,IAAI,CAACvB,IAAI,IAAIkB,GAAG,IAAIC,KAAK,EAAE,CAAC;MACrD;IACF;EACF;EAEAI,cAAcA,CAACC,MAAc;IAC3B,IAAI,CAACnB,WAAW,GAAG,IAAI,CAACA,WAAW,IAAImB,MAAM;EAC/C;EAEA;EACAC,cAAcA,CAAA;IACZ;IACA,IAAI,CAACvB,gBAAgB,GAAG,EAAE;IAC1B,IAAI,CAACG,WAAW,GAAG,KAAK;IACxB,OAAQ,IAAI,CAACJ,QAAQ,IAAI,EAAE;EAC7B;EAEA;EACQqB,WAAWA,CAACJ,GAAoB,EAAEC,KAAmB;IAC3D,IAAItB,UAAU,CAAC,IAAI,CAACI,QAAQ,CAACiB,GAAG,CAAC,EAAEC,KAAK,CAAC,EAAE;MACzC;IACF;IACA,IAAI,CAAClB,QAAQ,CAACiB,GAAG,CAAC,GAAGpB,SAAS,CAACqB,KAAK,CAAC;IACrC,IAAI,CAACjB,gBAAgB,CAACgB,GAAG,CAAC,GAAG,IAAI;IACjC,IAAI,CAACf,QAAQ,GAAG,IAAI;EACtB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}