{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log, createIterable, project32, Viewport } from '@deck.gl/core';\nimport { WebGLAggregator, CPUAggregator } from \"../common/aggregator/index.js\";\nimport AggregationLayer from \"../common/aggregation-layer.js\";\nimport { defaultColorRange } from \"../common/utils/color-utils.js\";\nimport { AttributeWithScale } from \"../common/utils/scale-utils.js\";\nimport { getBinIdRange } from \"../common/utils/bounds-utils.js\";\nimport { GridCellLayer } from \"./grid-cell-layer.js\";\nimport { binOptionsUniforms } from \"./bin-options-uniforms.js\";\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\nconst defaultProps = {\n  gpuAggregation: true,\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorValue: {\n    type: 'accessor',\n    value: null\n  },\n  // default value is calculated from `getColorWeight` and `colorAggregation`\n  getColorWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  colorAggregation: 'SUM',\n  lowerPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 0\n  },\n  upperPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 100\n  },\n  colorScaleType: 'quantize',\n  onSetColorDomain: noop,\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationValue: {\n    type: 'accessor',\n    value: null\n  },\n  // default value is calculated from `getElevationWeight` and `elevationAggregation`\n  getElevationWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  elevationAggregation: 'SUM',\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  elevationLowerPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 0\n  },\n  elevationUpperPercentile: {\n    type: 'number',\n    min: 0,\n    max: 100,\n    value: 100\n  },\n  elevationScaleType: 'linear',\n  onSetElevationDomain: noop,\n  // grid\n  cellSize: {\n    type: 'number',\n    min: 0,\n    value: 1000\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  gridAggregator: {\n    type: 'function',\n    optional: true,\n    value: null\n  },\n  extruded: false,\n  // Optional material for 'lighting' shader module\n  material: true\n};\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\nclass GridLayer extends AggregationLayer {\n  getAggregatorType() {\n    const {\n      gpuAggregation,\n      gridAggregator,\n      getColorValue,\n      getElevationValue\n    } = this.props;\n    if (gpuAggregation && (gridAggregator || getColorValue || getElevationValue)) {\n      // If these features are desired by the app, the user should explicitly use CPU aggregation\n      log.warn('Features not supported by GPU aggregation, falling back to CPU')();\n      return 'cpu';\n    }\n    if (\n    // GPU aggregation is requested\n    gpuAggregation &&\n    // GPU aggregation is supported by the device\n    WebGLAggregator.isSupported(this.context.device)) {\n      return 'gpu';\n    }\n    return 'cpu';\n  }\n  createAggregator(type) {\n    if (type === 'cpu') {\n      const {\n        gridAggregator,\n        cellSize\n      } = this.props;\n      return new CPUAggregator({\n        dimensions: 2,\n        getBin: {\n          sources: ['positions'],\n          getValue: ({\n            positions\n          }, index, opts) => {\n            if (gridAggregator) {\n              return gridAggregator(positions, cellSize);\n            }\n            const viewport = this.state.aggregatorViewport;\n            // project to common space\n            const p = viewport.projectPosition(positions);\n            const {\n              cellSizeCommon,\n              cellOriginCommon\n            } = opts;\n            return [Math.floor((p[0] - cellOriginCommon[0]) / cellSizeCommon[0]), Math.floor((p[1] - cellOriginCommon[1]) / cellSizeCommon[1])];\n          }\n        },\n        getValue: [{\n          sources: ['colorWeights'],\n          getValue: ({\n            colorWeights\n          }) => colorWeights\n        }, {\n          sources: ['elevationWeights'],\n          getValue: ({\n            elevationWeights\n          }) => elevationWeights\n        }]\n      });\n    }\n    return new WebGLAggregator(this.context.device, {\n      dimensions: 2,\n      channelCount: 2,\n      bufferLayout: this.getAttributeManager().getBufferLayouts({\n        isInstanced: false\n      }),\n      ...super.getShaders({\n        modules: [project32, binOptionsUniforms],\n        vs: /* glsl */`\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float colorWeights;\n  in float elevationWeights;\n\n  void getBin(out ivec2 binId) {\n    vec3 positionCommon = project_position(positions, positions64Low);\n    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);\n    binId = ivec2(gridCoords);\n  }\n  void getValue(out vec2 value) {\n    value = vec2(colorWeights, elevationWeights);\n  }\n  `\n      })\n    });\n  }\n  initializeState() {\n    super.initializeState();\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 'float64',\n        fp64: this.use64bitPositions()\n      },\n      colorWeights: {\n        size: 1,\n        accessor: 'getColorWeight'\n      },\n      elevationWeights: {\n        size: 1,\n        accessor: 'getElevationWeight'\n      }\n    });\n  }\n  updateState(params) {\n    const aggregatorChanged = super.updateState(params);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const {\n      aggregator\n    } = this.state;\n    if ((changeFlags.dataChanged || !this.state.dataAsArray) && (props.getColorValue || props.getElevationValue)) {\n      // Convert data to array\n      this.state.dataAsArray = Array.from(createIterable(props.data).iterable);\n    }\n    if (aggregatorChanged || changeFlags.dataChanged || props.cellSize !== oldProps.cellSize || props.getColorValue !== oldProps.getColorValue || props.getElevationValue !== oldProps.getElevationValue || props.colorAggregation !== oldProps.colorAggregation || props.elevationAggregation !== oldProps.elevationAggregation) {\n      this._updateBinOptions();\n      const {\n        cellSizeCommon,\n        cellOriginCommon,\n        binIdRange,\n        dataAsArray\n      } = this.state;\n      aggregator.setProps({\n        // @ts-expect-error only used by GPUAggregator\n        binIdRange,\n        pointCount: this.getNumInstances(),\n        operations: [props.colorAggregation, props.elevationAggregation],\n        binOptions: {\n          cellSizeCommon,\n          cellOriginCommon\n        },\n        onUpdate: this._onAggregationUpdate.bind(this)\n      });\n      if (dataAsArray) {\n        const {\n          getColorValue,\n          getElevationValue\n        } = this.props;\n        aggregator.setProps({\n          // @ts-expect-error only used by CPUAggregator\n          customOperations: [getColorValue && (indices => getColorValue(indices.map(i => dataAsArray[i]), {\n            indices,\n            data: props.data\n          })), getElevationValue && (indices => getElevationValue(indices.map(i => dataAsArray[i]), {\n            indices,\n            data: props.data\n          }))]\n        });\n      }\n    }\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getColorValue) {\n      aggregator.setNeedsUpdate(0);\n    }\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getElevationValue) {\n      aggregator.setNeedsUpdate(1);\n    }\n    return aggregatorChanged;\n  }\n  _updateBinOptions() {\n    const bounds = this.getBounds();\n    const cellSizeCommon = [1, 1];\n    let cellOriginCommon = [0, 0];\n    let binIdRange = [[0, 1], [0, 1]];\n    let viewport = this.context.viewport;\n    if (bounds && Number.isFinite(bounds[0][0])) {\n      let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];\n      const {\n        cellSize\n      } = this.props;\n      const {\n        unitsPerMeter\n      } = viewport.getDistanceScales(centroid);\n      cellSizeCommon[0] = unitsPerMeter[0] * cellSize;\n      cellSizeCommon[1] = unitsPerMeter[1] * cellSize;\n      // Offset common space to center at the origin of the grid cell where the data center is in\n      // This improves precision without affecting the cell positions\n      const centroidCommon = viewport.projectFlat(centroid);\n      cellOriginCommon = [Math.floor(centroidCommon[0] / cellSizeCommon[0]) * cellSizeCommon[0], Math.floor(centroidCommon[1] / cellSizeCommon[1]) * cellSizeCommon[1]];\n      centroid = viewport.unprojectFlat(cellOriginCommon);\n      const ViewportType = viewport.constructor;\n      // We construct a viewport for the GPU aggregator's project module\n      // This viewport is determined by data\n      // removes arbitrary precision variance that depends on initial view state\n      viewport = viewport.isGeospatial ? new ViewportType({\n        longitude: centroid[0],\n        latitude: centroid[1],\n        zoom: 12\n      }) : new Viewport({\n        position: [centroid[0], centroid[1], 0],\n        zoom: 12\n      });\n      // Round to the nearest 32-bit float to match CPU and GPU results\n      cellOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];\n      binIdRange = getBinIdRange({\n        dataBounds: bounds,\n        getBinId: p => {\n          const positionCommon = viewport.projectFlat(p);\n          return [Math.floor((positionCommon[0] - cellOriginCommon[0]) / cellSizeCommon[0]), Math.floor((positionCommon[1] - cellOriginCommon[1]) / cellSizeCommon[1])];\n        }\n      });\n    }\n    this.setState({\n      cellSizeCommon,\n      cellOriginCommon,\n      binIdRange,\n      aggregatorViewport: viewport\n    });\n  }\n  draw(opts) {\n    // Replaces render time viewport with our own\n    if (opts.shaderModuleProps.project) {\n      opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;\n    }\n    super.draw(opts);\n  }\n  _onAggregationUpdate({\n    channel\n  }) {\n    const props = this.getCurrentLayer().props;\n    const {\n      aggregator\n    } = this.state;\n    if (channel === 0) {\n      const result = aggregator.getResult(0);\n      this.setState({\n        colors: new AttributeWithScale(result, aggregator.binCount)\n      });\n      props.onSetColorDomain(aggregator.getResultDomain(0));\n    } else if (channel === 1) {\n      const result = aggregator.getResult(1);\n      this.setState({\n        elevations: new AttributeWithScale(result, aggregator.binCount)\n      });\n      props.onSetElevationDomain(aggregator.getResultDomain(1));\n    }\n  }\n  onAttributeChange(id) {\n    const {\n      aggregator\n    } = this.state;\n    switch (id) {\n      case 'positions':\n        aggregator.setNeedsUpdate();\n        this._updateBinOptions();\n        const {\n          cellSizeCommon,\n          cellOriginCommon,\n          binIdRange\n        } = this.state;\n        aggregator.setProps({\n          // @ts-expect-error only used by GPUAggregator\n          binIdRange,\n          binOptions: {\n            cellSizeCommon,\n            cellOriginCommon\n          }\n        });\n        break;\n      case 'colorWeights':\n        aggregator.setNeedsUpdate(0);\n        break;\n      case 'elevationWeights':\n        aggregator.setNeedsUpdate(1);\n        break;\n      default:\n      // This should not happen\n    }\n  }\n  renderLayers() {\n    const {\n      aggregator,\n      cellOriginCommon,\n      cellSizeCommon\n    } = this.state;\n    const {\n      elevationScale,\n      colorRange,\n      elevationRange,\n      extruded,\n      coverage,\n      material,\n      transitions,\n      colorScaleType,\n      lowerPercentile,\n      upperPercentile,\n      colorDomain,\n      elevationScaleType,\n      elevationLowerPercentile,\n      elevationUpperPercentile,\n      elevationDomain\n    } = this.props;\n    const CellLayerClass = this.getSubLayerClass('cells', GridCellLayer);\n    const binAttribute = aggregator.getBins();\n    const colors = this.state.colors?.update({\n      scaleType: colorScaleType,\n      lowerPercentile,\n      upperPercentile\n    });\n    const elevations = this.state.elevations?.update({\n      scaleType: elevationScaleType,\n      lowerPercentile: elevationLowerPercentile,\n      upperPercentile: elevationUpperPercentile\n    });\n    if (!colors || !elevations) {\n      return null;\n    }\n    return new CellLayerClass(this.getSubLayerProps({\n      id: 'cells'\n    }), {\n      data: {\n        length: aggregator.binCount,\n        attributes: {\n          getBin: binAttribute,\n          getColorValue: colors.attribute,\n          getElevationValue: elevations.attribute\n        }\n      },\n      // Data has changed shallowly, but we likely don't need to update the attributes\n      dataComparator: (data, oldData) => data.length === oldData.length,\n      updateTriggers: {\n        getBin: [binAttribute],\n        getColorValue: [colors.attribute],\n        getElevationValue: [elevations.attribute]\n      },\n      cellOriginCommon,\n      cellSizeCommon,\n      elevationScale,\n      colorRange,\n      colorScaleType,\n      elevationRange,\n      extruded,\n      coverage,\n      material,\n      colorDomain: colors.domain || colorDomain || aggregator.getResultDomain(0),\n      elevationDomain: elevations.domain || elevationDomain || aggregator.getResultDomain(1),\n      colorCutoff: colors.cutoff,\n      elevationCutoff: elevations.cutoff,\n      transitions: transitions && {\n        getFillColor: transitions.getColorValue || transitions.getColorWeight,\n        getElevation: transitions.getElevationValue || transitions.getElevationWeight\n      },\n      // Extensions are already handled by the GPUAggregator, do not pass it down\n      extensions: []\n    });\n  }\n  getPickingInfo(params) {\n    const info = params.info;\n    const {\n      index\n    } = info;\n    if (index >= 0) {\n      const bin = this.state.aggregator.getBin(index);\n      let object;\n      if (bin) {\n        object = {\n          col: bin.id[0],\n          row: bin.id[1],\n          colorValue: bin.value[0],\n          elevationValue: bin.value[1],\n          count: bin.count\n        };\n        if (bin.pointIndices) {\n          object.pointIndices = bin.pointIndices;\n          object.points = Array.isArray(this.props.data) ? bin.pointIndices.map(i => this.props.data[i]) : [];\n        }\n      }\n      info.object = object;\n    }\n    return info;\n  }\n}\nGridLayer.layerName = 'GridLayer';\nGridLayer.defaultProps = defaultProps;\nexport default GridLayer;","map":{"version":3,"names":["log","createIterable","project32","Viewport","WebGLAggregator","CPUAggregator","AggregationLayer","defaultColorRange","AttributeWithScale","getBinIdRange","GridCellLayer","binOptionsUniforms","noop","defaultProps","gpuAggregation","colorDomain","colorRange","getColorValue","type","value","getColorWeight","colorAggregation","lowerPercentile","min","max","upperPercentile","colorScaleType","onSetColorDomain","elevationDomain","elevationRange","getElevationValue","getElevationWeight","elevationAggregation","elevationScale","elevationLowerPercentile","elevationUpperPercentile","elevationScaleType","onSetElevationDomain","cellSize","coverage","getPosition","x","position","gridAggregator","optional","extruded","material","GridLayer","getAggregatorType","props","warn","isSupported","context","device","createAggregator","dimensions","getBin","sources","getValue","positions","index","opts","viewport","state","aggregatorViewport","p","projectPosition","cellSizeCommon","cellOriginCommon","Math","floor","colorWeights","elevationWeights","channelCount","bufferLayout","getAttributeManager","getBufferLayouts","isInstanced","getShaders","modules","vs","initializeState","attributeManager","add","size","accessor","fp64","use64bitPositions","updateState","params","aggregatorChanged","oldProps","changeFlags","aggregator","dataChanged","dataAsArray","Array","from","data","iterable","_updateBinOptions","binIdRange","setProps","pointCount","getNumInstances","operations","binOptions","onUpdate","_onAggregationUpdate","bind","customOperations","indices","map","i","updateTriggersChanged","setNeedsUpdate","bounds","getBounds","Number","isFinite","centroid","unitsPerMeter","getDistanceScales","centroidCommon","projectFlat","unprojectFlat","ViewportType","constructor","isGeospatial","longitude","latitude","zoom","fround","center","dataBounds","getBinId","positionCommon","setState","draw","shaderModuleProps","project","channel","getCurrentLayer","result","getResult","colors","binCount","getResultDomain","elevations","onAttributeChange","id","renderLayers","transitions","CellLayerClass","getSubLayerClass","binAttribute","getBins","update","scaleType","getSubLayerProps","length","attributes","attribute","dataComparator","oldData","updateTriggers","domain","colorCutoff","cutoff","elevationCutoff","getFillColor","getElevation","extensions","getPickingInfo","info","bin","object","col","row","colorValue","elevationValue","count","pointIndices","points","isArray","layerName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\aggregation-layers\\src\\grid-layer\\grid-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  log,\n  Accessor,\n  Color,\n  GetPickingInfoParams,\n  CompositeLayerProps,\n  createIterable,\n  Layer,\n  Material,\n  project32,\n  LayersList,\n  PickingInfo,\n  Position,\n  Viewport,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport {WebGLAggregator, CPUAggregator, AggregationOperation} from '../common/aggregator/index';\nimport AggregationLayer from '../common/aggregation-layer';\nimport {AggregateAccessor} from '../common/types';\nimport {defaultColorRange} from '../common/utils/color-utils';\nimport {AttributeWithScale} from '../common/utils/scale-utils';\nimport {getBinIdRange} from '../common/utils/bounds-utils';\n\nimport {GridCellLayer} from './grid-cell-layer';\nimport {BinOptions, binOptionsUniforms} from './bin-options-uniforms';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n\nconst defaultProps: DefaultProps<GridLayerProps> = {\n  gpuAggregation: true,\n\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorValue: {type: 'accessor', value: null}, // default value is calculated from `getColorWeight` and `colorAggregation`\n  getColorWeight: {type: 'accessor', value: 1},\n  colorAggregation: 'SUM',\n  lowerPercentile: {type: 'number', min: 0, max: 100, value: 0},\n  upperPercentile: {type: 'number', min: 0, max: 100, value: 100},\n  colorScaleType: 'quantize',\n  onSetColorDomain: noop,\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationValue: {type: 'accessor', value: null}, // default value is calculated from `getElevationWeight` and `elevationAggregation`\n  getElevationWeight: {type: 'accessor', value: 1},\n  elevationAggregation: 'SUM',\n  elevationScale: {type: 'number', min: 0, value: 1},\n  elevationLowerPercentile: {type: 'number', min: 0, max: 100, value: 0},\n  elevationUpperPercentile: {type: 'number', min: 0, max: 100, value: 100},\n  elevationScaleType: 'linear',\n  onSetElevationDomain: noop,\n\n  // grid\n  cellSize: {type: 'number', min: 0, value: 1000},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\n  gridAggregator: {type: 'function', optional: true, value: null},\n  extruded: false,\n\n  // Optional material for 'lighting' shader module\n  material: true\n};\n\n/** All properties supported by GridLayer. */\nexport type GridLayerProps<DataT = unknown> = _GridLayerProps<DataT> & CompositeLayerProps;\n\n/** Properties added by GridLayer. */\ntype _GridLayerProps<DataT> = {\n  /**\n   * Custom accessor to retrieve a grid bin index from each data object.\n   * Not supported by GPU aggregation.\n   */\n  gridAggregator?: ((position: number[], cellSize: number) => [number, number]) | null;\n\n  /**\n   * Size of each cell in meters.\n   * @default 1000\n   */\n  cellSize?: number;\n\n  /**\n   * Color scale domain, default is set to the extent of aggregated weights in each cell.\n   * @default [min(colorWeight), max(colorWeight)]\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Default: [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6) `6-class YlOrRd`\n   */\n  colorRange?: Color[];\n\n  /**\n   * Cell size multiplier, clamped between 0 - 1.\n   * @default 1\n   */\n  coverage?: number;\n\n  /**\n   * Elevation scale input domain, default is set to between 0 and the max of aggregated weights in each cell.\n   * @default [0, max(elevationWeight)]\n   */\n  elevationDomain?: [number, number] | null;\n\n  /**\n   * Elevation scale output range.\n   * @default [0, 1000]\n   */\n  elevationRange?: [number, number];\n\n  /**\n   * Cell elevation multiplier.\n   * @default 1\n   */\n  elevationScale?: number;\n\n  /**\n   * Whether to enable cell elevation. If set to false, all cell will be flat.\n   * @default true\n   */\n  extruded?: boolean;\n\n  /**\n   * Filter cells and re-calculate color by `upperPercentile`.\n   * Cells with value larger than the upperPercentile will be hidden.\n   * @default 100\n   */\n  upperPercentile?: number;\n\n  /**\n   * Filter cells and re-calculate color by `lowerPercentile`.\n   * Cells with value smaller than the lowerPercentile will be hidden.\n   * @default 0\n   */\n  lowerPercentile?: number;\n\n  /**\n   * Filter cells and re-calculate elevation by `elevationUpperPercentile`.\n   * Cells with elevation value larger than the `elevationUpperPercentile` will be hidden.\n   * @default 100\n   */\n  elevationUpperPercentile?: number;\n\n  /**\n   * Filter cells and re-calculate elevation by `elevationLowerPercentile`.\n   * Cells with elevation value larger than the `elevationLowerPercentile` will be hidden.\n   * @default 0\n   */\n  elevationLowerPercentile?: number;\n\n  /**\n   * Scaling function used to determine the color of the grid cell.\n   * Supported Values are 'quantize', 'linear', 'quantile' and 'ordinal'.\n   * @default 'quantize'\n   */\n  colorScaleType?: 'quantize' | 'linear' | 'quantile' | 'ordinal';\n\n  /**\n   * Scaling function used to determine the elevation of the grid cell.\n   * Supported Values are 'linear' and 'quantile'.\n   * @default 'linear'\n   */\n  elevationScaleType?: 'linear' | 'quantile';\n\n  /**\n   * Material settings for lighting effect. Applies if `extruded: true`.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's color value.\n   * Valid values are 'SUM', 'MEAN', 'MIN', 'MAX', 'COUNT'.\n   *\n   * @default 'SUM'\n   */\n  colorAggregation?: AggregationOperation;\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's elevation value.\n   * Valid values are 'SUM', 'MEAN', 'MIN', 'MAX', 'COUNT'.\n   *\n   * @default 'SUM'\n   */\n  elevationAggregation?: AggregationOperation;\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: Accessor<DataT, Position>;\n\n  /**\n   * The weight of a data object used to calculate the color value for a cell.\n   * @default 1\n   */\n  getColorWeight?: Accessor<DataT, number>;\n\n  /**\n   * After data objects are aggregated into cells, this accessor is called on each cell to get the value that its color is based on.\n   * Not supported by GPU aggregation.\n   * @default null\n   */\n  getColorValue?: AggregateAccessor<DataT> | null;\n\n  /**\n   * The weight of a data object used to calculate the elevation value for a cell.\n   * @default 1\n   */\n  getElevationWeight?: Accessor<DataT, number>;\n\n  /**\n   * After data objects are aggregated into cells, this accessor is called on each cell to get the value that its elevation is based on.\n   * Not supported by GPU aggregation.\n   * @default null\n   */\n  getElevationValue?: AggregateAccessor<DataT> | null;\n\n  /**\n   * This callback will be called when bin color domain has been calculated.\n   * @default () => {}\n   */\n  onSetColorDomain?: (minMax: [number, number]) => void;\n\n  /**\n   * This callback will be called when bin elevation domain has been calculated.\n   * @default () => {}\n   */\n  onSetElevationDomain?: (minMax: [number, number]) => void;\n\n  /**\n   * When set to true, aggregation is performed on GPU, provided other conditions are met.\n   * @default true\n   */\n  gpuAggregation?: boolean;\n};\n\nexport type GridLayerPickingInfo<DataT> = PickingInfo<{\n  /** Column index of the picked cell */\n  col: number;\n  /** Row index of the picked cell */\n  row: number;\n  /** Aggregated color value, as determined by `getColorWeight` and `colorAggregation` */\n  colorValue: number;\n  /** Aggregated elevation value, as determined by `getElevationWeight` and `elevationAggregation` */\n  elevationValue: number;\n  /** Number of data points in the picked cell */\n  count: number;\n  /** Indices of the data objects in the picked cell. Only available if using CPU aggregation. */\n  pointIndices?: number[];\n  /** The data objects in the picked cell. Only available if using CPU aggregation and layer data is an array. */\n  points?: DataT[];\n}>;\n\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\nexport default class GridLayer<DataT = any, ExtraPropsT extends {} = {}> extends AggregationLayer<\n  DataT,\n  ExtraPropsT & Required<_GridLayerProps<DataT>>\n> {\n  static layerName = 'GridLayer';\n  static defaultProps = defaultProps;\n\n  state!: AggregationLayer<DataT>['state'] &\n    BinOptions & {\n      // Needed if getColorValue, getElevationValue are used\n      dataAsArray?: DataT[];\n\n      colors?: AttributeWithScale;\n      elevations?: AttributeWithScale;\n\n      binIdRange: [number, number][];\n      aggregatorViewport: Viewport;\n    };\n\n  getAggregatorType(): string {\n    const {gpuAggregation, gridAggregator, getColorValue, getElevationValue} = this.props;\n    if (gpuAggregation && (gridAggregator || getColorValue || getElevationValue)) {\n      // If these features are desired by the app, the user should explicitly use CPU aggregation\n      log.warn('Features not supported by GPU aggregation, falling back to CPU')();\n      return 'cpu';\n    }\n\n    if (\n      // GPU aggregation is requested\n      gpuAggregation &&\n      // GPU aggregation is supported by the device\n      WebGLAggregator.isSupported(this.context.device)\n    ) {\n      return 'gpu';\n    }\n    return 'cpu';\n  }\n\n  createAggregator(type: string): WebGLAggregator | CPUAggregator {\n    if (type === 'cpu') {\n      const {gridAggregator, cellSize} = this.props;\n      return new CPUAggregator({\n        dimensions: 2,\n        getBin: {\n          sources: ['positions'],\n          getValue: ({positions}: {positions: number[]}, index: number, opts: BinOptions) => {\n            if (gridAggregator) {\n              return gridAggregator(positions, cellSize);\n            }\n            const viewport = this.state.aggregatorViewport;\n            // project to common space\n            const p = viewport.projectPosition(positions);\n            const {cellSizeCommon, cellOriginCommon} = opts;\n            return [\n              Math.floor((p[0] - cellOriginCommon[0]) / cellSizeCommon[0]),\n              Math.floor((p[1] - cellOriginCommon[1]) / cellSizeCommon[1])\n            ];\n          }\n        },\n        getValue: [\n          {sources: ['colorWeights'], getValue: ({colorWeights}) => colorWeights},\n          {sources: ['elevationWeights'], getValue: ({elevationWeights}) => elevationWeights}\n        ]\n      });\n    }\n    return new WebGLAggregator(this.context.device, {\n      dimensions: 2,\n      channelCount: 2,\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts({isInstanced: false}),\n      ...super.getShaders({\n        modules: [project32, binOptionsUniforms],\n        vs: /* glsl */ `\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float colorWeights;\n  in float elevationWeights;\n\n  void getBin(out ivec2 binId) {\n    vec3 positionCommon = project_position(positions, positions64Low);\n    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);\n    binId = ivec2(gridCoords);\n  }\n  void getValue(out vec2 value) {\n    value = vec2(colorWeights, elevationWeights);\n  }\n  `\n      })\n    });\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      positions: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 'float64',\n        fp64: this.use64bitPositions()\n      },\n      colorWeights: {size: 1, accessor: 'getColorWeight'},\n      elevationWeights: {size: 1, accessor: 'getElevationWeight'}\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    const aggregatorChanged = super.updateState(params);\n\n    const {props, oldProps, changeFlags} = params;\n    const {aggregator} = this.state;\n    if (\n      (changeFlags.dataChanged || !this.state.dataAsArray) &&\n      (props.getColorValue || props.getElevationValue)\n    ) {\n      // Convert data to array\n      this.state.dataAsArray = Array.from(createIterable(props.data).iterable);\n    }\n    if (\n      aggregatorChanged ||\n      changeFlags.dataChanged ||\n      props.cellSize !== oldProps.cellSize ||\n      props.getColorValue !== oldProps.getColorValue ||\n      props.getElevationValue !== oldProps.getElevationValue ||\n      props.colorAggregation !== oldProps.colorAggregation ||\n      props.elevationAggregation !== oldProps.elevationAggregation\n    ) {\n      this._updateBinOptions();\n      const {cellSizeCommon, cellOriginCommon, binIdRange, dataAsArray} = this.state;\n\n      aggregator.setProps({\n        // @ts-expect-error only used by GPUAggregator\n        binIdRange,\n        pointCount: this.getNumInstances(),\n        operations: [props.colorAggregation, props.elevationAggregation],\n        binOptions: {\n          cellSizeCommon,\n          cellOriginCommon\n        },\n        onUpdate: this._onAggregationUpdate.bind(this)\n      });\n\n      if (dataAsArray) {\n        const {getColorValue, getElevationValue} = this.props;\n        aggregator.setProps({\n          // @ts-expect-error only used by CPUAggregator\n          customOperations: [\n            getColorValue &&\n              ((indices: number[]) =>\n                getColorValue(\n                  indices.map(i => dataAsArray[i]),\n                  {indices, data: props.data}\n                )),\n            getElevationValue &&\n              ((indices: number[]) =>\n                getElevationValue(\n                  indices.map(i => dataAsArray[i]),\n                  {indices, data: props.data}\n                ))\n          ]\n        });\n      }\n    }\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getColorValue) {\n      aggregator.setNeedsUpdate(0);\n    }\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getElevationValue) {\n      aggregator.setNeedsUpdate(1);\n    }\n\n    return aggregatorChanged;\n  }\n\n  private _updateBinOptions() {\n    const bounds = this.getBounds();\n    const cellSizeCommon: [number, number] = [1, 1];\n    let cellOriginCommon: [number, number] = [0, 0];\n    let binIdRange: [number, number][] = [\n      [0, 1],\n      [0, 1]\n    ];\n    let viewport = this.context.viewport;\n\n    if (bounds && Number.isFinite(bounds[0][0])) {\n      let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];\n      const {cellSize} = this.props;\n      const {unitsPerMeter} = viewport.getDistanceScales(centroid);\n      cellSizeCommon[0] = unitsPerMeter[0] * cellSize;\n      cellSizeCommon[1] = unitsPerMeter[1] * cellSize;\n\n      // Offset common space to center at the origin of the grid cell where the data center is in\n      // This improves precision without affecting the cell positions\n      const centroidCommon = viewport.projectFlat(centroid);\n      cellOriginCommon = [\n        Math.floor(centroidCommon[0] / cellSizeCommon[0]) * cellSizeCommon[0],\n        Math.floor(centroidCommon[1] / cellSizeCommon[1]) * cellSizeCommon[1]\n      ];\n      centroid = viewport.unprojectFlat(cellOriginCommon);\n\n      const ViewportType = viewport.constructor as any;\n      // We construct a viewport for the GPU aggregator's project module\n      // This viewport is determined by data\n      // removes arbitrary precision variance that depends on initial view state\n      viewport = viewport.isGeospatial\n        ? new ViewportType({longitude: centroid[0], latitude: centroid[1], zoom: 12})\n        : new Viewport({position: [centroid[0], centroid[1], 0], zoom: 12});\n\n      // Round to the nearest 32-bit float to match CPU and GPU results\n      cellOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];\n\n      binIdRange = getBinIdRange({\n        dataBounds: bounds,\n        getBinId: (p: number[]) => {\n          const positionCommon = viewport.projectFlat(p);\n          return [\n            Math.floor((positionCommon[0] - cellOriginCommon[0]) / cellSizeCommon[0]),\n            Math.floor((positionCommon[1] - cellOriginCommon[1]) / cellSizeCommon[1])\n          ];\n        }\n      });\n    }\n\n    this.setState({cellSizeCommon, cellOriginCommon, binIdRange, aggregatorViewport: viewport});\n  }\n\n  override draw(opts) {\n    // Replaces render time viewport with our own\n    if (opts.shaderModuleProps.project) {\n      opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;\n    }\n    super.draw(opts);\n  }\n\n  private _onAggregationUpdate({channel}: {channel: number}) {\n    const props = this.getCurrentLayer()!.props;\n    const {aggregator} = this.state;\n    if (channel === 0) {\n      const result = aggregator.getResult(0)!;\n      this.setState({\n        colors: new AttributeWithScale(result, aggregator.binCount)\n      });\n      props.onSetColorDomain(aggregator.getResultDomain(0));\n    } else if (channel === 1) {\n      const result = aggregator.getResult(1)!;\n      this.setState({\n        elevations: new AttributeWithScale(result, aggregator.binCount)\n      });\n      props.onSetElevationDomain(aggregator.getResultDomain(1));\n    }\n  }\n\n  onAttributeChange(id: string) {\n    const {aggregator} = this.state;\n    switch (id) {\n      case 'positions':\n        aggregator.setNeedsUpdate();\n\n        this._updateBinOptions();\n        const {cellSizeCommon, cellOriginCommon, binIdRange} = this.state;\n        aggregator.setProps({\n          // @ts-expect-error only used by GPUAggregator\n          binIdRange,\n          binOptions: {\n            cellSizeCommon,\n            cellOriginCommon\n          }\n        });\n        break;\n\n      case 'colorWeights':\n        aggregator.setNeedsUpdate(0);\n        break;\n\n      case 'elevationWeights':\n        aggregator.setNeedsUpdate(1);\n        break;\n\n      default:\n      // This should not happen\n    }\n  }\n\n  renderLayers(): LayersList | Layer | null {\n    const {aggregator, cellOriginCommon, cellSizeCommon} = this.state;\n    const {\n      elevationScale,\n      colorRange,\n      elevationRange,\n      extruded,\n      coverage,\n      material,\n      transitions,\n      colorScaleType,\n      lowerPercentile,\n      upperPercentile,\n      colorDomain,\n      elevationScaleType,\n      elevationLowerPercentile,\n      elevationUpperPercentile,\n      elevationDomain\n    } = this.props;\n    const CellLayerClass = this.getSubLayerClass('cells', GridCellLayer);\n    const binAttribute = aggregator.getBins();\n\n    const colors = this.state.colors?.update({\n      scaleType: colorScaleType,\n      lowerPercentile,\n      upperPercentile\n    });\n    const elevations = this.state.elevations?.update({\n      scaleType: elevationScaleType,\n      lowerPercentile: elevationLowerPercentile,\n      upperPercentile: elevationUpperPercentile\n    });\n\n    if (!colors || !elevations) {\n      return null;\n    }\n\n    return new CellLayerClass(\n      this.getSubLayerProps({\n        id: 'cells'\n      }),\n      {\n        data: {\n          length: aggregator.binCount,\n          attributes: {\n            getBin: binAttribute,\n            getColorValue: colors.attribute,\n            getElevationValue: elevations.attribute\n          }\n        },\n        // Data has changed shallowly, but we likely don't need to update the attributes\n        dataComparator: (data, oldData) => data.length === oldData.length,\n        updateTriggers: {\n          getBin: [binAttribute],\n          getColorValue: [colors.attribute],\n          getElevationValue: [elevations.attribute]\n        },\n        cellOriginCommon,\n        cellSizeCommon,\n        elevationScale,\n        colorRange,\n        colorScaleType,\n        elevationRange,\n        extruded,\n        coverage,\n        material,\n        colorDomain: colors.domain || colorDomain || aggregator.getResultDomain(0),\n        elevationDomain: elevations.domain || elevationDomain || aggregator.getResultDomain(1),\n        colorCutoff: colors.cutoff,\n        elevationCutoff: elevations.cutoff,\n        transitions: transitions && {\n          getFillColor: transitions.getColorValue || transitions.getColorWeight,\n          getElevation: transitions.getElevationValue || transitions.getElevationWeight\n        },\n        // Extensions are already handled by the GPUAggregator, do not pass it down\n        extensions: []\n      }\n    );\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): GridLayerPickingInfo<DataT> {\n    const info: GridLayerPickingInfo<DataT> = params.info;\n    const {index} = info;\n    if (index >= 0) {\n      const bin = this.state.aggregator.getBin(index);\n      let object: GridLayerPickingInfo<DataT>['object'];\n      if (bin) {\n        object = {\n          col: bin.id[0],\n          row: bin.id[1],\n          colorValue: bin.value[0],\n          elevationValue: bin.value[1],\n          count: bin.count\n        };\n        if (bin.pointIndices) {\n          object.pointIndices = bin.pointIndices;\n          object.points = Array.isArray(this.props.data)\n            ? bin.pointIndices.map(i => (this.props.data as DataT[])[i])\n            : [];\n        }\n      }\n      info.object = object;\n    }\n\n    return info;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}