{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { RenderPass } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\nimport { withGLParameters } from \"../../context/state-tracker/with-parameters.js\";\nimport { setGLParameters } from \"../../context/parameters/unified-parameter-api.js\";\nconst COLOR_CHANNELS = [0x1, 0x2, 0x4, 0x8]; // GPUColorWrite RED, GREEN, BLUE, ALPHA\nexport class WEBGLRenderPass extends RenderPass {\n  device;\n  /** Parameters that should be applied before each draw call */\n  glParameters;\n  constructor(device, props) {\n    super(device, props);\n    this.device = device;\n    // If no viewport is provided, apply reasonably defaults\n    let viewport;\n    if (!props?.parameters?.viewport) {\n      if (props?.framebuffer) {\n        // Set the viewport to the size of the framebuffer\n        const {\n          width,\n          height\n        } = props.framebuffer;\n        viewport = [0, 0, width, height];\n      } else {\n        // Instead of using our own book-keeping, we can just read the values from the WebGL context\n        const [width, height] = device.getCanvasContext().getDrawingBufferSize();\n        viewport = [0, 0, width, height];\n      }\n    }\n    // TODO - do parameters (scissorRect) affect the clear operation?\n    this.device.pushState();\n    this.setParameters({\n      viewport,\n      ...this.props.parameters\n    });\n    // Specify mapping of draw buffer locations to color attachments\n    const webglFramebuffer = this.props.framebuffer;\n    if (webglFramebuffer?.handle) {\n      if (this.props.framebuffer) {\n        const drawBuffers = this.props.framebuffer.colorAttachments.map((_, i) => 36064 + i);\n        this.device.gl.drawBuffers(drawBuffers);\n      } else {\n        this.device.gl.drawBuffers([1029]);\n      }\n    }\n    // Hack - for now WebGL draws in \"immediate mode\" (instead of queueing the operations)...\n    this.clear();\n  }\n  end() {\n    this.device.popState();\n    // should add commands to CommandEncoder.\n  }\n  pushDebugGroup(groupLabel) {}\n  popDebugGroup() {}\n  insertDebugMarker(markerLabel) {}\n  // beginOcclusionQuery(queryIndex: number): void;\n  // endOcclusionQuery(): void;\n  // executeBundles(bundles: Iterable<GPURenderBundle>): void;\n  /**\n   * Maps RenderPass parameters to GL parameters\n   */\n  setParameters(parameters = {}) {\n    const glParameters = {\n      ...this.glParameters\n    };\n    // Framebuffers are specified using parameters in WebGL\n    glParameters.framebuffer = this.props.framebuffer || null;\n    if (this.props.depthReadOnly) {\n      glParameters.depthMask = !this.props.depthReadOnly;\n    }\n    glParameters.stencilMask = this.props.stencilReadOnly ? 0 : 1;\n    glParameters[35977] = this.props.discard;\n    // Map the four renderpass parameters to WebGL parameters\n    if (parameters.viewport) {\n      // WebGPU viewports are 6 coordinates (X, Y, Z)\n      if (parameters.viewport.length >= 6) {\n        glParameters.viewport = parameters.viewport.slice(0, 4);\n        glParameters.depthRange = [parameters.viewport[4], parameters.viewport[5]];\n      } else {\n        // WebGL viewports are 4 coordinates (X, Y)\n        glParameters.viewport = parameters.viewport;\n      }\n    }\n    if (parameters.scissorRect) {\n      glParameters.scissorTest = true;\n      glParameters.scissor = parameters.scissorRect;\n    }\n    if (parameters.blendConstant) {\n      glParameters.blendColor = parameters.blendConstant;\n    }\n    if (parameters.stencilReference) {\n      // eslint-disable-next-line no-console\n      console.warn('RenderPassParameters.stencilReference not yet implemented in WebGL');\n      // parameters.stencilFunc = [func, ref, mask];\n      // Does this work?\n      parameters[2967] = parameters.stencilReference;\n    }\n    if (parameters.colorMask) {\n      glParameters.colorMask = COLOR_CHANNELS.map(channel => Boolean(channel & parameters.colorMask));\n    }\n    this.glParameters = glParameters;\n    setGLParameters(this.device.gl, glParameters);\n  }\n  beginOcclusionQuery(queryIndex) {\n    const webglQuerySet = this.props.occlusionQuerySet;\n    webglQuerySet?.beginOcclusionQuery();\n  }\n  endOcclusionQuery() {\n    const webglQuerySet = this.props.occlusionQuerySet;\n    webglQuerySet?.endOcclusionQuery();\n  }\n  // PRIVATE\n  /**\n   * Optionally clears depth, color and stencil buffers based on parameters\n   */\n  clear() {\n    const glParameters = {\n      ...this.glParameters\n    };\n    let clearMask = 0;\n    if (this.props.clearColors) {\n      this.props.clearColors.forEach((color, drawBufferIndex) => {\n        if (color) {\n          this.clearColorBuffer(drawBufferIndex, color);\n        }\n      });\n    }\n    if (this.props.clearColor !== false && this.props.clearColors === undefined) {\n      clearMask |= 16384;\n      glParameters.clearColor = this.props.clearColor;\n    }\n    if (this.props.clearDepth !== false) {\n      clearMask |= 256;\n      glParameters.clearDepth = this.props.clearDepth;\n    }\n    if (this.props.clearStencil !== false) {\n      clearMask |= 1024;\n      glParameters.clearStencil = this.props.clearStencil;\n    }\n    if (clearMask !== 0) {\n      // Temporarily set any clear \"colors\" and call clear\n      withGLParameters(this.device.gl, glParameters, () => {\n        this.device.gl.clear(clearMask);\n      });\n    }\n  }\n  /**\n   * WebGL2 - clear a specific color buffer\n   */\n  clearColorBuffer(drawBuffer = 0, value = [0, 0, 0, 0]) {\n    withGLParameters(this.device.gl, {\n      framebuffer: this.props.framebuffer\n    }, () => {\n      // Method selection per OpenGL ES 3 docs\n      switch (value.constructor) {\n        case Int8Array:\n        case Int16Array:\n        case Int32Array:\n          this.device.gl.clearBufferiv(6144, drawBuffer, value);\n          break;\n        case Uint8Array:\n        case Uint8ClampedArray:\n        case Uint16Array:\n        case Uint32Array:\n          this.device.gl.clearBufferuiv(6144, drawBuffer, value);\n          break;\n        case Float32Array:\n          this.device.gl.clearBufferfv(6144, drawBuffer, value);\n          break;\n        default:\n          throw new Error('clearColorBuffer: color must be typed array');\n      }\n    });\n  }\n}","map":{"version":3,"names":["RenderPass","GL","withGLParameters","setGLParameters","COLOR_CHANNELS","WEBGLRenderPass","device","glParameters","constructor","props","viewport","parameters","framebuffer","width","height","getCanvasContext","getDrawingBufferSize","pushState","setParameters","webglFramebuffer","handle","drawBuffers","colorAttachments","map","_","i","gl","clear","end","popState","pushDebugGroup","groupLabel","popDebugGroup","insertDebugMarker","markerLabel","depthReadOnly","depthMask","stencilMask","stencilReadOnly","discard","length","slice","depthRange","scissorRect","scissorTest","scissor","blendConstant","blendColor","stencilReference","console","warn","colorMask","channel","Boolean","beginOcclusionQuery","queryIndex","webglQuerySet","occlusionQuerySet","endOcclusionQuery","clearMask","clearColors","forEach","color","drawBufferIndex","clearColorBuffer","clearColor","undefined","clearDepth","clearStencil","drawBuffer","value","Int8Array","Int16Array","Int32Array","clearBufferiv","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","clearBufferuiv","Float32Array","clearBufferfv","Error"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\webgl\\src\\adapter\\resources\\webgl-render-pass.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {NumericArray, NumberArray4} from '@math.gl/types';\nimport {RenderPass, RenderPassProps, RenderPassParameters} from '@luma.gl/core';\nimport {WebGLDevice} from '../webgl-device';\nimport {GL, GLParameters} from '@luma.gl/constants';\nimport {withGLParameters} from '../../context/state-tracker/with-parameters';\nimport {setGLParameters} from '../../context/parameters/unified-parameter-api';\nimport {WEBGLQuerySet} from './webgl-query-set';\nimport {WEBGLFramebuffer} from './webgl-framebuffer';\n\nconst COLOR_CHANNELS = [0x1, 0x2, 0x4, 0x8]; // GPUColorWrite RED, GREEN, BLUE, ALPHA\n\nexport class WEBGLRenderPass extends RenderPass {\n  readonly device: WebGLDevice;\n\n  /** Parameters that should be applied before each draw call */\n  glParameters: GLParameters;\n\n  constructor(device: WebGLDevice, props: RenderPassProps) {\n    super(device, props);\n    this.device = device;\n\n    // If no viewport is provided, apply reasonably defaults\n    let viewport;\n    if (!props?.parameters?.viewport) {\n      if (props?.framebuffer) {\n        // Set the viewport to the size of the framebuffer\n        const {width, height} = props.framebuffer;\n        viewport = [0, 0, width, height];\n      } else {\n        // Instead of using our own book-keeping, we can just read the values from the WebGL context\n        const [width, height] = device.getCanvasContext().getDrawingBufferSize();\n        viewport = [0, 0, width, height];\n      }\n    }\n\n    // TODO - do parameters (scissorRect) affect the clear operation?\n    this.device.pushState();\n    this.setParameters({viewport, ...this.props.parameters});\n\n    // Specify mapping of draw buffer locations to color attachments\n    const webglFramebuffer = this.props.framebuffer as WEBGLFramebuffer;\n    if (webglFramebuffer?.handle) {\n      if (this.props.framebuffer) {\n        const drawBuffers = this.props.framebuffer.colorAttachments.map(\n          (_, i) => GL.COLOR_ATTACHMENT0 + i\n        );\n        this.device.gl.drawBuffers(drawBuffers);\n      } else {\n        this.device.gl.drawBuffers([GL.BACK]);\n      }\n    }\n\n    // Hack - for now WebGL draws in \"immediate mode\" (instead of queueing the operations)...\n    this.clear();\n  }\n\n  end(): void {\n    this.device.popState();\n    // should add commands to CommandEncoder.\n  }\n\n  pushDebugGroup(groupLabel: string): void {}\n  popDebugGroup(): void {}\n  insertDebugMarker(markerLabel: string): void {}\n\n  // beginOcclusionQuery(queryIndex: number): void;\n  // endOcclusionQuery(): void;\n\n  // executeBundles(bundles: Iterable<GPURenderBundle>): void;\n\n  /**\n   * Maps RenderPass parameters to GL parameters\n   */\n  setParameters(parameters: RenderPassParameters = {}): void {\n    const glParameters: GLParameters = {...this.glParameters};\n\n    // Framebuffers are specified using parameters in WebGL\n    glParameters.framebuffer = this.props.framebuffer || null;\n\n    if (this.props.depthReadOnly) {\n      glParameters.depthMask = !this.props.depthReadOnly;\n    }\n\n    glParameters.stencilMask = this.props.stencilReadOnly ? 0 : 1;\n\n    glParameters[GL.RASTERIZER_DISCARD] = this.props.discard;\n\n    // Map the four renderpass parameters to WebGL parameters\n    if (parameters.viewport) {\n      // WebGPU viewports are 6 coordinates (X, Y, Z)\n      if (parameters.viewport.length >= 6) {\n        glParameters.viewport = parameters.viewport.slice(0, 4) as NumberArray4;\n        glParameters.depthRange = [parameters.viewport[4], parameters.viewport[5]];\n      } else {\n        // WebGL viewports are 4 coordinates (X, Y)\n        glParameters.viewport = parameters.viewport as NumberArray4;\n      }\n    }\n    if (parameters.scissorRect) {\n      glParameters.scissorTest = true;\n      glParameters.scissor = parameters.scissorRect;\n    }\n    if (parameters.blendConstant) {\n      glParameters.blendColor = parameters.blendConstant;\n    }\n    if (parameters.stencilReference) {\n      // eslint-disable-next-line no-console\n      console.warn('RenderPassParameters.stencilReference not yet implemented in WebGL');\n      // parameters.stencilFunc = [func, ref, mask];\n      // Does this work?\n      parameters[GL.STENCIL_REF] = parameters.stencilReference;\n    }\n\n    if (parameters.colorMask) {\n      glParameters.colorMask = COLOR_CHANNELS.map(channel =>\n        Boolean(channel & parameters.colorMask)\n      );\n    }\n\n    this.glParameters = glParameters;\n\n    setGLParameters(this.device.gl, glParameters);\n  }\n\n  beginOcclusionQuery(queryIndex: number): void {\n    const webglQuerySet = this.props.occlusionQuerySet as WEBGLQuerySet;\n    webglQuerySet?.beginOcclusionQuery();\n  }\n\n  override endOcclusionQuery(): void {\n    const webglQuerySet = this.props.occlusionQuerySet as WEBGLQuerySet;\n    webglQuerySet?.endOcclusionQuery();\n  }\n\n  // PRIVATE\n\n  /**\n   * Optionally clears depth, color and stencil buffers based on parameters\n   */\n  protected clear(): void {\n    const glParameters: GLParameters = {...this.glParameters};\n\n    let clearMask = 0;\n\n    if (this.props.clearColors) {\n      this.props.clearColors.forEach((color, drawBufferIndex) => {\n        if (color) {\n          this.clearColorBuffer(drawBufferIndex, color);\n        }\n      });\n    }\n\n    if (this.props.clearColor !== false && this.props.clearColors === undefined) {\n      clearMask |= GL.COLOR_BUFFER_BIT;\n      glParameters.clearColor = this.props.clearColor;\n    }\n    if (this.props.clearDepth !== false) {\n      clearMask |= GL.DEPTH_BUFFER_BIT;\n      glParameters.clearDepth = this.props.clearDepth;\n    }\n    if (this.props.clearStencil !== false) {\n      clearMask |= GL.STENCIL_BUFFER_BIT;\n      glParameters.clearStencil = this.props.clearStencil;\n    }\n\n    if (clearMask !== 0) {\n      // Temporarily set any clear \"colors\" and call clear\n      withGLParameters(this.device.gl, glParameters, () => {\n        this.device.gl.clear(clearMask);\n      });\n    }\n  }\n\n  /**\n   * WebGL2 - clear a specific color buffer\n   */\n  protected clearColorBuffer(drawBuffer: number = 0, value: NumericArray = [0, 0, 0, 0]) {\n    withGLParameters(this.device.gl, {framebuffer: this.props.framebuffer}, () => {\n      // Method selection per OpenGL ES 3 docs\n      switch (value.constructor) {\n        case Int8Array:\n        case Int16Array:\n        case Int32Array:\n          this.device.gl.clearBufferiv(GL.COLOR, drawBuffer, value);\n          break;\n        case Uint8Array:\n        case Uint8ClampedArray:\n        case Uint16Array:\n        case Uint32Array:\n          this.device.gl.clearBufferuiv(GL.COLOR, drawBuffer, value);\n          break;\n        case Float32Array:\n          this.device.gl.clearBufferfv(GL.COLOR, drawBuffer, value);\n          break;\n        default:\n          throw new Error('clearColorBuffer: color must be typed array');\n      }\n    });\n  }\n\n  /*\n  clearDepthStencil() {\n      case GL.DEPTH:\n        this.device.gl.clearBufferfv(GL.DEPTH, 0, [value]);\n        break;\n\n      case GL_STENCIL:\n        this.device.gl.clearBufferiv(GL.STENCIL, 0, [value]);\n        break;\n\n      case GL.DEPTH_STENCIL:\n        const [depth, stencil] = value;\n        this.device.gl.clearBufferfi(GL.DEPTH_STENCIL, 0, depth, stencil);\n        break;\n\n      default:\n        assert(false, ERR_ARGUMENTS);\n    }\n  });\n  */\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}