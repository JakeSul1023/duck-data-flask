{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// All utility methods needed to implement Marching Squares algorithm\n// Ref: https://en.wikipedia.org/wiki/Marching_squares\nimport { ISOLINES_CODE_OFFSET_MAP, ISOBANDS_CODE_OFFSET_MAP } from \"./marching-squares-codes.js\";\n// Utility methods\nfunction getVertexCode(weight, threshold) {\n  // threshold must be a single value or a range (array of size 2)\n  if (Number.isNaN(weight)) {\n    return 0;\n  }\n  // Iso-bands\n  if (Array.isArray(threshold)) {\n    if (weight < threshold[0]) {\n      return 0;\n    }\n    return weight < threshold[1] ? 1 : 2;\n  }\n  // Iso-lines\n  return weight >= threshold ? 1 : 0;\n}\n// Returns marching square code for given cell\n/* eslint-disable complexity, max-statements*/\nexport function getCode(opts) {\n  // Assumptions\n  // Origin is on bottom-left , and X increase to right, Y to top\n  // When processing one cell, we process 4 cells, by extending row to top and on column to right\n  // to create a 2X2 cell grid\n  const {\n    x,\n    y,\n    xRange,\n    yRange,\n    getValue,\n    threshold\n  } = opts;\n  const isLeftBoundary = x < xRange[0];\n  const isRightBoundary = x >= xRange[1] - 1;\n  const isBottomBoundary = y < yRange[0];\n  const isTopBoundary = y >= yRange[1] - 1;\n  const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;\n  let weights = 0;\n  let current;\n  let right;\n  let top;\n  let topRight;\n  // TOP\n  if (isLeftBoundary || isTopBoundary) {\n    top = 0;\n  } else {\n    const w = getValue(x, y + 1);\n    top = getVertexCode(w, threshold);\n    weights += w;\n  }\n  // TOP-RIGHT\n  if (isRightBoundary || isTopBoundary) {\n    topRight = 0;\n  } else {\n    const w = getValue(x + 1, y + 1);\n    topRight = getVertexCode(w, threshold);\n    weights += w;\n  }\n  // RIGHT\n  if (isRightBoundary || isBottomBoundary) {\n    right = 0;\n  } else {\n    const w = getValue(x + 1, y);\n    right = getVertexCode(w, threshold);\n    weights += w;\n  }\n  // CURRENT\n  if (isLeftBoundary || isBottomBoundary) {\n    current = 0;\n  } else {\n    const w = getValue(x, y);\n    current = getVertexCode(w, threshold);\n    weights += w;\n  }\n  let code = -1;\n  if (Number.isFinite(threshold)) {\n    code = top << 3 | topRight << 2 | right << 1 | current;\n  }\n  if (Array.isArray(threshold)) {\n    code = top << 6 | topRight << 4 | right << 2 | current;\n  }\n  let meanCode = 0;\n  // meanCode is only needed for saddle cases, and they should\n  // only occur when we are not processing a cell on boundary\n  // because when on a boundary either, bottom-row, top-row, left-column or right-column will have both 0 codes\n  if (!isBoundary) {\n    meanCode = getVertexCode(weights / 4, threshold);\n  }\n  return {\n    code,\n    meanCode\n  };\n}\n/* eslint-enable complexity, max-statements*/\n// Returns intersection vertices for given cellindex\n// [x, y] refers current marching cell, reference vertex is always top-right corner\nexport function getPolygons(opts) {\n  const {\n    x,\n    y,\n    z,\n    code,\n    meanCode\n  } = opts;\n  let offsets = ISOBANDS_CODE_OFFSET_MAP[code];\n  // handle saddle cases\n  if (!Array.isArray(offsets)) {\n    offsets = offsets[meanCode];\n  }\n  // Reference vertex is at top-right move to top-right corner\n  const rX = x + 1;\n  const rY = y + 1;\n  // offsets format\n  // [[1A, 1B, 1C, ...], [2A, 2B, 2C, ...]],\n  // vertices format\n  // [\n  //   [[x1A, y1A], [x1B, y1B], [x1C, y1C] ... ],\n  //        ...\n  // ]\n  const polygons = [];\n  offsets.forEach(polygonOffsets => {\n    const polygon = [];\n    polygonOffsets.forEach(xyOffset => {\n      const vX = rX + xyOffset[0];\n      const vY = rY + xyOffset[1];\n      polygon.push([vX, vY, z]);\n    });\n    polygons.push(polygon);\n  });\n  return polygons;\n}\n// Returns intersection vertices for given cellindex\n// [x, y] refers current marching cell, reference vertex is always top-right corner\nexport function getLines(opts) {\n  const {\n    x,\n    y,\n    z,\n    code,\n    meanCode\n  } = opts;\n  let offsets = ISOLINES_CODE_OFFSET_MAP[code];\n  // handle saddle cases\n  if (!Array.isArray(offsets)) {\n    offsets = offsets[meanCode];\n  }\n  // Reference vertex is at top-right move to top-right corner\n  const rX = x + 1;\n  const rY = y + 1;\n  // offsets format\n  // [[1A, 1B], [2A, 2B]],\n  // vertices format\n  // [[x1A, y1A], [x1B, y1B], [x2A, x2B], ...],\n  const lines = [];\n  offsets.forEach(xyOffsets => {\n    xyOffsets.forEach(offset => {\n      const vX = rX + offset[0];\n      const vY = rY + offset[1];\n      lines.push([vX, vY, z]);\n    });\n  });\n  return lines;\n}\n//# sourceMappingURL=marching-squares.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}