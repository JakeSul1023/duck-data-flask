{"ast":null,"code":"import { GLTFScenegraph } from \"../api/gltf-scenegraph.js\";\nimport { convertRawBufferToMetadataArray, getPrimitiveTextureData, primitivePropertyDataToAttributes, getArrayElementByteSize, getOffsetsForProperty, parseVariableLengthArrayNumeric, parseFixedLengthArrayNumeric, getPropertyDataString } from \"./utils/3d-tiles-utils.js\";\nconst EXT_STRUCTURAL_METADATA_NAME = 'EXT_structural_metadata';\nexport const name = EXT_STRUCTURAL_METADATA_NAME;\nexport async function decode(gltfData, options) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  decodeExtStructuralMetadata(scenegraph, options);\n}\nexport function encode(gltfData, options) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  encodeExtStructuralMetadata(scenegraph, options);\n  scenegraph.createBinaryChunk();\n  return scenegraph.gltf;\n}\n/*\n// Example of the extension.\n// See more info at https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata\nconst extensions = {\n  \"extensions\": {\n    \"EXT_structural_metadata\": {\n      \"schema\": {\n        \"classes\": {\n          \"tree\": {\n            \"name\": \"Tree\",\n            \"description\": \"Woody, perennial plant.\",\n            \"properties\": {\n              \"species\": {\n                \"description\": \"Type of tree.\",\n                \"type\": \"ENUM\",\n                \"enumType\": \"speciesEnum\",\n                \"required\": true\n              },\n              \"age\": {\n                \"description\": \"The age of the tree, in years\",\n                \"type\": \"SCALAR\",\n                \"componentType\": \"UINT8\",\n                \"required\": true\n              }\n            }\n          }\n        },\n        \"enums\": {\n          \"speciesEnum\": {\n            \"name\": \"Species\",\n            \"description\": \"An example enum for tree species.\",\n            // valueType is not defined here. Default is \"UINT16\"\n            \"values\": [\n              { \"name\": \"Unspecified\", \"value\": 0 },\n              { \"name\": \"Oak\", \"value\": 1 }\n            ]\n          }\n        }\n      },\n      \"propertyTables\": [{\n        \"name\": \"tree_survey_2021-09-29\",\n        \"class\": \"tree\",\n        \"count\": 10,  // The number of elements in each property array (in `species`, in `age`).\n        \"properties\": {\n          \"species\": {\n            \"values\": 0, // It's an index of the buffer view containing property values.\n          },\n          \"age\": {\n            \"values\": 1\n          }\n        }\n      }]\n    }\n  }\n}\n*/\n/**\n * Decodes feature metadata from extension.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param options - GLTFLoader options.\n */\nfunction decodeExtStructuralMetadata(scenegraph, options) {\n  // Decoding metadata involves buffers processing.\n  // So, if buffers have not been loaded, there is no reason to process metadata.\n  if (!options.gltf?.loadBuffers) {\n    return;\n  }\n  const extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);\n  if (!extension) {\n    return;\n  }\n  if (options.gltf?.loadImages) {\n    decodePropertyTextures(scenegraph, extension);\n  }\n  decodePropertyTables(scenegraph, extension);\n}\n/**\n * Processes the data stored in the textures\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param extension - Top-level extension.\n */\nfunction decodePropertyTextures(scenegraph, extension) {\n  const propertyTextures = extension.propertyTextures;\n  const json = scenegraph.gltf.json;\n  if (propertyTextures && json.meshes) {\n    // Iterate through all meshes/primitives.\n    for (const mesh of json.meshes) {\n      for (const primitive of mesh.primitives) {\n        processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension);\n      }\n    }\n  }\n}\n/**\n * Processes the data stored in the property tables.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param extension - Top-level extension.\n */\nfunction decodePropertyTables(scenegraph, extension) {\n  const schema = extension.schema;\n  if (!schema) {\n    return;\n  }\n  const schemaClasses = schema.classes;\n  const propertyTables = extension.propertyTables;\n  if (schemaClasses && propertyTables) {\n    for (const schemaName in schemaClasses) {\n      const propertyTable = findPropertyTableByClass(propertyTables, schemaName);\n      if (propertyTable) {\n        processPropertyTable(scenegraph, schema, propertyTable);\n      }\n    }\n  }\n}\n/**\n * Finds the property table by class name.\n * @param propertyTables - propertyTable definition taken from the top-level extension.\n * @param schemaClassName - class name in the extension schema.\n */\nfunction findPropertyTableByClass(propertyTables, schemaClassName) {\n  for (const propertyTable of propertyTables) {\n    if (propertyTable.class === schemaClassName) {\n      return propertyTable;\n    }\n  }\n  return null;\n}\n/**\n * Takes data from property textures reffered by the primitive.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyTextures - propertyTexture definition taken from the top-level extention.\n * @param primitive - Primitive object.\n * @param extension - Top-level extension.\n */\nfunction processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension) {\n  if (!propertyTextures) {\n    return;\n  }\n  const primitiveExtension = primitive.extensions?.[EXT_STRUCTURAL_METADATA_NAME];\n  const primitivePropertyTextureIndices = primitiveExtension?.propertyTextures;\n  if (!primitivePropertyTextureIndices) {\n    return;\n  }\n  for (const primitivePropertyTextureIndex of primitivePropertyTextureIndices) {\n    const propertyTexture = propertyTextures[primitivePropertyTextureIndex];\n    processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension);\n  }\n}\n/**\n * Takes property data from the texture pointed by the primitive and appends them to `exension.data`.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyTexture - propertyTexture definition taken from the top-level extension.\n * @param primitive - Primitive object.\n * @param extension - Top-level extension.\n */\nfunction processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension) {\n  if (!propertyTexture.properties) {\n    return;\n  }\n  if (!extension.dataAttributeNames) {\n    extension.dataAttributeNames = [];\n  }\n  /* Iterate through all properties defined in propertyTexture, e.g. \"speed\" and \"direction\":\n    {\n      \"class\": \"wind\",\n      \"properties\": {\n        \"speed\": {\n          \"index\": 0,\n          \"texCoord\": 0,\n          \"channels\": [0]\n        },\n        \"direction\": {\n          \"index\": 0,\n          \"texCoord\": 0,\n          \"channels\": [1, 2]\n        }\n      }\n    }\n  */\n  const className = propertyTexture.class;\n  for (const propertyName in propertyTexture.properties) {\n    // propertyName has values like \"speed\", \"direction\"\n    // Make attributeName as a combination of the class name and the propertyName like \"wind_speed\" or \"wind_direction\"\n    const attributeName = `${className}_${propertyName}`;\n    const textureInfoTopLevel = propertyTexture.properties?.[propertyName];\n    if (!textureInfoTopLevel) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    // The data taken from all meshes/primitives (the same property, e.g. \"speed\" or \"direction\") will be combined into one array and saved in textureInfoTopLevel.data\n    // Initially textureInfoTopLevel.data will be initialized with an empty array.\n    if (!textureInfoTopLevel.data) {\n      textureInfoTopLevel.data = [];\n    }\n    const featureTextureTable = textureInfoTopLevel.data;\n    const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);\n    if (propertyData === null) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);\n    textureInfoTopLevel.data = featureTextureTable;\n    extension.dataAttributeNames.push(attributeName);\n  }\n}\n/**\n * Navigates through all properies in the property table, gets properties data,\n * and put the data to `propertyTable.data` as an array.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param schema - schema object.\n * @param propertyTable - propertyTable definition taken from the top-level extension.\n */\nfunction processPropertyTable(scenegraph, schema, propertyTable) {\n  const schemaClass = schema.classes?.[propertyTable.class];\n  if (!schemaClass) {\n    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);\n  }\n  const numberOfElements = propertyTable.count; // `propertyTable.count` is a number of elements in each property array.\n  for (const propertyName in schemaClass.properties) {\n    const classProperty = schemaClass.properties[propertyName];\n    const propertyTableProperty = propertyTable.properties?.[propertyName];\n    if (propertyTableProperty) {\n      // Getting all elements (`numberOfElements`) of the array in the `propertyTableProperty`\n      const data = getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);\n      propertyTableProperty.data = data;\n    }\n  }\n}\n/**\n * Decodes a propertyTable column from binary source based on property type.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param schema - Schema object.\n * @param classProperty - class property object.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @returns {string[] | number[] | string[][] | number[][]}\n */\nfunction getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty) {\n  let data = [];\n  const valuesBufferView = propertyTableProperty.values;\n  const valuesDataBytes = scenegraph.getTypedArrayForBufferView(valuesBufferView);\n  const arrayOffsets = getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements);\n  const stringOffsets = getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements);\n  switch (classProperty.type) {\n    case 'SCALAR':\n    case 'VEC2':\n    case 'VEC3':\n    case 'VEC4':\n    case 'MAT2':\n    case 'MAT3':\n    case 'MAT4':\n      {\n        data = getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets);\n        break;\n      }\n    case 'BOOLEAN':\n      {\n        // TODO: implement it as soon as we have the corresponding tileset\n        throw new Error(`Not implemented - classProperty.type=${classProperty.type}`);\n      }\n    case 'STRING':\n      {\n        data = getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets);\n        break;\n      }\n    case 'ENUM':\n      {\n        data = getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets);\n        break;\n      }\n    default:\n      throw new Error(`Unknown classProperty type ${classProperty.type}`);\n  }\n  return data;\n}\n/**\n * Parses propertyTable.property.arrayOffsets that are offsets of sub-arrays in a flatten array of values.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param classProperty - class property object.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @returns Typed array with offset values.\n * @see https://github.com/CesiumGS/glTF/blob/2976f1183343a47a29e4059a70961371cd2fcee8/extensions/2.0/Vendor/EXT_structural_metadata/schema/propertyTable.property.schema.json#L21\n */\nfunction getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements) {\n  if (classProperty.array &&\n  // `count` is a number of array elements. May only be defined when `array` is true.\n  // If `count` is NOT defined, it's a VARIABLE-length array\n  typeof classProperty.count === 'undefined' &&\n  // `arrayOffsets` is an index of the buffer view containing offsets for variable-length arrays.\n  typeof propertyTableProperty.arrayOffsets !== 'undefined') {\n    // Data are in a VARIABLE-length array\n    return getOffsetsForProperty(scenegraph, propertyTableProperty.arrayOffsets, propertyTableProperty.arrayOffsetType || 'UINT32', numberOfElements);\n  }\n  return null;\n}\n/**\n * Parses propertyTable.property.stringOffsets.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @returns Typed array with offset values.\n * @see https://github.com/CesiumGS/glTF/blob/2976f1183343a47a29e4059a70961371cd2fcee8/extensions/2.0/Vendor/EXT_structural_metadata/schema/propertyTable.property.schema.json#L29C10-L29C23\n */\nfunction getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements) {\n  if (typeof propertyTableProperty.stringOffsets !== 'undefined' // `stringOffsets` is an index of the buffer view containing offsets for strings.\n  ) {\n    // Data are in a FIXED-length array\n    return getOffsetsForProperty(scenegraph, propertyTableProperty.stringOffsets, propertyTableProperty.stringOffsetType || 'UINT32', numberOfElements);\n  }\n  return null;\n}\n/**\n * Decodes properties of SCALAR, VEC-N, MAT-N types from binary sourse.\n * @param classProperty - class property object.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param valuesDataBytes - Data taken from values property of the property table property.\n * @param arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @returns Property values in a typed array or in an array of typed arrays.\n */\nfunction getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {\n  const isArray = classProperty.array;\n  const arrayCount = classProperty.count;\n  const elementSize = getArrayElementByteSize(classProperty.type, classProperty.componentType);\n  const elementCount = valuesDataBytes.byteLength / elementSize;\n  let valuesData;\n  if (classProperty.componentType) {\n    valuesData = convertRawBufferToMetadataArray(valuesDataBytes, classProperty.type,\n    // The datatype of the element's components. Only applicable to `SCALAR`, `VECN`, and `MATN` types.\n    classProperty.componentType, elementCount);\n  } else {\n    // The spec doesn't provide any info what to do if componentType is not set.\n    valuesData = valuesDataBytes;\n  }\n  if (isArray) {\n    if (arrayOffsets) {\n      // VARIABLE-length array\n      return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);\n    }\n    if (arrayCount) {\n      // FIXED-length array\n      return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);\n    }\n    return [];\n  }\n  return valuesData;\n}\n/**\n * Decodes properties of enum type from binary source.\n * @param schema - Schema object.\n * @param classProperty - Class property object.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param valuesDataBytes - Data taken from values property of the property table property.\n * @param arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @returns Strings array of nested strings array.\n */\nfunction getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {\n  const enumType = classProperty.enumType;\n  // Enum ID as declared in the `enums` dictionary. Required when `type` is `ENUM`.\n  if (!enumType) {\n    throw new Error('Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM');\n  }\n  const enumEntry = schema.enums?.[enumType];\n  if (!enumEntry) {\n    throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${enumType}`);\n  }\n  const enumValueType = enumEntry.valueType || 'UINT16';\n  const elementSize = getArrayElementByteSize(classProperty.type, enumValueType);\n  const elementCount = valuesDataBytes.byteLength / elementSize;\n  let valuesData = convertRawBufferToMetadataArray(valuesDataBytes, classProperty.type, enumValueType, elementCount);\n  if (!valuesData) {\n    valuesData = valuesDataBytes;\n  }\n  if (classProperty.array) {\n    if (arrayOffsets) {\n      // VARIABLE-length array\n      return parseVariableLengthArrayENUM({\n        valuesData,\n        numberOfElements,\n        arrayOffsets,\n        valuesDataBytesLength: valuesDataBytes.length,\n        elementSize,\n        enumEntry\n      });\n    }\n    const arrayCount = classProperty.count;\n    if (arrayCount) {\n      // FIXED-length array\n      return parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry);\n    }\n    return [];\n  }\n  // Single value (not an array)\n  return getEnumsArray(valuesData, 0, numberOfElements, enumEntry);\n}\n/**\n * Parses variable length nested ENUM arrays.\n * @param params.valuesData - Values in a flat typed array.\n * @param params.numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param params.arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @param params.valuesDataBytesLength - Byte length of values array.\n * @param params.elementSize - Single element byte size.\n * @param params.enumEntry - Enums dictionary.\n * @returns Nested strings array.\n */\nfunction parseVariableLengthArrayENUM(params) {\n  const {\n    valuesData,\n    numberOfElements,\n    arrayOffsets,\n    valuesDataBytesLength,\n    elementSize,\n    enumEntry\n  } = params;\n  const attributeValueArray = [];\n  for (let index = 0; index < numberOfElements; index++) {\n    const arrayOffset = arrayOffsets[index];\n    const arrayByteSize = arrayOffsets[index + 1] - arrayOffsets[index];\n    if (arrayByteSize + arrayOffset > valuesDataBytesLength) {\n      break;\n    }\n    const typedArrayOffset = arrayOffset / elementSize;\n    const elementCount = arrayByteSize / elementSize;\n    const array = getEnumsArray(valuesData, typedArrayOffset, elementCount, enumEntry);\n    attributeValueArray.push(array);\n  }\n  return attributeValueArray;\n}\n/**\n * Parses fixed length ENUM arrays.\n * @param valuesData - Values in a flat typed array.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param arrayCount - Nested arrays length.\n * @param enumEntry - Enums dictionary.\n * @returns Nested strings array.\n */\nfunction parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry) {\n  const attributeValueArray = [];\n  for (let index = 0; index < numberOfElements; index++) {\n    const elementOffset = arrayCount * index;\n    const array = getEnumsArray(valuesData, elementOffset, arrayCount, enumEntry);\n    attributeValueArray.push(array);\n  }\n  return attributeValueArray;\n}\n/**\n * Parses ENUM values into a string array.\n * @param valuesData - Values in a flat typed array.\n * @param offset - Offset to start parse from.\n * @param count - Values length to parse.\n * @param enumEntry - Enums dictionary.\n * @returns Array of strings with parsed ENUM names.\n */\nfunction getEnumsArray(valuesData, offset, count, enumEntry) {\n  const array = [];\n  for (let i = 0; i < count; i++) {\n    // At the moment we don't support BigInt. It requires additional calculations logic\n    // and might be an issue in Safari\n    if (valuesData instanceof BigInt64Array || valuesData instanceof BigUint64Array) {\n      array.push('');\n    } else {\n      const value = valuesData[offset + i];\n      const enumObject = getEnumByValue(enumEntry, value);\n      if (enumObject) {\n        array.push(enumObject.name);\n      } else {\n        array.push('');\n      }\n    }\n  }\n  return array;\n}\n/**\n * Looks up ENUM whose `value` property matches the specified number in the parameter `value`.\n * @param {GLTF_EXT_structural_metadata_Enum} enumEntry - ENUM entry containing the array of possible enums.\n * @param {number} value - The value of the ENUM to locate.\n * @returns {GLTF_EXT_structural_metadata_EnumValue | null} ENUM matcihng the specified value or null of no ENUM object was found.\n */\nfunction getEnumByValue(enumEntry, value) {\n  for (const enumValue of enumEntry.values) {\n    if (enumValue.value === value) {\n      return enumValue;\n    }\n  }\n  return null;\n}\nconst SCHEMA_CLASS_ID_DEFAULT = 'schemaClassId';\nfunction encodeExtStructuralMetadata(scenegraph, options) {\n  const extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);\n  if (!extension) {\n    return;\n  }\n  if (extension.propertyTables) {\n    for (const table of extension.propertyTables) {\n      const classId = table.class;\n      const schemaClass = extension.schema?.classes?.[classId];\n      if (table.properties && schemaClass) {\n        encodeProperties(table, schemaClass, scenegraph);\n      }\n    }\n  }\n}\nfunction encodeProperties(table, schemaClass, scenegraph) {\n  for (const propertyName in table.properties) {\n    const data = table.properties[propertyName].data;\n    if (data) {\n      const classProperty = schemaClass.properties[propertyName];\n      if (classProperty) {\n        const tableProperty = createPropertyTableProperty(data, classProperty, scenegraph);\n        // Override table property that came with \"data\"\n        table.properties[propertyName] = tableProperty;\n      }\n    }\n  }\n}\n/**\n * Creates ExtStructuralMetadata, creates the schema and creates a property table containing feature data provided.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyAttributes - property attributes\n * @param classId - classId to use for encoding metadata.\n * @returns Index of the table created.\n */\nexport function createExtStructuralMetadata(scenegraph, propertyAttributes, classId = SCHEMA_CLASS_ID_DEFAULT) {\n  let extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);\n  if (!extension) {\n    extension = scenegraph.addExtension(EXT_STRUCTURAL_METADATA_NAME);\n  }\n  extension.schema = createSchema(propertyAttributes, classId, extension.schema);\n  const table = createPropertyTable(propertyAttributes, classId, extension.schema);\n  if (!extension.propertyTables) {\n    extension.propertyTables = [];\n  }\n  return extension.propertyTables.push(table) - 1; // index of the table\n}\nfunction createSchema(propertyAttributes, classId, schemaToUpdate) {\n  const schema = schemaToUpdate ?? {\n    id: 'schema_id'\n  };\n  const schemaClass = {\n    properties: {}\n  };\n  for (const attribute of propertyAttributes) {\n    const classProperty = {\n      type: attribute.elementType,\n      componentType: attribute.componentType\n    };\n    schemaClass.properties[attribute.name] = classProperty;\n  }\n  schema.classes = {};\n  schema.classes[classId] = schemaClass;\n  return schema;\n}\nfunction createPropertyTable(propertyAttributes, classId, schema) {\n  const table = {\n    class: classId,\n    count: 0\n  };\n  // count is a number of rows in the table\n  let count = 0;\n  const schemaClass = schema.classes?.[classId];\n  for (const attribute of propertyAttributes) {\n    if (count === 0) {\n      count = attribute.values.length;\n    }\n    // The number of elements in all propertyAttributes must be the same\n    if (count !== attribute.values.length && attribute.values.length) {\n      throw new Error('Illegal values in attributes');\n    }\n    const classProperty = schemaClass?.properties[attribute.name];\n    if (classProperty) {\n      // const tableProperty = createPropertyTableProperty(attribute, classProperty, scenegraph);\n      if (!table.properties) {\n        table.properties = {};\n      }\n      // values is a required field. Its real value will be set while encoding data\n      table.properties[attribute.name] = {\n        values: 0,\n        data: attribute.values\n      };\n    }\n  }\n  table.count = count;\n  return table;\n}\nfunction createPropertyTableProperty(\n// attribute: PropertyAttribute,\nvalues, classProperty, scenegraph) {\n  const prop = {\n    values: 0\n  };\n  if (classProperty.type === 'STRING') {\n    const {\n      stringData,\n      stringOffsets\n    } = createPropertyDataString(values);\n    prop.stringOffsets = createBufferView(stringOffsets, scenegraph);\n    prop.values = createBufferView(stringData, scenegraph);\n  } else if (classProperty.type === 'SCALAR' && classProperty.componentType) {\n    const data = createPropertyDataScalar(values, classProperty.componentType);\n    prop.values = createBufferView(data, scenegraph);\n  }\n  return prop;\n}\nconst COMPONENT_TYPE_TO_ARRAY_CONSTRUCTOR = {\n  INT8: Int8Array,\n  UINT8: Uint8Array,\n  INT16: Int16Array,\n  UINT16: Uint16Array,\n  INT32: Int32Array,\n  UINT32: Uint32Array,\n  INT64: Int32Array,\n  UINT64: Uint32Array,\n  FLOAT32: Float32Array,\n  FLOAT64: Float64Array\n};\nfunction createPropertyDataScalar(array, componentType) {\n  const numberArray = [];\n  for (const value of array) {\n    numberArray.push(Number(value));\n  }\n  const Construct = COMPONENT_TYPE_TO_ARRAY_CONSTRUCTOR[componentType];\n  if (!Construct) {\n    throw new Error('Illegal component type');\n  }\n  return new Construct(numberArray);\n}\nfunction createPropertyDataString(strings) {\n  const utf8Encode = new TextEncoder();\n  const arr = [];\n  let len = 0;\n  for (const str of strings) {\n    const uint8Array = utf8Encode.encode(str);\n    len += uint8Array.length;\n    arr.push(uint8Array);\n  }\n  const strArray = new Uint8Array(len);\n  const strOffsets = [];\n  let offset = 0;\n  for (const str of arr) {\n    strArray.set(str, offset);\n    strOffsets.push(offset);\n    offset += str.length;\n  }\n  strOffsets.push(offset); // The last offset represents the byte offset after the last string.\n  const stringOffsetsTypedArray = new Uint32Array(strOffsets); // Its length = len+1\n  return {\n    stringData: strArray,\n    stringOffsets: stringOffsetsTypedArray\n  };\n}\nfunction createBufferView(typedArray, scenegraph) {\n  scenegraph.gltf.buffers.push({\n    arrayBuffer: typedArray.buffer,\n    byteOffset: typedArray.byteOffset,\n    byteLength: typedArray.byteLength\n  });\n  return scenegraph.addBufferView(typedArray);\n}","map":{"version":3,"names":["GLTFScenegraph","convertRawBufferToMetadataArray","getPrimitiveTextureData","primitivePropertyDataToAttributes","getArrayElementByteSize","getOffsetsForProperty","parseVariableLengthArrayNumeric","parseFixedLengthArrayNumeric","getPropertyDataString","EXT_STRUCTURAL_METADATA_NAME","name","decode","gltfData","options","scenegraph","decodeExtStructuralMetadata","encode","encodeExtStructuralMetadata","createBinaryChunk","gltf","loadBuffers","extension","getExtension","loadImages","decodePropertyTextures","decodePropertyTables","propertyTextures","json","meshes","mesh","primitive","primitives","processPrimitivePropertyTextures","schema","schemaClasses","classes","propertyTables","schemaName","propertyTable","findPropertyTableByClass","processPropertyTable","schemaClassName","class","primitiveExtension","extensions","primitivePropertyTextureIndices","primitivePropertyTextureIndex","propertyTexture","processPrimitivePropertyTexture","properties","dataAttributeNames","className","propertyName","attributeName","textureInfoTopLevel","data","featureTextureTable","propertyData","push","schemaClass","Error","numberOfElements","count","classProperty","propertyTableProperty","getPropertyDataFromBinarySource","valuesBufferView","values","valuesDataBytes","getTypedArrayForBufferView","arrayOffsets","getArrayOffsetsForProperty","stringOffsets","getStringOffsetsForProperty","type","getPropertyDataNumeric","getPropertyDataENUM","array","arrayOffsetType","stringOffsetType","isArray","arrayCount","elementSize","componentType","elementCount","byteLength","valuesData","length","enumType","enumEntry","enums","enumValueType","valueType","parseVariableLengthArrayENUM","valuesDataBytesLength","parseFixedLengthArrayENUM","getEnumsArray","params","attributeValueArray","index","arrayOffset","arrayByteSize","typedArrayOffset","elementOffset","offset","i","BigInt64Array","BigUint64Array","value","enumObject","getEnumByValue","enumValue","SCHEMA_CLASS_ID_DEFAULT","table","classId","encodeProperties","tableProperty","createPropertyTableProperty","createExtStructuralMetadata","propertyAttributes","addExtension","createSchema","createPropertyTable","schemaToUpdate","id","attribute","elementType","prop","stringData","createPropertyDataString","createBufferView","createPropertyDataScalar","COMPONENT_TYPE_TO_ARRAY_CONSTRUCTOR","INT8","Int8Array","UINT8","Uint8Array","INT16","Int16Array","UINT16","Uint16Array","INT32","Int32Array","UINT32","Uint32Array","INT64","UINT64","FLOAT32","Float32Array","FLOAT64","Float64Array","numberArray","Number","Construct","strings","utf8Encode","TextEncoder","arr","len","str","uint8Array","strArray","strOffsets","set","stringOffsetsTypedArray","typedArray","buffers","arrayBuffer","buffer","byteOffset","addBufferView"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_structural_metadata.js"],"sourcesContent":["import { GLTFScenegraph } from \"../api/gltf-scenegraph.js\";\nimport { convertRawBufferToMetadataArray, getPrimitiveTextureData, primitivePropertyDataToAttributes, getArrayElementByteSize, getOffsetsForProperty, parseVariableLengthArrayNumeric, parseFixedLengthArrayNumeric, getPropertyDataString } from \"./utils/3d-tiles-utils.js\";\nconst EXT_STRUCTURAL_METADATA_NAME = 'EXT_structural_metadata';\nexport const name = EXT_STRUCTURAL_METADATA_NAME;\nexport async function decode(gltfData, options) {\n    const scenegraph = new GLTFScenegraph(gltfData);\n    decodeExtStructuralMetadata(scenegraph, options);\n}\nexport function encode(gltfData, options) {\n    const scenegraph = new GLTFScenegraph(gltfData);\n    encodeExtStructuralMetadata(scenegraph, options);\n    scenegraph.createBinaryChunk();\n    return scenegraph.gltf;\n}\n/*\n// Example of the extension.\n// See more info at https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata\nconst extensions = {\n  \"extensions\": {\n    \"EXT_structural_metadata\": {\n      \"schema\": {\n        \"classes\": {\n          \"tree\": {\n            \"name\": \"Tree\",\n            \"description\": \"Woody, perennial plant.\",\n            \"properties\": {\n              \"species\": {\n                \"description\": \"Type of tree.\",\n                \"type\": \"ENUM\",\n                \"enumType\": \"speciesEnum\",\n                \"required\": true\n              },\n              \"age\": {\n                \"description\": \"The age of the tree, in years\",\n                \"type\": \"SCALAR\",\n                \"componentType\": \"UINT8\",\n                \"required\": true\n              }\n            }\n          }\n        },\n        \"enums\": {\n          \"speciesEnum\": {\n            \"name\": \"Species\",\n            \"description\": \"An example enum for tree species.\",\n            // valueType is not defined here. Default is \"UINT16\"\n            \"values\": [\n              { \"name\": \"Unspecified\", \"value\": 0 },\n              { \"name\": \"Oak\", \"value\": 1 }\n            ]\n          }\n        }\n      },\n      \"propertyTables\": [{\n        \"name\": \"tree_survey_2021-09-29\",\n        \"class\": \"tree\",\n        \"count\": 10,  // The number of elements in each property array (in `species`, in `age`).\n        \"properties\": {\n          \"species\": {\n            \"values\": 0, // It's an index of the buffer view containing property values.\n          },\n          \"age\": {\n            \"values\": 1\n          }\n        }\n      }]\n    }\n  }\n}\n*/\n/**\n * Decodes feature metadata from extension.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param options - GLTFLoader options.\n */\nfunction decodeExtStructuralMetadata(scenegraph, options) {\n    // Decoding metadata involves buffers processing.\n    // So, if buffers have not been loaded, there is no reason to process metadata.\n    if (!options.gltf?.loadBuffers) {\n        return;\n    }\n    const extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);\n    if (!extension) {\n        return;\n    }\n    if (options.gltf?.loadImages) {\n        decodePropertyTextures(scenegraph, extension);\n    }\n    decodePropertyTables(scenegraph, extension);\n}\n/**\n * Processes the data stored in the textures\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param extension - Top-level extension.\n */\nfunction decodePropertyTextures(scenegraph, extension) {\n    const propertyTextures = extension.propertyTextures;\n    const json = scenegraph.gltf.json;\n    if (propertyTextures && json.meshes) {\n        // Iterate through all meshes/primitives.\n        for (const mesh of json.meshes) {\n            for (const primitive of mesh.primitives) {\n                processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension);\n            }\n        }\n    }\n}\n/**\n * Processes the data stored in the property tables.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param extension - Top-level extension.\n */\nfunction decodePropertyTables(scenegraph, extension) {\n    const schema = extension.schema;\n    if (!schema) {\n        return;\n    }\n    const schemaClasses = schema.classes;\n    const propertyTables = extension.propertyTables;\n    if (schemaClasses && propertyTables) {\n        for (const schemaName in schemaClasses) {\n            const propertyTable = findPropertyTableByClass(propertyTables, schemaName);\n            if (propertyTable) {\n                processPropertyTable(scenegraph, schema, propertyTable);\n            }\n        }\n    }\n}\n/**\n * Finds the property table by class name.\n * @param propertyTables - propertyTable definition taken from the top-level extension.\n * @param schemaClassName - class name in the extension schema.\n */\nfunction findPropertyTableByClass(propertyTables, schemaClassName) {\n    for (const propertyTable of propertyTables) {\n        if (propertyTable.class === schemaClassName) {\n            return propertyTable;\n        }\n    }\n    return null;\n}\n/**\n * Takes data from property textures reffered by the primitive.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyTextures - propertyTexture definition taken from the top-level extention.\n * @param primitive - Primitive object.\n * @param extension - Top-level extension.\n */\nfunction processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension) {\n    if (!propertyTextures) {\n        return;\n    }\n    const primitiveExtension = primitive.extensions?.[EXT_STRUCTURAL_METADATA_NAME];\n    const primitivePropertyTextureIndices = primitiveExtension?.propertyTextures;\n    if (!primitivePropertyTextureIndices) {\n        return;\n    }\n    for (const primitivePropertyTextureIndex of primitivePropertyTextureIndices) {\n        const propertyTexture = propertyTextures[primitivePropertyTextureIndex];\n        processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension);\n    }\n}\n/**\n * Takes property data from the texture pointed by the primitive and appends them to `exension.data`.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyTexture - propertyTexture definition taken from the top-level extension.\n * @param primitive - Primitive object.\n * @param extension - Top-level extension.\n */\nfunction processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension) {\n    if (!propertyTexture.properties) {\n        return;\n    }\n    if (!extension.dataAttributeNames) {\n        extension.dataAttributeNames = [];\n    }\n    /* Iterate through all properties defined in propertyTexture, e.g. \"speed\" and \"direction\":\n      {\n        \"class\": \"wind\",\n        \"properties\": {\n          \"speed\": {\n            \"index\": 0,\n            \"texCoord\": 0,\n            \"channels\": [0]\n          },\n          \"direction\": {\n            \"index\": 0,\n            \"texCoord\": 0,\n            \"channels\": [1, 2]\n          }\n        }\n      }\n    */\n    const className = propertyTexture.class;\n    for (const propertyName in propertyTexture.properties) {\n        // propertyName has values like \"speed\", \"direction\"\n        // Make attributeName as a combination of the class name and the propertyName like \"wind_speed\" or \"wind_direction\"\n        const attributeName = `${className}_${propertyName}`;\n        const textureInfoTopLevel = propertyTexture.properties?.[propertyName];\n        if (!textureInfoTopLevel) {\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n        // The data taken from all meshes/primitives (the same property, e.g. \"speed\" or \"direction\") will be combined into one array and saved in textureInfoTopLevel.data\n        // Initially textureInfoTopLevel.data will be initialized with an empty array.\n        if (!textureInfoTopLevel.data) {\n            textureInfoTopLevel.data = [];\n        }\n        const featureTextureTable = textureInfoTopLevel.data;\n        const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);\n        if (propertyData === null) {\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n        primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);\n        textureInfoTopLevel.data = featureTextureTable;\n        extension.dataAttributeNames.push(attributeName);\n    }\n}\n/**\n * Navigates through all properies in the property table, gets properties data,\n * and put the data to `propertyTable.data` as an array.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param schema - schema object.\n * @param propertyTable - propertyTable definition taken from the top-level extension.\n */\nfunction processPropertyTable(scenegraph, schema, propertyTable) {\n    const schemaClass = schema.classes?.[propertyTable.class];\n    if (!schemaClass) {\n        throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);\n    }\n    const numberOfElements = propertyTable.count; // `propertyTable.count` is a number of elements in each property array.\n    for (const propertyName in schemaClass.properties) {\n        const classProperty = schemaClass.properties[propertyName];\n        const propertyTableProperty = propertyTable.properties?.[propertyName];\n        if (propertyTableProperty) {\n            // Getting all elements (`numberOfElements`) of the array in the `propertyTableProperty`\n            const data = getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);\n            propertyTableProperty.data = data;\n        }\n    }\n}\n/**\n * Decodes a propertyTable column from binary source based on property type.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param schema - Schema object.\n * @param classProperty - class property object.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @returns {string[] | number[] | string[][] | number[][]}\n */\nfunction getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty) {\n    let data = [];\n    const valuesBufferView = propertyTableProperty.values;\n    const valuesDataBytes = scenegraph.getTypedArrayForBufferView(valuesBufferView);\n    const arrayOffsets = getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements);\n    const stringOffsets = getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements);\n    switch (classProperty.type) {\n        case 'SCALAR':\n        case 'VEC2':\n        case 'VEC3':\n        case 'VEC4':\n        case 'MAT2':\n        case 'MAT3':\n        case 'MAT4': {\n            data = getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets);\n            break;\n        }\n        case 'BOOLEAN': {\n            // TODO: implement it as soon as we have the corresponding tileset\n            throw new Error(`Not implemented - classProperty.type=${classProperty.type}`);\n        }\n        case 'STRING': {\n            data = getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets);\n            break;\n        }\n        case 'ENUM': {\n            data = getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets);\n            break;\n        }\n        default:\n            throw new Error(`Unknown classProperty type ${classProperty.type}`);\n    }\n    return data;\n}\n/**\n * Parses propertyTable.property.arrayOffsets that are offsets of sub-arrays in a flatten array of values.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param classProperty - class property object.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @returns Typed array with offset values.\n * @see https://github.com/CesiumGS/glTF/blob/2976f1183343a47a29e4059a70961371cd2fcee8/extensions/2.0/Vendor/EXT_structural_metadata/schema/propertyTable.property.schema.json#L21\n */\nfunction getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements) {\n    if (classProperty.array &&\n        // `count` is a number of array elements. May only be defined when `array` is true.\n        // If `count` is NOT defined, it's a VARIABLE-length array\n        typeof classProperty.count === 'undefined' &&\n        // `arrayOffsets` is an index of the buffer view containing offsets for variable-length arrays.\n        typeof propertyTableProperty.arrayOffsets !== 'undefined') {\n        // Data are in a VARIABLE-length array\n        return getOffsetsForProperty(scenegraph, propertyTableProperty.arrayOffsets, propertyTableProperty.arrayOffsetType || 'UINT32', numberOfElements);\n    }\n    return null;\n}\n/**\n * Parses propertyTable.property.stringOffsets.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @returns Typed array with offset values.\n * @see https://github.com/CesiumGS/glTF/blob/2976f1183343a47a29e4059a70961371cd2fcee8/extensions/2.0/Vendor/EXT_structural_metadata/schema/propertyTable.property.schema.json#L29C10-L29C23\n */\nfunction getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements) {\n    if (typeof propertyTableProperty.stringOffsets !== 'undefined' // `stringOffsets` is an index of the buffer view containing offsets for strings.\n    ) {\n        // Data are in a FIXED-length array\n        return getOffsetsForProperty(scenegraph, propertyTableProperty.stringOffsets, propertyTableProperty.stringOffsetType || 'UINT32', numberOfElements);\n    }\n    return null;\n}\n/**\n * Decodes properties of SCALAR, VEC-N, MAT-N types from binary sourse.\n * @param classProperty - class property object.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param valuesDataBytes - Data taken from values property of the property table property.\n * @param arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @returns Property values in a typed array or in an array of typed arrays.\n */\nfunction getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {\n    const isArray = classProperty.array;\n    const arrayCount = classProperty.count;\n    const elementSize = getArrayElementByteSize(classProperty.type, classProperty.componentType);\n    const elementCount = valuesDataBytes.byteLength / elementSize;\n    let valuesData;\n    if (classProperty.componentType) {\n        valuesData = convertRawBufferToMetadataArray(valuesDataBytes, classProperty.type, \n        // The datatype of the element's components. Only applicable to `SCALAR`, `VECN`, and `MATN` types.\n        classProperty.componentType, elementCount);\n    }\n    else {\n        // The spec doesn't provide any info what to do if componentType is not set.\n        valuesData = valuesDataBytes;\n    }\n    if (isArray) {\n        if (arrayOffsets) {\n            // VARIABLE-length array\n            return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);\n        }\n        if (arrayCount) {\n            // FIXED-length array\n            return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);\n        }\n        return [];\n    }\n    return valuesData;\n}\n/**\n * Decodes properties of enum type from binary source.\n * @param schema - Schema object.\n * @param classProperty - Class property object.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param valuesDataBytes - Data taken from values property of the property table property.\n * @param arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @returns Strings array of nested strings array.\n */\nfunction getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {\n    const enumType = classProperty.enumType;\n    // Enum ID as declared in the `enums` dictionary. Required when `type` is `ENUM`.\n    if (!enumType) {\n        throw new Error('Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM');\n    }\n    const enumEntry = schema.enums?.[enumType];\n    if (!enumEntry) {\n        throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${enumType}`);\n    }\n    const enumValueType = enumEntry.valueType || 'UINT16';\n    const elementSize = getArrayElementByteSize(classProperty.type, enumValueType);\n    const elementCount = valuesDataBytes.byteLength / elementSize;\n    let valuesData = convertRawBufferToMetadataArray(valuesDataBytes, classProperty.type, enumValueType, elementCount);\n    if (!valuesData) {\n        valuesData = valuesDataBytes;\n    }\n    if (classProperty.array) {\n        if (arrayOffsets) {\n            // VARIABLE-length array\n            return parseVariableLengthArrayENUM({\n                valuesData,\n                numberOfElements,\n                arrayOffsets,\n                valuesDataBytesLength: valuesDataBytes.length,\n                elementSize,\n                enumEntry\n            });\n        }\n        const arrayCount = classProperty.count;\n        if (arrayCount) {\n            // FIXED-length array\n            return parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry);\n        }\n        return [];\n    }\n    // Single value (not an array)\n    return getEnumsArray(valuesData, 0, numberOfElements, enumEntry);\n}\n/**\n * Parses variable length nested ENUM arrays.\n * @param params.valuesData - Values in a flat typed array.\n * @param params.numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param params.arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @param params.valuesDataBytesLength - Byte length of values array.\n * @param params.elementSize - Single element byte size.\n * @param params.enumEntry - Enums dictionary.\n * @returns Nested strings array.\n */\nfunction parseVariableLengthArrayENUM(params) {\n    const { valuesData, numberOfElements, arrayOffsets, valuesDataBytesLength, elementSize, enumEntry } = params;\n    const attributeValueArray = [];\n    for (let index = 0; index < numberOfElements; index++) {\n        const arrayOffset = arrayOffsets[index];\n        const arrayByteSize = arrayOffsets[index + 1] - arrayOffsets[index];\n        if (arrayByteSize + arrayOffset > valuesDataBytesLength) {\n            break;\n        }\n        const typedArrayOffset = arrayOffset / elementSize;\n        const elementCount = arrayByteSize / elementSize;\n        const array = getEnumsArray(valuesData, typedArrayOffset, elementCount, enumEntry);\n        attributeValueArray.push(array);\n    }\n    return attributeValueArray;\n}\n/**\n * Parses fixed length ENUM arrays.\n * @param valuesData - Values in a flat typed array.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param arrayCount - Nested arrays length.\n * @param enumEntry - Enums dictionary.\n * @returns Nested strings array.\n */\nfunction parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry) {\n    const attributeValueArray = [];\n    for (let index = 0; index < numberOfElements; index++) {\n        const elementOffset = arrayCount * index;\n        const array = getEnumsArray(valuesData, elementOffset, arrayCount, enumEntry);\n        attributeValueArray.push(array);\n    }\n    return attributeValueArray;\n}\n/**\n * Parses ENUM values into a string array.\n * @param valuesData - Values in a flat typed array.\n * @param offset - Offset to start parse from.\n * @param count - Values length to parse.\n * @param enumEntry - Enums dictionary.\n * @returns Array of strings with parsed ENUM names.\n */\nfunction getEnumsArray(valuesData, offset, count, enumEntry) {\n    const array = [];\n    for (let i = 0; i < count; i++) {\n        // At the moment we don't support BigInt. It requires additional calculations logic\n        // and might be an issue in Safari\n        if (valuesData instanceof BigInt64Array || valuesData instanceof BigUint64Array) {\n            array.push('');\n        }\n        else {\n            const value = valuesData[offset + i];\n            const enumObject = getEnumByValue(enumEntry, value);\n            if (enumObject) {\n                array.push(enumObject.name);\n            }\n            else {\n                array.push('');\n            }\n        }\n    }\n    return array;\n}\n/**\n * Looks up ENUM whose `value` property matches the specified number in the parameter `value`.\n * @param {GLTF_EXT_structural_metadata_Enum} enumEntry - ENUM entry containing the array of possible enums.\n * @param {number} value - The value of the ENUM to locate.\n * @returns {GLTF_EXT_structural_metadata_EnumValue | null} ENUM matcihng the specified value or null of no ENUM object was found.\n */\nfunction getEnumByValue(enumEntry, value) {\n    for (const enumValue of enumEntry.values) {\n        if (enumValue.value === value) {\n            return enumValue;\n        }\n    }\n    return null;\n}\nconst SCHEMA_CLASS_ID_DEFAULT = 'schemaClassId';\nfunction encodeExtStructuralMetadata(scenegraph, options) {\n    const extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);\n    if (!extension) {\n        return;\n    }\n    if (extension.propertyTables) {\n        for (const table of extension.propertyTables) {\n            const classId = table.class;\n            const schemaClass = extension.schema?.classes?.[classId];\n            if (table.properties && schemaClass) {\n                encodeProperties(table, schemaClass, scenegraph);\n            }\n        }\n    }\n}\nfunction encodeProperties(table, schemaClass, scenegraph) {\n    for (const propertyName in table.properties) {\n        const data = table.properties[propertyName].data;\n        if (data) {\n            const classProperty = schemaClass.properties[propertyName];\n            if (classProperty) {\n                const tableProperty = createPropertyTableProperty(data, classProperty, scenegraph);\n                // Override table property that came with \"data\"\n                table.properties[propertyName] = tableProperty;\n            }\n        }\n    }\n}\n/**\n * Creates ExtStructuralMetadata, creates the schema and creates a property table containing feature data provided.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyAttributes - property attributes\n * @param classId - classId to use for encoding metadata.\n * @returns Index of the table created.\n */\nexport function createExtStructuralMetadata(scenegraph, propertyAttributes, classId = SCHEMA_CLASS_ID_DEFAULT) {\n    let extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);\n    if (!extension) {\n        extension = scenegraph.addExtension(EXT_STRUCTURAL_METADATA_NAME);\n    }\n    extension.schema = createSchema(propertyAttributes, classId, extension.schema);\n    const table = createPropertyTable(propertyAttributes, classId, extension.schema);\n    if (!extension.propertyTables) {\n        extension.propertyTables = [];\n    }\n    return extension.propertyTables.push(table) - 1; // index of the table\n}\nfunction createSchema(propertyAttributes, classId, schemaToUpdate) {\n    const schema = schemaToUpdate ?? {\n        id: 'schema_id'\n    };\n    const schemaClass = {\n        properties: {}\n    };\n    for (const attribute of propertyAttributes) {\n        const classProperty = {\n            type: attribute.elementType,\n            componentType: attribute.componentType\n        };\n        schemaClass.properties[attribute.name] = classProperty;\n    }\n    schema.classes = {};\n    schema.classes[classId] = schemaClass;\n    return schema;\n}\nfunction createPropertyTable(propertyAttributes, classId, schema) {\n    const table = {\n        class: classId,\n        count: 0\n    };\n    // count is a number of rows in the table\n    let count = 0;\n    const schemaClass = schema.classes?.[classId];\n    for (const attribute of propertyAttributes) {\n        if (count === 0) {\n            count = attribute.values.length;\n        }\n        // The number of elements in all propertyAttributes must be the same\n        if (count !== attribute.values.length && attribute.values.length) {\n            throw new Error('Illegal values in attributes');\n        }\n        const classProperty = schemaClass?.properties[attribute.name];\n        if (classProperty) {\n            // const tableProperty = createPropertyTableProperty(attribute, classProperty, scenegraph);\n            if (!table.properties) {\n                table.properties = {};\n            }\n            // values is a required field. Its real value will be set while encoding data\n            table.properties[attribute.name] = { values: 0, data: attribute.values };\n        }\n    }\n    table.count = count;\n    return table;\n}\nfunction createPropertyTableProperty(\n// attribute: PropertyAttribute,\nvalues, classProperty, scenegraph) {\n    const prop = { values: 0 };\n    if (classProperty.type === 'STRING') {\n        const { stringData, stringOffsets } = createPropertyDataString(values);\n        prop.stringOffsets = createBufferView(stringOffsets, scenegraph);\n        prop.values = createBufferView(stringData, scenegraph);\n    }\n    else if (classProperty.type === 'SCALAR' && classProperty.componentType) {\n        const data = createPropertyDataScalar(values, classProperty.componentType);\n        prop.values = createBufferView(data, scenegraph);\n    }\n    return prop;\n}\nconst COMPONENT_TYPE_TO_ARRAY_CONSTRUCTOR = {\n    INT8: Int8Array,\n    UINT8: Uint8Array,\n    INT16: Int16Array,\n    UINT16: Uint16Array,\n    INT32: Int32Array,\n    UINT32: Uint32Array,\n    INT64: Int32Array,\n    UINT64: Uint32Array,\n    FLOAT32: Float32Array,\n    FLOAT64: Float64Array\n};\nfunction createPropertyDataScalar(array, componentType) {\n    const numberArray = [];\n    for (const value of array) {\n        numberArray.push(Number(value));\n    }\n    const Construct = COMPONENT_TYPE_TO_ARRAY_CONSTRUCTOR[componentType];\n    if (!Construct) {\n        throw new Error('Illegal component type');\n    }\n    return new Construct(numberArray);\n}\nfunction createPropertyDataString(strings) {\n    const utf8Encode = new TextEncoder();\n    const arr = [];\n    let len = 0;\n    for (const str of strings) {\n        const uint8Array = utf8Encode.encode(str);\n        len += uint8Array.length;\n        arr.push(uint8Array);\n    }\n    const strArray = new Uint8Array(len);\n    const strOffsets = [];\n    let offset = 0;\n    for (const str of arr) {\n        strArray.set(str, offset);\n        strOffsets.push(offset);\n        offset += str.length;\n    }\n    strOffsets.push(offset); // The last offset represents the byte offset after the last string.\n    const stringOffsetsTypedArray = new Uint32Array(strOffsets); // Its length = len+1\n    return { stringData: strArray, stringOffsets: stringOffsetsTypedArray };\n}\nfunction createBufferView(typedArray, scenegraph) {\n    scenegraph.gltf.buffers.push({\n        arrayBuffer: typedArray.buffer,\n        byteOffset: typedArray.byteOffset,\n        byteLength: typedArray.byteLength\n    });\n    return scenegraph.addBufferView(typedArray);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}