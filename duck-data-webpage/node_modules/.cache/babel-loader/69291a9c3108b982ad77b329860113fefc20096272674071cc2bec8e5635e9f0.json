{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Layer, project32, picking, log } from '@deck.gl/core';\nimport { pbrMaterial } from '@luma.gl/shadertools';\nimport { ScenegraphNode, GroupNode, ModelNode } from '@luma.gl/engine';\nimport { createScenegraphsFromGLTF } from '@luma.gl/gltf';\nimport { GLTFLoader, postProcessGLTF } from '@loaders.gl/gltf';\nimport { waitForGLTFAssets } from \"./gltf-utils.js\";\nimport { MATRIX_ATTRIBUTES, shouldComposeModelMatrix } from \"../utils/matrix.js\";\nimport { scenegraphUniforms } from \"./scenegraph-layer-uniforms.js\";\nimport vs from \"./scenegraph-layer-vertex.glsl.js\";\nimport fs from \"./scenegraph-layer-fragment.glsl.js\";\nconst DEFAULT_COLOR = [255, 255, 255, 255];\nconst defaultProps = {\n  scenegraph: {\n    type: 'object',\n    value: null,\n    async: true\n  },\n  getScene: gltf => {\n    if (gltf && gltf.scenes) {\n      // gltf post processor replaces `gltf.scene` number with the scene `object`\n      return typeof gltf.scene === 'object' ? gltf.scene : gltf.scenes[gltf.scene || 0];\n    }\n    return gltf;\n  },\n  getAnimator: scenegraph => scenegraph && scenegraph.animator,\n  _animations: null,\n  sizeScale: {\n    type: 'number',\n    value: 1,\n    min: 0\n  },\n  sizeMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  sizeMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  // flat or pbr\n  _lighting: 'flat',\n  // _lighting must be pbr for this to work\n  _imageBasedLightingEnvironment: undefined,\n  // yaw, pitch and roll are in degrees\n  // https://en.wikipedia.org/wiki/Euler_angles\n  // [pitch, yaw, roll]\n  getOrientation: {\n    type: 'accessor',\n    value: [0, 0, 0]\n  },\n  getScale: {\n    type: 'accessor',\n    value: [1, 1, 1]\n  },\n  getTranslation: {\n    type: 'accessor',\n    value: [0, 0, 0]\n  },\n  // 4x4 matrix\n  getTransformMatrix: {\n    type: 'accessor',\n    value: []\n  },\n  loaders: [GLTFLoader]\n};\n/** Render a number of instances of a complete glTF scenegraph. */\nclass ScenegraphLayer extends Layer {\n  getShaders() {\n    const defines = {};\n    let pbr;\n    if (this.props._lighting === 'pbr') {\n      pbr = pbrMaterial;\n      defines.LIGHTING_PBR = 1;\n    } else {\n      // Dummy shader module needed to handle\n      // pbrMaterial.pbr_baseColorSampler binding\n      pbr = {\n        name: 'pbrMaterial'\n      };\n    }\n    const modules = [project32, picking, scenegraphUniforms, pbr];\n    return super.getShaders({\n      defines,\n      vs,\n      fs,\n      modules\n    });\n  }\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    // attributeManager is always defined for primitive layers\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 'float64',\n        fp64: this.use64bitPositions(),\n        accessor: 'getPosition',\n        transition: true\n      },\n      instanceColors: {\n        type: 'unorm8',\n        size: this.props.colorFormat.length,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR,\n        transition: true\n      },\n      instanceModelMatrix: MATRIX_ATTRIBUTES\n    });\n  }\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps\n    } = params;\n    if (props.scenegraph !== oldProps.scenegraph) {\n      this._updateScenegraph();\n    } else if (props._animations !== oldProps._animations) {\n      this._applyAnimationsProp(this.state.animator, props._animations);\n    }\n  }\n  finalizeState(context) {\n    super.finalizeState(context);\n    this.state.scenegraph?.destroy();\n  }\n  get isLoaded() {\n    return Boolean(this.state?.scenegraph && super.isLoaded);\n  }\n  _updateScenegraph() {\n    const props = this.props;\n    const {\n      device\n    } = this.context;\n    let scenegraphData = null;\n    if (props.scenegraph instanceof ScenegraphNode) {\n      // Signature 1: props.scenegraph is a proper luma.gl Scenegraph\n      scenegraphData = {\n        scenes: [props.scenegraph]\n      };\n    } else if (props.scenegraph && typeof props.scenegraph === 'object') {\n      // Converts loaders.gl gltf to luma.gl scenegraph using the undocumented @luma.gl/experimental function\n      const gltf = props.scenegraph;\n      // Tiles3DLoader already processes GLTF\n      const processedGLTF = gltf.json ? postProcessGLTF(gltf) : gltf;\n      const gltfObjects = createScenegraphsFromGLTF(device, processedGLTF, this._getModelOptions());\n      scenegraphData = {\n        gltf: processedGLTF,\n        ...gltfObjects\n      };\n      waitForGLTFAssets(gltfObjects).then(() => {\n        this.setNeedsRedraw();\n      }).catch(ex => {\n        this.raiseError(ex, 'loading glTF');\n      });\n    }\n    const options = {\n      layer: this,\n      device: this.context.device\n    };\n    const scenegraph = props.getScene(scenegraphData, options);\n    const animator = props.getAnimator(scenegraphData, options);\n    if (scenegraph instanceof GroupNode) {\n      this.state.scenegraph?.destroy();\n      this._applyAnimationsProp(animator, props._animations);\n      const models = [];\n      scenegraph.traverse(node => {\n        if (node instanceof ModelNode) {\n          models.push(node.model);\n        }\n      });\n      this.setState({\n        scenegraph,\n        animator,\n        models\n      });\n      this.getAttributeManager().invalidateAll();\n    } else if (scenegraph !== null) {\n      log.warn('invalid scenegraph:', scenegraph)();\n    }\n  }\n  _applyAnimationsProp(animator, animationsProp) {\n    if (!animator || !animationsProp) {\n      return;\n    }\n    const animations = animator.getAnimations();\n    // sort() to ensure '*' comes first so that other values can override\n    Object.keys(animationsProp).sort().forEach(key => {\n      // Key can be:\n      //  - number for index number\n      //  - name for animation name\n      //  - * to affect all animations\n      const value = animationsProp[key];\n      if (key === '*') {\n        animations.forEach(animation => {\n          Object.assign(animation, value);\n        });\n      } else if (Number.isFinite(Number(key))) {\n        const number = Number(key);\n        if (number >= 0 && number < animations.length) {\n          Object.assign(animations[number], value);\n        } else {\n          log.warn(`animation ${key} not found`)();\n        }\n      } else {\n        const findResult = animations.find(({\n          name\n        }) => name === key);\n        if (findResult) {\n          Object.assign(findResult, value);\n        } else {\n          log.warn(`animation ${key} not found`)();\n        }\n      }\n    });\n  }\n  _getModelOptions() {\n    const {\n      _imageBasedLightingEnvironment\n    } = this.props;\n    let env;\n    if (_imageBasedLightingEnvironment) {\n      if (typeof _imageBasedLightingEnvironment === 'function') {\n        env = _imageBasedLightingEnvironment({\n          gl: this.context.gl,\n          layer: this\n        });\n      } else {\n        env = _imageBasedLightingEnvironment;\n      }\n    }\n    return {\n      imageBasedLightingEnvironment: env,\n      modelOptions: {\n        id: this.props.id,\n        isInstanced: true,\n        bufferLayout: this.getAttributeManager().getBufferLayouts(),\n        ...this.getShaders()\n      },\n      // tangents are not supported\n      useTangents: false\n    };\n  }\n  draw({\n    context\n  }) {\n    if (!this.state.scenegraph) return;\n    if (this.props._animations && this.state.animator) {\n      this.state.animator.animate(context.timeline.getTime());\n      this.setNeedsRedraw();\n    }\n    const {\n      viewport,\n      renderPass\n    } = this.context;\n    const {\n      sizeScale,\n      sizeMinPixels,\n      sizeMaxPixels,\n      coordinateSystem\n    } = this.props;\n    const numInstances = this.getNumInstances();\n    this.state.scenegraph.traverse((node, {\n      worldMatrix\n    }) => {\n      if (node instanceof ModelNode) {\n        const {\n          model\n        } = node;\n        model.setInstanceCount(numInstances);\n        const pbrProjectionProps = {\n          // Needed for PBR (TODO: find better way to get it)\n          camera: model.uniforms.cameraPosition\n        };\n        const scenegraphProps = {\n          sizeScale,\n          sizeMinPixels,\n          sizeMaxPixels,\n          composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),\n          sceneModelMatrix: worldMatrix\n        };\n        model.shaderInputs.setProps({\n          pbrProjection: pbrProjectionProps,\n          scenegraph: scenegraphProps\n        });\n        model.draw(renderPass);\n      }\n    });\n  }\n}\nScenegraphLayer.defaultProps = defaultProps;\nScenegraphLayer.layerName = 'ScenegraphLayer';\nexport default ScenegraphLayer;","map":{"version":3,"names":["Layer","project32","picking","log","pbrMaterial","ScenegraphNode","GroupNode","ModelNode","createScenegraphsFromGLTF","GLTFLoader","postProcessGLTF","waitForGLTFAssets","MATRIX_ATTRIBUTES","shouldComposeModelMatrix","scenegraphUniforms","vs","fs","DEFAULT_COLOR","defaultProps","scenegraph","type","value","async","getScene","gltf","scenes","scene","getAnimator","animator","_animations","sizeScale","min","sizeMinPixels","sizeMaxPixels","Number","MAX_SAFE_INTEGER","getPosition","x","position","getColor","_lighting","_imageBasedLightingEnvironment","undefined","getOrientation","getScale","getTranslation","getTransformMatrix","loaders","ScenegraphLayer","getShaders","defines","pbr","props","LIGHTING_PBR","name","modules","initializeState","attributeManager","getAttributeManager","addInstanced","instancePositions","size","fp64","use64bitPositions","accessor","transition","instanceColors","colorFormat","length","defaultValue","instanceModelMatrix","updateState","params","oldProps","_updateScenegraph","_applyAnimationsProp","state","finalizeState","context","destroy","isLoaded","Boolean","device","scenegraphData","processedGLTF","json","gltfObjects","_getModelOptions","then","setNeedsRedraw","catch","ex","raiseError","options","layer","models","traverse","node","push","model","setState","invalidateAll","warn","animationsProp","animations","getAnimations","Object","keys","sort","forEach","key","animation","assign","isFinite","number","findResult","find","env","gl","imageBasedLightingEnvironment","modelOptions","id","isInstanced","bufferLayout","getBufferLayouts","useTangents","draw","animate","timeline","getTime","viewport","renderPass","coordinateSystem","numInstances","getNumInstances","worldMatrix","setInstanceCount","pbrProjectionProps","camera","uniforms","cameraPosition","scenegraphProps","composeModelMatrix","sceneModelMatrix","shaderInputs","setProps","pbrProjection","layerName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\mesh-layers\\src\\scenegraph-layer\\scenegraph-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Layer, project32, picking, log} from '@deck.gl/core';\nimport type {Device} from '@luma.gl/core';\nimport {pbrMaterial} from '@luma.gl/shadertools';\nimport {ScenegraphNode, GroupNode, ModelNode, Model} from '@luma.gl/engine';\nimport {GLTFAnimator, PBREnvironment, createScenegraphsFromGLTF} from '@luma.gl/gltf';\nimport {GLTFLoader, postProcessGLTF} from '@loaders.gl/gltf';\nimport {waitForGLTFAssets} from './gltf-utils';\n\nimport {MATRIX_ATTRIBUTES, shouldComposeModelMatrix} from '../utils/matrix';\n\nimport {scenegraphUniforms, ScenegraphProps} from './scenegraph-layer-uniforms';\nimport vs from './scenegraph-layer-vertex.glsl';\nimport fs from './scenegraph-layer-fragment.glsl';\n\nimport {\n  UpdateParameters,\n  LayerContext,\n  LayerProps,\n  LayerDataSource,\n  Position,\n  Color,\n  Accessor,\n  DefaultProps\n} from '@deck.gl/core';\n\ntype GLTFInstantiatorOptions = Parameters<typeof createScenegraphsFromGLTF>[2];\n\nconst DEFAULT_COLOR: [number, number, number, number] = [255, 255, 255, 255];\n\nexport type ScenegraphLayerProps<DataT = unknown> = _ScenegraphLayerProps<DataT> & LayerProps;\n\ntype _ScenegraphLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  // TODO - define in luma.gl\n  /**\n   * A url for a glTF model or scenegraph loaded via a [scenegraph loader](https://loaders.gl/docs/specifications/category-scenegraph)\n   */\n  scenegraph: any;\n  /**\n   * Create a luma.gl GroupNode from the resolved scenegraph prop\n   */\n  getScene?: (\n    scenegraph: any,\n    context: {device?: Device; layer: ScenegraphLayer<DataT>}\n  ) => GroupNode;\n  /**\n   * Create a luma.gl GLTFAnimator from the resolved scenegraph prop\n   */\n  getAnimator?: (\n    scenegraph: any,\n    context: {device?: Device; layer: ScenegraphLayer<DataT>}\n  ) => GLTFAnimator;\n  /**\n   * (Experimental) animation configurations. Requires `_animate` on deck object.\n   */\n  _animations?: {\n    [name: number | string | '*']: {\n      /** If the animation is playing */\n      playing?: boolean;\n      /** Start time of the animation, default `0` */\n      startTime?: number;\n      /** Speed multiplier of the animation, default `1` */\n      speed?: number;\n    };\n  } | null;\n  /**\n   * (Experimental) lighting mode\n   * @default 'flat'\n   */\n  _lighting?: 'flat' | 'pbr';\n  /**\n   * (Experimental) lighting environment. Requires `_lighting` to be `'pbr'`.\n   */\n  _imageBasedLightingEnvironment?:\n    | PBREnvironment\n    | ((context: {gl: WebGL2RenderingContext; layer: ScenegraphLayer<DataT>}) => PBREnvironment);\n\n  /** Anchor position accessor. */\n  getPosition?: Accessor<DataT, Position>;\n  /** Color value or accessor.\n   * @default [255, 255, 255, 255]\n   */\n  getColor?: Accessor<DataT, Color>;\n  /**\n   * Orientation in [pitch, yaw, roll] in degrees.\n   * @see https://en.wikipedia.org/wiki/Euler_angles\n   * @default [0, 0, 0]\n   */\n  getOrientation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Scaling factor of the model along each axis.\n   * @default [1, 1, 1]\n   */\n  getScale?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Translation from the anchor point, [x, y, z] in meters.\n   * @default [0, 0, 0]\n   */\n  getTranslation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * TransformMatrix. If specified, `getOrientation`, `getScale` and `getTranslation` are ignored.\n   */\n  getTransformMatrix?: Accessor<DataT, number[]>;\n  /**\n   * Multiplier to scale each geometry by.\n   * @default 1\n   */\n  sizeScale?: number;\n  /**\n   * The minimum size in pixels for one unit of the scene.\n   * @default 0\n   */\n  sizeMinPixels?: number;\n  /**\n   * The maximum size in pixels for one unit of the scene.\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  sizeMaxPixels?: number;\n};\n\nconst defaultProps: DefaultProps<ScenegraphLayerProps> = {\n  scenegraph: {type: 'object', value: null, async: true},\n  getScene: gltf => {\n    if (gltf && gltf.scenes) {\n      // gltf post processor replaces `gltf.scene` number with the scene `object`\n      return typeof gltf.scene === 'object' ? gltf.scene : gltf.scenes[gltf.scene || 0];\n    }\n    return gltf;\n  },\n  getAnimator: scenegraph => scenegraph && scenegraph.animator,\n  _animations: null,\n\n  sizeScale: {type: 'number', value: 1, min: 0},\n  sizeMinPixels: {type: 'number', min: 0, value: 0},\n  sizeMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER},\n\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n\n  // flat or pbr\n  _lighting: 'flat',\n  // _lighting must be pbr for this to work\n  _imageBasedLightingEnvironment: undefined,\n\n  // yaw, pitch and roll are in degrees\n  // https://en.wikipedia.org/wiki/Euler_angles\n  // [pitch, yaw, roll]\n  getOrientation: {type: 'accessor', value: [0, 0, 0]},\n  getScale: {type: 'accessor', value: [1, 1, 1]},\n  getTranslation: {type: 'accessor', value: [0, 0, 0]},\n  // 4x4 matrix\n  getTransformMatrix: {type: 'accessor', value: []},\n\n  loaders: [GLTFLoader]\n};\n\n/** Render a number of instances of a complete glTF scenegraph. */\nexport default class ScenegraphLayer<DataT = any, ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_ScenegraphLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'ScenegraphLayer';\n\n  state!: {\n    scenegraph: GroupNode;\n    animator: GLTFAnimator;\n    models: Model[];\n  };\n\n  getShaders() {\n    const defines: {LIGHTING_PBR?: 1} = {};\n    let pbr;\n\n    if (this.props._lighting === 'pbr') {\n      pbr = pbrMaterial;\n      defines.LIGHTING_PBR = 1;\n    } else {\n      // Dummy shader module needed to handle\n      // pbrMaterial.pbr_baseColorSampler binding\n      pbr = {name: 'pbrMaterial'};\n    }\n\n    const modules = [project32, picking, scenegraphUniforms, pbr];\n    return super.getShaders({defines, vs, fs, modules});\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    // attributeManager is always defined for primitive layers\n    attributeManager!.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 'float64',\n        fp64: this.use64bitPositions(),\n        accessor: 'getPosition',\n        transition: true\n      },\n      instanceColors: {\n        type: 'unorm8',\n        size: this.props.colorFormat.length,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR,\n        transition: true\n      },\n      instanceModelMatrix: MATRIX_ATTRIBUTES\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n    const {props, oldProps} = params;\n\n    if (props.scenegraph !== oldProps.scenegraph) {\n      this._updateScenegraph();\n    } else if (props._animations !== oldProps._animations) {\n      this._applyAnimationsProp(this.state.animator, props._animations);\n    }\n  }\n\n  finalizeState(context: LayerContext) {\n    super.finalizeState(context);\n    this.state.scenegraph?.destroy();\n  }\n\n  get isLoaded(): boolean {\n    return Boolean(this.state?.scenegraph && super.isLoaded);\n  }\n\n  private _updateScenegraph(): void {\n    const props = this.props;\n    const {device} = this.context;\n    let scenegraphData: any = null;\n    if (props.scenegraph instanceof ScenegraphNode) {\n      // Signature 1: props.scenegraph is a proper luma.gl Scenegraph\n      scenegraphData = {scenes: [props.scenegraph]};\n    } else if (props.scenegraph && typeof props.scenegraph === 'object') {\n      // Converts loaders.gl gltf to luma.gl scenegraph using the undocumented @luma.gl/experimental function\n      const gltf = props.scenegraph;\n\n      // Tiles3DLoader already processes GLTF\n      const processedGLTF = gltf.json ? postProcessGLTF(gltf) : gltf;\n\n      const gltfObjects = createScenegraphsFromGLTF(device, processedGLTF, this._getModelOptions());\n      scenegraphData = {gltf: processedGLTF, ...gltfObjects};\n\n      waitForGLTFAssets(gltfObjects)\n        .then(() => {\n          this.setNeedsRedraw();\n        })\n        .catch(ex => {\n          this.raiseError(ex, 'loading glTF');\n        });\n    }\n\n    const options = {layer: this, device: this.context.device};\n    const scenegraph = props.getScene(scenegraphData, options);\n    const animator = props.getAnimator(scenegraphData, options);\n\n    if (scenegraph instanceof GroupNode) {\n      this.state.scenegraph?.destroy();\n\n      this._applyAnimationsProp(animator, props._animations);\n\n      const models: Model[] = [];\n      scenegraph.traverse(node => {\n        if (node instanceof ModelNode) {\n          models.push(node.model);\n        }\n      });\n\n      this.setState({scenegraph, animator, models});\n      this.getAttributeManager()!.invalidateAll();\n    } else if (scenegraph !== null) {\n      log.warn('invalid scenegraph:', scenegraph)();\n    }\n  }\n\n  private _applyAnimationsProp(animator: GLTFAnimator, animationsProp: any): void {\n    if (!animator || !animationsProp) {\n      return;\n    }\n\n    const animations = animator.getAnimations();\n\n    // sort() to ensure '*' comes first so that other values can override\n    Object.keys(animationsProp)\n      .sort()\n      .forEach(key => {\n        // Key can be:\n        //  - number for index number\n        //  - name for animation name\n        //  - * to affect all animations\n        const value = animationsProp[key];\n\n        if (key === '*') {\n          animations.forEach(animation => {\n            Object.assign(animation, value);\n          });\n        } else if (Number.isFinite(Number(key))) {\n          const number = Number(key);\n          if (number >= 0 && number < animations.length) {\n            Object.assign(animations[number], value);\n          } else {\n            log.warn(`animation ${key} not found`)();\n          }\n        } else {\n          const findResult = animations.find(({name}) => name === key);\n          if (findResult) {\n            Object.assign(findResult, value);\n          } else {\n            log.warn(`animation ${key} not found`)();\n          }\n        }\n      });\n  }\n\n  private _getModelOptions(): GLTFInstantiatorOptions {\n    const {_imageBasedLightingEnvironment} = this.props;\n\n    let env: PBREnvironment | undefined;\n    if (_imageBasedLightingEnvironment) {\n      if (typeof _imageBasedLightingEnvironment === 'function') {\n        env = _imageBasedLightingEnvironment({gl: this.context.gl, layer: this});\n      } else {\n        env = _imageBasedLightingEnvironment;\n      }\n    }\n\n    return {\n      imageBasedLightingEnvironment: env,\n      modelOptions: {\n        id: this.props.id,\n        isInstanced: true,\n        bufferLayout: this.getAttributeManager()!.getBufferLayouts(),\n        ...this.getShaders()\n      },\n      // tangents are not supported\n      useTangents: false\n    };\n  }\n\n  draw({context}) {\n    if (!this.state.scenegraph) return;\n\n    if (this.props._animations && this.state.animator) {\n      this.state.animator.animate(context.timeline.getTime());\n      this.setNeedsRedraw();\n    }\n\n    const {viewport, renderPass} = this.context;\n    const {sizeScale, sizeMinPixels, sizeMaxPixels, coordinateSystem} = this.props;\n\n    const numInstances = this.getNumInstances();\n    this.state.scenegraph.traverse((node, {worldMatrix}) => {\n      if (node instanceof ModelNode) {\n        const {model} = node;\n        model.setInstanceCount(numInstances);\n\n        const pbrProjectionProps = {\n          // Needed for PBR (TODO: find better way to get it)\n          camera: model.uniforms.cameraPosition as [number, number, number]\n        };\n        const scenegraphProps: ScenegraphProps = {\n          sizeScale,\n          sizeMinPixels,\n          sizeMaxPixels,\n          composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),\n          sceneModelMatrix: worldMatrix\n        };\n\n        model.shaderInputs.setProps({\n          pbrProjection: pbrProjectionProps,\n          scenegraph: scenegraphProps\n        });\n        model.draw(renderPass);\n      }\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}