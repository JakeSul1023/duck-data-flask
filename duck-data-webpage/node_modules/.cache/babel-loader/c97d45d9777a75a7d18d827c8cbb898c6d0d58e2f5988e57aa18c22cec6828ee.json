{"ast":null,"code":"import { RecognizerState } from \"./recognizer-state.js\";\nimport { uniqueId } from \"../utils/unique-id.js\";\nimport { stateStr } from \"./state-str.js\";\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n */\nexport class Recognizer {\n  constructor(options) {\n    this.options = options;\n    this.id = uniqueId();\n    this.state = RecognizerState.Possible;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  /**\n   * set options\n   */\n  set(options) {\n    Object.assign(this.options, options);\n    // also update the touchAction, in case something changed about the directions/enabled state\n    this.manager.touchAction.update();\n    return this;\n  }\n  /**\n   * recognize simultaneous with an other recognizer.\n   */\n  recognizeWith(recognizerOrName) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.recognizeWith(item);\n      }\n      return this;\n    }\n    let otherRecognizer;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n      if (!otherRecognizer) {\n        throw new Error(`Cannot find recognizer ${recognizerOrName}`);\n      }\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    const {\n      simultaneous\n    } = this;\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n    return this;\n  }\n  /**\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   */\n  dropRecognizeWith(recognizerOrName) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.dropRecognizeWith(item);\n      }\n      return this;\n    }\n    let otherRecognizer;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    if (otherRecognizer) {\n      delete this.simultaneous[otherRecognizer.id];\n    }\n    return this;\n  }\n  /**\n   * recognizer can only run when an other is failing\n   */\n  requireFailure(recognizerOrName) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.requireFailure(item);\n      }\n      return this;\n    }\n    let otherRecognizer;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n      if (!otherRecognizer) {\n        throw new Error(`Cannot find recognizer ${recognizerOrName}`);\n      }\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    const {\n      requireFail\n    } = this;\n    if (requireFail.indexOf(otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n    return this;\n  }\n  /**\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   */\n  dropRequireFailure(recognizerOrName) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.dropRequireFailure(item);\n      }\n      return this;\n    }\n    let otherRecognizer;\n    if (typeof recognizerOrName === 'string') {\n      otherRecognizer = this.manager.get(recognizerOrName);\n    } else {\n      otherRecognizer = recognizerOrName;\n    }\n    if (otherRecognizer) {\n      const index = this.requireFail.indexOf(otherRecognizer);\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n    }\n    return this;\n  }\n  /**\n   * has require failures boolean\n   */\n  hasRequireFailures() {\n    return Boolean(this.requireFail.find(recognier => recognier.options.enable));\n  }\n  /**\n   * if the recognizer can recognize simultaneous with an other recognizer\n   */\n  canRecognizeWith(otherRecognizer) {\n    return Boolean(this.simultaneous[otherRecognizer.id]);\n  }\n  /**\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   */\n  emit(input) {\n    // Some recognizers override emit() with their own logic\n    if (!input) return;\n    const {\n      state\n    } = this;\n    // 'panstart' and 'panmove'\n    if (state < RecognizerState.Ended) {\n      this.manager.emit(this.options.event + stateStr(state), input);\n    }\n    // simple 'eventName' events\n    this.manager.emit(this.options.event, input);\n    // additional event(panleft, panright, pinchin, pinchout...)\n    if (input.additionalEvent) {\n      this.manager.emit(input.additionalEvent, input);\n    }\n    // panend and pancancel\n    if (state >= RecognizerState.Ended) {\n      this.manager.emit(this.options.event + stateStr(state), input);\n    }\n  }\n  /**\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   */\n  tryEmit(input) {\n    if (this.canEmit()) {\n      this.emit(input);\n    } else {\n      // it's failing anyway\n      this.state = RecognizerState.Failed;\n    }\n  }\n  /**\n   * can we emit?\n   */\n  canEmit() {\n    let i = 0;\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (RecognizerState.Failed | RecognizerState.Possible))) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  }\n  /**\n   * update the recognizer\n   */\n  recognize(inputData) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    const inputDataClone = {\n      ...inputData\n    };\n    // is is enabled and allow recognizing?\n    if (!this.options.enable) {\n      this.reset();\n      this.state = RecognizerState.Failed;\n      return;\n    }\n    // reset when we've reached the end\n    if (this.state & (RecognizerState.Recognized | RecognizerState.Cancelled | RecognizerState.Failed)) {\n      this.state = RecognizerState.Possible;\n    }\n    this.state = this.process(inputDataClone);\n    // the recognizer has recognized a gesture\n    // so trigger an event\n    if (this.state & (RecognizerState.Began | RecognizerState.Changed | RecognizerState.Ended | RecognizerState.Cancelled)) {\n      this.tryEmit(inputDataClone);\n    }\n  }\n  /**\n   * return the event names that are emitted by this recognizer\n   */\n  getEventNames() {\n    return [this.options.event];\n  }\n  /**\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   */\n  reset() {}\n}\n//# sourceMappingURL=recognizer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}