{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Buffer, Texture, TextureView, Sampler, RenderPipeline, UniformStore, log, getTypedArrayFromDataType, getAttributeInfosFromLayouts, _BufferLayoutHelper } from '@luma.gl/core';\nimport { ShaderAssembler, getShaderLayoutFromWGSL } from '@luma.gl/shadertools';\nimport { makeGPUGeometry } from \"../geometry/gpu-geometry.js\";\nimport { PipelineFactory } from \"../factories/pipeline-factory.js\";\nimport { ShaderFactory } from \"../factories/shader-factory.js\";\nimport { getDebugTableForShaderLayout } from \"../debug/debug-shader-layout.js\";\nimport { debugFramebuffer } from \"../debug/debug-framebuffer.js\";\nimport { deepEqual } from \"../utils/deep-equal.js\";\nimport { uid } from \"../utils/uid.js\";\nimport { ShaderInputs } from \"../shader-inputs.js\";\n// import type {AsyncTextureProps} from '../async-texture/async-texture';\nimport { AsyncTexture } from \"../async-texture/async-texture.js\";\nimport { splitUniformsAndBindings } from \"./split-uniforms-and-bindings.js\";\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n/**\n * v9 Model API\n * A model\n * - automatically reuses pipelines (programs) when possible\n * - automatically rebuilds pipelines if necessary to accommodate changed settings\n * shadertools integration\n * - accepts modules and performs shader transpilation\n */\nexport class Model {\n  static defaultProps = {\n    ...RenderPipeline.defaultProps,\n    source: undefined,\n    vs: null,\n    fs: null,\n    id: 'unnamed',\n    handle: undefined,\n    userData: {},\n    defines: {},\n    modules: [],\n    moduleSettings: undefined,\n    geometry: null,\n    indexBuffer: null,\n    attributes: {},\n    constantAttributes: {},\n    varyings: [],\n    isInstanced: undefined,\n    instanceCount: 0,\n    vertexCount: 0,\n    shaderInputs: undefined,\n    pipelineFactory: undefined,\n    shaderFactory: undefined,\n    transformFeedback: undefined,\n    shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),\n    debugShaders: undefined,\n    disableWarnings: undefined\n  };\n  device;\n  id;\n  // @ts-expect-error assigned in function called from constructor\n  source;\n  // @ts-expect-error assigned in function called from constructor\n  vs;\n  // @ts-expect-error assigned in function called from constructor\n  fs;\n  pipelineFactory;\n  shaderFactory;\n  userData = {};\n  // Fixed properties (change can trigger pipeline rebuild)\n  /** The render pipeline GPU parameters, depth testing etc */\n  parameters;\n  /** The primitive topology */\n  topology;\n  /** Buffer layout */\n  bufferLayout;\n  // Dynamic properties\n  /** Use instanced rendering */\n  isInstanced = undefined;\n  /** instance count. `undefined` means not instanced */\n  instanceCount = 0;\n  /** Vertex count */\n  vertexCount;\n  /** Index buffer */\n  indexBuffer = null;\n  /** Buffer-valued attributes */\n  bufferAttributes = {};\n  /** Constant-valued attributes */\n  constantAttributes = {};\n  /** Bindings (textures, samplers, uniform buffers) */\n  bindings = {};\n  /** Sets uniforms @deprecated Use uniform buffers and setBindings() for portability*/\n  uniforms = {};\n  /**\n   * VertexArray\n   * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!\n   * @todo - allow application to define multiple vertex arrays?\n   * */\n  vertexArray;\n  /** TransformFeedback, WebGL 2 only. */\n  transformFeedback = null;\n  /** The underlying GPU \"program\". @note May be recreated if parameters change */\n  pipeline;\n  /** ShaderInputs instance */\n  // @ts-expect-error Assigned in function called by constructor\n  shaderInputs;\n  // @ts-expect-error Assigned in function called by constructor\n  _uniformStore;\n  _attributeInfos = {};\n  _gpuGeometry = null;\n  _getModuleUniforms;\n  props;\n  _pipelineNeedsUpdate = 'newly created';\n  _needsRedraw = 'initializing';\n  _destroyed = false;\n  /** \"Time\" of last draw. Monotonically increasing timestamp */\n  _lastDrawTimestamp = -1;\n  get [Symbol.toStringTag]() {\n    return 'Model';\n  }\n  toString() {\n    return `Model(${this.id})`;\n  }\n  constructor(device, props) {\n    this.props = {\n      ...Model.defaultProps,\n      ...props\n    };\n    props = this.props;\n    this.id = props.id || uid('model');\n    this.device = device;\n    Object.assign(this.userData, props.userData);\n    // Setup shader module inputs\n    const moduleMap = Object.fromEntries(this.props.modules?.map(module => [module.name, module]) || []);\n    const shaderInputs = props.shaderInputs || new ShaderInputs(moduleMap, {\n      disableWarnings: this.props.disableWarnings\n    });\n    // @ts-ignore\n    this.setShaderInputs(shaderInputs);\n    // Setup shader assembler\n    const platformInfo = getPlatformInfo(device);\n    // Extract modules from shader inputs if not supplied\n    const modules =\n    // @ts-ignore shaderInputs is assigned in setShaderInputs above.\n    (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];\n    const isWebGPU = this.device.type === 'webgpu';\n    // WebGPU\n    // TODO - hack to support unified WGSL shader\n    // TODO - this is wrong, compile a single shader\n    if (isWebGPU && this.props.source) {\n      // WGSL\n      const {\n        source,\n        getUniforms\n      } = this.props.shaderAssembler.assembleWGSLShader({\n        platformInfo,\n        ...this.props,\n        modules\n      });\n      this.source = source;\n      // @ts-expect-error\n      this._getModuleUniforms = getUniforms;\n      // Extract shader layout after modules have been added to WGSL source, to include any bindings added by modules\n      this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.source);\n    } else {\n      // GLSL\n      const {\n        vs,\n        fs,\n        getUniforms\n      } = this.props.shaderAssembler.assembleGLSLShaderPair({\n        platformInfo,\n        ...this.props,\n        modules\n      });\n      this.vs = vs;\n      this.fs = fs;\n      // @ts-expect-error\n      this._getModuleUniforms = getUniforms;\n    }\n    this.vertexCount = this.props.vertexCount;\n    this.instanceCount = this.props.instanceCount;\n    this.topology = this.props.topology;\n    this.bufferLayout = this.props.bufferLayout;\n    this.parameters = this.props.parameters;\n    // Geometry, if provided, sets topology and vertex cound\n    if (props.geometry) {\n      this.setGeometry(props.geometry);\n    }\n    this.pipelineFactory = props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);\n    this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);\n    // Create the pipeline\n    // @note order is important\n    this.pipeline = this._updatePipeline();\n    this.vertexArray = device.createVertexArray({\n      renderPipeline: this.pipeline\n    });\n    // Now we can apply geometry attributes\n    if (this._gpuGeometry) {\n      this._setGeometryAttributes(this._gpuGeometry);\n    }\n    // Apply any dynamic settings that will not trigger pipeline change\n    if ('isInstanced' in props) {\n      this.isInstanced = props.isInstanced;\n    }\n    if (props.instanceCount) {\n      this.setInstanceCount(props.instanceCount);\n    }\n    if (props.vertexCount) {\n      this.setVertexCount(props.vertexCount);\n    }\n    if (props.indexBuffer) {\n      this.setIndexBuffer(props.indexBuffer);\n    }\n    if (props.attributes) {\n      this.setAttributes(props.attributes);\n    }\n    if (props.constantAttributes) {\n      this.setConstantAttributes(props.constantAttributes);\n    }\n    if (props.bindings) {\n      this.setBindings(props.bindings);\n    }\n    if (props.uniforms) {\n      this.setUniformsWebGL(props.uniforms);\n    }\n    if (props.moduleSettings) {\n      // log.warn('Model.props.moduleSettings is deprecated. Use Model.shaderInputs.setProps()')();\n      this.updateModuleSettingsWebGL(props.moduleSettings);\n    }\n    if (props.transformFeedback) {\n      this.transformFeedback = props.transformFeedback;\n    }\n    // Catch any access to non-standard props\n    Object.seal(this);\n  }\n  destroy() {\n    if (this._destroyed) return;\n    this.pipelineFactory.release(this.pipeline);\n    this.shaderFactory.release(this.pipeline.vs);\n    if (this.pipeline.fs) {\n      this.shaderFactory.release(this.pipeline.fs);\n    }\n    this._uniformStore.destroy();\n    // TODO - mark resource as managed and destroyIfManaged() ?\n    this._gpuGeometry?.destroy();\n    this._destroyed = true;\n  }\n  // Draw call\n  /** Query redraw status. Clears the status. */\n  needsRedraw() {\n    // Catch any writes to already bound resources\n    if (this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp) {\n      this.setNeedsRedraw('contents of bound textures or buffers updated');\n    }\n    const needsRedraw = this._needsRedraw;\n    this._needsRedraw = false;\n    return needsRedraw;\n  }\n  /** Mark the model as needing a redraw */\n  setNeedsRedraw(reason) {\n    this._needsRedraw ||= reason;\n  }\n  predraw() {\n    // Update uniform buffers if needed\n    this.updateShaderInputs();\n    // Check if the pipeline is invalidated\n    this.pipeline = this._updatePipeline();\n  }\n  draw(renderPass) {\n    const loadingBinding = this._areBindingsLoading();\n    if (loadingBinding) {\n      log.info(LOG_DRAW_PRIORITY, `>>> DRAWING ABORTED ${this.id}: ${loadingBinding} not loaded`)();\n      return false;\n    }\n    try {\n      renderPass.pushDebugGroup(`${this}.predraw(${renderPass})`);\n      this.predraw();\n    } finally {\n      renderPass.popDebugGroup();\n    }\n    let drawSuccess;\n    try {\n      renderPass.pushDebugGroup(`${this}.draw(${renderPass})`);\n      this._logDrawCallStart();\n      // Update the pipeline if invalidated\n      // TODO - inside RenderPass is likely the worst place to do this from performance perspective.\n      // Application can call Model.predraw() to avoid this.\n      this.pipeline = this._updatePipeline();\n      // Set pipeline state, we may be sharing a pipeline so we need to set all state on every draw\n      // Any caching needs to be done inside the pipeline functions\n      // TODO this is a busy initialized check for all bindings every frame\n      const syncBindings = this._getBindings();\n      this.pipeline.setBindings(syncBindings, {\n        disableWarnings: this.props.disableWarnings\n      });\n      if (!isObjectEmpty(this.uniforms)) {\n        this.pipeline.setUniformsWebGL(this.uniforms);\n      }\n      const {\n        indexBuffer\n      } = this.vertexArray;\n      const indexCount = indexBuffer ? indexBuffer.byteLength / (indexBuffer.indexType === 'uint32' ? 4 : 2) : undefined;\n      drawSuccess = this.pipeline.draw({\n        renderPass,\n        vertexArray: this.vertexArray,\n        isInstanced: this.isInstanced,\n        vertexCount: this.vertexCount,\n        instanceCount: this.instanceCount,\n        indexCount,\n        transformFeedback: this.transformFeedback || undefined,\n        // WebGL shares underlying cached pipelines even for models that have different parameters and topology,\n        // so we must provide our unique parameters to each draw\n        // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)\n        parameters: this.parameters,\n        topology: this.topology\n      });\n    } finally {\n      renderPass.popDebugGroup();\n      this._logDrawCallEnd();\n    }\n    this._logFramebuffer(renderPass);\n    // Update needsRedraw flag\n    if (drawSuccess) {\n      this._lastDrawTimestamp = this.device.timestamp;\n      this._needsRedraw = false;\n    } else {\n      this._needsRedraw = 'waiting for resource initialization';\n    }\n    return drawSuccess;\n  }\n  // Update fixed fields (can trigger pipeline rebuild)\n  /**\n   * Updates the optional geometry\n   * Geometry, set topology and bufferLayout\n   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU\n   */\n  setGeometry(geometry) {\n    this._gpuGeometry?.destroy();\n    const gpuGeometry = geometry && makeGPUGeometry(this.device, geometry);\n    if (gpuGeometry) {\n      this.setTopology(gpuGeometry.topology || 'triangle-list');\n      const bufferLayoutHelper = new _BufferLayoutHelper(this.bufferLayout);\n      this.bufferLayout = bufferLayoutHelper.mergeBufferLayouts(gpuGeometry.bufferLayout, this.bufferLayout);\n      if (this.vertexArray) {\n        this._setGeometryAttributes(gpuGeometry);\n      }\n    }\n    this._gpuGeometry = gpuGeometry;\n  }\n  /**\n   * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).\n   * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU\n   */\n  setTopology(topology) {\n    if (topology !== this.topology) {\n      this.topology = topology;\n      this._setPipelineNeedsUpdate('topology');\n    }\n  }\n  /**\n   * Updates the buffer layout.\n   * @note Triggers a pipeline rebuild / pipeline cache fetch\n   */\n  setBufferLayout(bufferLayout) {\n    const bufferLayoutHelper = new _BufferLayoutHelper(this.bufferLayout);\n    this.bufferLayout = this._gpuGeometry ? bufferLayoutHelper.mergeBufferLayouts(bufferLayout, this._gpuGeometry.bufferLayout) : bufferLayout;\n    this._setPipelineNeedsUpdate('bufferLayout');\n    // Recreate the pipeline\n    this.pipeline = this._updatePipeline();\n    // vertex array needs to be updated if we update buffer layout,\n    // but not if we update parameters\n    this.vertexArray = this.device.createVertexArray({\n      renderPipeline: this.pipeline\n    });\n    // Reapply geometry attributes to the new vertex array\n    if (this._gpuGeometry) {\n      this._setGeometryAttributes(this._gpuGeometry);\n    }\n  }\n  /**\n   * Set GPU parameters.\n   * @note Can trigger a pipeline rebuild / pipeline cache fetch.\n   * @param parameters\n   */\n  setParameters(parameters) {\n    if (!deepEqual(parameters, this.parameters, 2)) {\n      this.parameters = parameters;\n      this._setPipelineNeedsUpdate('parameters');\n    }\n  }\n  // Update dynamic fields\n  /**\n   * Updates the instance count (used in draw calls)\n   * @note Any attributes with stepMode=instance need to be at least this big\n   */\n  setInstanceCount(instanceCount) {\n    this.instanceCount = instanceCount;\n    // luma.gl examples don't set props.isInstanced and rely on auto-detection\n    // but deck.gl sets instanceCount even for models that are not instanced.\n    if (this.isInstanced === undefined && instanceCount > 0) {\n      this.isInstanced = true;\n    }\n    this.setNeedsRedraw('instanceCount');\n  }\n  /**\n   * Updates the vertex count (used in draw calls)\n   * @note Any attributes with stepMode=vertex need to be at least this big\n   */\n  setVertexCount(vertexCount) {\n    this.vertexCount = vertexCount;\n    this.setNeedsRedraw('vertexCount');\n  }\n  /** Set the shader inputs */\n  setShaderInputs(shaderInputs) {\n    this.shaderInputs = shaderInputs;\n    this._uniformStore = new UniformStore(this.shaderInputs.modules);\n    // Create uniform buffer bindings for all modules that actually have uniforms\n    for (const [moduleName, module] of Object.entries(this.shaderInputs.modules)) {\n      if (shaderModuleHasUniforms(module)) {\n        const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);\n        this.bindings[`${moduleName}Uniforms`] = uniformBuffer;\n      }\n    }\n    this.setNeedsRedraw('shaderInputs');\n  }\n  /** Update uniform buffers from the model's shader inputs */\n  updateShaderInputs() {\n    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());\n    this.setBindings(this.shaderInputs.getBindingValues());\n    // TODO - this is already tracked through buffer/texture update times?\n    this.setNeedsRedraw('shaderInputs');\n  }\n  /**\n   * Sets bindings (textures, samplers, uniform buffers)\n   */\n  setBindings(bindings) {\n    Object.assign(this.bindings, bindings);\n    this.setNeedsRedraw('bindings');\n  }\n  /**\n   * Updates optional transform feedback. WebGL only.\n   */\n  setTransformFeedback(transformFeedback) {\n    this.transformFeedback = transformFeedback;\n    this.setNeedsRedraw('transformFeedback');\n  }\n  /**\n   * Sets the index buffer\n   * @todo - how to unset it if we change geometry?\n   */\n  setIndexBuffer(indexBuffer) {\n    this.vertexArray.setIndexBuffer(indexBuffer);\n    this.setNeedsRedraw('indexBuffer');\n  }\n  /**\n   * Sets attributes (buffers)\n   * @note Overrides any attributes previously set with the same name\n   */\n  setAttributes(buffers, options) {\n    const disableWarnings = options?.disableWarnings ?? this.props.disableWarnings;\n    if (buffers.indices) {\n      log.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();\n    }\n    const bufferLayoutHelper = new _BufferLayoutHelper(this.bufferLayout);\n    // Check if all buffers have a layout\n    for (const [bufferName, buffer] of Object.entries(buffers)) {\n      const bufferLayout = bufferLayoutHelper.getBufferLayout(bufferName);\n      if (!bufferLayout) {\n        if (!disableWarnings) {\n          log.warn(`Model(${this.id}): Missing layout for buffer \"${bufferName}\".`)();\n        }\n        continue; // eslint-disable-line no-continue\n      }\n      // For an interleaved attribute we may need to set multiple attributes\n      const attributeNames = bufferLayoutHelper.getAttributeNamesForBuffer(bufferLayout);\n      let set = false;\n      for (const attributeName of attributeNames) {\n        const attributeInfo = this._attributeInfos[attributeName];\n        if (attributeInfo) {\n          this.vertexArray.setBuffer(attributeInfo.location, buffer);\n          set = true;\n        }\n      }\n      if (!set && !disableWarnings) {\n        log.warn(`Model(${this.id}): Ignoring buffer \"${buffer.id}\" for unknown attribute \"${bufferName}\"`)();\n      }\n    }\n    this.setNeedsRedraw('attributes');\n  }\n  /**\n   * Sets constant attributes\n   * @note Overrides any attributes previously set with the same name\n   * Constant attributes are only supported in WebGL, not in WebGPU\n   * Any attribute that is disabled in the current vertex array object\n   * is read from the context's global constant value for that attribute location.\n   * @param constantAttributes\n   */\n  setConstantAttributes(attributes, options) {\n    for (const [attributeName, value] of Object.entries(attributes)) {\n      const attributeInfo = this._attributeInfos[attributeName];\n      if (attributeInfo) {\n        this.vertexArray.setConstantWebGL(attributeInfo.location, value);\n      } else if (!(options?.disableWarnings ?? this.props.disableWarnings)) {\n        log.warn(`Model \"${this.id}: Ignoring constant supplied for unknown attribute \"${attributeName}\"`)();\n      }\n    }\n    this.setNeedsRedraw('constants');\n  }\n  // DEPRECATED METHODS\n  /**\n   * Sets individual uniforms\n   * @deprecated WebGL only, use uniform buffers for portability\n   * @param uniforms\n   */\n  setUniforms(uniforms) {\n    this.setUniformsWebGL(uniforms);\n  }\n  /**\n   * Sets individual uniforms\n   * @deprecated WebGL only, use uniform buffers for portability\n   * @param uniforms\n   */\n  setUniformsWebGL(uniforms) {\n    if (!isObjectEmpty(uniforms)) {\n      this.pipeline.setUniformsWebGL(uniforms);\n      Object.assign(this.uniforms, uniforms);\n    }\n    this.setNeedsRedraw('uniforms');\n  }\n  /**\n   * @deprecated Updates shader module settings (which results in uniforms being set)\n   */\n  updateModuleSettingsWebGL(props) {\n    // log.warn('Model.updateModuleSettings is deprecated. Use Model.shaderInputs.setProps()')();\n    const {\n      bindings,\n      uniforms\n    } = splitUniformsAndBindings(this._getModuleUniforms(props));\n    Object.assign(this.bindings, bindings);\n    Object.assign(this.uniforms, uniforms);\n    this.setNeedsRedraw('moduleSettings');\n  }\n  // Internal methods\n  /** Check that bindings are loaded. Returns id of first binding that is still loading. */\n  _areBindingsLoading() {\n    for (const binding of Object.values(this.bindings)) {\n      if (binding instanceof AsyncTexture && !binding.isReady) {\n        return binding.id;\n      }\n    }\n    return false;\n  }\n  /** Extracts texture view from loaded async textures. Returns null if any textures have not yet been loaded. */\n  _getBindings() {\n    const validBindings = {};\n    for (const [name, binding] of Object.entries(this.bindings)) {\n      if (binding instanceof AsyncTexture) {\n        // Check that async textures are loaded\n        if (binding.isReady) {\n          validBindings[name] = binding.texture;\n        }\n      } else {\n        validBindings[name] = binding;\n      }\n    }\n    return validBindings;\n  }\n  /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */\n  _getBindingsUpdateTimestamp() {\n    let timestamp = 0;\n    for (const binding of Object.values(this.bindings)) {\n      if (binding instanceof TextureView) {\n        timestamp = Math.max(timestamp, binding.texture.updateTimestamp);\n      } else if (binding instanceof Buffer || binding instanceof Texture) {\n        timestamp = Math.max(timestamp, binding.updateTimestamp);\n      } else if (binding instanceof AsyncTexture) {\n        timestamp = binding.texture ? Math.max(timestamp, binding.texture.updateTimestamp) :\n        // The texture will become available in the future\n        Infinity;\n      } else if (!(binding instanceof Sampler)) {\n        timestamp = Math.max(timestamp, binding.buffer.updateTimestamp);\n      }\n    }\n    return timestamp;\n  }\n  /**\n   * Updates the optional geometry attributes\n   * Geometry, sets several attributes, indexBuffer, and also vertex count\n   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU\n   */\n  _setGeometryAttributes(gpuGeometry) {\n    // Filter geometry attribute so that we don't issue warnings for unused attributes\n    const attributes = {\n      ...gpuGeometry.attributes\n    };\n    for (const [attributeName] of Object.entries(attributes)) {\n      if (!this.pipeline.shaderLayout.attributes.find(layout => layout.name === attributeName) && attributeName !== 'positions') {\n        delete attributes[attributeName];\n      }\n    }\n    // TODO - delete previous geometry?\n    this.vertexCount = gpuGeometry.vertexCount;\n    this.setIndexBuffer(gpuGeometry.indices || null);\n    this.setAttributes(gpuGeometry.attributes, {\n      disableWarnings: true\n    });\n    this.setAttributes(attributes, {\n      disableWarnings: this.props.disableWarnings\n    });\n    this.setNeedsRedraw('geometry attributes');\n  }\n  /** Mark pipeline as needing update */\n  _setPipelineNeedsUpdate(reason) {\n    this._pipelineNeedsUpdate ||= reason;\n    this.setNeedsRedraw(reason);\n  }\n  /** Update pipeline if needed */\n  _updatePipeline() {\n    if (this._pipelineNeedsUpdate) {\n      let prevShaderVs = null;\n      let prevShaderFs = null;\n      if (this.pipeline) {\n        log.log(1, `Model ${this.id}: Recreating pipeline because \"${this._pipelineNeedsUpdate}\".`)();\n        prevShaderVs = this.pipeline.vs;\n        prevShaderFs = this.pipeline.fs;\n      }\n      this._pipelineNeedsUpdate = false;\n      const vs = this.shaderFactory.createShader({\n        id: `${this.id}-vertex`,\n        stage: 'vertex',\n        source: this.source || this.vs,\n        debugShaders: this.props.debugShaders\n      });\n      let fs = null;\n      if (this.source) {\n        fs = vs;\n      } else if (this.fs) {\n        fs = this.shaderFactory.createShader({\n          id: `${this.id}-fragment`,\n          stage: 'fragment',\n          source: this.source || this.fs,\n          debugShaders: this.props.debugShaders\n        });\n      }\n      this.pipeline = this.pipelineFactory.createRenderPipeline({\n        ...this.props,\n        bufferLayout: this.bufferLayout,\n        topology: this.topology,\n        parameters: this.parameters,\n        // TODO - why set bindings here when we reset them every frame?\n        // Should we expose a BindGroup abstraction?\n        bindings: this._getBindings(),\n        vs,\n        fs\n      });\n      this._attributeInfos = getAttributeInfosFromLayouts(this.pipeline.shaderLayout, this.bufferLayout);\n      if (prevShaderVs) this.shaderFactory.release(prevShaderVs);\n      if (prevShaderFs) this.shaderFactory.release(prevShaderFs);\n    }\n    return this.pipeline;\n  }\n  /** Throttle draw call logging */\n  _lastLogTime = 0;\n  _logOpen = false;\n  _logDrawCallStart() {\n    // IF level is 4 or higher, log every frame.\n    const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {\n      return;\n    }\n    this._lastLogTime = Date.now();\n    this._logOpen = true;\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {\n      collapsed: log.level <= 2\n    })();\n  }\n  _logDrawCallEnd() {\n    if (this._logOpen) {\n      const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.shaderLayout, this.id);\n      // log.table(logLevel, attributeTable)();\n      // log.table(logLevel, uniformTable)();\n      log.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();\n      const uniformTable = this.shaderInputs.getDebugTable();\n      // Add any global uniforms\n      for (const [name, value] of Object.entries(this.uniforms)) {\n        uniformTable[name] = {\n          value\n        };\n      }\n      log.table(LOG_DRAW_PRIORITY, uniformTable)();\n      const attributeTable = this._getAttributeDebugTable();\n      log.table(LOG_DRAW_PRIORITY, this._attributeInfos)();\n      log.table(LOG_DRAW_PRIORITY, attributeTable)();\n      log.groupEnd(LOG_DRAW_PRIORITY)();\n      this._logOpen = false;\n    }\n  }\n  _drawCount = 0;\n  _logFramebuffer(renderPass) {\n    const debugFramebuffers = this.device.props.debugFramebuffers;\n    this._drawCount++;\n    // Update first 3 frames and then every 60 frames\n    if (!debugFramebuffers) {\n      // } || (this._drawCount++ > 3 && this._drawCount % 60)) {\n      return;\n    }\n    // TODO - display framebuffer output in debug window\n    const framebuffer = renderPass.props.framebuffer;\n    if (framebuffer) {\n      debugFramebuffer(framebuffer, {\n        id: framebuffer.id,\n        minimap: true\n      });\n      // log.image({logLevel: LOG_DRAW_PRIORITY, message: `${framebuffer.id} %c sup?`, image})();\n    }\n  }\n  _getAttributeDebugTable() {\n    const table = {};\n    for (const [name, attributeInfo] of Object.entries(this._attributeInfos)) {\n      const values = this.vertexArray.attributes[attributeInfo.location];\n      table[attributeInfo.location] = {\n        name,\n        type: attributeInfo.shaderType,\n        values: values ? this._getBufferOrConstantValues(values, attributeInfo.bufferDataType) : 'null'\n      };\n    }\n    if (this.vertexArray.indexBuffer) {\n      const {\n        indexBuffer\n      } = this.vertexArray;\n      const values = indexBuffer.indexType === 'uint32' ? new Uint32Array(indexBuffer.debugData) : new Uint16Array(indexBuffer.debugData);\n      table.indices = {\n        name: 'indices',\n        type: indexBuffer.indexType,\n        values: values.toString()\n      };\n    }\n    return table;\n  }\n  // TODO - fix typing of luma data types\n  _getBufferOrConstantValues(attribute, dataType) {\n    const TypedArrayConstructor = getTypedArrayFromDataType(dataType);\n    const typedArray = attribute instanceof Buffer ? new TypedArrayConstructor(attribute.debugData) : attribute;\n    return typedArray.toString();\n  }\n}\nfunction shaderModuleHasUniforms(module) {\n  return Boolean(module.uniformTypes && !isObjectEmpty(module.uniformTypes));\n}\n// HELPERS\n/** Create a shadertools platform info from the Device */\nexport function getPlatformInfo(device) {\n  return {\n    type: device.type,\n    shaderLanguage: device.info.shadingLanguage,\n    shaderLanguageVersion: device.info.shadingLanguageVersion,\n    gpu: device.info.gpu,\n    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API\n    features: device.features\n  };\n}\n/** Returns true if given object is empty, false otherwise. */\nfunction isObjectEmpty(obj) {\n  // @ts-ignore key is unused\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for (const key in obj) {\n    return false;\n  }\n  return true;\n}","map":{"version":3,"names":["Buffer","Texture","TextureView","Sampler","RenderPipeline","UniformStore","log","getTypedArrayFromDataType","getAttributeInfosFromLayouts","_BufferLayoutHelper","ShaderAssembler","getShaderLayoutFromWGSL","makeGPUGeometry","PipelineFactory","ShaderFactory","getDebugTableForShaderLayout","debugFramebuffer","deepEqual","uid","ShaderInputs","AsyncTexture","splitUniformsAndBindings","LOG_DRAW_PRIORITY","LOG_DRAW_TIMEOUT","Model","defaultProps","source","undefined","vs","fs","id","handle","userData","defines","modules","moduleSettings","geometry","indexBuffer","attributes","constantAttributes","varyings","isInstanced","instanceCount","vertexCount","shaderInputs","pipelineFactory","shaderFactory","transformFeedback","shaderAssembler","getDefaultShaderAssembler","debugShaders","disableWarnings","device","parameters","topology","bufferLayout","bufferAttributes","bindings","uniforms","vertexArray","pipeline","_uniformStore","_attributeInfos","_gpuGeometry","_getModuleUniforms","props","_pipelineNeedsUpdate","_needsRedraw","_destroyed","_lastDrawTimestamp","Symbol","toStringTag","toString","constructor","Object","assign","moduleMap","fromEntries","map","module","name","setShaderInputs","platformInfo","getPlatformInfo","length","getModules","isWebGPU","type","getUniforms","assembleWGSLShader","shaderLayout","assembleGLSLShaderPair","setGeometry","getDefaultPipelineFactory","getDefaultShaderFactory","_updatePipeline","createVertexArray","renderPipeline","_setGeometryAttributes","setInstanceCount","setVertexCount","setIndexBuffer","setAttributes","setConstantAttributes","setBindings","setUniformsWebGL","updateModuleSettingsWebGL","seal","destroy","release","needsRedraw","_getBindingsUpdateTimestamp","setNeedsRedraw","reason","predraw","updateShaderInputs","draw","renderPass","loadingBinding","_areBindingsLoading","info","pushDebugGroup","popDebugGroup","drawSuccess","_logDrawCallStart","syncBindings","_getBindings","isObjectEmpty","indexCount","byteLength","indexType","_logDrawCallEnd","_logFramebuffer","timestamp","gpuGeometry","setTopology","bufferLayoutHelper","mergeBufferLayouts","_setPipelineNeedsUpdate","setBufferLayout","setParameters","moduleName","entries","shaderModuleHasUniforms","uniformBuffer","getManagedUniformBuffer","setUniforms","getUniformValues","getBindingValues","setTransformFeedback","buffers","options","indices","warn","bufferName","buffer","getBufferLayout","attributeNames","getAttributeNamesForBuffer","set","attributeName","attributeInfo","setBuffer","location","value","setConstantWebGL","binding","values","isReady","validBindings","texture","Math","max","updateTimestamp","Infinity","find","layout","prevShaderVs","prevShaderFs","createShader","stage","createRenderPipeline","_lastLogTime","_logOpen","logDrawTimeout","level","Date","now","group","collapsed","shaderLayoutTable","table","uniformTable","getDebugTable","attributeTable","_getAttributeDebugTable","groupEnd","_drawCount","debugFramebuffers","framebuffer","minimap","shaderType","_getBufferOrConstantValues","bufferDataType","Uint32Array","debugData","Uint16Array","attribute","dataType","TypedArrayConstructor","typedArray","Boolean","uniformTypes","shaderLanguage","shadingLanguage","shaderLanguageVersion","shadingLanguageVersion","gpu","features","obj","key"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\engine\\src\\model\\model.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// A lot of imports, but then Model is where it all comes together...\nimport type {TypedArray} from '@math.gl/types';\nimport type {\n  RenderPipelineProps,\n  RenderPipelineParameters,\n  BufferLayout,\n  Shader,\n  VertexArray,\n  TransformFeedback,\n  AttributeInfo,\n  Binding,\n  UniformValue,\n  PrimitiveTopology\n} from '@luma.gl/core';\nimport {\n  Device,\n  DeviceFeature,\n  Buffer,\n  Texture,\n  TextureView,\n  Sampler,\n  RenderPipeline,\n  RenderPass,\n  UniformStore,\n  log,\n  getTypedArrayFromDataType,\n  getAttributeInfosFromLayouts,\n  _BufferLayoutHelper\n} from '@luma.gl/core';\n\nimport type {ShaderModule, PlatformInfo} from '@luma.gl/shadertools';\nimport {ShaderAssembler, getShaderLayoutFromWGSL} from '@luma.gl/shadertools';\n\nimport type {Geometry} from '../geometry/geometry';\nimport {GPUGeometry, makeGPUGeometry} from '../geometry/gpu-geometry';\nimport {PipelineFactory} from '../factories/pipeline-factory';\nimport {ShaderFactory} from '../factories/shader-factory';\nimport {getDebugTableForShaderLayout} from '../debug/debug-shader-layout';\nimport {debugFramebuffer} from '../debug/debug-framebuffer';\nimport {deepEqual} from '../utils/deep-equal';\nimport {uid} from '../utils/uid';\nimport {ShaderInputs} from '../shader-inputs';\n// import type {AsyncTextureProps} from '../async-texture/async-texture';\nimport {AsyncTexture} from '../async-texture/async-texture';\n\nimport {splitUniformsAndBindings} from './split-uniforms-and-bindings';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\nexport type ModelProps = Omit<RenderPipelineProps, 'vs' | 'fs' | 'bindings'> & {\n  source?: string;\n  vs: string | null;\n  fs: string | null;\n\n  /** shadertool shader modules (added to shader code) */\n  modules?: ShaderModule[];\n  /** Shadertool module defines (configures shader code)*/\n  defines?: Record<string, string | number | boolean>;\n  // TODO - injections, hooks etc?\n\n  /** Shader inputs, used to generated uniform buffers and bindings */\n  shaderInputs?: ShaderInputs;\n  /** Bindings */\n  bindings?: Record<string, Binding | AsyncTexture>;\n  /** Parameters that are built into the pipeline */\n  parameters?: RenderPipelineParameters;\n\n  /** Geometry */\n  geometry?: GPUGeometry | Geometry | null;\n\n  /** @deprecated Use instanced rendering? Will be auto-detected in 9.1 */\n  isInstanced?: boolean;\n  /** instance count */\n  instanceCount?: number;\n  /** Vertex count */\n  vertexCount?: number;\n\n  indexBuffer?: Buffer | null;\n  /** @note this is really a map of buffers, not a map of attributes */\n  attributes?: Record<string, Buffer>;\n  /**   */\n  constantAttributes?: Record<string, TypedArray>;\n\n  /** Some applications intentionally supply unused attributes and bindings, and want to disable warnings */\n  disableWarnings?: boolean;\n\n  /** @internal For use with {@link TransformFeedback}, WebGL only. */\n  varyings?: string[];\n\n  transformFeedback?: TransformFeedback;\n\n  /** Mapped uniforms for shadertool modules */\n  moduleSettings?: Record<string, Record<string, any>>;\n\n  /** Show shader source in browser? */\n  debugShaders?: 'never' | 'errors' | 'warnings' | 'always';\n\n  /** Factory used to create a {@link RenderPipeline}. Defaults to {@link Device} default factory. */\n  pipelineFactory?: PipelineFactory;\n  /** Factory used to create a {@link Shader}. Defaults to {@link Device} default factory. */\n  shaderFactory?: ShaderFactory;\n  /** Shader assembler. Defaults to the ShaderAssembler.getShaderAssembler() */\n  shaderAssembler?: ShaderAssembler;\n};\n\n/**\n * v9 Model API\n * A model\n * - automatically reuses pipelines (programs) when possible\n * - automatically rebuilds pipelines if necessary to accommodate changed settings\n * shadertools integration\n * - accepts modules and performs shader transpilation\n */\nexport class Model {\n  static defaultProps: Required<ModelProps> = {\n    ...RenderPipeline.defaultProps,\n    source: undefined!,\n    vs: null,\n    fs: null,\n    id: 'unnamed',\n    handle: undefined,\n    userData: {},\n    defines: {},\n    modules: [],\n    moduleSettings: undefined!,\n    geometry: null,\n    indexBuffer: null,\n    attributes: {},\n    constantAttributes: {},\n    varyings: [],\n\n    isInstanced: undefined!,\n    instanceCount: 0,\n    vertexCount: 0,\n\n    shaderInputs: undefined!,\n    pipelineFactory: undefined!,\n    shaderFactory: undefined!,\n    transformFeedback: undefined!,\n    shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),\n\n    debugShaders: undefined!,\n    disableWarnings: undefined!\n  };\n\n  readonly device: Device;\n  readonly id: string;\n  // @ts-expect-error assigned in function called from constructor\n  readonly source: string;\n  // @ts-expect-error assigned in function called from constructor\n  readonly vs: string;\n  // @ts-expect-error assigned in function called from constructor\n  readonly fs: string;\n  readonly pipelineFactory: PipelineFactory;\n  readonly shaderFactory: ShaderFactory;\n  userData: {[key: string]: any} = {};\n\n  // Fixed properties (change can trigger pipeline rebuild)\n\n  /** The render pipeline GPU parameters, depth testing etc */\n  parameters: RenderPipelineParameters;\n\n  /** The primitive topology */\n  topology: PrimitiveTopology;\n  /** Buffer layout */\n  bufferLayout: BufferLayout[];\n\n  // Dynamic properties\n\n  /** Use instanced rendering */\n  isInstanced: boolean | undefined = undefined;\n  /** instance count. `undefined` means not instanced */\n  instanceCount: number = 0;\n  /** Vertex count */\n  vertexCount: number;\n\n  /** Index buffer */\n  indexBuffer: Buffer | null = null;\n  /** Buffer-valued attributes */\n  bufferAttributes: Record<string, Buffer> = {};\n  /** Constant-valued attributes */\n  constantAttributes: Record<string, TypedArray> = {};\n  /** Bindings (textures, samplers, uniform buffers) */\n  bindings: Record<string, Binding | AsyncTexture> = {};\n  /** Sets uniforms @deprecated Use uniform buffers and setBindings() for portability*/\n  uniforms: Record<string, UniformValue> = {};\n\n  /**\n   * VertexArray\n   * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!\n   * @todo - allow application to define multiple vertex arrays?\n   * */\n  vertexArray: VertexArray;\n\n  /** TransformFeedback, WebGL 2 only. */\n  transformFeedback: TransformFeedback | null = null;\n\n  /** The underlying GPU \"program\". @note May be recreated if parameters change */\n  pipeline: RenderPipeline;\n\n  /** ShaderInputs instance */\n  // @ts-expect-error Assigned in function called by constructor\n  shaderInputs: ShaderInputs;\n  // @ts-expect-error Assigned in function called by constructor\n  _uniformStore: UniformStore;\n\n  _attributeInfos: Record<string, AttributeInfo> = {};\n  _gpuGeometry: GPUGeometry | null = null;\n  private _getModuleUniforms: (props?: Record<string, Record<string, any>>) => Record<string, any>;\n  private props: Required<ModelProps>;\n\n  _pipelineNeedsUpdate: string | false = 'newly created';\n  private _needsRedraw: string | false = 'initializing';\n  private _destroyed = false;\n\n  /** \"Time\" of last draw. Monotonically increasing timestamp */\n  _lastDrawTimestamp: number = -1;\n\n  get [Symbol.toStringTag](): string {\n    return 'Model';\n  }\n\n  toString(): string {\n    return `Model(${this.id})`;\n  }\n\n  constructor(device: Device, props: ModelProps) {\n    this.props = {...Model.defaultProps, ...props};\n    props = this.props;\n    this.id = props.id || uid('model');\n    this.device = device;\n\n    Object.assign(this.userData, props.userData);\n\n    // Setup shader module inputs\n    const moduleMap = Object.fromEntries(\n      this.props.modules?.map(module => [module.name, module]) || []\n    );\n\n    const shaderInputs =\n      props.shaderInputs ||\n      new ShaderInputs(moduleMap, {disableWarnings: this.props.disableWarnings});\n    // @ts-ignore\n    this.setShaderInputs(shaderInputs);\n\n    // Setup shader assembler\n    const platformInfo = getPlatformInfo(device);\n\n    // Extract modules from shader inputs if not supplied\n    const modules =\n      // @ts-ignore shaderInputs is assigned in setShaderInputs above.\n      (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];\n\n    const isWebGPU = this.device.type === 'webgpu';\n\n    // WebGPU\n    // TODO - hack to support unified WGSL shader\n    // TODO - this is wrong, compile a single shader\n    if (isWebGPU && this.props.source) {\n      // WGSL\n      const {source, getUniforms} = this.props.shaderAssembler.assembleWGSLShader({\n        platformInfo,\n        ...this.props,\n        modules\n      });\n      this.source = source;\n      // @ts-expect-error\n      this._getModuleUniforms = getUniforms;\n      // Extract shader layout after modules have been added to WGSL source, to include any bindings added by modules\n      this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.source);\n    } else {\n      // GLSL\n      const {vs, fs, getUniforms} = this.props.shaderAssembler.assembleGLSLShaderPair({\n        platformInfo,\n        ...this.props,\n        modules\n      });\n\n      this.vs = vs;\n      this.fs = fs;\n      // @ts-expect-error\n      this._getModuleUniforms = getUniforms;\n    }\n\n    this.vertexCount = this.props.vertexCount;\n    this.instanceCount = this.props.instanceCount;\n\n    this.topology = this.props.topology;\n    this.bufferLayout = this.props.bufferLayout;\n    this.parameters = this.props.parameters;\n\n    // Geometry, if provided, sets topology and vertex cound\n    if (props.geometry) {\n      this.setGeometry(props.geometry);\n    }\n\n    this.pipelineFactory =\n      props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);\n    this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);\n\n    // Create the pipeline\n    // @note order is important\n    this.pipeline = this._updatePipeline();\n\n    this.vertexArray = device.createVertexArray({\n      renderPipeline: this.pipeline\n    });\n\n    // Now we can apply geometry attributes\n    if (this._gpuGeometry) {\n      this._setGeometryAttributes(this._gpuGeometry);\n    }\n\n    // Apply any dynamic settings that will not trigger pipeline change\n    if ('isInstanced' in props) {\n      this.isInstanced = props.isInstanced;\n    }\n\n    if (props.instanceCount) {\n      this.setInstanceCount(props.instanceCount);\n    }\n    if (props.vertexCount) {\n      this.setVertexCount(props.vertexCount);\n    }\n    if (props.indexBuffer) {\n      this.setIndexBuffer(props.indexBuffer);\n    }\n    if (props.attributes) {\n      this.setAttributes(props.attributes);\n    }\n    if (props.constantAttributes) {\n      this.setConstantAttributes(props.constantAttributes);\n    }\n    if (props.bindings) {\n      this.setBindings(props.bindings);\n    }\n    if (props.uniforms) {\n      this.setUniformsWebGL(props.uniforms);\n    }\n    if (props.moduleSettings) {\n      // log.warn('Model.props.moduleSettings is deprecated. Use Model.shaderInputs.setProps()')();\n      this.updateModuleSettingsWebGL(props.moduleSettings);\n    }\n    if (props.transformFeedback) {\n      this.transformFeedback = props.transformFeedback;\n    }\n\n    // Catch any access to non-standard props\n    Object.seal(this);\n  }\n\n  destroy(): void {\n    if (this._destroyed) return;\n    this.pipelineFactory.release(this.pipeline);\n    this.shaderFactory.release(this.pipeline.vs);\n    if (this.pipeline.fs) {\n      this.shaderFactory.release(this.pipeline.fs);\n    }\n    this._uniformStore.destroy();\n    // TODO - mark resource as managed and destroyIfManaged() ?\n    this._gpuGeometry?.destroy();\n    this._destroyed = true;\n  }\n\n  // Draw call\n\n  /** Query redraw status. Clears the status. */\n  needsRedraw(): false | string {\n    // Catch any writes to already bound resources\n    if (this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp) {\n      this.setNeedsRedraw('contents of bound textures or buffers updated');\n    }\n    const needsRedraw = this._needsRedraw;\n    this._needsRedraw = false;\n    return needsRedraw;\n  }\n\n  /** Mark the model as needing a redraw */\n  setNeedsRedraw(reason: string): void {\n    this._needsRedraw ||= reason;\n  }\n\n  predraw(): void {\n    // Update uniform buffers if needed\n    this.updateShaderInputs();\n    // Check if the pipeline is invalidated\n    this.pipeline = this._updatePipeline();\n  }\n\n  draw(renderPass: RenderPass): boolean {\n    const loadingBinding = this._areBindingsLoading();\n    if (loadingBinding) {\n      log.info(LOG_DRAW_PRIORITY, `>>> DRAWING ABORTED ${this.id}: ${loadingBinding} not loaded`)();\n      return false;\n    }\n\n    try {\n      renderPass.pushDebugGroup(`${this}.predraw(${renderPass})`);\n      this.predraw();\n    } finally {\n      renderPass.popDebugGroup();\n    }\n\n    let drawSuccess: boolean;\n    try {\n      renderPass.pushDebugGroup(`${this}.draw(${renderPass})`);\n      this._logDrawCallStart();\n\n      // Update the pipeline if invalidated\n      // TODO - inside RenderPass is likely the worst place to do this from performance perspective.\n      // Application can call Model.predraw() to avoid this.\n      this.pipeline = this._updatePipeline();\n\n      // Set pipeline state, we may be sharing a pipeline so we need to set all state on every draw\n      // Any caching needs to be done inside the pipeline functions\n      // TODO this is a busy initialized check for all bindings every frame\n\n      const syncBindings = this._getBindings();\n      this.pipeline.setBindings(syncBindings, {\n        disableWarnings: this.props.disableWarnings\n      });\n      if (!isObjectEmpty(this.uniforms)) {\n        this.pipeline.setUniformsWebGL(this.uniforms);\n      }\n\n      const {indexBuffer} = this.vertexArray;\n      const indexCount = indexBuffer\n        ? indexBuffer.byteLength / (indexBuffer.indexType === 'uint32' ? 4 : 2)\n        : undefined;\n\n      drawSuccess = this.pipeline.draw({\n        renderPass,\n        vertexArray: this.vertexArray,\n        isInstanced: this.isInstanced,\n        vertexCount: this.vertexCount,\n        instanceCount: this.instanceCount,\n        indexCount,\n        transformFeedback: this.transformFeedback || undefined,\n        // WebGL shares underlying cached pipelines even for models that have different parameters and topology,\n        // so we must provide our unique parameters to each draw\n        // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)\n        parameters: this.parameters,\n        topology: this.topology\n      });\n    } finally {\n      renderPass.popDebugGroup();\n      this._logDrawCallEnd();\n    }\n    this._logFramebuffer(renderPass);\n\n    // Update needsRedraw flag\n    if (drawSuccess) {\n      this._lastDrawTimestamp = this.device.timestamp;\n      this._needsRedraw = false;\n    } else {\n      this._needsRedraw = 'waiting for resource initialization';\n    }\n    return drawSuccess;\n  }\n\n  // Update fixed fields (can trigger pipeline rebuild)\n\n  /**\n   * Updates the optional geometry\n   * Geometry, set topology and bufferLayout\n   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU\n   */\n  setGeometry(geometry: GPUGeometry | Geometry | null): void {\n    this._gpuGeometry?.destroy();\n    const gpuGeometry = geometry && makeGPUGeometry(this.device, geometry);\n    if (gpuGeometry) {\n      this.setTopology(gpuGeometry.topology || 'triangle-list');\n      const bufferLayoutHelper = new _BufferLayoutHelper(this.bufferLayout);\n      this.bufferLayout = bufferLayoutHelper.mergeBufferLayouts(\n        gpuGeometry.bufferLayout,\n        this.bufferLayout\n      );\n      if (this.vertexArray) {\n        this._setGeometryAttributes(gpuGeometry);\n      }\n    }\n    this._gpuGeometry = gpuGeometry;\n  }\n\n  /**\n   * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).\n   * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU\n   */\n  setTopology(topology: PrimitiveTopology): void {\n    if (topology !== this.topology) {\n      this.topology = topology;\n      this._setPipelineNeedsUpdate('topology');\n    }\n  }\n\n  /**\n   * Updates the buffer layout.\n   * @note Triggers a pipeline rebuild / pipeline cache fetch\n   */\n  setBufferLayout(bufferLayout: BufferLayout[]): void {\n    const bufferLayoutHelper = new _BufferLayoutHelper(this.bufferLayout);\n    this.bufferLayout = this._gpuGeometry\n      ? bufferLayoutHelper.mergeBufferLayouts(bufferLayout, this._gpuGeometry.bufferLayout)\n      : bufferLayout;\n    this._setPipelineNeedsUpdate('bufferLayout');\n\n    // Recreate the pipeline\n    this.pipeline = this._updatePipeline();\n\n    // vertex array needs to be updated if we update buffer layout,\n    // but not if we update parameters\n    this.vertexArray = this.device.createVertexArray({\n      renderPipeline: this.pipeline\n    });\n\n    // Reapply geometry attributes to the new vertex array\n    if (this._gpuGeometry) {\n      this._setGeometryAttributes(this._gpuGeometry);\n    }\n  }\n\n  /**\n   * Set GPU parameters.\n   * @note Can trigger a pipeline rebuild / pipeline cache fetch.\n   * @param parameters\n   */\n  setParameters(parameters: RenderPipelineParameters) {\n    if (!deepEqual(parameters, this.parameters, 2)) {\n      this.parameters = parameters;\n      this._setPipelineNeedsUpdate('parameters');\n    }\n  }\n\n  // Update dynamic fields\n\n  /**\n   * Updates the instance count (used in draw calls)\n   * @note Any attributes with stepMode=instance need to be at least this big\n   */\n  setInstanceCount(instanceCount: number): void {\n    this.instanceCount = instanceCount;\n    // luma.gl examples don't set props.isInstanced and rely on auto-detection\n    // but deck.gl sets instanceCount even for models that are not instanced.\n    if (this.isInstanced === undefined && instanceCount > 0) {\n      this.isInstanced = true;\n    }\n    this.setNeedsRedraw('instanceCount');\n  }\n\n  /**\n   * Updates the vertex count (used in draw calls)\n   * @note Any attributes with stepMode=vertex need to be at least this big\n   */\n  setVertexCount(vertexCount: number): void {\n    this.vertexCount = vertexCount;\n    this.setNeedsRedraw('vertexCount');\n  }\n\n  /** Set the shader inputs */\n  setShaderInputs(shaderInputs: ShaderInputs): void {\n    this.shaderInputs = shaderInputs;\n    this._uniformStore = new UniformStore(this.shaderInputs.modules);\n    // Create uniform buffer bindings for all modules that actually have uniforms\n    for (const [moduleName, module] of Object.entries(this.shaderInputs.modules)) {\n      if (shaderModuleHasUniforms(module)) {\n        const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);\n        this.bindings[`${moduleName}Uniforms`] = uniformBuffer;\n      }\n    }\n    this.setNeedsRedraw('shaderInputs');\n  }\n\n  /** Update uniform buffers from the model's shader inputs */\n  updateShaderInputs(): void {\n    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());\n    this.setBindings(this.shaderInputs.getBindingValues());\n    // TODO - this is already tracked through buffer/texture update times?\n    this.setNeedsRedraw('shaderInputs');\n  }\n\n  /**\n   * Sets bindings (textures, samplers, uniform buffers)\n   */\n  setBindings(bindings: Record<string, Binding | AsyncTexture>): void {\n    Object.assign(this.bindings, bindings);\n    this.setNeedsRedraw('bindings');\n  }\n\n  /**\n   * Updates optional transform feedback. WebGL only.\n   */\n  setTransformFeedback(transformFeedback: TransformFeedback | null): void {\n    this.transformFeedback = transformFeedback;\n    this.setNeedsRedraw('transformFeedback');\n  }\n\n  /**\n   * Sets the index buffer\n   * @todo - how to unset it if we change geometry?\n   */\n  setIndexBuffer(indexBuffer: Buffer | null): void {\n    this.vertexArray.setIndexBuffer(indexBuffer);\n    this.setNeedsRedraw('indexBuffer');\n  }\n\n  /**\n   * Sets attributes (buffers)\n   * @note Overrides any attributes previously set with the same name\n   */\n  setAttributes(buffers: Record<string, Buffer>, options?: {disableWarnings?: boolean}): void {\n    const disableWarnings = options?.disableWarnings ?? this.props.disableWarnings;\n    if (buffers.indices) {\n      log.warn(\n        `Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`\n      )();\n    }\n\n    const bufferLayoutHelper = new _BufferLayoutHelper(this.bufferLayout);\n\n    // Check if all buffers have a layout\n    for (const [bufferName, buffer] of Object.entries(buffers)) {\n      const bufferLayout = bufferLayoutHelper.getBufferLayout(bufferName);\n      if (!bufferLayout) {\n        if (!disableWarnings) {\n          log.warn(`Model(${this.id}): Missing layout for buffer \"${bufferName}\".`)();\n        }\n        continue; // eslint-disable-line no-continue\n      }\n\n      // For an interleaved attribute we may need to set multiple attributes\n      const attributeNames = bufferLayoutHelper.getAttributeNamesForBuffer(bufferLayout);\n      let set = false;\n      for (const attributeName of attributeNames) {\n        const attributeInfo = this._attributeInfos[attributeName];\n        if (attributeInfo) {\n          this.vertexArray.setBuffer(attributeInfo.location, buffer);\n          set = true;\n        }\n      }\n      if (!set && !disableWarnings) {\n        log.warn(\n          `Model(${this.id}): Ignoring buffer \"${buffer.id}\" for unknown attribute \"${bufferName}\"`\n        )();\n      }\n    }\n    this.setNeedsRedraw('attributes');\n  }\n\n  /**\n   * Sets constant attributes\n   * @note Overrides any attributes previously set with the same name\n   * Constant attributes are only supported in WebGL, not in WebGPU\n   * Any attribute that is disabled in the current vertex array object\n   * is read from the context's global constant value for that attribute location.\n   * @param constantAttributes\n   */\n  setConstantAttributes(\n    attributes: Record<string, TypedArray>,\n    options?: {disableWarnings?: boolean}\n  ): void {\n    for (const [attributeName, value] of Object.entries(attributes)) {\n      const attributeInfo = this._attributeInfos[attributeName];\n      if (attributeInfo) {\n        this.vertexArray.setConstantWebGL(attributeInfo.location, value);\n      } else if (!(options?.disableWarnings ?? this.props.disableWarnings)) {\n        log.warn(\n          `Model \"${this.id}: Ignoring constant supplied for unknown attribute \"${attributeName}\"`\n        )();\n      }\n    }\n    this.setNeedsRedraw('constants');\n  }\n\n  // DEPRECATED METHODS\n\n  /**\n   * Sets individual uniforms\n   * @deprecated WebGL only, use uniform buffers for portability\n   * @param uniforms\n   */\n  setUniforms(uniforms: Record<string, UniformValue>): void {\n    this.setUniformsWebGL(uniforms);\n  }\n\n  /**\n   * Sets individual uniforms\n   * @deprecated WebGL only, use uniform buffers for portability\n   * @param uniforms\n   */\n  setUniformsWebGL(uniforms: Record<string, UniformValue>): void {\n    if (!isObjectEmpty(uniforms)) {\n      this.pipeline.setUniformsWebGL(uniforms);\n      Object.assign(this.uniforms, uniforms);\n    }\n    this.setNeedsRedraw('uniforms');\n  }\n\n  /**\n   * @deprecated Updates shader module settings (which results in uniforms being set)\n   */\n  updateModuleSettingsWebGL(props: Record<string, any>): void {\n    // log.warn('Model.updateModuleSettings is deprecated. Use Model.shaderInputs.setProps()')();\n    const {bindings, uniforms} = splitUniformsAndBindings(this._getModuleUniforms(props));\n    Object.assign(this.bindings, bindings);\n    Object.assign(this.uniforms, uniforms);\n    this.setNeedsRedraw('moduleSettings');\n  }\n\n  // Internal methods\n\n  /** Check that bindings are loaded. Returns id of first binding that is still loading. */\n  _areBindingsLoading(): string | false {\n    for (const binding of Object.values(this.bindings)) {\n      if (binding instanceof AsyncTexture && !binding.isReady) {\n        return binding.id;\n      }\n    }\n    return false;\n  }\n\n  /** Extracts texture view from loaded async textures. Returns null if any textures have not yet been loaded. */\n  _getBindings(): Record<string, Binding> {\n    const validBindings: Record<string, Binding> = {};\n\n    for (const [name, binding] of Object.entries(this.bindings)) {\n      if (binding instanceof AsyncTexture) {\n        // Check that async textures are loaded\n        if (binding.isReady) {\n          validBindings[name] = binding.texture;\n        }\n      } else {\n        validBindings[name] = binding;\n      }\n    }\n\n    return validBindings;\n  }\n\n  /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */\n  _getBindingsUpdateTimestamp(): number {\n    let timestamp = 0;\n    for (const binding of Object.values(this.bindings)) {\n      if (binding instanceof TextureView) {\n        timestamp = Math.max(timestamp, binding.texture.updateTimestamp);\n      } else if (binding instanceof Buffer || binding instanceof Texture) {\n        timestamp = Math.max(timestamp, binding.updateTimestamp);\n      } else if (binding instanceof AsyncTexture) {\n        timestamp = binding.texture\n          ? Math.max(timestamp, binding.texture.updateTimestamp)\n          : // The texture will become available in the future\n            Infinity;\n      } else if (!(binding instanceof Sampler)) {\n        timestamp = Math.max(timestamp, binding.buffer.updateTimestamp);\n      }\n    }\n    return timestamp;\n  }\n\n  /**\n   * Updates the optional geometry attributes\n   * Geometry, sets several attributes, indexBuffer, and also vertex count\n   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU\n   */\n  _setGeometryAttributes(gpuGeometry: GPUGeometry): void {\n    // Filter geometry attribute so that we don't issue warnings for unused attributes\n    const attributes = {...gpuGeometry.attributes};\n    for (const [attributeName] of Object.entries(attributes)) {\n      if (\n        !this.pipeline.shaderLayout.attributes.find(layout => layout.name === attributeName) &&\n        attributeName !== 'positions'\n      ) {\n        delete attributes[attributeName];\n      }\n    }\n\n    // TODO - delete previous geometry?\n    this.vertexCount = gpuGeometry.vertexCount;\n    this.setIndexBuffer(gpuGeometry.indices || null);\n    this.setAttributes(gpuGeometry.attributes, {disableWarnings: true});\n    this.setAttributes(attributes, {disableWarnings: this.props.disableWarnings});\n\n    this.setNeedsRedraw('geometry attributes');\n  }\n\n  /** Mark pipeline as needing update */\n  _setPipelineNeedsUpdate(reason: string): void {\n    this._pipelineNeedsUpdate ||= reason;\n    this.setNeedsRedraw(reason);\n  }\n\n  /** Update pipeline if needed */\n  _updatePipeline(): RenderPipeline {\n    if (this._pipelineNeedsUpdate) {\n      let prevShaderVs: Shader | null = null;\n      let prevShaderFs: Shader | null = null;\n      if (this.pipeline) {\n        log.log(\n          1,\n          `Model ${this.id}: Recreating pipeline because \"${this._pipelineNeedsUpdate}\".`\n        )();\n        prevShaderVs = this.pipeline.vs;\n        prevShaderFs = this.pipeline.fs;\n      }\n\n      this._pipelineNeedsUpdate = false;\n\n      const vs = this.shaderFactory.createShader({\n        id: `${this.id}-vertex`,\n        stage: 'vertex',\n        source: this.source || this.vs,\n        debugShaders: this.props.debugShaders\n      });\n\n      let fs: Shader | null = null;\n      if (this.source) {\n        fs = vs;\n      } else if (this.fs) {\n        fs = this.shaderFactory.createShader({\n          id: `${this.id}-fragment`,\n          stage: 'fragment',\n          source: this.source || this.fs,\n          debugShaders: this.props.debugShaders\n        });\n      }\n\n      this.pipeline = this.pipelineFactory.createRenderPipeline({\n        ...this.props,\n        bufferLayout: this.bufferLayout,\n        topology: this.topology,\n        parameters: this.parameters,\n        // TODO - why set bindings here when we reset them every frame?\n        // Should we expose a BindGroup abstraction?\n        bindings: this._getBindings(),\n        vs,\n        fs\n      });\n\n      this._attributeInfos = getAttributeInfosFromLayouts(\n        this.pipeline.shaderLayout,\n        this.bufferLayout\n      );\n\n      if (prevShaderVs) this.shaderFactory.release(prevShaderVs);\n      if (prevShaderFs) this.shaderFactory.release(prevShaderFs);\n    }\n    return this.pipeline;\n  }\n\n  /** Throttle draw call logging */\n  _lastLogTime = 0;\n  _logOpen = false;\n\n  _logDrawCallStart(): void {\n    // IF level is 4 or higher, log every frame.\n    const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {\n      return;\n    }\n\n    this._lastLogTime = Date.now();\n    this._logOpen = true;\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.level <= 2})();\n  }\n\n  _logDrawCallEnd(): void {\n    if (this._logOpen) {\n      const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.shaderLayout, this.id);\n\n      // log.table(logLevel, attributeTable)();\n      // log.table(logLevel, uniformTable)();\n      log.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();\n\n      const uniformTable = this.shaderInputs.getDebugTable();\n      // Add any global uniforms\n      for (const [name, value] of Object.entries(this.uniforms)) {\n        uniformTable[name] = {value};\n      }\n      log.table(LOG_DRAW_PRIORITY, uniformTable)();\n\n      const attributeTable = this._getAttributeDebugTable();\n      log.table(LOG_DRAW_PRIORITY, this._attributeInfos)();\n      log.table(LOG_DRAW_PRIORITY, attributeTable)();\n\n      log.groupEnd(LOG_DRAW_PRIORITY)();\n      this._logOpen = false;\n    }\n  }\n\n  protected _drawCount = 0;\n  _logFramebuffer(renderPass: RenderPass): void {\n    const debugFramebuffers = this.device.props.debugFramebuffers;\n    this._drawCount++;\n    // Update first 3 frames and then every 60 frames\n    if (!debugFramebuffers) {\n      // } || (this._drawCount++ > 3 && this._drawCount % 60)) {\n      return;\n    }\n    // TODO - display framebuffer output in debug window\n    const framebuffer = renderPass.props.framebuffer;\n    if (framebuffer) {\n      debugFramebuffer(framebuffer, {id: framebuffer.id, minimap: true});\n      // log.image({logLevel: LOG_DRAW_PRIORITY, message: `${framebuffer.id} %c sup?`, image})();\n    }\n  }\n\n  _getAttributeDebugTable(): Record<string, Record<string, unknown>> {\n    const table: Record<string, Record<string, unknown>> = {};\n    for (const [name, attributeInfo] of Object.entries(this._attributeInfos)) {\n      const values = this.vertexArray.attributes[attributeInfo.location];\n      table[attributeInfo.location] = {\n        name,\n        type: attributeInfo.shaderType,\n        values: values\n          ? this._getBufferOrConstantValues(values, attributeInfo.bufferDataType)\n          : 'null'\n      };\n    }\n    if (this.vertexArray.indexBuffer) {\n      const {indexBuffer} = this.vertexArray;\n      const values =\n        indexBuffer.indexType === 'uint32'\n          ? new Uint32Array(indexBuffer.debugData)\n          : new Uint16Array(indexBuffer.debugData);\n      table.indices = {\n        name: 'indices',\n        type: indexBuffer.indexType,\n        values: values.toString()\n      };\n    }\n    return table;\n  }\n\n  // TODO - fix typing of luma data types\n  _getBufferOrConstantValues(attribute: Buffer | TypedArray, dataType: any): string {\n    const TypedArrayConstructor = getTypedArrayFromDataType(dataType);\n    const typedArray =\n      attribute instanceof Buffer ? new TypedArrayConstructor(attribute.debugData) : attribute;\n    return typedArray.toString();\n  }\n}\n\nfunction shaderModuleHasUniforms(module: ShaderModule): boolean {\n  return Boolean(module.uniformTypes && !isObjectEmpty(module.uniformTypes));\n}\n\n// HELPERS\n\n/** Create a shadertools platform info from the Device */\nexport function getPlatformInfo(device: Device): PlatformInfo {\n  return {\n    type: device.type,\n    shaderLanguage: device.info.shadingLanguage,\n    shaderLanguageVersion: device.info.shadingLanguageVersion as 100 | 300,\n    gpu: device.info.gpu,\n    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API\n    features: device.features as unknown as Set<DeviceFeature>\n  };\n}\n\n/** Returns true if given object is empty, false otherwise. */\nfunction isObjectEmpty(obj: object): boolean {\n  // @ts-ignore key is unused\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for (const key in obj) {\n    return false;\n  }\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}