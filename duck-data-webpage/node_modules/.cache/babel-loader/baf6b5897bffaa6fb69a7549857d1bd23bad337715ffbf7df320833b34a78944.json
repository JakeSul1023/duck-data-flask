{"ast":null,"code":"import { GLTFScenegraph } from \"../api/gltf-scenegraph.js\";\nimport { convertRawBufferToMetadataArray, getPrimitiveTextureData, primitivePropertyDataToAttributes, getArrayElementByteSize, getOffsetsForProperty, parseVariableLengthArrayNumeric, parseFixedLengthArrayNumeric, getPropertyDataString } from \"./utils/3d-tiles-utils.js\";\nconst EXT_STRUCTURAL_METADATA_NAME = 'EXT_structural_metadata';\nexport const name = EXT_STRUCTURAL_METADATA_NAME;\nexport async function decode(gltfData, options) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  decodeExtStructuralMetadata(scenegraph, options);\n}\nexport function encode(gltfData, options) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  encodeExtStructuralMetadata(scenegraph, options);\n  scenegraph.createBinaryChunk();\n  return scenegraph.gltf;\n}\n/*\n// Example of the extension.\n// See more info at https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata\nconst extensions = {\n  \"extensions\": {\n    \"EXT_structural_metadata\": {\n      \"schema\": {\n        \"classes\": {\n          \"tree\": {\n            \"name\": \"Tree\",\n            \"description\": \"Woody, perennial plant.\",\n            \"properties\": {\n              \"species\": {\n                \"description\": \"Type of tree.\",\n                \"type\": \"ENUM\",\n                \"enumType\": \"speciesEnum\",\n                \"required\": true\n              },\n              \"age\": {\n                \"description\": \"The age of the tree, in years\",\n                \"type\": \"SCALAR\",\n                \"componentType\": \"UINT8\",\n                \"required\": true\n              }\n            }\n          }\n        },\n        \"enums\": {\n          \"speciesEnum\": {\n            \"name\": \"Species\",\n            \"description\": \"An example enum for tree species.\",\n            // valueType is not defined here. Default is \"UINT16\"\n            \"values\": [\n              { \"name\": \"Unspecified\", \"value\": 0 },\n              { \"name\": \"Oak\", \"value\": 1 }\n            ]\n          }\n        }\n      },\n      \"propertyTables\": [{\n        \"name\": \"tree_survey_2021-09-29\",\n        \"class\": \"tree\",\n        \"count\": 10,  // The number of elements in each property array (in `species`, in `age`).\n        \"properties\": {\n          \"species\": {\n            \"values\": 0, // It's an index of the buffer view containing property values.\n          },\n          \"age\": {\n            \"values\": 1\n          }\n        }\n      }]\n    }\n  }\n}\n*/\n/**\n * Decodes feature metadata from extension.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param options - GLTFLoader options.\n */\nfunction decodeExtStructuralMetadata(scenegraph, options) {\n  // Decoding metadata involves buffers processing.\n  // So, if buffers have not been loaded, there is no reason to process metadata.\n  if (!options.gltf?.loadBuffers) {\n    return;\n  }\n  const extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);\n  if (!extension) {\n    return;\n  }\n  if (options.gltf?.loadImages) {\n    decodePropertyTextures(scenegraph, extension);\n  }\n  decodePropertyTables(scenegraph, extension);\n}\n/**\n * Processes the data stored in the textures\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param extension - Top-level extension.\n */\nfunction decodePropertyTextures(scenegraph, extension) {\n  const propertyTextures = extension.propertyTextures;\n  const json = scenegraph.gltf.json;\n  if (propertyTextures && json.meshes) {\n    // Iterate through all meshes/primitives.\n    for (const mesh of json.meshes) {\n      for (const primitive of mesh.primitives) {\n        processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension);\n      }\n    }\n  }\n}\n/**\n * Processes the data stored in the property tables.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param extension - Top-level extension.\n */\nfunction decodePropertyTables(scenegraph, extension) {\n  const schema = extension.schema;\n  if (!schema) {\n    return;\n  }\n  const schemaClasses = schema.classes;\n  const propertyTables = extension.propertyTables;\n  if (schemaClasses && propertyTables) {\n    for (const schemaName in schemaClasses) {\n      const propertyTable = findPropertyTableByClass(propertyTables, schemaName);\n      if (propertyTable) {\n        processPropertyTable(scenegraph, schema, propertyTable);\n      }\n    }\n  }\n}\n/**\n * Finds the property table by class name.\n * @param propertyTables - propertyTable definition taken from the top-level extension.\n * @param schemaClassName - class name in the extension schema.\n */\nfunction findPropertyTableByClass(propertyTables, schemaClassName) {\n  for (const propertyTable of propertyTables) {\n    if (propertyTable.class === schemaClassName) {\n      return propertyTable;\n    }\n  }\n  return null;\n}\n/**\n * Takes data from property textures reffered by the primitive.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyTextures - propertyTexture definition taken from the top-level extention.\n * @param primitive - Primitive object.\n * @param extension - Top-level extension.\n */\nfunction processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension) {\n  if (!propertyTextures) {\n    return;\n  }\n  const primitiveExtension = primitive.extensions?.[EXT_STRUCTURAL_METADATA_NAME];\n  const primitivePropertyTextureIndices = primitiveExtension?.propertyTextures;\n  if (!primitivePropertyTextureIndices) {\n    return;\n  }\n  for (const primitivePropertyTextureIndex of primitivePropertyTextureIndices) {\n    const propertyTexture = propertyTextures[primitivePropertyTextureIndex];\n    processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension);\n  }\n}\n/**\n * Takes property data from the texture pointed by the primitive and appends them to `exension.data`.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyTexture - propertyTexture definition taken from the top-level extension.\n * @param primitive - Primitive object.\n * @param extension - Top-level extension.\n */\nfunction processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension) {\n  if (!propertyTexture.properties) {\n    return;\n  }\n  if (!extension.dataAttributeNames) {\n    extension.dataAttributeNames = [];\n  }\n  /* Iterate through all properties defined in propertyTexture, e.g. \"speed\" and \"direction\":\n    {\n      \"class\": \"wind\",\n      \"properties\": {\n        \"speed\": {\n          \"index\": 0,\n          \"texCoord\": 0,\n          \"channels\": [0]\n        },\n        \"direction\": {\n          \"index\": 0,\n          \"texCoord\": 0,\n          \"channels\": [1, 2]\n        }\n      }\n    }\n  */\n  const className = propertyTexture.class;\n  for (const propertyName in propertyTexture.properties) {\n    // propertyName has values like \"speed\", \"direction\"\n    // Make attributeName as a combination of the class name and the propertyName like \"wind_speed\" or \"wind_direction\"\n    const attributeName = `${className}_${propertyName}`;\n    const textureInfoTopLevel = propertyTexture.properties?.[propertyName];\n    if (!textureInfoTopLevel) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    // The data taken from all meshes/primitives (the same property, e.g. \"speed\" or \"direction\") will be combined into one array and saved in textureInfoTopLevel.data\n    // Initially textureInfoTopLevel.data will be initialized with an empty array.\n    if (!textureInfoTopLevel.data) {\n      textureInfoTopLevel.data = [];\n    }\n    const featureTextureTable = textureInfoTopLevel.data;\n    const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);\n    if (propertyData === null) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);\n    textureInfoTopLevel.data = featureTextureTable;\n    extension.dataAttributeNames.push(attributeName);\n  }\n}\n/**\n * Navigates through all properies in the property table, gets properties data,\n * and put the data to `propertyTable.data` as an array.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param schema - schema object.\n * @param propertyTable - propertyTable definition taken from the top-level extension.\n */\nfunction processPropertyTable(scenegraph, schema, propertyTable) {\n  const schemaClass = schema.classes?.[propertyTable.class];\n  if (!schemaClass) {\n    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);\n  }\n  const numberOfElements = propertyTable.count; // `propertyTable.count` is a number of elements in each property array.\n  for (const propertyName in schemaClass.properties) {\n    const classProperty = schemaClass.properties[propertyName];\n    const propertyTableProperty = propertyTable.properties?.[propertyName];\n    if (propertyTableProperty) {\n      // Getting all elements (`numberOfElements`) of the array in the `propertyTableProperty`\n      const data = getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);\n      propertyTableProperty.data = data;\n    }\n  }\n}\n/**\n * Decodes a propertyTable column from binary source based on property type.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param schema - Schema object.\n * @param classProperty - class property object.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @returns {string[] | number[] | string[][] | number[][]}\n */\nfunction getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty) {\n  let data = [];\n  const valuesBufferView = propertyTableProperty.values;\n  const valuesDataBytes = scenegraph.getTypedArrayForBufferView(valuesBufferView);\n  const arrayOffsets = getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements);\n  const stringOffsets = getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements);\n  switch (classProperty.type) {\n    case 'SCALAR':\n    case 'VEC2':\n    case 'VEC3':\n    case 'VEC4':\n    case 'MAT2':\n    case 'MAT3':\n    case 'MAT4':\n      {\n        data = getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets);\n        break;\n      }\n    case 'BOOLEAN':\n      {\n        // TODO: implement it as soon as we have the corresponding tileset\n        throw new Error(`Not implemented - classProperty.type=${classProperty.type}`);\n      }\n    case 'STRING':\n      {\n        data = getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets);\n        break;\n      }\n    case 'ENUM':\n      {\n        data = getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets);\n        break;\n      }\n    default:\n      throw new Error(`Unknown classProperty type ${classProperty.type}`);\n  }\n  return data;\n}\n/**\n * Parses propertyTable.property.arrayOffsets that are offsets of sub-arrays in a flatten array of values.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param classProperty - class property object.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @returns Typed array with offset values.\n * @see https://github.com/CesiumGS/glTF/blob/2976f1183343a47a29e4059a70961371cd2fcee8/extensions/2.0/Vendor/EXT_structural_metadata/schema/propertyTable.property.schema.json#L21\n */\nfunction getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements) {\n  if (classProperty.array &&\n  // `count` is a number of array elements. May only be defined when `array` is true.\n  // If `count` is NOT defined, it's a VARIABLE-length array\n  typeof classProperty.count === 'undefined' &&\n  // `arrayOffsets` is an index of the buffer view containing offsets for variable-length arrays.\n  typeof propertyTableProperty.arrayOffsets !== 'undefined') {\n    // Data are in a VARIABLE-length array\n    return getOffsetsForProperty(scenegraph, propertyTableProperty.arrayOffsets, propertyTableProperty.arrayOffsetType || 'UINT32', numberOfElements);\n  }\n  return null;\n}\n/**\n * Parses propertyTable.property.stringOffsets.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @returns Typed array with offset values.\n * @see https://github.com/CesiumGS/glTF/blob/2976f1183343a47a29e4059a70961371cd2fcee8/extensions/2.0/Vendor/EXT_structural_metadata/schema/propertyTable.property.schema.json#L29C10-L29C23\n */\nfunction getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements) {\n  if (typeof propertyTableProperty.stringOffsets !== 'undefined' // `stringOffsets` is an index of the buffer view containing offsets for strings.\n  ) {\n    // Data are in a FIXED-length array\n    return getOffsetsForProperty(scenegraph, propertyTableProperty.stringOffsets, propertyTableProperty.stringOffsetType || 'UINT32', numberOfElements);\n  }\n  return null;\n}\n/**\n * Decodes properties of SCALAR, VEC-N, MAT-N types from binary sourse.\n * @param classProperty - class property object.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param valuesDataBytes - Data taken from values property of the property table property.\n * @param arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @returns Property values in a typed array or in an array of typed arrays.\n */\nfunction getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {\n  const isArray = classProperty.array;\n  const arrayCount = classProperty.count;\n  const elementSize = getArrayElementByteSize(classProperty.type, classProperty.componentType);\n  const elementCount = valuesDataBytes.byteLength / elementSize;\n  let valuesData;\n  if (classProperty.componentType) {\n    valuesData = convertRawBufferToMetadataArray(valuesDataBytes, classProperty.type,\n    // The datatype of the element's components. Only applicable to `SCALAR`, `VECN`, and `MATN` types.\n    classProperty.componentType, elementCount);\n  } else {\n    // The spec doesn't provide any info what to do if componentType is not set.\n    valuesData = valuesDataBytes;\n  }\n  if (isArray) {\n    if (arrayOffsets) {\n      // VARIABLE-length array\n      return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);\n    }\n    if (arrayCount) {\n      // FIXED-length array\n      return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);\n    }\n    return [];\n  }\n  return valuesData;\n}\n/**\n * Decodes properties of enum type from binary source.\n * @param schema - Schema object.\n * @param classProperty - Class property object.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param valuesDataBytes - Data taken from values property of the property table property.\n * @param arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @returns Strings array of nested strings array.\n */\nfunction getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {\n  const enumType = classProperty.enumType;\n  // Enum ID as declared in the `enums` dictionary. Required when `type` is `ENUM`.\n  if (!enumType) {\n    throw new Error('Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM');\n  }\n  const enumEntry = schema.enums?.[enumType];\n  if (!enumEntry) {\n    throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${enumType}`);\n  }\n  const enumValueType = enumEntry.valueType || 'UINT16';\n  const elementSize = getArrayElementByteSize(classProperty.type, enumValueType);\n  const elementCount = valuesDataBytes.byteLength / elementSize;\n  let valuesData = convertRawBufferToMetadataArray(valuesDataBytes, classProperty.type, enumValueType, elementCount);\n  if (!valuesData) {\n    valuesData = valuesDataBytes;\n  }\n  if (classProperty.array) {\n    if (arrayOffsets) {\n      // VARIABLE-length array\n      return parseVariableLengthArrayENUM({\n        valuesData,\n        numberOfElements,\n        arrayOffsets,\n        valuesDataBytesLength: valuesDataBytes.length,\n        elementSize,\n        enumEntry\n      });\n    }\n    const arrayCount = classProperty.count;\n    if (arrayCount) {\n      // FIXED-length array\n      return parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry);\n    }\n    return [];\n  }\n  // Single value (not an array)\n  return getEnumsArray(valuesData, 0, numberOfElements, enumEntry);\n}\n/**\n * Parses variable length nested ENUM arrays.\n * @param params.valuesData - Values in a flat typed array.\n * @param params.numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param params.arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @param params.valuesDataBytesLength - Byte length of values array.\n * @param params.elementSize - Single element byte size.\n * @param params.enumEntry - Enums dictionary.\n * @returns Nested strings array.\n */\nfunction parseVariableLengthArrayENUM(params) {\n  const {\n    valuesData,\n    numberOfElements,\n    arrayOffsets,\n    valuesDataBytesLength,\n    elementSize,\n    enumEntry\n  } = params;\n  const attributeValueArray = [];\n  for (let index = 0; index < numberOfElements; index++) {\n    const arrayOffset = arrayOffsets[index];\n    const arrayByteSize = arrayOffsets[index + 1] - arrayOffsets[index];\n    if (arrayByteSize + arrayOffset > valuesDataBytesLength) {\n      break;\n    }\n    const typedArrayOffset = arrayOffset / elementSize;\n    const elementCount = arrayByteSize / elementSize;\n    const array = getEnumsArray(valuesData, typedArrayOffset, elementCount, enumEntry);\n    attributeValueArray.push(array);\n  }\n  return attributeValueArray;\n}\n/**\n * Parses fixed length ENUM arrays.\n * @param valuesData - Values in a flat typed array.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param arrayCount - Nested arrays length.\n * @param enumEntry - Enums dictionary.\n * @returns Nested strings array.\n */\nfunction parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry) {\n  const attributeValueArray = [];\n  for (let index = 0; index < numberOfElements; index++) {\n    const elementOffset = arrayCount * index;\n    const array = getEnumsArray(valuesData, elementOffset, arrayCount, enumEntry);\n    attributeValueArray.push(array);\n  }\n  return attributeValueArray;\n}\n/**\n * Parses ENUM values into a string array.\n * @param valuesData - Values in a flat typed array.\n * @param offset - Offset to start parse from.\n * @param count - Values length to parse.\n * @param enumEntry - Enums dictionary.\n * @returns Array of strings with parsed ENUM names.\n */\nfunction getEnumsArray(valuesData, offset, count, enumEntry) {\n  const array = [];\n  for (let i = 0; i < count; i++) {\n    // At the moment we don't support BigInt. It requires additional calculations logic\n    // and might be an issue in Safari\n    if (valuesData instanceof BigInt64Array || valuesData instanceof BigUint64Array) {\n      array.push('');\n    } else {\n      const value = valuesData[offset + i];\n      const enumObject = getEnumByValue(enumEntry, value);\n      if (enumObject) {\n        array.push(enumObject.name);\n      } else {\n        array.push('');\n      }\n    }\n  }\n  return array;\n}\n/**\n * Looks up ENUM whose `value` property matches the specified number in the parameter `value`.\n * @param {GLTF_EXT_structural_metadata_Enum} enumEntry - ENUM entry containing the array of possible enums.\n * @param {number} value - The value of the ENUM to locate.\n * @returns {GLTF_EXT_structural_metadata_EnumValue | null} ENUM matcihng the specified value or null of no ENUM object was found.\n */\nfunction getEnumByValue(enumEntry, value) {\n  for (const enumValue of enumEntry.values) {\n    if (enumValue.value === value) {\n      return enumValue;\n    }\n  }\n  return null;\n}\nconst SCHEMA_CLASS_ID_DEFAULT = 'schemaClassId';\nfunction encodeExtStructuralMetadata(scenegraph, options) {\n  const extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);\n  if (!extension) {\n    return;\n  }\n  if (extension.propertyTables) {\n    for (const table of extension.propertyTables) {\n      const classId = table.class;\n      const schemaClass = extension.schema?.classes?.[classId];\n      if (table.properties && schemaClass) {\n        encodeProperties(table, schemaClass, scenegraph);\n      }\n    }\n  }\n}\nfunction encodeProperties(table, schemaClass, scenegraph) {\n  for (const propertyName in table.properties) {\n    const data = table.properties[propertyName].data;\n    if (data) {\n      const classProperty = schemaClass.properties[propertyName];\n      if (classProperty) {\n        const tableProperty = createPropertyTableProperty(data, classProperty, scenegraph);\n        // Override table property that came with \"data\"\n        table.properties[propertyName] = tableProperty;\n      }\n    }\n  }\n}\n/**\n * Creates ExtStructuralMetadata, creates the schema and creates a property table containing feature data provided.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyAttributes - property attributes\n * @param classId - classId to use for encoding metadata.\n * @returns Index of the table created.\n */\nexport function createExtStructuralMetadata(scenegraph, propertyAttributes, classId = SCHEMA_CLASS_ID_DEFAULT) {\n  let extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);\n  if (!extension) {\n    extension = scenegraph.addExtension(EXT_STRUCTURAL_METADATA_NAME);\n  }\n  extension.schema = createSchema(propertyAttributes, classId, extension.schema);\n  const table = createPropertyTable(propertyAttributes, classId, extension.schema);\n  if (!extension.propertyTables) {\n    extension.propertyTables = [];\n  }\n  return extension.propertyTables.push(table) - 1; // index of the table\n}\nfunction createSchema(propertyAttributes, classId, schemaToUpdate) {\n  const schema = schemaToUpdate ?? {\n    id: 'schema_id'\n  };\n  const schemaClass = {\n    properties: {}\n  };\n  for (const attribute of propertyAttributes) {\n    const classProperty = {\n      type: attribute.elementType,\n      componentType: attribute.componentType\n    };\n    schemaClass.properties[attribute.name] = classProperty;\n  }\n  schema.classes = {};\n  schema.classes[classId] = schemaClass;\n  return schema;\n}\nfunction createPropertyTable(propertyAttributes, classId, schema) {\n  const table = {\n    class: classId,\n    count: 0\n  };\n  // count is a number of rows in the table\n  let count = 0;\n  const schemaClass = schema.classes?.[classId];\n  for (const attribute of propertyAttributes) {\n    if (count === 0) {\n      count = attribute.values.length;\n    }\n    // The number of elements in all propertyAttributes must be the same\n    if (count !== attribute.values.length && attribute.values.length) {\n      throw new Error('Illegal values in attributes');\n    }\n    const classProperty = schemaClass?.properties[attribute.name];\n    if (classProperty) {\n      // const tableProperty = createPropertyTableProperty(attribute, classProperty, scenegraph);\n      if (!table.properties) {\n        table.properties = {};\n      }\n      // values is a required field. Its real value will be set while encoding data\n      table.properties[attribute.name] = {\n        values: 0,\n        data: attribute.values\n      };\n    }\n  }\n  table.count = count;\n  return table;\n}\nfunction createPropertyTableProperty(\n// attribute: PropertyAttribute,\nvalues, classProperty, scenegraph) {\n  const prop = {\n    values: 0\n  };\n  if (classProperty.type === 'STRING') {\n    const {\n      stringData,\n      stringOffsets\n    } = createPropertyDataString(values);\n    prop.stringOffsets = createBufferView(stringOffsets, scenegraph);\n    prop.values = createBufferView(stringData, scenegraph);\n  } else if (classProperty.type === 'SCALAR' && classProperty.componentType) {\n    const data = createPropertyDataScalar(values, classProperty.componentType);\n    prop.values = createBufferView(data, scenegraph);\n  }\n  return prop;\n}\nconst COMPONENT_TYPE_TO_ARRAY_CONSTRUCTOR = {\n  INT8: Int8Array,\n  UINT8: Uint8Array,\n  INT16: Int16Array,\n  UINT16: Uint16Array,\n  INT32: Int32Array,\n  UINT32: Uint32Array,\n  INT64: Int32Array,\n  UINT64: Uint32Array,\n  FLOAT32: Float32Array,\n  FLOAT64: Float64Array\n};\nfunction createPropertyDataScalar(array, componentType) {\n  const numberArray = [];\n  for (const value of array) {\n    numberArray.push(Number(value));\n  }\n  const Construct = COMPONENT_TYPE_TO_ARRAY_CONSTRUCTOR[componentType];\n  if (!Construct) {\n    throw new Error('Illegal component type');\n  }\n  return new Construct(numberArray);\n}\nfunction createPropertyDataString(strings) {\n  const utf8Encode = new TextEncoder();\n  const arr = [];\n  let len = 0;\n  for (const str of strings) {\n    const uint8Array = utf8Encode.encode(str);\n    len += uint8Array.length;\n    arr.push(uint8Array);\n  }\n  const strArray = new Uint8Array(len);\n  const strOffsets = [];\n  let offset = 0;\n  for (const str of arr) {\n    strArray.set(str, offset);\n    strOffsets.push(offset);\n    offset += str.length;\n  }\n  strOffsets.push(offset); // The last offset represents the byte offset after the last string.\n  const stringOffsetsTypedArray = new Uint32Array(strOffsets); // Its length = len+1\n  return {\n    stringData: strArray,\n    stringOffsets: stringOffsetsTypedArray\n  };\n}\nfunction createBufferView(typedArray, scenegraph) {\n  scenegraph.gltf.buffers.push({\n    arrayBuffer: typedArray.buffer,\n    byteOffset: typedArray.byteOffset,\n    byteLength: typedArray.byteLength\n  });\n  return scenegraph.addBufferView(typedArray);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}