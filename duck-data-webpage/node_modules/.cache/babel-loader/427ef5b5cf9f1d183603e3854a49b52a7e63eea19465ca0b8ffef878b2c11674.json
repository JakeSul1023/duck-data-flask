{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Framebuffer } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\nimport { getGLTypeFromTypedArray, getTypedArrayFromGLType } from \"./typed-array-utils.js\";\nimport { glFormatToComponents, glTypeToBytes } from \"./format-utils.js\";\nimport { WEBGLTexture } from \"../resources/webgl-texture.js\";\nimport { withGLParameters } from \"../../context/state-tracker/with-parameters.js\";\n/** A \"border\" parameter is required in many WebGL texture APIs, but must always be 0... */\nconst BORDER = 0;\n/**\n * Initializes a texture memory space\n * Clear all the textures and mip levels of a two-dimensional or array texture at the same time.\n * On some implementations faster than repeatedly setting levels\n *\n * @note From WebGL 2 spec section 3.7.6:\n * @see https://registry.khronos.org/webgl/specs/latest/2.0/\n * - The image contents are set as if a buffer of sufficient size initialized to 0 would be passed to each level's texImage2D/3D\n * - texStorage2D should be considered a preferred alternative to texImage2D. It may have lower memory costs than texImage2D in some implementations.\n * - Once texStorage*D has been called, the texture is immutable and can only be updated with texSubImage*(), not texImage()\n */\nexport function initializeTextureStorage(gl, levels, options) {\n  const {\n    dimension,\n    width,\n    height,\n    depth = 0\n  } = options;\n  const {\n    glInternalFormat\n  } = options;\n  const glTarget = options.glTarget; // getWebGLCubeFaceTarget(options.glTarget, dimension, depth);\n  switch (dimension) {\n    case '2d-array':\n    case '3d':\n      gl.texStorage3D(glTarget, levels, glInternalFormat, width, height, depth);\n      break;\n    default:\n      gl.texStorage2D(glTarget, levels, glInternalFormat, width, height);\n  }\n}\n/**\n * Copy a region of compressed data from a GPU memory buffer into this texture.\n */\nexport function copyExternalImageToMipLevel(gl, handle, image, options) {\n  const {\n    width,\n    height\n  } = options;\n  const {\n    dimension,\n    depth = 0,\n    mipLevel = 0\n  } = options;\n  const {\n    x = 0,\n    y = 0,\n    z = 0\n  } = options;\n  const {\n    glFormat,\n    glType\n  } = options;\n  const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);\n  const glParameters = options.flipY ? {\n    [37440]: true\n  } : {};\n  withGLParameters(gl, glParameters, () => {\n    switch (dimension) {\n      case '2d-array':\n      case '3d':\n        gl.bindTexture(glTarget, handle);\n        // prettier-ignore\n        gl.texSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, glType, image);\n        gl.bindTexture(glTarget, null);\n        break;\n      case '2d':\n      case 'cube':\n        gl.bindTexture(glTarget, handle);\n        // prettier-ignore\n        gl.texSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, glType, image);\n        gl.bindTexture(glTarget, null);\n        break;\n      default:\n        throw new Error(dimension);\n    }\n  });\n}\n/**\n * Copy a region of data from a CPU memory buffer into this texture.\n */\nexport function copyCPUDataToMipLevel(gl, typedArray, options) {\n  const {\n    dimension,\n    width,\n    height,\n    depth = 0,\n    mipLevel = 0,\n    byteOffset = 0\n  } = options;\n  const {\n    x = 0,\n    y = 0,\n    z = 0\n  } = options;\n  const {\n    glFormat,\n    glType,\n    compressed\n  } = options;\n  const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);\n  // gl.bindTexture(glTarget, null);\n  switch (dimension) {\n    case '2d-array':\n    case '3d':\n      if (compressed) {\n        // prettier-ignore\n        gl.compressedTexSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, typedArray, byteOffset); // , byteLength\n      } else {\n        // prettier-ignore\n        gl.texSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, glType, typedArray, byteOffset); // , byteLength\n      }\n      break;\n    case '2d':\n    case 'cube':\n      if (compressed) {\n        // prettier-ignore\n        gl.compressedTexSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, typedArray, byteOffset); // , byteLength\n      } else {\n        // prettier-ignore\n        gl.texSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, glType, typedArray, byteOffset); // , byteLength\n      }\n      break;\n    default:\n      throw new Error(dimension);\n  }\n}\n/**\n * Copy a region of compressed data from a GPU memory buffer into this texture.\n */\nexport function copyGPUBufferToMipLevel(gl, webglBuffer, byteLength, options) {\n  const {\n    dimension,\n    width,\n    height,\n    depth = 0,\n    mipLevel = 0,\n    byteOffset = 0\n  } = options;\n  const {\n    x = 0,\n    y = 0,\n    z = 0\n  } = options;\n  const {\n    glFormat,\n    glType,\n    compressed\n  } = options;\n  const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);\n  gl.bindBuffer(35052, webglBuffer);\n  switch (dimension) {\n    case '2d-array':\n    case '3d':\n      // 3 dimensional textures requires 3D texture functions\n      if (compressed) {\n        // TODO enable extension?\n        // prettier-ignore\n        gl.compressedTexSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, byteLength, byteOffset);\n      } else {\n        // prettier-ignore\n        gl.texSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, glType, byteOffset);\n      }\n      break;\n    case '2d':\n    case 'cube':\n      if (compressed) {\n        // prettier-ignore\n        gl.compressedTexSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, byteLength, byteOffset);\n      } else {\n        // prettier-ignore\n        gl.texSubImage2D(glTarget, mipLevel, x, y, width, height, BORDER, glFormat, byteOffset);\n      }\n      break;\n    default:\n      throw new Error(dimension);\n  }\n}\n// INTERNAL HELPERS\n/** Convert a WebGPU style texture constant to a WebGL style texture constant */\nexport function getWebGLTextureTarget(dimension) {\n  // prettier-ignore\n  switch (dimension) {\n    case '1d':\n      break;\n    // not supported in any WebGL version\n    case '2d':\n      return 3553;\n    // supported in WebGL1\n    case '3d':\n      return 32879;\n    // supported in WebGL2\n    case 'cube':\n      return 34067;\n    // supported in WebGL1\n    case '2d-array':\n      return 35866;\n    // supported in WebGL2\n    case 'cube-array':\n      break;\n    // not supported in any WebGL version\n  }\n  throw new Error(dimension);\n}\n/**\n * In WebGL, cube maps specify faces by overriding target instead of using the depth parameter.\n * @note We still bind the texture using GL.TEXTURE_CUBE_MAP, but we need to use the face-specific target when setting mip levels.\n * @returns glTarget unchanged, if dimension !== 'cube'.\n */\nexport function getWebGLCubeFaceTarget(glTarget, dimension, level) {\n  return dimension === 'cube' ? 34069 + level : glTarget;\n}\n/**\n * Copies data from a type  or a Texture object into ArrayBuffer object.\n * App can provide targetPixelArray or have it auto allocated by this method\n *  newly allocated by this method unless provided by app.\n * @deprecated Use CommandEncoder.copyTextureToBuffer and Buffer.read\n * @note Slow requires roundtrip to GPU\n *\n * @param source\n * @param options\n * @returns pixel array,\n */\nexport function readPixelsToArray(source, options) {\n  const {\n    sourceX = 0,\n    sourceY = 0,\n    sourceAttachment = 0 // TODO - support gl.readBuffer\n  } = options || {};\n  let {\n    target = null,\n    // following parameters are auto deduced if not provided\n    sourceWidth,\n    sourceHeight,\n    sourceDepth,\n    sourceFormat,\n    sourceType\n  } = options || {};\n  const {\n    framebuffer,\n    deleteFramebuffer\n  } = getFramebuffer(source);\n  // assert(framebuffer);\n  const {\n    gl,\n    handle\n  } = framebuffer;\n  sourceWidth ||= framebuffer.width;\n  sourceHeight ||= framebuffer.height;\n  const texture = framebuffer.colorAttachments[sourceAttachment]?.texture;\n  if (!texture) {\n    throw new Error(`Invalid framebuffer attachment ${sourceAttachment}`);\n  }\n  sourceDepth = texture?.depth || 1;\n  sourceFormat ||= texture?.glFormat || 6408;\n  // Deduce the type from color attachment if not provided.\n  sourceType ||= texture?.glType || 5121;\n  // Deduce type and allocated pixelArray if needed\n  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight, sourceDepth);\n  // Pixel array available, if necessary, deduce type from it.\n  sourceType = sourceType || getGLTypeFromTypedArray(target);\n  // Note: luma.gl overrides bindFramebuffer so that we can reliably restore the previous framebuffer (this is the only function for which we do that)\n  const prevHandle = gl.bindFramebuffer(36160, handle);\n  // Select the color attachment to read from\n  gl.readBuffer(36064 + sourceAttachment);\n  // There is a lot of hedging in the WebGL2 spec about what formats are guaranteed to be readable\n  // (It should always be possible to read RGBA/UNSIGNED_BYTE, but most other combinations are not guaranteed)\n  // Querying is possible but expensive:\n  // const {device} = framebuffer;\n  // texture.glReadFormat ||= gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT);\n  // texture.glReadType ||= gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE);\n  // console.log('params', device.getGLKey(texture.glReadFormat), device.getGLKey(texture.glReadType));\n  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);\n  gl.readBuffer(36064);\n  gl.bindFramebuffer(36160, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.destroy();\n  }\n  return target;\n}\n/**\n * Copies data from a Framebuffer or a Texture object into a Buffer object.\n * NOTE: doesn't wait for copy to be complete, it programs GPU to perform a DMA transffer.\n * @deprecated Use CommandEncoder\n * @param source\n * @param options\n */\nexport function readPixelsToBuffer(source, options) {\n  const {\n    target,\n    sourceX = 0,\n    sourceY = 0,\n    sourceFormat = 6408,\n    targetByteOffset = 0\n  } = options || {};\n  // following parameters are auto deduced if not provided\n  let {\n    sourceWidth,\n    sourceHeight,\n    sourceType\n  } = options || {};\n  const {\n    framebuffer,\n    deleteFramebuffer\n  } = getFramebuffer(source);\n  // assert(framebuffer);\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n  // Asynchronous read (PIXEL_PACK_BUFFER) is WebGL2 only feature\n  const webglFramebuffer = framebuffer;\n  // deduce type if not available.\n  sourceType = sourceType || 5121;\n  let webglBufferTarget = target;\n  if (!webglBufferTarget) {\n    // Create new buffer with enough size\n    const components = glFormatToComponents(sourceFormat);\n    const byteCount = glTypeToBytes(sourceType);\n    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;\n    webglBufferTarget = webglFramebuffer.device.createBuffer({\n      byteLength\n    });\n  }\n  // TODO(donmccurdy): Do we have tests to confirm this is working?\n  const commandEncoder = source.device.createCommandEncoder();\n  commandEncoder.copyTextureToBuffer({\n    sourceTexture: source,\n    width: sourceWidth,\n    height: sourceHeight,\n    origin: [sourceX, sourceY],\n    destinationBuffer: webglBufferTarget,\n    byteOffset: targetByteOffset\n  });\n  commandEncoder.destroy();\n  if (deleteFramebuffer) {\n    framebuffer.destroy();\n  }\n  return webglBufferTarget;\n}\n/**\n * Copy a rectangle from a Framebuffer or Texture object into a texture (at an offset)\n * @deprecated Use CommandEncoder\n */\n// eslint-disable-next-line complexity, max-statements\nexport function copyToTexture(sourceTexture, destinationTexture, options) {\n  const {\n    sourceX = 0,\n    sourceY = 0,\n    // attachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetMipmaplevel = 0,\n    targetInternalFormat = 6408\n  } = options || {};\n  let {\n    targetX,\n    targetY,\n    targetZ,\n    width,\n    // defaults to target width\n    height // defaults to target height\n  } = options || {};\n  const {\n    framebuffer,\n    deleteFramebuffer\n  } = getFramebuffer(sourceTexture);\n  // assert(framebuffer);\n  const webglFramebuffer = framebuffer;\n  const {\n    device,\n    handle\n  } = webglFramebuffer;\n  const isSubCopy = typeof targetX !== 'undefined' || typeof targetY !== 'undefined' || typeof targetZ !== 'undefined';\n  targetX = targetX || 0;\n  targetY = targetY || 0;\n  targetZ = targetZ || 0;\n  const prevHandle = device.gl.bindFramebuffer(36160, handle);\n  // TODO - support gl.readBuffer (WebGL2 only)\n  // const prevBuffer = gl.readBuffer(attachment);\n  // assert(target);\n  let texture = null;\n  let textureTarget;\n  if (destinationTexture instanceof WEBGLTexture) {\n    texture = destinationTexture;\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n    texture?.bind(0);\n    // @ts-ignore\n    textureTarget = texture.target;\n  } else {\n    // @ts-ignore\n    textureTarget = target;\n  }\n  if (!isSubCopy) {\n    device.gl.copyTexImage2D(textureTarget, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0 /* border must be 0 */);\n  } else {\n    switch (textureTarget) {\n      case 3553:\n      case 34067:\n        device.gl.copyTexSubImage2D(textureTarget, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);\n        break;\n      case 35866:\n      case 32879:\n        device.gl.copyTexSubImage3D(textureTarget, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);\n        break;\n      default:\n    }\n  }\n  if (texture) {\n    texture.unbind();\n  }\n  // @ts-expect-error\n  device.gl.bindFramebuffer(36160, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.destroy();\n  }\n  return texture;\n}\nfunction getFramebuffer(source) {\n  if (!(source instanceof Framebuffer)) {\n    return {\n      framebuffer: toFramebuffer(source),\n      deleteFramebuffer: true\n    };\n  }\n  return {\n    framebuffer: source,\n    deleteFramebuffer: false\n  };\n}\n/**\n * Wraps a given texture into a framebuffer object, that can be further used\n * to read data from the texture object.\n */\nexport function toFramebuffer(texture, props) {\n  const {\n    device,\n    width,\n    height,\n    id\n  } = texture;\n  const framebuffer = device.createFramebuffer({\n    ...props,\n    id: `framebuffer-for-${id}`,\n    width,\n    height,\n    colorAttachments: [texture]\n  });\n  return framebuffer;\n}\n// eslint-disable-next-line max-params\nfunction getPixelArray(pixelArray, glType, glFormat, width, height, depth) {\n  if (pixelArray) {\n    return pixelArray;\n  }\n  // const formatInfo = decodeTextureFormat(format);\n  // Allocate pixel array if not already available, using supplied type\n  glType ||= 5121;\n  const ArrayType = getTypedArrayFromGLType(glType, {\n    clamped: false\n  });\n  const components = glFormatToComponents(glFormat);\n  // TODO - check for composite type (components = 1).\n  return new ArrayType(width * height * components);\n}","map":{"version":3,"names":["Framebuffer","GL","getGLTypeFromTypedArray","getTypedArrayFromGLType","glFormatToComponents","glTypeToBytes","WEBGLTexture","withGLParameters","BORDER","initializeTextureStorage","gl","levels","options","dimension","width","height","depth","glInternalFormat","glTarget","texStorage3D","texStorage2D","copyExternalImageToMipLevel","handle","image","mipLevel","x","y","z","glFormat","glType","getWebGLCubeFaceTarget","glParameters","flipY","bindTexture","texSubImage3D","texSubImage2D","Error","copyCPUDataToMipLevel","typedArray","byteOffset","compressed","compressedTexSubImage3D","compressedTexSubImage2D","copyGPUBufferToMipLevel","webglBuffer","byteLength","bindBuffer","getWebGLTextureTarget","level","readPixelsToArray","source","sourceX","sourceY","sourceAttachment","target","sourceWidth","sourceHeight","sourceDepth","sourceFormat","sourceType","framebuffer","deleteFramebuffer","getFramebuffer","texture","colorAttachments","getPixelArray","prevHandle","bindFramebuffer","readBuffer","readPixels","destroy","readPixelsToBuffer","targetByteOffset","webglFramebuffer","webglBufferTarget","components","byteCount","device","createBuffer","commandEncoder","createCommandEncoder","copyTextureToBuffer","sourceTexture","origin","destinationBuffer","copyToTexture","destinationTexture","targetMipmaplevel","targetInternalFormat","targetX","targetY","targetZ","isSubCopy","textureTarget","Number","isFinite","bind","copyTexImage2D","copyTexSubImage2D","copyTexSubImage3D","unbind","toFramebuffer","props","id","createFramebuffer","pixelArray","ArrayType","clamped"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\webgl\\src\\adapter\\helpers\\webgl-texture-utils.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n//\n// WebGL... the texture API from hell... hopefully made simpler\n//\n\nimport {TypedArray} from '@math.gl/types';\nimport type {ExternalImage} from '@luma.gl/core';\nimport {Buffer, Texture, Framebuffer, FramebufferProps} from '@luma.gl/core';\nimport {\n  GL,\n  GLTextureTarget,\n  GLTextureCubeMapTarget,\n  GLTexelDataFormat,\n  GLPixelType,\n  GLDataType\n} from '@luma.gl/constants';\n\nimport {WEBGLFramebuffer} from '../resources/webgl-framebuffer';\nimport {getGLTypeFromTypedArray, getTypedArrayFromGLType} from './typed-array-utils';\nimport {glFormatToComponents, glTypeToBytes} from './format-utils';\nimport {WEBGLBuffer} from '../resources/webgl-buffer';\nimport {WEBGLTexture} from '../resources/webgl-texture';\nimport {withGLParameters} from '../../context/state-tracker/with-parameters';\n\n/** A \"border\" parameter is required in many WebGL texture APIs, but must always be 0... */\nconst BORDER = 0;\n\n/**\n * Options for setting data into a texture\n */\nexport type WebGLSetTextureOptions = {\n  dimension: '1d' | '2d' | '2d-array' | 'cube' | 'cube-array' | '3d';\n  height: number;\n  width: number;\n  depth: number;\n  mipLevel?: number;\n  glTarget: GLTextureTarget;\n  glInternalFormat: GL;\n  glFormat: GLTexelDataFormat;\n  glType: GLPixelType;\n  compressed?: boolean;\n  byteOffset?: number;\n  byteLength?: number;\n};\n\n/**\n * Options for copying an image or data into a texture\n *\n * @param {GLenum} format - internal format of image data.\n * @param {GLenum} type\n *  - format of array (autodetect from type) or\n *  - (WEBGL2) format of buffer or ArrayBufferView\n * @param {GLenum} dataFormat - format of image data.\n * @param {Number} offset - (WEBGL2) offset from start of buffer\n * @parameters - temporary settings to be applied, can be used to supply pixel store settings.\n */\nexport type WebGLCopyTextureOptions = {\n  dimension: '1d' | '2d' | '2d-array' | 'cube' | 'cube-array' | '3d';\n  /** mip level to be updated */\n  mipLevel?: number;\n  /** width of the sub image to be updated */\n  width: number;\n  /** height of the sub image to be updated */\n  height: number;\n  /** depth of texture to be updated */\n  depth?: number;\n  /** xOffset from where texture to be updated */\n  x?: number;\n  /** yOffset from where texture to be updated */\n  y?: number;\n  /** yOffset from where texture to be updated */\n  z?: number;\n\n  glTarget: GLTextureTarget;\n  glInternalFormat: GL;\n  glFormat: GL;\n  glType: GL;\n  compressed?: boolean;\n  byteOffset?: number;\n  byteLength?: number;\n};\n\n/**\n * Initializes a texture memory space\n * Clear all the textures and mip levels of a two-dimensional or array texture at the same time.\n * On some implementations faster than repeatedly setting levels\n *\n * @note From WebGL 2 spec section 3.7.6:\n * @see https://registry.khronos.org/webgl/specs/latest/2.0/\n * - The image contents are set as if a buffer of sufficient size initialized to 0 would be passed to each level's texImage2D/3D\n * - texStorage2D should be considered a preferred alternative to texImage2D. It may have lower memory costs than texImage2D in some implementations.\n * - Once texStorage*D has been called, the texture is immutable and can only be updated with texSubImage*(), not texImage()\n */\nexport function initializeTextureStorage(\n  gl: WebGL2RenderingContext,\n  levels: number,\n  options: WebGLSetTextureOptions\n): void {\n  const {dimension, width, height, depth = 0} = options;\n  const {glInternalFormat} = options;\n  const glTarget = options.glTarget; // getWebGLCubeFaceTarget(options.glTarget, dimension, depth);\n  switch (dimension) {\n    case '2d-array':\n    case '3d':\n      gl.texStorage3D(glTarget, levels, glInternalFormat, width, height, depth);\n      break;\n\n    default:\n      gl.texStorage2D(glTarget, levels, glInternalFormat, width, height);\n  }\n}\n\n/**\n * Copy a region of compressed data from a GPU memory buffer into this texture.\n */\nexport function copyExternalImageToMipLevel(\n  gl: WebGL2RenderingContext,\n  handle: WebGLTexture,\n  image: ExternalImage,\n  options: WebGLCopyTextureOptions & {flipY?: boolean}\n): void {\n  const {width, height} = options;\n  const {dimension, depth = 0, mipLevel = 0} = options;\n  const {x = 0, y = 0, z = 0} = options;\n  const {glFormat, glType} = options;\n\n  const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);\n\n  const glParameters = options.flipY ? {[GL.UNPACK_FLIP_Y_WEBGL]: true} : {};\n  withGLParameters(gl, glParameters, () => {\n    switch (dimension) {\n      case '2d-array':\n      case '3d':\n        gl.bindTexture(glTarget, handle);\n        // prettier-ignore\n        gl.texSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, glType, image);\n        gl.bindTexture(glTarget, null);\n        break;\n\n      case '2d':\n      case 'cube':\n        gl.bindTexture(glTarget, handle);\n        // prettier-ignore\n        gl.texSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, glType, image);\n        gl.bindTexture(glTarget, null);\n        break;\n\n      default:\n        throw new Error(dimension);\n    }\n  });\n}\n\n/**\n * Copy a region of data from a CPU memory buffer into this texture.\n */\nexport function copyCPUDataToMipLevel(\n  gl: WebGL2RenderingContext,\n  typedArray: TypedArray,\n  options: WebGLCopyTextureOptions\n): void {\n  const {dimension, width, height, depth = 0, mipLevel = 0, byteOffset = 0} = options;\n  const {x = 0, y = 0, z = 0} = options;\n  const {glFormat, glType, compressed} = options;\n  const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);\n\n  // gl.bindTexture(glTarget, null);\n\n  switch (dimension) {\n    case '2d-array':\n    case '3d':\n      if (compressed) {\n        // prettier-ignore\n        gl.compressedTexSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, typedArray, byteOffset); // , byteLength\n      } else {\n        // prettier-ignore\n        gl.texSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, glType, typedArray, byteOffset); // , byteLength\n      }\n      break;\n\n    case '2d':\n    case 'cube':\n      if (compressed) {\n        // prettier-ignore\n        gl.compressedTexSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, typedArray, byteOffset); // , byteLength\n      } else {\n        // prettier-ignore\n        gl.texSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, glType, typedArray, byteOffset); // , byteLength\n      }\n      break;\n\n    default:\n      throw new Error(dimension);\n  }\n}\n\n/**\n * Copy a region of compressed data from a GPU memory buffer into this texture.\n */\nexport function copyGPUBufferToMipLevel(\n  gl: WebGL2RenderingContext,\n  webglBuffer: WebGLBuffer,\n  byteLength: number,\n  options: WebGLCopyTextureOptions\n): void {\n  const {dimension, width, height, depth = 0, mipLevel = 0, byteOffset = 0} = options;\n  const {x = 0, y = 0, z = 0} = options;\n  const {glFormat, glType, compressed} = options;\n  const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);\n\n  gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, webglBuffer);\n\n  switch (dimension) {\n    case '2d-array':\n    case '3d':\n      // 3 dimensional textures requires 3D texture functions\n      if (compressed) {\n        // TODO enable extension?\n        // prettier-ignore\n        gl.compressedTexSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, byteLength, byteOffset);\n      } else {\n        // prettier-ignore\n        gl.texSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, glType, byteOffset);\n      }\n      break;\n\n    case '2d':\n    case 'cube':\n      if (compressed) {\n        // prettier-ignore\n        gl.compressedTexSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, byteLength, byteOffset);\n      } else {\n        // prettier-ignore\n        gl.texSubImage2D(glTarget, mipLevel, x, y, width, height, BORDER, glFormat, byteOffset);\n      }\n      break;\n\n    default:\n      throw new Error(dimension);\n  }\n}\n\n// INTERNAL HELPERS\n\n/** Convert a WebGPU style texture constant to a WebGL style texture constant */\nexport function getWebGLTextureTarget(\n  dimension: '1d' | '2d' | '2d-array' | 'cube' | 'cube-array' | '3d'\n): GLTextureTarget {\n  // prettier-ignore\n  switch (dimension) {\n    case '1d': break; // not supported in any WebGL version\n    case '2d': return GL.TEXTURE_2D; // supported in WebGL1\n    case '3d': return GL.TEXTURE_3D; // supported in WebGL2\n    case 'cube': return GL.TEXTURE_CUBE_MAP; // supported in WebGL1\n    case '2d-array': return GL.TEXTURE_2D_ARRAY; // supported in WebGL2\n    case 'cube-array': break; // not supported in any WebGL version\n  }\n  throw new Error(dimension);\n}\n\n/**\n * In WebGL, cube maps specify faces by overriding target instead of using the depth parameter.\n * @note We still bind the texture using GL.TEXTURE_CUBE_MAP, but we need to use the face-specific target when setting mip levels.\n * @returns glTarget unchanged, if dimension !== 'cube'.\n */\nexport function getWebGLCubeFaceTarget(\n  glTarget: GLTextureTarget,\n  dimension: '1d' | '2d' | '2d-array' | 'cube' | 'cube-array' | '3d',\n  level: number\n): GLTextureTarget | GLTextureCubeMapTarget {\n  return dimension === 'cube' ? GL.TEXTURE_CUBE_MAP_POSITIVE_X + level : glTarget;\n}\n\n// texImage methods\n\n/**\n * Clear a texture mip level.\n * Wrapper for the messy WebGL texture API\n *\nexport function clearMipLevel(gl: WebGL2RenderingContext, options: WebGLSetTextureOptions): void {\n  const {dimension, width, height, depth = 0, mipLevel = 0} = options;\n  const {glInternalFormat, glFormat, glType, compressed} = options;\n  const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);\n\n  switch (dimension) {\n    case '2d-array':\n    case '3d':\n      if (compressed) {\n        // prettier-ignore\n        gl.compressedTexImage3D(glTarget, mipLevel, glInternalFormat, width, height, depth, BORDER, null);\n      } else {\n        // prettier-ignore\n        gl.texImage3D( glTarget, mipLevel, glInternalFormat, width, height, depth, BORDER, glFormat, glType, null);\n      }\n      break;\n\n    case '2d':\n    case 'cube':\n      if (compressed) {\n        // prettier-ignore\n        gl.compressedTexImage2D(glTarget, mipLevel, glInternalFormat, width, height, BORDER, null);\n      } else {\n        // prettier-ignore\n        gl.texImage2D(glTarget, mipLevel, glInternalFormat, width, height, BORDER, glFormat, glType, null);\n      }\n      break;\n\n    default:\n      throw new Error(dimension);\n  }\n}\n  */\n\n/**\n * Set a texture mip level to the contents of an external image.\n * Wrapper for the messy WebGL texture API\n * @note Corresponds to WebGPU device.queue.copyExternalImageToTexture()\n *\nexport function setMipLevelFromExternalImage(\n  gl: WebGL2RenderingContext,\n  image: ExternalImage,\n  options: WebGLSetTextureOptions\n): void {\n  const {dimension, width, height, depth = 0, level = 0} = options;\n  const {glInternalFormat, glType} = options;\n\n  const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);\n\n  // TODO - we can't change texture width (due to WebGPU limitations) -\n  // and the width/heigh of an external image is implicit, so why do we need to extract it?\n  // So what width height do we supply? The image size or the texture size?\n  // const {width, height} = Texture.getExternalImageSize(image);\n\n  switch (dimension) {\n    case '2d-array':\n    case '3d':\n      // prettier-ignore\n      gl.texImage3D(glTarget, level, glInternalFormat, width, height, depth, BORDER, glInternalFormat, glType, image);\n      break;\n\n    case '2d':\n    case 'cube':\n      // prettier-ignore\n      gl.texImage2D(glTarget, level, glInternalFormat, width, height, BORDER, glInternalFormat, glType, image);\n      break;\n\n    default:\n      throw new Error(dimension);\n  }\n}\n\n/**\n * Set a texture mip level from CPU memory\n * Wrapper for the messy WebGL texture API\n * @note Not available (directly) in WebGPU\n *\nexport function setMipLevelFromTypedArray(\n  gl: WebGL2RenderingContext,\n  data: TypedArray,\n  parameters: {},\n  options: {\n    dimension: '1d' | '2d' | '2d-array' | 'cube' | 'cube-array' | '3d';\n    height: number;\n    width: number;\n    depth?: number;\n    level?: number;\n    offset?: number;\n    glTarget: GLTextureTarget;\n    glInternalFormat: GL;\n    glFormat: GL;\n    glType: GL;\n    compressed?: boolean;\n  }\n): void {\n  const {dimension, width, height, depth = 0, level = 0, offset = 0} = options;\n  const {glInternalFormat, glFormat, glType, compressed} = options;\n\n  const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);\n\n  withGLParameters(gl, parameters, () => {\n    switch (dimension) {\n      case '2d-array':\n      case '3d':\n        if (compressed) {\n          // prettier-ignore\n          gl.compressedTexImage3D(glTarget, level, glInternalFormat, width, height, depth, BORDER, data);\n        } else {\n          // prettier-ignore\n          gl.texImage3D( glTarget, level, glInternalFormat, width, height, depth, BORDER, glFormat, glType, data);\n        }\n        break;\n\n      case '2d':\n        if (compressed) {\n          // prettier-ignore\n          gl.compressedTexImage2D(glTarget, level, glInternalFormat, width, height, BORDER, data);\n        } else {\n          // prettier-ignore\n          gl.texImage2D( glTarget, level, glInternalFormat, width, height, BORDER, glFormat, glType, data, offset);\n        }\n        break;\n\n      default:\n        throw new Error(dimension);\n    }\n  });\n}\n\n/**\n   * Set a texture level from CPU memory\n   * @note Not available (directly) in WebGPU\n  _setMipLevelFromTypedArray(\n    depth: number,\n    level: number,\n    data: TextureLevelData,\n    offset = 0,\n    parameters\n  ): void {\n    withGLParameters(this.gl, parameters, () => {\n      switch (this.props.dimension) {\n        case '2d-array':\n        case '3d':\n          if (this.compressed) {\n            // prettier-ignore\n            this.device.gl.compressedTexImage3D(this.glTarget, level, this.glInternalFormat, data.width, data.height, depth, BORDER, data.data);\n          } else {\n            // prettier-ignore\n            this.gl.texImage3D( this.glTarget, level, this.glInternalFormat, this.width, this.height, depth, BORDER, this.glFormat, this.glType, data.data);\n          }\n          break;\n\n        case '2d':\n          if (this.compressed) {\n            // prettier-ignore\n            this.device.gl.compressedTexImage2D(this.glTarget, level, this.glInternalFormat, data.width, data.height, BORDER, data.data);\n          } else {\n            // prettier-ignore\n            this.device.gl.texImage2D( this.glTarget, level, this.glInternalFormat, this.width, this.height, BORDER, this.glFormat, this.glType, data.data, offset);\n          }\n          break;\n\n        default:\n          throw new Error(this.props.dimension);\n      }\n    });\n  }\n\n * Set a texture level from a GPU buffer\n *\nexport function setMipLevelFromGPUBuffer(\n  gl: WebGL2RenderingContext,\n  buffer: Buffer,\n  options: WebGLSetTextureOptions\n): void {\n  const {dimension, width, height, depth = 0, level = 0, byteOffset = 0} = options;\n  const {glInternalFormat, glFormat, glType, compressed} = options;\n  const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);\n\n  const webglBuffer = buffer as WEBGLBuffer;\n  const imageSize = buffer.byteLength;\n\n  // In WebGL the source buffer is not a parameter. Instead it needs to be bound to a special bind point\n  gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, webglBuffer.handle);\n\n  switch (dimension) {\n    case '2d-array':\n    case '3d':\n      if (compressed) {\n        // prettier-ignore\n        gl.compressedTexImage3D(glTarget, level, glInternalFormat, width, height, depth, BORDER, imageSize, byteOffset);\n      } else {\n        // prettier-ignore\n        gl.texImage3D(glTarget, level, glInternalFormat, width, height, depth, BORDER, glFormat, glType, byteOffset);\n      }\n      break;\n\n    case '2d':\n      if (compressed) {\n        // prettier-ignore\n        gl.compressedTexImage2D(glTarget, level, glInternalFormat, width, height, BORDER, imageSize, byteOffset);\n      } else {\n        // prettier-ignore\n        gl.texImage2D(glTarget, level, glInternalFormat, width, height, BORDER, glFormat, glType, byteOffset);\n      }\n      break;\n\n    default:\n      throw new Error(dimension);\n  }\n\n  gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, null);\n}\n*/\nexport type ReadPixelsToArrayOptions = {\n  sourceX?: number;\n  sourceY?: number;\n  sourceFormat?: number;\n  sourceAttachment?: number;\n  target?: Uint8Array | Uint16Array | Float32Array;\n  // following parameters are auto deduced if not provided\n  sourceWidth?: number;\n  sourceHeight?: number;\n  sourceDepth?: number;\n  sourceType?: number;\n};\n\nexport type ReadPixelsToBufferOptions = {\n  sourceX?: number;\n  sourceY?: number;\n  sourceFormat?: number;\n  target?: Buffer; // A new Buffer object is created when not provided.\n  targetByteOffset?: number; // byte offset in buffer object\n  // following parameters are auto deduced if not provided\n  sourceWidth?: number;\n  sourceHeight?: number;\n  sourceType?: number;\n};\n\n/**\n * Copies data from a type  or a Texture object into ArrayBuffer object.\n * App can provide targetPixelArray or have it auto allocated by this method\n *  newly allocated by this method unless provided by app.\n * @deprecated Use CommandEncoder.copyTextureToBuffer and Buffer.read\n * @note Slow requires roundtrip to GPU\n *\n * @param source\n * @param options\n * @returns pixel array,\n */\nexport function readPixelsToArray(\n  source: Framebuffer | Texture,\n  options?: ReadPixelsToArrayOptions\n): Uint8Array | Uint16Array | Float32Array {\n  const {\n    sourceX = 0,\n    sourceY = 0,\n    sourceAttachment = 0 // TODO - support gl.readBuffer\n  } = options || {};\n  let {\n    target = null,\n    // following parameters are auto deduced if not provided\n    sourceWidth,\n    sourceHeight,\n    sourceDepth,\n    sourceFormat,\n    sourceType\n  } = options || {};\n\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  // assert(framebuffer);\n  const {gl, handle} = framebuffer;\n\n  sourceWidth ||= framebuffer.width;\n  sourceHeight ||= framebuffer.height;\n\n  const texture = framebuffer.colorAttachments[sourceAttachment]?.texture;\n  if (!texture) {\n    throw new Error(`Invalid framebuffer attachment ${sourceAttachment}`);\n  }\n  sourceDepth = texture?.depth || 1;\n\n  sourceFormat ||= texture?.glFormat || GL.RGBA;\n  // Deduce the type from color attachment if not provided.\n  sourceType ||= texture?.glType || GL.UNSIGNED_BYTE;\n\n  // Deduce type and allocated pixelArray if needed\n  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight, sourceDepth);\n\n  // Pixel array available, if necessary, deduce type from it.\n  sourceType = sourceType || getGLTypeFromTypedArray(target);\n\n  // Note: luma.gl overrides bindFramebuffer so that we can reliably restore the previous framebuffer (this is the only function for which we do that)\n  const prevHandle = gl.bindFramebuffer(\n    GL.FRAMEBUFFER,\n    handle\n  ) as unknown as WebGLFramebuffer | null;\n\n  // Select the color attachment to read from\n  gl.readBuffer(gl.COLOR_ATTACHMENT0 + sourceAttachment);\n\n  // There is a lot of hedging in the WebGL2 spec about what formats are guaranteed to be readable\n  // (It should always be possible to read RGBA/UNSIGNED_BYTE, but most other combinations are not guaranteed)\n  // Querying is possible but expensive:\n  // const {device} = framebuffer;\n  // texture.glReadFormat ||= gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT);\n  // texture.glReadType ||= gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE);\n  // console.log('params', device.getGLKey(texture.glReadFormat), device.getGLKey(texture.glReadType));\n\n  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);\n  gl.readBuffer(gl.COLOR_ATTACHMENT0);\n  gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n\n  if (deleteFramebuffer) {\n    framebuffer.destroy();\n  }\n\n  return target;\n}\n\n/**\n * Copies data from a Framebuffer or a Texture object into a Buffer object.\n * NOTE: doesn't wait for copy to be complete, it programs GPU to perform a DMA transffer.\n * @deprecated Use CommandEncoder\n * @param source\n * @param options\n */\nexport function readPixelsToBuffer(\n  source: Framebuffer | Texture,\n  options?: ReadPixelsToBufferOptions\n): WEBGLBuffer {\n  const {\n    target,\n    sourceX = 0,\n    sourceY = 0,\n    sourceFormat = GL.RGBA,\n    targetByteOffset = 0\n  } = options || {};\n  // following parameters are auto deduced if not provided\n  let {sourceWidth, sourceHeight, sourceType} = options || {};\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  // assert(framebuffer);\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n\n  // Asynchronous read (PIXEL_PACK_BUFFER) is WebGL2 only feature\n  const webglFramebuffer = framebuffer;\n\n  // deduce type if not available.\n  sourceType = sourceType || GL.UNSIGNED_BYTE;\n\n  let webglBufferTarget = target as unknown as WEBGLBuffer | undefined;\n  if (!webglBufferTarget) {\n    // Create new buffer with enough size\n    const components = glFormatToComponents(sourceFormat);\n    const byteCount = glTypeToBytes(sourceType);\n    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;\n    webglBufferTarget = webglFramebuffer.device.createBuffer({byteLength});\n  }\n\n  // TODO(donmccurdy): Do we have tests to confirm this is working?\n  const commandEncoder = source.device.createCommandEncoder();\n  commandEncoder.copyTextureToBuffer({\n    sourceTexture: source as Texture,\n    width: sourceWidth,\n    height: sourceHeight,\n    origin: [sourceX, sourceY],\n    destinationBuffer: webglBufferTarget,\n    byteOffset: targetByteOffset\n  });\n  commandEncoder.destroy();\n\n  if (deleteFramebuffer) {\n    framebuffer.destroy();\n  }\n\n  return webglBufferTarget;\n}\n\n/**\n * Copy a rectangle from a Framebuffer or Texture object into a texture (at an offset)\n * @deprecated Use CommandEncoder\n */\n// eslint-disable-next-line complexity, max-statements\nexport function copyToTexture(\n  sourceTexture: Framebuffer | Texture,\n  destinationTexture: Texture | GL,\n  options?: {\n    sourceX?: number;\n    sourceY?: number;\n\n    targetX?: number;\n    targetY?: number;\n    targetZ?: number;\n    targetMipmaplevel?: number;\n    targetInternalFormat?: number;\n\n    width?: number; // defaults to target width\n    height?: number; // defaults to target height\n  }\n): Texture {\n  const {\n    sourceX = 0,\n    sourceY = 0,\n    // attachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetMipmaplevel = 0,\n    targetInternalFormat = GL.RGBA\n  } = options || {};\n  let {\n    targetX,\n    targetY,\n    targetZ,\n    width, // defaults to target width\n    height // defaults to target height\n  } = options || {};\n\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(sourceTexture);\n  // assert(framebuffer);\n  const webglFramebuffer = framebuffer;\n  const {device, handle} = webglFramebuffer;\n  const isSubCopy =\n    typeof targetX !== 'undefined' ||\n    typeof targetY !== 'undefined' ||\n    typeof targetZ !== 'undefined';\n  targetX = targetX || 0;\n  targetY = targetY || 0;\n  targetZ = targetZ || 0;\n  const prevHandle = device.gl.bindFramebuffer(GL.FRAMEBUFFER, handle);\n  // TODO - support gl.readBuffer (WebGL2 only)\n  // const prevBuffer = gl.readBuffer(attachment);\n  // assert(target);\n  let texture: WEBGLTexture | null = null;\n  let textureTarget: GL;\n  if (destinationTexture instanceof WEBGLTexture) {\n    texture = destinationTexture;\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n    texture?.bind(0);\n    // @ts-ignore\n    textureTarget = texture.target;\n  } else {\n    // @ts-ignore\n    textureTarget = target;\n  }\n\n  if (!isSubCopy) {\n    device.gl.copyTexImage2D(\n      textureTarget,\n      targetMipmaplevel,\n      targetInternalFormat,\n      sourceX,\n      sourceY,\n      width,\n      height,\n      0 /* border must be 0 */\n    );\n  } else {\n    switch (textureTarget) {\n      case GL.TEXTURE_2D:\n      case GL.TEXTURE_CUBE_MAP:\n        device.gl.copyTexSubImage2D(\n          textureTarget,\n          targetMipmaplevel,\n          targetX,\n          targetY,\n          sourceX,\n          sourceY,\n          width,\n          height\n        );\n        break;\n      case GL.TEXTURE_2D_ARRAY:\n      case GL.TEXTURE_3D:\n        device.gl.copyTexSubImage3D(\n          textureTarget,\n          targetMipmaplevel,\n          targetX,\n          targetY,\n          targetZ,\n          sourceX,\n          sourceY,\n          width,\n          height\n        );\n        break;\n      default:\n    }\n  }\n  if (texture) {\n    texture.unbind();\n  }\n  // @ts-expect-error\n  device.gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.destroy();\n  }\n  return texture;\n}\n\nfunction getFramebuffer(source: Texture | Framebuffer): {\n  framebuffer: WEBGLFramebuffer;\n  deleteFramebuffer: boolean;\n} {\n  if (!(source instanceof Framebuffer)) {\n    return {framebuffer: toFramebuffer(source), deleteFramebuffer: true};\n  }\n  return {framebuffer: source as WEBGLFramebuffer, deleteFramebuffer: false};\n}\n\n/**\n * Wraps a given texture into a framebuffer object, that can be further used\n * to read data from the texture object.\n */\nexport function toFramebuffer(texture: Texture, props?: FramebufferProps): WEBGLFramebuffer {\n  const {device, width, height, id} = texture;\n  const framebuffer = device.createFramebuffer({\n    ...props,\n    id: `framebuffer-for-${id}`,\n    width,\n    height,\n    colorAttachments: [texture]\n  });\n  return framebuffer as WEBGLFramebuffer;\n}\n\n// eslint-disable-next-line max-params\nfunction getPixelArray(\n  pixelArray,\n  glType: GLDataType | GLPixelType,\n  glFormat: GL,\n  width: number,\n  height: number,\n  depth?: number\n): Uint8Array | Uint16Array | Float32Array {\n  if (pixelArray) {\n    return pixelArray;\n  }\n  // const formatInfo = decodeTextureFormat(format);\n  // Allocate pixel array if not already available, using supplied type\n  glType ||= GL.UNSIGNED_BYTE;\n  const ArrayType = getTypedArrayFromGLType(glType, {clamped: false});\n  const components = glFormatToComponents(glFormat);\n  // TODO - check for composite type (components = 1).\n  return new ArrayType(width * height * components) as Uint8Array | Uint16Array | Float32Array;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}