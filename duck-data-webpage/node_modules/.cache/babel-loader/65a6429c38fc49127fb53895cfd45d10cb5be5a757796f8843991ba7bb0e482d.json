{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { project } from '@deck.gl/core';\nconst uniformBlock = /* glsl */`\\\nuniform brushingUniforms {\n  bool enabled;\n  highp int target;\n  vec2 mousePos;\n  float radius;\n} brushing;\n`;\nconst vertex = /* glsl */`\n  in vec2 brushingTargets;\n\n  out float brushing_isVisible;\n\n  bool brushing_isPointInRange(vec2 position) {\n    if (!brushing.enabled) {\n      return true;\n    }\n    vec2 source_commonspace = project_position(position);\n    vec2 target_commonspace = project_position(brushing.mousePos);\n    float distance = length((target_commonspace - source_commonspace) / project.commonUnitsPerMeter.xy);\n\n    return distance <= brushing.radius;\n  }\n\n  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {\n    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);\n  }\n\n  void brushing_setVisible(bool visible) {\n    brushing_isVisible = float(visible);\n  }\n`;\nconst vs = `\n${uniformBlock}\n${vertex}\n`;\nconst fragment = /* glsl */`\n  in float brushing_isVisible;\n`;\nconst fs = `\n${uniformBlock}\n${fragment}\n`;\nconst TARGET = {\n  source: 0,\n  target: 1,\n  custom: 2,\n  source_target: 3\n};\nconst inject = {\n  'vs:DECKGL_FILTER_GL_POSITION': /* glsl */`\n    vec2 brushingTarget;\n    vec2 brushingSource;\n    if (brushing.target == 3) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n      brushingSource = geometry.worldPosition.xy;\n    } else if (brushing.target == 0) {\n      brushingTarget = geometry.worldPosition.xy;\n    } else if (brushing.target == 1) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n    } else {\n      brushingTarget = brushingTargets;\n    }\n    bool visible;\n    if (brushing.target == 3) {\n      visible = brushing_arePointsInRange(brushingSource, brushingTarget);\n    } else {\n      visible = brushing_isPointInRange(brushingTarget);\n    }\n    brushing_setVisible(visible);\n  `,\n  'fs:DECKGL_FILTER_COLOR': `\n    if (brushing.enabled && brushing_isVisible < 0.5) {\n      discard;\n    }\n  `\n};\nexport default {\n  name: 'brushing',\n  dependencies: [project],\n  vs,\n  fs,\n  inject,\n  getUniforms: opts => {\n    if (!opts || !('viewport' in opts)) {\n      return {};\n    }\n    const {\n      brushingEnabled = true,\n      brushingRadius = 10000,\n      brushingTarget = 'source',\n      mousePosition,\n      viewport\n    } = opts;\n    return {\n      enabled: Boolean(brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)),\n      radius: brushingRadius,\n      target: TARGET[brushingTarget] || 0,\n      mousePos: mousePosition ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y]) : [0, 0]\n    };\n  },\n  uniformTypes: {\n    enabled: 'i32',\n    target: 'i32',\n    mousePos: 'vec2<f32>',\n    radius: 'f32'\n  }\n};","map":{"version":3,"names":["project","uniformBlock","vertex","vs","fragment","fs","TARGET","source","target","custom","source_target","inject","name","dependencies","getUniforms","opts","brushingEnabled","brushingRadius","brushingTarget","mousePosition","viewport","enabled","Boolean","containsPixel","radius","mousePos","unproject","x","y","uniformTypes"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\extensions\\src\\brushing\\shader-module.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable camelcase */\nimport type {ShaderModule} from '@luma.gl/shadertools';\nimport {project} from '@deck.gl/core';\nimport type {Viewport} from '@deck.gl/core';\n\nimport type {BrushingExtensionProps} from './brushing-extension';\n\nexport type BrushingModuleProps = {\n  // From layer context\n  viewport: Viewport;\n  mousePosition?: {x: number; y: number};\n} & BrushingExtensionProps;\n\ntype BrushingModuleUniforms = {\n  enabled?: boolean;\n  target?: number;\n  mousePos?: [number, number];\n  radius?: number;\n};\n\nconst uniformBlock = /* glsl */ `\\\nuniform brushingUniforms {\n  bool enabled;\n  highp int target;\n  vec2 mousePos;\n  float radius;\n} brushing;\n`;\n\nconst vertex = /* glsl */ `\n  in vec2 brushingTargets;\n\n  out float brushing_isVisible;\n\n  bool brushing_isPointInRange(vec2 position) {\n    if (!brushing.enabled) {\n      return true;\n    }\n    vec2 source_commonspace = project_position(position);\n    vec2 target_commonspace = project_position(brushing.mousePos);\n    float distance = length((target_commonspace - source_commonspace) / project.commonUnitsPerMeter.xy);\n\n    return distance <= brushing.radius;\n  }\n\n  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {\n    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);\n  }\n\n  void brushing_setVisible(bool visible) {\n    brushing_isVisible = float(visible);\n  }\n`;\n\nconst vs = `\n${uniformBlock}\n${vertex}\n`;\n\nconst fragment = /* glsl */ `\n  in float brushing_isVisible;\n`;\n\nconst fs = `\n${uniformBlock}\n${fragment}\n`;\n\nconst TARGET = {\n  source: 0,\n  target: 1,\n  custom: 2,\n  source_target: 3\n};\n\nconst inject = {\n  'vs:DECKGL_FILTER_GL_POSITION': /* glsl */ `\n    vec2 brushingTarget;\n    vec2 brushingSource;\n    if (brushing.target == 3) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n      brushingSource = geometry.worldPosition.xy;\n    } else if (brushing.target == 0) {\n      brushingTarget = geometry.worldPosition.xy;\n    } else if (brushing.target == 1) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n    } else {\n      brushingTarget = brushingTargets;\n    }\n    bool visible;\n    if (brushing.target == 3) {\n      visible = brushing_arePointsInRange(brushingSource, brushingTarget);\n    } else {\n      visible = brushing_isPointInRange(brushingTarget);\n    }\n    brushing_setVisible(visible);\n  `,\n\n  'fs:DECKGL_FILTER_COLOR': `\n    if (brushing.enabled && brushing_isVisible < 0.5) {\n      discard;\n    }\n  `\n};\n\nexport default {\n  name: 'brushing',\n  dependencies: [project],\n  vs,\n  fs,\n  inject,\n  getUniforms: (opts?: BrushingModuleProps | {}): BrushingModuleUniforms => {\n    if (!opts || !('viewport' in opts)) {\n      return {};\n    }\n    const {\n      brushingEnabled = true,\n      brushingRadius = 10000,\n      brushingTarget = 'source',\n      mousePosition,\n      viewport\n    } = opts;\n    return {\n      enabled: Boolean(brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)),\n      radius: brushingRadius,\n      target: TARGET[brushingTarget] || 0,\n      mousePos: mousePosition\n        ? (viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y]) as [\n            number,\n            number\n          ])\n        : [0, 0]\n    };\n  },\n  uniformTypes: {\n    enabled: 'i32',\n    target: 'i32',\n    mousePos: 'vec2<f32>',\n    radius: 'f32'\n  }\n} as ShaderModule<BrushingModuleProps, BrushingModuleUniforms, {}>;\n"],"mappings":"AAAA;AACA;AACA;AAIA,SAAQA,OAAO,QAAO,eAAe;AAkBrC,MAAMC,YAAY,GAAG,UAAW;;;;;;;CAO/B;AAED,MAAMC,MAAM,GAAG,UAAW;;;;;;;;;;;;;;;;;;;;;;;CAuBzB;AAED,MAAMC,EAAE,GAAG;EACTF,YAAY;EACZC,MAAM;CACP;AAED,MAAME,QAAQ,GAAG,UAAW;;CAE3B;AAED,MAAMC,EAAE,GAAG;EACTJ,YAAY;EACZG,QAAQ;CACT;AAED,MAAME,MAAM,GAAG;EACbC,MAAM,EAAE,CAAC;EACTC,MAAM,EAAE,CAAC;EACTC,MAAM,EAAE,CAAC;EACTC,aAAa,EAAE;CAChB;AAED,MAAMC,MAAM,GAAG;EACb,8BAA8B,EAAE,UAAW;;;;;;;;;;;;;;;;;;;;GAoB1C;EAED,wBAAwB,EAAE;;;;;CAK3B;AAED,eAAe;EACbC,IAAI,EAAE,UAAU;EAChBC,YAAY,EAAE,CAACb,OAAO,CAAC;EACvBG,EAAE;EACFE,EAAE;EACFM,MAAM;EACNG,WAAW,EAAGC,IAA+B,IAA4B;IACvE,IAAI,CAACA,IAAI,IAAI,EAAE,UAAU,IAAIA,IAAI,CAAC,EAAE;MAClC,OAAO,EAAE;IACX;IACA,MAAM;MACJC,eAAe,GAAG,IAAI;MACtBC,cAAc,GAAG,KAAK;MACtBC,cAAc,GAAG,QAAQ;MACzBC,aAAa;MACbC;IAAQ,CACT,GAAGL,IAAI;IACR,OAAO;MACLM,OAAO,EAAEC,OAAO,CAACN,eAAe,IAAIG,aAAa,IAAIC,QAAQ,CAACG,aAAa,CAACJ,aAAa,CAAC,CAAC;MAC3FK,MAAM,EAAEP,cAAc;MACtBT,MAAM,EAAEF,MAAM,CAACY,cAAc,CAAC,IAAI,CAAC;MACnCO,QAAQ,EAAEN,aAAa,GAClBC,QAAQ,CAACM,SAAS,CAAC,CAACP,aAAa,CAACQ,CAAC,GAAGP,QAAQ,CAACO,CAAC,EAAER,aAAa,CAACS,CAAC,GAAGR,QAAQ,CAACQ,CAAC,CAAC,CAG9E,GACF,CAAC,CAAC,EAAE,CAAC;KACV;EACH,CAAC;EACDC,YAAY,EAAE;IACZR,OAAO,EAAE,KAAK;IACdb,MAAM,EAAE,KAAK;IACbiB,QAAQ,EAAE,WAAW;IACrBD,MAAM,EAAE;;CAEsD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}