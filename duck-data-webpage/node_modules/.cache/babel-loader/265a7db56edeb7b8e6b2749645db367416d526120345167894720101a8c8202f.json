{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nlet channelHandles = 1;\nlet animationHandles = 1;\nexport class Timeline {\n  time = 0;\n  channels = new Map();\n  animations = new Map();\n  playing = false;\n  lastEngineTime = -1;\n  constructor() {}\n  addChannel(props) {\n    const {\n      delay = 0,\n      duration = Number.POSITIVE_INFINITY,\n      rate = 1,\n      repeat = 1\n    } = props;\n    const channelId = channelHandles++;\n    const channel = {\n      time: 0,\n      delay,\n      duration,\n      rate,\n      repeat\n    };\n    this._setChannelTime(channel, this.time);\n    this.channels.set(channelId, channel);\n    return channelId;\n  }\n  removeChannel(channelId) {\n    this.channels.delete(channelId);\n    for (const [animationHandle, animation] of this.animations) {\n      if (animation.channel === channelId) {\n        this.detachAnimation(animationHandle);\n      }\n    }\n  }\n  isFinished(channelId) {\n    const channel = this.channels.get(channelId);\n    if (channel === undefined) {\n      return false;\n    }\n    return this.time >= channel.delay + channel.duration * channel.repeat;\n  }\n  getTime(channelId) {\n    if (channelId === undefined) {\n      return this.time;\n    }\n    const channel = this.channels.get(channelId);\n    if (channel === undefined) {\n      return -1;\n    }\n    return channel.time;\n  }\n  setTime(time) {\n    this.time = Math.max(0, time);\n    const channels = this.channels.values();\n    for (const channel of channels) {\n      this._setChannelTime(channel, this.time);\n    }\n    const animations = this.animations.values();\n    for (const animationData of animations) {\n      const {\n        animation,\n        channel\n      } = animationData;\n      animation.setTime(this.getTime(channel));\n    }\n  }\n  play() {\n    this.playing = true;\n  }\n  pause() {\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n  reset() {\n    this.setTime(0);\n  }\n  attachAnimation(animation, channelHandle) {\n    const animationHandle = animationHandles++;\n    this.animations.set(animationHandle, {\n      animation,\n      channel: channelHandle\n    });\n    animation.setTime(this.getTime(channelHandle));\n    return animationHandle;\n  }\n  detachAnimation(channelId) {\n    this.animations.delete(channelId);\n  }\n  update(engineTime) {\n    if (this.playing) {\n      if (this.lastEngineTime === -1) {\n        this.lastEngineTime = engineTime;\n      }\n      this.setTime(this.time + (engineTime - this.lastEngineTime));\n      this.lastEngineTime = engineTime;\n    }\n  }\n  _setChannelTime(channel, time) {\n    const offsetTime = time - channel.delay;\n    const totalDuration = channel.duration * channel.repeat;\n    // Note(Tarek): Don't loop on final repeat.\n    if (offsetTime >= totalDuration) {\n      channel.time = channel.duration * channel.rate;\n    } else {\n      channel.time = Math.max(0, offsetTime) % channel.duration;\n      channel.time *= channel.rate;\n    }\n  }\n}","map":{"version":3,"names":["channelHandles","animationHandles","Timeline","time","channels","Map","animations","playing","lastEngineTime","constructor","addChannel","props","delay","duration","Number","POSITIVE_INFINITY","rate","repeat","channelId","channel","_setChannelTime","set","removeChannel","delete","animationHandle","animation","detachAnimation","isFinished","get","undefined","getTime","setTime","Math","max","values","animationData","play","pause","reset","attachAnimation","channelHandle","update","engineTime","offsetTime","totalDuration"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\engine\\src\\animation\\timeline.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/**\n * Timeline channel properties\n * @param delay = 0;\n * @param duration = Number.POSITIVE_INFINITY;\n * @param rate = 1\n * @param repeat = 1\n */\nexport type ChannelOptions = {\n  delay?: number;\n  duration?: number;\n  rate?: number;\n  repeat?: number;\n};\n\nexport type AnimationOptions = {\n  setTime: (time: number) => void;\n};\n\ntype Channel = {\n  time: number;\n  delay: number;\n  duration: number;\n  rate: number;\n  repeat: number;\n};\n\ntype Animation = {\n  channel?: number;\n  animation: {\n    setTime: (time: number) => void;\n  };\n};\n\nlet channelHandles = 1;\nlet animationHandles = 1;\n\nexport class Timeline {\n  time: number = 0;\n  channels = new Map<number, Channel>();\n  animations = new Map<number, Animation>();\n  playing: boolean = false;\n  lastEngineTime: number = -1;\n\n  constructor() {}\n\n  addChannel(props: ChannelOptions): number {\n    const {delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1} = props;\n\n    const channelId = channelHandles++;\n    const channel: Channel = {\n      time: 0,\n      delay,\n      duration,\n      rate,\n      repeat\n    };\n    this._setChannelTime(channel, this.time);\n    this.channels.set(channelId, channel);\n\n    return channelId;\n  }\n\n  removeChannel(channelId: number): void {\n    this.channels.delete(channelId);\n\n    for (const [animationHandle, animation] of this.animations) {\n      if (animation.channel === channelId) {\n        this.detachAnimation(animationHandle);\n      }\n    }\n  }\n\n  isFinished(channelId: number): boolean {\n    const channel = this.channels.get(channelId);\n    if (channel === undefined) {\n      return false;\n    }\n\n    return this.time >= channel.delay + channel.duration * channel.repeat;\n  }\n\n  getTime(channelId?: number): number {\n    if (channelId === undefined) {\n      return this.time;\n    }\n\n    const channel = this.channels.get(channelId);\n\n    if (channel === undefined) {\n      return -1;\n    }\n\n    return channel.time;\n  }\n\n  setTime(time: number): void {\n    this.time = Math.max(0, time);\n\n    const channels = this.channels.values();\n    for (const channel of channels) {\n      this._setChannelTime(channel, this.time);\n    }\n\n    const animations = this.animations.values();\n    for (const animationData of animations) {\n      const {animation, channel} = animationData;\n      animation.setTime(this.getTime(channel));\n    }\n  }\n\n  play(): void {\n    this.playing = true;\n  }\n\n  pause(): void {\n    this.playing = false;\n    this.lastEngineTime = -1;\n  }\n\n  reset(): void {\n    this.setTime(0);\n  }\n\n  attachAnimation(animation: AnimationOptions, channelHandle?: number): number {\n    const animationHandle = animationHandles++;\n\n    this.animations.set(animationHandle, {\n      animation,\n      channel: channelHandle\n    });\n\n    animation.setTime(this.getTime(channelHandle));\n\n    return animationHandle;\n  }\n\n  detachAnimation(channelId: number): void {\n    this.animations.delete(channelId);\n  }\n\n  update(engineTime: number): void {\n    if (this.playing) {\n      if (this.lastEngineTime === -1) {\n        this.lastEngineTime = engineTime;\n      }\n      this.setTime(this.time + (engineTime - this.lastEngineTime));\n      this.lastEngineTime = engineTime;\n    }\n  }\n\n  _setChannelTime(channel: Channel, time: number): void {\n    const offsetTime = time - channel.delay;\n    const totalDuration = channel.duration * channel.repeat;\n    // Note(Tarek): Don't loop on final repeat.\n    if (offsetTime >= totalDuration) {\n      channel.time = channel.duration * channel.rate;\n    } else {\n      channel.time = Math.max(0, offsetTime) % channel.duration;\n      channel.time *= channel.rate;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}