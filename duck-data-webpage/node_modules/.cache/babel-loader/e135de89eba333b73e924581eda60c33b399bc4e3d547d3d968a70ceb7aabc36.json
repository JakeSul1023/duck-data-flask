{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@luma.gl/core';\n// import type {ShaderUniformType, UniformValue, UniformFormat, UniformInfoDevice, Texture, Sampler} from '@luma.gl/core';\nimport { getShaderModuleDependencies } from '@luma.gl/shadertools';\nimport { splitUniformsAndBindings } from \"./model/split-uniforms-and-bindings.js\";\n/**\n * ShaderInputs holds uniform and binding values for one or more shader modules,\n * - It can generate binary data for any uniform buffer\n * - It can manage a uniform buffer for each block\n * - It can update managed uniform buffers with a single call\n * - It performs some book keeping on what has changed to minimize unnecessary writes to uniform buffers.\n */\nexport class ShaderInputs {\n  options = {\n    disableWarnings: false\n  };\n  /**\n   * The map of modules\n   * @todo should should this include the resolved dependencies?\n   */\n  // @ts-ignore Fix typings\n  modules;\n  /** Stores the uniform values for each module */\n  moduleUniforms;\n  /** Stores the uniform bindings for each module  */\n  moduleBindings;\n  /** Tracks if uniforms have changed */\n  // moduleUniformsChanged: Record<keyof ShaderPropsT, false | string>;\n  /**\n   * Create a new UniformStore instance\n   * @param modules\n   */\n  constructor(\n  // @ts-ignore Fix typings\n  modules, options) {\n    Object.assign(this.options, options);\n    // Extract modules with dependencies\n    const resolvedModules = getShaderModuleDependencies(Object.values(modules).filter(module => module.dependencies));\n    for (const resolvedModule of resolvedModules) {\n      // @ts-ignore\n      modules[resolvedModule.name] = resolvedModule;\n    }\n    log.log(1, 'Creating ShaderInputs with modules', Object.keys(modules))();\n    // Store the module definitions and create storage for uniform values and binding values, per module\n    // @ts-ignore Fix typings\n    this.modules = modules;\n    this.moduleUniforms = {};\n    this.moduleBindings = {};\n    // Initialize the modules\n    for (const [name, module] of Object.entries(modules)) {\n      this._addModule(module);\n      if (module.name && name !== module.name && !this.options.disableWarnings) {\n        log.warn(`Module name: ${name} vs ${module.name}`)();\n      }\n    }\n  }\n  /** Destroy */\n  destroy() {}\n  /**\n   * Set module props\n   */\n  setProps(props) {\n    for (const name of Object.keys(props)) {\n      const moduleName = name;\n      const moduleProps = props[moduleName] || {};\n      const module = this.modules[moduleName];\n      if (!module) {\n        // Ignore props for unregistered modules\n        if (!this.options.disableWarnings) {\n          log.warn(`Module ${name} not found`)();\n        }\n        continue; // eslint-disable-line no-continue\n      }\n      const oldUniforms = this.moduleUniforms[moduleName];\n      const oldBindings = this.moduleBindings[moduleName];\n      const uniformsAndBindings = module.getUniforms?.(moduleProps, oldUniforms) || moduleProps;\n      const {\n        uniforms,\n        bindings\n      } = splitUniformsAndBindings(uniformsAndBindings);\n      this.moduleUniforms[moduleName] = {\n        ...oldUniforms,\n        ...uniforms\n      };\n      this.moduleBindings[moduleName] = {\n        ...oldBindings,\n        ...bindings\n      };\n      // this.moduleUniformsChanged ||= moduleName;\n      // console.log(`setProps(${String(moduleName)}`, moduleName, this.moduleUniforms[moduleName])\n    }\n  }\n  /**\n   * Return the map of modules\n   * @todo should should this include the resolved dependencies?\n   */\n  getModules() {\n    return Object.values(this.modules);\n  }\n  /** Get all uniform values for all modules */\n  getUniformValues() {\n    return this.moduleUniforms;\n  }\n  /** Merges all bindings for the shader (from the various modules) */\n  getBindingValues() {\n    const bindings = {};\n    for (const moduleBindings of Object.values(this.moduleBindings)) {\n      Object.assign(bindings, moduleBindings);\n    }\n    return bindings;\n  }\n  // INTERNAL\n  /** Return a debug table that can be used for console.table() or log.table() */\n  getDebugTable() {\n    const table = {};\n    for (const [moduleName, module] of Object.entries(this.moduleUniforms)) {\n      for (const [key, value] of Object.entries(module)) {\n        table[`${moduleName}.${key}`] = {\n          type: this.modules[moduleName].uniformTypes?.[key],\n          value: String(value)\n        };\n      }\n    }\n    return table;\n  }\n  _addModule(module) {\n    const moduleName = module.name;\n    // Get default uniforms from module\n    this.moduleUniforms[moduleName] = module.defaultUniforms || {};\n    this.moduleBindings[moduleName] = {};\n  }\n}\n//# sourceMappingURL=shader-inputs.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}