{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Shader } from '@luma.gl/core';\n/** Manages a cached pool of Shaders for reuse. */\nexport class ShaderFactory {\n  static defaultProps = {\n    ...Shader.defaultProps\n  };\n  /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */\n  static getDefaultShaderFactory(device) {\n    device._lumaData.defaultShaderFactory ||= new ShaderFactory(device);\n    return device._lumaData.defaultShaderFactory;\n  }\n  device;\n  destroyPolicy;\n  _cache = {};\n  /** @internal */\n  constructor(device) {\n    this.device = device;\n    this.destroyPolicy = device.props._factoryDestroyPolicy;\n  }\n  /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */\n  createShader(props) {\n    const key = this._hashShader(props);\n    let cacheEntry = this._cache[key];\n    if (!cacheEntry) {\n      const shader = this.device.createShader({\n        ...props,\n        id: props.id ? `${props.id}-cached` : undefined\n      });\n      this._cache[key] = cacheEntry = {\n        shader,\n        useCount: 0\n      };\n    }\n    cacheEntry.useCount++;\n    return cacheEntry.shader;\n  }\n  /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */\n  release(shader) {\n    const key = this._hashShader(shader);\n    const cacheEntry = this._cache[key];\n    if (cacheEntry) {\n      cacheEntry.useCount--;\n      if (cacheEntry.useCount === 0) {\n        if (this.destroyPolicy === 'unused') {\n          delete this._cache[key];\n          cacheEntry.shader.destroy();\n        }\n      }\n    }\n  }\n  // PRIVATE\n  _hashShader(value) {\n    return `${value.stage}:${value.source}`;\n  }\n}","map":{"version":3,"names":["Shader","ShaderFactory","defaultProps","getDefaultShaderFactory","device","_lumaData","defaultShaderFactory","destroyPolicy","_cache","constructor","props","_factoryDestroyPolicy","createShader","key","_hashShader","cacheEntry","shader","id","undefined","useCount","release","destroy","value","stage","source"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\engine\\src\\factories\\shader-factory.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, Shader, ShaderProps} from '@luma.gl/core';\n\n/** Manages a cached pool of Shaders for reuse. */\nexport class ShaderFactory {\n  static readonly defaultProps: Required<ShaderProps> = {...Shader.defaultProps};\n\n  /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */\n  static getDefaultShaderFactory(device: Device): ShaderFactory {\n    device._lumaData.defaultShaderFactory ||= new ShaderFactory(device);\n    return device._lumaData.defaultShaderFactory as ShaderFactory;\n  }\n\n  public readonly device: Device;\n  readonly destroyPolicy: 'unused' | 'never';\n  private readonly _cache: Record<string, {shader: Shader; useCount: number}> = {};\n\n  /** @internal */\n  constructor(device: Device) {\n    this.device = device;\n    this.destroyPolicy = device.props._factoryDestroyPolicy;\n  }\n\n  /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */\n  createShader(props: ShaderProps): Shader {\n    const key = this._hashShader(props);\n\n    let cacheEntry = this._cache[key];\n    if (!cacheEntry) {\n      const shader = this.device.createShader({\n        ...props,\n        id: props.id ? `${props.id}-cached` : undefined\n      });\n      this._cache[key] = cacheEntry = {shader, useCount: 0};\n    }\n\n    cacheEntry.useCount++;\n    return cacheEntry.shader;\n  }\n\n  /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */\n  release(shader: Shader): void {\n    const key = this._hashShader(shader);\n    const cacheEntry = this._cache[key];\n    if (cacheEntry) {\n      cacheEntry.useCount--;\n      if (cacheEntry.useCount === 0) {\n        if (this.destroyPolicy === 'unused') {\n          delete this._cache[key];\n          cacheEntry.shader.destroy();\n        }\n      }\n    }\n  }\n\n  // PRIVATE\n\n  private _hashShader(value: Shader | ShaderProps): string {\n    return `${value.stage}:${value.source}`;\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA,SAAgBA,MAAM,QAAoB,eAAe;AAEzD;AACA,OAAM,MAAOC,aAAa;EACxB,OAAgBC,YAAY,GAA0B;IAAC,GAAGF,MAAM,CAACE;EAAY,CAAC;EAE9E;EACA,OAAOC,uBAAuBA,CAACC,MAAc;IAC3CA,MAAM,CAACC,SAAS,CAACC,oBAAoB,KAAK,IAAIL,aAAa,CAACG,MAAM,CAAC;IACnE,OAAOA,MAAM,CAACC,SAAS,CAACC,oBAAqC;EAC/D;EAEgBF,MAAM;EACbG,aAAa;EACLC,MAAM,GAAuD,EAAE;EAEhF;EACAC,YAAYL,MAAc;IACxB,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACG,aAAa,GAAGH,MAAM,CAACM,KAAK,CAACC,qBAAqB;EACzD;EAEA;EACAC,YAAYA,CAACF,KAAkB;IAC7B,MAAMG,GAAG,GAAG,IAAI,CAACC,WAAW,CAACJ,KAAK,CAAC;IAEnC,IAAIK,UAAU,GAAG,IAAI,CAACP,MAAM,CAACK,GAAG,CAAC;IACjC,IAAI,CAACE,UAAU,EAAE;MACf,MAAMC,MAAM,GAAG,IAAI,CAACZ,MAAM,CAACQ,YAAY,CAAC;QACtC,GAAGF,KAAK;QACRO,EAAE,EAAEP,KAAK,CAACO,EAAE,GAAG,GAAGP,KAAK,CAACO,EAAE,SAAS,GAAGC;OACvC,CAAC;MACF,IAAI,CAACV,MAAM,CAACK,GAAG,CAAC,GAAGE,UAAU,GAAG;QAACC,MAAM;QAAEG,QAAQ,EAAE;MAAC,CAAC;IACvD;IAEAJ,UAAU,CAACI,QAAQ,EAAE;IACrB,OAAOJ,UAAU,CAACC,MAAM;EAC1B;EAEA;EACAI,OAAOA,CAACJ,MAAc;IACpB,MAAMH,GAAG,GAAG,IAAI,CAACC,WAAW,CAACE,MAAM,CAAC;IACpC,MAAMD,UAAU,GAAG,IAAI,CAACP,MAAM,CAACK,GAAG,CAAC;IACnC,IAAIE,UAAU,EAAE;MACdA,UAAU,CAACI,QAAQ,EAAE;MACrB,IAAIJ,UAAU,CAACI,QAAQ,KAAK,CAAC,EAAE;QAC7B,IAAI,IAAI,CAACZ,aAAa,KAAK,QAAQ,EAAE;UACnC,OAAO,IAAI,CAACC,MAAM,CAACK,GAAG,CAAC;UACvBE,UAAU,CAACC,MAAM,CAACK,OAAO,EAAE;QAC7B;MACF;IACF;EACF;EAEA;EAEQP,WAAWA,CAACQ,KAA2B;IAC7C,OAAO,GAAGA,KAAK,CAACC,KAAK,IAAID,KAAK,CAACE,MAAM,EAAE;EACzC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}