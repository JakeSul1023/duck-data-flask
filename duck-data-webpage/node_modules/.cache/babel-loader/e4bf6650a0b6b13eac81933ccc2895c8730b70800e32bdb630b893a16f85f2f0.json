{"ast":null,"code":"// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n/* eslint-disable */\nimport { Quaternion, Vector3, Matrix3, Matrix4, degrees } from '@math.gl/core';\nimport { BoundingSphere, OrientedBoundingBox } from '@math.gl/culling';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { assert } from '@loaders.gl/loader-utils';\n// const scratchProjectedBoundingSphere = new BoundingSphere();\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n// const scratchMatrix = new Matrix3();\nconst scratchPoint = new Vector3();\nconst scratchScale = new Vector3();\nconst scratchNorthWest = new Vector3();\nconst scratchSouthEast = new Vector3();\nconst scratchCenter = new Vector3();\nconst scratchXAxis = new Vector3();\nconst scratchYAxis = new Vector3();\nconst scratchZAxis = new Vector3();\n// const scratchRectangle = new Rectangle();\n// const scratchOrientedBoundingBox = new OrientedBoundingBox();\n// const scratchTransform = new Matrix4();\n/**\n * Create a bounding volume from the tile's bounding volume header.\n * @param {Object} boundingVolumeHeader The tile's bounding volume header.\n * @param {Matrix4} transform The transform to apply to the bounding volume.\n * @param [result] The object onto which to store the result.\n * @returns The modified result parameter or a new TileBoundingVolume instance if none was provided.\n */\nexport function createBoundingVolume(boundingVolumeHeader, transform, result) {\n  assert(boundingVolumeHeader, '3D Tile: boundingVolume must be defined');\n  // boundingVolume schema:\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/schema/boundingVolume.schema.json\n  if (boundingVolumeHeader.box) {\n    return createBox(boundingVolumeHeader.box, transform, result);\n  }\n  if (boundingVolumeHeader.region) {\n    return createObbFromRegion(boundingVolumeHeader.region);\n  }\n  if (boundingVolumeHeader.sphere) {\n    return createSphere(boundingVolumeHeader.sphere, transform, result);\n  }\n  throw new Error('3D Tile: boundingVolume must contain a sphere, region, or box');\n}\n/**\n * Calculate the cartographic bounding box the tile's bounding volume.\n * @param {Object} boundingVolumeHeader The tile's bounding volume header.\n * @param {BoundingVolume} boundingVolume The bounding volume.\n * @returns {CartographicBounds}\n */\nexport function getCartographicBounds(boundingVolumeHeader, boundingVolume) {\n  // boundingVolume schema:\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/schema/boundingVolume.schema.json\n  if (boundingVolumeHeader.box) {\n    return orientedBoundingBoxToCartographicBounds(boundingVolume);\n  }\n  if (boundingVolumeHeader.region) {\n    // [west, south, east, north, minimum height, maximum height]\n    // Latitudes and longitudes are in the WGS 84 datum as defined in EPSG 4979 and are in radians.\n    // Heights are in meters above (or below) the WGS 84 ellipsoid.\n    const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;\n    return [[degrees(west), degrees(south), minHeight], [degrees(east), degrees(north), maxHeight]];\n  }\n  if (boundingVolumeHeader.sphere) {\n    return boundingSphereToCartographicBounds(boundingVolume);\n  }\n  throw new Error('Unkown boundingVolume type');\n}\nfunction createBox(box, transform, result) {\n  // https://math.gl/modules/culling/docs/api-reference/oriented-bounding-box\n  // 1. A half-axes based representation.\n  // box: An array of 12 numbers that define an oriented bounding box.\n  // The first three elements define the x, y, and z values for the center of the box.\n  // The next three elements (with indices 3, 4, and 5) define the x axis direction and half-length.\n  // The next three elements (indices 6, 7, and 8) define the y axis direction and half-length.\n  // The last three elements (indices 9, 10, and 11) define the z axis direction and half-length.\n  // 2. A half-size-quaternion based representation.\n  // box: An array of 10 numbers that define an oriented bounding box.\n  // The first three elements define the x, y, and z values for the center of the box in a right-handed 3-axis (x, y, z) Cartesian coordinate system where the z-axis is up.\n  // The next three elements (with indices 3, 4, and 5) define the halfSize.\n  // The last four elements (indices 6, 7, 8 and 10) define the quaternion.\n  const center = new Vector3(box[0], box[1], box[2]);\n  transform.transform(center, center);\n  let origin = [];\n  if (box.length === 10) {\n    const halfSize = box.slice(3, 6);\n    const quaternion = new Quaternion();\n    quaternion.fromArray(box, 6);\n    const x = new Vector3([1, 0, 0]);\n    const y = new Vector3([0, 1, 0]);\n    const z = new Vector3([0, 0, 1]);\n    x.transformByQuaternion(quaternion);\n    x.scale(halfSize[0]);\n    y.transformByQuaternion(quaternion);\n    y.scale(halfSize[1]);\n    z.transformByQuaternion(quaternion);\n    z.scale(halfSize[2]);\n    origin = [...x.toArray(), ...y.toArray(), ...z.toArray()];\n  } else {\n    origin = [...box.slice(3, 6), ...box.slice(6, 9), ...box.slice(9, 12)];\n  }\n  const xAxis = transform.transformAsVector(origin.slice(0, 3));\n  const yAxis = transform.transformAsVector(origin.slice(3, 6));\n  const zAxis = transform.transformAsVector(origin.slice(6, 9));\n  const halfAxes = new Matrix3([xAxis[0], xAxis[1], xAxis[2], yAxis[0], yAxis[1], yAxis[2], zAxis[0], zAxis[1], zAxis[2]]);\n  if (defined(result)) {\n    result.center = center;\n    result.halfAxes = halfAxes;\n    return result;\n  }\n  return new OrientedBoundingBox(center, halfAxes);\n}\n/*\nfunction createBoxFromTransformedRegion(region, transform, initialTransform, result) {\n  const rectangle = Rectangle.unpack(region, 0, scratchRectangle);\n  const minimumHeight = region[4];\n  const maximumHeight = region[5];\n\n  const orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n    rectangle,\n    minimumHeight,\n    maximumHeight,\n    Ellipsoid.WGS84,\n    scratchOrientedBoundingBox\n  );\n  const center = orientedBoundingBox.center;\n  const halfAxes = orientedBoundingBox.halfAxes;\n\n  // A region bounding volume is not transformed by the transform in the tileset JSON,\n  // but may be transformed by additional transforms applied in Cesium.\n  // This is why the transform is calculated as the difference between the initial transform and the current transform.\n  transform = Matrix4.multiplyTransformation(\n    transform,\n    Matrix4.inverseTransformation(initialTransform, scratchTransform),\n    scratchTransform\n  );\n  center = Matrix4.multiplyByPoint(transform, center, center);\n  const rotationScale = Matrix4.getRotation(transform, scratchMatrix);\n  halfAxes = Matrix3.multiply(rotationScale, halfAxes, halfAxes);\n\n  if (defined(result) && result instanceof TileOrientedBoundingBox) {\n    result.update(center, halfAxes);\n    return result;\n  }\n\n  return new TileOrientedBoundingBox(center, halfAxes);\n}\n\nfunction createRegion(region, transform, initialTransform, result) {\n  if (!Matrix4.equalsEpsilon(transform, initialTransform, CesiumMath.EPSILON8)) {\n    return createBoxFromTransformedRegion(region, transform, initialTransform, result);\n  }\n\n  if (defined(result)) {\n    return result;\n  }\n\n  const rectangleRegion = Rectangle.unpack(region, 0, scratchRectangle);\n\n  return new TileBoundingRegion({\n    rectangle: rectangleRegion,\n    minimumHeight: region[4],\n    maximumHeight: region[5]\n  });\n}\n*/\nfunction createSphere(sphere, transform, result) {\n  // Find the transformed center\n  const center = new Vector3(sphere[0], sphere[1], sphere[2]);\n  transform.transform(center, center);\n  const scale = transform.getScale(scratchScale);\n  const uniformScale = Math.max(Math.max(scale[0], scale[1]), scale[2]);\n  const radius = sphere[3] * uniformScale;\n  if (defined(result)) {\n    result.center = center;\n    result.radius = radius;\n    return result;\n  }\n  return new BoundingSphere(center, radius);\n}\n/**\n * Create OrientedBoundingBox instance from region 3D tiles bounding volume\n * @param region - region 3D tiles bounding volume\n * @returns OrientedBoundingBox instance\n */\nfunction createObbFromRegion(region) {\n  // [west, south, east, north, minimum height, maximum height]\n  // Latitudes and longitudes are in the WGS 84 datum as defined in EPSG 4979 and are in radians.\n  // Heights are in meters above (or below) the WGS 84 ellipsoid.\n  const [west, south, east, north, minHeight, maxHeight] = region;\n  const northWest = Ellipsoid.WGS84.cartographicToCartesian([degrees(west), degrees(north), minHeight], scratchNorthWest);\n  const southEast = Ellipsoid.WGS84.cartographicToCartesian([degrees(east), degrees(south), maxHeight], scratchSouthEast);\n  const centerInCartesian = new Vector3().addVectors(northWest, southEast).multiplyByScalar(0.5);\n  Ellipsoid.WGS84.cartesianToCartographic(centerInCartesian, scratchCenter);\n  Ellipsoid.WGS84.cartographicToCartesian([degrees(east), scratchCenter[1], scratchCenter[2]], scratchXAxis);\n  Ellipsoid.WGS84.cartographicToCartesian([scratchCenter[0], degrees(north), scratchCenter[2]], scratchYAxis);\n  Ellipsoid.WGS84.cartographicToCartesian([scratchCenter[0], scratchCenter[1], maxHeight], scratchZAxis);\n  return createBox([...centerInCartesian, ...scratchXAxis.subtract(centerInCartesian), ...scratchYAxis.subtract(centerInCartesian), ...scratchZAxis.subtract(centerInCartesian)], new Matrix4());\n}\n/**\n * Convert a bounding volume defined by OrientedBoundingBox to cartographic bounds\n * @returns {CartographicBounds}\n */\nfunction orientedBoundingBoxToCartographicBounds(boundingVolume) {\n  const result = emptyCartographicBounds();\n  const {\n    halfAxes\n  } = boundingVolume;\n  const xAxis = new Vector3(halfAxes.getColumn(0));\n  const yAxis = new Vector3(halfAxes.getColumn(1));\n  const zAxis = new Vector3(halfAxes.getColumn(2));\n  // Test all 8 corners of the box\n  for (let x = 0; x < 2; x++) {\n    for (let y = 0; y < 2; y++) {\n      for (let z = 0; z < 2; z++) {\n        scratchPoint.copy(boundingVolume.center);\n        scratchPoint.add(xAxis);\n        scratchPoint.add(yAxis);\n        scratchPoint.add(zAxis);\n        addToCartographicBounds(result, scratchPoint);\n        zAxis.negate();\n      }\n      yAxis.negate();\n    }\n    xAxis.negate();\n  }\n  return result;\n}\n/**\n * Convert a bounding volume defined by BoundingSphere to cartographic bounds\n * @returns {CartographicBounds}\n */\nfunction boundingSphereToCartographicBounds(boundingVolume) {\n  const result = emptyCartographicBounds();\n  const {\n    center,\n    radius\n  } = boundingVolume;\n  const point = Ellipsoid.WGS84.scaleToGeodeticSurface(center, scratchPoint);\n  let zAxis;\n  if (point) {\n    zAxis = Ellipsoid.WGS84.geodeticSurfaceNormal(point);\n  } else {\n    zAxis = new Vector3(0, 0, 1);\n  }\n  let xAxis = new Vector3(zAxis[2], -zAxis[1], 0);\n  if (xAxis.len() > 0) {\n    xAxis.normalize();\n  } else {\n    xAxis = new Vector3(0, 1, 0);\n  }\n  const yAxis = xAxis.clone().cross(zAxis);\n  // Test 6 end points of the 3 axes\n  for (const axis of [xAxis, yAxis, zAxis]) {\n    scratchScale.copy(axis).scale(radius);\n    for (let dir = 0; dir < 2; dir++) {\n      scratchPoint.copy(center);\n      scratchPoint.add(scratchScale);\n      addToCartographicBounds(result, scratchPoint);\n      // Flip the axis\n      scratchScale.negate();\n    }\n  }\n  return result;\n}\n/**\n * Create a new cartographic bounds that contains no points\n * @returns {CartographicBounds}\n */\nfunction emptyCartographicBounds() {\n  return [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n}\n/**\n * Add a point to the target cartographic bounds\n * @param {CartographicBounds} target\n * @param {Vector3} cartesian coordinates of the point to add\n */\nfunction addToCartographicBounds(target, cartesian) {\n  Ellipsoid.WGS84.cartesianToCartographic(cartesian, scratchPoint);\n  target[0][0] = Math.min(target[0][0], scratchPoint[0]);\n  target[0][1] = Math.min(target[0][1], scratchPoint[1]);\n  target[0][2] = Math.min(target[0][2], scratchPoint[2]);\n  target[1][0] = Math.max(target[1][0], scratchPoint[0]);\n  target[1][1] = Math.max(target[1][1], scratchPoint[1]);\n  target[1][2] = Math.max(target[1][2], scratchPoint[2]);\n}","map":{"version":3,"names":["Quaternion","Vector3","Matrix3","Matrix4","degrees","BoundingSphere","OrientedBoundingBox","Ellipsoid","assert","defined","x","undefined","scratchPoint","scratchScale","scratchNorthWest","scratchSouthEast","scratchCenter","scratchXAxis","scratchYAxis","scratchZAxis","createBoundingVolume","boundingVolumeHeader","transform","result","box","createBox","region","createObbFromRegion","sphere","createSphere","Error","getCartographicBounds","boundingVolume","orientedBoundingBoxToCartographicBounds","west","south","east","north","minHeight","maxHeight","boundingSphereToCartographicBounds","center","origin","length","halfSize","slice","quaternion","fromArray","y","z","transformByQuaternion","scale","toArray","xAxis","transformAsVector","yAxis","zAxis","halfAxes","getScale","uniformScale","Math","max","radius","northWest","WGS84","cartographicToCartesian","southEast","centerInCartesian","addVectors","multiplyByScalar","cartesianToCartographic","subtract","emptyCartographicBounds","getColumn","copy","add","addToCartographicBounds","negate","point","scaleToGeodeticSurface","geodeticSurfaceNormal","len","normalize","clone","cross","axis","dir","Infinity","target","cartesian","min"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/tiles/dist/tileset/helpers/bounding-volume.js"],"sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n/* eslint-disable */\nimport { Quaternion, Vector3, Matrix3, Matrix4, degrees } from '@math.gl/core';\nimport { BoundingSphere, OrientedBoundingBox } from '@math.gl/culling';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { assert } from '@loaders.gl/loader-utils';\n// const scratchProjectedBoundingSphere = new BoundingSphere();\nfunction defined(x) {\n    return x !== undefined && x !== null;\n}\n// const scratchMatrix = new Matrix3();\nconst scratchPoint = new Vector3();\nconst scratchScale = new Vector3();\nconst scratchNorthWest = new Vector3();\nconst scratchSouthEast = new Vector3();\nconst scratchCenter = new Vector3();\nconst scratchXAxis = new Vector3();\nconst scratchYAxis = new Vector3();\nconst scratchZAxis = new Vector3();\n// const scratchRectangle = new Rectangle();\n// const scratchOrientedBoundingBox = new OrientedBoundingBox();\n// const scratchTransform = new Matrix4();\n/**\n * Create a bounding volume from the tile's bounding volume header.\n * @param {Object} boundingVolumeHeader The tile's bounding volume header.\n * @param {Matrix4} transform The transform to apply to the bounding volume.\n * @param [result] The object onto which to store the result.\n * @returns The modified result parameter or a new TileBoundingVolume instance if none was provided.\n */\nexport function createBoundingVolume(boundingVolumeHeader, transform, result) {\n    assert(boundingVolumeHeader, '3D Tile: boundingVolume must be defined');\n    // boundingVolume schema:\n    // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/schema/boundingVolume.schema.json\n    if (boundingVolumeHeader.box) {\n        return createBox(boundingVolumeHeader.box, transform, result);\n    }\n    if (boundingVolumeHeader.region) {\n        return createObbFromRegion(boundingVolumeHeader.region);\n    }\n    if (boundingVolumeHeader.sphere) {\n        return createSphere(boundingVolumeHeader.sphere, transform, result);\n    }\n    throw new Error('3D Tile: boundingVolume must contain a sphere, region, or box');\n}\n/**\n * Calculate the cartographic bounding box the tile's bounding volume.\n * @param {Object} boundingVolumeHeader The tile's bounding volume header.\n * @param {BoundingVolume} boundingVolume The bounding volume.\n * @returns {CartographicBounds}\n */\nexport function getCartographicBounds(boundingVolumeHeader, boundingVolume) {\n    // boundingVolume schema:\n    // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/schema/boundingVolume.schema.json\n    if (boundingVolumeHeader.box) {\n        return orientedBoundingBoxToCartographicBounds(boundingVolume);\n    }\n    if (boundingVolumeHeader.region) {\n        // [west, south, east, north, minimum height, maximum height]\n        // Latitudes and longitudes are in the WGS 84 datum as defined in EPSG 4979 and are in radians.\n        // Heights are in meters above (or below) the WGS 84 ellipsoid.\n        const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;\n        return [\n            [degrees(west), degrees(south), minHeight],\n            [degrees(east), degrees(north), maxHeight]\n        ];\n    }\n    if (boundingVolumeHeader.sphere) {\n        return boundingSphereToCartographicBounds(boundingVolume);\n    }\n    throw new Error('Unkown boundingVolume type');\n}\nfunction createBox(box, transform, result) {\n    // https://math.gl/modules/culling/docs/api-reference/oriented-bounding-box\n    // 1. A half-axes based representation.\n    // box: An array of 12 numbers that define an oriented bounding box.\n    // The first three elements define the x, y, and z values for the center of the box.\n    // The next three elements (with indices 3, 4, and 5) define the x axis direction and half-length.\n    // The next three elements (indices 6, 7, and 8) define the y axis direction and half-length.\n    // The last three elements (indices 9, 10, and 11) define the z axis direction and half-length.\n    // 2. A half-size-quaternion based representation.\n    // box: An array of 10 numbers that define an oriented bounding box.\n    // The first three elements define the x, y, and z values for the center of the box in a right-handed 3-axis (x, y, z) Cartesian coordinate system where the z-axis is up.\n    // The next three elements (with indices 3, 4, and 5) define the halfSize.\n    // The last four elements (indices 6, 7, 8 and 10) define the quaternion.\n    const center = new Vector3(box[0], box[1], box[2]);\n    transform.transform(center, center);\n    let origin = [];\n    if (box.length === 10) {\n        const halfSize = box.slice(3, 6);\n        const quaternion = new Quaternion();\n        quaternion.fromArray(box, 6);\n        const x = new Vector3([1, 0, 0]);\n        const y = new Vector3([0, 1, 0]);\n        const z = new Vector3([0, 0, 1]);\n        x.transformByQuaternion(quaternion);\n        x.scale(halfSize[0]);\n        y.transformByQuaternion(quaternion);\n        y.scale(halfSize[1]);\n        z.transformByQuaternion(quaternion);\n        z.scale(halfSize[2]);\n        origin = [...x.toArray(), ...y.toArray(), ...z.toArray()];\n    }\n    else {\n        origin = [...box.slice(3, 6), ...box.slice(6, 9), ...box.slice(9, 12)];\n    }\n    const xAxis = transform.transformAsVector(origin.slice(0, 3));\n    const yAxis = transform.transformAsVector(origin.slice(3, 6));\n    const zAxis = transform.transformAsVector(origin.slice(6, 9));\n    const halfAxes = new Matrix3([\n        xAxis[0],\n        xAxis[1],\n        xAxis[2],\n        yAxis[0],\n        yAxis[1],\n        yAxis[2],\n        zAxis[0],\n        zAxis[1],\n        zAxis[2]\n    ]);\n    if (defined(result)) {\n        result.center = center;\n        result.halfAxes = halfAxes;\n        return result;\n    }\n    return new OrientedBoundingBox(center, halfAxes);\n}\n/*\nfunction createBoxFromTransformedRegion(region, transform, initialTransform, result) {\n  const rectangle = Rectangle.unpack(region, 0, scratchRectangle);\n  const minimumHeight = region[4];\n  const maximumHeight = region[5];\n\n  const orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n    rectangle,\n    minimumHeight,\n    maximumHeight,\n    Ellipsoid.WGS84,\n    scratchOrientedBoundingBox\n  );\n  const center = orientedBoundingBox.center;\n  const halfAxes = orientedBoundingBox.halfAxes;\n\n  // A region bounding volume is not transformed by the transform in the tileset JSON,\n  // but may be transformed by additional transforms applied in Cesium.\n  // This is why the transform is calculated as the difference between the initial transform and the current transform.\n  transform = Matrix4.multiplyTransformation(\n    transform,\n    Matrix4.inverseTransformation(initialTransform, scratchTransform),\n    scratchTransform\n  );\n  center = Matrix4.multiplyByPoint(transform, center, center);\n  const rotationScale = Matrix4.getRotation(transform, scratchMatrix);\n  halfAxes = Matrix3.multiply(rotationScale, halfAxes, halfAxes);\n\n  if (defined(result) && result instanceof TileOrientedBoundingBox) {\n    result.update(center, halfAxes);\n    return result;\n  }\n\n  return new TileOrientedBoundingBox(center, halfAxes);\n}\n\nfunction createRegion(region, transform, initialTransform, result) {\n  if (!Matrix4.equalsEpsilon(transform, initialTransform, CesiumMath.EPSILON8)) {\n    return createBoxFromTransformedRegion(region, transform, initialTransform, result);\n  }\n\n  if (defined(result)) {\n    return result;\n  }\n\n  const rectangleRegion = Rectangle.unpack(region, 0, scratchRectangle);\n\n  return new TileBoundingRegion({\n    rectangle: rectangleRegion,\n    minimumHeight: region[4],\n    maximumHeight: region[5]\n  });\n}\n*/\nfunction createSphere(sphere, transform, result) {\n    // Find the transformed center\n    const center = new Vector3(sphere[0], sphere[1], sphere[2]);\n    transform.transform(center, center);\n    const scale = transform.getScale(scratchScale);\n    const uniformScale = Math.max(Math.max(scale[0], scale[1]), scale[2]);\n    const radius = sphere[3] * uniformScale;\n    if (defined(result)) {\n        result.center = center;\n        result.radius = radius;\n        return result;\n    }\n    return new BoundingSphere(center, radius);\n}\n/**\n * Create OrientedBoundingBox instance from region 3D tiles bounding volume\n * @param region - region 3D tiles bounding volume\n * @returns OrientedBoundingBox instance\n */\nfunction createObbFromRegion(region) {\n    // [west, south, east, north, minimum height, maximum height]\n    // Latitudes and longitudes are in the WGS 84 datum as defined in EPSG 4979 and are in radians.\n    // Heights are in meters above (or below) the WGS 84 ellipsoid.\n    const [west, south, east, north, minHeight, maxHeight] = region;\n    const northWest = Ellipsoid.WGS84.cartographicToCartesian([degrees(west), degrees(north), minHeight], scratchNorthWest);\n    const southEast = Ellipsoid.WGS84.cartographicToCartesian([degrees(east), degrees(south), maxHeight], scratchSouthEast);\n    const centerInCartesian = new Vector3().addVectors(northWest, southEast).multiplyByScalar(0.5);\n    Ellipsoid.WGS84.cartesianToCartographic(centerInCartesian, scratchCenter);\n    Ellipsoid.WGS84.cartographicToCartesian([degrees(east), scratchCenter[1], scratchCenter[2]], scratchXAxis);\n    Ellipsoid.WGS84.cartographicToCartesian([scratchCenter[0], degrees(north), scratchCenter[2]], scratchYAxis);\n    Ellipsoid.WGS84.cartographicToCartesian([scratchCenter[0], scratchCenter[1], maxHeight], scratchZAxis);\n    return createBox([\n        ...centerInCartesian,\n        ...scratchXAxis.subtract(centerInCartesian),\n        ...scratchYAxis.subtract(centerInCartesian),\n        ...scratchZAxis.subtract(centerInCartesian)\n    ], new Matrix4());\n}\n/**\n * Convert a bounding volume defined by OrientedBoundingBox to cartographic bounds\n * @returns {CartographicBounds}\n */\nfunction orientedBoundingBoxToCartographicBounds(boundingVolume) {\n    const result = emptyCartographicBounds();\n    const { halfAxes } = boundingVolume;\n    const xAxis = new Vector3(halfAxes.getColumn(0));\n    const yAxis = new Vector3(halfAxes.getColumn(1));\n    const zAxis = new Vector3(halfAxes.getColumn(2));\n    // Test all 8 corners of the box\n    for (let x = 0; x < 2; x++) {\n        for (let y = 0; y < 2; y++) {\n            for (let z = 0; z < 2; z++) {\n                scratchPoint.copy(boundingVolume.center);\n                scratchPoint.add(xAxis);\n                scratchPoint.add(yAxis);\n                scratchPoint.add(zAxis);\n                addToCartographicBounds(result, scratchPoint);\n                zAxis.negate();\n            }\n            yAxis.negate();\n        }\n        xAxis.negate();\n    }\n    return result;\n}\n/**\n * Convert a bounding volume defined by BoundingSphere to cartographic bounds\n * @returns {CartographicBounds}\n */\nfunction boundingSphereToCartographicBounds(boundingVolume) {\n    const result = emptyCartographicBounds();\n    const { center, radius } = boundingVolume;\n    const point = Ellipsoid.WGS84.scaleToGeodeticSurface(center, scratchPoint);\n    let zAxis;\n    if (point) {\n        zAxis = Ellipsoid.WGS84.geodeticSurfaceNormal(point);\n    }\n    else {\n        zAxis = new Vector3(0, 0, 1);\n    }\n    let xAxis = new Vector3(zAxis[2], -zAxis[1], 0);\n    if (xAxis.len() > 0) {\n        xAxis.normalize();\n    }\n    else {\n        xAxis = new Vector3(0, 1, 0);\n    }\n    const yAxis = xAxis.clone().cross(zAxis);\n    // Test 6 end points of the 3 axes\n    for (const axis of [xAxis, yAxis, zAxis]) {\n        scratchScale.copy(axis).scale(radius);\n        for (let dir = 0; dir < 2; dir++) {\n            scratchPoint.copy(center);\n            scratchPoint.add(scratchScale);\n            addToCartographicBounds(result, scratchPoint);\n            // Flip the axis\n            scratchScale.negate();\n        }\n    }\n    return result;\n}\n/**\n * Create a new cartographic bounds that contains no points\n * @returns {CartographicBounds}\n */\nfunction emptyCartographicBounds() {\n    return [\n        [Infinity, Infinity, Infinity],\n        [-Infinity, -Infinity, -Infinity]\n    ];\n}\n/**\n * Add a point to the target cartographic bounds\n * @param {CartographicBounds} target\n * @param {Vector3} cartesian coordinates of the point to add\n */\nfunction addToCartographicBounds(target, cartesian) {\n    Ellipsoid.WGS84.cartesianToCartographic(cartesian, scratchPoint);\n    target[0][0] = Math.min(target[0][0], scratchPoint[0]);\n    target[0][1] = Math.min(target[0][1], scratchPoint[1]);\n    target[0][2] = Math.min(target[0][2], scratchPoint[2]);\n    target[1][0] = Math.max(target[1][0], scratchPoint[0]);\n    target[1][1] = Math.max(target[1][1], scratchPoint[1]);\n    target[1][2] = Math.max(target[1][2], scratchPoint[2]);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}