{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { RenderPass } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\nimport { withGLParameters } from \"../../context/state-tracker/with-parameters.js\";\nimport { setGLParameters } from \"../../context/parameters/unified-parameter-api.js\";\nconst COLOR_CHANNELS = [0x1, 0x2, 0x4, 0x8]; // GPUColorWrite RED, GREEN, BLUE, ALPHA\nexport class WEBGLRenderPass extends RenderPass {\n  device;\n  /** Parameters that should be applied before each draw call */\n  glParameters;\n  constructor(device, props) {\n    super(device, props);\n    this.device = device;\n    // If no viewport is provided, apply reasonably defaults\n    let viewport;\n    if (!props?.parameters?.viewport) {\n      if (props?.framebuffer) {\n        // Set the viewport to the size of the framebuffer\n        const {\n          width,\n          height\n        } = props.framebuffer;\n        viewport = [0, 0, width, height];\n      } else {\n        // Instead of using our own book-keeping, we can just read the values from the WebGL context\n        const [width, height] = device.getCanvasContext().getDrawingBufferSize();\n        viewport = [0, 0, width, height];\n      }\n    }\n    // TODO - do parameters (scissorRect) affect the clear operation?\n    this.device.pushState();\n    this.setParameters({\n      viewport,\n      ...this.props.parameters\n    });\n    // Specify mapping of draw buffer locations to color attachments\n    const webglFramebuffer = this.props.framebuffer;\n    if (webglFramebuffer?.handle) {\n      if (this.props.framebuffer) {\n        const drawBuffers = this.props.framebuffer.colorAttachments.map((_, i) => 36064 + i);\n        this.device.gl.drawBuffers(drawBuffers);\n      } else {\n        this.device.gl.drawBuffers([1029]);\n      }\n    }\n    // Hack - for now WebGL draws in \"immediate mode\" (instead of queueing the operations)...\n    this.clear();\n  }\n  end() {\n    this.device.popState();\n    // should add commands to CommandEncoder.\n  }\n  pushDebugGroup(groupLabel) {}\n  popDebugGroup() {}\n  insertDebugMarker(markerLabel) {}\n  // beginOcclusionQuery(queryIndex: number): void;\n  // endOcclusionQuery(): void;\n  // executeBundles(bundles: Iterable<GPURenderBundle>): void;\n  /**\n   * Maps RenderPass parameters to GL parameters\n   */\n  setParameters(parameters = {}) {\n    const glParameters = {\n      ...this.glParameters\n    };\n    // Framebuffers are specified using parameters in WebGL\n    glParameters.framebuffer = this.props.framebuffer || null;\n    if (this.props.depthReadOnly) {\n      glParameters.depthMask = !this.props.depthReadOnly;\n    }\n    glParameters.stencilMask = this.props.stencilReadOnly ? 0 : 1;\n    glParameters[35977] = this.props.discard;\n    // Map the four renderpass parameters to WebGL parameters\n    if (parameters.viewport) {\n      // WebGPU viewports are 6 coordinates (X, Y, Z)\n      if (parameters.viewport.length >= 6) {\n        glParameters.viewport = parameters.viewport.slice(0, 4);\n        glParameters.depthRange = [parameters.viewport[4], parameters.viewport[5]];\n      } else {\n        // WebGL viewports are 4 coordinates (X, Y)\n        glParameters.viewport = parameters.viewport;\n      }\n    }\n    if (parameters.scissorRect) {\n      glParameters.scissorTest = true;\n      glParameters.scissor = parameters.scissorRect;\n    }\n    if (parameters.blendConstant) {\n      glParameters.blendColor = parameters.blendConstant;\n    }\n    if (parameters.stencilReference) {\n      // eslint-disable-next-line no-console\n      console.warn('RenderPassParameters.stencilReference not yet implemented in WebGL');\n      // parameters.stencilFunc = [func, ref, mask];\n      // Does this work?\n      parameters[2967] = parameters.stencilReference;\n    }\n    if (parameters.colorMask) {\n      glParameters.colorMask = COLOR_CHANNELS.map(channel => Boolean(channel & parameters.colorMask));\n    }\n    this.glParameters = glParameters;\n    setGLParameters(this.device.gl, glParameters);\n  }\n  beginOcclusionQuery(queryIndex) {\n    const webglQuerySet = this.props.occlusionQuerySet;\n    webglQuerySet?.beginOcclusionQuery();\n  }\n  endOcclusionQuery() {\n    const webglQuerySet = this.props.occlusionQuerySet;\n    webglQuerySet?.endOcclusionQuery();\n  }\n  // PRIVATE\n  /**\n   * Optionally clears depth, color and stencil buffers based on parameters\n   */\n  clear() {\n    const glParameters = {\n      ...this.glParameters\n    };\n    let clearMask = 0;\n    if (this.props.clearColors) {\n      this.props.clearColors.forEach((color, drawBufferIndex) => {\n        if (color) {\n          this.clearColorBuffer(drawBufferIndex, color);\n        }\n      });\n    }\n    if (this.props.clearColor !== false && this.props.clearColors === undefined) {\n      clearMask |= 16384;\n      glParameters.clearColor = this.props.clearColor;\n    }\n    if (this.props.clearDepth !== false) {\n      clearMask |= 256;\n      glParameters.clearDepth = this.props.clearDepth;\n    }\n    if (this.props.clearStencil !== false) {\n      clearMask |= 1024;\n      glParameters.clearStencil = this.props.clearStencil;\n    }\n    if (clearMask !== 0) {\n      // Temporarily set any clear \"colors\" and call clear\n      withGLParameters(this.device.gl, glParameters, () => {\n        this.device.gl.clear(clearMask);\n      });\n    }\n  }\n  /**\n   * WebGL2 - clear a specific color buffer\n   */\n  clearColorBuffer(drawBuffer = 0, value = [0, 0, 0, 0]) {\n    withGLParameters(this.device.gl, {\n      framebuffer: this.props.framebuffer\n    }, () => {\n      // Method selection per OpenGL ES 3 docs\n      switch (value.constructor) {\n        case Int8Array:\n        case Int16Array:\n        case Int32Array:\n          this.device.gl.clearBufferiv(6144, drawBuffer, value);\n          break;\n        case Uint8Array:\n        case Uint8ClampedArray:\n        case Uint16Array:\n        case Uint32Array:\n          this.device.gl.clearBufferuiv(6144, drawBuffer, value);\n          break;\n        case Float32Array:\n          this.device.gl.clearBufferfv(6144, drawBuffer, value);\n          break;\n        default:\n          throw new Error('clearColorBuffer: color must be typed array');\n      }\n    });\n  }\n}\n//# sourceMappingURL=webgl-render-pass.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}