{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { registerJSModules } from '@loaders.gl/loader-utils';\nimport { isPureObject, isObject } from \"../../javascript-utils/is-type.js\";\nimport { probeLog, NullLog } from \"./loggers.js\";\nimport { DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS } from \"./option-defaults.js\";\n/**\n * Helper for safely accessing global loaders.gl variables\n * Wraps initialization of global variable in function to defeat overly aggressive tree-shakers\n */\nexport function getGlobalLoaderState() {\n  // @ts-ignore\n  globalThis.loaders = globalThis.loaders || {};\n  // @ts-ignore\n  const {\n    loaders\n  } = globalThis;\n  // Add _state object to keep separate from modules added to globalThis.loaders\n  if (!loaders._state) {\n    loaders._state = {};\n  }\n  return loaders._state;\n}\n/**\n * Store global loader options on the global object to increase chances of cross loaders-version interoperability\n * NOTE: This use case is not reliable but can help when testing new versions of loaders.gl with existing frameworks\n * @returns global loader options merged with default loader options\n */\nexport function getGlobalLoaderOptions() {\n  const state = getGlobalLoaderState();\n  // Ensure all default loader options from this library are mentioned\n  state.globalOptions = state.globalOptions || {\n    ...DEFAULT_LOADER_OPTIONS\n  };\n  return state.globalOptions;\n}\n/**\n * Set global loader options\n * @param options\n */\nexport function setGlobalOptions(options) {\n  const state = getGlobalLoaderState();\n  const globalOptions = getGlobalLoaderOptions();\n  // @ts-expect-error First param looks incorrect\n  state.globalOptions = normalizeOptionsInternal(globalOptions, options);\n  // Make sure any new modules are registered\n  registerJSModules(options.modules);\n}\n/**\n * Merges options with global opts and loader defaults, also injects baseUri\n * @param options\n * @param loader\n * @param loaders\n * @param url\n */\nexport function normalizeOptions(options, loader, loaders, url) {\n  loaders = loaders || [];\n  loaders = Array.isArray(loaders) ? loaders : [loaders];\n  validateOptions(options, loaders);\n  return normalizeOptionsInternal(loader, options, url);\n}\n// VALIDATE OPTIONS\n/**\n * Warn for unsupported options\n * @param options\n * @param loaders\n */\nfunction validateOptions(options, loaders) {\n  // Check top level options\n  validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);\n  for (const loader of loaders) {\n    // Get the scoped, loader specific options from the user supplied options\n    const idOptions = options && options[loader.id] || {};\n    // Get scoped, loader specific default and deprecated options from the selected loader\n    const loaderOptions = loader.options && loader.options[loader.id] || {};\n    const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};\n    // Validate loader specific options\n    // @ts-ignore\n    validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);\n  }\n}\n// eslint-disable-next-line max-params, complexity\nfunction validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {\n  const loaderName = id || 'Top level';\n  const prefix = id ? `${id}.` : '';\n  for (const key in options) {\n    // If top level option value is an object it could options for a loader, so ignore\n    const isSubOptions = !id && isObject(options[key]);\n    const isBaseUriOption = key === 'baseUri' && !id;\n    const isWorkerUrlOption = key === 'workerUrl' && id;\n    // <loader>.workerUrl requires special handling as it is now auto-generated and no longer specified as a default option.\n    if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {\n      // Issue deprecation warnings\n      if (key in deprecatedOptions) {\n        probeLog.warn(`${loaderName} loader option \\'${prefix}${key}\\' no longer supported, use \\'${deprecatedOptions[key]}\\'`)();\n      } else if (!isSubOptions) {\n        const suggestion = findSimilarOption(key, loaders);\n        probeLog.warn(`${loaderName} loader option \\'${prefix}${key}\\' not recognized. ${suggestion}`)();\n      }\n    }\n  }\n}\nfunction findSimilarOption(optionKey, loaders) {\n  const lowerCaseOptionKey = optionKey.toLowerCase();\n  let bestSuggestion = '';\n  for (const loader of loaders) {\n    for (const key in loader.options) {\n      if (optionKey === key) {\n        return `Did you mean \\'${loader.id}.${key}\\'?`;\n      }\n      const lowerCaseKey = key.toLowerCase();\n      const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);\n      if (isPartialMatch) {\n        bestSuggestion = bestSuggestion || `Did you mean \\'${loader.id}.${key}\\'?`;\n      }\n    }\n  }\n  return bestSuggestion;\n}\nfunction normalizeOptionsInternal(loader, options, url) {\n  const loaderDefaultOptions = loader.options || {};\n  const mergedOptions = {\n    ...loaderDefaultOptions\n  };\n  addUrlOptions(mergedOptions, url);\n  // LOGGING: options.log can be set to `null` to defeat logging\n  if (mergedOptions.log === null) {\n    mergedOptions.log = new NullLog();\n  }\n  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());\n  mergeNestedFields(mergedOptions, options);\n  return mergedOptions;\n}\n// Merge nested options objects\nfunction mergeNestedFields(mergedOptions, options) {\n  for (const key in options) {\n    // Check for nested options\n    // object in options => either no key in defaultOptions or object in defaultOptions\n    if (key in options) {\n      const value = options[key];\n      if (isPureObject(value) && isPureObject(mergedOptions[key])) {\n        mergedOptions[key] = {\n          ...mergedOptions[key],\n          ...options[key]\n        };\n      } else {\n        mergedOptions[key] = options[key];\n      }\n    }\n    // else: No need to merge nested opts, and the initial merge already copied over the nested options\n  }\n}\n/**\n * Harvest information from the url\n * @deprecated This is mainly there to support a hack in the GLTFLoader\n * TODO - baseUri should be a directory, i.e. remove file component from baseUri\n * TODO - extract extension?\n * TODO - extract query parameters?\n * TODO - should these be injected on context instead of options?\n */\nfunction addUrlOptions(options, url) {\n  if (url && !('baseUri' in options)) {\n    options.baseUri = url;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}