{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Model } from '@luma.gl/engine';\nimport { createRenderTarget } from \"./utils.js\";\nimport { binSorterUniforms } from \"./bin-sorter-uniforms.js\";\nconst COLOR_CHANNELS = [0x1, 0x2, 0x4, 0x8]; // GPU color mask RED, GREEN, BLUE, ALPHA\nconst MAX_FLOAT32 = 3e38;\nconst EMPTY_MASKS = {\n  SUM: 0,\n  MEAN: 0,\n  MIN: 0,\n  MAX: 0,\n  COUNT: 0\n};\nexport const TEXTURE_WIDTH = 1024;\n/**\n * This class manages the resources for performing the first step of aggregation\n * Sort a list of data points into a number of bins\n */\nexport class WebGLBinSorter {\n  constructor(device, props) {\n    /**\n     * A packed texture in which each pixel represents a bin.\n     * The index of the pixel in the memory layout is the bin index.\n     * Alpha value is the count of data points that fall into this bin\n     * R,G,B values are the aggregated values of each channel:\n     *   - Sum of all data points if operation is 'SUM', or 'MEAN'\n     *   - Min of all data points if operation is 'MIN'\n     *   - Max of all data points if operation is 'MAX'\n     */\n    this.binsFBO = null;\n    this.device = device;\n    this.model = createModel(device, props);\n  }\n  get texture() {\n    return this.binsFBO ? this.binsFBO.colorAttachments[0].texture : null;\n  }\n  destroy() {\n    this.model.destroy();\n    this.binsFBO?.colorAttachments[0].texture.destroy();\n    this.binsFBO?.destroy();\n  }\n  getBinValues(index) {\n    if (!this.binsFBO) {\n      return null;\n    }\n    const x = index % TEXTURE_WIDTH;\n    const y = Math.floor(index / TEXTURE_WIDTH);\n    const buffer = this.device.readPixelsToArrayWebGL(this.binsFBO, {\n      sourceX: x,\n      sourceY: y,\n      sourceWidth: 1,\n      sourceHeight: 1\n    }).buffer;\n    return new Float32Array(buffer);\n  }\n  setDimensions(binCount, binIdRange) {\n    const width = TEXTURE_WIDTH;\n    const height = Math.ceil(binCount / width);\n    // Only destroy existing texture if it is not large enough\n    if (!this.binsFBO) {\n      this.binsFBO = createRenderTarget(this.device, width, height);\n    } else if (this.binsFBO.height < height) {\n      this.binsFBO.resize({\n        width,\n        height\n      });\n    }\n    const binSorterProps = {\n      binIdRange: [binIdRange[0][0], binIdRange[0][1], binIdRange[1]?.[0] || 0, binIdRange[1]?.[1] || 0],\n      targetSize: [this.binsFBO.width, this.binsFBO.height]\n    };\n    this.model.shaderInputs.setProps({\n      binSorter: binSorterProps\n    });\n  }\n  setModelProps(props) {\n    const model = this.model;\n    if (props.attributes) {\n      model.setAttributes(props.attributes);\n    }\n    if (props.constantAttributes) {\n      model.setConstantAttributes(props.constantAttributes);\n    }\n    if (props.vertexCount !== undefined) {\n      model.setVertexCount(props.vertexCount);\n    }\n    if (props.shaderModuleProps) {\n      model.shaderInputs.setProps(props.shaderModuleProps);\n    }\n  }\n  /** Update aggregation */\n  update(/** The aggregation operation for each channel. Use null to skip update. */\n  operations) {\n    if (!this.binsFBO) {\n      return;\n    }\n    const masks = getMaskByOperation(operations);\n    this._updateBins('SUM', masks.SUM + masks.MEAN);\n    this._updateBins('MIN', masks.MIN);\n    this._updateBins('MAX', masks.MAX);\n  }\n  /** Recalculate aggregation on the given channels using the given operation */\n  _updateBins(operation, /** GPU bit mask of one or more channels that should be updated */\n  colorMask) {\n    if (colorMask === 0) {\n      return;\n    }\n    colorMask |= COLOR_CHANNELS[3]; // Also renders to the alpha channel (point count)\n    const model = this.model;\n    const target = this.binsFBO;\n    const initialValue = operation === 'MAX' ? -MAX_FLOAT32 : operation === 'MIN' ? MAX_FLOAT32 : 0;\n    const renderPass = this.device.beginRenderPass({\n      id: `gpu-aggregation-${operation}`,\n      framebuffer: target,\n      parameters: {\n        viewport: [0, 0, target.width, target.height],\n        colorMask\n      },\n      clearColor: [initialValue, initialValue, initialValue, 0],\n      clearDepth: false,\n      clearStencil: false\n    });\n    model.setParameters({\n      blend: true,\n      blendColorSrcFactor: 'one',\n      blendColorDstFactor: 'one',\n      blendAlphaSrcFactor: 'one',\n      blendAlphaDstFactor: 'one',\n      blendColorOperation: operation === 'MAX' ? 'max' : operation === 'MIN' ? 'min' : 'add',\n      blendAlphaOperation: 'add'\n    });\n    model.draw(renderPass);\n    renderPass.end();\n  }\n}\n/** Convert a [channel -> operation] map to a [operation -> GPU color mask] map */\nfunction getMaskByOperation(operations) {\n  const result = {\n    ...EMPTY_MASKS\n  };\n  for (let channel = 0; channel < operations.length; channel++) {\n    const op = operations[channel];\n    if (op) {\n      result[op] += COLOR_CHANNELS[channel];\n    }\n  }\n  return result;\n}\nfunction createModel(device, props) {\n  let userVs = props.vs;\n  if (props.dimensions === 2) {\n    // If user provides 2d bin IDs, convert them to 1d indices for data packing\n    userVs += /* glsl */`\nvoid getBin(out int binId) {\n  ivec2 binId2;\n  getBin(binId2);\n  if (binId2.x < binSorter.binIdRange.x || binId2.x >= binSorter.binIdRange.y) {\n    binId = -1;\n  } else {\n    binId = (binId2.y - binSorter.binIdRange.z) * (binSorter.binIdRange.y - binSorter.binIdRange.x) + binId2.x;\n  }\n}\n`;\n  }\n  const vs = `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-sort-bins-vertex\n\n${userVs}\n\nout vec3 v_Value;\n\nvoid main() {\n  int binIndex;\n  getBin(binIndex);\n  binIndex = binIndex - binSorter.binIdRange.x;\n  if (binIndex < 0) {\n    gl_Position = vec4(0.);\n    return;\n  }\n  int row = binIndex / binSorter.targetSize.x;\n  int col = binIndex - row * binSorter.targetSize.x;\n  vec2 position = (vec2(col, row) + 0.5) / vec2(binSorter.targetSize) * 2.0 - 1.0;\n  gl_Position = vec4(position, 0.0, 1.0);\n  gl_PointSize = 1.0;\n\n#if NUM_CHANNELS == 3\n  getValue(v_Value);\n#elif NUM_CHANNELS == 2\n  getValue(v_Value.xy);\n#else\n  getValue(v_Value.x);\n#endif\n}\n`;\n  const fs = /* glsl */`\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-sort-bins-fragment\n\nprecision highp float;\n\nin vec3 v_Value;\nout vec4 fragColor;\n\nvoid main() {\n  fragColor.xyz = v_Value;\n\n  #ifdef MODULE_GEOMETRY\n  geometry.uv = vec2(0.);\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n  #endif\n\n  fragColor.w = 1.0;\n}\n`;\n  const model = new Model(device, {\n    bufferLayout: props.bufferLayout,\n    modules: [...(props.modules || []), binSorterUniforms],\n    defines: {\n      ...props.defines,\n      NON_INSTANCED_MODEL: 1,\n      NUM_CHANNELS: props.channelCount\n    },\n    isInstanced: false,\n    vs,\n    fs,\n    topology: 'point-list',\n    disableWarnings: true\n  });\n  return model;\n}","map":{"version":3,"names":["Model","createRenderTarget","binSorterUniforms","COLOR_CHANNELS","MAX_FLOAT32","EMPTY_MASKS","SUM","MEAN","MIN","MAX","COUNT","TEXTURE_WIDTH","WebGLBinSorter","constructor","device","props","binsFBO","model","createModel","texture","colorAttachments","destroy","getBinValues","index","x","y","Math","floor","buffer","readPixelsToArrayWebGL","sourceX","sourceY","sourceWidth","sourceHeight","Float32Array","setDimensions","binCount","binIdRange","width","height","ceil","resize","binSorterProps","targetSize","shaderInputs","setProps","binSorter","setModelProps","attributes","setAttributes","constantAttributes","setConstantAttributes","vertexCount","undefined","setVertexCount","shaderModuleProps","update","operations","masks","getMaskByOperation","_updateBins","operation","colorMask","target","initialValue","renderPass","beginRenderPass","id","framebuffer","parameters","viewport","clearColor","clearDepth","clearStencil","setParameters","blend","blendColorSrcFactor","blendColorDstFactor","blendAlphaSrcFactor","blendAlphaDstFactor","blendColorOperation","blendAlphaOperation","draw","end","result","channel","length","op","userVs","vs","dimensions","fs","bufferLayout","modules","defines","NON_INSTANCED_MODEL","NUM_CHANNELS","channelCount","isInstanced","topology","disableWarnings"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\aggregation-layers\\src\\common\\aggregator\\gpu-aggregator\\webgl-bin-sorter.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Model, ModelProps} from '@luma.gl/engine';\nimport {createRenderTarget} from './utils';\n\nimport type {Device, Framebuffer, Texture} from '@luma.gl/core';\nimport type {WebGLAggregatorProps} from './webgl-aggregator';\nimport type {AggregationOperation} from '../aggregator';\nimport {BinSorterProps, binSorterUniforms} from './bin-sorter-uniforms';\n\nconst COLOR_CHANNELS = [0x1, 0x2, 0x4, 0x8]; // GPU color mask RED, GREEN, BLUE, ALPHA\nconst MAX_FLOAT32 = 3e38;\nconst EMPTY_MASKS = {SUM: 0, MEAN: 0, MIN: 0, MAX: 0, COUNT: 0};\n\nexport const TEXTURE_WIDTH = 1024;\n\n/**\n * This class manages the resources for performing the first step of aggregation\n * Sort a list of data points into a number of bins\n */\nexport class WebGLBinSorter {\n  device: Device;\n  model: Model;\n\n  /**\n   * A packed texture in which each pixel represents a bin.\n   * The index of the pixel in the memory layout is the bin index.\n   * Alpha value is the count of data points that fall into this bin\n   * R,G,B values are the aggregated values of each channel:\n   *   - Sum of all data points if operation is 'SUM', or 'MEAN'\n   *   - Min of all data points if operation is 'MIN'\n   *   - Max of all data points if operation is 'MAX'\n   */\n  private binsFBO: Framebuffer | null = null;\n\n  constructor(device: Device, props: WebGLAggregatorProps) {\n    this.device = device;\n    this.model = createModel(device, props);\n  }\n\n  get texture(): Texture | null {\n    return this.binsFBO ? this.binsFBO.colorAttachments[0].texture : null;\n  }\n\n  destroy() {\n    this.model.destroy();\n    this.binsFBO?.colorAttachments[0].texture.destroy();\n    this.binsFBO?.destroy();\n  }\n\n  getBinValues(index: number): Float32Array | null {\n    if (!this.binsFBO) {\n      return null;\n    }\n    const x = index % TEXTURE_WIDTH;\n    const y = Math.floor(index / TEXTURE_WIDTH);\n    const buffer = this.device.readPixelsToArrayWebGL(this.binsFBO, {\n      sourceX: x,\n      sourceY: y,\n      sourceWidth: 1,\n      sourceHeight: 1\n    }).buffer;\n    return new Float32Array(buffer);\n  }\n\n  setDimensions(binCount: number, binIdRange: [number, number][]) {\n    const width = TEXTURE_WIDTH;\n    const height = Math.ceil(binCount / width);\n\n    // Only destroy existing texture if it is not large enough\n    if (!this.binsFBO) {\n      this.binsFBO = createRenderTarget(this.device, width, height);\n    } else if (this.binsFBO.height < height) {\n      this.binsFBO.resize({width, height});\n    }\n\n    const binSorterProps: BinSorterProps = {\n      binIdRange: [\n        binIdRange[0][0],\n        binIdRange[0][1],\n        binIdRange[1]?.[0] || 0,\n        binIdRange[1]?.[1] || 0\n      ],\n      targetSize: [this.binsFBO.width, this.binsFBO.height]\n    };\n    this.model.shaderInputs.setProps({binSorter: binSorterProps});\n  }\n\n  setModelProps(\n    props: Pick<ModelProps, 'vertexCount' | 'uniforms' | 'attributes' | 'constantAttributes'> & {\n      shaderModuleProps?: Record<string, any>;\n    }\n  ) {\n    const model = this.model;\n    if (props.attributes) {\n      model.setAttributes(props.attributes);\n    }\n    if (props.constantAttributes) {\n      model.setConstantAttributes(props.constantAttributes);\n    }\n    if (props.vertexCount !== undefined) {\n      model.setVertexCount(props.vertexCount);\n    }\n    if (props.shaderModuleProps) {\n      model.shaderInputs.setProps(props.shaderModuleProps);\n    }\n  }\n\n  /** Update aggregation */\n  update(\n    /** The aggregation operation for each channel. Use null to skip update. */\n    operations: (AggregationOperation | null)[]\n  ) {\n    if (!this.binsFBO) {\n      return;\n    }\n    const masks = getMaskByOperation(operations);\n    this._updateBins('SUM', masks.SUM + masks.MEAN);\n    this._updateBins('MIN', masks.MIN);\n    this._updateBins('MAX', masks.MAX);\n  }\n\n  /** Recalculate aggregation on the given channels using the given operation */\n  private _updateBins(\n    operation: AggregationOperation,\n    /** GPU bit mask of one or more channels that should be updated */\n    colorMask: number\n  ) {\n    if (colorMask === 0) {\n      return;\n    }\n    colorMask |= COLOR_CHANNELS[3]; // Also renders to the alpha channel (point count)\n\n    const model = this.model;\n    const target = this.binsFBO!;\n\n    const initialValue = operation === 'MAX' ? -MAX_FLOAT32 : operation === 'MIN' ? MAX_FLOAT32 : 0;\n    const renderPass = this.device.beginRenderPass({\n      id: `gpu-aggregation-${operation}`,\n      framebuffer: target,\n      parameters: {\n        viewport: [0, 0, target.width, target.height],\n        colorMask\n      },\n      clearColor: [initialValue, initialValue, initialValue, 0],\n      clearDepth: false,\n      clearStencil: false\n    });\n    model.setParameters({\n      blend: true,\n      blendColorSrcFactor: 'one',\n      blendColorDstFactor: 'one',\n      blendAlphaSrcFactor: 'one',\n      blendAlphaDstFactor: 'one',\n      blendColorOperation: operation === 'MAX' ? 'max' : operation === 'MIN' ? 'min' : 'add',\n      blendAlphaOperation: 'add'\n    });\n    model.draw(renderPass);\n    renderPass.end();\n  }\n}\n\n/** Convert a [channel -> operation] map to a [operation -> GPU color mask] map */\nfunction getMaskByOperation(\n  operations: (AggregationOperation | null)[]\n): Record<AggregationOperation, number> {\n  const result: Record<AggregationOperation, number> = {...EMPTY_MASKS};\n  for (let channel = 0; channel < operations.length; channel++) {\n    const op = operations[channel];\n    if (op) {\n      result[op] += COLOR_CHANNELS[channel];\n    }\n  }\n  return result;\n}\n\nfunction createModel(device: Device, props: WebGLAggregatorProps): Model {\n  let userVs = props.vs;\n\n  if (props.dimensions === 2) {\n    // If user provides 2d bin IDs, convert them to 1d indices for data packing\n    userVs += /* glsl */ `\nvoid getBin(out int binId) {\n  ivec2 binId2;\n  getBin(binId2);\n  if (binId2.x < binSorter.binIdRange.x || binId2.x >= binSorter.binIdRange.y) {\n    binId = -1;\n  } else {\n    binId = (binId2.y - binSorter.binIdRange.z) * (binSorter.binIdRange.y - binSorter.binIdRange.x) + binId2.x;\n  }\n}\n`;\n  }\n\n  const vs = `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-sort-bins-vertex\n\n${userVs}\n\nout vec3 v_Value;\n\nvoid main() {\n  int binIndex;\n  getBin(binIndex);\n  binIndex = binIndex - binSorter.binIdRange.x;\n  if (binIndex < 0) {\n    gl_Position = vec4(0.);\n    return;\n  }\n  int row = binIndex / binSorter.targetSize.x;\n  int col = binIndex - row * binSorter.targetSize.x;\n  vec2 position = (vec2(col, row) + 0.5) / vec2(binSorter.targetSize) * 2.0 - 1.0;\n  gl_Position = vec4(position, 0.0, 1.0);\n  gl_PointSize = 1.0;\n\n#if NUM_CHANNELS == 3\n  getValue(v_Value);\n#elif NUM_CHANNELS == 2\n  getValue(v_Value.xy);\n#else\n  getValue(v_Value.x);\n#endif\n}\n`;\n  const fs = /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-sort-bins-fragment\n\nprecision highp float;\n\nin vec3 v_Value;\nout vec4 fragColor;\n\nvoid main() {\n  fragColor.xyz = v_Value;\n\n  #ifdef MODULE_GEOMETRY\n  geometry.uv = vec2(0.);\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n  #endif\n\n  fragColor.w = 1.0;\n}\n`;\n  const model = new Model(device, {\n    bufferLayout: props.bufferLayout,\n    modules: [...(props.modules || []), binSorterUniforms],\n    defines: {...props.defines, NON_INSTANCED_MODEL: 1, NUM_CHANNELS: props.channelCount},\n    isInstanced: false,\n    vs,\n    fs,\n    topology: 'point-list',\n    disableWarnings: true\n  });\n  return model;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}