{"ast":null,"code":"// luma.gl, MIT license\nimport { AsyncTexture } from '@luma.gl/engine';\nimport { loadImageTexture } from '@loaders.gl/textures';\n/** Loads textures for PBR environment */\nexport function loadPBREnvironment(device, props) {\n  const brdfLutTexture = new AsyncTexture(device, {\n    id: 'brdfLUT',\n    sampler: {\n      wrapS: 'clamp-to-edge',\n      wrapT: 'clamp-to-edge',\n      minFilter: 'linear',\n      maxFilter: 'linear'\n    },\n    // Texture accepts a promise that returns an image as data (Async Textures)\n    data: loadImageTexture(props.brdfLutUrl)\n  });\n  const diffuseEnvSampler = makeCube(device, {\n    id: 'DiffuseEnvSampler',\n    getTextureForFace: dir => loadImageTexture(props.getTexUrl('diffuse', dir, 0)),\n    sampler: {\n      wrapS: 'clamp-to-edge',\n      wrapT: 'clamp-to-edge',\n      minFilter: 'linear',\n      maxFilter: 'linear'\n    }\n  });\n  const specularEnvSampler = makeCube(device, {\n    id: 'SpecularEnvSampler',\n    getTextureForFace: dir => {\n      const imageArray = [];\n      for (let lod = 0; lod <= props.specularMipLevels - 1; lod++) {\n        imageArray.push(loadImageTexture(props.getTexUrl('specular', dir, lod)));\n      }\n      return imageArray;\n    },\n    sampler: {\n      wrapS: 'clamp-to-edge',\n      wrapT: 'clamp-to-edge',\n      minFilter: 'linear',\n      // [GL.TEXTURE_MIN_FILTER]: GL.LINEAR_MIPMAP_LINEAR,\n      maxFilter: 'linear'\n    }\n  });\n  return {\n    brdfLutTexture,\n    diffuseEnvSampler,\n    specularEnvSampler\n  };\n}\n// TODO put somewhere common\nconst FACES = [0, 1, 2, 3, 4, 5];\nfunction makeCube(device, {\n  id,\n  getTextureForFace,\n  sampler\n}) {\n  const data = {};\n  FACES.forEach(face => {\n    data[String(face)] = getTextureForFace(face);\n  });\n  return new AsyncTexture(device, {\n    id,\n    dimension: 'cube',\n    mipmaps: false,\n    sampler,\n    // @ts-expect-error\n    data\n  });\n}","map":{"version":3,"names":["AsyncTexture","loadImageTexture","loadPBREnvironment","device","props","brdfLutTexture","id","sampler","wrapS","wrapT","minFilter","maxFilter","data","brdfLutUrl","diffuseEnvSampler","makeCube","getTextureForFace","dir","getTexUrl","specularEnvSampler","imageArray","lod","specularMipLevels","push","FACES","forEach","face","String","dimension","mipmaps"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\gltf\\src\\pbr\\pbr-environment.ts"],"sourcesContent":["// luma.gl, MIT license\n\nimport {Device, SamplerProps} from '@luma.gl/core';\nimport {AsyncTexture} from '@luma.gl/engine';\nimport {loadImageTexture} from '@loaders.gl/textures';\n\n/** Environment textures for PBR module */\nexport type PBREnvironment = {\n  /** Bi-directional Reflectance Distribution Function (BRDF) lookup table */\n  brdfLutTexture: AsyncTexture;\n  diffuseEnvSampler: AsyncTexture;\n  specularEnvSampler: AsyncTexture;\n};\n\nexport type PBREnvironmentProps = {\n  brdfLutUrl: string;\n  getTexUrl: (name: string, dir: number, level: number) => string;\n  specularMipLevels?: number;\n};\n\n/** Loads textures for PBR environment */\nexport function loadPBREnvironment(device: Device, props: PBREnvironmentProps): PBREnvironment {\n  const brdfLutTexture = new AsyncTexture(device, {\n    id: 'brdfLUT',\n    sampler: {\n      wrapS: 'clamp-to-edge',\n      wrapT: 'clamp-to-edge',\n      minFilter: 'linear',\n      maxFilter: 'linear'\n    } as SamplerProps,\n    // Texture accepts a promise that returns an image as data (Async Textures)\n    data: loadImageTexture(props.brdfLutUrl)\n  });\n\n  const diffuseEnvSampler = makeCube(device, {\n    id: 'DiffuseEnvSampler',\n    getTextureForFace: dir => loadImageTexture(props.getTexUrl('diffuse', dir, 0)),\n    sampler: {\n      wrapS: 'clamp-to-edge',\n      wrapT: 'clamp-to-edge',\n      minFilter: 'linear',\n      maxFilter: 'linear'\n    } as SamplerProps\n  });\n\n  const specularEnvSampler = makeCube(device, {\n    id: 'SpecularEnvSampler',\n    getTextureForFace: (dir: number) => {\n      const imageArray = [];\n      for (let lod = 0; lod <= props.specularMipLevels - 1; lod++) {\n        imageArray.push(loadImageTexture(props.getTexUrl('specular', dir, lod)));\n      }\n      return imageArray;\n    },\n    sampler: {\n      wrapS: 'clamp-to-edge',\n      wrapT: 'clamp-to-edge',\n      minFilter: 'linear', // [GL.TEXTURE_MIN_FILTER]: GL.LINEAR_MIPMAP_LINEAR,\n      maxFilter: 'linear'\n    } as SamplerProps\n  });\n\n  return {\n    brdfLutTexture,\n    diffuseEnvSampler,\n    specularEnvSampler\n  };\n}\n\n// TODO put somewhere common\nconst FACES = [0, 1, 2, 3, 4, 5];\n\nfunction makeCube(\n  device: Device,\n  {\n    id,\n    getTextureForFace,\n    sampler\n  }: {\n    id: string;\n    getTextureForFace: (dir: number) => Promise<any> | Promise<any>[];\n    sampler: SamplerProps;\n  }\n): AsyncTexture {\n  const data = {};\n  FACES.forEach(face => {\n    data[String(face)] = getTextureForFace(face);\n  });\n  return new AsyncTexture(device, {\n    id,\n    dimension: 'cube',\n    mipmaps: false,\n    sampler,\n    // @ts-expect-error\n    data\n  });\n}\n"],"mappings":"AAAA;AAGA,SAAQA,YAAY,QAAO,iBAAiB;AAC5C,SAAQC,gBAAgB,QAAO,sBAAsB;AAgBrD;AACA,OAAM,SAAUC,kBAAkBA,CAACC,MAAc,EAAEC,KAA0B;EAC3E,MAAMC,cAAc,GAAG,IAAIL,YAAY,CAACG,MAAM,EAAE;IAC9CG,EAAE,EAAE,SAAS;IACbC,OAAO,EAAE;MACPC,KAAK,EAAE,eAAe;MACtBC,KAAK,EAAE,eAAe;MACtBC,SAAS,EAAE,QAAQ;MACnBC,SAAS,EAAE;KACI;IACjB;IACAC,IAAI,EAAEX,gBAAgB,CAACG,KAAK,CAACS,UAAU;GACxC,CAAC;EAEF,MAAMC,iBAAiB,GAAGC,QAAQ,CAACZ,MAAM,EAAE;IACzCG,EAAE,EAAE,mBAAmB;IACvBU,iBAAiB,EAAEC,GAAG,IAAIhB,gBAAgB,CAACG,KAAK,CAACc,SAAS,CAAC,SAAS,EAAED,GAAG,EAAE,CAAC,CAAC,CAAC;IAC9EV,OAAO,EAAE;MACPC,KAAK,EAAE,eAAe;MACtBC,KAAK,EAAE,eAAe;MACtBC,SAAS,EAAE,QAAQ;MACnBC,SAAS,EAAE;;GAEd,CAAC;EAEF,MAAMQ,kBAAkB,GAAGJ,QAAQ,CAACZ,MAAM,EAAE;IAC1CG,EAAE,EAAE,oBAAoB;IACxBU,iBAAiB,EAAGC,GAAW,IAAI;MACjC,MAAMG,UAAU,GAAG,EAAE;MACrB,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,IAAIjB,KAAK,CAACkB,iBAAiB,GAAG,CAAC,EAAED,GAAG,EAAE,EAAE;QAC3DD,UAAU,CAACG,IAAI,CAACtB,gBAAgB,CAACG,KAAK,CAACc,SAAS,CAAC,UAAU,EAAED,GAAG,EAAEI,GAAG,CAAC,CAAC,CAAC;MAC1E;MACA,OAAOD,UAAU;IACnB,CAAC;IACDb,OAAO,EAAE;MACPC,KAAK,EAAE,eAAe;MACtBC,KAAK,EAAE,eAAe;MACtBC,SAAS,EAAE,QAAQ;MAAE;MACrBC,SAAS,EAAE;;GAEd,CAAC;EAEF,OAAO;IACLN,cAAc;IACdS,iBAAiB;IACjBK;GACD;AACH;AAEA;AACA,MAAMK,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AAEhC,SAAST,QAAQA,CACfZ,MAAc,EACd;EACEG,EAAE;EACFU,iBAAiB;EACjBT;AAAO,CAKR;EAED,MAAMK,IAAI,GAAG,EAAE;EACfY,KAAK,CAACC,OAAO,CAACC,IAAI,IAAG;IACnBd,IAAI,CAACe,MAAM,CAACD,IAAI,CAAC,CAAC,GAAGV,iBAAiB,CAACU,IAAI,CAAC;EAC9C,CAAC,CAAC;EACF,OAAO,IAAI1B,YAAY,CAACG,MAAM,EAAE;IAC9BG,EAAE;IACFsB,SAAS,EAAE,MAAM;IACjBC,OAAO,EAAE,KAAK;IACdtB,OAAO;IACP;IACAK;GACD,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}