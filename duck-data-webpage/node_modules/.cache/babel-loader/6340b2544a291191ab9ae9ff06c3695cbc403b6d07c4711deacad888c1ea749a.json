{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\nimport { createProtoFeature } from \"./proto-feature.js\";\n/* eslint-disable no-continue */\n/**\n * Clip features between two vertical or horizontal axis-parallel lines:\n *     |        |\n *  ___|___     |     /\n * /   |   \\____|____/\n *     |        |\n *\n * @param k1 and k2 are the line coordinates\n * @param axis: 0 for x, 1 for y\n * @param minAll and maxAll: minimum and maximum coordinate value for all features\n */\n// eslint-disable-next-line max-params, complexity, max-statements\nexport function clipFeatures(features, scale, k1, k2, axis, minAll, maxAll, options) {\n  k1 /= scale;\n  k2 /= scale;\n  if (minAll >= k1 && maxAll < k2) {\n    return features;\n  }\n  // trivial accept\n  else if (maxAll < k1 || minAll >= k2) {\n    return null; // trivial reject\n  }\n  const clipped = [];\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    let type = feature.type;\n    const min = axis === 0 ? feature.minX : feature.minY;\n    const max = axis === 0 ? feature.maxX : feature.maxY;\n    if (min >= k1 && max < k2) {\n      // trivial accept\n      clipped.push(feature);\n      continue;\n    } else if (max < k1 || min >= k2) {\n      // trivial reject\n      continue;\n    }\n    let newGeometry = [];\n    if (type === 'Point' || type === 'MultiPoint') {\n      clipPoints(geometry, newGeometry, k1, k2, axis);\n    } else if (type === 'LineString') {\n      clipLine(geometry, newGeometry, k1, k2, axis, false, options.lineMetrics);\n    } else if (type === 'MultiLineString') {\n      clipLines(geometry, newGeometry, k1, k2, axis, false);\n    } else if (type === 'Polygon') {\n      clipLines(geometry, newGeometry, k1, k2, axis, true);\n    } else if (type === 'MultiPolygon') {\n      for (const polygon of geometry) {\n        const newPolygon = [];\n        clipLines(polygon, newPolygon, k1, k2, axis, true);\n        if (newPolygon.length) {\n          newGeometry.push(newPolygon);\n        }\n      }\n    }\n    if (newGeometry.length) {\n      if (options.lineMetrics && type === 'LineString') {\n        for (const line of newGeometry) {\n          clipped.push(createProtoFeature(feature.id, type, line, feature.tags));\n        }\n        continue;\n      }\n      if (type === 'LineString' || type === 'MultiLineString') {\n        if (newGeometry.length === 1) {\n          type = 'LineString';\n          // @ts-expect-error TODO - use proper GeoJSON geometry types\n          newGeometry = newGeometry[0];\n        } else {\n          type = 'MultiLineString';\n        }\n      }\n      if (type === 'Point' || type === 'MultiPoint') {\n        type = newGeometry.length === 3 ? 'Point' : 'MultiPoint';\n      }\n      clipped.push(createProtoFeature(feature.id, type, newGeometry, feature.tags));\n    }\n  }\n  return clipped.length ? clipped : null;\n}\nfunction clipPoints(geom, newGeom, k1, k2, axis) {\n  for (let i = 0; i < geom.length; i += 3) {\n    const a = geom[i + axis];\n    if (a >= k1 && a <= k2) {\n      addPoint(newGeom, geom[i], geom[i + 1], geom[i + 2]);\n    }\n  }\n}\n// eslint-disable-next-line max-params, complexity, max-statements\nfunction clipLine(geom, newGeom, k1, k2, axis, isPolygon, trackMetrics) {\n  let slice = newSlice(geom);\n  const intersect = axis === 0 ? intersectX : intersectY;\n  let len = geom.start;\n  let segLen;\n  let t;\n  for (let i = 0; i < geom.length - 3; i += 3) {\n    const ax = geom[i];\n    const ay = geom[i + 1];\n    const az = geom[i + 2];\n    const bx = geom[i + 3];\n    const by = geom[i + 4];\n    const a = axis === 0 ? ax : ay;\n    const b = axis === 0 ? bx : by;\n    let exited = false;\n    if (trackMetrics) {\n      segLen = Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));\n    }\n    if (a < k1) {\n      // ---|-->  | (line enters the clip region from the left)\n      if (b > k1) {\n        t = intersect(slice, ax, ay, bx, by, k1);\n        if (trackMetrics) {\n          slice.start = len + segLen * t;\n        }\n      }\n    } else if (a > k2) {\n      // |  <--|--- (line enters the clip region from the right)\n      if (b < k2) {\n        t = intersect(slice, ax, ay, bx, by, k2);\n        if (trackMetrics) {\n          slice.start = len + segLen * t;\n        }\n      }\n    } else {\n      addPoint(slice, ax, ay, az);\n    }\n    if (b < k1 && a >= k1) {\n      // <--|---  | or <--|-----|--- (line exits the clip region on the left)\n      t = intersect(slice, ax, ay, bx, by, k1);\n      exited = true;\n    }\n    if (b > k2 && a <= k2) {\n      // |  ---|--> or ---|-----|--> (line exits the clip region on the right)\n      t = intersect(slice, ax, ay, bx, by, k2);\n      exited = true;\n    }\n    if (!isPolygon && exited) {\n      if (trackMetrics) {\n        slice.end = len + segLen * t;\n      }\n      newGeom.push(slice);\n      slice = newSlice(geom);\n    }\n    if (trackMetrics) {\n      len += segLen;\n    }\n  }\n  // add the last point\n  let last = geom.length - 3;\n  const ax = geom[last];\n  const ay = geom[last + 1];\n  const az = geom[last + 2];\n  const a = axis === 0 ? ax : ay;\n  if (a >= k1 && a <= k2) addPoint(slice, ax, ay, az);\n  // close the polygon if its endpoints are not the same after clipping\n  last = slice.length - 3;\n  if (isPolygon && last >= 3 && (slice[last] !== slice[0] || slice[last + 1] !== slice[1])) {\n    addPoint(slice, slice[0], slice[1], slice[2]);\n  }\n  // add the final slice\n  if (slice.length) {\n    newGeom.push(slice);\n  }\n}\nclass Slice extends Array {\n  size;\n  start;\n  end;\n}\nfunction newSlice(line) {\n  const slice = [];\n  slice.size = line.size;\n  slice.start = line.start;\n  slice.end = line.end;\n  return slice;\n}\n// eslint-disable-next-line max-params\nfunction clipLines(geom, newGeom, k1, k2, axis, isPolygon) {\n  for (const line of geom) {\n    clipLine(line, newGeom, k1, k2, axis, isPolygon, false);\n  }\n}\nfunction addPoint(out, x, y, z) {\n  out.push(x, y, z);\n}\n// eslint-disable-next-line max-params\nfunction intersectX(out, ax, ay, bx, by, x) {\n  const t = (x - ax) / (bx - ax);\n  addPoint(out, x, ay + (by - ay) * t, 1);\n  return t;\n}\n// eslint-disable-next-line max-params\nfunction intersectY(out, ax, ay, bx, by, y) {\n  const t = (y - ay) / (by - ay);\n  addPoint(out, ax + (bx - ax) * t, y, 1);\n  return t;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}