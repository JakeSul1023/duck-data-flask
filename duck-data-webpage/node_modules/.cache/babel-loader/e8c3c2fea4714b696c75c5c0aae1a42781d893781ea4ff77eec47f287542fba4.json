{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@deck.gl/core';\nimport IconLayer from \"../../icon-layer/icon-layer.js\";\nimport { sdfUniforms } from \"./sdf-uniforms.js\";\nimport fs from \"./multi-icon-layer-fragment.glsl.js\";\n// TODO expose as layer properties\nconst DEFAULT_BUFFER = 192.0 / 256;\nconst EMPTY_ARRAY = [];\nconst defaultProps = {\n  getIconOffsets: {\n    type: 'accessor',\n    value: x => x.offsets\n  },\n  alphaCutoff: 0.001,\n  smoothing: 0.1,\n  outlineWidth: 0,\n  outlineColor: {\n    type: 'color',\n    value: [0, 0, 0, 255]\n  }\n};\nclass MultiIconLayer extends IconLayer {\n  getShaders() {\n    const shaders = super.getShaders();\n    return {\n      ...shaders,\n      modules: [...shaders.modules, sdfUniforms],\n      fs\n    };\n  }\n  initializeState() {\n    super.initializeState();\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instanceOffsets: {\n        size: 2,\n        accessor: 'getIconOffsets'\n      },\n      instancePickingColors: {\n        type: 'uint8',\n        size: 3,\n        accessor: (object, {\n          index,\n          target: value\n        }) => this.encodePickingColor(index, value)\n      }\n    });\n  }\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps\n    } = params;\n    let {\n      outlineColor\n    } = props;\n    if (outlineColor !== oldProps.outlineColor) {\n      outlineColor = outlineColor.map(x => x / 255);\n      outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;\n      this.setState({\n        outlineColor\n      });\n    }\n    if (!props.sdf && props.outlineWidth) {\n      log.warn(`${this.id}: fontSettings.sdf is required to render outline`)();\n    }\n  }\n  draw(params) {\n    const {\n      sdf,\n      smoothing,\n      outlineWidth\n    } = this.props;\n    const {\n      outlineColor\n    } = this.state;\n    const outlineBuffer = outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER * (1 - outlineWidth)) : -1;\n    const model = this.state.model;\n    const sdfProps = {\n      buffer: DEFAULT_BUFFER,\n      outlineBuffer,\n      gamma: smoothing,\n      enabled: Boolean(sdf),\n      outlineColor\n    };\n    model.shaderInputs.setProps({\n      sdf: sdfProps\n    });\n    super.draw(params);\n    // draw text without outline on top to ensure a thick outline won't occlude other characters\n    if (sdf && outlineWidth) {\n      const {\n        iconManager\n      } = this.state;\n      const iconsTexture = iconManager.getTexture();\n      if (iconsTexture) {\n        model.shaderInputs.setProps({\n          sdf: {\n            ...sdfProps,\n            outlineBuffer: DEFAULT_BUFFER\n          }\n        });\n        model.draw(this.context.renderPass);\n      }\n    }\n  }\n  getInstanceOffset(icons) {\n    return icons ? Array.from(icons).flatMap(icon => super.getInstanceOffset(icon)) : EMPTY_ARRAY;\n  }\n  getInstanceColorMode(icons) {\n    return 1; // mask\n  }\n  getInstanceIconFrame(icons) {\n    return icons ? Array.from(icons).flatMap(icon => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY;\n  }\n}\nMultiIconLayer.defaultProps = defaultProps;\nMultiIconLayer.layerName = 'MultiIconLayer';\nexport default MultiIconLayer;","map":{"version":3,"names":["log","IconLayer","sdfUniforms","fs","DEFAULT_BUFFER","EMPTY_ARRAY","defaultProps","getIconOffsets","type","value","x","offsets","alphaCutoff","smoothing","outlineWidth","outlineColor","MultiIconLayer","getShaders","shaders","modules","initializeState","attributeManager","getAttributeManager","addInstanced","instanceOffsets","size","accessor","instancePickingColors","object","index","target","encodePickingColor","updateState","params","props","oldProps","map","Number","isFinite","setState","sdf","warn","id","draw","state","outlineBuffer","Math","max","model","sdfProps","buffer","gamma","enabled","Boolean","shaderInputs","setProps","iconManager","iconsTexture","getTexture","context","renderPass","getInstanceOffset","icons","Array","from","flatMap","icon","getInstanceColorMode","getInstanceIconFrame","layerName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\layers\\src\\text-layer\\multi-icon-layer\\multi-icon-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {log} from '@deck.gl/core';\nimport IconLayer from '../../icon-layer/icon-layer';\n\nimport {SdfProps, sdfUniforms} from './sdf-uniforms';\nimport fs from './multi-icon-layer-fragment.glsl';\n\nimport type {IconLayerProps} from '../../icon-layer/icon-layer';\nimport type {Accessor, Color, UpdateParameters, DefaultProps} from '@deck.gl/core';\n\n// TODO expose as layer properties\nconst DEFAULT_BUFFER = 192.0 / 256;\nconst EMPTY_ARRAY = [];\n\ntype _MultiIconLayerProps<DataT> = {\n  getIconOffsets?: Accessor<DataT, number[]>;\n  sdf?: boolean;\n  smoothing?: number;\n  outlineWidth?: number;\n  outlineColor?: Color;\n};\n\nexport type MultiIconLayerProps<DataT = unknown> = _MultiIconLayerProps<DataT> &\n  IconLayerProps<DataT>;\n\nconst defaultProps: DefaultProps<MultiIconLayerProps> = {\n  getIconOffsets: {type: 'accessor', value: (x: any) => x.offsets},\n  alphaCutoff: 0.001,\n  smoothing: 0.1,\n  outlineWidth: 0,\n  outlineColor: {type: 'color', value: [0, 0, 0, 255]}\n};\n\nexport default class MultiIconLayer<DataT, ExtraPropsT extends {} = {}> extends IconLayer<\n  DataT,\n  ExtraPropsT & Required<_MultiIconLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'MultiIconLayer';\n\n  state!: IconLayer['state'] & {\n    outlineColor: [number, number, number, number];\n  };\n\n  getShaders() {\n    const shaders = super.getShaders();\n    return {...shaders, modules: [...shaders.modules, sdfUniforms], fs};\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager();\n    attributeManager!.addInstanced({\n      instanceOffsets: {\n        size: 2,\n        accessor: 'getIconOffsets'\n      },\n      instancePickingColors: {\n        type: 'uint8',\n        size: 3,\n        accessor: (object, {index, target: value}) => this.encodePickingColor(index, value)\n      }\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n    const {props, oldProps} = params;\n    let {outlineColor} = props;\n\n    if (outlineColor !== oldProps.outlineColor) {\n      outlineColor = outlineColor.map(x => x / 255) as Color;\n      outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;\n\n      this.setState({\n        outlineColor\n      });\n    }\n    if (!props.sdf && props.outlineWidth) {\n      log.warn(`${this.id}: fontSettings.sdf is required to render outline`)();\n    }\n  }\n\n  draw(params) {\n    const {sdf, smoothing, outlineWidth} = this.props;\n    const {outlineColor} = this.state;\n    const outlineBuffer = outlineWidth\n      ? Math.max(smoothing, DEFAULT_BUFFER * (1 - outlineWidth))\n      : -1;\n\n    const model = this.state.model!;\n    const sdfProps: SdfProps = {\n      buffer: DEFAULT_BUFFER,\n      outlineBuffer,\n      gamma: smoothing,\n      enabled: Boolean(sdf),\n      outlineColor\n    };\n    model.shaderInputs.setProps({sdf: sdfProps});\n    super.draw(params);\n\n    // draw text without outline on top to ensure a thick outline won't occlude other characters\n    if (sdf && outlineWidth) {\n      const {iconManager} = this.state;\n      const iconsTexture = iconManager.getTexture();\n\n      if (iconsTexture) {\n        model.shaderInputs.setProps({sdf: {...sdfProps, outlineBuffer: DEFAULT_BUFFER}});\n        model.draw(this.context.renderPass);\n      }\n    }\n  }\n\n  protected getInstanceOffset(icons: string): number[] {\n    return icons ? Array.from(icons).flatMap(icon => super.getInstanceOffset(icon)) : EMPTY_ARRAY;\n  }\n\n  getInstanceColorMode(icons: string): number {\n    return 1; // mask\n  }\n\n  getInstanceIconFrame(icons: string): number[] {\n    return icons\n      ? Array.from(icons).flatMap(icon => super.getInstanceIconFrame(icon))\n      : EMPTY_ARRAY;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}