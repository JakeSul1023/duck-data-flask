{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { COORDINATE_SYSTEM, project32, Viewport, _deepEqual } from '@deck.gl/core';\nimport { PathLayer, SolidPolygonLayer } from '@deck.gl/layers';\nimport { WebGLAggregator, CPUAggregator } from \"../common/aggregator/index.js\";\nimport AggregationLayer from \"../common/aggregation-layer.js\";\nimport { generateContours } from \"./contour-utils.js\";\nimport { getAggregatorValueReader } from \"./value-reader.js\";\nimport { getBinIdRange } from \"../common/utils/bounds-utils.js\";\nimport { Matrix4 } from '@math.gl/core';\nimport { binOptionsUniforms } from \"./bin-options-uniforms.js\";\nconst DEFAULT_COLOR = [255, 255, 255, 255];\nconst DEFAULT_STROKE_WIDTH = 1;\nconst defaultProps = {\n  // grid aggregation\n  cellSize: {\n    type: 'number',\n    min: 1,\n    value: 1000\n  },\n  gridOrigin: {\n    type: 'array',\n    compare: true,\n    value: [0, 0]\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  gpuAggregation: true,\n  aggregation: 'SUM',\n  // contour lines\n  contours: {\n    type: 'object',\n    value: [{\n      threshold: 1\n    }],\n    optional: true,\n    compare: 3\n  },\n  zOffset: 0.005\n};\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\nclass GridLayer extends AggregationLayer {\n  getAggregatorType() {\n    return this.props.gpuAggregation && WebGLAggregator.isSupported(this.context.device) ? 'gpu' : 'cpu';\n  }\n  createAggregator(type) {\n    if (type === 'cpu') {\n      return new CPUAggregator({\n        dimensions: 2,\n        getBin: {\n          sources: ['positions'],\n          getValue: ({\n            positions\n          }, index, opts) => {\n            const viewport = this.state.aggregatorViewport;\n            // project to common space\n            const p = viewport.projectPosition(positions);\n            const {\n              cellSizeCommon,\n              cellOriginCommon\n            } = opts;\n            return [Math.floor((p[0] - cellOriginCommon[0]) / cellSizeCommon[0]), Math.floor((p[1] - cellOriginCommon[1]) / cellSizeCommon[1])];\n          }\n        },\n        getValue: [{\n          sources: ['counts'],\n          getValue: ({\n            counts\n          }) => counts\n        }],\n        onUpdate: this._onAggregationUpdate.bind(this)\n      });\n    }\n    return new WebGLAggregator(this.context.device, {\n      dimensions: 2,\n      channelCount: 1,\n      bufferLayout: this.getAttributeManager().getBufferLayouts({\n        isInstanced: false\n      }),\n      ...super.getShaders({\n        modules: [project32, binOptionsUniforms],\n        vs: /* glsl */`\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float counts;\n\n  void getBin(out ivec2 binId) {\n    vec3 positionCommon = project_position(positions, positions64Low);\n    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);\n    binId = ivec2(gridCoords);\n  }\n  void getValue(out float value) {\n    value = counts;\n  }\n  `\n      }),\n      onUpdate: this._onAggregationUpdate.bind(this)\n    });\n  }\n  initializeState() {\n    super.initializeState();\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 'float64',\n        fp64: this.use64bitPositions()\n      },\n      counts: {\n        size: 1,\n        accessor: 'getWeight'\n      }\n    });\n  }\n  updateState(params) {\n    const aggregatorChanged = super.updateState(params);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const {\n      aggregator\n    } = this.state;\n    if (aggregatorChanged || changeFlags.dataChanged || props.cellSize !== oldProps.cellSize || !_deepEqual(props.gridOrigin, oldProps.gridOrigin, 1) || props.aggregation !== oldProps.aggregation) {\n      this._updateBinOptions();\n      const {\n        cellSizeCommon,\n        cellOriginCommon,\n        binIdRange\n      } = this.state;\n      aggregator.setProps({\n        // @ts-expect-error only used by GPUAggregator\n        binIdRange,\n        pointCount: this.getNumInstances(),\n        operations: [props.aggregation],\n        binOptions: {\n          cellSizeCommon,\n          cellOriginCommon\n        }\n      });\n    }\n    if (!_deepEqual(oldProps.contours, props.contours, 2)) {\n      // Recalculate contours\n      this.setState({\n        contourData: null\n      });\n    }\n    return aggregatorChanged;\n  }\n  _updateBinOptions() {\n    const bounds = this.getBounds();\n    const cellSizeCommon = [1, 1];\n    let cellOriginCommon = [0, 0];\n    let binIdRange = [[0, 1], [0, 1]];\n    let viewport = this.context.viewport;\n    if (bounds && Number.isFinite(bounds[0][0])) {\n      let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];\n      const {\n        cellSize,\n        gridOrigin\n      } = this.props;\n      const {\n        unitsPerMeter\n      } = viewport.getDistanceScales(centroid);\n      cellSizeCommon[0] = unitsPerMeter[0] * cellSize;\n      cellSizeCommon[1] = unitsPerMeter[1] * cellSize;\n      // Offset common space to center at the origin of the grid cell where the data center is in\n      // This improves precision without affecting the cell positions\n      const centroidCommon = viewport.projectFlat(centroid);\n      cellOriginCommon = [Math.floor((centroidCommon[0] - gridOrigin[0]) / cellSizeCommon[0]) * cellSizeCommon[0] + gridOrigin[0], Math.floor((centroidCommon[1] - gridOrigin[1]) / cellSizeCommon[1]) * cellSizeCommon[1] + gridOrigin[1]];\n      centroid = viewport.unprojectFlat(cellOriginCommon);\n      const ViewportType = viewport.constructor;\n      // We construct a viewport for the GPU aggregator's project module\n      // This viewport is determined by data\n      // removes arbitrary precision variance that depends on initial view state\n      viewport = viewport.isGeospatial ? new ViewportType({\n        longitude: centroid[0],\n        latitude: centroid[1],\n        zoom: 12\n      }) : new Viewport({\n        position: [centroid[0], centroid[1], 0],\n        zoom: 12\n      });\n      // Round to the nearest 32-bit float to match CPU and GPU results\n      cellOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];\n      binIdRange = getBinIdRange({\n        dataBounds: bounds,\n        getBinId: p => {\n          const positionCommon = viewport.projectFlat(p);\n          return [Math.floor((positionCommon[0] - cellOriginCommon[0]) / cellSizeCommon[0]), Math.floor((positionCommon[1] - cellOriginCommon[1]) / cellSizeCommon[1])];\n        }\n      });\n    }\n    this.setState({\n      cellSizeCommon,\n      cellOriginCommon,\n      binIdRange,\n      aggregatorViewport: viewport\n    });\n  }\n  draw(opts) {\n    // Replaces render time viewport with our own\n    if (opts.shaderModuleProps.project) {\n      opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;\n    }\n    super.draw(opts);\n  }\n  _onAggregationUpdate() {\n    const {\n      aggregator,\n      binIdRange\n    } = this.state;\n    this.setState({\n      aggregatedValueReader: getAggregatorValueReader({\n        aggregator,\n        binIdRange,\n        channel: 0\n      }),\n      contourData: null\n    });\n  }\n  _getContours() {\n    const {\n      aggregatedValueReader\n    } = this.state;\n    if (!aggregatedValueReader) {\n      return null;\n    }\n    if (!this.state.contourData) {\n      const {\n        binIdRange\n      } = this.state;\n      const {\n        contours\n      } = this.props;\n      const contourData = generateContours({\n        contours,\n        getValue: aggregatedValueReader,\n        xRange: binIdRange[0],\n        yRange: binIdRange[1]\n      });\n      this.state.contourData = contourData;\n    }\n    return this.state.contourData;\n  }\n  onAttributeChange(id) {\n    const {\n      aggregator\n    } = this.state;\n    switch (id) {\n      case 'positions':\n        aggregator.setNeedsUpdate();\n        this._updateBinOptions();\n        const {\n          cellSizeCommon,\n          cellOriginCommon,\n          binIdRange\n        } = this.state;\n        aggregator.setProps({\n          // @ts-expect-error only used by GPUAggregator\n          binIdRange,\n          binOptions: {\n            cellSizeCommon,\n            cellOriginCommon\n          }\n        });\n        break;\n      case 'counts':\n        aggregator.setNeedsUpdate(0);\n        break;\n      default:\n      // This should not happen\n    }\n  }\n  renderLayers() {\n    const contourData = this._getContours();\n    if (!contourData) {\n      return null;\n    }\n    const {\n      lines,\n      polygons\n    } = contourData;\n    const {\n      zOffset\n    } = this.props;\n    const {\n      cellOriginCommon,\n      cellSizeCommon\n    } = this.state;\n    const LinesSubLayerClass = this.getSubLayerClass('lines', PathLayer);\n    const BandsSubLayerClass = this.getSubLayerClass('bands', SolidPolygonLayer);\n    const modelMatrix = new Matrix4().translate([cellOriginCommon[0], cellOriginCommon[1], 0]).scale([cellSizeCommon[0], cellSizeCommon[1], zOffset]);\n    // Contour lines layer\n    const lineLayer = lines && lines.length > 0 && new LinesSubLayerClass(this.getSubLayerProps({\n      id: 'lines'\n    }), {\n      data: lines,\n      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n      modelMatrix,\n      getPath: d => d.vertices,\n      getColor: d => d.contour.color ?? DEFAULT_COLOR,\n      getWidth: d => d.contour.strokeWidth ?? DEFAULT_STROKE_WIDTH,\n      widthUnits: 'pixels'\n    });\n    // Contour bands layer\n    const bandsLayer = polygons && polygons.length > 0 && new BandsSubLayerClass(this.getSubLayerProps({\n      id: 'bands'\n    }), {\n      data: polygons,\n      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n      modelMatrix,\n      getPolygon: d => d.vertices,\n      getFillColor: d => d.contour.color ?? DEFAULT_COLOR\n    });\n    return [lineLayer, bandsLayer];\n  }\n  getPickingInfo(params) {\n    const info = params.info;\n    const {\n      object\n    } = info;\n    if (object) {\n      info.object = {\n        contour: object.contour\n      };\n    }\n    return info;\n  }\n}\nGridLayer.layerName = 'ContourLayer';\nGridLayer.defaultProps = defaultProps;\nexport default GridLayer;","map":{"version":3,"names":["COORDINATE_SYSTEM","project32","Viewport","_deepEqual","PathLayer","SolidPolygonLayer","WebGLAggregator","CPUAggregator","AggregationLayer","generateContours","getAggregatorValueReader","getBinIdRange","Matrix4","binOptionsUniforms","DEFAULT_COLOR","DEFAULT_STROKE_WIDTH","defaultProps","cellSize","type","min","value","gridOrigin","compare","getPosition","x","position","getWeight","gpuAggregation","aggregation","contours","threshold","optional","zOffset","GridLayer","getAggregatorType","props","isSupported","context","device","createAggregator","dimensions","getBin","sources","getValue","positions","index","opts","viewport","state","aggregatorViewport","p","projectPosition","cellSizeCommon","cellOriginCommon","Math","floor","counts","onUpdate","_onAggregationUpdate","bind","channelCount","bufferLayout","getAttributeManager","getBufferLayouts","isInstanced","getShaders","modules","vs","initializeState","attributeManager","add","size","accessor","fp64","use64bitPositions","updateState","params","aggregatorChanged","oldProps","changeFlags","aggregator","dataChanged","_updateBinOptions","binIdRange","setProps","pointCount","getNumInstances","operations","binOptions","setState","contourData","bounds","getBounds","Number","isFinite","centroid","unitsPerMeter","getDistanceScales","centroidCommon","projectFlat","unprojectFlat","ViewportType","constructor","isGeospatial","longitude","latitude","zoom","fround","center","dataBounds","getBinId","positionCommon","draw","shaderModuleProps","project","aggregatedValueReader","channel","_getContours","xRange","yRange","onAttributeChange","id","setNeedsUpdate","renderLayers","lines","polygons","LinesSubLayerClass","getSubLayerClass","BandsSubLayerClass","modelMatrix","translate","scale","lineLayer","length","getSubLayerProps","data","coordinateSystem","CARTESIAN","getPath","d","vertices","getColor","contour","color","getWidth","strokeWidth","widthUnits","bandsLayer","getPolygon","getFillColor","getPickingInfo","info","object","layerName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\aggregation-layers\\src\\contour-layer\\contour-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  Accessor,\n  COORDINATE_SYSTEM,\n  GetPickingInfoParams,\n  project32,\n  LayersList,\n  PickingInfo,\n  Position,\n  Viewport,\n  _deepEqual,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport {PathLayer, SolidPolygonLayer} from '@deck.gl/layers';\nimport {WebGLAggregator, CPUAggregator, AggregationOperation} from '../common/aggregator/index';\nimport AggregationLayer from '../common/aggregation-layer';\nimport {AggregationLayerProps} from '../common/aggregation-layer';\nimport {generateContours, Contour, ContourLine, ContourPolygon} from './contour-utils';\nimport {getAggregatorValueReader} from './value-reader';\nimport {getBinIdRange} from '../common/utils/bounds-utils';\nimport {Matrix4} from '@math.gl/core';\nimport {BinOptions, binOptionsUniforms} from './bin-options-uniforms';\n\nconst DEFAULT_COLOR = [255, 255, 255, 255];\nconst DEFAULT_STROKE_WIDTH = 1;\n\nconst defaultProps: DefaultProps<ContourLayerProps> = {\n  // grid aggregation\n  cellSize: {type: 'number', min: 1, value: 1000},\n  gridOrigin: {type: 'array', compare: true, value: [0, 0]},\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\n  getWeight: {type: 'accessor', value: 1},\n  gpuAggregation: true,\n  aggregation: 'SUM',\n\n  // contour lines\n  contours: {\n    type: 'object',\n    value: [{threshold: 1}],\n    optional: true,\n    compare: 3\n  },\n\n  zOffset: 0.005\n};\n\n/** All properties supported by GridLayer. */\nexport type ContourLayerProps<DataT = unknown> = _ContourLayerProps<DataT> &\n  AggregationLayerProps<DataT>;\n\n/** Properties added by GridLayer. */\ntype _ContourLayerProps<DataT> = {\n  /**\n   * Size of each cell in meters.\n   * @default 1000\n   */\n  cellSize?: number;\n\n  /**\n   * The grid origin\n   * @default [0, 0]\n   */\n  gridOrigin?: [number, number];\n\n  /**\n   * When set to true, aggregation is performed on GPU, provided other conditions are met.\n   * @default false\n   */\n  gpuAggregation?: boolean;\n\n  /**\n   * Defines the type of aggregation operation, valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'.\n   * @default 'SUM'\n   */\n  aggregation?: AggregationOperation;\n\n  /**\n   * Definition of contours to be drawn.\n   * @default [{threshold: 1}]\n   */\n  contours?: Contour[];\n\n  /**\n   * A very small z offset that is added for each vertex of a contour (Isoline or Isoband).\n   * @default 0.005\n   */\n  zOffset?: number;\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: Accessor<DataT, Position>;\n\n  /**\n   * The weight of each object.\n   * @default 1\n   */\n  getWeight?: Accessor<DataT, number>;\n};\n\nexport type ContourLayerPickingInfo = PickingInfo<{\n  contour: Contour;\n}>;\n\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\nexport default class GridLayer<DataT = any, ExtraPropsT extends {} = {}> extends AggregationLayer<\n  DataT,\n  ExtraPropsT & Required<_ContourLayerProps<DataT>>\n> {\n  static layerName = 'ContourLayer';\n  static defaultProps = defaultProps;\n\n  state!: AggregationLayer<DataT>['state'] &\n    BinOptions & {\n      // Aggregator result\n      aggregatedValueReader?: (x: number, y: number) => number;\n      contourData?: {\n        lines: ContourLine[];\n        polygons: ContourPolygon[];\n      };\n\n      binIdRange: [number, number][];\n      aggregatorViewport: Viewport;\n    };\n\n  getAggregatorType(): string {\n    return this.props.gpuAggregation && WebGLAggregator.isSupported(this.context.device)\n      ? 'gpu'\n      : 'cpu';\n  }\n\n  createAggregator(type: string): WebGLAggregator | CPUAggregator {\n    if (type === 'cpu') {\n      return new CPUAggregator({\n        dimensions: 2,\n        getBin: {\n          sources: ['positions'],\n          getValue: ({positions}: {positions: number[]}, index: number, opts: BinOptions) => {\n            const viewport = this.state.aggregatorViewport;\n            // project to common space\n            const p = viewport.projectPosition(positions);\n            const {cellSizeCommon, cellOriginCommon} = opts;\n            return [\n              Math.floor((p[0] - cellOriginCommon[0]) / cellSizeCommon[0]),\n              Math.floor((p[1] - cellOriginCommon[1]) / cellSizeCommon[1])\n            ];\n          }\n        },\n        getValue: [{sources: ['counts'], getValue: ({counts}) => counts}],\n        onUpdate: this._onAggregationUpdate.bind(this)\n      });\n    }\n    return new WebGLAggregator(this.context.device, {\n      dimensions: 2,\n      channelCount: 1,\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts({isInstanced: false}),\n      ...super.getShaders({\n        modules: [project32, binOptionsUniforms],\n        vs: /* glsl */ `\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float counts;\n\n  void getBin(out ivec2 binId) {\n    vec3 positionCommon = project_position(positions, positions64Low);\n    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);\n    binId = ivec2(gridCoords);\n  }\n  void getValue(out float value) {\n    value = counts;\n  }\n  `\n      }),\n      onUpdate: this._onAggregationUpdate.bind(this)\n    });\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      positions: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 'float64',\n        fp64: this.use64bitPositions()\n      },\n      counts: {size: 1, accessor: 'getWeight'}\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    const aggregatorChanged = super.updateState(params);\n\n    const {props, oldProps, changeFlags} = params;\n    const {aggregator} = this.state;\n    if (\n      aggregatorChanged ||\n      changeFlags.dataChanged ||\n      props.cellSize !== oldProps.cellSize ||\n      !_deepEqual(props.gridOrigin, oldProps.gridOrigin, 1) ||\n      props.aggregation !== oldProps.aggregation\n    ) {\n      this._updateBinOptions();\n      const {cellSizeCommon, cellOriginCommon, binIdRange} = this.state;\n\n      aggregator.setProps({\n        // @ts-expect-error only used by GPUAggregator\n        binIdRange,\n        pointCount: this.getNumInstances(),\n        operations: [props.aggregation],\n        binOptions: {\n          cellSizeCommon,\n          cellOriginCommon\n        }\n      });\n    }\n\n    if (!_deepEqual(oldProps.contours, props.contours, 2)) {\n      // Recalculate contours\n      this.setState({contourData: null});\n    }\n\n    return aggregatorChanged;\n  }\n\n  private _updateBinOptions() {\n    const bounds = this.getBounds();\n    const cellSizeCommon: [number, number] = [1, 1];\n    let cellOriginCommon: [number, number] = [0, 0];\n    let binIdRange: [number, number][] = [\n      [0, 1],\n      [0, 1]\n    ];\n    let viewport = this.context.viewport;\n\n    if (bounds && Number.isFinite(bounds[0][0])) {\n      let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];\n      const {cellSize, gridOrigin} = this.props;\n      const {unitsPerMeter} = viewport.getDistanceScales(centroid);\n      cellSizeCommon[0] = unitsPerMeter[0] * cellSize;\n      cellSizeCommon[1] = unitsPerMeter[1] * cellSize;\n\n      // Offset common space to center at the origin of the grid cell where the data center is in\n      // This improves precision without affecting the cell positions\n      const centroidCommon = viewport.projectFlat(centroid);\n      cellOriginCommon = [\n        Math.floor((centroidCommon[0] - gridOrigin[0]) / cellSizeCommon[0]) * cellSizeCommon[0] +\n          gridOrigin[0],\n        Math.floor((centroidCommon[1] - gridOrigin[1]) / cellSizeCommon[1]) * cellSizeCommon[1] +\n          gridOrigin[1]\n      ];\n      centroid = viewport.unprojectFlat(cellOriginCommon);\n\n      const ViewportType = viewport.constructor as any;\n      // We construct a viewport for the GPU aggregator's project module\n      // This viewport is determined by data\n      // removes arbitrary precision variance that depends on initial view state\n      viewport = viewport.isGeospatial\n        ? new ViewportType({longitude: centroid[0], latitude: centroid[1], zoom: 12})\n        : new Viewport({position: [centroid[0], centroid[1], 0], zoom: 12});\n\n      // Round to the nearest 32-bit float to match CPU and GPU results\n      cellOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];\n\n      binIdRange = getBinIdRange({\n        dataBounds: bounds,\n        getBinId: (p: number[]) => {\n          const positionCommon = viewport.projectFlat(p);\n          return [\n            Math.floor((positionCommon[0] - cellOriginCommon[0]) / cellSizeCommon[0]),\n            Math.floor((positionCommon[1] - cellOriginCommon[1]) / cellSizeCommon[1])\n          ];\n        }\n      });\n    }\n\n    this.setState({cellSizeCommon, cellOriginCommon, binIdRange, aggregatorViewport: viewport});\n  }\n\n  override draw(opts) {\n    // Replaces render time viewport with our own\n    if (opts.shaderModuleProps.project) {\n      opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;\n    }\n    super.draw(opts);\n  }\n\n  private _onAggregationUpdate() {\n    const {aggregator, binIdRange} = this.state;\n    this.setState({\n      aggregatedValueReader: getAggregatorValueReader({aggregator, binIdRange, channel: 0}),\n      contourData: null\n    });\n  }\n\n  private _getContours(): {\n    lines: ContourLine[];\n    polygons: ContourPolygon[];\n  } | null {\n    const {aggregatedValueReader} = this.state;\n    if (!aggregatedValueReader) {\n      return null;\n    }\n\n    if (!this.state.contourData) {\n      const {binIdRange} = this.state;\n      const {contours} = this.props;\n      const contourData = generateContours({\n        contours,\n        getValue: aggregatedValueReader,\n        xRange: binIdRange[0],\n        yRange: binIdRange[1]\n      });\n\n      this.state.contourData = contourData;\n    }\n    return this.state.contourData;\n  }\n\n  onAttributeChange(id: string) {\n    const {aggregator} = this.state;\n    switch (id) {\n      case 'positions':\n        aggregator.setNeedsUpdate();\n\n        this._updateBinOptions();\n        const {cellSizeCommon, cellOriginCommon, binIdRange} = this.state;\n        aggregator.setProps({\n          // @ts-expect-error only used by GPUAggregator\n          binIdRange,\n          binOptions: {\n            cellSizeCommon,\n            cellOriginCommon\n          }\n        });\n        break;\n\n      case 'counts':\n        aggregator.setNeedsUpdate(0);\n        break;\n\n      default:\n      // This should not happen\n    }\n  }\n\n  renderLayers(): LayersList | null {\n    const contourData = this._getContours();\n    if (!contourData) {\n      return null;\n    }\n    const {lines, polygons} = contourData;\n    const {zOffset} = this.props;\n    const {cellOriginCommon, cellSizeCommon} = this.state;\n\n    const LinesSubLayerClass = this.getSubLayerClass('lines', PathLayer);\n    const BandsSubLayerClass = this.getSubLayerClass('bands', SolidPolygonLayer);\n    const modelMatrix = new Matrix4()\n      .translate([cellOriginCommon[0], cellOriginCommon[1], 0])\n      .scale([cellSizeCommon[0], cellSizeCommon[1], zOffset]);\n\n    // Contour lines layer\n    const lineLayer =\n      lines &&\n      lines.length > 0 &&\n      new LinesSubLayerClass(\n        this.getSubLayerProps({\n          id: 'lines'\n        }),\n        {\n          data: lines,\n          coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n          modelMatrix,\n          getPath: d => d.vertices,\n          getColor: d => d.contour.color ?? DEFAULT_COLOR,\n          getWidth: d => d.contour.strokeWidth ?? DEFAULT_STROKE_WIDTH,\n          widthUnits: 'pixels'\n        }\n      );\n\n    // Contour bands layer\n    const bandsLayer =\n      polygons &&\n      polygons.length > 0 &&\n      new BandsSubLayerClass(\n        this.getSubLayerProps({\n          id: 'bands'\n        }),\n        {\n          data: polygons,\n          coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n          modelMatrix,\n          getPolygon: d => d.vertices,\n          getFillColor: d => d.contour.color ?? DEFAULT_COLOR\n        }\n      );\n\n    return [lineLayer, bandsLayer];\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): ContourLayerPickingInfo {\n    const info: ContourLayerPickingInfo = params.info;\n    const {object} = info;\n    if (object) {\n      info.object = {\n        contour: (object as ContourLine | ContourPolygon).contour\n      };\n    }\n\n    return info;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}