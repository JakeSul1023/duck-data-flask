{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getMeshBoundingBox } from '@loaders.gl/schema';\nimport Martini from '@mapbox/martini';\nimport Delatin from \"./delatin/index.js\";\nimport { addSkirt } from \"./helpers/skirt.js\";\n/**\n * Returns generated mesh object from image data\n *\n * @param terrainImage terrain image data\n * @param terrainOptions terrain options\n * @returns mesh object\n */\nexport function makeTerrainMeshFromImage(terrainImage, terrainOptions) {\n  const {\n    meshMaxError,\n    bounds,\n    elevationDecoder\n  } = terrainOptions;\n  const {\n    data,\n    width,\n    height\n  } = terrainImage;\n  let terrain;\n  let mesh;\n  switch (terrainOptions.tesselator) {\n    case 'martini':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      break;\n    case 'delatin':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      break;\n    // auto\n    default:\n      if (width === height && !(height & width - 1)) {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'martini');\n        mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      } else {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'delatin');\n        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      }\n      break;\n  }\n  const {\n    vertices\n  } = mesh;\n  let {\n    triangles\n  } = mesh;\n  let attributes = getMeshAttributes(vertices, terrain, width, height, bounds);\n  // Compute bounding box before adding skirt so that z values are not skewed\n  const boundingBox = getMeshBoundingBox(attributes);\n  if (terrainOptions.skirtHeight) {\n    const {\n      attributes: newAttributes,\n      triangles: newTriangles\n    } = addSkirt(attributes, triangles, terrainOptions.skirtHeight);\n    attributes = newAttributes;\n    triangles = newTriangles;\n  }\n  return {\n    // Data return by this loader implementation\n    loaderData: {\n      header: {}\n    },\n    header: {\n      vertexCount: triangles.length,\n      boundingBox\n    },\n    mode: 4,\n    // TRIANGLES\n    indices: {\n      value: Uint32Array.from(triangles),\n      size: 1\n    },\n    attributes\n  };\n}\n/**\n * Get Martini generated vertices and triangles\n *\n * @param {number} meshMaxError threshold for simplifying mesh\n * @param {number} width width of the input data\n * @param {number[] | Float32Array} terrain elevation data\n * @returns {{vertices: Uint16Array, triangles: Uint32Array}} vertices and triangles data\n */\nfunction getMartiniTileMesh(meshMaxError, width, terrain) {\n  const gridSize = width + 1;\n  const martini = new Martini(gridSize);\n  const tile = martini.createTile(terrain);\n  const {\n    vertices,\n    triangles\n  } = tile.getMesh(meshMaxError);\n  return {\n    vertices,\n    triangles\n  };\n}\n/**\n * Get Delatin generated vertices and triangles\n *\n * @param {number} meshMaxError threshold for simplifying mesh\n * @param {number} width width of the input data array\n * @param {number} height height of the input data array\n * @param {number[] | Float32Array} terrain elevation data\n * @returns {{vertices: number[], triangles: number[]}} vertices and triangles data\n */\nfunction getDelatinTileMesh(meshMaxError, width, height, terrain) {\n  const tin = new Delatin(terrain, width + 1, height + 1);\n  tin.run(meshMaxError);\n  // @ts-expect-error\n  const {\n    coords,\n    triangles\n  } = tin;\n  const vertices = coords;\n  return {\n    vertices,\n    triangles\n  };\n}\nfunction getTerrain(imageData, width, height, elevationDecoder, tesselator) {\n  const {\n    rScaler,\n    bScaler,\n    gScaler,\n    offset\n  } = elevationDecoder;\n  // From Martini demo\n  // https://observablehq.com/@mourner/martin-real-time-rtin-terrain-mesh\n  const terrain = new Float32Array((width + 1) * (height + 1));\n  // decode terrain values\n  for (let i = 0, y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++, i++) {\n      const k = i * 4;\n      const r = imageData[k + 0];\n      const g = imageData[k + 1];\n      const b = imageData[k + 2];\n      terrain[i + y] = r * rScaler + g * gScaler + b * bScaler + offset;\n    }\n  }\n  if (tesselator === 'martini') {\n    // backfill bottom border\n    for (let i = (width + 1) * width, x = 0; x < width; x++, i++) {\n      terrain[i] = terrain[i - width - 1];\n    }\n    // backfill right border\n    for (let i = height, y = 0; y < height + 1; y++, i += height + 1) {\n      terrain[i] = terrain[i - 1];\n    }\n  }\n  return terrain;\n}\nfunction getMeshAttributes(vertices, terrain, width, height, bounds) {\n  const gridSize = width + 1;\n  const numOfVerticies = vertices.length / 2;\n  // vec3. x, y in pixels, z in meters\n  const positions = new Float32Array(numOfVerticies * 3);\n  // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n  const texCoords = new Float32Array(numOfVerticies * 2);\n  const [minX, minY, maxX, maxY] = bounds || [0, 0, width, height];\n  const xScale = (maxX - minX) / width;\n  const yScale = (maxY - minY) / height;\n  for (let i = 0; i < numOfVerticies; i++) {\n    const x = vertices[i * 2];\n    const y = vertices[i * 2 + 1];\n    const pixelIdx = y * gridSize + x;\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = -y * yScale + maxY;\n    positions[3 * i + 2] = terrain[pixelIdx];\n    texCoords[2 * i + 0] = x / width;\n    texCoords[2 * i + 1] = y / height;\n  }\n  return {\n    POSITION: {\n      value: positions,\n      size: 3\n    },\n    TEXCOORD_0: {\n      value: texCoords,\n      size: 2\n    }\n    // NORMAL: {}, - optional, but creates the high poly look with lighting\n  };\n}","map":{"version":3,"names":["getMeshBoundingBox","Martini","Delatin","addSkirt","makeTerrainMeshFromImage","terrainImage","terrainOptions","meshMaxError","bounds","elevationDecoder","data","width","height","terrain","mesh","tesselator","getTerrain","getMartiniTileMesh","getDelatinTileMesh","vertices","triangles","attributes","getMeshAttributes","boundingBox","skirtHeight","newAttributes","newTriangles","loaderData","header","vertexCount","length","mode","indices","value","Uint32Array","from","size","gridSize","martini","tile","createTile","getMesh","tin","run","coords","imageData","rScaler","bScaler","gScaler","offset","Float32Array","i","y","x","k","r","g","b","numOfVerticies","positions","texCoords","minX","minY","maxX","maxY","xScale","yScale","pixelIdx","POSITION","TEXCOORD_0"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/terrain/dist/lib/parse-terrain.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getMeshBoundingBox } from '@loaders.gl/schema';\nimport Martini from '@mapbox/martini';\nimport Delatin from \"./delatin/index.js\";\nimport { addSkirt } from \"./helpers/skirt.js\";\n/**\n * Returns generated mesh object from image data\n *\n * @param terrainImage terrain image data\n * @param terrainOptions terrain options\n * @returns mesh object\n */\nexport function makeTerrainMeshFromImage(terrainImage, terrainOptions) {\n    const { meshMaxError, bounds, elevationDecoder } = terrainOptions;\n    const { data, width, height } = terrainImage;\n    let terrain;\n    let mesh;\n    switch (terrainOptions.tesselator) {\n        case 'martini':\n            terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n            mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n            break;\n        case 'delatin':\n            terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n            mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n            break;\n        // auto\n        default:\n            if (width === height && !(height & (width - 1))) {\n                terrain = getTerrain(data, width, height, elevationDecoder, 'martini');\n                mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n            }\n            else {\n                terrain = getTerrain(data, width, height, elevationDecoder, 'delatin');\n                mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n            }\n            break;\n    }\n    const { vertices } = mesh;\n    let { triangles } = mesh;\n    let attributes = getMeshAttributes(vertices, terrain, width, height, bounds);\n    // Compute bounding box before adding skirt so that z values are not skewed\n    const boundingBox = getMeshBoundingBox(attributes);\n    if (terrainOptions.skirtHeight) {\n        const { attributes: newAttributes, triangles: newTriangles } = addSkirt(attributes, triangles, terrainOptions.skirtHeight);\n        attributes = newAttributes;\n        triangles = newTriangles;\n    }\n    return {\n        // Data return by this loader implementation\n        loaderData: {\n            header: {}\n        },\n        header: {\n            vertexCount: triangles.length,\n            boundingBox\n        },\n        mode: 4, // TRIANGLES\n        indices: { value: Uint32Array.from(triangles), size: 1 },\n        attributes\n    };\n}\n/**\n * Get Martini generated vertices and triangles\n *\n * @param {number} meshMaxError threshold for simplifying mesh\n * @param {number} width width of the input data\n * @param {number[] | Float32Array} terrain elevation data\n * @returns {{vertices: Uint16Array, triangles: Uint32Array}} vertices and triangles data\n */\nfunction getMartiniTileMesh(meshMaxError, width, terrain) {\n    const gridSize = width + 1;\n    const martini = new Martini(gridSize);\n    const tile = martini.createTile(terrain);\n    const { vertices, triangles } = tile.getMesh(meshMaxError);\n    return { vertices, triangles };\n}\n/**\n * Get Delatin generated vertices and triangles\n *\n * @param {number} meshMaxError threshold for simplifying mesh\n * @param {number} width width of the input data array\n * @param {number} height height of the input data array\n * @param {number[] | Float32Array} terrain elevation data\n * @returns {{vertices: number[], triangles: number[]}} vertices and triangles data\n */\nfunction getDelatinTileMesh(meshMaxError, width, height, terrain) {\n    const tin = new Delatin(terrain, width + 1, height + 1);\n    tin.run(meshMaxError);\n    // @ts-expect-error\n    const { coords, triangles } = tin;\n    const vertices = coords;\n    return { vertices, triangles };\n}\nfunction getTerrain(imageData, width, height, elevationDecoder, tesselator) {\n    const { rScaler, bScaler, gScaler, offset } = elevationDecoder;\n    // From Martini demo\n    // https://observablehq.com/@mourner/martin-real-time-rtin-terrain-mesh\n    const terrain = new Float32Array((width + 1) * (height + 1));\n    // decode terrain values\n    for (let i = 0, y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++, i++) {\n            const k = i * 4;\n            const r = imageData[k + 0];\n            const g = imageData[k + 1];\n            const b = imageData[k + 2];\n            terrain[i + y] = r * rScaler + g * gScaler + b * bScaler + offset;\n        }\n    }\n    if (tesselator === 'martini') {\n        // backfill bottom border\n        for (let i = (width + 1) * width, x = 0; x < width; x++, i++) {\n            terrain[i] = terrain[i - width - 1];\n        }\n        // backfill right border\n        for (let i = height, y = 0; y < height + 1; y++, i += height + 1) {\n            terrain[i] = terrain[i - 1];\n        }\n    }\n    return terrain;\n}\nfunction getMeshAttributes(vertices, terrain, width, height, bounds) {\n    const gridSize = width + 1;\n    const numOfVerticies = vertices.length / 2;\n    // vec3. x, y in pixels, z in meters\n    const positions = new Float32Array(numOfVerticies * 3);\n    // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n    const texCoords = new Float32Array(numOfVerticies * 2);\n    const [minX, minY, maxX, maxY] = bounds || [0, 0, width, height];\n    const xScale = (maxX - minX) / width;\n    const yScale = (maxY - minY) / height;\n    for (let i = 0; i < numOfVerticies; i++) {\n        const x = vertices[i * 2];\n        const y = vertices[i * 2 + 1];\n        const pixelIdx = y * gridSize + x;\n        positions[3 * i + 0] = x * xScale + minX;\n        positions[3 * i + 1] = -y * yScale + maxY;\n        positions[3 * i + 2] = terrain[pixelIdx];\n        texCoords[2 * i + 0] = x / width;\n        texCoords[2 * i + 1] = y / height;\n    }\n    return {\n        POSITION: { value: positions, size: 3 },\n        TEXCOORD_0: { value: texCoords, size: 2 }\n        // NORMAL: {}, - optional, but creates the high poly look with lighting\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}