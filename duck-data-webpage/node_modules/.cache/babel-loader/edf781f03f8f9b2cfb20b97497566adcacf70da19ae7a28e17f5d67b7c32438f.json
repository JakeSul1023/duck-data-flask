{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport Transition from \"../transitions/transition.js\";\nconst noop = () => {};\n// Enums cannot be directly exported as they are not transpiled correctly into ES5, see https://github.com/visgl/deck.gl/issues/7130\nexport const TRANSITION_EVENTS = {\n  BREAK: 1,\n  SNAP_TO_END: 2,\n  IGNORE: 3\n};\nconst DEFAULT_EASING = t => t;\nconst DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;\nexport default class TransitionManager {\n  constructor(opts) {\n    this._onTransitionUpdate = transition => {\n      // NOTE: Be cautious re-ordering statements in this function.\n      const {\n        time,\n        settings: {\n          interpolator,\n          startProps,\n          endProps,\n          duration,\n          easing\n        }\n      } = transition;\n      const t = easing(time / duration);\n      const viewport = interpolator.interpolateProps(startProps, endProps, t);\n      // This gurantees all props (e.g. bearing, longitude) are normalized\n      // So when viewports are compared they are in same range.\n      this.propsInTransition = this.getControllerState({\n        ...this.props,\n        ...viewport\n      }).getViewportProps();\n      this.onViewStateChange({\n        viewState: this.propsInTransition,\n        oldViewState: this.props\n      });\n    };\n    this.getControllerState = opts.getControllerState;\n    this.propsInTransition = null;\n    this.transition = new Transition(opts.timeline);\n    this.onViewStateChange = opts.onViewStateChange || noop;\n    this.onStateChange = opts.onStateChange || noop;\n  }\n  finalize() {\n    this.transition.cancel();\n  }\n  // Returns current transitioned viewport.\n  getViewportInTransition() {\n    return this.propsInTransition;\n  }\n  // Process the vewiport change, either ignore or trigger a new transition.\n  // Return true if a new transition is triggered, false otherwise.\n  processViewStateChange(nextProps) {\n    let transitionTriggered = false;\n    const currentProps = this.props;\n    // Set this.props here as '_triggerTransition' calls '_updateViewport' that uses this.props.\n    this.props = nextProps;\n    // NOTE: Be cautious re-ordering statements in this function.\n    if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n      return false;\n    }\n    if (this._isTransitionEnabled(nextProps)) {\n      let startProps = currentProps;\n      if (this.transition.inProgress) {\n        // @ts-expect-error\n        const {\n          interruption,\n          endProps\n        } = this.transition.settings;\n        startProps = {\n          ...currentProps,\n          ...(interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps)\n        };\n      }\n      this._triggerTransition(startProps, nextProps);\n      transitionTriggered = true;\n    } else {\n      this.transition.cancel();\n    }\n    return transitionTriggered;\n  }\n  updateTransition() {\n    this.transition.update();\n  }\n  // Helper methods\n  _isTransitionEnabled(props) {\n    const {\n      transitionDuration,\n      transitionInterpolator\n    } = props;\n    return (transitionDuration > 0 || transitionDuration === 'auto') && Boolean(transitionInterpolator);\n  }\n  _isUpdateDueToCurrentTransition(props) {\n    if (this.transition.inProgress && this.propsInTransition) {\n      // @ts-expect-error\n      return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);\n    }\n    return false;\n  }\n  _shouldIgnoreViewportChange(currentProps, nextProps) {\n    if (this.transition.inProgress) {\n      // @ts-expect-error\n      const transitionSettings = this.transition.settings;\n      // Ignore update if it is requested to be ignored\n      return transitionSettings.interruption === TRANSITION_EVENTS.IGNORE ||\n      // Ignore update if it is due to current active transition.\n      this._isUpdateDueToCurrentTransition(nextProps);\n    }\n    if (this._isTransitionEnabled(nextProps)) {\n      // Ignore if none of the viewport props changed.\n      return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);\n    }\n    return true;\n  }\n  _triggerTransition(startProps, endProps) {\n    const startViewstate = this.getControllerState(startProps);\n    const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);\n    // update transitionDuration for 'auto' mode\n    const transitionInterpolator = endProps.transitionInterpolator;\n    const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;\n    if (duration === 0) {\n      return;\n    }\n    const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);\n    this.propsInTransition = {};\n    const transitionSettings = {\n      duration,\n      easing: endProps.transitionEasing || DEFAULT_EASING,\n      interpolator: transitionInterpolator,\n      interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,\n      startProps: initialProps.start,\n      endProps: initialProps.end,\n      onStart: endProps.onTransitionStart,\n      onUpdate: this._onTransitionUpdate,\n      onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),\n      onEnd: this._onTransitionEnd(endProps.onTransitionEnd)\n    };\n    this.transition.start(transitionSettings);\n    this.onStateChange({\n      inTransition: true\n    });\n    this.updateTransition();\n  }\n  _onTransitionEnd(callback) {\n    return transition => {\n      this.propsInTransition = null;\n      this.onStateChange({\n        inTransition: false,\n        isZooming: false,\n        isPanning: false,\n        isRotating: false\n      });\n      callback?.(transition);\n    };\n  }\n}","map":{"version":3,"names":["Transition","noop","TRANSITION_EVENTS","BREAK","SNAP_TO_END","IGNORE","DEFAULT_EASING","t","DEFAULT_INTERRUPTION","TransitionManager","constructor","opts","_onTransitionUpdate","transition","time","settings","interpolator","startProps","endProps","duration","easing","viewport","interpolateProps","propsInTransition","getControllerState","props","getViewportProps","onViewStateChange","viewState","oldViewState","timeline","onStateChange","finalize","cancel","getViewportInTransition","processViewStateChange","nextProps","transitionTriggered","currentProps","_shouldIgnoreViewportChange","_isTransitionEnabled","inProgress","interruption","_triggerTransition","updateTransition","update","transitionDuration","transitionInterpolator","Boolean","_isUpdateDueToCurrentTransition","arePropsEqual","transitionSettings","startViewstate","endViewStateProps","shortestPathFrom","getDuration","initialProps","initializeProps","transitionEasing","transitionInterruption","start","end","onStart","onTransitionStart","onUpdate","onInterrupt","_onTransitionEnd","onTransitionInterrupt","onEnd","onTransitionEnd","inTransition","callback","isZooming","isPanning","isRotating"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\controllers\\transition-manager.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport Transition, {TransitionSettings as BaseTransitionSettings} from '../transitions/transition';\nimport TransitionInterpolator from '../transitions/transition-interpolator';\nimport type {IViewState} from './view-state';\n\nimport type {Timeline} from '@luma.gl/engine';\nimport type {InteractionState} from './controller';\n\nconst noop = () => {};\n\n// Enums cannot be directly exported as they are not transpiled correctly into ES5, see https://github.com/visgl/deck.gl/issues/7130\nexport const TRANSITION_EVENTS = {\n  BREAK: 1,\n  SNAP_TO_END: 2,\n  IGNORE: 3\n} as const;\n\ntype TransitionEvent = 1 | 2 | 3;\n\nexport type TransitionProps = {\n  /** Transition duration in milliseconds, default value 0, implies no transition. When using `FlyToInterpolator`, it can also be set to `'auto'`. */\n  transitionDuration?: number | 'auto';\n  /** An interpolator object that defines the transition behavior between two viewports. */\n  transitionInterpolator?: TransitionInterpolator;\n  /** Easing function that can be used to achieve effects like \"Ease-In-Cubic\", \"Ease-Out-Cubic\", etc. Default value performs Linear easing. */\n  transitionEasing?: (t: number) => number;\n  /** Controls how to process a new view state change that occurs during an existing transition. */\n  transitionInterruption?: TransitionEvent;\n  /** Callback fired when requested transition starts. */\n  onTransitionStart?: (transition: Transition) => void;\n  /** Callback fired when requested transition is interrupted. */\n  onTransitionInterrupt?: (transition: Transition) => void;\n  /** Callback fired when requested transition ends. */\n  onTransitionEnd?: (transition: Transition) => void;\n};\n\nconst DEFAULT_EASING = t => t;\nconst DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;\n\ntype TransitionSettings = BaseTransitionSettings & {\n  interpolator: TransitionInterpolator;\n  easing: (t: number) => number;\n  interruption: TransitionEvent;\n  startProps: Record<string, any>;\n  endProps: Record<string, any>;\n};\n\nexport default class TransitionManager<ControllerState extends IViewState<ControllerState>> {\n  getControllerState: (props: any) => ControllerState;\n  props?: TransitionProps;\n  propsInTransition: Record<string, any> | null;\n  transition: Transition;\n  onViewStateChange: (params: {\n    viewState: Record<string, any>;\n    oldViewState: Record<string, any>;\n  }) => void;\n  onStateChange: (state: InteractionState) => void;\n\n  constructor(opts: {\n    timeline: Timeline;\n    getControllerState: (props: any) => ControllerState;\n    onViewStateChange?: (params: {\n      viewState: Record<string, any>;\n      oldViewState: Record<string, any>;\n    }) => void;\n    onStateChange?: (state: InteractionState) => void;\n  }) {\n    this.getControllerState = opts.getControllerState;\n    this.propsInTransition = null;\n    this.transition = new Transition(opts.timeline);\n\n    this.onViewStateChange = opts.onViewStateChange || noop;\n    this.onStateChange = opts.onStateChange || noop;\n  }\n\n  finalize(): void {\n    this.transition.cancel();\n  }\n\n  // Returns current transitioned viewport.\n  getViewportInTransition(): Record<string, any> | null {\n    return this.propsInTransition;\n  }\n\n  // Process the vewiport change, either ignore or trigger a new transition.\n  // Return true if a new transition is triggered, false otherwise.\n  processViewStateChange(nextProps: TransitionProps) {\n    let transitionTriggered = false;\n    const currentProps = this.props;\n    // Set this.props here as '_triggerTransition' calls '_updateViewport' that uses this.props.\n    this.props = nextProps;\n\n    // NOTE: Be cautious re-ordering statements in this function.\n    if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n      return false;\n    }\n\n    if (this._isTransitionEnabled(nextProps)) {\n      let startProps = currentProps;\n      if (this.transition.inProgress) {\n        // @ts-expect-error\n        const {interruption, endProps} = this.transition.settings as TransitionSettings;\n        startProps = {\n          ...currentProps,\n          ...(interruption === TRANSITION_EVENTS.SNAP_TO_END\n            ? endProps\n            : this.propsInTransition || currentProps)\n        };\n      }\n\n      this._triggerTransition(startProps, nextProps);\n\n      transitionTriggered = true;\n    } else {\n      this.transition.cancel();\n    }\n\n    return transitionTriggered;\n  }\n\n  updateTransition() {\n    this.transition.update();\n  }\n\n  // Helper methods\n\n  _isTransitionEnabled(props: TransitionProps): boolean {\n    const {transitionDuration, transitionInterpolator} = props;\n    return (\n      ((transitionDuration as number) > 0 || transitionDuration === 'auto') &&\n      Boolean(transitionInterpolator)\n    );\n  }\n\n  _isUpdateDueToCurrentTransition(props: TransitionProps): boolean {\n    if (this.transition.inProgress && this.propsInTransition) {\n      // @ts-expect-error\n      return (this.transition.settings as TransitionSettings).interpolator.arePropsEqual(\n        props,\n        this.propsInTransition\n      );\n    }\n    return false;\n  }\n\n  _shouldIgnoreViewportChange(currentProps: TransitionProps, nextProps: TransitionProps): boolean {\n    if (this.transition.inProgress) {\n      // @ts-expect-error\n      const transitionSettings = this.transition.settings as TransitionSettings;\n      // Ignore update if it is requested to be ignored\n      return (\n        transitionSettings.interruption === TRANSITION_EVENTS.IGNORE ||\n        // Ignore update if it is due to current active transition.\n        this._isUpdateDueToCurrentTransition(nextProps)\n      );\n    }\n    if (this._isTransitionEnabled(nextProps)) {\n      // Ignore if none of the viewport props changed.\n      return (nextProps.transitionInterpolator as TransitionInterpolator).arePropsEqual(\n        currentProps,\n        nextProps\n      );\n    }\n    return true;\n  }\n\n  _triggerTransition(startProps: TransitionProps, endProps: TransitionProps): void {\n    const startViewstate = this.getControllerState(startProps);\n    const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);\n\n    // update transitionDuration for 'auto' mode\n    const transitionInterpolator = endProps.transitionInterpolator as TransitionInterpolator;\n    const duration = transitionInterpolator.getDuration\n      ? transitionInterpolator.getDuration(startProps, endProps)\n      : (endProps.transitionDuration as number);\n\n    if (duration === 0) {\n      return;\n    }\n\n    const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);\n\n    this.propsInTransition = {};\n    const transitionSettings: TransitionSettings = {\n      duration,\n      easing: endProps.transitionEasing || DEFAULT_EASING,\n      interpolator: transitionInterpolator,\n      interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,\n\n      startProps: initialProps.start,\n      endProps: initialProps.end,\n\n      onStart: endProps.onTransitionStart,\n      onUpdate: this._onTransitionUpdate,\n      onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),\n      onEnd: this._onTransitionEnd(endProps.onTransitionEnd)\n    };\n    this.transition.start(transitionSettings);\n\n    this.onStateChange({inTransition: true});\n\n    this.updateTransition();\n  }\n\n  _onTransitionEnd(callback?: (transition: Transition) => void) {\n    return transition => {\n      this.propsInTransition = null;\n\n      this.onStateChange({\n        inTransition: false,\n        isZooming: false,\n        isPanning: false,\n        isRotating: false\n      });\n\n      callback?.(transition);\n    };\n  }\n\n  _onTransitionUpdate = transition => {\n    // NOTE: Be cautious re-ordering statements in this function.\n    const {\n      time,\n      settings: {interpolator, startProps, endProps, duration, easing}\n    } = transition;\n    const t = easing(time / duration);\n    const viewport = interpolator.interpolateProps(startProps, endProps, t);\n\n    // This gurantees all props (e.g. bearing, longitude) are normalized\n    // So when viewports are compared they are in same range.\n    this.propsInTransition = this.getControllerState({\n      ...this.props,\n      ...viewport\n    }).getViewportProps();\n\n    this.onViewStateChange({\n      viewState: this.propsInTransition,\n      oldViewState: this.props as TransitionProps\n    });\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}