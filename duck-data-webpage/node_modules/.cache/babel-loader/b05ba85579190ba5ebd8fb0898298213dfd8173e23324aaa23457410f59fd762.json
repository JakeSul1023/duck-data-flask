{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { COORDINATE_SYSTEM, PROJECTION_MODE } from \"../../lib/constants.js\";\nimport project from \"../project/project.js\";\nimport { Vector3, Matrix4 } from '@math.gl/core';\nimport memoize from \"../../utils/memoize.js\";\nimport { pixelsToWorld } from '@math.gl/web-mercator';\nconst uniformBlock = /* glsl */`\nuniform shadowUniforms {\n  bool drawShadowMap;\n  bool useShadowMap;\n  vec4 color;\n  highp int lightId;\n  float lightCount;\n  mat4 viewProjectionMatrix0;\n  mat4 viewProjectionMatrix1;\n  vec4 projectCenter0;\n  vec4 projectCenter1;\n} shadow;\n`;\nconst vertex = /* glsl */`\nconst int max_lights = 2;\n\nout vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  mat4 viewProjectionMatrices[max_lights];\n  viewProjectionMatrices[0] = shadow.viewProjectionMatrix0;\n  viewProjectionMatrices[1] = shadow.viewProjectionMatrix1;\n  vec4 projectCenters[max_lights];\n  projectCenters[0] = shadow.projectCenter0;\n  projectCenters[1] = shadow.projectCenter1;\n\n  if (shadow.drawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[shadow.lightId], projectCenters[shadow.lightId]);\n  }\n  if (shadow.useShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow.lightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[i], projectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n`;\nconst vs = `\n${uniformBlock}\n${vertex}\n`;\nconst fragment = /* glsl */`\nconst int max_lights = 2;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\n\nin vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow.drawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow.useShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow.lightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow.color.a / shadow.lightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow.color.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n`;\nconst fs = `\n${uniformBlock}\n${fragment}\n`;\nconst getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);\nconst getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);\nconst DEFAULT_SHADOW_COLOR = [0, 0, 0, 1.0];\nconst VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\nfunction screenToCommonSpace(xyz, pixelUnprojectionMatrix) {\n  const [x, y, z] = xyz;\n  const coord = pixelsToWorld([x, y, z], pixelUnprojectionMatrix);\n  if (Number.isFinite(z)) {\n    return coord;\n  }\n  return [coord[0], coord[1], 0];\n}\nfunction getViewportCenterPosition({\n  viewport,\n  center\n}) {\n  return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);\n}\nfunction getViewProjectionMatrices({\n  viewport,\n  shadowMatrices\n}) {\n  const projectionMatrices = [];\n  const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;\n  const farZ = viewport.isGeospatial ? undefined : 1;\n  const corners = [[0, 0, farZ],\n  // top left ground\n  [viewport.width, 0, farZ],\n  // top right ground\n  [0, viewport.height, farZ],\n  // bottom left ground\n  [viewport.width, viewport.height, farZ],\n  // bottom right ground\n  [0, 0, -1],\n  // top left near\n  [viewport.width, 0, -1],\n  // top right near\n  [0, viewport.height, -1],\n  // bottom left near\n  [viewport.width, viewport.height, -1] // bottom right near\n  ].map(pixel =>\n  // @ts-expect-error z may be undefined\n  screenToCommonSpace(pixel, pixelUnprojectionMatrix));\n  for (const shadowMatrix of shadowMatrices) {\n    const viewMatrix = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());\n    const positions = corners.map(corner => viewMatrix.transform(corner));\n    const projectionMatrix = new Matrix4().ortho({\n      left: Math.min(...positions.map(position => position[0])),\n      right: Math.max(...positions.map(position => position[0])),\n      bottom: Math.min(...positions.map(position => position[1])),\n      top: Math.max(...positions.map(position => position[1])),\n      near: Math.min(...positions.map(position => -position[2])),\n      far: Math.max(...positions.map(position => -position[2]))\n    });\n    projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));\n  }\n  return projectionMatrices;\n}\n/* eslint-disable camelcase */\n// eslint-disable-next-line complexity\nfunction createShadowUniforms(opts) {\n  const {\n    shadowEnabled = true,\n    project: projectProps\n  } = opts;\n  if (!shadowEnabled || !projectProps || !opts.shadowMatrices || !opts.shadowMatrices.length) {\n    return {\n      drawShadowMap: false,\n      useShadowMap: false,\n      shadow_uShadowMap0: opts.dummyShadowMap,\n      shadow_uShadowMap1: opts.dummyShadowMap\n    };\n  }\n  const projectUniforms = project.getUniforms(projectProps);\n  const center = getMemoizedViewportCenterPosition({\n    viewport: projectProps.viewport,\n    center: projectUniforms.center\n  });\n  const projectCenters = [];\n  const viewProjectionMatrices = getMemoizedViewProjectionMatrices({\n    shadowMatrices: opts.shadowMatrices,\n    viewport: projectProps.viewport\n  }).slice();\n  for (let i = 0; i < opts.shadowMatrices.length; i++) {\n    const viewProjectionMatrix = viewProjectionMatrices[i];\n    const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new Vector3(projectProps.viewport.center).negate());\n    if (projectUniforms.coordinateSystem === COORDINATE_SYSTEM.LNGLAT && projectUniforms.projectionMode === PROJECTION_MODE.WEB_MERCATOR) {\n      viewProjectionMatrices[i] = viewProjectionMatrixCentered;\n      projectCenters[i] = center;\n    } else {\n      viewProjectionMatrices[i] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX);\n      projectCenters[i] = viewProjectionMatrixCentered.transform(center);\n    }\n  }\n  const uniforms = {\n    drawShadowMap: Boolean(opts.drawToShadowMap),\n    useShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,\n    color: opts.shadowColor || DEFAULT_SHADOW_COLOR,\n    lightId: opts.shadowLightId || 0,\n    lightCount: opts.shadowMatrices.length,\n    shadow_uShadowMap0: opts.dummyShadowMap,\n    shadow_uShadowMap1: opts.dummyShadowMap\n  };\n  for (let i = 0; i < viewProjectionMatrices.length; i++) {\n    uniforms[`viewProjectionMatrix${i}`] = viewProjectionMatrices[i];\n    uniforms[`projectCenter${i}`] = projectCenters[i];\n  }\n  for (let i = 0; i < 2; i++) {\n    uniforms[`shadow_uShadowMap${i}`] = opts.shadowMaps && opts.shadowMaps[i] || opts.dummyShadowMap;\n  }\n  return uniforms;\n}\nexport default {\n  name: 'shadow',\n  dependencies: [project],\n  vs,\n  fs,\n  inject: {\n    'vs:DECKGL_FILTER_GL_POSITION': `\n    position = shadow_setVertexPosition(geometry.position);\n    `,\n    'fs:DECKGL_FILTER_COLOR': `\n    color = shadow_filterShadowColor(color);\n    `\n  },\n  getUniforms: createShadowUniforms,\n  uniformTypes: {\n    drawShadowMap: 'f32',\n    useShadowMap: 'f32',\n    color: 'vec4<f32>',\n    lightId: 'i32',\n    lightCount: 'f32',\n    viewProjectionMatrix0: 'mat4x4<f32>',\n    viewProjectionMatrix1: 'mat4x4<f32>',\n    projectCenter0: 'vec4<f32>',\n    projectCenter1: 'vec4<f32>'\n  }\n};\n//# sourceMappingURL=shadow.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}