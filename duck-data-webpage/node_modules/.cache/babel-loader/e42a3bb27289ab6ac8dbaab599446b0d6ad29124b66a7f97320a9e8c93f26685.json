{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { concatenateTypedArrays } from '@loaders.gl/loader-utils';\n/**\n * Add skirt to existing mesh\n * @param {object} attributes - POSITION and TEXCOOD_0 attributes data\n * @param {any} triangles - indices array of the mesh geometry\n * @param skirtHeight - height of the skirt geometry\n * @param outsideIndices - edge indices from quantized mesh data\n * @returns - geometry data with added skirt\n */\nexport function addSkirt(attributes, triangles, skirtHeight, outsideIndices) {\n  const outsideEdges = outsideIndices ? getOutsideEdgesFromIndices(outsideIndices, attributes.POSITION.value) : getOutsideEdgesFromTriangles(triangles);\n  // 2 new vertices for each outside edge\n  const newPosition = new attributes.POSITION.value.constructor(outsideEdges.length * 6);\n  const newTexcoord0 = new attributes.TEXCOORD_0.value.constructor(outsideEdges.length * 4);\n  // 2 new triangles for each outside edge\n  const newTriangles = new triangles.constructor(outsideEdges.length * 6);\n  for (let i = 0; i < outsideEdges.length; i++) {\n    const edge = outsideEdges[i];\n    updateAttributesForNewEdge({\n      edge,\n      edgeIndex: i,\n      attributes,\n      skirtHeight,\n      newPosition,\n      newTexcoord0,\n      newTriangles\n    });\n  }\n  attributes.POSITION.value = concatenateTypedArrays(attributes.POSITION.value, newPosition);\n  attributes.TEXCOORD_0.value = concatenateTypedArrays(attributes.TEXCOORD_0.value, newTexcoord0);\n  const resultTriangles = triangles instanceof Array ? triangles.concat(newTriangles) : concatenateTypedArrays(triangles, newTriangles);\n  return {\n    attributes,\n    triangles: resultTriangles\n  };\n}\n/**\n * Get geometry edges that located on a border of the mesh\n * @param {any} triangles - indices array of the mesh geometry\n * @returns {number[][]} - outside edges data\n */\nfunction getOutsideEdgesFromTriangles(triangles) {\n  const edges = [];\n  for (let i = 0; i < triangles.length; i += 3) {\n    edges.push([triangles[i], triangles[i + 1]]);\n    edges.push([triangles[i + 1], triangles[i + 2]]);\n    edges.push([triangles[i + 2], triangles[i]]);\n  }\n  edges.sort((a, b) => Math.min(...a) - Math.min(...b) || Math.max(...a) - Math.max(...b));\n  const outsideEdges = [];\n  let index = 0;\n  while (index < edges.length) {\n    if (edges[index][0] === edges[index + 1]?.[1] && edges[index][1] === edges[index + 1]?.[0]) {\n      index += 2;\n    } else {\n      outsideEdges.push(edges[index]);\n      index++;\n    }\n  }\n  return outsideEdges;\n}\n/**\n * Get geometry edges that located on a border of the mesh\n * @param {object} indices - edge indices from quantized mesh data\n * @param {TypedArray} position - position attribute geometry data\n * @returns {number[][]} - outside edges data\n */\nfunction getOutsideEdgesFromIndices(indices, position) {\n  // Sort skirt indices to create adjacent triangles\n  indices.westIndices.sort((a, b) => position[3 * a + 1] - position[3 * b + 1]);\n  // Reverse (b - a) to match triangle winding\n  indices.eastIndices.sort((a, b) => position[3 * b + 1] - position[3 * a + 1]);\n  indices.southIndices.sort((a, b) => position[3 * b] - position[3 * a]);\n  // Reverse (b - a) to match triangle winding\n  indices.northIndices.sort((a, b) => position[3 * a] - position[3 * b]);\n  const edges = [];\n  for (const index in indices) {\n    const indexGroup = indices[index];\n    for (let i = 0; i < indexGroup.length - 1; i++) {\n      edges.push([indexGroup[i], indexGroup[i + 1]]);\n    }\n  }\n  return edges;\n}\n/**\n * Get geometry edges that located on a border of the mesh\n * @param {object} args\n * @param {number[]} args.edge - edge indices in geometry\n * @param {number} args.edgeIndex - edge index in outsideEdges array\n * @param {object} args.attributes - POSITION and TEXCOORD_0 attributes\n * @param {number} args.skirtHeight - height of the skirt geometry\n * @param {TypedArray} args.newPosition - POSITION array for skirt data\n * @param {TypedArray} args.newTexcoord0 - TEXCOORD_0 array for skirt data\n * @param {TypedArray | Array} args.newTriangles - trinagle indices array for skirt data\n * @returns {void}\n */\nfunction updateAttributesForNewEdge({\n  edge,\n  edgeIndex,\n  attributes,\n  skirtHeight,\n  newPosition,\n  newTexcoord0,\n  newTriangles\n}) {\n  const positionsLength = attributes.POSITION.value.length;\n  const vertex1Offset = edgeIndex * 2;\n  const vertex2Offset = edgeIndex * 2 + 1;\n  // Define POSITION for new 1st vertex\n  newPosition.set(attributes.POSITION.value.subarray(edge[0] * 3, edge[0] * 3 + 3), vertex1Offset * 3);\n  newPosition[vertex1Offset * 3 + 2] = newPosition[vertex1Offset * 3 + 2] - skirtHeight; // put down elevation on the skirt height\n  // Define POSITION for new 2nd vertex\n  newPosition.set(attributes.POSITION.value.subarray(edge[1] * 3, edge[1] * 3 + 3), vertex2Offset * 3);\n  newPosition[vertex2Offset * 3 + 2] = newPosition[vertex2Offset * 3 + 2] - skirtHeight; // put down elevation on the skirt height\n  // Use same TEXCOORDS for skirt vertices\n  newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[0] * 2, edge[0] * 2 + 2), vertex1Offset * 2);\n  newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[1] * 2, edge[1] * 2 + 2), vertex2Offset * 2);\n  // Define new triangles\n  const triangle1Offset = edgeIndex * 2 * 3;\n  newTriangles[triangle1Offset] = edge[0];\n  newTriangles[triangle1Offset + 1] = positionsLength / 3 + vertex2Offset;\n  newTriangles[triangle1Offset + 2] = edge[1];\n  newTriangles[triangle1Offset + 3] = positionsLength / 3 + vertex2Offset;\n  newTriangles[triangle1Offset + 4] = edge[0];\n  newTriangles[triangle1Offset + 5] = positionsLength / 3 + vertex1Offset;\n}","map":{"version":3,"names":["concatenateTypedArrays","addSkirt","attributes","triangles","skirtHeight","outsideIndices","outsideEdges","getOutsideEdgesFromIndices","POSITION","value","getOutsideEdgesFromTriangles","newPosition","constructor","length","newTexcoord0","TEXCOORD_0","newTriangles","i","edge","updateAttributesForNewEdge","edgeIndex","resultTriangles","Array","concat","edges","push","sort","a","b","Math","min","max","index","indices","position","westIndices","eastIndices","southIndices","northIndices","indexGroup","positionsLength","vertex1Offset","vertex2Offset","set","subarray","triangle1Offset"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/terrain/dist/lib/helpers/skirt.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { concatenateTypedArrays } from '@loaders.gl/loader-utils';\n/**\n * Add skirt to existing mesh\n * @param {object} attributes - POSITION and TEXCOOD_0 attributes data\n * @param {any} triangles - indices array of the mesh geometry\n * @param skirtHeight - height of the skirt geometry\n * @param outsideIndices - edge indices from quantized mesh data\n * @returns - geometry data with added skirt\n */\nexport function addSkirt(attributes, triangles, skirtHeight, outsideIndices) {\n    const outsideEdges = outsideIndices\n        ? getOutsideEdgesFromIndices(outsideIndices, attributes.POSITION.value)\n        : getOutsideEdgesFromTriangles(triangles);\n    // 2 new vertices for each outside edge\n    const newPosition = new attributes.POSITION.value.constructor(outsideEdges.length * 6);\n    const newTexcoord0 = new attributes.TEXCOORD_0.value.constructor(outsideEdges.length * 4);\n    // 2 new triangles for each outside edge\n    const newTriangles = new triangles.constructor(outsideEdges.length * 6);\n    for (let i = 0; i < outsideEdges.length; i++) {\n        const edge = outsideEdges[i];\n        updateAttributesForNewEdge({\n            edge,\n            edgeIndex: i,\n            attributes,\n            skirtHeight,\n            newPosition,\n            newTexcoord0,\n            newTriangles\n        });\n    }\n    attributes.POSITION.value = concatenateTypedArrays(attributes.POSITION.value, newPosition);\n    attributes.TEXCOORD_0.value = concatenateTypedArrays(attributes.TEXCOORD_0.value, newTexcoord0);\n    const resultTriangles = triangles instanceof Array\n        ? triangles.concat(newTriangles)\n        : concatenateTypedArrays(triangles, newTriangles);\n    return {\n        attributes,\n        triangles: resultTriangles\n    };\n}\n/**\n * Get geometry edges that located on a border of the mesh\n * @param {any} triangles - indices array of the mesh geometry\n * @returns {number[][]} - outside edges data\n */\nfunction getOutsideEdgesFromTriangles(triangles) {\n    const edges = [];\n    for (let i = 0; i < triangles.length; i += 3) {\n        edges.push([triangles[i], triangles[i + 1]]);\n        edges.push([triangles[i + 1], triangles[i + 2]]);\n        edges.push([triangles[i + 2], triangles[i]]);\n    }\n    edges.sort((a, b) => Math.min(...a) - Math.min(...b) || Math.max(...a) - Math.max(...b));\n    const outsideEdges = [];\n    let index = 0;\n    while (index < edges.length) {\n        if (edges[index][0] === edges[index + 1]?.[1] && edges[index][1] === edges[index + 1]?.[0]) {\n            index += 2;\n        }\n        else {\n            outsideEdges.push(edges[index]);\n            index++;\n        }\n    }\n    return outsideEdges;\n}\n/**\n * Get geometry edges that located on a border of the mesh\n * @param {object} indices - edge indices from quantized mesh data\n * @param {TypedArray} position - position attribute geometry data\n * @returns {number[][]} - outside edges data\n */\nfunction getOutsideEdgesFromIndices(indices, position) {\n    // Sort skirt indices to create adjacent triangles\n    indices.westIndices.sort((a, b) => position[3 * a + 1] - position[3 * b + 1]);\n    // Reverse (b - a) to match triangle winding\n    indices.eastIndices.sort((a, b) => position[3 * b + 1] - position[3 * a + 1]);\n    indices.southIndices.sort((a, b) => position[3 * b] - position[3 * a]);\n    // Reverse (b - a) to match triangle winding\n    indices.northIndices.sort((a, b) => position[3 * a] - position[3 * b]);\n    const edges = [];\n    for (const index in indices) {\n        const indexGroup = indices[index];\n        for (let i = 0; i < indexGroup.length - 1; i++) {\n            edges.push([indexGroup[i], indexGroup[i + 1]]);\n        }\n    }\n    return edges;\n}\n/**\n * Get geometry edges that located on a border of the mesh\n * @param {object} args\n * @param {number[]} args.edge - edge indices in geometry\n * @param {number} args.edgeIndex - edge index in outsideEdges array\n * @param {object} args.attributes - POSITION and TEXCOORD_0 attributes\n * @param {number} args.skirtHeight - height of the skirt geometry\n * @param {TypedArray} args.newPosition - POSITION array for skirt data\n * @param {TypedArray} args.newTexcoord0 - TEXCOORD_0 array for skirt data\n * @param {TypedArray | Array} args.newTriangles - trinagle indices array for skirt data\n * @returns {void}\n */\nfunction updateAttributesForNewEdge({ edge, edgeIndex, attributes, skirtHeight, newPosition, newTexcoord0, newTriangles }) {\n    const positionsLength = attributes.POSITION.value.length;\n    const vertex1Offset = edgeIndex * 2;\n    const vertex2Offset = edgeIndex * 2 + 1;\n    // Define POSITION for new 1st vertex\n    newPosition.set(attributes.POSITION.value.subarray(edge[0] * 3, edge[0] * 3 + 3), vertex1Offset * 3);\n    newPosition[vertex1Offset * 3 + 2] = newPosition[vertex1Offset * 3 + 2] - skirtHeight; // put down elevation on the skirt height\n    // Define POSITION for new 2nd vertex\n    newPosition.set(attributes.POSITION.value.subarray(edge[1] * 3, edge[1] * 3 + 3), vertex2Offset * 3);\n    newPosition[vertex2Offset * 3 + 2] = newPosition[vertex2Offset * 3 + 2] - skirtHeight; // put down elevation on the skirt height\n    // Use same TEXCOORDS for skirt vertices\n    newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[0] * 2, edge[0] * 2 + 2), vertex1Offset * 2);\n    newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[1] * 2, edge[1] * 2 + 2), vertex2Offset * 2);\n    // Define new triangles\n    const triangle1Offset = edgeIndex * 2 * 3;\n    newTriangles[triangle1Offset] = edge[0];\n    newTriangles[triangle1Offset + 1] = positionsLength / 3 + vertex2Offset;\n    newTriangles[triangle1Offset + 2] = edge[1];\n    newTriangles[triangle1Offset + 3] = positionsLength / 3 + vertex2Offset;\n    newTriangles[triangle1Offset + 4] = edge[0];\n    newTriangles[triangle1Offset + 5] = positionsLength / 3 + vertex1Offset;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,sBAAsB,QAAQ,0BAA0B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,QAAQA,CAACC,UAAU,EAAEC,SAAS,EAAEC,WAAW,EAAEC,cAAc,EAAE;EACzE,MAAMC,YAAY,GAAGD,cAAc,GAC7BE,0BAA0B,CAACF,cAAc,EAAEH,UAAU,CAACM,QAAQ,CAACC,KAAK,CAAC,GACrEC,4BAA4B,CAACP,SAAS,CAAC;EAC7C;EACA,MAAMQ,WAAW,GAAG,IAAIT,UAAU,CAACM,QAAQ,CAACC,KAAK,CAACG,WAAW,CAACN,YAAY,CAACO,MAAM,GAAG,CAAC,CAAC;EACtF,MAAMC,YAAY,GAAG,IAAIZ,UAAU,CAACa,UAAU,CAACN,KAAK,CAACG,WAAW,CAACN,YAAY,CAACO,MAAM,GAAG,CAAC,CAAC;EACzF;EACA,MAAMG,YAAY,GAAG,IAAIb,SAAS,CAACS,WAAW,CAACN,YAAY,CAACO,MAAM,GAAG,CAAC,CAAC;EACvE,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,YAAY,CAACO,MAAM,EAAEI,CAAC,EAAE,EAAE;IAC1C,MAAMC,IAAI,GAAGZ,YAAY,CAACW,CAAC,CAAC;IAC5BE,0BAA0B,CAAC;MACvBD,IAAI;MACJE,SAAS,EAAEH,CAAC;MACZf,UAAU;MACVE,WAAW;MACXO,WAAW;MACXG,YAAY;MACZE;IACJ,CAAC,CAAC;EACN;EACAd,UAAU,CAACM,QAAQ,CAACC,KAAK,GAAGT,sBAAsB,CAACE,UAAU,CAACM,QAAQ,CAACC,KAAK,EAAEE,WAAW,CAAC;EAC1FT,UAAU,CAACa,UAAU,CAACN,KAAK,GAAGT,sBAAsB,CAACE,UAAU,CAACa,UAAU,CAACN,KAAK,EAAEK,YAAY,CAAC;EAC/F,MAAMO,eAAe,GAAGlB,SAAS,YAAYmB,KAAK,GAC5CnB,SAAS,CAACoB,MAAM,CAACP,YAAY,CAAC,GAC9BhB,sBAAsB,CAACG,SAAS,EAAEa,YAAY,CAAC;EACrD,OAAO;IACHd,UAAU;IACVC,SAAS,EAAEkB;EACf,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAASX,4BAA4BA,CAACP,SAAS,EAAE;EAC7C,MAAMqB,KAAK,GAAG,EAAE;EAChB,KAAK,IAAIP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,SAAS,CAACU,MAAM,EAAEI,CAAC,IAAI,CAAC,EAAE;IAC1CO,KAAK,CAACC,IAAI,CAAC,CAACtB,SAAS,CAACc,CAAC,CAAC,EAAEd,SAAS,CAACc,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IAC5CO,KAAK,CAACC,IAAI,CAAC,CAACtB,SAAS,CAACc,CAAC,GAAG,CAAC,CAAC,EAAEd,SAAS,CAACc,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IAChDO,KAAK,CAACC,IAAI,CAAC,CAACtB,SAAS,CAACc,CAAC,GAAG,CAAC,CAAC,EAAEd,SAAS,CAACc,CAAC,CAAC,CAAC,CAAC;EAChD;EACAO,KAAK,CAACE,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKC,IAAI,CAACC,GAAG,CAAC,GAAGH,CAAC,CAAC,GAAGE,IAAI,CAACC,GAAG,CAAC,GAAGF,CAAC,CAAC,IAAIC,IAAI,CAACE,GAAG,CAAC,GAAGJ,CAAC,CAAC,GAAGE,IAAI,CAACE,GAAG,CAAC,GAAGH,CAAC,CAAC,CAAC;EACxF,MAAMtB,YAAY,GAAG,EAAE;EACvB,IAAI0B,KAAK,GAAG,CAAC;EACb,OAAOA,KAAK,GAAGR,KAAK,CAACX,MAAM,EAAE;IACzB,IAAIW,KAAK,CAACQ,KAAK,CAAC,CAAC,CAAC,CAAC,KAAKR,KAAK,CAACQ,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAIR,KAAK,CAACQ,KAAK,CAAC,CAAC,CAAC,CAAC,KAAKR,KAAK,CAACQ,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;MACxFA,KAAK,IAAI,CAAC;IACd,CAAC,MACI;MACD1B,YAAY,CAACmB,IAAI,CAACD,KAAK,CAACQ,KAAK,CAAC,CAAC;MAC/BA,KAAK,EAAE;IACX;EACJ;EACA,OAAO1B,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,0BAA0BA,CAAC0B,OAAO,EAAEC,QAAQ,EAAE;EACnD;EACAD,OAAO,CAACE,WAAW,CAACT,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKM,QAAQ,CAAC,CAAC,GAAGP,CAAC,GAAG,CAAC,CAAC,GAAGO,QAAQ,CAAC,CAAC,GAAGN,CAAC,GAAG,CAAC,CAAC,CAAC;EAC7E;EACAK,OAAO,CAACG,WAAW,CAACV,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKM,QAAQ,CAAC,CAAC,GAAGN,CAAC,GAAG,CAAC,CAAC,GAAGM,QAAQ,CAAC,CAAC,GAAGP,CAAC,GAAG,CAAC,CAAC,CAAC;EAC7EM,OAAO,CAACI,YAAY,CAACX,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKM,QAAQ,CAAC,CAAC,GAAGN,CAAC,CAAC,GAAGM,QAAQ,CAAC,CAAC,GAAGP,CAAC,CAAC,CAAC;EACtE;EACAM,OAAO,CAACK,YAAY,CAACZ,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKM,QAAQ,CAAC,CAAC,GAAGP,CAAC,CAAC,GAAGO,QAAQ,CAAC,CAAC,GAAGN,CAAC,CAAC,CAAC;EACtE,MAAMJ,KAAK,GAAG,EAAE;EAChB,KAAK,MAAMQ,KAAK,IAAIC,OAAO,EAAE;IACzB,MAAMM,UAAU,GAAGN,OAAO,CAACD,KAAK,CAAC;IACjC,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsB,UAAU,CAAC1B,MAAM,GAAG,CAAC,EAAEI,CAAC,EAAE,EAAE;MAC5CO,KAAK,CAACC,IAAI,CAAC,CAACc,UAAU,CAACtB,CAAC,CAAC,EAAEsB,UAAU,CAACtB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IAClD;EACJ;EACA,OAAOO,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASL,0BAA0BA,CAAC;EAAED,IAAI;EAAEE,SAAS;EAAElB,UAAU;EAAEE,WAAW;EAAEO,WAAW;EAAEG,YAAY;EAAEE;AAAa,CAAC,EAAE;EACvH,MAAMwB,eAAe,GAAGtC,UAAU,CAACM,QAAQ,CAACC,KAAK,CAACI,MAAM;EACxD,MAAM4B,aAAa,GAAGrB,SAAS,GAAG,CAAC;EACnC,MAAMsB,aAAa,GAAGtB,SAAS,GAAG,CAAC,GAAG,CAAC;EACvC;EACAT,WAAW,CAACgC,GAAG,CAACzC,UAAU,CAACM,QAAQ,CAACC,KAAK,CAACmC,QAAQ,CAAC1B,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEuB,aAAa,GAAG,CAAC,CAAC;EACpG9B,WAAW,CAAC8B,aAAa,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG9B,WAAW,CAAC8B,aAAa,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGrC,WAAW,CAAC,CAAC;EACvF;EACAO,WAAW,CAACgC,GAAG,CAACzC,UAAU,CAACM,QAAQ,CAACC,KAAK,CAACmC,QAAQ,CAAC1B,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEwB,aAAa,GAAG,CAAC,CAAC;EACpG/B,WAAW,CAAC+B,aAAa,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG/B,WAAW,CAAC+B,aAAa,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGtC,WAAW,CAAC,CAAC;EACvF;EACAU,YAAY,CAAC6B,GAAG,CAACzC,UAAU,CAACa,UAAU,CAACN,KAAK,CAACmC,QAAQ,CAAC1B,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEuB,aAAa,GAAG,CAAC,CAAC;EACvG3B,YAAY,CAAC6B,GAAG,CAACzC,UAAU,CAACa,UAAU,CAACN,KAAK,CAACmC,QAAQ,CAAC1B,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEwB,aAAa,GAAG,CAAC,CAAC;EACvG;EACA,MAAMG,eAAe,GAAGzB,SAAS,GAAG,CAAC,GAAG,CAAC;EACzCJ,YAAY,CAAC6B,eAAe,CAAC,GAAG3B,IAAI,CAAC,CAAC,CAAC;EACvCF,YAAY,CAAC6B,eAAe,GAAG,CAAC,CAAC,GAAGL,eAAe,GAAG,CAAC,GAAGE,aAAa;EACvE1B,YAAY,CAAC6B,eAAe,GAAG,CAAC,CAAC,GAAG3B,IAAI,CAAC,CAAC,CAAC;EAC3CF,YAAY,CAAC6B,eAAe,GAAG,CAAC,CAAC,GAAGL,eAAe,GAAG,CAAC,GAAGE,aAAa;EACvE1B,YAAY,CAAC6B,eAAe,GAAG,CAAC,CAAC,GAAG3B,IAAI,CAAC,CAAC,CAAC;EAC3CF,YAAY,CAAC6B,eAAe,GAAG,CAAC,CAAC,GAAGL,eAAe,GAAG,CAAC,GAAGC,aAAa;AAC3E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}