{"ast":null,"code":"// Native Draco attribute names to GLTF attribute names.\nconst GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR_0: 'COLOR',\n  TEXCOORD_0: 'TEX_COORD'\n};\nconst noop = () => {};\nexport default class DracoBuilder {\n  draco;\n  dracoEncoder;\n  dracoMeshBuilder;\n  dracoMetadataBuilder;\n  log;\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco) {\n    this.draco = draco;\n    this.dracoEncoder = new this.draco.Encoder();\n    this.dracoMeshBuilder = new this.draco.MeshBuilder();\n    this.dracoMetadataBuilder = new this.draco.MetadataBuilder();\n  }\n  destroy() {\n    this.destroyEncodedObject(this.dracoMeshBuilder);\n    this.destroyEncodedObject(this.dracoEncoder);\n    this.destroyEncodedObject(this.dracoMetadataBuilder);\n    // @ts-ignore\n    this.dracoMeshBuilder = null;\n    // @ts-ignore\n    this.dracoEncoder = null;\n    // @ts-ignore\n    this.draco = null;\n  }\n  // TBD - when does this need to be called?\n  destroyEncodedObject(object) {\n    if (object) {\n      this.draco.destroy(object);\n    }\n  }\n  /**\n   * Encode mesh or point cloud\n   * @param mesh =({})\n   * @param options\n   */\n  encodeSync(mesh, options = {}) {\n    this.log = noop; // TODO\n    this._setOptions(options);\n    return options.pointcloud ? this._encodePointCloud(mesh, options) : this._encodeMesh(mesh, options);\n  }\n  // PRIVATE\n  _getAttributesFromMesh(mesh) {\n    // TODO - Change the encodePointCloud interface instead?\n    const attributes = {\n      ...mesh,\n      ...mesh.attributes\n    };\n    // Fold indices into the attributes\n    if (mesh.indices) {\n      attributes.indices = mesh.indices;\n    }\n    return attributes;\n  }\n  _encodePointCloud(pointcloud, options) {\n    const dracoPointCloud = new this.draco.PointCloud();\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoPointCloud, options.metadata);\n    }\n    const attributes = this._getAttributesFromMesh(pointcloud);\n    // Build a `DracoPointCloud` from the input data\n    this._createDracoPointCloud(dracoPointCloud, attributes, options);\n    const dracoData = new this.draco.DracoInt8Array();\n    try {\n      const encodedLen = this.dracoEncoder.EncodePointCloudToDracoBuffer(dracoPointCloud, false, dracoData);\n      if (!(encodedLen > 0)) {\n        throw new Error('Draco encoding failed.');\n      }\n      this.log(`DRACO encoded ${dracoPointCloud.num_points()} points\n        with ${dracoPointCloud.num_attributes()} attributes into ${encodedLen} bytes`);\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoPointCloud);\n    }\n  }\n  _encodeMesh(mesh, options) {\n    const dracoMesh = new this.draco.Mesh();\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoMesh, options.metadata);\n    }\n    const attributes = this._getAttributesFromMesh(mesh);\n    // Build a `DracoMesh` from the input data\n    this._createDracoMesh(dracoMesh, attributes, options);\n    const dracoData = new this.draco.DracoInt8Array();\n    try {\n      const encodedLen = this.dracoEncoder.EncodeMeshToDracoBuffer(dracoMesh, dracoData);\n      if (encodedLen <= 0) {\n        throw new Error('Draco encoding failed.');\n      }\n      this.log(`DRACO encoded ${dracoMesh.num_points()} points\n        with ${dracoMesh.num_attributes()} attributes into ${encodedLen} bytes`);\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoMesh);\n    }\n  }\n  /**\n   * Set encoding options.\n   * @param {{speed?: any; method?: any; quantization?: any;}} options\n   */\n  _setOptions(options) {\n    if ('speed' in options) {\n      // @ts-ignore\n      this.dracoEncoder.SetSpeedOptions(...options.speed);\n    }\n    if ('method' in options) {\n      const dracoMethod = this.draco[options.method || 'MESH_SEQUENTIAL_ENCODING'];\n      // assert(dracoMethod)\n      this.dracoEncoder.SetEncodingMethod(dracoMethod);\n    }\n    if ('quantization' in options) {\n      for (const attribute in options.quantization) {\n        const bits = options.quantization[attribute];\n        const dracoPosition = this.draco[attribute];\n        this.dracoEncoder.SetAttributeQuantization(dracoPosition, bits);\n      }\n    }\n  }\n  /**\n   * @param {Mesh} dracoMesh\n   * @param {object} attributes\n   * @returns {Mesh}\n   */\n  _createDracoMesh(dracoMesh, attributes, options) {\n    const optionalMetadata = options.attributesMetadata || {};\n    try {\n      const positions = this._getPositionAttribute(attributes);\n      if (!positions) {\n        throw new Error('positions');\n      }\n      const vertexCount = positions.length / 3;\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n        const uniqueId = this._addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount);\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoMesh, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoMesh);\n      throw error;\n    }\n    return dracoMesh;\n  }\n  /**\n   * @param {} dracoPointCloud\n   * @param {object} attributes\n   */\n  _createDracoPointCloud(dracoPointCloud, attributes, options) {\n    const optionalMetadata = options.attributesMetadata || {};\n    try {\n      const positions = this._getPositionAttribute(attributes);\n      if (!positions) {\n        throw new Error('positions');\n      }\n      const vertexCount = positions.length / 3;\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n        const uniqueId = this._addAttributeToMesh(dracoPointCloud, attributeName, attribute, vertexCount);\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoPointCloud, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoPointCloud);\n      throw error;\n    }\n    return dracoPointCloud;\n  }\n  /**\n   * @param mesh\n   * @param attributeName\n   * @param attribute\n   * @param vertexCount\n   */\n  _addAttributeToMesh(mesh, attributeName, attribute, vertexCount) {\n    if (!ArrayBuffer.isView(attribute)) {\n      return -1;\n    }\n    const type = this._getDracoAttributeType(attributeName);\n    // @ts-ignore TODO/fix types\n    const size = attribute.length / vertexCount;\n    if (type === 'indices') {\n      // @ts-ignore TODO/fix types\n      const numFaces = attribute.length / 3;\n      this.log(`Adding attribute ${attributeName}, size ${numFaces}`);\n      // @ts-ignore assumes mesh is a Mesh, not a point cloud\n      this.dracoMeshBuilder.AddFacesToMesh(mesh, numFaces, attribute);\n      return -1;\n    }\n    this.log(`Adding attribute ${attributeName}, size ${size}`);\n    const builder = this.dracoMeshBuilder;\n    const {\n      buffer\n    } = attribute;\n    switch (attribute.constructor) {\n      case Int8Array:\n        return builder.AddInt8Attribute(mesh, type, vertexCount, size, new Int8Array(buffer));\n      case Int16Array:\n        return builder.AddInt16Attribute(mesh, type, vertexCount, size, new Int16Array(buffer));\n      case Int32Array:\n        return builder.AddInt32Attribute(mesh, type, vertexCount, size, new Int32Array(buffer));\n      case Uint8Array:\n      case Uint8ClampedArray:\n        return builder.AddUInt8Attribute(mesh, type, vertexCount, size, new Uint8Array(buffer));\n      case Uint16Array:\n        return builder.AddUInt16Attribute(mesh, type, vertexCount, size, new Uint16Array(buffer));\n      case Uint32Array:\n        return builder.AddUInt32Attribute(mesh, type, vertexCount, size, new Uint32Array(buffer));\n      case Float32Array:\n        return builder.AddFloatAttribute(mesh, type, vertexCount, size, new Float32Array(buffer));\n      default:\n        // eslint-disable-next-line no-console\n        console.warn('Unsupported attribute type', attribute);\n        return -1;\n    }\n    // case Float64Array:\n    // Add attribute does not seem to be exposed\n    //   return builder.AddAttribute(mesh, type, vertexCount, size, new Float32Array(buffer));\n  }\n  /**\n   * DRACO can compress attributes of know type better\n   * TODO - expose an attribute type map?\n   * @param attributeName\n   */\n  _getDracoAttributeType(attributeName) {\n    switch (attributeName.toLowerCase()) {\n      case 'indices':\n        return 'indices';\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return this.draco.POSITION;\n      case 'normal':\n      case 'normals':\n        return this.draco.NORMAL;\n      case 'color':\n      case 'colors':\n        return this.draco.COLOR;\n      case 'texcoord':\n      case 'texcoords':\n        return this.draco.TEX_COORD;\n      default:\n        return this.draco.GENERIC;\n    }\n  }\n  _getPositionAttribute(attributes) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const dracoType = this._getDracoAttributeType(attributeName);\n      if (dracoType === this.draco.POSITION) {\n        return attribute;\n      }\n    }\n    return null;\n  }\n  /**\n   * Add metadata for the geometry.\n   * @param dracoGeometry - WASM Draco Object\n   * @param metadata\n   */\n  _addGeometryMetadata(dracoGeometry, metadata) {\n    const dracoMetadata = new this.draco.Metadata();\n    this._populateDracoMetadata(dracoMetadata, metadata);\n    this.dracoMeshBuilder.AddMetadata(dracoGeometry, dracoMetadata);\n  }\n  /**\n   * Add metadata for an attribute to geometry.\n   * @param dracoGeometry - WASM Draco Object\n   * @param uniqueAttributeId\n   * @param metadata\n   */\n  _addAttributeMetadata(dracoGeometry, uniqueAttributeId, metadata) {\n    // Note: Draco JS IDL doesn't seem to expose draco.AttributeMetadata, however it seems to\n    // create such objects automatically from draco.Metadata object.\n    const dracoAttributeMetadata = new this.draco.Metadata();\n    this._populateDracoMetadata(dracoAttributeMetadata, metadata);\n    // Draco3d doc note: Directly add attribute metadata to geometry.\n    // You can do this without explicitly adding |GeometryMetadata| to mesh.\n    this.dracoMeshBuilder.SetMetadataForAttribute(dracoGeometry, uniqueAttributeId, dracoAttributeMetadata);\n  }\n  /**\n   * Add contents of object or map to a WASM Draco Metadata Object\n   * @param dracoMetadata - WASM Draco Object\n   * @param metadata\n   */\n  _populateDracoMetadata(dracoMetadata, metadata) {\n    for (const [key, value] of getEntries(metadata)) {\n      switch (typeof value) {\n        case 'number':\n          if (Math.trunc(value) === value) {\n            this.dracoMetadataBuilder.AddIntEntry(dracoMetadata, key, value);\n          } else {\n            this.dracoMetadataBuilder.AddDoubleEntry(dracoMetadata, key, value);\n          }\n          break;\n        case 'object':\n          if (value instanceof Int32Array) {\n            this.dracoMetadataBuilder.AddIntEntryArray(dracoMetadata, key, value, value.length);\n          }\n          break;\n        case 'string':\n        default:\n          this.dracoMetadataBuilder.AddStringEntry(dracoMetadata, key, value);\n      }\n    }\n  }\n}\n// HELPER FUNCTIONS\n/**\n * Copy encoded data to buffer\n * @param dracoData\n */\nfunction dracoInt8ArrayToArrayBuffer(dracoData) {\n  const byteLength = dracoData.size();\n  const outputBuffer = new ArrayBuffer(byteLength);\n  const outputData = new Int8Array(outputBuffer);\n  for (let i = 0; i < byteLength; ++i) {\n    outputData[i] = dracoData.GetValue(i);\n  }\n  return outputBuffer;\n}\n/** Enable iteration over either an object or a map */\nfunction getEntries(container) {\n  const hasEntriesFunc = container.entries && !container.hasOwnProperty('entries');\n  return hasEntriesFunc ? container.entries() : Object.entries(container);\n}","map":{"version":3,"names":["GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP","POSITION","NORMAL","COLOR_0","TEXCOORD_0","noop","DracoBuilder","draco","dracoEncoder","dracoMeshBuilder","dracoMetadataBuilder","log","constructor","Encoder","MeshBuilder","MetadataBuilder","destroy","destroyEncodedObject","object","encodeSync","mesh","options","_setOptions","pointcloud","_encodePointCloud","_encodeMesh","_getAttributesFromMesh","attributes","indices","dracoPointCloud","PointCloud","metadata","_addGeometryMetadata","_createDracoPointCloud","dracoData","DracoInt8Array","encodedLen","EncodePointCloudToDracoBuffer","Error","num_points","num_attributes","dracoInt8ArrayToArrayBuffer","dracoMesh","Mesh","_createDracoMesh","EncodeMeshToDracoBuffer","SetSpeedOptions","speed","dracoMethod","method","SetEncodingMethod","attribute","quantization","bits","dracoPosition","SetAttributeQuantization","optionalMetadata","attributesMetadata","positions","_getPositionAttribute","vertexCount","length","attributeName","uniqueId","_addAttributeToMesh","_addAttributeMetadata","name","error","ArrayBuffer","isView","type","_getDracoAttributeType","size","numFaces","AddFacesToMesh","builder","buffer","Int8Array","AddInt8Attribute","Int16Array","AddInt16Attribute","Int32Array","AddInt32Attribute","Uint8Array","Uint8ClampedArray","AddUInt8Attribute","Uint16Array","AddUInt16Attribute","Uint32Array","AddUInt32Attribute","Float32Array","AddFloatAttribute","console","warn","toLowerCase","COLOR","TEX_COORD","GENERIC","dracoType","dracoGeometry","dracoMetadata","Metadata","_populateDracoMetadata","AddMetadata","uniqueAttributeId","dracoAttributeMetadata","SetMetadataForAttribute","key","value","getEntries","Math","trunc","AddIntEntry","AddDoubleEntry","AddIntEntryArray","AddStringEntry","byteLength","outputBuffer","outputData","i","GetValue","container","hasEntriesFunc","entries","hasOwnProperty","Object"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/draco/dist/lib/draco-builder.js"],"sourcesContent":["// Native Draco attribute names to GLTF attribute names.\nconst GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP = {\n    POSITION: 'POSITION',\n    NORMAL: 'NORMAL',\n    COLOR_0: 'COLOR',\n    TEXCOORD_0: 'TEX_COORD'\n};\nconst noop = () => { };\nexport default class DracoBuilder {\n    draco;\n    dracoEncoder;\n    dracoMeshBuilder;\n    dracoMetadataBuilder;\n    log;\n    // draco - the draco decoder, either import `draco3d` or load dynamically\n    constructor(draco) {\n        this.draco = draco;\n        this.dracoEncoder = new this.draco.Encoder();\n        this.dracoMeshBuilder = new this.draco.MeshBuilder();\n        this.dracoMetadataBuilder = new this.draco.MetadataBuilder();\n    }\n    destroy() {\n        this.destroyEncodedObject(this.dracoMeshBuilder);\n        this.destroyEncodedObject(this.dracoEncoder);\n        this.destroyEncodedObject(this.dracoMetadataBuilder);\n        // @ts-ignore\n        this.dracoMeshBuilder = null;\n        // @ts-ignore\n        this.dracoEncoder = null;\n        // @ts-ignore\n        this.draco = null;\n    }\n    // TBD - when does this need to be called?\n    destroyEncodedObject(object) {\n        if (object) {\n            this.draco.destroy(object);\n        }\n    }\n    /**\n     * Encode mesh or point cloud\n     * @param mesh =({})\n     * @param options\n     */\n    encodeSync(mesh, options = {}) {\n        this.log = noop; // TODO\n        this._setOptions(options);\n        return options.pointcloud\n            ? this._encodePointCloud(mesh, options)\n            : this._encodeMesh(mesh, options);\n    }\n    // PRIVATE\n    _getAttributesFromMesh(mesh) {\n        // TODO - Change the encodePointCloud interface instead?\n        const attributes = { ...mesh, ...mesh.attributes };\n        // Fold indices into the attributes\n        if (mesh.indices) {\n            attributes.indices = mesh.indices;\n        }\n        return attributes;\n    }\n    _encodePointCloud(pointcloud, options) {\n        const dracoPointCloud = new this.draco.PointCloud();\n        if (options.metadata) {\n            this._addGeometryMetadata(dracoPointCloud, options.metadata);\n        }\n        const attributes = this._getAttributesFromMesh(pointcloud);\n        // Build a `DracoPointCloud` from the input data\n        this._createDracoPointCloud(dracoPointCloud, attributes, options);\n        const dracoData = new this.draco.DracoInt8Array();\n        try {\n            const encodedLen = this.dracoEncoder.EncodePointCloudToDracoBuffer(dracoPointCloud, false, dracoData);\n            if (!(encodedLen > 0)) {\n                throw new Error('Draco encoding failed.');\n            }\n            this.log(`DRACO encoded ${dracoPointCloud.num_points()} points\n        with ${dracoPointCloud.num_attributes()} attributes into ${encodedLen} bytes`);\n            return dracoInt8ArrayToArrayBuffer(dracoData);\n        }\n        finally {\n            this.destroyEncodedObject(dracoData);\n            this.destroyEncodedObject(dracoPointCloud);\n        }\n    }\n    _encodeMesh(mesh, options) {\n        const dracoMesh = new this.draco.Mesh();\n        if (options.metadata) {\n            this._addGeometryMetadata(dracoMesh, options.metadata);\n        }\n        const attributes = this._getAttributesFromMesh(mesh);\n        // Build a `DracoMesh` from the input data\n        this._createDracoMesh(dracoMesh, attributes, options);\n        const dracoData = new this.draco.DracoInt8Array();\n        try {\n            const encodedLen = this.dracoEncoder.EncodeMeshToDracoBuffer(dracoMesh, dracoData);\n            if (encodedLen <= 0) {\n                throw new Error('Draco encoding failed.');\n            }\n            this.log(`DRACO encoded ${dracoMesh.num_points()} points\n        with ${dracoMesh.num_attributes()} attributes into ${encodedLen} bytes`);\n            return dracoInt8ArrayToArrayBuffer(dracoData);\n        }\n        finally {\n            this.destroyEncodedObject(dracoData);\n            this.destroyEncodedObject(dracoMesh);\n        }\n    }\n    /**\n     * Set encoding options.\n     * @param {{speed?: any; method?: any; quantization?: any;}} options\n     */\n    _setOptions(options) {\n        if ('speed' in options) {\n            // @ts-ignore\n            this.dracoEncoder.SetSpeedOptions(...options.speed);\n        }\n        if ('method' in options) {\n            const dracoMethod = this.draco[options.method || 'MESH_SEQUENTIAL_ENCODING'];\n            // assert(dracoMethod)\n            this.dracoEncoder.SetEncodingMethod(dracoMethod);\n        }\n        if ('quantization' in options) {\n            for (const attribute in options.quantization) {\n                const bits = options.quantization[attribute];\n                const dracoPosition = this.draco[attribute];\n                this.dracoEncoder.SetAttributeQuantization(dracoPosition, bits);\n            }\n        }\n    }\n    /**\n     * @param {Mesh} dracoMesh\n     * @param {object} attributes\n     * @returns {Mesh}\n     */\n    _createDracoMesh(dracoMesh, attributes, options) {\n        const optionalMetadata = options.attributesMetadata || {};\n        try {\n            const positions = this._getPositionAttribute(attributes);\n            if (!positions) {\n                throw new Error('positions');\n            }\n            const vertexCount = positions.length / 3;\n            for (let attributeName in attributes) {\n                const attribute = attributes[attributeName];\n                attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n                const uniqueId = this._addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount);\n                if (uniqueId !== -1) {\n                    this._addAttributeMetadata(dracoMesh, uniqueId, {\n                        name: attributeName,\n                        ...(optionalMetadata[attributeName] || {})\n                    });\n                }\n            }\n        }\n        catch (error) {\n            this.destroyEncodedObject(dracoMesh);\n            throw error;\n        }\n        return dracoMesh;\n    }\n    /**\n     * @param {} dracoPointCloud\n     * @param {object} attributes\n     */\n    _createDracoPointCloud(dracoPointCloud, attributes, options) {\n        const optionalMetadata = options.attributesMetadata || {};\n        try {\n            const positions = this._getPositionAttribute(attributes);\n            if (!positions) {\n                throw new Error('positions');\n            }\n            const vertexCount = positions.length / 3;\n            for (let attributeName in attributes) {\n                const attribute = attributes[attributeName];\n                attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n                const uniqueId = this._addAttributeToMesh(dracoPointCloud, attributeName, attribute, vertexCount);\n                if (uniqueId !== -1) {\n                    this._addAttributeMetadata(dracoPointCloud, uniqueId, {\n                        name: attributeName,\n                        ...(optionalMetadata[attributeName] || {})\n                    });\n                }\n            }\n        }\n        catch (error) {\n            this.destroyEncodedObject(dracoPointCloud);\n            throw error;\n        }\n        return dracoPointCloud;\n    }\n    /**\n     * @param mesh\n     * @param attributeName\n     * @param attribute\n     * @param vertexCount\n     */\n    _addAttributeToMesh(mesh, attributeName, attribute, vertexCount) {\n        if (!ArrayBuffer.isView(attribute)) {\n            return -1;\n        }\n        const type = this._getDracoAttributeType(attributeName);\n        // @ts-ignore TODO/fix types\n        const size = attribute.length / vertexCount;\n        if (type === 'indices') {\n            // @ts-ignore TODO/fix types\n            const numFaces = attribute.length / 3;\n            this.log(`Adding attribute ${attributeName}, size ${numFaces}`);\n            // @ts-ignore assumes mesh is a Mesh, not a point cloud\n            this.dracoMeshBuilder.AddFacesToMesh(mesh, numFaces, attribute);\n            return -1;\n        }\n        this.log(`Adding attribute ${attributeName}, size ${size}`);\n        const builder = this.dracoMeshBuilder;\n        const { buffer } = attribute;\n        switch (attribute.constructor) {\n            case Int8Array:\n                return builder.AddInt8Attribute(mesh, type, vertexCount, size, new Int8Array(buffer));\n            case Int16Array:\n                return builder.AddInt16Attribute(mesh, type, vertexCount, size, new Int16Array(buffer));\n            case Int32Array:\n                return builder.AddInt32Attribute(mesh, type, vertexCount, size, new Int32Array(buffer));\n            case Uint8Array:\n            case Uint8ClampedArray:\n                return builder.AddUInt8Attribute(mesh, type, vertexCount, size, new Uint8Array(buffer));\n            case Uint16Array:\n                return builder.AddUInt16Attribute(mesh, type, vertexCount, size, new Uint16Array(buffer));\n            case Uint32Array:\n                return builder.AddUInt32Attribute(mesh, type, vertexCount, size, new Uint32Array(buffer));\n            case Float32Array:\n                return builder.AddFloatAttribute(mesh, type, vertexCount, size, new Float32Array(buffer));\n            default:\n                // eslint-disable-next-line no-console\n                console.warn('Unsupported attribute type', attribute);\n                return -1;\n        }\n        // case Float64Array:\n        // Add attribute does not seem to be exposed\n        //   return builder.AddAttribute(mesh, type, vertexCount, size, new Float32Array(buffer));\n    }\n    /**\n     * DRACO can compress attributes of know type better\n     * TODO - expose an attribute type map?\n     * @param attributeName\n     */\n    _getDracoAttributeType(attributeName) {\n        switch (attributeName.toLowerCase()) {\n            case 'indices':\n                return 'indices';\n            case 'position':\n            case 'positions':\n            case 'vertices':\n                return this.draco.POSITION;\n            case 'normal':\n            case 'normals':\n                return this.draco.NORMAL;\n            case 'color':\n            case 'colors':\n                return this.draco.COLOR;\n            case 'texcoord':\n            case 'texcoords':\n                return this.draco.TEX_COORD;\n            default:\n                return this.draco.GENERIC;\n        }\n    }\n    _getPositionAttribute(attributes) {\n        for (const attributeName in attributes) {\n            const attribute = attributes[attributeName];\n            const dracoType = this._getDracoAttributeType(attributeName);\n            if (dracoType === this.draco.POSITION) {\n                return attribute;\n            }\n        }\n        return null;\n    }\n    /**\n     * Add metadata for the geometry.\n     * @param dracoGeometry - WASM Draco Object\n     * @param metadata\n     */\n    _addGeometryMetadata(dracoGeometry, metadata) {\n        const dracoMetadata = new this.draco.Metadata();\n        this._populateDracoMetadata(dracoMetadata, metadata);\n        this.dracoMeshBuilder.AddMetadata(dracoGeometry, dracoMetadata);\n    }\n    /**\n     * Add metadata for an attribute to geometry.\n     * @param dracoGeometry - WASM Draco Object\n     * @param uniqueAttributeId\n     * @param metadata\n     */\n    _addAttributeMetadata(dracoGeometry, uniqueAttributeId, metadata) {\n        // Note: Draco JS IDL doesn't seem to expose draco.AttributeMetadata, however it seems to\n        // create such objects automatically from draco.Metadata object.\n        const dracoAttributeMetadata = new this.draco.Metadata();\n        this._populateDracoMetadata(dracoAttributeMetadata, metadata);\n        // Draco3d doc note: Directly add attribute metadata to geometry.\n        // You can do this without explicitly adding |GeometryMetadata| to mesh.\n        this.dracoMeshBuilder.SetMetadataForAttribute(dracoGeometry, uniqueAttributeId, dracoAttributeMetadata);\n    }\n    /**\n     * Add contents of object or map to a WASM Draco Metadata Object\n     * @param dracoMetadata - WASM Draco Object\n     * @param metadata\n     */\n    _populateDracoMetadata(dracoMetadata, metadata) {\n        for (const [key, value] of getEntries(metadata)) {\n            switch (typeof value) {\n                case 'number':\n                    if (Math.trunc(value) === value) {\n                        this.dracoMetadataBuilder.AddIntEntry(dracoMetadata, key, value);\n                    }\n                    else {\n                        this.dracoMetadataBuilder.AddDoubleEntry(dracoMetadata, key, value);\n                    }\n                    break;\n                case 'object':\n                    if (value instanceof Int32Array) {\n                        this.dracoMetadataBuilder.AddIntEntryArray(dracoMetadata, key, value, value.length);\n                    }\n                    break;\n                case 'string':\n                default:\n                    this.dracoMetadataBuilder.AddStringEntry(dracoMetadata, key, value);\n            }\n        }\n    }\n}\n// HELPER FUNCTIONS\n/**\n * Copy encoded data to buffer\n * @param dracoData\n */\nfunction dracoInt8ArrayToArrayBuffer(dracoData) {\n    const byteLength = dracoData.size();\n    const outputBuffer = new ArrayBuffer(byteLength);\n    const outputData = new Int8Array(outputBuffer);\n    for (let i = 0; i < byteLength; ++i) {\n        outputData[i] = dracoData.GetValue(i);\n    }\n    return outputBuffer;\n}\n/** Enable iteration over either an object or a map */\nfunction getEntries(container) {\n    const hasEntriesFunc = container.entries && !container.hasOwnProperty('entries');\n    return hasEntriesFunc ? container.entries() : Object.entries(container);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}