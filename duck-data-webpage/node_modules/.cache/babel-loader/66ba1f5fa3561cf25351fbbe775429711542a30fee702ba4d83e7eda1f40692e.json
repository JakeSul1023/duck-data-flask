{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { GL } from '@luma.gl/constants';\n/** Check is uniform is of sampler type */\nexport function isSamplerUniform(type) {\n  return SAMPLER_TYPES.includes(type);\n}\nconst SAMPLER_TYPES = [35678, 35680, 35679, 35682, 36289, 36292, 36293, 36298, 36299, 36300, 36303, 36306, 36307, 36308, 36311];\n// Composite types table\nconst COMPOSITE_GL_TYPES = {\n  [5126]: [5126, 1, 'float', 'f32', 'float32'],\n  [35664]: [5126, 2, 'vec2', 'vec2<f32>', 'float32x2'],\n  [35665]: [5126, 3, 'vec3', 'vec3<f32>', 'float32x3'],\n  [35666]: [5126, 4, 'vec4', 'vec4<f32>', 'float32x4'],\n  [5124]: [5124, 1, 'int', 'i32', 'sint32'],\n  [35667]: [5124, 2, 'ivec2', 'vec2<i32>', 'sint32x2'],\n  [35668]: [5124, 3, 'ivec3', 'vec3<i32>', 'sint32x3'],\n  [35669]: [5124, 4, 'ivec4', 'vec4<i32>', 'sint32x4'],\n  [5125]: [5125, 1, 'uint', 'u32', 'uint32'],\n  [36294]: [5125, 2, 'uvec2', 'vec2<u32>', 'uint32x2'],\n  [36295]: [5125, 3, 'uvec3', 'vec3<u32>', 'uint32x3'],\n  [36296]: [5125, 4, 'uvec4', 'vec4<u32>', 'uint32x4'],\n  [35670]: [5126, 1, 'bool', 'f32', 'float32'],\n  [35671]: [5126, 2, 'bvec2', 'vec2<f32>', 'float32x2'],\n  [35672]: [5126, 3, 'bvec3', 'vec3<f32>', 'float32x3'],\n  [35673]: [5126, 4, 'bvec4', 'vec4<f32>', 'float32x4'],\n  // TODO - are sizes/components below correct?\n  [35674]: [5126, 8, 'mat2', 'mat2x2<f32>'],\n  // 4\n  [35685]: [5126, 8, 'mat2x3', 'mat2x3<f32>'],\n  // 6\n  [35686]: [5126, 8, 'mat2x4', 'mat2x4<f32>'],\n  // 8\n  [35687]: [5126, 12, 'mat3x2', 'mat3x2<f32>'],\n  // 6\n  [35675]: [5126, 12, 'mat3', 'mat3x3<f32>'],\n  // 9\n  [35688]: [5126, 12, 'mat3x4', 'mat3x4<f32>'],\n  // 12\n  [35689]: [5126, 16, 'mat4x2', 'mat4x2<f32>'],\n  // 8\n  [35690]: [5126, 16, 'mat4x3', 'mat4x3<f32>'],\n  // 12\n  [35676]: [5126, 16, 'mat4', 'mat4x4<f32>'] // 16\n};\n/** Decomposes a composite type (GL.VEC3) into a basic type (GL.FLOAT) and components (3) */\nexport function decodeGLUniformType(glUniformType) {\n  const typeAndSize = COMPOSITE_GL_TYPES[glUniformType];\n  if (!typeAndSize) {\n    throw new Error('uniform');\n  }\n  const [glType, components,, format] = typeAndSize;\n  return {\n    format,\n    components,\n    glType\n  };\n}\n/** Decomposes a composite type (GL.VEC3) into a basic type (GL.FLOAT) and components (3) */\nexport function decodeGLAttributeType(glAttributeType) {\n  const typeAndSize = COMPOSITE_GL_TYPES[glAttributeType];\n  if (!typeAndSize) {\n    throw new Error('attribute');\n  }\n  const [, components,, shaderType, vertexFormat] = typeAndSize;\n  // TODO sanity - if (shaderType.startsWith('mat' ...))\n  const attributeType = shaderType;\n  return {\n    attributeType,\n    vertexFormat,\n    components\n  }; // , glType};\n}\n/** Decomposes a composite type GL.VEC3 into a basic type (GL.FLOAT) and components (3) */\nexport function decomposeCompositeGLDataType(compositeGLDataType) {\n  const typeAndSize = COMPOSITE_GL_TYPES[compositeGLDataType];\n  if (!typeAndSize) {\n    return null;\n  }\n  const [type, components] = typeAndSize;\n  return {\n    type,\n    components\n  };\n}\nexport function getCompositeGLDataType(type, components) {\n  switch (type) {\n    case 5120:\n    case 5121:\n    case 5122:\n    case 5123:\n      type = 5126;\n      break;\n    default:\n  }\n  for (const glType in COMPOSITE_GL_TYPES) {\n    const [compType, compComponents, name] = COMPOSITE_GL_TYPES[glType];\n    if (compType === type && compComponents === components) {\n      return {\n        glType: Number(glType),\n        name\n      };\n    }\n  }\n  return null;\n}","map":{"version":3,"names":["GL","isSamplerUniform","type","SAMPLER_TYPES","includes","COMPOSITE_GL_TYPES","decodeGLUniformType","glUniformType","typeAndSize","Error","glType","components","format","decodeGLAttributeType","glAttributeType","shaderType","vertexFormat","attributeType","decomposeCompositeGLDataType","compositeGLDataType","getCompositeGLDataType","compType","compComponents","name","Number"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\webgl\\src\\adapter\\helpers\\decode-webgl-types.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderUniformType, ShaderAttributeType, VertexFormat} from '@luma.gl/core';\nimport {GL, GLUniformType, GLSamplerType, GLCompositeType, GLDataType} from '@luma.gl/constants';\n\n/** Check is uniform is of sampler type */\nexport function isSamplerUniform(type: GLUniformType): boolean {\n  return SAMPLER_TYPES.includes(type as GLSamplerType);\n}\n\nconst SAMPLER_TYPES: GLSamplerType[] = [\n  GL.SAMPLER_2D,\n  GL.SAMPLER_CUBE,\n  GL.SAMPLER_3D,\n  GL.SAMPLER_2D_SHADOW,\n  GL.SAMPLER_2D_ARRAY,\n  GL.SAMPLER_2D_ARRAY_SHADOW,\n  GL.SAMPLER_CUBE_SHADOW,\n  GL.INT_SAMPLER_2D,\n  GL.INT_SAMPLER_3D,\n  GL.INT_SAMPLER_CUBE,\n  GL.INT_SAMPLER_2D_ARRAY,\n  GL.UNSIGNED_INT_SAMPLER_2D,\n  GL.UNSIGNED_INT_SAMPLER_3D,\n  GL.UNSIGNED_INT_SAMPLER_CUBE,\n  GL.UNSIGNED_INT_SAMPLER_2D_ARRAY\n];\n\n// Composite types table\nconst COMPOSITE_GL_TYPES: Record<\n  GLCompositeType,\n  [GLDataType, number, string, ShaderUniformType, VertexFormat?]\n> = {\n  [GL.FLOAT]: [GL.FLOAT, 1, 'float', 'f32', 'float32'],\n  [GL.FLOAT_VEC2]: [GL.FLOAT, 2, 'vec2', 'vec2<f32>', 'float32x2'],\n  [GL.FLOAT_VEC3]: [GL.FLOAT, 3, 'vec3', 'vec3<f32>', 'float32x3'],\n  [GL.FLOAT_VEC4]: [GL.FLOAT, 4, 'vec4', 'vec4<f32>', 'float32x4'],\n\n  [GL.INT]: [GL.INT, 1, 'int', 'i32', 'sint32'],\n  [GL.INT_VEC2]: [GL.INT, 2, 'ivec2', 'vec2<i32>', 'sint32x2'],\n  [GL.INT_VEC3]: [GL.INT, 3, 'ivec3', 'vec3<i32>', 'sint32x3'],\n  [GL.INT_VEC4]: [GL.INT, 4, 'ivec4', 'vec4<i32>', 'sint32x4'],\n\n  [GL.UNSIGNED_INT]: [GL.UNSIGNED_INT, 1, 'uint', 'u32', 'uint32'],\n  [GL.UNSIGNED_INT_VEC2]: [GL.UNSIGNED_INT, 2, 'uvec2', 'vec2<u32>', 'uint32x2'],\n  [GL.UNSIGNED_INT_VEC3]: [GL.UNSIGNED_INT, 3, 'uvec3', 'vec3<u32>', 'uint32x3'],\n  [GL.UNSIGNED_INT_VEC4]: [GL.UNSIGNED_INT, 4, 'uvec4', 'vec4<u32>', 'uint32x4'],\n\n  [GL.BOOL]: [GL.FLOAT, 1, 'bool', 'f32', 'float32'],\n  [GL.BOOL_VEC2]: [GL.FLOAT, 2, 'bvec2', 'vec2<f32>', 'float32x2'],\n  [GL.BOOL_VEC3]: [GL.FLOAT, 3, 'bvec3', 'vec3<f32>', 'float32x3'],\n  [GL.BOOL_VEC4]: [GL.FLOAT, 4, 'bvec4', 'vec4<f32>', 'float32x4'],\n\n  // TODO - are sizes/components below correct?\n  [GL.FLOAT_MAT2]: [GL.FLOAT, 8, 'mat2', 'mat2x2<f32>'], // 4\n  [GL.FLOAT_MAT2x3]: [GL.FLOAT, 8, 'mat2x3', 'mat2x3<f32>'], // 6\n  [GL.FLOAT_MAT2x4]: [GL.FLOAT, 8, 'mat2x4', 'mat2x4<f32>'], // 8\n\n  [GL.FLOAT_MAT3x2]: [GL.FLOAT, 12, 'mat3x2', 'mat3x2<f32>'], // 6\n  [GL.FLOAT_MAT3]: [GL.FLOAT, 12, 'mat3', 'mat3x3<f32>'], // 9\n  [GL.FLOAT_MAT3x4]: [GL.FLOAT, 12, 'mat3x4', 'mat3x4<f32>'], // 12\n\n  [GL.FLOAT_MAT4x2]: [GL.FLOAT, 16, 'mat4x2', 'mat4x2<f32>'], // 8\n  [GL.FLOAT_MAT4x3]: [GL.FLOAT, 16, 'mat4x3', 'mat4x3<f32>'], // 12\n  [GL.FLOAT_MAT4]: [GL.FLOAT, 16, 'mat4', 'mat4x4<f32>'] // 16\n};\n\n/** Decomposes a composite type (GL.VEC3) into a basic type (GL.FLOAT) and components (3) */\nexport function decodeGLUniformType(glUniformType: GL): {\n  format: ShaderUniformType;\n  components: number;\n  glType: GLDataType;\n} {\n  const typeAndSize = COMPOSITE_GL_TYPES[glUniformType];\n  if (!typeAndSize) {\n    throw new Error('uniform');\n  }\n  const [glType, components, , format] = typeAndSize;\n  return {format, components, glType};\n}\n\n/** Decomposes a composite type (GL.VEC3) into a basic type (GL.FLOAT) and components (3) */\nexport function decodeGLAttributeType(glAttributeType: GL): {\n  attributeType: ShaderAttributeType;\n  vertexFormat: VertexFormat;\n  components: number;\n  // glType: GLDataType;\n} {\n  const typeAndSize = COMPOSITE_GL_TYPES[glAttributeType];\n  if (!typeAndSize) {\n    throw new Error('attribute');\n  }\n  const [, components, , shaderType, vertexFormat] = typeAndSize;\n  // TODO sanity - if (shaderType.startsWith('mat' ...))\n  const attributeType = shaderType as unknown as ShaderAttributeType;\n  return {attributeType, vertexFormat, components}; // , glType};\n}\n\n/** Decomposes a composite type GL.VEC3 into a basic type (GL.FLOAT) and components (3) */\nexport function decomposeCompositeGLDataType(\n  compositeGLDataType: GLCompositeType\n): {type: GLDataType; components: number} | null {\n  const typeAndSize = COMPOSITE_GL_TYPES[compositeGLDataType];\n  if (!typeAndSize) {\n    return null;\n  }\n  const [type, components] = typeAndSize;\n  return {type, components};\n}\n\nexport function getCompositeGLDataType(\n  type: GL,\n  components\n): {glType: GLDataType; name: string} | null {\n  switch (type) {\n    case GL.BYTE:\n    case GL.UNSIGNED_BYTE:\n    case GL.SHORT:\n    case GL.UNSIGNED_SHORT:\n      type = GL.FLOAT;\n      break;\n    default:\n  }\n\n  for (const glType in COMPOSITE_GL_TYPES) {\n    const [compType, compComponents, name] = COMPOSITE_GL_TYPES[glType];\n    if (compType === type && compComponents === components) {\n      return {glType: Number(glType), name};\n    }\n  }\n  return null;\n}\n"],"mappings":"AAAA;AACA;AACA;AAGA,SAAQA,EAAE,QAAkE,oBAAoB;AAEhG;AACA,OAAM,SAAUC,gBAAgBA,CAACC,IAAmB;EAClD,OAAOC,aAAa,CAACC,QAAQ,CAACF,IAAqB,CAAC;AACtD;AAEA,MAAMC,aAAa,GAAoB,C,wGAgBtC;AAED;AACA,MAAME,kBAAkB,GAGpB;EACF,QAAY,OAAW,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,SAAS,CAAC;EACpD,SAAiB,OAAW,CAAC,EAAE,MAAM,EAAE,WAAW,EAAE,WAAW,CAAC;EAChE,SAAiB,OAAW,CAAC,EAAE,MAAM,EAAE,WAAW,EAAE,WAAW,CAAC;EAChE,SAAiB,OAAW,CAAC,EAAE,MAAM,EAAE,WAAW,EAAE,WAAW,CAAC;EAEhE,QAAU,OAAS,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,QAAQ,CAAC;EAC7C,SAAe,OAAS,CAAC,EAAE,OAAO,EAAE,WAAW,EAAE,UAAU,CAAC;EAC5D,SAAe,OAAS,CAAC,EAAE,OAAO,EAAE,WAAW,EAAE,UAAU,CAAC;EAC5D,SAAe,OAAS,CAAC,EAAE,OAAO,EAAE,WAAW,EAAE,UAAU,CAAC;EAE5D,QAAmB,OAAkB,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,QAAQ,CAAC;EAChE,SAAwB,OAAkB,CAAC,EAAE,OAAO,EAAE,WAAW,EAAE,UAAU,CAAC;EAC9E,SAAwB,OAAkB,CAAC,EAAE,OAAO,EAAE,WAAW,EAAE,UAAU,CAAC;EAC9E,SAAwB,OAAkB,CAAC,EAAE,OAAO,EAAE,WAAW,EAAE,UAAU,CAAC;EAE9E,SAAW,OAAW,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,SAAS,CAAC;EAClD,SAAgB,OAAW,CAAC,EAAE,OAAO,EAAE,WAAW,EAAE,WAAW,CAAC;EAChE,SAAgB,OAAW,CAAC,EAAE,OAAO,EAAE,WAAW,EAAE,WAAW,CAAC;EAChE,SAAgB,OAAW,CAAC,EAAE,OAAO,EAAE,WAAW,EAAE,WAAW,CAAC;EAEhE;EACA,SAAiB,OAAW,CAAC,EAAE,MAAM,EAAE,aAAa,CAAC;EAAE;EACvD,SAAmB,OAAW,CAAC,EAAE,QAAQ,EAAE,aAAa,CAAC;EAAE;EAC3D,SAAmB,OAAW,CAAC,EAAE,QAAQ,EAAE,aAAa,CAAC;EAAE;EAE3D,SAAmB,OAAW,EAAE,EAAE,QAAQ,EAAE,aAAa,CAAC;EAAE;EAC5D,SAAiB,OAAW,EAAE,EAAE,MAAM,EAAE,aAAa,CAAC;EAAE;EACxD,SAAmB,OAAW,EAAE,EAAE,QAAQ,EAAE,aAAa,CAAC;EAAE;EAE5D,SAAmB,OAAW,EAAE,EAAE,QAAQ,EAAE,aAAa,CAAC;EAAE;EAC5D,SAAmB,OAAW,EAAE,EAAE,QAAQ,EAAE,aAAa,CAAC;EAAE;EAC5D,SAAiB,OAAW,EAAE,EAAE,MAAM,EAAE,aAAa,CAAC,CAAC;CACxD;AAED;AACA,OAAM,SAAUC,mBAAmBA,CAACC,aAAiB;EAKnD,MAAMC,WAAW,GAAGH,kBAAkB,CAACE,aAAa,CAAC;EACrD,IAAI,CAACC,WAAW,EAAE;IAChB,MAAM,IAAIC,KAAK,CAAC,SAAS,CAAC;EAC5B;EACA,MAAM,CAACC,MAAM,EAAEC,UAAU,GAAIC,MAAM,CAAC,GAAGJ,WAAW;EAClD,OAAO;IAACI,MAAM;IAAED,UAAU;IAAED;EAAM,CAAC;AACrC;AAEA;AACA,OAAM,SAAUG,qBAAqBA,CAACC,eAAmB;EAMvD,MAAMN,WAAW,GAAGH,kBAAkB,CAACS,eAAe,CAAC;EACvD,IAAI,CAACN,WAAW,EAAE;IAChB,MAAM,IAAIC,KAAK,CAAC,WAAW,CAAC;EAC9B;EACA,MAAM,GAAGE,UAAU,GAAII,UAAU,EAAEC,YAAY,CAAC,GAAGR,WAAW;EAC9D;EACA,MAAMS,aAAa,GAAGF,UAA4C;EAClE,OAAO;IAACE,aAAa;IAAED,YAAY;IAAEL;EAAU,CAAC,CAAC,CAAC;AACpD;AAEA;AACA,OAAM,SAAUO,4BAA4BA,CAC1CC,mBAAoC;EAEpC,MAAMX,WAAW,GAAGH,kBAAkB,CAACc,mBAAmB,CAAC;EAC3D,IAAI,CAACX,WAAW,EAAE;IAChB,OAAO,IAAI;EACb;EACA,MAAM,CAACN,IAAI,EAAES,UAAU,CAAC,GAAGH,WAAW;EACtC,OAAO;IAACN,IAAI;IAAES;EAAU,CAAC;AAC3B;AAEA,OAAM,SAAUS,sBAAsBA,CACpClB,IAAQ,EACRS,UAAU;EAEV,QAAQT,IAAI;IACV;IACA;IACA;IACA;MACEA,IAAI,OAAW;MACf;IACF;EACF;EAEA,KAAK,MAAMQ,MAAM,IAAIL,kBAAkB,EAAE;IACvC,MAAM,CAACgB,QAAQ,EAAEC,cAAc,EAAEC,IAAI,CAAC,GAAGlB,kBAAkB,CAACK,MAAM,CAAC;IACnE,IAAIW,QAAQ,KAAKnB,IAAI,IAAIoB,cAAc,KAAKX,UAAU,EAAE;MACtD,OAAO;QAACD,MAAM,EAAEc,MAAM,CAACd,MAAM,CAAC;QAAEa;MAAI,CAAC;IACvC;EACF;EACA,OAAO,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}