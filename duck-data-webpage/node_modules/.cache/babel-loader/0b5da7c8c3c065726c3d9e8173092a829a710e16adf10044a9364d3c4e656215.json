{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport log from \"../utils/log.js\";\nimport { createMat4, getCameraPosition, getFrustumPlanes } from \"../utils/math-utils.js\";\nimport { Matrix4, Vector3, equals, clamp, mat4 } from '@math.gl/core';\nimport { getDistanceScales, getMeterZoom, lngLatToWorld, worldToLngLat, worldToPixels, pixelsToWorld } from '@math.gl/web-mercator';\nimport { PROJECTION_MODE } from \"../lib/constants.js\";\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nconst IDENTITY = createMat4();\nconst ZERO_VECTOR = [0, 0, 0];\nconst DEFAULT_DISTANCE_SCALES = {\n  unitsPerMeter: [1, 1, 1],\n  metersPerUnit: [1, 1, 1]\n};\n// / Helpers\nfunction createProjectionMatrix({\n  width,\n  height,\n  orthographic,\n  fovyRadians,\n  focalDistance,\n  padding,\n  near,\n  far\n}) {\n  const aspect = width / height;\n  const matrix = orthographic ? new Matrix4().orthographic({\n    fovy: fovyRadians,\n    aspect,\n    focalDistance,\n    near,\n    far\n  }) : new Matrix4().perspective({\n    fovy: fovyRadians,\n    aspect,\n    near,\n    far\n  });\n  if (padding) {\n    const {\n      left = 0,\n      right = 0,\n      top = 0,\n      bottom = 0\n    } = padding;\n    const offsetX = clamp((left + width - right) / 2, 0, width) - width / 2;\n    const offsetY = clamp((top + height - bottom) / 2, 0, height) - height / 2;\n    // pixels to clip space\n    matrix[8] -= offsetX * 2 / width;\n    matrix[9] += offsetY * 2 / height;\n  }\n  return matrix;\n}\n/**\n * Manages coordinate system transformations.\n *\n * Note: The Viewport is immutable in the sense that it only has accessors.\n * A new viewport instance should be created if any parameters have changed.\n */\nclass Viewport {\n  // eslint-disable-next-line complexity\n  constructor(opts = {}) {\n    this._frustumPlanes = {};\n    // @ts-ignore\n    this.id = opts.id || this.constructor.displayName || 'viewport';\n    this.x = opts.x || 0;\n    this.y = opts.y || 0;\n    // Silently allow apps to send in w,h = 0,0\n    this.width = opts.width || 1;\n    this.height = opts.height || 1;\n    this.zoom = opts.zoom || 0;\n    this.padding = opts.padding;\n    this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;\n    this.focalDistance = opts.focalDistance || 1;\n    this.position = opts.position || ZERO_VECTOR;\n    this.modelMatrix = opts.modelMatrix || null;\n    const {\n      longitude,\n      latitude\n    } = opts;\n    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);\n    this._initProps(opts);\n    this._initMatrices(opts);\n    // Bind methods for easy access\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    this.projectFlat = this.projectFlat.bind(this);\n    this.unprojectFlat = this.unprojectFlat.bind(this);\n  }\n  get subViewports() {\n    return null;\n  }\n  get metersPerPixel() {\n    return this.distanceScales.metersPerUnit[2] / this.scale;\n  }\n  get projectionMode() {\n    if (this.isGeospatial) {\n      return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;\n    }\n    return PROJECTION_MODE.IDENTITY;\n  }\n  // Two viewports are equal if width and height are identical, and if\n  // their view and projection matrices are (approximately) equal.\n  equals(viewport) {\n    if (!(viewport instanceof Viewport)) {\n      return false;\n    }\n    if (this === viewport) {\n      return true;\n    }\n    return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && equals(viewport.projectionMatrix, this.projectionMatrix) && equals(viewport.viewMatrix, this.viewMatrix);\n    // TODO - check distance scales?\n  }\n  /**\n   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n   * using viewport projection parameters\n   * - [longitude, latitude] to [x, y]\n   * - [longitude, latitude, Z] => [x, y, z]\n   * Note: By default, returns top-left coordinates for canvas/SVG type render\n   *\n   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]\n   * @param {Object} opts - options\n   * @param {Object} opts.topLeft=true - Whether projected coords are top left\n   * @return {Array} - [x, y] or [x, y, z] in top left coords\n   */\n  project(xyz, {\n    topLeft = true\n  } = {}) {\n    const worldPosition = this.projectPosition(xyz);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  }\n  /**\n   * Unproject pixel coordinates on screen onto world coordinates,\n   * (possibly [lon, lat]) on map.\n   * - [x, y] => [lng, lat]\n   * - [x, y, z] => [lng, lat, Z]\n   * @param {Array} xyz -\n   * @param {Object} opts - options\n   * @param {Object} opts.topLeft=true - Whether origin is top left\n   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]\n   */\n  unproject(xyz, {\n    topLeft = true,\n    targetZ\n  } = {}) {\n    const [x, y, z] = xyz;\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  }\n  // NON_LINEAR PROJECTION HOOKS\n  // Used for web meractor projection\n  projectPosition(xyz) {\n    const [X, Y] = this.projectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n    return [X, Y, Z];\n  }\n  unprojectPosition(xyz) {\n    const [X, Y] = this.unprojectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n    return [X, Y, Z];\n  }\n  /**\n   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n   * Performs the nonlinear part of the web mercator projection.\n   * Remaining projection is done with 4x4 matrices which also handles\n   * perspective.\n   * @param {Array} lngLat - [lng, lat] coordinates\n   *   Specifies a point on the sphere to project onto the map.\n   * @return {Array} [x,y] coordinates.\n   */\n  projectFlat(xyz) {\n    if (this.isGeospatial) {\n      // Shader clamps latitude to +-89.9, see /shaderlib/project/project.glsl.js\n      // lngLatToWorld([0, -89.9])[1] = -317.9934163758329\n      // lngLatToWorld([0, 89.9])[1] = 829.9934163758271\n      const result = lngLatToWorld(xyz);\n      result[1] = clamp(result[1], -318, 830);\n      return result;\n    }\n    return xyz;\n  }\n  /**\n   * Unproject world point [x,y] on map onto {lat, lon} on sphere\n   * @param {object|Vector} xy - object with {x,y} members\n   *  representing point on projected map plane\n   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n   *   Has toArray method if you need a GeoJSON Array.\n   *   Per cartographic tradition, lat and lon are specified as degrees.\n   */\n  unprojectFlat(xyz) {\n    if (this.isGeospatial) {\n      return worldToLngLat(xyz);\n    }\n    return xyz;\n  }\n  /**\n   * Get bounds of the current viewport\n   * @return {Array} - [minX, minY, maxX, maxY]\n   */\n  getBounds(options = {}) {\n    const unprojectOption = {\n      targetZ: options.z || 0\n    };\n    const topLeft = this.unproject([0, 0], unprojectOption);\n    const topRight = this.unproject([this.width, 0], unprojectOption);\n    const bottomLeft = this.unproject([0, this.height], unprojectOption);\n    const bottomRight = this.unproject([this.width, this.height], unprojectOption);\n    return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];\n  }\n  getDistanceScales(coordinateOrigin) {\n    if (coordinateOrigin && this.isGeospatial) {\n      return getDistanceScales({\n        longitude: coordinateOrigin[0],\n        latitude: coordinateOrigin[1],\n        highPrecision: true\n      });\n    }\n    return this.distanceScales;\n  }\n  containsPixel({\n    x,\n    y,\n    width = 1,\n    height = 1\n  }) {\n    return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;\n  }\n  // Extract frustum planes in common space\n  getFrustumPlanes() {\n    if (this._frustumPlanes.near) {\n      // @ts-ignore\n      return this._frustumPlanes;\n    }\n    Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));\n    // @ts-ignore\n    return this._frustumPlanes;\n  }\n  // EXPERIMENTAL METHODS\n  /**\n   * Needed by panning and linear transition\n   * Pan the viewport to place a given world coordinate at screen point [x, y]\n   *\n   * @param {Array} coords - world coordinates\n   * @param {Array} pixel - [x,y] coordinates on screen\n   * @return {Object} props of the new viewport\n   */\n  panByPosition(coords, pixel) {\n    return null;\n  }\n  // INTERNAL METHODS\n  /* eslint-disable complexity, max-statements */\n  _initProps(opts) {\n    const longitude = opts.longitude;\n    const latitude = opts.latitude;\n    if (this.isGeospatial) {\n      if (!Number.isFinite(opts.zoom)) {\n        this.zoom = getMeterZoom({\n          latitude\n        }) + Math.log2(this.focalDistance);\n      }\n      this.distanceScales = opts.distanceScales || getDistanceScales({\n        latitude,\n        longitude\n      });\n    }\n    const scale = Math.pow(2, this.zoom);\n    this.scale = scale;\n    const {\n      position,\n      modelMatrix\n    } = opts;\n    let meterOffset = ZERO_VECTOR;\n    if (position) {\n      meterOffset = modelMatrix ? new Matrix4(modelMatrix).transformAsVector(position, []) : position;\n    }\n    if (this.isGeospatial) {\n      // Determine camera center in common space\n      const center = this.projectPosition([longitude, latitude, 0]);\n      this.center = new Vector3(meterOffset)\n      // Convert to pixels in current zoom\n      .scale(this.distanceScales.unitsPerMeter).add(center);\n    } else {\n      this.center = this.projectPosition(meterOffset);\n    }\n  }\n  /* eslint-enable complexity, max-statements */\n  _initMatrices(opts) {\n    const {\n      // View matrix\n      viewMatrix = IDENTITY,\n      // Projection matrix\n      projectionMatrix = null,\n      // Projection matrix parameters, used if projectionMatrix not supplied\n      orthographic = false,\n      fovyRadians,\n      fovy = 75,\n      near = 0.1,\n      // Distance of near clipping plane\n      far = 1000,\n      // Distance of far clipping plane\n      padding = null,\n      // Center offset in pixels\n      focalDistance = 1\n    } = opts;\n    this.viewMatrixUncentered = viewMatrix;\n    // Make a centered version of the matrix for projection modes without an offset\n    this.viewMatrix = new Matrix4()\n    // Apply the uncentered view matrix\n    .multiplyRight(viewMatrix)\n    // And center it\n    .translate(new Vector3(this.center).negate());\n    this.projectionMatrix = projectionMatrix || createProjectionMatrix({\n      width: this.width,\n      height: this.height,\n      orthographic,\n      fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS,\n      focalDistance,\n      padding,\n      near,\n      far\n    });\n    // Note: As usual, matrix operations should be applied in \"reverse\" order\n    // since vectors will be multiplied in from the right during transformation\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, this.projectionMatrix);\n    mat4.multiply(vpm, vpm, this.viewMatrix);\n    this.viewProjectionMatrix = vpm;\n    // console.log('VPM', this.viewMatrix, this.projectionMatrix, this.viewProjectionMatrix);\n    // Calculate inverse view matrix\n    this.viewMatrixInverse = mat4.invert([], this.viewMatrix) || this.viewMatrix;\n    // Decompose camera parameters\n    this.cameraPosition = getCameraPosition(this.viewMatrixInverse);\n    /*\n     * Builds matrices that converts preprojected lngLats to screen pixels\n     * and vice versa.\n     * Note: Currently returns bottom-left coordinates!\n     * Note: Starts with the GL projection matrix and adds steps to the\n     *       scale and translate that matrix onto the window.\n     * Note: WebGL controls clip space to screen projection with gl.viewport\n     *       and does not need this step.\n     */\n    // matrix for conversion from world location to screen (pixel) coordinates\n    const viewportMatrix = createMat4(); // matrix from NDC to viewport.\n    const pixelProjectionMatrix = createMat4(); // matrix from world space to viewport.\n    mat4.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);\n    mat4.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);\n    mat4.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);\n    this.pixelProjectionMatrix = pixelProjectionMatrix;\n    this.pixelUnprojectionMatrix = mat4.invert(createMat4(), this.pixelProjectionMatrix);\n    if (!this.pixelUnprojectionMatrix) {\n      log.warn('Pixel project matrix not invertible')();\n      // throw new Error('Pixel project matrix not invertible');\n    }\n  }\n}\nViewport.displayName = 'Viewport';\nexport default Viewport;","map":{"version":3,"names":["log","createMat4","getCameraPosition","getFrustumPlanes","Matrix4","Vector3","equals","clamp","mat4","getDistanceScales","getMeterZoom","lngLatToWorld","worldToLngLat","worldToPixels","pixelsToWorld","PROJECTION_MODE","DEGREES_TO_RADIANS","Math","PI","IDENTITY","ZERO_VECTOR","DEFAULT_DISTANCE_SCALES","unitsPerMeter","metersPerUnit","createProjectionMatrix","width","height","orthographic","fovyRadians","focalDistance","padding","near","far","aspect","matrix","fovy","perspective","left","right","top","bottom","offsetX","offsetY","Viewport","constructor","opts","_frustumPlanes","id","displayName","x","y","zoom","distanceScales","position","modelMatrix","longitude","latitude","isGeospatial","Number","isFinite","_initProps","_initMatrices","bind","project","unproject","projectPosition","unprojectPosition","projectFlat","unprojectFlat","subViewports","metersPerPixel","scale","projectionMode","WEB_MERCATOR","WEB_MERCATOR_AUTO_OFFSET","viewport","projectionMatrix","viewMatrix","xyz","topLeft","worldPosition","coord","pixelProjectionMatrix","y2","length","targetZ","z","targetZWorld","pixelUnprojectionMatrix","X","Y","Z","result","getBounds","options","unprojectOption","topRight","bottomLeft","bottomRight","min","max","coordinateOrigin","highPrecision","containsPixel","Object","assign","viewProjectionMatrix","panByPosition","coords","pixel","log2","pow","meterOffset","transformAsVector","center","add","viewMatrixUncentered","multiplyRight","translate","negate","vpm","multiply","viewMatrixInverse","invert","cameraPosition","viewportMatrix","warn"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\viewports\\viewport.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport log from '../utils/log';\nimport {createMat4, getCameraPosition, getFrustumPlanes, FrustumPlane} from '../utils/math-utils';\n\nimport {Matrix4, Vector3, equals, clamp, mat4} from '@math.gl/core';\n\nimport {\n  getDistanceScales,\n  getMeterZoom,\n  lngLatToWorld,\n  worldToLngLat,\n  worldToPixels,\n  pixelsToWorld\n} from '@math.gl/web-mercator';\n\nimport {PROJECTION_MODE} from '../lib/constants';\n\nexport type DistanceScales = {\n  unitsPerMeter: number[];\n  metersPerUnit: number[];\n};\n\nexport type Padding = {\n  left?: number;\n  right?: number;\n  top?: number;\n  bottom?: number;\n};\n\nexport type ViewportOptions = {\n  /** Name of the viewport */\n  id?: string;\n  /** Left offset from the canvas edge, in pixels */\n  x?: number;\n  /** Top offset from the canvas edge, in pixels */\n  y?: number;\n  /** Viewport width in pixels */\n  width?: number;\n  /** Viewport height in pixels */\n  height?: number;\n  /** Longitude in degrees (geospatial only) */\n  longitude?: number;\n  /** Latitude in degrees (geospatial only) */\n  latitude?: number;\n  /** Viewport center in world space. If geospatial, refers to meter offsets from lng, lat, elevation */\n  position?: number[];\n  /** Zoom level */\n  zoom?: number;\n  /** Padding around the viewport, in pixels. */\n  padding?: Padding | null;\n  distanceScales?: DistanceScales;\n  /** Model matrix of viewport center */\n  modelMatrix?: number[] | null;\n  /** Custom view matrix */\n  viewMatrix?: number[];\n  /** Custom projection matrix */\n  projectionMatrix?: number[];\n  /** Modifier of viewport scale. Corresponds to the number of pixels per common unit at zoom 0. */\n  focalDistance?: number;\n  /** Use orthographic projection */\n  orthographic?: boolean;\n  /** fovy in radians. If supplied, overrides fovy */\n  fovyRadians?: number;\n  /** fovy in degrees. */\n  fovy?: number;\n  /** Near plane of the projection matrix */\n  near?: number;\n  /** Far plane of the projection matrix */\n  far?: number;\n};\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\n\nconst IDENTITY = createMat4();\n\nconst ZERO_VECTOR = [0, 0, 0];\n\nconst DEFAULT_DISTANCE_SCALES: DistanceScales = {\n  unitsPerMeter: [1, 1, 1],\n  metersPerUnit: [1, 1, 1]\n};\n\n// / Helpers\nfunction createProjectionMatrix({\n  width,\n  height,\n  orthographic,\n  fovyRadians,\n  focalDistance,\n  padding,\n  near,\n  far\n}: {\n  width: number;\n  height: number;\n  orthographic: boolean;\n  fovyRadians: number;\n  focalDistance: number;\n  padding: Padding | null;\n  near: number;\n  far: number;\n}) {\n  const aspect = width / height;\n  const matrix = orthographic\n    ? new Matrix4().orthographic({fovy: fovyRadians, aspect, focalDistance, near, far})\n    : new Matrix4().perspective({fovy: fovyRadians, aspect, near, far});\n  if (padding) {\n    const {left = 0, right = 0, top = 0, bottom = 0} = padding;\n    const offsetX = clamp((left + width - right) / 2, 0, width) - width / 2;\n    const offsetY = clamp((top + height - bottom) / 2, 0, height) - height / 2;\n    // pixels to clip space\n    matrix[8] -= (offsetX * 2) / width;\n    matrix[9] += (offsetY * 2) / height;\n  }\n  return matrix;\n}\n\n/**\n * Manages coordinate system transformations.\n *\n * Note: The Viewport is immutable in the sense that it only has accessors.\n * A new viewport instance should be created if any parameters have changed.\n */\nexport default class Viewport {\n  static displayName = 'Viewport';\n\n  /** Init parameters */\n\n  id: string;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  padding?: Padding | null;\n  isGeospatial: boolean;\n  zoom: number;\n  focalDistance: number;\n  position: number[];\n  modelMatrix: number[] | null;\n\n  /** Derived parameters */\n\n  // `!` post-fix expression operator asserts that its operand is non-null and non-undefined in contexts\n  // where the type checker is unable to conclude that fact.\n\n  distanceScales: DistanceScales; /** scale factors between world space and common space */\n  scale!: number; /** scale factor, equals 2^zoom */\n  center!: number[]; /** viewport center in common space */\n  cameraPosition!: number[]; /** Camera position in common space */\n  projectionMatrix!: number[];\n  viewMatrix!: number[];\n  viewMatrixUncentered!: number[];\n  viewMatrixInverse!: number[];\n  viewProjectionMatrix!: number[];\n  pixelProjectionMatrix!: number[];\n  pixelUnprojectionMatrix!: number[];\n  resolution?: number;\n\n  private _frustumPlanes: {[name: string]: FrustumPlane} = {};\n\n  // eslint-disable-next-line complexity\n  constructor(opts: ViewportOptions = {}) {\n    // @ts-ignore\n    this.id = opts.id || this.constructor.displayName || 'viewport';\n\n    this.x = opts.x || 0;\n    this.y = opts.y || 0;\n    // Silently allow apps to send in w,h = 0,0\n    this.width = opts.width || 1;\n    this.height = opts.height || 1;\n    this.zoom = opts.zoom || 0;\n    this.padding = opts.padding;\n    this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;\n    this.focalDistance = opts.focalDistance || 1;\n    this.position = opts.position || ZERO_VECTOR;\n    this.modelMatrix = opts.modelMatrix || null;\n\n    const {longitude, latitude} = opts;\n    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);\n\n    this._initProps(opts);\n    this._initMatrices(opts);\n\n    // Bind methods for easy access\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    this.projectFlat = this.projectFlat.bind(this);\n    this.unprojectFlat = this.unprojectFlat.bind(this);\n  }\n\n  get subViewports(): Viewport[] | null {\n    return null;\n  }\n\n  get metersPerPixel(): number {\n    return this.distanceScales.metersPerUnit[2] / this.scale;\n  }\n\n  get projectionMode(): number {\n    if (this.isGeospatial) {\n      return this.zoom < 12\n        ? PROJECTION_MODE.WEB_MERCATOR\n        : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;\n    }\n    return PROJECTION_MODE.IDENTITY;\n  }\n\n  // Two viewports are equal if width and height are identical, and if\n  // their view and projection matrices are (approximately) equal.\n  equals(viewport: Viewport): boolean {\n    if (!(viewport instanceof Viewport)) {\n      return false;\n    }\n    if (this === viewport) {\n      return true;\n    }\n\n    return (\n      viewport.width === this.width &&\n      viewport.height === this.height &&\n      viewport.scale === this.scale &&\n      equals(viewport.projectionMatrix, this.projectionMatrix) &&\n      equals(viewport.viewMatrix, this.viewMatrix)\n    );\n    // TODO - check distance scales?\n  }\n\n  /**\n   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n   * using viewport projection parameters\n   * - [longitude, latitude] to [x, y]\n   * - [longitude, latitude, Z] => [x, y, z]\n   * Note: By default, returns top-left coordinates for canvas/SVG type render\n   *\n   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]\n   * @param {Object} opts - options\n   * @param {Object} opts.topLeft=true - Whether projected coords are top left\n   * @return {Array} - [x, y] or [x, y, z] in top left coords\n   */\n  project(xyz: number[], {topLeft = true}: {topLeft?: boolean} = {}): number[] {\n    const worldPosition = this.projectPosition(xyz);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  }\n\n  /**\n   * Unproject pixel coordinates on screen onto world coordinates,\n   * (possibly [lon, lat]) on map.\n   * - [x, y] => [lng, lat]\n   * - [x, y, z] => [lng, lat, Z]\n   * @param {Array} xyz -\n   * @param {Object} opts - options\n   * @param {Object} opts.topLeft=true - Whether origin is top left\n   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]\n   */\n  unproject(\n    xyz: number[],\n    {topLeft = true, targetZ}: {topLeft?: boolean; targetZ?: number} = {}\n  ): number[] {\n    const [x, y, z] = xyz;\n\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ as number] : [X, Y];\n  }\n\n  // NON_LINEAR PROJECTION HOOKS\n  // Used for web meractor projection\n\n  projectPosition(xyz: number[]): [number, number, number] {\n    const [X, Y] = this.projectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n    return [X, Y, Z];\n  }\n\n  unprojectPosition(xyz: number[]): [number, number, number] {\n    const [X, Y] = this.unprojectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n    return [X, Y, Z];\n  }\n\n  /**\n   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n   * Performs the nonlinear part of the web mercator projection.\n   * Remaining projection is done with 4x4 matrices which also handles\n   * perspective.\n   * @param {Array} lngLat - [lng, lat] coordinates\n   *   Specifies a point on the sphere to project onto the map.\n   * @return {Array} [x,y] coordinates.\n   */\n  projectFlat(xyz: number[]): [number, number] {\n    if (this.isGeospatial) {\n      // Shader clamps latitude to +-89.9, see /shaderlib/project/project.glsl.js\n      // lngLatToWorld([0, -89.9])[1] = -317.9934163758329\n      // lngLatToWorld([0, 89.9])[1] = 829.9934163758271\n      const result = lngLatToWorld(xyz);\n      result[1] = clamp(result[1], -318, 830);\n      return result;\n    }\n    return xyz as [number, number];\n  }\n\n  /**\n   * Unproject world point [x,y] on map onto {lat, lon} on sphere\n   * @param {object|Vector} xy - object with {x,y} members\n   *  representing point on projected map plane\n   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n   *   Has toArray method if you need a GeoJSON Array.\n   *   Per cartographic tradition, lat and lon are specified as degrees.\n   */\n  unprojectFlat(xyz: number[]): [number, number] {\n    if (this.isGeospatial) {\n      return worldToLngLat(xyz);\n    }\n    return xyz as [number, number];\n  }\n\n  /**\n   * Get bounds of the current viewport\n   * @return {Array} - [minX, minY, maxX, maxY]\n   */\n  getBounds(options: {z?: number} = {}): [number, number, number, number] {\n    const unprojectOption = {targetZ: options.z || 0};\n\n    const topLeft = this.unproject([0, 0], unprojectOption);\n    const topRight = this.unproject([this.width, 0], unprojectOption);\n    const bottomLeft = this.unproject([0, this.height], unprojectOption);\n    const bottomRight = this.unproject([this.width, this.height], unprojectOption);\n\n    return [\n      Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),\n      Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),\n      Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),\n      Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])\n    ];\n  }\n\n  getDistanceScales(coordinateOrigin?: number[]): DistanceScales {\n    if (coordinateOrigin && this.isGeospatial) {\n      return getDistanceScales({\n        longitude: coordinateOrigin[0],\n        latitude: coordinateOrigin[1],\n        highPrecision: true\n      });\n    }\n    return this.distanceScales;\n  }\n\n  containsPixel({\n    x,\n    y,\n    width = 1,\n    height = 1\n  }: {\n    x: number;\n    y: number;\n    width?: number;\n    height?: number;\n  }): boolean {\n    return (\n      x < this.x + this.width &&\n      this.x < x + width &&\n      y < this.y + this.height &&\n      this.y < y + height\n    );\n  }\n\n  // Extract frustum planes in common space\n  getFrustumPlanes(): {\n    left: FrustumPlane;\n    right: FrustumPlane;\n    bottom: FrustumPlane;\n    top: FrustumPlane;\n    near: FrustumPlane;\n    far: FrustumPlane;\n  } {\n    if (this._frustumPlanes.near) {\n      // @ts-ignore\n      return this._frustumPlanes;\n    }\n\n    Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));\n\n    // @ts-ignore\n    return this._frustumPlanes;\n  }\n\n  // EXPERIMENTAL METHODS\n\n  /**\n   * Needed by panning and linear transition\n   * Pan the viewport to place a given world coordinate at screen point [x, y]\n   *\n   * @param {Array} coords - world coordinates\n   * @param {Array} pixel - [x,y] coordinates on screen\n   * @return {Object} props of the new viewport\n   */\n  panByPosition(coords: number[], pixel: number[]): any {\n    return null;\n  }\n\n  // INTERNAL METHODS\n\n  /* eslint-disable complexity, max-statements */\n  private _initProps(opts: ViewportOptions) {\n    const longitude = opts.longitude as number;\n    const latitude = opts.latitude as number;\n\n    if (this.isGeospatial) {\n      if (!Number.isFinite(opts.zoom)) {\n        this.zoom = getMeterZoom({latitude}) + Math.log2(this.focalDistance);\n      }\n      this.distanceScales = opts.distanceScales || getDistanceScales({latitude, longitude});\n    }\n    const scale = Math.pow(2, this.zoom);\n    this.scale = scale;\n\n    const {position, modelMatrix} = opts;\n    let meterOffset: number[] = ZERO_VECTOR;\n    if (position) {\n      meterOffset = modelMatrix\n        ? (new Matrix4(modelMatrix).transformAsVector(position, []) as number[])\n        : position;\n    }\n\n    if (this.isGeospatial) {\n      // Determine camera center in common space\n      const center = this.projectPosition([longitude, latitude, 0]);\n\n      this.center = new Vector3(meterOffset)\n        // Convert to pixels in current zoom\n        .scale(this.distanceScales.unitsPerMeter)\n        .add(center);\n    } else {\n      this.center = this.projectPosition(meterOffset);\n    }\n  }\n  /* eslint-enable complexity, max-statements */\n\n  private _initMatrices(opts: ViewportOptions) {\n    const {\n      // View matrix\n      viewMatrix = IDENTITY,\n      // Projection matrix\n      projectionMatrix = null,\n\n      // Projection matrix parameters, used if projectionMatrix not supplied\n      orthographic = false,\n      fovyRadians,\n      fovy = 75,\n      near = 0.1, // Distance of near clipping plane\n      far = 1000, // Distance of far clipping plane\n      padding = null, // Center offset in pixels\n      focalDistance = 1\n    } = opts;\n\n    this.viewMatrixUncentered = viewMatrix;\n    // Make a centered version of the matrix for projection modes without an offset\n    this.viewMatrix = new Matrix4()\n      // Apply the uncentered view matrix\n      .multiplyRight(viewMatrix)\n      // And center it\n      .translate(new Vector3(this.center).negate());\n\n    this.projectionMatrix =\n      projectionMatrix ||\n      createProjectionMatrix({\n        width: this.width,\n        height: this.height,\n        orthographic,\n        fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS,\n        focalDistance,\n        padding,\n        near,\n        far\n      });\n\n    // Note: As usual, matrix operations should be applied in \"reverse\" order\n    // since vectors will be multiplied in from the right during transformation\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, this.projectionMatrix);\n    mat4.multiply(vpm, vpm, this.viewMatrix);\n    this.viewProjectionMatrix = vpm;\n\n    // console.log('VPM', this.viewMatrix, this.projectionMatrix, this.viewProjectionMatrix);\n\n    // Calculate inverse view matrix\n    this.viewMatrixInverse = mat4.invert([], this.viewMatrix) || this.viewMatrix;\n\n    // Decompose camera parameters\n    this.cameraPosition = getCameraPosition(this.viewMatrixInverse);\n\n    /*\n     * Builds matrices that converts preprojected lngLats to screen pixels\n     * and vice versa.\n     * Note: Currently returns bottom-left coordinates!\n     * Note: Starts with the GL projection matrix and adds steps to the\n     *       scale and translate that matrix onto the window.\n     * Note: WebGL controls clip space to screen projection with gl.viewport\n     *       and does not need this step.\n     */\n\n    // matrix for conversion from world location to screen (pixel) coordinates\n    const viewportMatrix = createMat4(); // matrix from NDC to viewport.\n    const pixelProjectionMatrix = createMat4(); // matrix from world space to viewport.\n    mat4.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);\n    mat4.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);\n    mat4.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);\n    this.pixelProjectionMatrix = pixelProjectionMatrix;\n\n    this.pixelUnprojectionMatrix = mat4.invert(createMat4(), this.pixelProjectionMatrix);\n    if (!this.pixelUnprojectionMatrix) {\n      log.warn('Pixel project matrix not invertible')();\n      // throw new Error('Pixel project matrix not invertible');\n    }\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA,OAAOA,GAAG;AACV,SAAQC,UAAU,EAAEC,iBAAiB,EAAEC,gBAAgB,QAAe;AAEtE,SAAQC,OAAO,EAAEC,OAAO,EAAEC,MAAM,EAAEC,KAAK,EAAEC,IAAI,QAAO,eAAe;AAEnE,SACEC,iBAAiB,EACjBC,YAAY,EACZC,aAAa,EACbC,aAAa,EACbC,aAAa,EACbC,aAAa,QACR,uBAAuB;AAE9B,SAAQC,eAAe,QAAC;AAwDxB,MAAMC,kBAAkB,GAAGC,IAAI,CAACC,EAAE,GAAG,GAAG;AAExC,MAAMC,QAAQ,GAAGlB,UAAU,EAAE;AAE7B,MAAMmB,WAAW,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AAE7B,MAAMC,uBAAuB,GAAmB;EAC9CC,aAAa,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACxBC,aAAa,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC;CACxB;AAED;AACA,SAASC,sBAAsBA,CAAC;EAC9BC,KAAK;EACLC,MAAM;EACNC,YAAY;EACZC,WAAW;EACXC,aAAa;EACbC,OAAO;EACPC,IAAI;EACJC;AAAG,CAUJ;EACC,MAAMC,MAAM,GAAGR,KAAK,GAAGC,MAAM;EAC7B,MAAMQ,MAAM,GAAGP,YAAY,GACvB,IAAIvB,OAAO,EAAE,CAACuB,YAAY,CAAC;IAACQ,IAAI,EAAEP,WAAW;IAAEK,MAAM;IAAEJ,aAAa;IAAEE,IAAI;IAAEC;EAAG,CAAC,CAAC,GACjF,IAAI5B,OAAO,EAAE,CAACgC,WAAW,CAAC;IAACD,IAAI,EAAEP,WAAW;IAAEK,MAAM;IAAEF,IAAI;IAAEC;EAAG,CAAC,CAAC;EACrE,IAAIF,OAAO,EAAE;IACX,MAAM;MAACO,IAAI,GAAG,CAAC;MAAEC,KAAK,GAAG,CAAC;MAAEC,GAAG,GAAG,CAAC;MAAEC,MAAM,GAAG;IAAC,CAAC,GAAGV,OAAO;IAC1D,MAAMW,OAAO,GAAGlC,KAAK,CAAC,CAAC8B,IAAI,GAAGZ,KAAK,GAAGa,KAAK,IAAI,CAAC,EAAE,CAAC,EAAEb,KAAK,CAAC,GAAGA,KAAK,GAAG,CAAC;IACvE,MAAMiB,OAAO,GAAGnC,KAAK,CAAC,CAACgC,GAAG,GAAGb,MAAM,GAAGc,MAAM,IAAI,CAAC,EAAE,CAAC,EAAEd,MAAM,CAAC,GAAGA,MAAM,GAAG,CAAC;IAC1E;IACAQ,MAAM,CAAC,CAAC,CAAC,IAAKO,OAAO,GAAG,CAAC,GAAIhB,KAAK;IAClCS,MAAM,CAAC,CAAC,CAAC,IAAKQ,OAAO,GAAG,CAAC,GAAIhB,MAAM;EACrC;EACA,OAAOQ,MAAM;AACf;AAEA;;;;;;AAMA,MAAqBS,QAAQ;EAqC3B;EACAC,YAAYC,IAAA,GAAwB,EAAE;IAH9B,KAAAC,cAAc,GAAmC,EAAE;IAIzD;IACA,IAAI,CAACC,EAAE,GAAGF,IAAI,CAACE,EAAE,IAAI,IAAI,CAACH,WAAW,CAACI,WAAW,IAAI,UAAU;IAE/D,IAAI,CAACC,CAAC,GAAGJ,IAAI,CAACI,CAAC,IAAI,CAAC;IACpB,IAAI,CAACC,CAAC,GAAGL,IAAI,CAACK,CAAC,IAAI,CAAC;IACpB;IACA,IAAI,CAACzB,KAAK,GAAGoB,IAAI,CAACpB,KAAK,IAAI,CAAC;IAC5B,IAAI,CAACC,MAAM,GAAGmB,IAAI,CAACnB,MAAM,IAAI,CAAC;IAC9B,IAAI,CAACyB,IAAI,GAAGN,IAAI,CAACM,IAAI,IAAI,CAAC;IAC1B,IAAI,CAACrB,OAAO,GAAGe,IAAI,CAACf,OAAO;IAC3B,IAAI,CAACsB,cAAc,GAAGP,IAAI,CAACO,cAAc,IAAI/B,uBAAuB;IACpE,IAAI,CAACQ,aAAa,GAAGgB,IAAI,CAAChB,aAAa,IAAI,CAAC;IAC5C,IAAI,CAACwB,QAAQ,GAAGR,IAAI,CAACQ,QAAQ,IAAIjC,WAAW;IAC5C,IAAI,CAACkC,WAAW,GAAGT,IAAI,CAACS,WAAW,IAAI,IAAI;IAE3C,MAAM;MAACC,SAAS;MAAEC;IAAQ,CAAC,GAAGX,IAAI;IAClC,IAAI,CAACY,YAAY,GAAGC,MAAM,CAACC,QAAQ,CAACH,QAAQ,CAAC,IAAIE,MAAM,CAACC,QAAQ,CAACJ,SAAS,CAAC;IAE3E,IAAI,CAACK,UAAU,CAACf,IAAI,CAAC;IACrB,IAAI,CAACgB,aAAa,CAAChB,IAAI,CAAC;IAExB;IACA,IAAI,CAACvC,MAAM,GAAG,IAAI,CAACA,MAAM,CAACwD,IAAI,CAAC,IAAI,CAAC;IACpC,IAAI,CAACC,OAAO,GAAG,IAAI,CAACA,OAAO,CAACD,IAAI,CAAC,IAAI,CAAC;IACtC,IAAI,CAACE,SAAS,GAAG,IAAI,CAACA,SAAS,CAACF,IAAI,CAAC,IAAI,CAAC;IAC1C,IAAI,CAACG,eAAe,GAAG,IAAI,CAACA,eAAe,CAACH,IAAI,CAAC,IAAI,CAAC;IACtD,IAAI,CAACI,iBAAiB,GAAG,IAAI,CAACA,iBAAiB,CAACJ,IAAI,CAAC,IAAI,CAAC;IAC1D,IAAI,CAACK,WAAW,GAAG,IAAI,CAACA,WAAW,CAACL,IAAI,CAAC,IAAI,CAAC;IAC9C,IAAI,CAACM,aAAa,GAAG,IAAI,CAACA,aAAa,CAACN,IAAI,CAAC,IAAI,CAAC;EACpD;EAEA,IAAIO,YAAYA,CAAA;IACd,OAAO,IAAI;EACb;EAEA,IAAIC,cAAcA,CAAA;IAChB,OAAO,IAAI,CAAClB,cAAc,CAAC7B,aAAa,CAAC,CAAC,CAAC,GAAG,IAAI,CAACgD,KAAK;EAC1D;EAEA,IAAIC,cAAcA,CAAA;IAChB,IAAI,IAAI,CAACf,YAAY,EAAE;MACrB,OAAO,IAAI,CAACN,IAAI,GAAG,EAAE,GACjBpC,eAAe,CAAC0D,YAAY,GAC5B1D,eAAe,CAAC2D,wBAAwB;IAC9C;IACA,OAAO3D,eAAe,CAACI,QAAQ;EACjC;EAEA;EACA;EACAb,MAAMA,CAACqE,QAAkB;IACvB,IAAI,EAAEA,QAAQ,YAAYhC,QAAQ,CAAC,EAAE;MACnC,OAAO,KAAK;IACd;IACA,IAAI,IAAI,KAAKgC,QAAQ,EAAE;MACrB,OAAO,IAAI;IACb;IAEA,OACEA,QAAQ,CAAClD,KAAK,KAAK,IAAI,CAACA,KAAK,IAC7BkD,QAAQ,CAACjD,MAAM,KAAK,IAAI,CAACA,MAAM,IAC/BiD,QAAQ,CAACJ,KAAK,KAAK,IAAI,CAACA,KAAK,IAC7BjE,MAAM,CAACqE,QAAQ,CAACC,gBAAgB,EAAE,IAAI,CAACA,gBAAgB,CAAC,IACxDtE,MAAM,CAACqE,QAAQ,CAACE,UAAU,EAAE,IAAI,CAACA,UAAU,CAAC;IAE9C;EACF;EAEA;;;;;;;;;;;;EAYAd,OAAOA,CAACe,GAAa,EAAE;IAACC,OAAO,GAAG;EAAI,IAAyB,EAAE;IAC/D,MAAMC,aAAa,GAAG,IAAI,CAACf,eAAe,CAACa,GAAG,CAAC;IAC/C,MAAMG,KAAK,GAAGpE,aAAa,CAACmE,aAAa,EAAE,IAAI,CAACE,qBAAqB,CAAC;IAEtE,MAAM,CAACjC,CAAC,EAAEC,CAAC,CAAC,GAAG+B,KAAK;IACpB,MAAME,EAAE,GAAGJ,OAAO,GAAG7B,CAAC,GAAG,IAAI,CAACxB,MAAM,GAAGwB,CAAC;IACxC,OAAO4B,GAAG,CAACM,MAAM,KAAK,CAAC,GAAG,CAACnC,CAAC,EAAEkC,EAAE,CAAC,GAAG,CAAClC,CAAC,EAAEkC,EAAE,EAAEF,KAAK,CAAC,CAAC,CAAC,CAAC;EACvD;EAEA;;;;;;;;;;EAUAjB,SAASA,CACPc,GAAa,EACb;IAACC,OAAO,GAAG,IAAI;IAAEM;EAAO,IAA2C,EAAE;IAErE,MAAM,CAACpC,CAAC,EAAEC,CAAC,EAAEoC,CAAC,CAAC,GAAGR,GAAG;IAErB,MAAMK,EAAE,GAAGJ,OAAO,GAAG7B,CAAC,GAAG,IAAI,CAACxB,MAAM,GAAGwB,CAAC;IACxC,MAAMqC,YAAY,GAAGF,OAAO,IAAIA,OAAO,GAAG,IAAI,CAACjC,cAAc,CAAC9B,aAAa,CAAC,CAAC,CAAC;IAC9E,MAAM2D,KAAK,GAAGnE,aAAa,CAAC,CAACmC,CAAC,EAAEkC,EAAE,EAAEG,CAAC,CAAC,EAAE,IAAI,CAACE,uBAAuB,EAAED,YAAY,CAAC;IACnF,MAAM,CAACE,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,GAAG,IAAI,CAACzB,iBAAiB,CAACe,KAAK,CAAC;IAE/C,IAAIvB,MAAM,CAACC,QAAQ,CAAC2B,CAAC,CAAC,EAAE;MACtB,OAAO,CAACG,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;IAClB;IACA,OAAOjC,MAAM,CAACC,QAAQ,CAAC0B,OAAO,CAAC,GAAG,CAACI,CAAC,EAAEC,CAAC,EAAEL,OAAiB,CAAC,GAAG,CAACI,CAAC,EAAEC,CAAC,CAAC;EACtE;EAEA;EACA;EAEAzB,eAAeA,CAACa,GAAa;IAC3B,MAAM,CAACW,CAAC,EAAEC,CAAC,CAAC,GAAG,IAAI,CAACvB,WAAW,CAACW,GAAG,CAAC;IACpC,MAAMa,CAAC,GAAG,CAACb,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC1B,cAAc,CAAC9B,aAAa,CAAC,CAAC,CAAC;IAC9D,OAAO,CAACmE,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;EAClB;EAEAzB,iBAAiBA,CAACY,GAAa;IAC7B,MAAM,CAACW,CAAC,EAAEC,CAAC,CAAC,GAAG,IAAI,CAACtB,aAAa,CAACU,GAAG,CAAC;IACtC,MAAMa,CAAC,GAAG,CAACb,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC1B,cAAc,CAAC7B,aAAa,CAAC,CAAC,CAAC;IAC9D,OAAO,CAACkE,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;EAClB;EAEA;;;;;;;;;EASAxB,WAAWA,CAACW,GAAa;IACvB,IAAI,IAAI,CAACrB,YAAY,EAAE;MACrB;MACA;MACA;MACA,MAAMmC,MAAM,GAAGjF,aAAa,CAACmE,GAAG,CAAC;MACjCc,MAAM,CAAC,CAAC,CAAC,GAAGrF,KAAK,CAACqF,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC;MACvC,OAAOA,MAAM;IACf;IACA,OAAOd,GAAuB;EAChC;EAEA;;;;;;;;EAQAV,aAAaA,CAACU,GAAa;IACzB,IAAI,IAAI,CAACrB,YAAY,EAAE;MACrB,OAAO7C,aAAa,CAACkE,GAAG,CAAC;IAC3B;IACA,OAAOA,GAAuB;EAChC;EAEA;;;;EAIAe,SAASA,CAACC,OAAA,GAAwB,EAAE;IAClC,MAAMC,eAAe,GAAG;MAACV,OAAO,EAAES,OAAO,CAACR,CAAC,IAAI;IAAC,CAAC;IAEjD,MAAMP,OAAO,GAAG,IAAI,CAACf,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE+B,eAAe,CAAC;IACvD,MAAMC,QAAQ,GAAG,IAAI,CAAChC,SAAS,CAAC,CAAC,IAAI,CAACvC,KAAK,EAAE,CAAC,CAAC,EAAEsE,eAAe,CAAC;IACjE,MAAME,UAAU,GAAG,IAAI,CAACjC,SAAS,CAAC,CAAC,CAAC,EAAE,IAAI,CAACtC,MAAM,CAAC,EAAEqE,eAAe,CAAC;IACpE,MAAMG,WAAW,GAAG,IAAI,CAAClC,SAAS,CAAC,CAAC,IAAI,CAACvC,KAAK,EAAE,IAAI,CAACC,MAAM,CAAC,EAAEqE,eAAe,CAAC;IAE9E,OAAO,CACL9E,IAAI,CAACkF,GAAG,CAACpB,OAAO,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAAC,CAAC,CAAC,EAAEC,UAAU,CAAC,CAAC,CAAC,EAAEC,WAAW,CAAC,CAAC,CAAC,CAAC,EAChEjF,IAAI,CAACkF,GAAG,CAACpB,OAAO,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAAC,CAAC,CAAC,EAAEC,UAAU,CAAC,CAAC,CAAC,EAAEC,WAAW,CAAC,CAAC,CAAC,CAAC,EAChEjF,IAAI,CAACmF,GAAG,CAACrB,OAAO,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAAC,CAAC,CAAC,EAAEC,UAAU,CAAC,CAAC,CAAC,EAAEC,WAAW,CAAC,CAAC,CAAC,CAAC,EAChEjF,IAAI,CAACmF,GAAG,CAACrB,OAAO,CAAC,CAAC,CAAC,EAAEiB,QAAQ,CAAC,CAAC,CAAC,EAAEC,UAAU,CAAC,CAAC,CAAC,EAAEC,WAAW,CAAC,CAAC,CAAC,CAAC,CACjE;EACH;EAEAzF,iBAAiBA,CAAC4F,gBAA2B;IAC3C,IAAIA,gBAAgB,IAAI,IAAI,CAAC5C,YAAY,EAAE;MACzC,OAAOhD,iBAAiB,CAAC;QACvB8C,SAAS,EAAE8C,gBAAgB,CAAC,CAAC,CAAC;QAC9B7C,QAAQ,EAAE6C,gBAAgB,CAAC,CAAC,CAAC;QAC7BC,aAAa,EAAE;OAChB,CAAC;IACJ;IACA,OAAO,IAAI,CAAClD,cAAc;EAC5B;EAEAmD,aAAaA,CAAC;IACZtD,CAAC;IACDC,CAAC;IACDzB,KAAK,GAAG,CAAC;IACTC,MAAM,GAAG;EAAC,CAMX;IACC,OACEuB,CAAC,GAAG,IAAI,CAACA,CAAC,GAAG,IAAI,CAACxB,KAAK,IACvB,IAAI,CAACwB,CAAC,GAAGA,CAAC,GAAGxB,KAAK,IAClByB,CAAC,GAAG,IAAI,CAACA,CAAC,GAAG,IAAI,CAACxB,MAAM,IACxB,IAAI,CAACwB,CAAC,GAAGA,CAAC,GAAGxB,MAAM;EAEvB;EAEA;EACAvB,gBAAgBA,CAAA;IAQd,IAAI,IAAI,CAAC2C,cAAc,CAACf,IAAI,EAAE;MAC5B;MACA,OAAO,IAAI,CAACe,cAAc;IAC5B;IAEA0D,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC3D,cAAc,EAAE3C,gBAAgB,CAAC,IAAI,CAACuG,oBAAoB,CAAC,CAAC;IAE/E;IACA,OAAO,IAAI,CAAC5D,cAAc;EAC5B;EAEA;EAEA;;;;;;;;EAQA6D,aAAaA,CAACC,MAAgB,EAAEC,KAAe;IAC7C,OAAO,IAAI;EACb;EAEA;EAEA;EACQjD,UAAUA,CAACf,IAAqB;IACtC,MAAMU,SAAS,GAAGV,IAAI,CAACU,SAAmB;IAC1C,MAAMC,QAAQ,GAAGX,IAAI,CAACW,QAAkB;IAExC,IAAI,IAAI,CAACC,YAAY,EAAE;MACrB,IAAI,CAACC,MAAM,CAACC,QAAQ,CAACd,IAAI,CAACM,IAAI,CAAC,EAAE;QAC/B,IAAI,CAACA,IAAI,GAAGzC,YAAY,CAAC;UAAC8C;QAAQ,CAAC,CAAC,GAAGvC,IAAI,CAAC6F,IAAI,CAAC,IAAI,CAACjF,aAAa,CAAC;MACtE;MACA,IAAI,CAACuB,cAAc,GAAGP,IAAI,CAACO,cAAc,IAAI3C,iBAAiB,CAAC;QAAC+C,QAAQ;QAAED;MAAS,CAAC,CAAC;IACvF;IACA,MAAMgB,KAAK,GAAGtD,IAAI,CAAC8F,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC5D,IAAI,CAAC;IACpC,IAAI,CAACoB,KAAK,GAAGA,KAAK;IAElB,MAAM;MAAClB,QAAQ;MAAEC;IAAW,CAAC,GAAGT,IAAI;IACpC,IAAImE,WAAW,GAAa5F,WAAW;IACvC,IAAIiC,QAAQ,EAAE;MACZ2D,WAAW,GAAG1D,WAAW,GACpB,IAAIlD,OAAO,CAACkD,WAAW,CAAC,CAAC2D,iBAAiB,CAAC5D,QAAQ,EAAE,EAAE,CAAc,GACtEA,QAAQ;IACd;IAEA,IAAI,IAAI,CAACI,YAAY,EAAE;MACrB;MACA,MAAMyD,MAAM,GAAG,IAAI,CAACjD,eAAe,CAAC,CAACV,SAAS,EAAEC,QAAQ,EAAE,CAAC,CAAC,CAAC;MAE7D,IAAI,CAAC0D,MAAM,GAAG,IAAI7G,OAAO,CAAC2G,WAAW;MACnC;MAAA,CACCzC,KAAK,CAAC,IAAI,CAACnB,cAAc,CAAC9B,aAAa,CAAC,CACxC6F,GAAG,CAACD,MAAM,CAAC;IAChB,CAAC,MAAM;MACL,IAAI,CAACA,MAAM,GAAG,IAAI,CAACjD,eAAe,CAAC+C,WAAW,CAAC;IACjD;EACF;EACA;EAEQnD,aAAaA,CAAChB,IAAqB;IACzC,MAAM;MACJ;MACAgC,UAAU,GAAG1D,QAAQ;MACrB;MACAyD,gBAAgB,GAAG,IAAI;MAEvB;MACAjD,YAAY,GAAG,KAAK;MACpBC,WAAW;MACXO,IAAI,GAAG,EAAE;MACTJ,IAAI,GAAG,GAAG;MAAE;MACZC,GAAG,GAAG,IAAI;MAAE;MACZF,OAAO,GAAG,IAAI;MAAE;MAChBD,aAAa,GAAG;IAAC,CAClB,GAAGgB,IAAI;IAER,IAAI,CAACuE,oBAAoB,GAAGvC,UAAU;IACtC;IACA,IAAI,CAACA,UAAU,GAAG,IAAIzE,OAAO;IAC3B;IAAA,CACCiH,aAAa,CAACxC,UAAU;IACzB;IAAA,CACCyC,SAAS,CAAC,IAAIjH,OAAO,CAAC,IAAI,CAAC6G,MAAM,CAAC,CAACK,MAAM,EAAE,CAAC;IAE/C,IAAI,CAAC3C,gBAAgB,GACnBA,gBAAgB,IAChBpD,sBAAsB,CAAC;MACrBC,KAAK,EAAE,IAAI,CAACA,KAAK;MACjBC,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBC,YAAY;MACZC,WAAW,EAAEA,WAAW,IAAIO,IAAI,GAAGnB,kBAAkB;MACrDa,aAAa;MACbC,OAAO;MACPC,IAAI;MACJC;KACD,CAAC;IAEJ;IACA;IACA,MAAMwF,GAAG,GAAGvH,UAAU,EAAE;IACxBO,IAAI,CAACiH,QAAQ,CAACD,GAAG,EAAEA,GAAG,EAAE,IAAI,CAAC5C,gBAAgB,CAAC;IAC9CpE,IAAI,CAACiH,QAAQ,CAACD,GAAG,EAAEA,GAAG,EAAE,IAAI,CAAC3C,UAAU,CAAC;IACxC,IAAI,CAAC6B,oBAAoB,GAAGc,GAAG;IAE/B;IAEA;IACA,IAAI,CAACE,iBAAiB,GAAGlH,IAAI,CAACmH,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC9C,UAAU,CAAC,IAAI,IAAI,CAACA,UAAU;IAE5E;IACA,IAAI,CAAC+C,cAAc,GAAG1H,iBAAiB,CAAC,IAAI,CAACwH,iBAAiB,CAAC;IAE/D;;;;;;;;;IAUA;IACA,MAAMG,cAAc,GAAG5H,UAAU,EAAE,CAAC,CAAC;IACrC,MAAMiF,qBAAqB,GAAGjF,UAAU,EAAE,CAAC,CAAC;IAC5CO,IAAI,CAAC+D,KAAK,CAACsD,cAAc,EAAEA,cAAc,EAAE,CAAC,IAAI,CAACpG,KAAK,GAAG,CAAC,EAAE,CAAC,IAAI,CAACC,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;IACjFlB,IAAI,CAAC8G,SAAS,CAACO,cAAc,EAAEA,cAAc,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC1DrH,IAAI,CAACiH,QAAQ,CAACvC,qBAAqB,EAAE2C,cAAc,EAAE,IAAI,CAACnB,oBAAoB,CAAC;IAC/E,IAAI,CAACxB,qBAAqB,GAAGA,qBAAqB;IAElD,IAAI,CAACM,uBAAuB,GAAGhF,IAAI,CAACmH,MAAM,CAAC1H,UAAU,EAAE,EAAE,IAAI,CAACiF,qBAAqB,CAAC;IACpF,IAAI,CAAC,IAAI,CAACM,uBAAuB,EAAE;MACjCxF,GAAG,CAAC8H,IAAI,CAAC,qCAAqC,CAAC,EAAE;MACjD;IACF;EACF;;AAnZOnF,QAAA,CAAAK,WAAW,GAAG,UAAU;eADZL,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}