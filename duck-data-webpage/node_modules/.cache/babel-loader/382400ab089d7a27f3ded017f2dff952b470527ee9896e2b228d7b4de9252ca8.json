{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { makePropValidators, getValidatedProperties } from \"../filters/prop-types.js\";\nimport { normalizeInjections } from \"../shader-assembly/shader-injections.js\";\n// SHNDER MODULE API\nexport function initializeShaderModules(modules) {\n  modules.map(module => initializeShaderModule(module));\n}\nexport function initializeShaderModule(module) {\n  if (module.instance) {\n    return;\n  }\n  initializeShaderModules(module.dependencies || []);\n  const {\n    propTypes = {},\n    deprecations = [],\n    // defines = {},\n    inject = {}\n  } = module;\n  const instance = {\n    normalizedInjections: normalizeInjections(inject),\n    parsedDeprecations: parseDeprecationDefinitions(deprecations)\n  };\n  if (propTypes) {\n    instance.propValidators = makePropValidators(propTypes);\n  }\n  module.instance = instance;\n  // TODO(ib) - we need to apply the original prop types to the default uniforms\n  let defaultProps = {};\n  if (propTypes) {\n    defaultProps = Object.entries(propTypes).reduce((obj, [key, propType]) => {\n      // @ts-expect-error\n      const value = propType?.value;\n      if (value) {\n        // @ts-expect-error\n        obj[key] = value;\n      }\n      return obj;\n    }, {});\n  }\n  module.defaultUniforms = {\n    ...module.defaultUniforms,\n    ...defaultProps\n  };\n}\n/** Convert module props to uniforms */\nexport function getShaderModuleUniforms(module, props, oldUniforms) {\n  initializeShaderModule(module);\n  const uniforms = oldUniforms || {\n    ...module.defaultUniforms\n  };\n  // If module has a getUniforms function, use it\n  if (props && module.getUniforms) {\n    return module.getUniforms(props, uniforms);\n  }\n  // Build uniforms from the uniforms array\n  // @ts-expect-error\n  return getValidatedProperties(props, module.instance?.propValidators, module.name);\n}\n/* TODO this looks like it was unused code\n  _defaultGetUniforms(opts: Record<string, any> = {}): Record<string, any> {\n    const uniforms: Record<string, any> = {};\n    const propTypes = this.uniforms;\n\n    for (const key in propTypes) {\n      const propDef = propTypes[key];\n      if (key in opts && !propDef.private) {\n        if (propDef.validate) {\n          assert(propDef.validate(opts[key], propDef), `${this.name}: invalid ${key}`);\n        }\n        uniforms[key] = opts[key];\n      } else {\n        uniforms[key] = propDef.value;\n      }\n    }\n\n    return uniforms;\n  }\n}\n*/\n// Warn about deprecated uniforms or functions\nexport function checkShaderModuleDeprecations(shaderModule, shaderSource, log) {\n  shaderModule.deprecations?.forEach(def => {\n    if (def.regex?.test(shaderSource)) {\n      if (def.deprecated) {\n        log.deprecated(def.old, def.new)();\n      } else {\n        log.removed(def.old, def.new)();\n      }\n    }\n  });\n}\n// HELPERS\nfunction parseDeprecationDefinitions(deprecations) {\n  deprecations.forEach(def => {\n    switch (def.type) {\n      case 'function':\n        def.regex = new RegExp(`\\\\b${def.old}\\\\(`);\n        break;\n      default:\n        def.regex = new RegExp(`${def.type} ${def.old};`);\n    }\n  });\n  return deprecations;\n}","map":{"version":3,"names":["makePropValidators","getValidatedProperties","normalizeInjections","initializeShaderModules","modules","map","module","initializeShaderModule","instance","dependencies","propTypes","deprecations","inject","normalizedInjections","parsedDeprecations","parseDeprecationDefinitions","propValidators","defaultProps","Object","entries","reduce","obj","key","propType","value","defaultUniforms","getShaderModuleUniforms","props","oldUniforms","uniforms","getUniforms","name","checkShaderModuleDeprecations","shaderModule","shaderSource","log","forEach","def","regex","test","deprecated","old","new","removed","type","RegExp"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\shadertools\\src\\lib\\shader-module\\shader-module.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {UniformFormat} from '../../types';\nimport {\n  PropType,\n  PropValidator,\n  makePropValidators,\n  getValidatedProperties\n} from '../filters/prop-types';\nimport type {UniformTypes, UniformValue} from '../utils/uniform-types';\nimport {ShaderInjection, normalizeInjections} from '../shader-assembly/shader-injections';\n\n// To avoid dependency on core module, do not import `Binding` type.\n// The ShaderModule is not concerned with the type of `Binding`,\n// it is the repsonsibility of `splitUniformsAndBindings` in\n// ShaderInputs to type the result of `getUniforms()`\ntype Binding = unknown; // import type {Binding} from '@luma.gl/core';\n\nexport type UniformInfo = {\n  format?: UniformFormat;\n} & PropType;\n\n// Helper types\ntype BindingKeys<T> = {[K in keyof T]: T[K] extends UniformValue ? never : K}[keyof T];\ntype UniformKeys<T> = {[K in keyof T]: T[K] extends UniformValue ? K : never}[keyof T];\nexport type PickBindings<T> = {[K in BindingKeys<Required<T>>]: T[K]};\nexport type PickUniforms<T> = {[K in UniformKeys<Required<T>>]: T[K]};\n\n/**\n * A shader module definition object\n *\n * @note Needs to be initialized with `initializeShaderModules`\n * @note `UniformsT` & `BindingsT` are deduced from `PropsT` by default. If\n * a custom type for `UniformsT` is used, `BindingsT` should be also be provided.\n */\nexport type ShaderModule<\n  PropsT extends Record<string, any> = Record<string, any>,\n  UniformsT extends Record<string, UniformValue> = PickUniforms<PropsT>,\n  BindingsT extends Record<string, Binding> = PickBindings<PropsT>\n> = {\n  /** Used for type inference not for values */\n  props?: PropsT;\n  /** Used for type inference, not currently used for values */\n  uniforms?: UniformsT;\n  /** Used for type inference, not currently used for values */\n  bindings?: BindingsT;\n\n  name: string;\n\n  /** WGSL code */\n  source?: string;\n  /** GLSL fragment shader code */\n  fs?: string;\n  /** GLSL vertex shader code */\n  vs?: string;\n\n  /** Uniform shader types @note: Both order and types MUST match uniform block declarations in shader */\n  uniformTypes?: Required<UniformTypes<UniformsT>>; // Record<keyof UniformsT, UniformFormat>;\n  /** Uniform JS prop types  */\n  propTypes?: Record<keyof UniformsT, UniformInfo>;\n  /** Default uniform values */\n  defaultUniforms?: Required<UniformsT>; // Record<keyof UniformsT, UniformValue>;\n\n  /** Function that maps props to uniforms & bindings */\n  getUniforms?: (\n    props: Partial<PropsT>,\n    prevUniforms?: UniformsT\n  ) => Partial<UniformsT & BindingsT>;\n\n  defines?: Record<string, string | number>;\n  /** Injections */\n  inject?: Record<string, string | {injection: string; order: number}>;\n  dependencies?: ShaderModule<any, any>[];\n  /** Information on deprecated properties */\n  deprecations?: ShaderModuleDeprecation[];\n\n  /** The instance field contains information that is generated at run-time */\n  instance?: {\n    propValidators?: Record<string, PropValidator>;\n    parsedDeprecations: ShaderModuleDeprecation[];\n\n    normalizedInjections: {\n      vertex: Record<string, ShaderInjection>;\n      fragment: Record<string, ShaderInjection>;\n    };\n  };\n};\n\n/** Use to generate deprecations when shader module is used */\nexport type ShaderModuleDeprecation = {\n  type: string;\n  regex?: RegExp;\n  new: string;\n  old: string;\n  deprecated?: boolean;\n};\n\n// SHNDER MODULE API\n\nexport function initializeShaderModules(modules: ShaderModule[]): void {\n  modules.map((module: ShaderModule) => initializeShaderModule(module));\n}\n\nexport function initializeShaderModule(module: ShaderModule): void {\n  if (module.instance) {\n    return;\n  }\n\n  initializeShaderModules(module.dependencies || []);\n\n  const {\n    propTypes = {},\n    deprecations = [],\n    // defines = {},\n    inject = {}\n  } = module;\n\n  const instance: Required<ShaderModule>['instance'] = {\n    normalizedInjections: normalizeInjections(inject),\n    parsedDeprecations: parseDeprecationDefinitions(deprecations)\n  };\n\n  if (propTypes) {\n    instance.propValidators = makePropValidators(propTypes);\n  }\n\n  module.instance = instance;\n\n  // TODO(ib) - we need to apply the original prop types to the default uniforms\n  let defaultProps: ShaderModule['props'] = {};\n  if (propTypes) {\n    defaultProps = Object.entries(propTypes).reduce(\n      (obj: ShaderModule['props'], [key, propType]) => {\n        // @ts-expect-error\n        const value = propType?.value;\n        if (value) {\n          // @ts-expect-error\n          obj[key] = value;\n        }\n        return obj;\n      },\n      {} as ShaderModule['props']\n    );\n  }\n\n  module.defaultUniforms = {...module.defaultUniforms, ...defaultProps} as any;\n}\n\n/** Convert module props to uniforms */\nexport function getShaderModuleUniforms<\n  ShaderModuleT extends ShaderModule<Record<string, unknown>, Record<string, UniformValue>>\n>(\n  module: ShaderModuleT,\n  props?: ShaderModuleT['props'],\n  oldUniforms?: ShaderModuleT['uniforms']\n): Record<string, Binding | UniformValue> {\n  initializeShaderModule(module);\n\n  const uniforms = oldUniforms || {...module.defaultUniforms};\n  // If module has a getUniforms function, use it\n  if (props && module.getUniforms) {\n    return module.getUniforms(props, uniforms);\n  }\n\n  // Build uniforms from the uniforms array\n  // @ts-expect-error\n  return getValidatedProperties(props, module.instance?.propValidators, module.name);\n}\n\n/* TODO this looks like it was unused code\n  _defaultGetUniforms(opts: Record<string, any> = {}): Record<string, any> {\n    const uniforms: Record<string, any> = {};\n    const propTypes = this.uniforms;\n\n    for (const key in propTypes) {\n      const propDef = propTypes[key];\n      if (key in opts && !propDef.private) {\n        if (propDef.validate) {\n          assert(propDef.validate(opts[key], propDef), `${this.name}: invalid ${key}`);\n        }\n        uniforms[key] = opts[key];\n      } else {\n        uniforms[key] = propDef.value;\n      }\n    }\n\n    return uniforms;\n  }\n}\n*/\n// Warn about deprecated uniforms or functions\nexport function checkShaderModuleDeprecations(\n  shaderModule: ShaderModule,\n  shaderSource: string,\n  log: any\n): void {\n  shaderModule.deprecations?.forEach(def => {\n    if (def.regex?.test(shaderSource)) {\n      if (def.deprecated) {\n        log.deprecated(def.old, def.new)();\n      } else {\n        log.removed(def.old, def.new)();\n      }\n    }\n  });\n}\n\n// HELPERS\n\nfunction parseDeprecationDefinitions(deprecations: ShaderModuleDeprecation[]) {\n  deprecations.forEach(def => {\n    switch (def.type) {\n      case 'function':\n        def.regex = new RegExp(`\\\\b${def.old}\\\\(`);\n        break;\n      default:\n        def.regex = new RegExp(`${def.type} ${def.old};`);\n    }\n  });\n\n  return deprecations;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}