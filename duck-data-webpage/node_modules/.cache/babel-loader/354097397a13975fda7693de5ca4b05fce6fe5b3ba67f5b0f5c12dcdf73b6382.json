{"ast":null,"code":"import { GLTFScenegraph } from \"../api/gltf-scenegraph.js\";\nimport { meshoptDecodeGltfBuffer } from \"../../meshopt/meshopt-decoder.js\";\n// @ts-ignore\n// eslint-disable-next-line\nconst DEFAULT_MESHOPT_OPTIONS = {\n  byteOffset: 0,\n  filter: 'NONE'\n};\n/** Extension name */\nconst EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\nexport const name = EXT_MESHOPT_COMPRESSION;\nexport async function decode(gltfData, options) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  if (!options?.gltf?.decompressMeshes || !options.gltf?.loadBuffers) {\n    return;\n  }\n  const promises = [];\n  for (const bufferViewIndex of gltfData.json.bufferViews || []) {\n    promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));\n  }\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n  // We have now decompressed all primitives, so remove the top-level extension\n  scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);\n}\n/** Decode one meshopt buffer view */\nasync function decodeMeshoptBufferView(scenegraph, bufferView) {\n  const meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);\n  if (meshoptExtension) {\n    const {\n      byteOffset = 0,\n      byteLength = 0,\n      byteStride,\n      count,\n      mode,\n      filter = 'NONE',\n      buffer: bufferIndex\n    } = meshoptExtension;\n    const buffer = scenegraph.gltf.buffers[bufferIndex];\n    const source = new Uint8Array(buffer.arrayBuffer, buffer.byteOffset + byteOffset, byteLength);\n    const result = new Uint8Array(scenegraph.gltf.buffers[bufferView.buffer].arrayBuffer, bufferView.byteOffset, bufferView.byteLength);\n    await meshoptDecodeGltfBuffer(result, count, byteStride, source, mode, filter);\n    scenegraph.removeObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);\n  }\n}","map":{"version":3,"names":["GLTFScenegraph","meshoptDecodeGltfBuffer","DEFAULT_MESHOPT_OPTIONS","byteOffset","filter","EXT_MESHOPT_COMPRESSION","name","decode","gltfData","options","scenegraph","gltf","decompressMeshes","loadBuffers","promises","bufferViewIndex","json","bufferViews","push","decodeMeshoptBufferView","Promise","all","removeExtension","bufferView","meshoptExtension","getObjectExtension","byteLength","byteStride","count","mode","buffer","bufferIndex","buffers","source","Uint8Array","arrayBuffer","result","removeObjectExtension"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_meshopt_compression.js"],"sourcesContent":["import { GLTFScenegraph } from \"../api/gltf-scenegraph.js\";\nimport { meshoptDecodeGltfBuffer } from \"../../meshopt/meshopt-decoder.js\";\n// @ts-ignore\n// eslint-disable-next-line\nconst DEFAULT_MESHOPT_OPTIONS = {\n    byteOffset: 0,\n    filter: 'NONE'\n};\n/** Extension name */\nconst EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\nexport const name = EXT_MESHOPT_COMPRESSION;\nexport async function decode(gltfData, options) {\n    const scenegraph = new GLTFScenegraph(gltfData);\n    if (!options?.gltf?.decompressMeshes || !options.gltf?.loadBuffers) {\n        return;\n    }\n    const promises = [];\n    for (const bufferViewIndex of gltfData.json.bufferViews || []) {\n        promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));\n    }\n    // Decompress meshes in parallel\n    await Promise.all(promises);\n    // We have now decompressed all primitives, so remove the top-level extension\n    scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);\n}\n/** Decode one meshopt buffer view */\nasync function decodeMeshoptBufferView(scenegraph, bufferView) {\n    const meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);\n    if (meshoptExtension) {\n        const { byteOffset = 0, byteLength = 0, byteStride, count, mode, filter = 'NONE', buffer: bufferIndex } = meshoptExtension;\n        const buffer = scenegraph.gltf.buffers[bufferIndex];\n        const source = new Uint8Array(buffer.arrayBuffer, buffer.byteOffset + byteOffset, byteLength);\n        const result = new Uint8Array(scenegraph.gltf.buffers[bufferView.buffer].arrayBuffer, bufferView.byteOffset, bufferView.byteLength);\n        await meshoptDecodeGltfBuffer(result, count, byteStride, source, mode, filter);\n        scenegraph.removeObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);\n    }\n}\n"],"mappings":"AAAA,SAASA,cAAc,QAAQ,2BAA2B;AAC1D,SAASC,uBAAuB,QAAQ,kCAAkC;AAC1E;AACA;AACA,MAAMC,uBAAuB,GAAG;EAC5BC,UAAU,EAAE,CAAC;EACbC,MAAM,EAAE;AACZ,CAAC;AACD;AACA,MAAMC,uBAAuB,GAAG,yBAAyB;AACzD,OAAO,MAAMC,IAAI,GAAGD,uBAAuB;AAC3C,OAAO,eAAeE,MAAMA,CAACC,QAAQ,EAAEC,OAAO,EAAE;EAC5C,MAAMC,UAAU,GAAG,IAAIV,cAAc,CAACQ,QAAQ,CAAC;EAC/C,IAAI,CAACC,OAAO,EAAEE,IAAI,EAAEC,gBAAgB,IAAI,CAACH,OAAO,CAACE,IAAI,EAAEE,WAAW,EAAE;IAChE;EACJ;EACA,MAAMC,QAAQ,GAAG,EAAE;EACnB,KAAK,MAAMC,eAAe,IAAIP,QAAQ,CAACQ,IAAI,CAACC,WAAW,IAAI,EAAE,EAAE;IAC3DH,QAAQ,CAACI,IAAI,CAACC,uBAAuB,CAACT,UAAU,EAAEK,eAAe,CAAC,CAAC;EACvE;EACA;EACA,MAAMK,OAAO,CAACC,GAAG,CAACP,QAAQ,CAAC;EAC3B;EACAJ,UAAU,CAACY,eAAe,CAACjB,uBAAuB,CAAC;AACvD;AACA;AACA,eAAec,uBAAuBA,CAACT,UAAU,EAAEa,UAAU,EAAE;EAC3D,MAAMC,gBAAgB,GAAGd,UAAU,CAACe,kBAAkB,CAACF,UAAU,EAAElB,uBAAuB,CAAC;EAC3F,IAAImB,gBAAgB,EAAE;IAClB,MAAM;MAAErB,UAAU,GAAG,CAAC;MAAEuB,UAAU,GAAG,CAAC;MAAEC,UAAU;MAAEC,KAAK;MAAEC,IAAI;MAAEzB,MAAM,GAAG,MAAM;MAAE0B,MAAM,EAAEC;IAAY,CAAC,GAAGP,gBAAgB;IAC1H,MAAMM,MAAM,GAAGpB,UAAU,CAACC,IAAI,CAACqB,OAAO,CAACD,WAAW,CAAC;IACnD,MAAME,MAAM,GAAG,IAAIC,UAAU,CAACJ,MAAM,CAACK,WAAW,EAAEL,MAAM,CAAC3B,UAAU,GAAGA,UAAU,EAAEuB,UAAU,CAAC;IAC7F,MAAMU,MAAM,GAAG,IAAIF,UAAU,CAACxB,UAAU,CAACC,IAAI,CAACqB,OAAO,CAACT,UAAU,CAACO,MAAM,CAAC,CAACK,WAAW,EAAEZ,UAAU,CAACpB,UAAU,EAAEoB,UAAU,CAACG,UAAU,CAAC;IACnI,MAAMzB,uBAAuB,CAACmC,MAAM,EAAER,KAAK,EAAED,UAAU,EAAEM,MAAM,EAAEJ,IAAI,EAAEzB,MAAM,CAAC;IAC9EM,UAAU,CAAC2B,qBAAqB,CAACd,UAAU,EAAElB,uBAAuB,CAAC;EACzE;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}