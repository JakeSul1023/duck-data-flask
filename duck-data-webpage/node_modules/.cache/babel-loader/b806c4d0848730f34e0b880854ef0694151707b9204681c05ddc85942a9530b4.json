{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { initializeShaderModules } from \"./shader-module/shader-module.js\";\nimport { assembleWGSLShader, assembleGLSLShaderPair } from \"./shader-assembly/assemble-shaders.js\";\nimport { preprocess } from \"./preprocessor/preprocessor.js\";\n/**\n * A stateful version of `assembleShaders` that can be used to assemble shaders.\n * Supports setting of default modules and hooks.\n */\nexport class ShaderAssembler {\n  /** Default ShaderAssembler instance */\n  static defaultShaderAssembler;\n  /** Hook functions */\n  _hookFunctions = [];\n  /** Shader modules */\n  _defaultModules = [];\n  /**\n   * A default shader assembler instance - the natural place to register default modules and hooks\n   * @returns\n   */\n  static getDefaultShaderAssembler() {\n    ShaderAssembler.defaultShaderAssembler = ShaderAssembler.defaultShaderAssembler || new ShaderAssembler();\n    return ShaderAssembler.defaultShaderAssembler;\n  }\n  /**\n   * Add a default module that does not have to be provided with every call to assembleShaders()\n   */\n  addDefaultModule(module) {\n    if (!this._defaultModules.find(m => m.name === (typeof module === 'string' ? module : module.name))) {\n      this._defaultModules.push(module);\n    }\n  }\n  /**\n   * Remove a default module\n   */\n  removeDefaultModule(module) {\n    const moduleName = typeof module === 'string' ? module : module.name;\n    this._defaultModules = this._defaultModules.filter(m => m.name !== moduleName);\n  }\n  /**\n   * Register a shader hook\n   * @param hook\n   * @param opts\n   */\n  addShaderHook(hook, opts) {\n    if (opts) {\n      hook = Object.assign(opts, {\n        hook\n      });\n    }\n    this._hookFunctions.push(hook);\n  }\n  /**\n   * Assemble a WGSL unified shader\n   * @param platformInfo\n   * @param props\n   * @returns\n   */\n  assembleWGSLShader(props) {\n    const modules = this._getModuleList(props.modules); // Combine with default modules\n    const hookFunctions = this._hookFunctions; // TODO - combine with default hook functions\n    const {\n      source,\n      getUniforms\n    } = assembleWGSLShader({\n      ...props,\n      // @ts-expect-error\n      source: props.source,\n      modules,\n      hookFunctions\n    });\n    // WGSL does not have built-in preprocessing support (just compile time constants)\n    const preprocessedSource = props.platformInfo.shaderLanguage === 'wgsl' ? preprocess(source) : source;\n    return {\n      source: preprocessedSource,\n      getUniforms,\n      modules\n    };\n  }\n  /**\n   * Assemble a pair of shaders into a single shader program\n   * @param platformInfo\n   * @param props\n   * @returns\n   */\n  assembleGLSLShaderPair(props) {\n    const modules = this._getModuleList(props.modules); // Combine with default modules\n    const hookFunctions = this._hookFunctions; // TODO - combine with default hook functions\n    const assembled = assembleGLSLShaderPair({\n      ...props,\n      // @ts-expect-error\n      vs: props.vs,\n      // @ts-expect-error\n      fs: props.fs,\n      modules,\n      hookFunctions\n    });\n    return {\n      ...assembled,\n      modules\n    };\n  }\n  /**\n   * Dedupe and combine with default modules\n   */\n  _getModuleList(appModules = []) {\n    const modules = new Array(this._defaultModules.length + appModules.length);\n    const seen = {};\n    let count = 0;\n    for (let i = 0, len = this._defaultModules.length; i < len; ++i) {\n      const module = this._defaultModules[i];\n      const name = module.name;\n      modules[count++] = module;\n      seen[name] = true;\n    }\n    for (let i = 0, len = appModules.length; i < len; ++i) {\n      const module = appModules[i];\n      const name = module.name;\n      if (!seen[name]) {\n        modules[count++] = module;\n        seen[name] = true;\n      }\n    }\n    modules.length = count;\n    initializeShaderModules(modules);\n    return modules;\n  }\n}","map":{"version":3,"names":["initializeShaderModules","assembleWGSLShader","assembleGLSLShaderPair","preprocess","ShaderAssembler","defaultShaderAssembler","_hookFunctions","_defaultModules","getDefaultShaderAssembler","addDefaultModule","module","find","m","name","push","removeDefaultModule","moduleName","filter","addShaderHook","hook","opts","Object","assign","props","modules","_getModuleList","hookFunctions","source","getUniforms","preprocessedSource","platformInfo","shaderLanguage","assembled","vs","fs","appModules","Array","length","seen","count","i","len"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\shadertools\\src\\lib\\shader-assembler.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderModule} from './shader-module/shader-module';\nimport {initializeShaderModules} from './shader-module/shader-module';\nimport {\n  AssembleShaderProps,\n  GetUniformsFunc,\n  assembleWGSLShader,\n  assembleGLSLShaderPair\n} from './shader-assembly/assemble-shaders';\nimport {preprocess} from './preprocessor/preprocessor';\n\n/**\n * A stateful version of `assembleShaders` that can be used to assemble shaders.\n * Supports setting of default modules and hooks.\n */\nexport class ShaderAssembler {\n  /** Default ShaderAssembler instance */\n  static defaultShaderAssembler: ShaderAssembler;\n  /** Hook functions */\n  private readonly _hookFunctions: any[] = [];\n  /** Shader modules */\n  private _defaultModules: ShaderModule[] = [];\n\n  /**\n   * A default shader assembler instance - the natural place to register default modules and hooks\n   * @returns\n   */\n  static getDefaultShaderAssembler(): ShaderAssembler {\n    ShaderAssembler.defaultShaderAssembler =\n      ShaderAssembler.defaultShaderAssembler || new ShaderAssembler();\n    return ShaderAssembler.defaultShaderAssembler;\n  }\n\n  /**\n   * Add a default module that does not have to be provided with every call to assembleShaders()\n   */\n  addDefaultModule(module: ShaderModule): void {\n    if (\n      !this._defaultModules.find(\n        m => m.name === (typeof module === 'string' ? module : module.name)\n      )\n    ) {\n      this._defaultModules.push(module);\n    }\n  }\n\n  /**\n   * Remove a default module\n   */\n  removeDefaultModule(module: ShaderModule): void {\n    const moduleName = typeof module === 'string' ? module : module.name;\n    this._defaultModules = this._defaultModules.filter(m => m.name !== moduleName);\n  }\n\n  /**\n   * Register a shader hook\n   * @param hook\n   * @param opts\n   */\n  addShaderHook(hook: string, opts?: any): void {\n    if (opts) {\n      hook = Object.assign(opts, {hook});\n    }\n    this._hookFunctions.push(hook);\n  }\n\n  /**\n   * Assemble a WGSL unified shader\n   * @param platformInfo\n   * @param props\n   * @returns\n   */\n  assembleWGSLShader(props: AssembleShaderProps): {\n    source: string;\n    getUniforms: GetUniformsFunc;\n    modules: ShaderModule[];\n  } {\n    const modules = this._getModuleList(props.modules); // Combine with default modules\n    const hookFunctions = this._hookFunctions; // TODO - combine with default hook functions\n    const {source, getUniforms} = assembleWGSLShader({\n      ...props,\n      // @ts-expect-error\n      source: props.source,\n      modules,\n      hookFunctions\n    });\n    // WGSL does not have built-in preprocessing support (just compile time constants)\n    const preprocessedSource =\n      props.platformInfo.shaderLanguage === 'wgsl' ? preprocess(source) : source;\n    return {source: preprocessedSource, getUniforms, modules};\n  }\n\n  /**\n   * Assemble a pair of shaders into a single shader program\n   * @param platformInfo\n   * @param props\n   * @returns\n   */\n  assembleGLSLShaderPair(props: AssembleShaderProps): {\n    vs: string;\n    fs: string;\n    getUniforms: GetUniformsFunc;\n    modules: ShaderModule[];\n  } {\n    const modules = this._getModuleList(props.modules); // Combine with default modules\n    const hookFunctions = this._hookFunctions; // TODO - combine with default hook functions\n    const assembled = assembleGLSLShaderPair({\n      ...props,\n      // @ts-expect-error\n      vs: props.vs,\n      // @ts-expect-error\n      fs: props.fs,\n      modules,\n      hookFunctions\n    });\n\n    return {...assembled, modules};\n  }\n\n  /**\n   * Dedupe and combine with default modules\n   */\n  _getModuleList(appModules: ShaderModule[] = []): ShaderModule[] {\n    const modules = new Array<ShaderModule>(this._defaultModules.length + appModules.length);\n    const seen: Record<string, boolean> = {};\n    let count = 0;\n\n    for (let i = 0, len = this._defaultModules.length; i < len; ++i) {\n      const module = this._defaultModules[i];\n      const name = module.name;\n      modules[count++] = module;\n      seen[name] = true;\n    }\n\n    for (let i = 0, len = appModules.length; i < len; ++i) {\n      const module = appModules[i];\n      const name = module.name;\n      if (!seen[name]) {\n        modules[count++] = module;\n        seen[name] = true;\n      }\n    }\n\n    modules.length = count;\n\n    initializeShaderModules(modules);\n    return modules;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}