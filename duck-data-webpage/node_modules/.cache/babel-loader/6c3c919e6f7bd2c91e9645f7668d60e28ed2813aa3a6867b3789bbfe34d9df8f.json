{"ast":null,"code":"import { FileHandleFile, concatenateArrayBuffers, path, NodeFilesystem, NodeFile } from '@loaders.gl/loader-utils';\nimport { generateEoCD, parseEoCDRecord, updateEoCD } from \"./end-of-central-directory.js\";\nimport { CRC32Hash } from '@loaders.gl/crypto';\nimport { generateLocalHeader } from \"./local-file-header.js\";\nimport { generateCDHeader } from \"./cd-file-header.js\";\nimport { fetchFile } from '@loaders.gl/core';\n/**\n * cut off CD and EoCD records from zip file\n * @param provider zip file\n * @returns tuple with three values: CD, EoCD record, EoCD information\n */\nasync function cutTheTailOff(provider) {\n  // define where the body ends\n  const oldEoCDinfo = await parseEoCDRecord(provider);\n  const oldCDStartOffset = oldEoCDinfo.cdStartOffset;\n  // define cd length\n  const oldCDLength = Number(oldEoCDinfo.offsets.zip64EoCDOffset ? oldEoCDinfo.offsets.zip64EoCDOffset - oldCDStartOffset : oldEoCDinfo.offsets.zipEoCDOffset - oldCDStartOffset);\n  // cut off everything except of archieve body\n  const zipEnding = await provider.slice(oldCDStartOffset, provider.length);\n  await provider.truncate(Number(oldCDStartOffset));\n  // divide cd body and eocd record\n  const oldCDBody = zipEnding.slice(0, oldCDLength);\n  const eocdBody = zipEnding.slice(oldCDLength, zipEnding.byteLength);\n  return [oldCDBody, eocdBody, oldEoCDinfo];\n}\n/**\n * generates CD and local headers for the file\n * @param fileName name of the file\n * @param fileToAdd buffer with the file\n * @param localFileHeaderOffset offset of the file local header\n * @returns tuple with two values: local header and file body, cd header\n */\nasync function generateFileHeaders(fileName, fileToAdd, localFileHeaderOffset) {\n  // generating CRC32 of the content\n  const newFileCRC322 = parseInt(await new CRC32Hash().hash(fileToAdd, 'hex'), 16);\n  // generate local header for the file\n  const newFileLocalHeader = generateLocalHeader({\n    crc32: newFileCRC322,\n    fileName,\n    length: fileToAdd.byteLength\n  });\n  // generate hash file cd header\n  const newFileCDHeader = generateCDHeader({\n    crc32: newFileCRC322,\n    fileName,\n    offset: localFileHeaderOffset,\n    length: fileToAdd.byteLength\n  });\n  return [new Uint8Array(concatenateArrayBuffers(newFileLocalHeader, fileToAdd)), new Uint8Array(newFileCDHeader)];\n}\n/**\n * adds one file in the end of the archieve\n * @param zipUrl path to the file\n * @param fileToAdd new file body\n * @param fileName new file name\n */\nexport async function addOneFile(zipUrl, fileToAdd, fileName) {\n  // init file handler\n  const provider = new FileHandleFile(zipUrl, true);\n  const [oldCDBody, eocdBody, oldEoCDinfo] = await cutTheTailOff(provider);\n  // remember the new file local header start offset\n  const newFileOffset = provider.length;\n  const [localPart, cdHeaderPart] = await generateFileHeaders(fileName, fileToAdd, newFileOffset);\n  // write down the file local header\n  await provider.append(localPart);\n  // add the file CD header to the CD\n  const newCDBody = concatenateArrayBuffers(oldCDBody, cdHeaderPart);\n  // remember the CD start offset\n  const newCDStartOffset = provider.length;\n  // write down new CD\n  await provider.append(new Uint8Array(newCDBody));\n  // remember where eocd starts\n  const eocdOffset = provider.length;\n  await provider.append(updateEoCD(eocdBody, oldEoCDinfo.offsets, newCDStartOffset, eocdOffset, oldEoCDinfo.cdRecordsNumber + 1n));\n}\n/**\n * creates zip archive with no compression\n * @note This is a node specific function that works on files\n * @param inputPath path where files for the achive are stored\n * @param outputPath path where zip archive will be placed\n */\nexport async function createZip(inputPath, outputPath, createAdditionalData) {\n  const fileIterator = getFileIterator(inputPath);\n  const resFile = new NodeFile(outputPath, 'w');\n  const fileList = [];\n  const cdArray = [];\n  for await (const file of fileIterator) {\n    await addFile(file, resFile, cdArray, fileList);\n  }\n  if (createAdditionalData) {\n    const additionaldata = await createAdditionalData(fileList);\n    await addFile(additionaldata, resFile, cdArray);\n  }\n  const cdOffset = (await resFile.stat()).bigsize;\n  const cd = concatenateArrayBuffers(...cdArray);\n  await resFile.append(new Uint8Array(cd));\n  const eoCDStart = (await resFile.stat()).bigsize;\n  await resFile.append(new Uint8Array(generateEoCD({\n    recordsNumber: cdArray.length,\n    cdSize: cd.byteLength,\n    cdOffset,\n    eoCDStart\n  })));\n}\n/**\n * Adds file to zip parts\n * @param file file to add\n * @param resFile zip file body\n * @param cdArray zip file central directory\n * @param fileList list of file offsets\n */\nasync function addFile(file, resFile, cdArray, fileList) {\n  const size = (await resFile.stat()).bigsize;\n  fileList?.push({\n    fileName: file.path,\n    localHeaderOffset: size\n  });\n  const [localPart, cdHeaderPart] = await generateFileHeaders(file.path, file.file, size);\n  await resFile.append(localPart);\n  cdArray.push(cdHeaderPart);\n}\n/**\n * creates iterator providing buffer with file content and path to every file in the input folder\n * @param inputPath path to the input folder\n * @returns iterator\n */\nexport function getFileIterator(inputPath) {\n  async function* iterable() {\n    const fileList = await getAllFiles(inputPath);\n    for (const filePath of fileList) {\n      const file = await (await fetchFile(path.join(inputPath, filePath))).arrayBuffer();\n      yield {\n        path: filePath,\n        file\n      };\n    }\n  }\n  return iterable();\n}\n/**\n * creates a list of relative paths to all files in the provided folder\n * @param basePath path of the root folder\n * @param subfolder relative path from the root folder.\n * @returns list of paths\n */\nexport async function getAllFiles(basePath, subfolder = '', fsPassed) {\n  const fs = fsPassed ? fsPassed : new NodeFilesystem({});\n  const files = await fs.readdir(pathJoin(basePath, subfolder));\n  const arrayOfFiles = [];\n  for (const file of files) {\n    const fullPath = pathJoin(basePath, subfolder, file);\n    if ((await fs.stat(fullPath)).isDirectory) {\n      const files = await getAllFiles(basePath, pathJoin(subfolder, file));\n      arrayOfFiles.push(...files);\n    } else {\n      arrayOfFiles.push(pathJoin(subfolder, file));\n    }\n  }\n  return arrayOfFiles;\n}\n/**\n * removes empty parts from path array and joins it\n * @param paths paths to join\n * @returns joined path\n */\nfunction pathJoin(...paths) {\n  const resPaths = paths.filter(val => val.length);\n  return path.join(...resPaths);\n}","map":{"version":3,"names":["FileHandleFile","concatenateArrayBuffers","path","NodeFilesystem","NodeFile","generateEoCD","parseEoCDRecord","updateEoCD","CRC32Hash","generateLocalHeader","generateCDHeader","fetchFile","cutTheTailOff","provider","oldEoCDinfo","oldCDStartOffset","cdStartOffset","oldCDLength","Number","offsets","zip64EoCDOffset","zipEoCDOffset","zipEnding","slice","length","truncate","oldCDBody","eocdBody","byteLength","generateFileHeaders","fileName","fileToAdd","localFileHeaderOffset","newFileCRC322","parseInt","hash","newFileLocalHeader","crc32","newFileCDHeader","offset","Uint8Array","addOneFile","zipUrl","newFileOffset","localPart","cdHeaderPart","append","newCDBody","newCDStartOffset","eocdOffset","cdRecordsNumber","createZip","inputPath","outputPath","createAdditionalData","fileIterator","getFileIterator","resFile","fileList","cdArray","file","addFile","additionaldata","cdOffset","stat","bigsize","cd","eoCDStart","recordsNumber","cdSize","size","push","localHeaderOffset","iterable","getAllFiles","filePath","join","arrayBuffer","basePath","subfolder","fsPassed","fs","files","readdir","pathJoin","arrayOfFiles","fullPath","isDirectory","paths","resPaths","filter","val"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/zip/dist/parse-zip/zip-composition.js"],"sourcesContent":["import { FileHandleFile, concatenateArrayBuffers, path, NodeFilesystem, NodeFile } from '@loaders.gl/loader-utils';\nimport { generateEoCD, parseEoCDRecord, updateEoCD } from \"./end-of-central-directory.js\";\nimport { CRC32Hash } from '@loaders.gl/crypto';\nimport { generateLocalHeader } from \"./local-file-header.js\";\nimport { generateCDHeader } from \"./cd-file-header.js\";\nimport { fetchFile } from '@loaders.gl/core';\n/**\n * cut off CD and EoCD records from zip file\n * @param provider zip file\n * @returns tuple with three values: CD, EoCD record, EoCD information\n */\nasync function cutTheTailOff(provider) {\n    // define where the body ends\n    const oldEoCDinfo = await parseEoCDRecord(provider);\n    const oldCDStartOffset = oldEoCDinfo.cdStartOffset;\n    // define cd length\n    const oldCDLength = Number(oldEoCDinfo.offsets.zip64EoCDOffset\n        ? oldEoCDinfo.offsets.zip64EoCDOffset - oldCDStartOffset\n        : oldEoCDinfo.offsets.zipEoCDOffset - oldCDStartOffset);\n    // cut off everything except of archieve body\n    const zipEnding = await provider.slice(oldCDStartOffset, provider.length);\n    await provider.truncate(Number(oldCDStartOffset));\n    // divide cd body and eocd record\n    const oldCDBody = zipEnding.slice(0, oldCDLength);\n    const eocdBody = zipEnding.slice(oldCDLength, zipEnding.byteLength);\n    return [oldCDBody, eocdBody, oldEoCDinfo];\n}\n/**\n * generates CD and local headers for the file\n * @param fileName name of the file\n * @param fileToAdd buffer with the file\n * @param localFileHeaderOffset offset of the file local header\n * @returns tuple with two values: local header and file body, cd header\n */\nasync function generateFileHeaders(fileName, fileToAdd, localFileHeaderOffset) {\n    // generating CRC32 of the content\n    const newFileCRC322 = parseInt(await new CRC32Hash().hash(fileToAdd, 'hex'), 16);\n    // generate local header for the file\n    const newFileLocalHeader = generateLocalHeader({\n        crc32: newFileCRC322,\n        fileName,\n        length: fileToAdd.byteLength\n    });\n    // generate hash file cd header\n    const newFileCDHeader = generateCDHeader({\n        crc32: newFileCRC322,\n        fileName,\n        offset: localFileHeaderOffset,\n        length: fileToAdd.byteLength\n    });\n    return [\n        new Uint8Array(concatenateArrayBuffers(newFileLocalHeader, fileToAdd)),\n        new Uint8Array(newFileCDHeader)\n    ];\n}\n/**\n * adds one file in the end of the archieve\n * @param zipUrl path to the file\n * @param fileToAdd new file body\n * @param fileName new file name\n */\nexport async function addOneFile(zipUrl, fileToAdd, fileName) {\n    // init file handler\n    const provider = new FileHandleFile(zipUrl, true);\n    const [oldCDBody, eocdBody, oldEoCDinfo] = await cutTheTailOff(provider);\n    // remember the new file local header start offset\n    const newFileOffset = provider.length;\n    const [localPart, cdHeaderPart] = await generateFileHeaders(fileName, fileToAdd, newFileOffset);\n    // write down the file local header\n    await provider.append(localPart);\n    // add the file CD header to the CD\n    const newCDBody = concatenateArrayBuffers(oldCDBody, cdHeaderPart);\n    // remember the CD start offset\n    const newCDStartOffset = provider.length;\n    // write down new CD\n    await provider.append(new Uint8Array(newCDBody));\n    // remember where eocd starts\n    const eocdOffset = provider.length;\n    await provider.append(updateEoCD(eocdBody, oldEoCDinfo.offsets, newCDStartOffset, eocdOffset, oldEoCDinfo.cdRecordsNumber + 1n));\n}\n/**\n * creates zip archive with no compression\n * @note This is a node specific function that works on files\n * @param inputPath path where files for the achive are stored\n * @param outputPath path where zip archive will be placed\n */\nexport async function createZip(inputPath, outputPath, createAdditionalData) {\n    const fileIterator = getFileIterator(inputPath);\n    const resFile = new NodeFile(outputPath, 'w');\n    const fileList = [];\n    const cdArray = [];\n    for await (const file of fileIterator) {\n        await addFile(file, resFile, cdArray, fileList);\n    }\n    if (createAdditionalData) {\n        const additionaldata = await createAdditionalData(fileList);\n        await addFile(additionaldata, resFile, cdArray);\n    }\n    const cdOffset = (await resFile.stat()).bigsize;\n    const cd = concatenateArrayBuffers(...cdArray);\n    await resFile.append(new Uint8Array(cd));\n    const eoCDStart = (await resFile.stat()).bigsize;\n    await resFile.append(new Uint8Array(generateEoCD({ recordsNumber: cdArray.length, cdSize: cd.byteLength, cdOffset, eoCDStart })));\n}\n/**\n * Adds file to zip parts\n * @param file file to add\n * @param resFile zip file body\n * @param cdArray zip file central directory\n * @param fileList list of file offsets\n */\nasync function addFile(file, resFile, cdArray, fileList) {\n    const size = (await resFile.stat()).bigsize;\n    fileList?.push({ fileName: file.path, localHeaderOffset: size });\n    const [localPart, cdHeaderPart] = await generateFileHeaders(file.path, file.file, size);\n    await resFile.append(localPart);\n    cdArray.push(cdHeaderPart);\n}\n/**\n * creates iterator providing buffer with file content and path to every file in the input folder\n * @param inputPath path to the input folder\n * @returns iterator\n */\nexport function getFileIterator(inputPath) {\n    async function* iterable() {\n        const fileList = await getAllFiles(inputPath);\n        for (const filePath of fileList) {\n            const file = await (await fetchFile(path.join(inputPath, filePath))).arrayBuffer();\n            yield { path: filePath, file };\n        }\n    }\n    return iterable();\n}\n/**\n * creates a list of relative paths to all files in the provided folder\n * @param basePath path of the root folder\n * @param subfolder relative path from the root folder.\n * @returns list of paths\n */\nexport async function getAllFiles(basePath, subfolder = '', fsPassed) {\n    const fs = fsPassed ? fsPassed : new NodeFilesystem({});\n    const files = await fs.readdir(pathJoin(basePath, subfolder));\n    const arrayOfFiles = [];\n    for (const file of files) {\n        const fullPath = pathJoin(basePath, subfolder, file);\n        if ((await fs.stat(fullPath)).isDirectory) {\n            const files = await getAllFiles(basePath, pathJoin(subfolder, file));\n            arrayOfFiles.push(...files);\n        }\n        else {\n            arrayOfFiles.push(pathJoin(subfolder, file));\n        }\n    }\n    return arrayOfFiles;\n}\n/**\n * removes empty parts from path array and joins it\n * @param paths paths to join\n * @returns joined path\n */\nfunction pathJoin(...paths) {\n    const resPaths = paths.filter((val) => val.length);\n    return path.join(...resPaths);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}