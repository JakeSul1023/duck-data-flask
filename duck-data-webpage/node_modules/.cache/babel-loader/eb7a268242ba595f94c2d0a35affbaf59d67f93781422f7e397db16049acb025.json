{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n// TODO - should we automatically parse the embedded glTF or leave it to the app?\n// - I.e. some apps might work directly on a GLB, in that case no need for us to decode...\n// - And if we decode, do we still keep the GLB in case it is needed?\n// - Do we add an option to control this?\n// - Also, should we have hard dependency on gltf module or use injection or auto-discovery for gltf parser?\nimport { GLTFLoader, postProcessGLTF, _getMemoryUsageGLTF } from '@loaders.gl/gltf';\nimport { sliceArrayBuffer, parseFromContext } from '@loaders.gl/loader-utils';\nexport const GLTF_FORMAT = {\n  URI: 0,\n  EMBEDDED: 1\n};\nexport function parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options) {\n  // Set flags\n  // glTF models need to be rotated from Y to Z up\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#y-up-to-z-up\n  tile.rotateYtoZ = true;\n  // Assume glTF consumes rest of tile\n  const gltfByteLength = (tile.byteOffset || 0) + (tile.byteLength || 0) - byteOffset;\n  if (gltfByteLength === 0) {\n    throw new Error('glTF byte length must be greater than 0.');\n  }\n  // Save gltf up axis\n  tile.gltfUpAxis = options?.['3d-tiles'] && options['3d-tiles'].assetGltfUpAxis ? options['3d-tiles'].assetGltfUpAxis : 'Y';\n  // TODO - We can avoid copy if already 4-byte aligned...\n  // However the rest of the code may not be able to accept byteOffsets, so copy anyway\n  tile.gltfArrayBuffer = sliceArrayBuffer(arrayBuffer, byteOffset, gltfByteLength);\n  tile.gltfByteOffset = 0;\n  tile.gltfByteLength = gltfByteLength;\n  if (byteOffset % 4 === 0) {\n    // tile.gltfArrayBuffer = arrayBuffer;\n    // tile.gltfByteOffset = byteOffset;\n    // tile.gltfByteLength = gltfByteLength;\n  } else {\n    // Create a copy of the glb so that it is 4-byte aligned\n    // eslint-disable-next-line\n    console.warn(`${tile.type}: embedded glb is not aligned to a 4-byte boundary.`);\n  }\n  // Entire tile is consumed\n  return (tile.byteOffset || 0) + (tile.byteLength || 0);\n}\nexport async function extractGLTF(tile, gltfFormat, options, context) {\n  const tile3DOptions = options?.['3d-tiles'] || {};\n  extractGLTFBufferOrURL(tile, gltfFormat, options);\n  if (tile3DOptions.loadGLTF) {\n    if (!context) {\n      return;\n    }\n    if (tile.gltfUrl) {\n      const {\n        fetch\n      } = context;\n      const response = await fetch(tile.gltfUrl, options);\n      tile.gltfArrayBuffer = await response.arrayBuffer();\n      tile.gltfByteOffset = 0;\n    }\n    if (tile.gltfArrayBuffer) {\n      // TODO - Should handle byteOffset... However, not used now...\n      const gltfWithBuffers = await parseFromContext(tile.gltfArrayBuffer, GLTFLoader, options, context);\n      tile.gltf = postProcessGLTF(gltfWithBuffers);\n      tile.gpuMemoryUsageInBytes = _getMemoryUsageGLTF(tile.gltf);\n      delete tile.gltfArrayBuffer;\n      delete tile.gltfByteOffset;\n      delete tile.gltfByteLength;\n    }\n  }\n}\nfunction extractGLTFBufferOrURL(tile, gltfFormat, options) {\n  switch (gltfFormat) {\n    case GLTF_FORMAT.URI:\n      // We need to remove padding from the end of the model URL in case this tile was part of a composite tile.\n      // This removes all white space and null characters from the end of the string.\n      if (tile.gltfArrayBuffer) {\n        const gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);\n        const textDecoder = new TextDecoder();\n        const gltfUrl = textDecoder.decode(gltfUrlBytes);\n        tile.gltfUrl = gltfUrl.replace(/[\\s\\0]+$/, '');\n      }\n      delete tile.gltfArrayBuffer;\n      delete tile.gltfByteOffset;\n      delete tile.gltfByteLength;\n      break;\n    case GLTF_FORMAT.EMBEDDED:\n      break;\n    default:\n      throw new Error('b3dm: Illegal glTF format field');\n  }\n}","map":{"version":3,"names":["GLTFLoader","postProcessGLTF","_getMemoryUsageGLTF","sliceArrayBuffer","parseFromContext","GLTF_FORMAT","URI","EMBEDDED","parse3DTileGLTFViewSync","tile","arrayBuffer","byteOffset","options","rotateYtoZ","gltfByteLength","byteLength","Error","gltfUpAxis","assetGltfUpAxis","gltfArrayBuffer","gltfByteOffset","console","warn","type","extractGLTF","gltfFormat","context","tile3DOptions","extractGLTFBufferOrURL","loadGLTF","gltfUrl","fetch","response","gltfWithBuffers","gltf","gpuMemoryUsageInBytes","gltfUrlBytes","Uint8Array","textDecoder","TextDecoder","decode","replace"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-tile-gltf-view.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n// TODO - should we automatically parse the embedded glTF or leave it to the app?\n// - I.e. some apps might work directly on a GLB, in that case no need for us to decode...\n// - And if we decode, do we still keep the GLB in case it is needed?\n// - Do we add an option to control this?\n// - Also, should we have hard dependency on gltf module or use injection or auto-discovery for gltf parser?\nimport { GLTFLoader, postProcessGLTF, _getMemoryUsageGLTF } from '@loaders.gl/gltf';\nimport { sliceArrayBuffer, parseFromContext } from '@loaders.gl/loader-utils';\nexport const GLTF_FORMAT = {\n    URI: 0,\n    EMBEDDED: 1\n};\nexport function parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options) {\n    // Set flags\n    // glTF models need to be rotated from Y to Z up\n    // https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#y-up-to-z-up\n    tile.rotateYtoZ = true;\n    // Assume glTF consumes rest of tile\n    const gltfByteLength = (tile.byteOffset || 0) + (tile.byteLength || 0) - byteOffset;\n    if (gltfByteLength === 0) {\n        throw new Error('glTF byte length must be greater than 0.');\n    }\n    // Save gltf up axis\n    tile.gltfUpAxis =\n        options?.['3d-tiles'] && options['3d-tiles'].assetGltfUpAxis\n            ? options['3d-tiles'].assetGltfUpAxis\n            : 'Y';\n    // TODO - We can avoid copy if already 4-byte aligned...\n    // However the rest of the code may not be able to accept byteOffsets, so copy anyway\n    tile.gltfArrayBuffer = sliceArrayBuffer(arrayBuffer, byteOffset, gltfByteLength);\n    tile.gltfByteOffset = 0;\n    tile.gltfByteLength = gltfByteLength;\n    if (byteOffset % 4 === 0) {\n        // tile.gltfArrayBuffer = arrayBuffer;\n        // tile.gltfByteOffset = byteOffset;\n        // tile.gltfByteLength = gltfByteLength;\n    }\n    else {\n        // Create a copy of the glb so that it is 4-byte aligned\n        // eslint-disable-next-line\n        console.warn(`${tile.type}: embedded glb is not aligned to a 4-byte boundary.`);\n    }\n    // Entire tile is consumed\n    return (tile.byteOffset || 0) + (tile.byteLength || 0);\n}\nexport async function extractGLTF(tile, gltfFormat, options, context) {\n    const tile3DOptions = options?.['3d-tiles'] || {};\n    extractGLTFBufferOrURL(tile, gltfFormat, options);\n    if (tile3DOptions.loadGLTF) {\n        if (!context) {\n            return;\n        }\n        if (tile.gltfUrl) {\n            const { fetch } = context;\n            const response = await fetch(tile.gltfUrl, options);\n            tile.gltfArrayBuffer = await response.arrayBuffer();\n            tile.gltfByteOffset = 0;\n        }\n        if (tile.gltfArrayBuffer) {\n            // TODO - Should handle byteOffset... However, not used now...\n            const gltfWithBuffers = await parseFromContext(tile.gltfArrayBuffer, GLTFLoader, options, context);\n            tile.gltf = postProcessGLTF(gltfWithBuffers);\n            tile.gpuMemoryUsageInBytes = _getMemoryUsageGLTF(tile.gltf);\n            delete tile.gltfArrayBuffer;\n            delete tile.gltfByteOffset;\n            delete tile.gltfByteLength;\n        }\n    }\n}\nfunction extractGLTFBufferOrURL(tile, gltfFormat, options) {\n    switch (gltfFormat) {\n        case GLTF_FORMAT.URI:\n            // We need to remove padding from the end of the model URL in case this tile was part of a composite tile.\n            // This removes all white space and null characters from the end of the string.\n            if (tile.gltfArrayBuffer) {\n                const gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);\n                const textDecoder = new TextDecoder();\n                const gltfUrl = textDecoder.decode(gltfUrlBytes);\n                tile.gltfUrl = gltfUrl.replace(/[\\s\\0]+$/, '');\n            }\n            delete tile.gltfArrayBuffer;\n            delete tile.gltfByteOffset;\n            delete tile.gltfByteLength;\n            break;\n        case GLTF_FORMAT.EMBEDDED:\n            break;\n        default:\n            throw new Error('b3dm: Illegal glTF format field');\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}