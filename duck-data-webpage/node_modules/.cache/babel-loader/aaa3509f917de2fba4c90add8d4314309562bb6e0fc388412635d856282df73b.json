{"ast":null,"code":"import { TouchAction } from \"./touchaction/touchaction.js\";\nimport { PointerEventInput } from \"./inputs/pointerevent.js\";\nimport { splitStr } from \"./utils/split-str.js\";\nimport { prefixed } from \"./utils/prefixed.js\";\nimport { RecognizerState } from \"./recognizer/recognizer-state.js\";\nconst STOP = 1;\nconst FORCED_STOP = 2;\nconst defaultOptions = {\n  touchAction: 'compute',\n  enable: true,\n  inputTarget: null,\n  cssProps: {\n    /**\n     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n     */\n    userSelect: 'none',\n    /**\n     * (Webkit) Disable default dragging behavior\n     */\n    // @ts-ignore\n    userDrag: 'none',\n    /**\n     * (iOS only) Disables the default callout shown when you touch and hold a touch target.\n     * When you touch and hold a touch target such as a link, Safari displays\n     * a callout containing information about the link. This property allows you to disable that callout.\n     */\n    // @ts-ignore\n    touchCallout: 'none',\n    /**\n     * (iOS only) Sets the color of the highlight that appears over a link while it's being tapped.\n     */\n    // @ts-ignore\n    tapHighlightColor: 'rgba(0,0,0,0)'\n  }\n};\n/**\n * Manager\n */\nexport class Manager {\n  constructor(element, options) {\n    this.options = {\n      ...defaultOptions,\n      ...options,\n      cssProps: {\n        ...defaultOptions.cssProps,\n        ...options.cssProps\n      },\n      inputTarget: options.inputTarget || element\n    };\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = new PointerEventInput(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    this.toggleCssProps(true);\n  }\n  /**\n   * set options\n   */\n  set(options) {\n    Object.assign(this.options, options);\n    // Options that need a little more setup\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n    return this;\n  }\n  /**\n   * stop recognizing for this session.\n   * This session will be discarded, when a new [input]start event is fired.\n   * When forced, the recognizer cycle is stopped immediately.\n   */\n  stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  }\n  /**\n   * run the recognizers!\n   * called by the inputHandler function on every movement of the pointers (touches)\n   * it walks through all the recognizers and tries to detect the gesture that is being made\n   */\n  recognize(inputData) {\n    const {\n      session\n    } = this;\n    if (session.stopped) {\n      return;\n    }\n    // run the touch-action polyfill\n    if (this.session.prevented) {\n      inputData.srcEvent.preventDefault();\n    }\n    let recognizer;\n    const {\n      recognizers\n    } = this;\n    // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n    let {\n      curRecognizer\n    } = session;\n    // reset when the last recognizer is recognized\n    // or when we're in a new session\n    if (!curRecognizer || curRecognizer && curRecognizer.state & RecognizerState.Recognized) {\n      curRecognizer = session.curRecognizer = null;\n    }\n    let i = 0;\n    while (i < recognizers.length) {\n      recognizer = recognizers[i];\n      // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n      if (session.stopped !== FORCED_STOP && (\n      // 1\n      !curRecognizer || recognizer === curRecognizer ||\n      // 2\n      recognizer.canRecognizeWith(curRecognizer))) {\n        // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      }\n      // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n      if (!curRecognizer && recognizer.state & (RecognizerState.Began | RecognizerState.Changed | RecognizerState.Ended)) {\n        curRecognizer = session.curRecognizer = recognizer;\n      }\n      i++;\n    }\n  }\n  /**\n   * get a recognizer by its event name.\n   */\n  get(recognizerName) {\n    const {\n      recognizers\n    } = this;\n    for (let i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizerName) {\n        return recognizers[i];\n      }\n    }\n    return null;\n  }\n  /**\n   * add a recognizer to the manager\n   * existing recognizers with the same event name will be removed\n   */\n  add(recognizer) {\n    if (Array.isArray(recognizer)) {\n      for (const item of recognizer) {\n        this.add(item);\n      }\n      return this;\n    }\n    // remove existing\n    const existing = this.get(recognizer.options.event);\n    if (existing) {\n      this.remove(existing);\n    }\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n    this.touchAction.update();\n    return recognizer;\n  }\n  /**\n   * remove a recognizer by name or instance\n   */\n  remove(recognizerOrName) {\n    if (Array.isArray(recognizerOrName)) {\n      for (const item of recognizerOrName) {\n        this.remove(item);\n      }\n      return this;\n    }\n    const recognizer = typeof recognizerOrName === 'string' ? this.get(recognizerOrName) : recognizerOrName;\n    // let's make sure this recognizer exists\n    if (recognizer) {\n      const {\n        recognizers\n      } = this;\n      const index = recognizers.indexOf(recognizer);\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n    return this;\n  }\n  /**\n   * bind event\n   */\n  on(events, handler) {\n    if (!events || !handler) {\n      return;\n    }\n    const {\n      handlers\n    } = this;\n    for (const event of splitStr(events)) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    }\n  }\n  /**\n   * unbind event, leave hander blank to remove all handlers\n   */\n  off(events, handler) {\n    if (!events) {\n      return;\n    }\n    const {\n      handlers\n    } = this;\n    for (const event of splitStr(events)) {\n      if (!handler) {\n        delete handlers[event];\n      } else if (handlers[event]) {\n        handlers[event].splice(handlers[event].indexOf(handler), 1);\n      }\n    }\n  }\n  /**\n   * emit event to the listeners\n   */\n  emit(event, data) {\n    // no handlers, so skip it all\n    const handlers = this.handlers[event] && this.handlers[event].slice();\n    if (!handlers || !handlers.length) {\n      return;\n    }\n    const evt = data;\n    evt.type = event;\n    evt.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n    let i = 0;\n    while (i < handlers.length) {\n      handlers[i](evt);\n      i++;\n    }\n  }\n  /**\n   * destroy the manager and unbinds all events\n   * it doesn't unbind dom events, that is the user own responsibility\n   */\n  destroy() {\n    this.toggleCssProps(false);\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  }\n  /**\n   * add/remove the css properties as defined in manager.options.cssProps\n   */\n  toggleCssProps(add) {\n    const {\n      element\n    } = this;\n    if (!element) {\n      return;\n    }\n    for (const [name, value] of Object.entries(this.options.cssProps)) {\n      const prop = prefixed(element.style, name);\n      if (add) {\n        this.oldCssProps[prop] = element.style[prop];\n        element.style[prop] = value;\n      } else {\n        element.style[prop] = this.oldCssProps[prop] || '';\n      }\n    }\n    if (!add) {\n      this.oldCssProps = {};\n    }\n  }\n}\n//# sourceMappingURL=manager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}