{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT AND ISC\n// Copyright vis.gl contributors\n/*\nAdapted from s2-geometry under ISC License (ISC)\nCopyright (c) 2012-2016, Jon Atkins <github@jonatkins.com>\nCopyright (c) 2016, AJ ONeal <aj@daplie.com>\nPermission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n*/\nimport Long from 'long';\n//\n// Functional Style\n//\nconst FACE_BITS = 3;\nconst MAX_LEVEL = 30;\nconst POS_BITS = 2 * MAX_LEVEL + 1; // 61 (60 bits of data, 1 bit lsb marker)\nconst RADIAN_TO_DEGREE = 180 / Math.PI;\n/**\n * Return the S2Cell\n * @param hilbertQuadkey {string} A string that is the Hilbert quad key (containing /)\n * @returns {@link S2Cell}\n */\n// eslint-disable-next-line max-statements\nexport function getS2CellFromQuadKey(hilbertQuadkey) {\n  if (hilbertQuadkey.length === 0) {\n    throw new Error(`Invalid Hilbert quad key ${hilbertQuadkey}`);\n  }\n  const parts = hilbertQuadkey.split('/');\n  const face = parseInt(parts[0], 10); // face is in the range [0..5]\n  const position = parts[1]; // position is in the range [0..4**30-1]\n  const maxLevel = position.length;\n  let level = 0;\n  const point = [0, 0];\n  for (let i = maxLevel - 1; i >= 0; i--) {\n    level = maxLevel - i;\n    const bit = position[i];\n    let rx = 0;\n    let ry = 0;\n    if (bit === '1') {\n      ry = 1;\n    } else if (bit === '2') {\n      rx = 1;\n      ry = 1;\n    } else if (bit === '3') {\n      rx = 1;\n    }\n    const val = Math.pow(2, level - 1);\n    rotateAndFlipQuadrant(val, point, rx, ry);\n    point[0] += val * rx;\n    point[1] += val * ry;\n  }\n  if (face % 2 === 1) {\n    const t = point[0];\n    point[0] = point[1];\n    point[1] = t;\n  }\n  return {\n    face,\n    ij: point,\n    level\n  };\n}\n/**\n * Convets S2 cell ID to the Hilbert quad key\n * @param cellId {Long} Cell id that is a 64-bit encoding of a face and a Hilbert curve parameter on that face\n * @returns {string} the Hilbert quad key (containing /) as a string in the format 'face/pos', where\n *  - face is a 10-base representation of the face number\n *  - pos is a 4-base representation of the position along the Hilbert curve. For example,\n *    pos == '13' means the following:\n *       The face is divided two times. After the first time the child cell with position 1 will be selected.\n *       Then, this cell will be divided the second time, and the child cell with position 3 will be selected.\n */\nexport function getS2QuadkeyFromCellId(cellId) {\n  if (cellId.isZero()) {\n    // Invalid token\n    return '';\n  }\n  let bin = cellId.toString(2);\n  while (bin.length < FACE_BITS + POS_BITS) {\n    // eslint-disable-next-line prefer-template\n    bin = '0' + bin;\n  }\n  // MUST come AFTER binstr has been left-padded with '0's\n  const lsbIndex = bin.lastIndexOf('1');\n  // substring(start, end) // includes start, does not include end\n  const faceB = bin.substring(0, 3);\n  // posB will always be a multiple of 2 (or it's invalid)\n  const posB = bin.substring(3, lsbIndex);\n  const levelN = posB.length / 2;\n  const faceS = Long.fromString(faceB, true, 2).toString(10);\n  /*\n    Here is a fix for the case when posB is an empty string that causes an exception in Long.fromString\n  */\n  let posS = '';\n  if (levelN !== 0) {\n    // posB is not an empty string, because levelN !== 0\n    posS = Long.fromString(posB, true, 2).toString(4);\n    while (posS.length < levelN) {\n      // eslint-disable-next-line prefer-template\n      posS = '0' + posS;\n    }\n  }\n  // Note, posS will be \"\" for the level==0, which corresponds to the full face.\n  // Example: Full face 0 (No subdivision, so level==0): Returns \"0/\"\n  // TODO: Is it ok?\n  return `${faceS}/${posS}`;\n}\n/**\n * Convets S2 the Hilbert quad key to cell ID.\n * @param quadkey {string} The Hilbert quad key (containing /) as a string in the format 'face/pos'\n * @returns {Long} Cell id that is a 64-bit encoding of a face and a Hilbert curve parameter on that face\n */\n/* eslint complexity: [\"error\", { \"max\": 14 }] */\nexport function getS2CellIdFromQuadkey(hilbertQuadkey) {\n  if (hilbertQuadkey.length === 0 || hilbertQuadkey.indexOf('/') !== 1) {\n    throw new Error(`Invalid Hilbert quad key ${hilbertQuadkey}`);\n  }\n  let idS = '';\n  const faceS = hilbertQuadkey[0];\n  switch (faceS) {\n    case '0':\n      idS += '000';\n      break;\n    case '1':\n      idS += '001';\n      break;\n    case '2':\n      idS += '010';\n      break;\n    case '3':\n      idS += '011';\n      break;\n    case '4':\n      idS += '100';\n      break;\n    case '5':\n      idS += '101';\n      break;\n    default:\n      throw new Error(`Invalid Hilbert quad key ${hilbertQuadkey}`);\n  }\n  const maxLevel = hilbertQuadkey.length;\n  // Don't convert position to Long, because it can contain leading zeros, which makes you handle it later.\n  for (let i = 2; i < maxLevel; i++) {\n    // The first char is a face, the second char is '/'\n    const p = hilbertQuadkey[i];\n    switch (p) {\n      case '0':\n        idS += '00';\n        break;\n      case '1':\n        idS += '01';\n        break;\n      case '2':\n        idS += '10';\n        break;\n      case '3':\n        idS += '11';\n        break;\n      default:\n        throw new Error(`Invalid Hilbert quad key ${hilbertQuadkey}`);\n    }\n  }\n  // Append the sentinel bit\n  idS += '1';\n  const paddedId = idS.padEnd(64, '0');\n  const id = Long.fromString(paddedId, true, 2);\n  return id;\n}\nexport function IJToST(ij, level, offsets) {\n  const maxSize = 1 << level;\n  return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];\n}\nfunction singleSTtoUV(st) {\n  if (st >= 0.5) {\n    return 1 / 3.0 * (4 * st * st - 1);\n  }\n  return 1 / 3.0 * (1 - 4 * (1 - st) * (1 - st));\n}\nexport function STToUV(st) {\n  return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];\n}\nexport function FaceUVToXYZ(face, [u, v]) {\n  switch (face) {\n    case 0:\n      return [1, u, v];\n    case 1:\n      return [-u, 1, v];\n    case 2:\n      return [-u, -v, 1];\n    case 3:\n      return [-1, -v, -u];\n    case 4:\n      return [v, -1, -u];\n    case 5:\n      return [v, u, -1];\n    default:\n      throw new Error('Invalid face');\n  }\n}\nexport function XYZToLngLat([x, y, z]) {\n  const lat = Math.atan2(z, Math.sqrt(x * x + y * y));\n  const lng = Math.atan2(y, x);\n  return [lng * RADIAN_TO_DEGREE, lat * RADIAN_TO_DEGREE];\n}\nfunction rotateAndFlipQuadrant(n, point, rx, ry) {\n  if (ry === 0) {\n    if (rx === 1) {\n      point[0] = n - 1 - point[0];\n      point[1] = n - 1 - point[1];\n    }\n    const x = point[0];\n    point[0] = point[1];\n    point[1] = x;\n  }\n}\n/**\n * Retrieve S2 geometry center\n * @param s2cell {S2Cell} S2 cell\n * @returns {[number, number]} Longitude and Latitude coordinates of the S2 cell's center\n */\nexport function getS2LngLatFromS2Cell(s2Cell) {\n  const st = IJToST(s2Cell.ij, s2Cell.level, [0.5, 0.5]);\n  const uv = STToUV(st);\n  const xyz = FaceUVToXYZ(s2Cell.face, uv);\n  return XYZToLngLat(xyz);\n}\n/**\n * Return longitude and latitude of four corners of the cell.\n * @param s2Cell {S2Cell} S2 cell\n * @returns {Array<[number, number]>} Array of longitude and latitude pairs (in degrees) for four corners of the cell.\n */\nexport function getCornerLngLats(s2Cell) {\n  const result = [];\n  const offsets = [[0.0, 0.0], [0.0, 1.0], [1.0, 1.0], [1.0, 0.0]];\n  for (let i = 0; i < 4; i++) {\n    const st = IJToST(s2Cell.ij, s2Cell.level, offsets[i]);\n    const uv = STToUV(st);\n    const xyz = FaceUVToXYZ(s2Cell.face, uv);\n    result.push(XYZToLngLat(xyz));\n  }\n  return result;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}