{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Geometry } from \"../geometry/geometry.js\";\nimport { uid } from \"../utils/uid.js\";\n// Primitives inspired by TDL http://code.google.com/p/webglsamples/,\n// copyright 2011 Google Inc. new BSD License\n// (http://www.opensource.org/licenses/bsd-license.php).\nexport class SphereGeometry extends Geometry {\n  constructor(props = {}) {\n    const {\n      id = uid('sphere-geometry')\n    } = props;\n    const {\n      indices,\n      attributes\n    } = tesselateSphere(props);\n    super({\n      ...props,\n      id,\n      topology: 'triangle-list',\n      indices,\n      attributes: {\n        ...attributes,\n        ...props.attributes\n      }\n    });\n  }\n}\n/* eslint-disable max-statements, complexity */\nfunction tesselateSphere(props) {\n  const {\n    nlat = 10,\n    nlong = 10\n  } = props;\n  const startLat = 0;\n  const endLat = Math.PI;\n  const latRange = endLat - startLat;\n  const startLong = 0;\n  const endLong = 2 * Math.PI;\n  const longRange = endLong - startLong;\n  const numVertices = (nlat + 1) * (nlong + 1);\n  const radius = (n1, n2, n3, u, v) => props.radius || 1;\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n  const texCoords = new Float32Array(numVertices * 2);\n  const IndexType = numVertices > 0xffff ? Uint32Array : Uint16Array;\n  const indices = new IndexType(nlat * nlong * 6);\n  // Create positions, normals and texCoords\n  for (let y = 0; y <= nlat; y++) {\n    for (let x = 0; x <= nlong; x++) {\n      const u = x / nlong;\n      const v = y / nlat;\n      const index = x + y * (nlong + 1);\n      const i2 = index * 2;\n      const i3 = index * 3;\n      const theta = longRange * u;\n      const phi = latRange * v;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n      const sinPhi = Math.sin(phi);\n      const cosPhi = Math.cos(phi);\n      const ux = cosTheta * sinPhi;\n      const uy = cosPhi;\n      const uz = sinTheta * sinPhi;\n      const r = radius(ux, uy, uz, u, v);\n      positions[i3 + 0] = r * ux;\n      positions[i3 + 1] = r * uy;\n      positions[i3 + 2] = r * uz;\n      normals[i3 + 0] = ux;\n      normals[i3 + 1] = uy;\n      normals[i3 + 2] = uz;\n      texCoords[i2 + 0] = u;\n      texCoords[i2 + 1] = 1 - v;\n    }\n  }\n  // Create indices\n  const numVertsAround = nlong + 1;\n  for (let x = 0; x < nlong; x++) {\n    for (let y = 0; y < nlat; y++) {\n      const index = (x * nlat + y) * 6;\n      indices[index + 0] = y * numVertsAround + x;\n      indices[index + 1] = y * numVertsAround + x + 1;\n      indices[index + 2] = (y + 1) * numVertsAround + x;\n      indices[index + 3] = (y + 1) * numVertsAround + x;\n      indices[index + 4] = y * numVertsAround + x + 1;\n      indices[index + 5] = (y + 1) * numVertsAround + x + 1;\n    }\n  }\n  return {\n    indices: {\n      size: 1,\n      value: indices\n    },\n    attributes: {\n      POSITION: {\n        size: 3,\n        value: positions\n      },\n      NORMAL: {\n        size: 3,\n        value: normals\n      },\n      TEXCOORD_0: {\n        size: 2,\n        value: texCoords\n      }\n    }\n  };\n}\n//# sourceMappingURL=sphere-geometry.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}