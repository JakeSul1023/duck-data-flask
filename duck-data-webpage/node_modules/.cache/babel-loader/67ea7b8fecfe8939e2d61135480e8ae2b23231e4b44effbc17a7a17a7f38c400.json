{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { luma } from '@luma.gl/core';\nimport { requestAnimationFramePolyfill, cancelAnimationFramePolyfill } from \"./request-animation-frame.js\";\nimport { Stats } from '@probe.gl/stats';\nlet statIdCounter = 0;\nconst DEFAULT_ANIMATION_LOOP_PROPS = {\n  device: null,\n  onAddHTML: () => '',\n  onInitialize: async () => {\n    return null;\n  },\n  onRender: () => {},\n  onFinalize: () => {},\n  onError: error => console.error(error),\n  // eslint-disable-line no-console\n  stats: luma.stats.get(`animation-loop-${statIdCounter++}`),\n  // view parameters\n  useDevicePixels: true,\n  autoResizeViewport: false,\n  autoResizeDrawingBuffer: false\n};\n/** Convenient animation loop */\nexport class AnimationLoop {\n  device = null;\n  canvas = null;\n  props;\n  animationProps = null;\n  timeline = null;\n  stats;\n  cpuTime;\n  gpuTime;\n  frameRate;\n  display;\n  needsRedraw = 'initialized';\n  _initialized = false;\n  _running = false;\n  _animationFrameId = null;\n  _nextFramePromise = null;\n  _resolveNextFrame = null;\n  _cpuStartTime = 0;\n  _error = null;\n  // _gpuTimeQuery: Query | null = null;\n  /*\n   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context\n   */\n  constructor(props) {\n    this.props = {\n      ...DEFAULT_ANIMATION_LOOP_PROPS,\n      ...props\n    };\n    props = this.props;\n    if (!props.device) {\n      throw new Error('No device provided');\n    }\n    const {\n      useDevicePixels = true\n    } = this.props;\n    // state\n    this.stats = props.stats || new Stats({\n      id: 'animation-loop-stats'\n    });\n    this.cpuTime = this.stats.get('CPU Time');\n    this.gpuTime = this.stats.get('GPU Time');\n    this.frameRate = this.stats.get('Frame Rate');\n    this.setProps({\n      autoResizeViewport: props.autoResizeViewport,\n      autoResizeDrawingBuffer: props.autoResizeDrawingBuffer,\n      useDevicePixels\n    });\n    // Bind methods\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n    this._onMousemove = this._onMousemove.bind(this);\n    this._onMouseleave = this._onMouseleave.bind(this);\n  }\n  destroy() {\n    this.stop();\n    this._setDisplay(null);\n  }\n  /** @deprecated Use .destroy() */\n  delete() {\n    this.destroy();\n  }\n  setError(error) {\n    this.props.onError(error);\n    this._error = Error();\n    const canvas = this.device?.canvasContext?.canvas;\n    if (canvas instanceof HTMLCanvasElement) {\n      const errorDiv = document.createElement('h1');\n      errorDiv.innerHTML = error.message;\n      errorDiv.style.position = 'absolute';\n      errorDiv.style.top = '20%'; // left: 50%; transform: translate(-50%, -50%);';\n      errorDiv.style.left = '10px';\n      errorDiv.style.color = 'black';\n      errorDiv.style.backgroundColor = 'red';\n      document.body.appendChild(errorDiv);\n      // canvas.style.position = 'absolute';\n    }\n  }\n  /** Flags this animation loop as needing redraw */\n  setNeedsRedraw(reason) {\n    this.needsRedraw = this.needsRedraw || reason;\n    return this;\n  }\n  /** TODO - move these props to CanvasContext? */\n  setProps(props) {\n    if ('autoResizeViewport' in props) {\n      this.props.autoResizeViewport = props.autoResizeViewport || false;\n    }\n    if ('autoResizeDrawingBuffer' in props) {\n      this.props.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer || false;\n    }\n    if ('useDevicePixels' in props) {\n      this.props.useDevicePixels = props.useDevicePixels || false;\n    }\n    return this;\n  }\n  /** Starts a render loop if not already running */\n  async start() {\n    if (this._running) {\n      return this;\n    }\n    this._running = true;\n    try {\n      let appContext;\n      if (!this._initialized) {\n        this._initialized = true;\n        // Create the WebGL context\n        await this._initDevice();\n        this._initialize();\n        // Note: onIntialize can return a promise (e.g. in case app needs to load resources)\n        await this.props.onInitialize(this._getAnimationProps());\n      }\n      // check that we haven't been stopped\n      if (!this._running) {\n        return null;\n      }\n      // Start the loop\n      if (appContext !== false) {\n        // cancel any pending renders to ensure only one loop can ever run\n        this._cancelAnimationFrame();\n        this._requestAnimationFrame();\n      }\n      return this;\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.props.onError(error);\n      // this._running = false; // TODO\n      throw error;\n    }\n  }\n  /** Stops a render loop if already running, finalizing */\n  stop() {\n    // console.debug(`Stopping ${this.constructor.name}`);\n    if (this._running) {\n      // call callback\n      // If stop is called immediately, we can end up in a state where props haven't been initialized...\n      if (this.animationProps && !this._error) {\n        this.props.onFinalize(this.animationProps);\n      }\n      this._cancelAnimationFrame();\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n      this._running = false;\n    }\n    return this;\n  }\n  /** Explicitly draw a frame */\n  redraw() {\n    if (this.device?.isLost || this._error) {\n      return this;\n    }\n    this._beginFrameTimers();\n    this._setupFrame();\n    this._updateAnimationProps();\n    this._renderFrame(this._getAnimationProps());\n    // clear needsRedraw flag\n    this._clearNeedsRedraw();\n    if (this._resolveNextFrame) {\n      this._resolveNextFrame(this);\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n    }\n    this._endFrameTimers();\n    return this;\n  }\n  /** Add a timeline, it will be automatically updated by the animation loop. */\n  attachTimeline(timeline) {\n    this.timeline = timeline;\n    return this.timeline;\n  }\n  /** Remove a timeline */\n  detachTimeline() {\n    this.timeline = null;\n  }\n  /** Wait until a render completes */\n  waitForRender() {\n    this.setNeedsRedraw('waitForRender');\n    if (!this._nextFramePromise) {\n      this._nextFramePromise = new Promise(resolve => {\n        this._resolveNextFrame = resolve;\n      });\n    }\n    return this._nextFramePromise;\n  }\n  /** TODO - should use device.deviceContext */\n  async toDataURL() {\n    this.setNeedsRedraw('toDataURL');\n    await this.waitForRender();\n    if (this.canvas instanceof HTMLCanvasElement) {\n      return this.canvas.toDataURL();\n    }\n    throw new Error('OffscreenCanvas');\n  }\n  // PRIVATE METHODS\n  _initialize() {\n    this._startEventHandling();\n    // Initialize the callback data\n    this._initializeAnimationProps();\n    this._updateAnimationProps();\n    // Default viewport setup, in case onInitialize wants to render\n    this._resizeCanvasDrawingBuffer();\n    this._resizeViewport();\n    // this._gpuTimeQuery = Query.isSupported(this.gl, ['timers']) ? new Query(this.gl) : null;\n  }\n  _setDisplay(display) {\n    if (this.display) {\n      this.display.destroy();\n      this.display.animationLoop = null;\n    }\n    // store animation loop on the display\n    if (display) {\n      display.animationLoop = this;\n    }\n    this.display = display;\n  }\n  _requestAnimationFrame() {\n    if (!this._running) {\n      return;\n    }\n    // VR display has a separate animation frame to sync with headset\n    // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/\n    // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame\n    // if (this.display && this.display.requestAnimationFrame) {\n    //   this._animationFrameId = this.display.requestAnimationFrame(this._animationFrame.bind(this));\n    // }\n    this._animationFrameId = requestAnimationFramePolyfill(this._animationFrame.bind(this));\n  }\n  _cancelAnimationFrame() {\n    if (this._animationFrameId === null) {\n      return;\n    }\n    // VR display has a separate animation frame to sync with headset\n    // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/\n    // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame\n    // if (this.display && this.display.cancelAnimationFramePolyfill) {\n    //   this.display.cancelAnimationFrame(this._animationFrameId);\n    // }\n    cancelAnimationFramePolyfill(this._animationFrameId);\n    this._animationFrameId = null;\n  }\n  _animationFrame() {\n    if (!this._running) {\n      return;\n    }\n    this.redraw();\n    this._requestAnimationFrame();\n  }\n  // Called on each frame, can be overridden to call onRender multiple times\n  // to support e.g. stereoscopic rendering\n  _renderFrame(animationProps) {\n    // Allow e.g. VR display to render multiple frames.\n    if (this.display) {\n      this.display._renderFrame(animationProps);\n      return;\n    }\n    // call callback\n    this.props.onRender(this._getAnimationProps());\n    // end callback\n    // Submit commands (necessary on WebGPU)\n    this.device?.submit();\n  }\n  _clearNeedsRedraw() {\n    this.needsRedraw = false;\n  }\n  _setupFrame() {\n    this._resizeCanvasDrawingBuffer();\n    this._resizeViewport();\n  }\n  // Initialize the  object that will be passed to app callbacks\n  _initializeAnimationProps() {\n    const canvas = this.device?.canvasContext?.canvas;\n    if (!this.device || !canvas) {\n      throw new Error('loop');\n    }\n    this.animationProps = {\n      animationLoop: this,\n      device: this.device,\n      canvas,\n      timeline: this.timeline,\n      // Initial values\n      useDevicePixels: this.props.useDevicePixels,\n      needsRedraw: false,\n      // Placeholders\n      width: 1,\n      height: 1,\n      aspect: 1,\n      // Animation props\n      time: 0,\n      startTime: Date.now(),\n      engineTime: 0,\n      tick: 0,\n      tock: 0,\n      // Experimental\n      _mousePosition: null // Event props\n    };\n  }\n  _getAnimationProps() {\n    if (!this.animationProps) {\n      throw new Error('animationProps');\n    }\n    return this.animationProps;\n  }\n  // Update the context object that will be passed to app callbacks\n  _updateAnimationProps() {\n    if (!this.animationProps) {\n      return;\n    }\n    // Can this be replaced with canvas context?\n    const {\n      width,\n      height,\n      aspect\n    } = this._getSizeAndAspect();\n    if (width !== this.animationProps.width || height !== this.animationProps.height) {\n      this.setNeedsRedraw('drawing buffer resized');\n    }\n    if (aspect !== this.animationProps.aspect) {\n      this.setNeedsRedraw('drawing buffer aspect changed');\n    }\n    this.animationProps.width = width;\n    this.animationProps.height = height;\n    this.animationProps.aspect = aspect;\n    this.animationProps.needsRedraw = this.needsRedraw;\n    // Update time properties\n    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;\n    if (this.timeline) {\n      this.timeline.update(this.animationProps.engineTime);\n    }\n    this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);\n    this.animationProps.tock++;\n    // For back compatibility\n    this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;\n  }\n  /** Wait for supplied device */\n  async _initDevice() {\n    this.device = await this.props.device;\n    if (!this.device) {\n      throw new Error('No device provided');\n    }\n    this.canvas = this.device.canvasContext?.canvas || null;\n    // this._createInfoDiv();\n  }\n  _createInfoDiv() {\n    if (this.canvas && this.props.onAddHTML) {\n      const wrapperDiv = document.createElement('div');\n      document.body.appendChild(wrapperDiv);\n      wrapperDiv.style.position = 'relative';\n      const div = document.createElement('div');\n      div.style.position = 'absolute';\n      div.style.left = '10px';\n      div.style.bottom = '10px';\n      div.style.width = '300px';\n      div.style.background = 'white';\n      if (this.canvas instanceof HTMLCanvasElement) {\n        wrapperDiv.appendChild(this.canvas);\n      }\n      wrapperDiv.appendChild(div);\n      const html = this.props.onAddHTML(div);\n      if (html) {\n        div.innerHTML = html;\n      }\n    }\n  }\n  _getSizeAndAspect() {\n    if (!this.device) {\n      return {\n        width: 1,\n        height: 1,\n        aspect: 1\n      };\n    }\n    // https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n    const [width, height] = this.device?.canvasContext?.getPixelSize() || [1, 1];\n    // https://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html\n    let aspect = 1;\n    const canvas = this.device?.canvasContext?.canvas;\n    // @ts-expect-error\n    if (canvas && canvas.clientHeight) {\n      // @ts-expect-error\n      aspect = canvas.clientWidth / canvas.clientHeight;\n    } else if (width > 0 && height > 0) {\n      aspect = width / height;\n    }\n    return {\n      width,\n      height,\n      aspect\n    };\n  }\n  /** Default viewport setup */\n  _resizeViewport() {\n    // TODO can we use canvas context to code this in a portable way?\n    // @ts-expect-error Expose on canvasContext\n    if (this.props.autoResizeViewport && this.device.gl) {\n      // @ts-expect-error Expose canvasContext\n      this.device.gl.viewport(0, 0,\n      // @ts-expect-error Expose canvasContext\n      this.device.gl.drawingBufferWidth,\n      // @ts-expect-error Expose canvasContext\n      this.device.gl.drawingBufferHeight);\n    }\n  }\n  /**\n   * Resize the render buffer of the canvas to match canvas client size\n   * Optionally multiplying with devicePixel ratio\n   */\n  _resizeCanvasDrawingBuffer() {\n    if (this.props.autoResizeDrawingBuffer) {\n      this.device?.canvasContext?.resize({\n        useDevicePixels: this.props.useDevicePixels\n      });\n    }\n  }\n  _beginFrameTimers() {\n    this.frameRate.timeEnd();\n    this.frameRate.timeStart();\n    // Check if timer for last frame has completed.\n    // GPU timer results are never available in the same\n    // frame they are captured.\n    // if (\n    //   this._gpuTimeQuery &&\n    //   this._gpuTimeQuery.isResultAvailable() &&\n    //   !this._gpuTimeQuery.isTimerDisjoint()\n    // ) {\n    //   this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());\n    // }\n    // if (this._gpuTimeQuery) {\n    //   // GPU time query start\n    //   this._gpuTimeQuery.beginTimeElapsedQuery();\n    // }\n    this.cpuTime.timeStart();\n  }\n  _endFrameTimers() {\n    this.cpuTime.timeEnd();\n    // if (this._gpuTimeQuery) {\n    //   // GPU time query end. Results will be available on next frame.\n    //   this._gpuTimeQuery.end();\n    // }\n  }\n  // Event handling\n  _startEventHandling() {\n    if (this.canvas) {\n      this.canvas.addEventListener('mousemove', this._onMousemove.bind(this));\n      this.canvas.addEventListener('mouseleave', this._onMouseleave.bind(this));\n    }\n  }\n  _onMousemove(event) {\n    if (event instanceof MouseEvent) {\n      this._getAnimationProps()._mousePosition = [event.offsetX, event.offsetY];\n    }\n  }\n  _onMouseleave(event) {\n    this._getAnimationProps()._mousePosition = null;\n  }\n}","map":{"version":3,"names":["luma","requestAnimationFramePolyfill","cancelAnimationFramePolyfill","Stats","statIdCounter","DEFAULT_ANIMATION_LOOP_PROPS","device","onAddHTML","onInitialize","onRender","onFinalize","onError","error","console","stats","get","useDevicePixels","autoResizeViewport","autoResizeDrawingBuffer","AnimationLoop","canvas","props","animationProps","timeline","cpuTime","gpuTime","frameRate","display","needsRedraw","_initialized","_running","_animationFrameId","_nextFramePromise","_resolveNextFrame","_cpuStartTime","_error","constructor","Error","id","setProps","start","bind","stop","_onMousemove","_onMouseleave","destroy","_setDisplay","delete","setError","canvasContext","HTMLCanvasElement","errorDiv","document","createElement","innerHTML","message","style","position","top","left","color","backgroundColor","body","appendChild","setNeedsRedraw","reason","appContext","_initDevice","_initialize","_getAnimationProps","_cancelAnimationFrame","_requestAnimationFrame","err","redraw","isLost","_beginFrameTimers","_setupFrame","_updateAnimationProps","_renderFrame","_clearNeedsRedraw","_endFrameTimers","attachTimeline","detachTimeline","waitForRender","Promise","resolve","toDataURL","_startEventHandling","_initializeAnimationProps","_resizeCanvasDrawingBuffer","_resizeViewport","animationLoop","_animationFrame","submit","width","height","aspect","time","startTime","Date","now","engineTime","tick","tock","_mousePosition","_getSizeAndAspect","update","Math","floor","getTime","_createInfoDiv","wrapperDiv","div","bottom","background","html","getPixelSize","clientHeight","clientWidth","gl","viewport","drawingBufferWidth","drawingBufferHeight","resize","timeEnd","timeStart","addEventListener","event","MouseEvent","offsetX","offsetY"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\engine\\src\\animation-loop\\animation-loop.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {luma, Device} from '@luma.gl/core';\nimport {\n  requestAnimationFramePolyfill,\n  cancelAnimationFramePolyfill\n} from './request-animation-frame';\nimport {Timeline} from '../animation/timeline';\nimport {AnimationProps} from './animation-props';\nimport {Stats, Stat} from '@probe.gl/stats';\n\nlet statIdCounter = 0;\n\n/** AnimationLoop properties */\nexport type AnimationLoopProps = {\n  device: Device | Promise<Device>;\n\n  onAddHTML?: (div: HTMLDivElement) => string; // innerHTML\n  onInitialize?: (animationProps: AnimationProps) => Promise<unknown>;\n  onRender?: (animationProps: AnimationProps) => unknown;\n  onFinalize?: (animationProps: AnimationProps) => void;\n  onError?: (reason: Error) => void;\n\n  stats?: Stats;\n\n  // view parameters - TODO move to CanvasContext?\n  autoResizeViewport?: boolean;\n  autoResizeDrawingBuffer?: boolean;\n  useDevicePixels?: number | boolean;\n};\n\nexport type MutableAnimationLoopProps = {\n  // view parameters\n  autoResizeViewport?: boolean;\n  autoResizeDrawingBuffer?: boolean;\n  useDevicePixels?: number | boolean;\n};\n\nconst DEFAULT_ANIMATION_LOOP_PROPS: Required<AnimationLoopProps> = {\n  device: null!,\n\n  onAddHTML: () => '',\n  onInitialize: async () => {\n    return null;\n  },\n  onRender: () => {},\n  onFinalize: () => {},\n  onError: error => console.error(error), // eslint-disable-line no-console\n\n  stats: luma.stats.get(`animation-loop-${statIdCounter++}`),\n\n  // view parameters\n  useDevicePixels: true,\n  autoResizeViewport: false,\n  autoResizeDrawingBuffer: false\n};\n\n/** Convenient animation loop */\nexport class AnimationLoop {\n  device: Device | null = null;\n  canvas: HTMLCanvasElement | OffscreenCanvas | null = null;\n\n  props: Required<AnimationLoopProps>;\n  animationProps: AnimationProps | null = null;\n  timeline: Timeline | null = null;\n  stats: Stats;\n  cpuTime: Stat;\n  gpuTime: Stat;\n  frameRate: Stat;\n\n  display: any;\n\n  needsRedraw: string | false = 'initialized';\n\n  _initialized: boolean = false;\n  _running: boolean = false;\n  _animationFrameId: any = null;\n  _nextFramePromise: Promise<AnimationLoop> | null = null;\n  _resolveNextFrame: ((animationLoop: AnimationLoop) => void) | null = null;\n  _cpuStartTime: number = 0;\n  _error: Error | null = null;\n\n  // _gpuTimeQuery: Query | null = null;\n\n  /*\n   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context\n   */\n  constructor(props: AnimationLoopProps) {\n    this.props = {...DEFAULT_ANIMATION_LOOP_PROPS, ...props};\n    props = this.props;\n\n    if (!props.device) {\n      throw new Error('No device provided');\n    }\n\n    const {useDevicePixels = true} = this.props;\n\n    // state\n    this.stats = props.stats || new Stats({id: 'animation-loop-stats'});\n    this.cpuTime = this.stats.get('CPU Time');\n    this.gpuTime = this.stats.get('GPU Time');\n    this.frameRate = this.stats.get('Frame Rate');\n\n    this.setProps({\n      autoResizeViewport: props.autoResizeViewport,\n      autoResizeDrawingBuffer: props.autoResizeDrawingBuffer,\n      useDevicePixels\n    });\n\n    // Bind methods\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n\n    this._onMousemove = this._onMousemove.bind(this);\n    this._onMouseleave = this._onMouseleave.bind(this);\n  }\n\n  destroy(): void {\n    this.stop();\n    this._setDisplay(null);\n  }\n\n  /** @deprecated Use .destroy() */\n  delete(): void {\n    this.destroy();\n  }\n\n  setError(error: Error): void {\n    this.props.onError(error);\n    this._error = Error();\n    const canvas = this.device?.canvasContext?.canvas;\n    if (canvas instanceof HTMLCanvasElement) {\n      const errorDiv = document.createElement('h1');\n      errorDiv.innerHTML = error.message;\n      errorDiv.style.position = 'absolute';\n      errorDiv.style.top = '20%'; // left: 50%; transform: translate(-50%, -50%);';\n      errorDiv.style.left = '10px';\n      errorDiv.style.color = 'black';\n      errorDiv.style.backgroundColor = 'red';\n      document.body.appendChild(errorDiv);\n      // canvas.style.position = 'absolute';\n    }\n  }\n\n  /** Flags this animation loop as needing redraw */\n  setNeedsRedraw(reason: string): this {\n    this.needsRedraw = this.needsRedraw || reason;\n    return this;\n  }\n\n  /** TODO - move these props to CanvasContext? */\n  setProps(props: MutableAnimationLoopProps): this {\n    if ('autoResizeViewport' in props) {\n      this.props.autoResizeViewport = props.autoResizeViewport || false;\n    }\n    if ('autoResizeDrawingBuffer' in props) {\n      this.props.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer || false;\n    }\n    if ('useDevicePixels' in props) {\n      this.props.useDevicePixels = props.useDevicePixels || false;\n    }\n    return this;\n  }\n\n  /** Starts a render loop if not already running */\n  async start() {\n    if (this._running) {\n      return this;\n    }\n    this._running = true;\n\n    try {\n      let appContext;\n      if (!this._initialized) {\n        this._initialized = true;\n        // Create the WebGL context\n        await this._initDevice();\n        this._initialize();\n\n        // Note: onIntialize can return a promise (e.g. in case app needs to load resources)\n        await this.props.onInitialize(this._getAnimationProps());\n      }\n\n      // check that we haven't been stopped\n      if (!this._running) {\n        return null;\n      }\n\n      // Start the loop\n      if (appContext !== false) {\n        // cancel any pending renders to ensure only one loop can ever run\n        this._cancelAnimationFrame();\n        this._requestAnimationFrame();\n      }\n\n      return this;\n    } catch (err: unknown) {\n      const error = err instanceof Error ? err : new Error('Unknown error');\n      this.props.onError(error);\n      // this._running = false; // TODO\n      throw error;\n    }\n  }\n\n  /** Stops a render loop if already running, finalizing */\n  stop() {\n    // console.debug(`Stopping ${this.constructor.name}`);\n    if (this._running) {\n      // call callback\n      // If stop is called immediately, we can end up in a state where props haven't been initialized...\n      if (this.animationProps && !this._error) {\n        this.props.onFinalize(this.animationProps);\n      }\n\n      this._cancelAnimationFrame();\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n      this._running = false;\n    }\n    return this;\n  }\n\n  /** Explicitly draw a frame */\n  redraw(): this {\n    if (this.device?.isLost || this._error) {\n      return this;\n    }\n\n    this._beginFrameTimers();\n\n    this._setupFrame();\n    this._updateAnimationProps();\n\n    this._renderFrame(this._getAnimationProps());\n\n    // clear needsRedraw flag\n    this._clearNeedsRedraw();\n\n    if (this._resolveNextFrame) {\n      this._resolveNextFrame(this);\n      this._nextFramePromise = null;\n      this._resolveNextFrame = null;\n    }\n\n    this._endFrameTimers();\n\n    return this;\n  }\n\n  /** Add a timeline, it will be automatically updated by the animation loop. */\n  attachTimeline(timeline: Timeline): Timeline {\n    this.timeline = timeline;\n    return this.timeline;\n  }\n\n  /** Remove a timeline */\n  detachTimeline(): void {\n    this.timeline = null;\n  }\n\n  /** Wait until a render completes */\n  waitForRender(): Promise<AnimationLoop> {\n    this.setNeedsRedraw('waitForRender');\n\n    if (!this._nextFramePromise) {\n      this._nextFramePromise = new Promise(resolve => {\n        this._resolveNextFrame = resolve;\n      });\n    }\n    return this._nextFramePromise;\n  }\n\n  /** TODO - should use device.deviceContext */\n  async toDataURL(): Promise<string> {\n    this.setNeedsRedraw('toDataURL');\n    await this.waitForRender();\n    if (this.canvas instanceof HTMLCanvasElement) {\n      return this.canvas.toDataURL();\n    }\n    throw new Error('OffscreenCanvas');\n  }\n\n  // PRIVATE METHODS\n\n  _initialize(): void {\n    this._startEventHandling();\n\n    // Initialize the callback data\n    this._initializeAnimationProps();\n    this._updateAnimationProps();\n\n    // Default viewport setup, in case onInitialize wants to render\n    this._resizeCanvasDrawingBuffer();\n    this._resizeViewport();\n\n    // this._gpuTimeQuery = Query.isSupported(this.gl, ['timers']) ? new Query(this.gl) : null;\n  }\n\n  _setDisplay(display: any): void {\n    if (this.display) {\n      this.display.destroy();\n      this.display.animationLoop = null;\n    }\n\n    // store animation loop on the display\n    if (display) {\n      display.animationLoop = this;\n    }\n\n    this.display = display;\n  }\n\n  _requestAnimationFrame(): void {\n    if (!this._running) {\n      return;\n    }\n\n    // VR display has a separate animation frame to sync with headset\n    // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/\n    // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame\n    // if (this.display && this.display.requestAnimationFrame) {\n    //   this._animationFrameId = this.display.requestAnimationFrame(this._animationFrame.bind(this));\n    // }\n    this._animationFrameId = requestAnimationFramePolyfill(this._animationFrame.bind(this));\n  }\n\n  _cancelAnimationFrame(): void {\n    if (this._animationFrameId === null) {\n      return;\n    }\n\n    // VR display has a separate animation frame to sync with headset\n    // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/\n    // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame\n    // if (this.display && this.display.cancelAnimationFramePolyfill) {\n    //   this.display.cancelAnimationFrame(this._animationFrameId);\n    // }\n    cancelAnimationFramePolyfill(this._animationFrameId);\n    this._animationFrameId = null;\n  }\n\n  _animationFrame(): void {\n    if (!this._running) {\n      return;\n    }\n    this.redraw();\n    this._requestAnimationFrame();\n  }\n\n  // Called on each frame, can be overridden to call onRender multiple times\n  // to support e.g. stereoscopic rendering\n  _renderFrame(animationProps: AnimationProps): void {\n    // Allow e.g. VR display to render multiple frames.\n    if (this.display) {\n      this.display._renderFrame(animationProps);\n      return;\n    }\n\n    // call callback\n    this.props.onRender(this._getAnimationProps());\n    // end callback\n\n    // Submit commands (necessary on WebGPU)\n    this.device?.submit();\n  }\n\n  _clearNeedsRedraw(): void {\n    this.needsRedraw = false;\n  }\n\n  _setupFrame(): void {\n    this._resizeCanvasDrawingBuffer();\n    this._resizeViewport();\n  }\n\n  // Initialize the  object that will be passed to app callbacks\n  _initializeAnimationProps(): void {\n    const canvas = this.device?.canvasContext?.canvas;\n\n    if (!this.device || !canvas) {\n      throw new Error('loop');\n    }\n    this.animationProps = {\n      animationLoop: this,\n\n      device: this.device,\n      canvas,\n      timeline: this.timeline,\n\n      // Initial values\n      useDevicePixels: this.props.useDevicePixels,\n      needsRedraw: false,\n\n      // Placeholders\n      width: 1,\n      height: 1,\n      aspect: 1,\n\n      // Animation props\n      time: 0,\n      startTime: Date.now(),\n      engineTime: 0,\n      tick: 0,\n      tock: 0,\n\n      // Experimental\n      _mousePosition: null // Event props\n    };\n  }\n\n  _getAnimationProps(): AnimationProps {\n    if (!this.animationProps) {\n      throw new Error('animationProps');\n    }\n    return this.animationProps;\n  }\n\n  // Update the context object that will be passed to app callbacks\n  _updateAnimationProps(): void {\n    if (!this.animationProps) {\n      return;\n    }\n\n    // Can this be replaced with canvas context?\n    const {width, height, aspect} = this._getSizeAndAspect();\n    if (width !== this.animationProps.width || height !== this.animationProps.height) {\n      this.setNeedsRedraw('drawing buffer resized');\n    }\n    if (aspect !== this.animationProps.aspect) {\n      this.setNeedsRedraw('drawing buffer aspect changed');\n    }\n\n    this.animationProps.width = width;\n    this.animationProps.height = height;\n    this.animationProps.aspect = aspect;\n\n    this.animationProps.needsRedraw = this.needsRedraw;\n\n    // Update time properties\n    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;\n\n    if (this.timeline) {\n      this.timeline.update(this.animationProps.engineTime);\n    }\n\n    this.animationProps.tick = Math.floor((this.animationProps.time / 1000) * 60);\n    this.animationProps.tock++;\n\n    // For back compatibility\n    this.animationProps.time = this.timeline\n      ? this.timeline.getTime()\n      : this.animationProps.engineTime;\n  }\n\n  /** Wait for supplied device */\n  async _initDevice() {\n    this.device = await this.props.device;\n    if (!this.device) {\n      throw new Error('No device provided');\n    }\n    this.canvas = this.device.canvasContext?.canvas || null;\n    // this._createInfoDiv();\n  }\n\n  _createInfoDiv(): void {\n    if (this.canvas && this.props.onAddHTML) {\n      const wrapperDiv = document.createElement('div');\n      document.body.appendChild(wrapperDiv);\n      wrapperDiv.style.position = 'relative';\n      const div = document.createElement('div');\n      div.style.position = 'absolute';\n      div.style.left = '10px';\n      div.style.bottom = '10px';\n      div.style.width = '300px';\n      div.style.background = 'white';\n      if (this.canvas instanceof HTMLCanvasElement) {\n        wrapperDiv.appendChild(this.canvas);\n      }\n      wrapperDiv.appendChild(div);\n      const html = this.props.onAddHTML(div);\n      if (html) {\n        div.innerHTML = html;\n      }\n    }\n  }\n\n  _getSizeAndAspect(): {width: number; height: number; aspect: number} {\n    if (!this.device) {\n      return {width: 1, height: 1, aspect: 1};\n    }\n    // https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n    const [width, height] = this.device?.canvasContext?.getPixelSize() || [1, 1];\n\n    // https://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html\n    let aspect = 1;\n    const canvas = this.device?.canvasContext?.canvas;\n\n    // @ts-expect-error\n    if (canvas && canvas.clientHeight) {\n      // @ts-expect-error\n      aspect = canvas.clientWidth / canvas.clientHeight;\n    } else if (width > 0 && height > 0) {\n      aspect = width / height;\n    }\n\n    return {width, height, aspect};\n  }\n\n  /** Default viewport setup */\n  _resizeViewport(): void {\n    // TODO can we use canvas context to code this in a portable way?\n    // @ts-expect-error Expose on canvasContext\n    if (this.props.autoResizeViewport && this.device.gl) {\n      // @ts-expect-error Expose canvasContext\n      this.device.gl.viewport(\n        0,\n        0,\n        // @ts-expect-error Expose canvasContext\n        this.device.gl.drawingBufferWidth,\n        // @ts-expect-error Expose canvasContext\n        this.device.gl.drawingBufferHeight\n      );\n    }\n  }\n\n  /**\n   * Resize the render buffer of the canvas to match canvas client size\n   * Optionally multiplying with devicePixel ratio\n   */\n  _resizeCanvasDrawingBuffer(): void {\n    if (this.props.autoResizeDrawingBuffer) {\n      this.device?.canvasContext?.resize({useDevicePixels: this.props.useDevicePixels});\n    }\n  }\n\n  _beginFrameTimers() {\n    this.frameRate.timeEnd();\n    this.frameRate.timeStart();\n\n    // Check if timer for last frame has completed.\n    // GPU timer results are never available in the same\n    // frame they are captured.\n    // if (\n    //   this._gpuTimeQuery &&\n    //   this._gpuTimeQuery.isResultAvailable() &&\n    //   !this._gpuTimeQuery.isTimerDisjoint()\n    // ) {\n    //   this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());\n    // }\n\n    // if (this._gpuTimeQuery) {\n    //   // GPU time query start\n    //   this._gpuTimeQuery.beginTimeElapsedQuery();\n    // }\n\n    this.cpuTime.timeStart();\n  }\n\n  _endFrameTimers() {\n    this.cpuTime.timeEnd();\n\n    // if (this._gpuTimeQuery) {\n    //   // GPU time query end. Results will be available on next frame.\n    //   this._gpuTimeQuery.end();\n    // }\n  }\n\n  // Event handling\n\n  _startEventHandling() {\n    if (this.canvas) {\n      this.canvas.addEventListener('mousemove', this._onMousemove.bind(this));\n      this.canvas.addEventListener('mouseleave', this._onMouseleave.bind(this));\n    }\n  }\n\n  _onMousemove(event: Event) {\n    if (event instanceof MouseEvent) {\n      this._getAnimationProps()._mousePosition = [event.offsetX, event.offsetY];\n    }\n  }\n\n  _onMouseleave(event: Event) {\n    this._getAnimationProps()._mousePosition = null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}