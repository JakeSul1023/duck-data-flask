{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { Vector3 } from '@math.gl/core';\nimport { GL } from '@loaders.gl/math';\n// Prepare attribute for positions\nexport function normalize3DTilePositionAttribute(tile, positions, options) {\n  if (!tile.isQuantized) {\n    return positions;\n  }\n  // For quantized posititions, either expand to Float32Array or return custom accessor\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/TileFormats/Instanced3DModel/README.md#quantized-positions\n  // Optionally decodes quantized positions on GPU, for simpler renderers that don't accept normalized attributes\n  if (options['3d-tiles'] && options['3d-tiles'].decodeQuantizedPositions) {\n    tile.isQuantized = false;\n    return decodeQuantizedPositions(tile, positions);\n  }\n  // Default: Use normalized shorts directly, no copying/processing.\n  // NOTE: The \"missing\" offset/scaling operations are automatically added to modelMatrix if `tile.isQuantized === true`\n  return {\n    type: GL.UNSIGNED_SHORT,\n    value: positions,\n    size: 3,\n    normalized: true\n  };\n}\n// Pre-scale quantized positions on CPU\nfunction decodeQuantizedPositions(tile, positions) {\n  const scratchPosition = new Vector3();\n  const decodedArray = new Float32Array(tile.pointCount * 3);\n  for (let i = 0; i < tile.pointCount; i++) {\n    // POSITION = POSITION_QUANTIZED / 65535.0 * QUANTIZED_VOLUME_SCALE + QUANTIZED_VOLUME_OFFSET\n    scratchPosition.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]).scale(1 / tile.quantizedRange).multiply(tile.quantizedVolumeScale).add(tile.quantizedVolumeOffset).toArray(decodedArray, i * 3);\n  }\n  return decodedArray;\n}","map":{"version":3,"names":["Vector3","GL","normalize3DTilePositionAttribute","tile","positions","options","isQuantized","decodeQuantizedPositions","type","UNSIGNED_SHORT","value","size","normalized","scratchPosition","decodedArray","Float32Array","pointCount","i","set","scale","quantizedRange","multiply","quantizedVolumeScale","add","quantizedVolumeOffset","toArray"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/normalize-3d-tile-positions.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { Vector3 } from '@math.gl/core';\nimport { GL } from '@loaders.gl/math';\n// Prepare attribute for positions\nexport function normalize3DTilePositionAttribute(tile, positions, options) {\n    if (!tile.isQuantized) {\n        return positions;\n    }\n    // For quantized posititions, either expand to Float32Array or return custom accessor\n    // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/TileFormats/Instanced3DModel/README.md#quantized-positions\n    // Optionally decodes quantized positions on GPU, for simpler renderers that don't accept normalized attributes\n    if (options['3d-tiles'] && options['3d-tiles'].decodeQuantizedPositions) {\n        tile.isQuantized = false;\n        return decodeQuantizedPositions(tile, positions);\n    }\n    // Default: Use normalized shorts directly, no copying/processing.\n    // NOTE: The \"missing\" offset/scaling operations are automatically added to modelMatrix if `tile.isQuantized === true`\n    return {\n        type: GL.UNSIGNED_SHORT,\n        value: positions,\n        size: 3,\n        normalized: true\n    };\n}\n// Pre-scale quantized positions on CPU\nfunction decodeQuantizedPositions(tile, positions) {\n    const scratchPosition = new Vector3();\n    const decodedArray = new Float32Array(tile.pointCount * 3);\n    for (let i = 0; i < tile.pointCount; i++) {\n        // POSITION = POSITION_QUANTIZED / 65535.0 * QUANTIZED_VOLUME_SCALE + QUANTIZED_VOLUME_OFFSET\n        scratchPosition\n            .set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2])\n            .scale(1 / tile.quantizedRange)\n            .multiply(tile.quantizedVolumeScale)\n            .add(tile.quantizedVolumeOffset)\n            .toArray(decodedArray, i * 3);\n    }\n    return decodedArray;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,OAAO,QAAQ,eAAe;AACvC,SAASC,EAAE,QAAQ,kBAAkB;AACrC;AACA,OAAO,SAASC,gCAAgCA,CAACC,IAAI,EAAEC,SAAS,EAAEC,OAAO,EAAE;EACvE,IAAI,CAACF,IAAI,CAACG,WAAW,EAAE;IACnB,OAAOF,SAAS;EACpB;EACA;EACA;EACA;EACA,IAAIC,OAAO,CAAC,UAAU,CAAC,IAAIA,OAAO,CAAC,UAAU,CAAC,CAACE,wBAAwB,EAAE;IACrEJ,IAAI,CAACG,WAAW,GAAG,KAAK;IACxB,OAAOC,wBAAwB,CAACJ,IAAI,EAAEC,SAAS,CAAC;EACpD;EACA;EACA;EACA,OAAO;IACHI,IAAI,EAAEP,EAAE,CAACQ,cAAc;IACvBC,KAAK,EAAEN,SAAS;IAChBO,IAAI,EAAE,CAAC;IACPC,UAAU,EAAE;EAChB,CAAC;AACL;AACA;AACA,SAASL,wBAAwBA,CAACJ,IAAI,EAAEC,SAAS,EAAE;EAC/C,MAAMS,eAAe,GAAG,IAAIb,OAAO,CAAC,CAAC;EACrC,MAAMc,YAAY,GAAG,IAAIC,YAAY,CAACZ,IAAI,CAACa,UAAU,GAAG,CAAC,CAAC;EAC1D,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,IAAI,CAACa,UAAU,EAAEC,CAAC,EAAE,EAAE;IACtC;IACAJ,eAAe,CACVK,GAAG,CAACd,SAAS,CAACa,CAAC,GAAG,CAAC,CAAC,EAAEb,SAAS,CAACa,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEb,SAAS,CAACa,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CACjEE,KAAK,CAAC,CAAC,GAAGhB,IAAI,CAACiB,cAAc,CAAC,CAC9BC,QAAQ,CAAClB,IAAI,CAACmB,oBAAoB,CAAC,CACnCC,GAAG,CAACpB,IAAI,CAACqB,qBAAqB,CAAC,CAC/BC,OAAO,CAACX,YAAY,EAAEG,CAAC,GAAG,CAAC,CAAC;EACrC;EACA,OAAOH,YAAY;AACvB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}