{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Buffer } from \"../adapter/resources/buffer.js\";\nimport { log } from \"../utils/log.js\";\nimport { UniformBlock } from \"./uniform-block.js\";\nimport { UniformBufferLayout } from \"./uniform-buffer-layout.js\";\n/**\n * A uniform store holds a uniform values for one or more uniform blocks,\n * - It can generate binary data for any uniform buffer\n * - It can manage a uniform buffer for each block\n * - It can update managed uniform buffers with a single call\n * - It performs some book keeping on what has changed to minimize unnecessary writes to uniform buffers.\n */\nexport class UniformStore {\n  /** Stores the uniform values for each uniform block */\n  uniformBlocks = (() => new Map())();\n  /** Can generate data for a uniform buffer for each block from data */\n  uniformBufferLayouts = (() => new Map())();\n  /** Actual buffer for the blocks */\n  uniformBuffers = (() => new Map())();\n  /**\n   * Create a new UniformStore instance\n   * @param blocks\n   */\n  constructor(blocks) {\n    for (const [bufferName, block] of Object.entries(blocks)) {\n      const uniformBufferName = bufferName;\n      // Create a layout object to help us generate correctly formatted binary uniform buffers\n      const uniformBufferLayout = new UniformBufferLayout(block.uniformTypes || {});\n      this.uniformBufferLayouts.set(uniformBufferName, uniformBufferLayout);\n      // Create a Uniform block to store the uniforms for each buffer.\n      const uniformBlock = new UniformBlock({\n        name: bufferName\n      });\n      uniformBlock.setUniforms(block.defaultUniforms || {});\n      this.uniformBlocks.set(uniformBufferName, uniformBlock);\n    }\n  }\n  /** Destroy any managed uniform buffers */\n  destroy() {\n    for (const uniformBuffer of this.uniformBuffers.values()) {\n      uniformBuffer.destroy();\n    }\n  }\n  /**\n   * Set uniforms\n   * Makes all properties partial\n   */\n  setUniforms(uniforms) {\n    for (const [blockName, uniformValues] of Object.entries(uniforms)) {\n      this.uniformBlocks.get(blockName)?.setUniforms(uniformValues);\n      // We leverage logging in updateUniformBuffers(), even though slightly less efficient\n      // this.updateUniformBuffer(blockName);\n    }\n    this.updateUniformBuffers();\n  }\n  /** Get the required minimum length of the uniform buffer */\n  getUniformBufferByteLength(uniformBufferName) {\n    return this.uniformBufferLayouts.get(uniformBufferName)?.byteLength || 0;\n  }\n  /** Get formatted binary memory that can be uploaded to a buffer */\n  getUniformBufferData(uniformBufferName) {\n    const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms() || {};\n    // @ts-ignore\n    return this.uniformBufferLayouts.get(uniformBufferName)?.getData(uniformValues);\n  }\n  /**\n   * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)\n   * The new buffer is initialized with current / supplied values\n   */\n  createUniformBuffer(device, uniformBufferName, uniforms) {\n    if (uniforms) {\n      this.setUniforms(uniforms);\n    }\n    const byteLength = this.getUniformBufferByteLength(uniformBufferName);\n    const uniformBuffer = device.createBuffer({\n      usage: Buffer.UNIFORM | Buffer.COPY_DST,\n      byteLength\n    });\n    // Note that this clears the needs redraw flag\n    const uniformBufferData = this.getUniformBufferData(uniformBufferName);\n    uniformBuffer.write(uniformBufferData);\n    return uniformBuffer;\n  }\n  /** Get the managed uniform buffer. \"managed\" resources are destroyed when the uniformStore is destroyed. */\n  getManagedUniformBuffer(device, uniformBufferName) {\n    if (!this.uniformBuffers.get(uniformBufferName)) {\n      const byteLength = this.getUniformBufferByteLength(uniformBufferName);\n      const uniformBuffer = device.createBuffer({\n        usage: Buffer.UNIFORM | Buffer.COPY_DST,\n        byteLength\n      });\n      this.uniformBuffers.set(uniformBufferName, uniformBuffer);\n    }\n    // this.updateUniformBuffers();\n    // @ts-ignore\n    return this.uniformBuffers.get(uniformBufferName);\n  }\n  /** Updates all uniform buffers where values have changed */\n  updateUniformBuffers() {\n    let reason = false;\n    for (const uniformBufferName of this.uniformBlocks.keys()) {\n      const bufferReason = this.updateUniformBuffer(uniformBufferName);\n      reason ||= bufferReason;\n    }\n    if (reason) {\n      log.log(3, `UniformStore.updateUniformBuffers(): ${reason}`)();\n    }\n    return reason;\n  }\n  /** Update one uniform buffer. Only updates if values have changed */\n  updateUniformBuffer(uniformBufferName) {\n    const uniformBlock = this.uniformBlocks.get(uniformBufferName);\n    let uniformBuffer = this.uniformBuffers.get(uniformBufferName);\n    let reason = false;\n    if (uniformBuffer && uniformBlock?.needsRedraw) {\n      reason ||= uniformBlock.needsRedraw;\n      // This clears the needs redraw flag\n      const uniformBufferData = this.getUniformBufferData(uniformBufferName);\n      uniformBuffer = this.uniformBuffers.get(uniformBufferName);\n      uniformBuffer?.write(uniformBufferData);\n      // logging - TODO - don't query the values unnecessarily\n      const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms();\n      log.log(4, `Writing to uniform buffer ${String(uniformBufferName)}`, uniformBufferData, uniformValues)();\n    }\n    return reason;\n  }\n}\n//# sourceMappingURL=uniform-store.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}