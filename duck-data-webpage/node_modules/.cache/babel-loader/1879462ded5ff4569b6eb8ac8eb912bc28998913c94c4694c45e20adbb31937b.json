{"ast":null,"code":"import { getJSModule, registerJSModules } from '@loaders.gl/loader-utils';\nimport { Hash } from \"./hash.js\";\n/**\n * A transform that calculates Cryptographic Hash using Crypto JS library\n * @deprecated Warning, experimental class\n */\nexport class CryptoHash extends Hash {\n  name;\n  options;\n  /** Name of digest algorithm */\n  _algorithm;\n  /** CryptoJS algorithm */\n  _algo;\n  constructor(options) {\n    super();\n    this.options = options;\n    registerJSModules(options?.modules);\n    this._algorithm = this.options?.crypto?.algorithm;\n    if (!this._algorithm) {\n      throw new Error(this.name);\n    }\n    this.name = this._algorithm.toLowerCase();\n  }\n  async preload() {\n    const CryptoJS = getJSModule('CryptoJS', this.name);\n    this._algo = CryptoJS.algo[this._algorithm];\n  }\n  /**\n   * Atomic hash calculation\n   * @returns base64 encoded hash\n   */\n  async hash(input, encoding) {\n    await this.preload();\n    const hash = this._algo.create();\n    if (!hash) {\n      throw new Error(this.name);\n    }\n    const CryptoJS = getJSModule('CryptoJS', this.name);\n    // arrayBuffer is accepted, even though types and docs say no\n    // https://stackoverflow.com/questions/25567468/how-to-decrypt-an-arraybuffer\n    const typedWordArray = CryptoJS.lib.WordArray.create(input);\n    // Map our encoding constant to Crypto library\n    const enc = encoding === 'base64' ? CryptoJS.enc.Base64 : CryptoJS.enc.Hex;\n    return hash.update(typedWordArray).finalize().toString(enc);\n  }\n  hashBatches(asyncIterator) {\n    try {\n      var _this = this;\n      let encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'base64';\n      return async function* () {\n        await _this.preload();\n        const CryptoJS = getJSModule('CryptoJS', _this.name);\n        const hash = _this._algo.create();\n        if (!hash) {\n          throw new Error(_this.name);\n        }\n        for await (const chunk of asyncIterator) {\n          // arrayBuffer is accepted, even though types and docs say no\n          // https://stackoverflow.com/questions/25567468/how-to-decrypt-an-arraybuffer\n          const typedWordArray = CryptoJS.lib.WordArray.create(chunk);\n          hash.update(typedWordArray);\n          yield chunk;\n        }\n        // Map our encoding constant to Crypto library\n        const enc = encoding === 'base64' ? CryptoJS.enc.Base64 : CryptoJS.enc.Hex;\n        const digest = hash.finalize().toString(enc);\n        _this.options?.crypto?.onEnd?.({\n          hash: digest\n        });\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}