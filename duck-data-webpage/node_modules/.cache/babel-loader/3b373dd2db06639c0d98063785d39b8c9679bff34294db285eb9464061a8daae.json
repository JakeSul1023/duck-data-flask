{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isTable, makeBatchFromTable } from '@loaders.gl/schema';\nimport { concatenateArrayBuffersAsync } from '@loaders.gl/loader-utils';\nimport { isLoaderObject } from \"../loader-utils/normalize-loader.js\";\nimport { normalizeOptions } from \"../loader-utils/option-utils.js\";\nimport { getLoaderContext } from \"../loader-utils/loader-context.js\";\nimport { getAsyncIterableFromData } from \"../loader-utils/get-data.js\";\nimport { getResourceUrl } from \"../utils/resource-utils.js\";\nimport { selectLoader } from \"./select-loader.js\";\n// Ensure `parse` is available in context if loader falls back to `parse`\nimport { parse } from \"./parse.js\";\n/**\n * Parses `data` using a specified loader\n * @param data\n * @param loaders\n * @param options\n * @param context\n */\nexport async function parseInBatches(data, loaders, options, context) {\n  const loaderArray = Array.isArray(loaders) ? loaders : undefined;\n  // Signature: parseInBatches(data, options, url) - Uses registered loaders\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined; // context not supported in short signature\n    options = loaders;\n    loaders = undefined;\n  }\n  data = await data; // Resolve any promise\n  options = options || {};\n  // Extract a url for auto detection\n  const url = getResourceUrl(data);\n  // Chooses a loader and normalizes it\n  // Note - only uses URL and contentType for streams and iterator inputs\n  const loader = await selectLoader(data, loaders, options);\n  // Note: if options.nothrow was set, it is possible that no loader was found, if so just return null\n  if (!loader) {\n    return [];\n  }\n  // Normalize options\n  options = normalizeOptions(options, loader, loaderArray, url);\n  context = getLoaderContext({\n    url,\n    _parseInBatches: parseInBatches,\n    _parse: parse,\n    loaders: loaderArray\n  }, options, context || null);\n  return await parseWithLoaderInBatches(loader, data, options, context);\n}\n/**\n * Loader has been selected and context has been prepared, see if we need to emit a metadata batch\n */\nasync function parseWithLoaderInBatches(loader, data, options, context) {\n  const outputIterator = await parseToOutputIterator(loader, data, options, context);\n  // Generate metadata batch if requested\n  if (!options.metadata) {\n    return outputIterator;\n  }\n  const metadataBatch = {\n    shape: 'metadata',\n    batchType: 'metadata',\n    metadata: {\n      _loader: loader,\n      _context: context\n    },\n    // Populate with some default fields to avoid crashing\n    data: [],\n    bytesUsed: 0\n  };\n  async function* makeMetadataBatchIterator(iterator) {\n    yield metadataBatch;\n    yield* iterator;\n  }\n  return makeMetadataBatchIterator(outputIterator);\n}\n/**\n * Prep work is done, now it is time to start parsing into an output operator\n * The approach depends on which parse function the loader exposes\n * `parseInBatches` (preferred), `parse` (fallback)\n */\nasync function parseToOutputIterator(loader, data, options, context) {\n  // Get an iterator from the input\n  const inputIterator = await getAsyncIterableFromData(data, options);\n  // Apply any iterator transforms (options.transforms)\n  const transformedIterator = await applyInputTransforms(inputIterator, options?.transforms || []);\n  // If loader supports parseInBatches, we are done\n  if (loader.parseInBatches) {\n    return loader.parseInBatches(transformedIterator, options, context);\n  }\n  return parseChunkInBatches(transformedIterator, loader, options, context);\n}\n// Fallback: load atomically using `parse` concatenating input iterator into single chunk\nasync function* parseChunkInBatches(transformedIterator, loader, options, context) {\n  const arrayBuffer = await concatenateArrayBuffersAsync(transformedIterator);\n  // Call `parse` instead of `loader.parse` to ensure we can call workers etc.\n  const parsedData = await parse(arrayBuffer, loader,\n  // TODO - Hack: supply loaders MIME type to ensure we match it\n  {\n    ...options,\n    mimeType: loader.mimeTypes[0]\n  }, context);\n  // yield a single batch, the output from loader.parse() repackaged as a batch\n  const batch = convertDataToBatch(parsedData, loader);\n  yield batch;\n}\n/**\n * Convert parsed data into a single batch\n * @todo run through batch builder to apply options etc...\n */\nfunction convertDataToBatch(parsedData, loader) {\n  // prettier-ignore\n  const batch = isTable(parsedData) ? makeBatchFromTable(parsedData) : {\n    shape: 'unknown',\n    batchType: 'data',\n    data: parsedData,\n    length: Array.isArray(parsedData) ? parsedData.length : 1\n  };\n  batch.mimeType = loader.mimeTypes[0];\n  return batch;\n}\n/**\n * Create an iterator chain with any transform iterators (crypto, decompression)\n * @param inputIterator\n * @param options\n */\nasync function applyInputTransforms(inputIterator, transforms = []) {\n  let iteratorChain = inputIterator;\n  for await (const transformBatches of transforms) {\n    iteratorChain = transformBatches(iteratorChain);\n  }\n  return iteratorChain;\n}","map":{"version":3,"names":["isTable","makeBatchFromTable","concatenateArrayBuffersAsync","isLoaderObject","normalizeOptions","getLoaderContext","getAsyncIterableFromData","getResourceUrl","selectLoader","parse","parseInBatches","data","loaders","options","context","loaderArray","Array","isArray","undefined","url","loader","_parseInBatches","_parse","parseWithLoaderInBatches","outputIterator","parseToOutputIterator","metadata","metadataBatch","shape","batchType","_loader","_context","bytesUsed","makeMetadataBatchIterator","iterator","inputIterator","transformedIterator","applyInputTransforms","transforms","parseChunkInBatches","arrayBuffer","parsedData","mimeType","mimeTypes","batch","convertDataToBatch","length","iteratorChain","transformBatches"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/core/dist/lib/api/parse-in-batches.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isTable, makeBatchFromTable } from '@loaders.gl/schema';\nimport { concatenateArrayBuffersAsync } from '@loaders.gl/loader-utils';\nimport { isLoaderObject } from \"../loader-utils/normalize-loader.js\";\nimport { normalizeOptions } from \"../loader-utils/option-utils.js\";\nimport { getLoaderContext } from \"../loader-utils/loader-context.js\";\nimport { getAsyncIterableFromData } from \"../loader-utils/get-data.js\";\nimport { getResourceUrl } from \"../utils/resource-utils.js\";\nimport { selectLoader } from \"./select-loader.js\";\n// Ensure `parse` is available in context if loader falls back to `parse`\nimport { parse } from \"./parse.js\";\n/**\n * Parses `data` using a specified loader\n * @param data\n * @param loaders\n * @param options\n * @param context\n */\nexport async function parseInBatches(data, loaders, options, context) {\n    const loaderArray = Array.isArray(loaders) ? loaders : undefined;\n    // Signature: parseInBatches(data, options, url) - Uses registered loaders\n    if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n        context = undefined; // context not supported in short signature\n        options = loaders;\n        loaders = undefined;\n    }\n    data = await data; // Resolve any promise\n    options = options || {};\n    // Extract a url for auto detection\n    const url = getResourceUrl(data);\n    // Chooses a loader and normalizes it\n    // Note - only uses URL and contentType for streams and iterator inputs\n    const loader = await selectLoader(data, loaders, options);\n    // Note: if options.nothrow was set, it is possible that no loader was found, if so just return null\n    if (!loader) {\n        return [];\n    }\n    // Normalize options\n    options = normalizeOptions(options, loader, loaderArray, url);\n    context = getLoaderContext({ url, _parseInBatches: parseInBatches, _parse: parse, loaders: loaderArray }, options, context || null);\n    return await parseWithLoaderInBatches(loader, data, options, context);\n}\n/**\n * Loader has been selected and context has been prepared, see if we need to emit a metadata batch\n */\nasync function parseWithLoaderInBatches(loader, data, options, context) {\n    const outputIterator = await parseToOutputIterator(loader, data, options, context);\n    // Generate metadata batch if requested\n    if (!options.metadata) {\n        return outputIterator;\n    }\n    const metadataBatch = {\n        shape: 'metadata',\n        batchType: 'metadata',\n        metadata: {\n            _loader: loader,\n            _context: context\n        },\n        // Populate with some default fields to avoid crashing\n        data: [],\n        bytesUsed: 0\n    };\n    async function* makeMetadataBatchIterator(iterator) {\n        yield metadataBatch;\n        yield* iterator;\n    }\n    return makeMetadataBatchIterator(outputIterator);\n}\n/**\n * Prep work is done, now it is time to start parsing into an output operator\n * The approach depends on which parse function the loader exposes\n * `parseInBatches` (preferred), `parse` (fallback)\n */\nasync function parseToOutputIterator(loader, data, options, context) {\n    // Get an iterator from the input\n    const inputIterator = await getAsyncIterableFromData(data, options);\n    // Apply any iterator transforms (options.transforms)\n    const transformedIterator = await applyInputTransforms(inputIterator, options?.transforms || []);\n    // If loader supports parseInBatches, we are done\n    if (loader.parseInBatches) {\n        return loader.parseInBatches(transformedIterator, options, context);\n    }\n    return parseChunkInBatches(transformedIterator, loader, options, context);\n}\n// Fallback: load atomically using `parse` concatenating input iterator into single chunk\nasync function* parseChunkInBatches(transformedIterator, loader, options, context) {\n    const arrayBuffer = await concatenateArrayBuffersAsync(transformedIterator);\n    // Call `parse` instead of `loader.parse` to ensure we can call workers etc.\n    const parsedData = await parse(arrayBuffer, loader, \n    // TODO - Hack: supply loaders MIME type to ensure we match it\n    { ...options, mimeType: loader.mimeTypes[0] }, context);\n    // yield a single batch, the output from loader.parse() repackaged as a batch\n    const batch = convertDataToBatch(parsedData, loader);\n    yield batch;\n}\n/**\n * Convert parsed data into a single batch\n * @todo run through batch builder to apply options etc...\n */\nfunction convertDataToBatch(parsedData, loader) {\n    // prettier-ignore\n    const batch = isTable(parsedData)\n        ? makeBatchFromTable(parsedData)\n        : {\n            shape: 'unknown',\n            batchType: 'data',\n            data: parsedData,\n            length: Array.isArray(parsedData) ? parsedData.length : 1\n        };\n    batch.mimeType = loader.mimeTypes[0];\n    return batch;\n}\n/**\n * Create an iterator chain with any transform iterators (crypto, decompression)\n * @param inputIterator\n * @param options\n */\nasync function applyInputTransforms(inputIterator, transforms = []) {\n    let iteratorChain = inputIterator;\n    for await (const transformBatches of transforms) {\n        iteratorChain = transformBatches(iteratorChain);\n    }\n    return iteratorChain;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}