{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { LayerExtension } from '@deck.gl/core';\nconst defaultProps = {\n  clipBounds: [0, 0, 1, 1],\n  clipByInstance: undefined\n};\nconst shaderFunction = /* glsl */`\nuniform clipUniforms {\n  vec4 bounds;\n} clip;\n\nbool clip_isInBounds(vec2 position) {\n  return position.x >= clip.bounds[0] && position.y >= clip.bounds[1] && position.x < clip.bounds[2] && position.y < clip.bounds[3];\n}\n`;\n/*\n * The vertex-shader version clips geometries by their anchor position\n * e.g. ScatterplotLayer - show if the center of a circle is within bounds\n */\nconst shaderModuleVs = {\n  name: 'clip',\n  vs: shaderFunction,\n  uniformTypes: {\n    bounds: 'vec4<f32>'\n  }\n};\nconst injectionVs = {\n  'vs:#decl': /* glsl */`\nout float clip_isVisible;\n`,\n  'vs:DECKGL_FILTER_GL_POSITION': /* glsl */`\n  clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));\n`,\n  'fs:#decl': /* glsl */`\nin float clip_isVisible;\n`,\n  'fs:DECKGL_FILTER_COLOR': /* glsl */`\n  if (clip_isVisible < 0.5) discard;\n`\n};\n/*\n * The fragment-shader version clips pixels at the bounds\n * e.g. PolygonLayer - show the part of the polygon that intersect with the bounds\n */\nconst shaderModuleFs = {\n  name: 'clip',\n  fs: shaderFunction,\n  uniformTypes: {\n    bounds: 'vec4<f32>'\n  }\n};\nconst injectionFs = {\n  'vs:#decl': /* glsl */`\nout vec2 clip_commonPosition;\n`,\n  'vs:DECKGL_FILTER_GL_POSITION': /* glsl */`\n  clip_commonPosition = geometry.position.xy;\n`,\n  'fs:#decl': /* glsl */`\nin vec2 clip_commonPosition;\n`,\n  'fs:DECKGL_FILTER_COLOR': /* glsl */`\n  if (!clip_isInBounds(clip_commonPosition)) discard;\n`\n};\n/** Adds support for clipping rendered layers by rectangular bounds. */\nclass ClipExtension extends LayerExtension {\n  getShaders() {\n    // If `clipByInstance: true`, the entire object is shown/hidden based on its anchor position (done by vertex shader)\n    // Otherwise, the object is trimmed by the clip bounds (done by fragment shader)\n    // Default behavior: consider a layer instanced if it has attribute `instancePositions`\n    let clipByInstance = 'instancePositions' in this.getAttributeManager().attributes;\n    // Users can override by setting the `clipByInstance` prop\n    if (this.props.clipByInstance !== undefined) {\n      clipByInstance = Boolean(this.props.clipByInstance);\n    }\n    this.state.clipByInstance = clipByInstance;\n    return clipByInstance ? {\n      modules: [shaderModuleVs],\n      inject: injectionVs\n    } : {\n      modules: [shaderModuleFs],\n      inject: injectionFs\n    };\n  }\n  /* eslint-disable camelcase */\n  draw() {\n    const {\n      clipBounds\n    } = this.props;\n    const clipProps = {};\n    if (this.state.clipByInstance) {\n      clipProps.bounds = clipBounds;\n    } else {\n      const corner0 = this.projectPosition([clipBounds[0], clipBounds[1], 0]);\n      const corner1 = this.projectPosition([clipBounds[2], clipBounds[3], 0]);\n      clipProps.bounds = [Math.min(corner0[0], corner1[0]), Math.min(corner0[1], corner1[1]), Math.max(corner0[0], corner1[0]), Math.max(corner0[1], corner1[1])];\n    }\n    this.setShaderModuleProps({\n      clip: clipProps\n    });\n  }\n}\nClipExtension.defaultProps = defaultProps;\nClipExtension.extensionName = 'ClipExtension';\nexport default ClipExtension;","map":{"version":3,"names":["LayerExtension","defaultProps","clipBounds","clipByInstance","undefined","shaderFunction","shaderModuleVs","name","vs","uniformTypes","bounds","injectionVs","shaderModuleFs","fs","injectionFs","ClipExtension","getShaders","getAttributeManager","attributes","props","Boolean","state","modules","inject","draw","clipProps","corner0","projectPosition","corner1","Math","min","max","setShaderModuleProps","clip","extensionName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\extensions\\src\\clip\\clip-extension.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\nimport {LayerExtension} from '@deck.gl/core';\n\nimport type {Layer} from '@deck.gl/core';\n\nconst defaultProps = {\n  clipBounds: [0, 0, 1, 1],\n  clipByInstance: undefined\n};\n\nexport type ClipExtensionProps = {\n  /** Rectangular bounds to be used for clipping the rendered region, in `[left, bottom, right, top]`.\n   * @default [0, 0, 1, 1]\n   */\n  clipBounds?: [number, number, number, number];\n  /**\n   * Controls whether an object is clipped by its anchor (e.g. icon, point) or by its geometry (e.g. path, polygon).\n   * If not specified, it is automatically deduced from the layer.\n   */\n  clipByInstance?: boolean;\n};\n\nconst shaderFunction = /* glsl */ `\nuniform clipUniforms {\n  vec4 bounds;\n} clip;\n\nbool clip_isInBounds(vec2 position) {\n  return position.x >= clip.bounds[0] && position.y >= clip.bounds[1] && position.x < clip.bounds[2] && position.y < clip.bounds[3];\n}\n`;\n\nexport type ClipModuleProps = {\n  bounds: [number, number, number, number];\n};\n\n/*\n * The vertex-shader version clips geometries by their anchor position\n * e.g. ScatterplotLayer - show if the center of a circle is within bounds\n */\nconst shaderModuleVs: ShaderModule<ClipModuleProps> = {\n  name: 'clip',\n  vs: shaderFunction,\n  uniformTypes: {\n    bounds: 'vec4<f32>'\n  }\n};\n\nconst injectionVs = {\n  'vs:#decl': /* glsl */ `\nout float clip_isVisible;\n`,\n  'vs:DECKGL_FILTER_GL_POSITION': /* glsl */ `\n  clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));\n`,\n  'fs:#decl': /* glsl */ `\nin float clip_isVisible;\n`,\n  'fs:DECKGL_FILTER_COLOR': /* glsl */ `\n  if (clip_isVisible < 0.5) discard;\n`\n};\n\n/*\n * The fragment-shader version clips pixels at the bounds\n * e.g. PolygonLayer - show the part of the polygon that intersect with the bounds\n */\nconst shaderModuleFs: ShaderModule<ClipModuleProps> = {\n  name: 'clip',\n  fs: shaderFunction,\n  uniformTypes: {\n    bounds: 'vec4<f32>'\n  }\n};\n\nconst injectionFs = {\n  'vs:#decl': /* glsl */ `\nout vec2 clip_commonPosition;\n`,\n  'vs:DECKGL_FILTER_GL_POSITION': /* glsl */ `\n  clip_commonPosition = geometry.position.xy;\n`,\n  'fs:#decl': /* glsl */ `\nin vec2 clip_commonPosition;\n`,\n  'fs:DECKGL_FILTER_COLOR': /* glsl */ `\n  if (!clip_isInBounds(clip_commonPosition)) discard;\n`\n};\n\n/** Adds support for clipping rendered layers by rectangular bounds. */\nexport default class ClipExtension extends LayerExtension {\n  static defaultProps = defaultProps;\n  static extensionName = 'ClipExtension';\n\n  getShaders(this: Layer<ClipExtensionProps>) {\n    // If `clipByInstance: true`, the entire object is shown/hidden based on its anchor position (done by vertex shader)\n    // Otherwise, the object is trimmed by the clip bounds (done by fragment shader)\n\n    // Default behavior: consider a layer instanced if it has attribute `instancePositions`\n    let clipByInstance = 'instancePositions' in this.getAttributeManager()!.attributes;\n    // Users can override by setting the `clipByInstance` prop\n    if (this.props.clipByInstance !== undefined) {\n      clipByInstance = Boolean(this.props.clipByInstance);\n    }\n    this.state.clipByInstance = clipByInstance;\n\n    return clipByInstance\n      ? {\n          modules: [shaderModuleVs],\n          inject: injectionVs\n        }\n      : {\n          modules: [shaderModuleFs],\n          inject: injectionFs\n        };\n  }\n\n  /* eslint-disable camelcase */\n  draw(this: Layer<Required<ClipExtensionProps>>): void {\n    const {clipBounds} = this.props;\n    const clipProps = {} as ClipModuleProps;\n    if (this.state.clipByInstance) {\n      clipProps.bounds = clipBounds;\n    } else {\n      const corner0 = this.projectPosition([clipBounds[0], clipBounds[1], 0]);\n      const corner1 = this.projectPosition([clipBounds[2], clipBounds[3], 0]);\n\n      clipProps.bounds = [\n        Math.min(corner0[0], corner1[0]),\n        Math.min(corner0[1], corner1[1]),\n        Math.max(corner0[0], corner1[0]),\n        Math.max(corner0[1], corner1[1])\n      ];\n    }\n\n    this.setShaderModuleProps({clip: clipProps});\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}