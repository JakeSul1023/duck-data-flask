{"ast":null,"code":"/* eslint-disable indent */\nimport { earcut } from '@math.gl/polygon';\n/**\n * Convert binary features to flat binary arrays. Similar to\n * `geojsonToBinary` helper function, except that it expects\n * a binary representation of the feature data, which enables\n * 2X-3X speed increase in parse speed, compared to using\n * geoJSON. See `binary-vector-tile/VectorTileFeature` for\n * data format detais\n *\n * @param features\n * @param geometryInfo\n * @param options\n * @returns filled arrays\n */\nexport function flatGeojsonToBinary(features, geometryInfo, options) {\n  const propArrayTypes = extractNumericPropTypes(features);\n  const numericPropKeys = Object.keys(propArrayTypes).filter(k => propArrayTypes[k] !== Array);\n  return fillArrays(features, {\n    propArrayTypes,\n    ...geometryInfo\n  }, {\n    numericPropKeys: options && options.numericPropKeys || numericPropKeys,\n    PositionDataType: options ? options.PositionDataType : Float32Array,\n    triangulate: options ? options.triangulate : true\n  });\n}\nexport const TEST_EXPORTS = {\n  extractNumericPropTypes\n};\n/**\n * Extracts properties that are always numeric\n *\n * @param features\n * @returns object with numeric types\n */\nfunction extractNumericPropTypes(features) {\n  const propArrayTypes = {};\n  for (const feature of features) {\n    if (feature.properties) {\n      for (const key in feature.properties) {\n        // If property has not been seen before, or if property has been numeric\n        // in all previous features, check if numeric in this feature\n        // If not numeric, Array is stored to prevent rechecking in the future\n        // Additionally, detects if 64 bit precision is required\n        const val = feature.properties[key];\n        propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);\n      }\n    }\n  }\n  return propArrayTypes;\n}\n/**\n * Fills coordinates into pre-allocated typed arrays\n *\n * @param features\n * @param geometryInfo\n * @param options\n * @returns an accessor object with value and size keys\n */\n// eslint-disable-next-line complexity, max-statements\nfunction fillArrays(features, geometryInfo, options) {\n  const {\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    polygonFeaturesCount,\n    propArrayTypes,\n    coordLength\n  } = geometryInfo;\n  const {\n    numericPropKeys = [],\n    PositionDataType = Float32Array,\n    triangulate = true\n  } = options;\n  const hasGlobalId = features[0] && 'id' in features[0];\n  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n  const points = {\n    type: 'Point',\n    positions: new PositionDataType(pointPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n    featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const lines = {\n    type: 'LineString',\n    pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),\n    positions: new PositionDataType(linePositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n    featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const polygons = {\n    type: 'Polygon',\n    polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),\n    primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),\n    positions: new PositionDataType(polygonPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n    featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  if (triangulate) {\n    polygons.triangles = [];\n  }\n  // Instantiate numeric properties arrays; one value per vertex\n  for (const object of [points, lines, polygons]) {\n    for (const propName of numericPropKeys) {\n      // If property has been numeric in all previous features in which the property existed, check\n      // if numeric in this feature\n      const T = propArrayTypes[propName];\n      object.numericProps[propName] = new T(object.positions.length / coordLength);\n    }\n  }\n  // Set last element of path/polygon indices as positions length\n  lines.pathIndices[linePathsCount] = linePositionsCount;\n  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n  const indexMap = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    const properties = feature.properties || {};\n    switch (geometry.type) {\n      case 'Point':\n        handlePoint(geometry, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          points.fields.push({\n            id: feature.id\n          });\n        }\n        indexMap.pointFeature++;\n        break;\n      case 'LineString':\n        handleLineString(geometry, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          lines.fields.push({\n            id: feature.id\n          });\n        }\n        indexMap.lineFeature++;\n        break;\n      case 'Polygon':\n        handlePolygon(geometry, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          polygons.fields.push({\n            id: feature.id\n          });\n        }\n        indexMap.polygonFeature++;\n        break;\n      default:\n        throw new Error('Invalid geometry type');\n    }\n    indexMap.feature++;\n  }\n  // Wrap each array in an accessor object with value and size keys\n  return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n/**\n * Fills (Multi)Point coordinates into points object of arrays\n *\n * @param geometry\n * @param points\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handlePoint(geometry, points, indexMap, coordLength, properties) {\n  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);\n  points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n  points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n  indexMap.pointPosition += nPositions;\n}\n/**\n * Fills (Multi)LineString coordinates into lines object of arrays\n *\n * @param geometry\n * @param lines\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handleLineString(geometry, lines, indexMap, coordLength, properties) {\n  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n  lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);\n  lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);\n  for (let i = 0, il = geometry.indices.length; i < il; ++i) {\n    // Extract range of data we are working with, defined by start\n    // and end indices (these index into the geometry.data array)\n    const start = geometry.indices[i];\n    const end = i === il - 1 ? geometry.data.length // last line, so read to end of data\n    : geometry.indices[i + 1]; // start index for next line\n    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;\n    indexMap.linePosition += (end - start) / coordLength;\n  }\n}\n/**\n * Fills (Multi)Polygon coordinates into polygons object of arrays\n *\n * @param geometry\n * @param polygons\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handlePolygon(geometry, polygons, indexMap, coordLength, properties) {\n  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n  polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n  polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n  // Unlike Point & LineString geometry.indices is a 2D array\n  for (let l = 0, ll = geometry.indices.length; l < ll; ++l) {\n    const startPosition = indexMap.polygonPosition;\n    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;\n    const areas = geometry.areas[l];\n    const indices = geometry.indices[l];\n    const nextIndices = geometry.indices[l + 1];\n    for (let i = 0, il = indices.length; i < il; ++i) {\n      const start = indices[i];\n      const end = i === il - 1 ?\n      // last line, so either read to:\n      nextIndices === undefined ? geometry.data.length // end of data (no next indices)\n      : nextIndices[0] // start of first line in nextIndices\n      : indices[i + 1]; // start index for next line\n      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;\n      indexMap.polygonPosition += (end - start) / coordLength;\n    }\n    const endPosition = indexMap.polygonPosition;\n    triangulatePolygon(polygons, areas, indices, {\n      startPosition,\n      endPosition,\n      coordLength\n    });\n  }\n}\n/**\n * Triangulate polygon using earcut\n *\n * @param polygons\n * @param areas\n * @param indices\n * @param param3\n */\nfunction triangulatePolygon(polygons, areas, indices, {\n  startPosition,\n  endPosition,\n  coordLength\n}) {\n  if (!polygons.triangles) {\n    return;\n  }\n  const start = startPosition * coordLength;\n  const end = endPosition * coordLength;\n  // Extract positions and holes for just this polygon\n  const polygonPositions = polygons.positions.subarray(start, end);\n  // Holes are referenced relative to outer polygon\n  const offset = indices[0];\n  const holes = indices.slice(1).map(n => (n - offset) / coordLength);\n  // Compute triangulation\n  const triangles = earcut(polygonPositions, holes, coordLength, areas);\n  // Indices returned by triangulation are relative to start\n  // of polygon, so we need to offset\n  for (let t = 0, tl = triangles.length; t < tl; ++t) {\n    polygons.triangles.push(startPosition + triangles[t]);\n  }\n}\n/**\n * Wraps an object containing array into accessors\n *\n * @param obj\n * @param size\n */\nfunction wrapProps(obj, size) {\n  const returnObj = {};\n  for (const key in obj) {\n    returnObj[key] = {\n      value: obj[key],\n      size\n    };\n  }\n  return returnObj;\n}\n/**\n * Wrap each array in an accessor object with value and size keys\n *\n * @param points\n * @param lines\n * @param polygons\n * @param coordLength\n * @returns object\n */\nfunction makeAccessorObjects(points, lines, polygons, coordLength) {\n  const binaryFeatures = {\n    shape: 'binary-feature-collection',\n    points: {\n      ...points,\n      positions: {\n        value: points.positions,\n        size: coordLength\n      },\n      globalFeatureIds: {\n        value: points.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: points.featureIds,\n        size: 1\n      },\n      numericProps: wrapProps(points.numericProps, 1)\n    },\n    lines: {\n      ...lines,\n      positions: {\n        value: lines.positions,\n        size: coordLength\n      },\n      pathIndices: {\n        value: lines.pathIndices,\n        size: 1\n      },\n      globalFeatureIds: {\n        value: lines.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: lines.featureIds,\n        size: 1\n      },\n      numericProps: wrapProps(lines.numericProps, 1)\n    },\n    polygons: {\n      ...polygons,\n      positions: {\n        value: polygons.positions,\n        size: coordLength\n      },\n      polygonIndices: {\n        value: polygons.polygonIndices,\n        size: 1\n      },\n      primitivePolygonIndices: {\n        value: polygons.primitivePolygonIndices,\n        size: 1\n      },\n      globalFeatureIds: {\n        value: polygons.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: polygons.featureIds,\n        size: 1\n      },\n      numericProps: wrapProps(polygons.numericProps, 1)\n    } // triangles not expected\n  };\n  if (binaryFeatures.polygons && polygons.triangles) {\n    binaryFeatures.polygons.triangles = {\n      value: new Uint32Array(polygons.triangles),\n      size: 1\n    };\n  }\n  return binaryFeatures;\n}\n/**\n * Add numeric properties to object\n *\n * @param object\n * @param properties\n * @param index\n * @param length\n */\nfunction fillNumericProperties(object, properties, index, length) {\n  for (const numericPropName in object.numericProps) {\n    if (numericPropName in properties) {\n      const value = properties[numericPropName];\n      object.numericProps[numericPropName].fill(value, index, index + length);\n    }\n  }\n}\n/**\n * Keep string properties in object\n *\n * @param properties\n * @param numericKeys\n * @returns object\n */\nfunction keepStringProperties(properties, numericKeys) {\n  const props = {};\n  for (const key in properties) {\n    if (!numericKeys.includes(key)) {\n      props[key] = properties[key];\n    }\n  }\n  return props;\n}\n/**\n *\n * Deduce correct array constructor to use for a given value\n *\n * @param x value to test\n * @param constructor previous constructor deduced\n * @returns PropArrayConstructor\n */\nfunction deduceArrayType(x, constructor) {\n  if (constructor === Array || !Number.isFinite(x)) {\n    return Array;\n  }\n  // If this or previous value required 64bits use Float64Array\n  return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}