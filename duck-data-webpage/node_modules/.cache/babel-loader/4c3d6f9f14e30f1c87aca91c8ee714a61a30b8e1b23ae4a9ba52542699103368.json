{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { CommandBuffer, Texture } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\nimport { WEBGLTexture } from \"./webgl-texture.js\";\nimport { getTextureFormatWebGL } from \"../converters/webgl-texture-table.js\";\nexport class WEBGLCommandBuffer extends CommandBuffer {\n  device;\n  commands = [];\n  constructor(device) {\n    super(device, {});\n    this.device = device;\n  }\n  submitCommands(commands = this.commands) {\n    for (const command of commands) {\n      switch (command.name) {\n        case 'copy-buffer-to-buffer':\n          _copyBufferToBuffer(this.device, command.options);\n          break;\n        case 'copy-buffer-to-texture':\n          _copyBufferToTexture(this.device, command.options);\n          break;\n        case 'copy-texture-to-buffer':\n          _copyTextureToBuffer(this.device, command.options);\n          break;\n        case 'copy-texture-to-texture':\n          _copyTextureToTexture(this.device, command.options);\n          break;\n        // case 'clear-texture':\n        //   _clearTexture(this.device, command.options);\n        //   break;\n        default:\n          throw new Error(command.name);\n      }\n    }\n  }\n}\nfunction _copyBufferToBuffer(device, options) {\n  const source = options.sourceBuffer;\n  const destination = options.destinationBuffer;\n  // {In WebGL2 we can p}erform the copy on the GPU\n  // Use GL.COPY_READ_BUFFER+GL.COPY_WRITE_BUFFER avoid disturbing other targets and locking type\n  device.gl.bindBuffer(36662, source.handle);\n  device.gl.bindBuffer(36663, destination.handle);\n  device.gl.copyBufferSubData(36662, 36663, options.sourceOffset ?? 0, options.destinationOffset ?? 0, options.size);\n  device.gl.bindBuffer(36662, null);\n  device.gl.bindBuffer(36663, null);\n}\n/**\n * Copies data from a Buffer object into a Texture object\n * NOTE: doesn't wait for copy to be complete\n */\nfunction _copyBufferToTexture(device, options) {\n  throw new Error('Not implemented');\n}\n/**\n * Copies data from a Texture object into a Buffer object.\n * NOTE: doesn't wait for copy to be complete\n */\nfunction _copyTextureToBuffer(device, options) {\n  const {\n    /** Texture to copy to/from. */\n    sourceTexture,\n    /**  Mip-map level of the texture to copy to/from. (Default 0) */\n    mipLevel = 0,\n    /** Defines which aspects of the texture to copy to/from. */\n    aspect = 'all',\n    /** Width to copy */\n    width = options.sourceTexture.width,\n    /** Height to copy */\n    height = options.sourceTexture.height,\n    depthOrArrayLayers = 0,\n    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */\n    origin = [0, 0],\n    /** Destination buffer */\n    destinationBuffer,\n    /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */\n    byteOffset = 0,\n    /**\n     * The stride, in bytes, between the beginning of each block row and the subsequent block row.\n     * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).\n     */\n    bytesPerRow,\n    /**\n     * Number of block rows per single image of the texture.\n     * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.\n     * Required if there are multiple images (i.e. the copy depth is more than one).\n     */\n    rowsPerImage\n  } = options;\n  // TODO - Not possible to read just stencil or depth part in WebGL?\n  if (aspect !== 'all') {\n    throw new Error('aspect not supported in WebGL');\n  }\n  // TODO - mipLevels are set when attaching texture to framebuffer\n  if (mipLevel !== 0 || depthOrArrayLayers !== 0 || bytesPerRow || rowsPerImage) {\n    throw new Error('not implemented');\n  }\n  // Asynchronous read (PIXEL_PACK_BUFFER) is WebGL2 only feature\n  const {\n    framebuffer,\n    destroyFramebuffer\n  } = getFramebuffer(sourceTexture);\n  let prevHandle;\n  try {\n    const webglBuffer = destinationBuffer;\n    const sourceWidth = width || framebuffer.width;\n    const sourceHeight = height || framebuffer.height;\n    const sourceParams = getTextureFormatWebGL(framebuffer.colorAttachments[0].texture.props.format);\n    const sourceFormat = sourceParams.format;\n    const sourceType = sourceParams.type;\n    // if (!target) {\n    //   // Create new buffer with enough size\n    //   const components = glFormatToComponents(sourceFormat);\n    //   const byteCount = glTypeToBytes(sourceType);\n    //   const byteLength = byteOffset + sourceWidth * sourceHeight * components * byteCount;\n    //   target = device.createBuffer({byteLength});\n    // }\n    device.gl.bindBuffer(35051, webglBuffer.handle);\n    // @ts-expect-error native bindFramebuffer is overridden by our state tracker\n    prevHandle = device.gl.bindFramebuffer(36160, framebuffer.handle);\n    device.gl.readPixels(origin[0], origin[1], sourceWidth, sourceHeight, sourceFormat, sourceType, byteOffset);\n  } finally {\n    device.gl.bindBuffer(35051, null);\n    // prevHandle may be unassigned if the try block failed before binding\n    if (prevHandle !== undefined) {\n      device.gl.bindFramebuffer(36160, prevHandle);\n    }\n    if (destroyFramebuffer) {\n      framebuffer.destroy();\n    }\n  }\n}\n/**\n * Copies data from a Framebuffer or a Texture object into a Buffer object.\n * NOTE: doesn't wait for copy to be complete, it programs GPU to perform a DMA transfer.\nexport function readPixelsToBuffer(\n  source: Framebuffer | Texture,\n  options?: {\n    sourceX?: number;\n    sourceY?: number;\n    sourceFormat?: number;\n    target?: Buffer; // A new Buffer object is created when not provided.\n    targetByteOffset?: number; // byte offset in buffer object\n    // following parameters are auto deduced if not provided\n    sourceWidth?: number;\n    sourceHeight?: number;\n    sourceType?: number;\n  }\n): Buffer\n */\n/**\n * Copy a rectangle from a Framebuffer or Texture object into a texture (at an offset)\n */\n// eslint-disable-next-line complexity, max-statements\nfunction _copyTextureToTexture(device, options) {\n  const {\n    /** Texture to copy to/from. */\n    sourceTexture,\n    /**  Mip-map level of the texture to copy to (Default 0) */\n    destinationMipLevel = 0,\n    /** Defines which aspects of the texture to copy to/from. */\n    // aspect = 'all',\n    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */\n    origin = [0, 0],\n    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */\n    destinationOrigin = [0, 0],\n    /** Texture to copy to/from. */\n    destinationTexture\n    /**  Mip-map level of the texture to copy to/from. (Default 0) */\n    // destinationMipLevel = options.mipLevel,\n    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */\n    // destinationOrigin = [0, 0],\n    /** Defines which aspects of the texture to copy to/from. */\n    // destinationAspect = options.aspect,\n  } = options;\n  let {\n    width = options.destinationTexture.width,\n    height = options.destinationTexture.height\n    // depthOrArrayLayers = 0\n  } = options;\n  const {\n    framebuffer,\n    destroyFramebuffer\n  } = getFramebuffer(sourceTexture);\n  const [sourceX, sourceY] = origin;\n  const [destinationX, destinationY, destinationZ] = destinationOrigin;\n  // @ts-expect-error native bindFramebuffer is overridden by our state tracker\n  const prevHandle = device.gl.bindFramebuffer(36160, framebuffer.handle);\n  // TODO - support gl.readBuffer (WebGL2 only)\n  // const prevBuffer = gl.readBuffer(attachment);\n  let texture = null;\n  let textureTarget;\n  if (destinationTexture instanceof WEBGLTexture) {\n    texture = destinationTexture;\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n    texture.bind(0);\n    textureTarget = texture.glTarget;\n  } else {\n    throw new Error('invalid destination');\n  }\n  switch (textureTarget) {\n    case 3553:\n    case 34067:\n      device.gl.copyTexSubImage2D(textureTarget, destinationMipLevel, destinationX, destinationY, sourceX, sourceY, width, height);\n      break;\n    case 35866:\n    case 32879:\n      device.gl.copyTexSubImage3D(textureTarget, destinationMipLevel, destinationX, destinationY, destinationZ, sourceX, sourceY, width, height);\n      break;\n    default:\n  }\n  if (texture) {\n    texture.unbind();\n  }\n  device.gl.bindFramebuffer(36160, prevHandle);\n  if (destroyFramebuffer) {\n    framebuffer.destroy();\n  }\n}\n/** Clear one mip level of a texture *\nfunction _clearTexture(device: WebGLDevice, options: ClearTextureOptions) {\n  const BORDER = 0;\n  const {dimension, width, height, depth = 0, mipLevel = 0} = options;\n  const {glInternalFormat, glFormat, glType, compressed} = options;\n  const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);\n\n  switch (dimension) {\n    case '2d-array':\n    case '3d':\n      if (compressed) {\n        // prettier-ignore\n        device.gl.compressedTexImage3D(glTarget, mipLevel, glInternalFormat, width, height, depth, BORDER, null);\n      } else {\n        // prettier-ignore\n        device.gl.texImage3D( glTarget, mipLevel, glInternalFormat, width, height, depth, BORDER, glFormat, glType, null);\n      }\n      break;\n\n    case '2d':\n    case 'cube':\n      if (compressed) {\n        // prettier-ignore\n        device.gl.compressedTexImage2D(glTarget, mipLevel, glInternalFormat, width, height, BORDER, null);\n      } else {\n        // prettier-ignore\n        device.gl.texImage2D(glTarget, mipLevel, glInternalFormat, width, height, BORDER, glFormat, glType, null);\n      }\n      break;\n\n    default:\n      throw new Error(dimension);\n  }\n}\n  */\n// function _readTexture(device: WebGLDevice, options: CopyTextureToBufferOptions) {}\n// HELPERS\n/**\n * In WebGL, cube maps specify faces by overriding target instead of using the depth parameter.\n * @note We still bind the texture using GL.TEXTURE_CUBE_MAP, but we need to use the face-specific target when setting mip levels.\n * @returns glTarget unchanged, if dimension !== 'cube'.\n */\nexport function getWebGLCubeFaceTarget(glTarget, dimension, level) {\n  return dimension === 'cube' ? 34069 + level : glTarget;\n}\n/** Wrap a texture in a framebuffer so that we can use WebGL APIs that work on framebuffers */\nfunction getFramebuffer(source) {\n  if (source instanceof Texture) {\n    const {\n      width,\n      height,\n      id\n    } = source;\n    const framebuffer = source.device.createFramebuffer({\n      id: `framebuffer-for-${id}`,\n      width,\n      height,\n      colorAttachments: [source]\n    });\n    return {\n      framebuffer,\n      destroyFramebuffer: true\n    };\n  }\n  return {\n    framebuffer: source,\n    destroyFramebuffer: false\n  };\n}\n/**\n * Returns number of components in a specific readPixels WebGL format\n * @todo use shadertypes utils instead?\n */\nexport function glFormatToComponents(format) {\n  switch (format) {\n    case 6406:\n    case 33326:\n    case 6403:\n      return 1;\n    case 33328:\n    case 33319:\n      return 2;\n    case 6407:\n    case 34837:\n      return 3;\n    case 6408:\n    case 34836:\n      return 4;\n    // TODO: Add support for additional WebGL2 formats\n    default:\n      throw new Error('GLFormat');\n  }\n}\n/**\n * Return byte count for given readPixels WebGL type\n * @todo use shadertypes utils instead?\n */\nexport function glTypeToBytes(type) {\n  switch (type) {\n    case 5121:\n      return 1;\n    case 33635:\n    case 32819:\n    case 32820:\n      return 2;\n    case 5126:\n      return 4;\n    // TODO: Add support for additional WebGL2 types\n    default:\n      throw new Error('GLType');\n  }\n}","map":{"version":3,"names":["CommandBuffer","Texture","GL","WEBGLTexture","getTextureFormatWebGL","WEBGLCommandBuffer","device","commands","constructor","submitCommands","command","name","_copyBufferToBuffer","options","_copyBufferToTexture","_copyTextureToBuffer","_copyTextureToTexture","Error","source","sourceBuffer","destination","destinationBuffer","gl","bindBuffer","handle","copyBufferSubData","sourceOffset","destinationOffset","size","sourceTexture","mipLevel","aspect","width","height","depthOrArrayLayers","origin","byteOffset","bytesPerRow","rowsPerImage","framebuffer","destroyFramebuffer","getFramebuffer","prevHandle","webglBuffer","sourceWidth","sourceHeight","sourceParams","colorAttachments","texture","props","format","sourceFormat","sourceType","type","bindFramebuffer","readPixels","undefined","destroy","destinationMipLevel","destinationOrigin","destinationTexture","sourceX","sourceY","destinationX","destinationY","destinationZ","textureTarget","Number","isFinite","bind","glTarget","copyTexSubImage2D","copyTexSubImage3D","unbind","getWebGLCubeFaceTarget","dimension","level","id","createFramebuffer","glFormatToComponents","glTypeToBytes"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\webgl\\src\\adapter\\resources\\webgl-command-buffer.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {\n  CopyBufferToBufferOptions,\n  CopyBufferToTextureOptions,\n  CopyTextureToBufferOptions,\n  CopyTextureToTextureOptions\n  // ClearTextureOptions,\n  // ReadTextureOptions\n} from '@luma.gl/core';\nimport {CommandBuffer, Texture, Framebuffer} from '@luma.gl/core';\nimport {\n  GL,\n  GLTextureTarget,\n  GLTextureCubeMapTarget\n  // GLTexelDataFormat,\n  // GLPixelType,\n  // GLDataType\n} from '@luma.gl/constants';\n\nimport {WebGLDevice} from '../webgl-device';\nimport {WEBGLBuffer} from './webgl-buffer';\nimport {WEBGLTexture} from './webgl-texture';\nimport {WEBGLFramebuffer} from './webgl-framebuffer';\nimport {getTextureFormatWebGL} from '../converters/webgl-texture-table';\n\ntype CopyBufferToBufferCommand = {\n  name: 'copy-buffer-to-buffer';\n  options: CopyBufferToBufferOptions;\n};\n\ntype CopyBufferToTextureCommand = {\n  name: 'copy-buffer-to-texture';\n  options: CopyBufferToTextureOptions;\n};\n\ntype CopyTextureToBufferCommand = {\n  name: 'copy-texture-to-buffer';\n  options: CopyTextureToBufferOptions;\n};\n\ntype CopyTextureToTextureCommand = {\n  name: 'copy-texture-to-texture';\n  options: CopyTextureToTextureOptions;\n};\n\ntype ClearTextureCommand = {\n  name: 'clear-texture';\n  options: {}; // ClearTextureOptions;\n};\n\ntype ReadTextureCommand = {\n  name: 'read-texture';\n  options: {}; // ReadTextureOptions;\n};\n\ntype Command =\n  | CopyBufferToBufferCommand\n  | CopyBufferToTextureCommand\n  | CopyTextureToBufferCommand\n  | CopyTextureToTextureCommand\n  | ClearTextureCommand\n  | ReadTextureCommand;\n\nexport class WEBGLCommandBuffer extends CommandBuffer {\n  device: WebGLDevice;\n  commands: Command[] = [];\n\n  constructor(device: WebGLDevice) {\n    super(device, {});\n    this.device = device;\n  }\n\n  submitCommands(commands: Command[] = this.commands) {\n    for (const command of commands) {\n      switch (command.name) {\n        case 'copy-buffer-to-buffer':\n          _copyBufferToBuffer(this.device, command.options);\n          break;\n        case 'copy-buffer-to-texture':\n          _copyBufferToTexture(this.device, command.options);\n          break;\n        case 'copy-texture-to-buffer':\n          _copyTextureToBuffer(this.device, command.options);\n          break;\n        case 'copy-texture-to-texture':\n          _copyTextureToTexture(this.device, command.options);\n          break;\n        // case 'clear-texture':\n        //   _clearTexture(this.device, command.options);\n        //   break;\n        default:\n          throw new Error(command.name);\n      }\n    }\n  }\n}\n\nfunction _copyBufferToBuffer(device: WebGLDevice, options: CopyBufferToBufferOptions): void {\n  const source = options.sourceBuffer as WEBGLBuffer;\n  const destination = options.destinationBuffer as WEBGLBuffer;\n\n  // {In WebGL2 we can p}erform the copy on the GPU\n  // Use GL.COPY_READ_BUFFER+GL.COPY_WRITE_BUFFER avoid disturbing other targets and locking type\n  device.gl.bindBuffer(GL.COPY_READ_BUFFER, source.handle);\n  device.gl.bindBuffer(GL.COPY_WRITE_BUFFER, destination.handle);\n  device.gl.copyBufferSubData(\n    GL.COPY_READ_BUFFER,\n    GL.COPY_WRITE_BUFFER,\n    options.sourceOffset ?? 0,\n    options.destinationOffset ?? 0,\n    options.size\n  );\n  device.gl.bindBuffer(GL.COPY_READ_BUFFER, null);\n  device.gl.bindBuffer(GL.COPY_WRITE_BUFFER, null);\n}\n\n/**\n * Copies data from a Buffer object into a Texture object\n * NOTE: doesn't wait for copy to be complete\n */\nfunction _copyBufferToTexture(device: WebGLDevice, options: CopyBufferToTextureOptions): void {\n  throw new Error('Not implemented');\n}\n\n/**\n * Copies data from a Texture object into a Buffer object.\n * NOTE: doesn't wait for copy to be complete\n */\nfunction _copyTextureToBuffer(device: WebGLDevice, options: CopyTextureToBufferOptions): void {\n  const {\n    /** Texture to copy to/from. */\n    sourceTexture,\n    /**  Mip-map level of the texture to copy to/from. (Default 0) */\n    mipLevel = 0,\n    /** Defines which aspects of the texture to copy to/from. */\n    aspect = 'all',\n\n    /** Width to copy */\n    width = options.sourceTexture.width,\n    /** Height to copy */\n    height = options.sourceTexture.height,\n    depthOrArrayLayers = 0,\n    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */\n    origin = [0, 0],\n\n    /** Destination buffer */\n    destinationBuffer,\n    /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */\n    byteOffset = 0,\n    /**\n     * The stride, in bytes, between the beginning of each block row and the subsequent block row.\n     * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).\n     */\n    bytesPerRow,\n    /**\n     * Number of block rows per single image of the texture.\n     * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.\n     * Required if there are multiple images (i.e. the copy depth is more than one).\n     */\n    rowsPerImage\n  } = options;\n\n  // TODO - Not possible to read just stencil or depth part in WebGL?\n  if (aspect !== 'all') {\n    throw new Error('aspect not supported in WebGL');\n  }\n\n  // TODO - mipLevels are set when attaching texture to framebuffer\n  if (mipLevel !== 0 || depthOrArrayLayers !== 0 || bytesPerRow || rowsPerImage) {\n    throw new Error('not implemented');\n  }\n\n  // Asynchronous read (PIXEL_PACK_BUFFER) is WebGL2 only feature\n  const {framebuffer, destroyFramebuffer} = getFramebuffer(sourceTexture);\n  let prevHandle: WebGLFramebuffer | null | undefined;\n  try {\n    const webglBuffer = destinationBuffer as WEBGLBuffer;\n    const sourceWidth = width || framebuffer.width;\n    const sourceHeight = height || framebuffer.height;\n    const sourceParams = getTextureFormatWebGL(\n      framebuffer.colorAttachments[0].texture.props.format\n    );\n    const sourceFormat = sourceParams.format;\n    const sourceType = sourceParams.type;\n\n    // if (!target) {\n    //   // Create new buffer with enough size\n    //   const components = glFormatToComponents(sourceFormat);\n    //   const byteCount = glTypeToBytes(sourceType);\n    //   const byteLength = byteOffset + sourceWidth * sourceHeight * components * byteCount;\n    //   target = device.createBuffer({byteLength});\n    // }\n\n    device.gl.bindBuffer(GL.PIXEL_PACK_BUFFER, webglBuffer.handle);\n    // @ts-expect-error native bindFramebuffer is overridden by our state tracker\n    prevHandle = device.gl.bindFramebuffer(GL.FRAMEBUFFER, framebuffer.handle);\n\n    device.gl.readPixels(\n      origin[0],\n      origin[1],\n      sourceWidth,\n      sourceHeight,\n      sourceFormat,\n      sourceType,\n      byteOffset\n    );\n  } finally {\n    device.gl.bindBuffer(GL.PIXEL_PACK_BUFFER, null);\n    // prevHandle may be unassigned if the try block failed before binding\n    if (prevHandle !== undefined) {\n      device.gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle);\n    }\n\n    if (destroyFramebuffer) {\n      framebuffer.destroy();\n    }\n  }\n}\n\n/**\n * Copies data from a Framebuffer or a Texture object into a Buffer object.\n * NOTE: doesn't wait for copy to be complete, it programs GPU to perform a DMA transfer.\nexport function readPixelsToBuffer(\n  source: Framebuffer | Texture,\n  options?: {\n    sourceX?: number;\n    sourceY?: number;\n    sourceFormat?: number;\n    target?: Buffer; // A new Buffer object is created when not provided.\n    targetByteOffset?: number; // byte offset in buffer object\n    // following parameters are auto deduced if not provided\n    sourceWidth?: number;\n    sourceHeight?: number;\n    sourceType?: number;\n  }\n): Buffer\n */\n\n/**\n * Copy a rectangle from a Framebuffer or Texture object into a texture (at an offset)\n */\n// eslint-disable-next-line complexity, max-statements\nfunction _copyTextureToTexture(device: WebGLDevice, options: CopyTextureToTextureOptions): void {\n  const {\n    /** Texture to copy to/from. */\n    sourceTexture,\n    /**  Mip-map level of the texture to copy to (Default 0) */\n    destinationMipLevel = 0,\n    /** Defines which aspects of the texture to copy to/from. */\n    // aspect = 'all',\n    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */\n    origin = [0, 0],\n\n    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */\n    destinationOrigin = [0, 0],\n\n    /** Texture to copy to/from. */\n    destinationTexture\n    /**  Mip-map level of the texture to copy to/from. (Default 0) */\n    // destinationMipLevel = options.mipLevel,\n    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */\n    // destinationOrigin = [0, 0],\n    /** Defines which aspects of the texture to copy to/from. */\n    // destinationAspect = options.aspect,\n  } = options;\n\n  let {\n    width = options.destinationTexture.width,\n    height = options.destinationTexture.height\n    // depthOrArrayLayers = 0\n  } = options;\n\n  const {framebuffer, destroyFramebuffer} = getFramebuffer(sourceTexture);\n  const [sourceX, sourceY] = origin;\n  const [destinationX, destinationY, destinationZ] = destinationOrigin;\n\n  // @ts-expect-error native bindFramebuffer is overridden by our state tracker\n  const prevHandle: WebGLFramebuffer | null = device.gl.bindFramebuffer(\n    GL.FRAMEBUFFER,\n    framebuffer.handle\n  );\n  // TODO - support gl.readBuffer (WebGL2 only)\n  // const prevBuffer = gl.readBuffer(attachment);\n\n  let texture: WEBGLTexture = null;\n  let textureTarget: GL;\n  if (destinationTexture instanceof WEBGLTexture) {\n    texture = destinationTexture;\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n    texture.bind(0);\n    textureTarget = texture.glTarget;\n  } else {\n    throw new Error('invalid destination');\n  }\n\n  switch (textureTarget) {\n    case GL.TEXTURE_2D:\n    case GL.TEXTURE_CUBE_MAP:\n      device.gl.copyTexSubImage2D(\n        textureTarget,\n        destinationMipLevel,\n        destinationX,\n        destinationY,\n        sourceX,\n        sourceY,\n        width,\n        height\n      );\n      break;\n    case GL.TEXTURE_2D_ARRAY:\n    case GL.TEXTURE_3D:\n      device.gl.copyTexSubImage3D(\n        textureTarget,\n        destinationMipLevel,\n        destinationX,\n        destinationY,\n        destinationZ,\n        sourceX,\n        sourceY,\n        width,\n        height\n      );\n      break;\n    default:\n  }\n\n  if (texture) {\n    texture.unbind();\n  }\n  device.gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle);\n  if (destroyFramebuffer) {\n    framebuffer.destroy();\n  }\n}\n\n/** Clear one mip level of a texture *\nfunction _clearTexture(device: WebGLDevice, options: ClearTextureOptions) {\n  const BORDER = 0;\n  const {dimension, width, height, depth = 0, mipLevel = 0} = options;\n  const {glInternalFormat, glFormat, glType, compressed} = options;\n  const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);\n\n  switch (dimension) {\n    case '2d-array':\n    case '3d':\n      if (compressed) {\n        // prettier-ignore\n        device.gl.compressedTexImage3D(glTarget, mipLevel, glInternalFormat, width, height, depth, BORDER, null);\n      } else {\n        // prettier-ignore\n        device.gl.texImage3D( glTarget, mipLevel, glInternalFormat, width, height, depth, BORDER, glFormat, glType, null);\n      }\n      break;\n\n    case '2d':\n    case 'cube':\n      if (compressed) {\n        // prettier-ignore\n        device.gl.compressedTexImage2D(glTarget, mipLevel, glInternalFormat, width, height, BORDER, null);\n      } else {\n        // prettier-ignore\n        device.gl.texImage2D(glTarget, mipLevel, glInternalFormat, width, height, BORDER, glFormat, glType, null);\n      }\n      break;\n\n    default:\n      throw new Error(dimension);\n  }\n}\n  */\n\n// function _readTexture(device: WebGLDevice, options: CopyTextureToBufferOptions) {}\n\n// HELPERS\n\n/**\n * In WebGL, cube maps specify faces by overriding target instead of using the depth parameter.\n * @note We still bind the texture using GL.TEXTURE_CUBE_MAP, but we need to use the face-specific target when setting mip levels.\n * @returns glTarget unchanged, if dimension !== 'cube'.\n */\nexport function getWebGLCubeFaceTarget(\n  glTarget: GLTextureTarget,\n  dimension: '1d' | '2d' | '2d-array' | 'cube' | 'cube-array' | '3d',\n  level: number\n): GLTextureTarget | GLTextureCubeMapTarget {\n  return dimension === 'cube' ? GL.TEXTURE_CUBE_MAP_POSITIVE_X + level : glTarget;\n}\n\n/** Wrap a texture in a framebuffer so that we can use WebGL APIs that work on framebuffers */\nfunction getFramebuffer(source: Texture | Framebuffer): {\n  framebuffer: WEBGLFramebuffer;\n  destroyFramebuffer: boolean;\n} {\n  if (source instanceof Texture) {\n    const {width, height, id} = source;\n    const framebuffer = source.device.createFramebuffer({\n      id: `framebuffer-for-${id}`,\n      width,\n      height,\n      colorAttachments: [source]\n    }) as unknown as WEBGLFramebuffer;\n\n    return {framebuffer, destroyFramebuffer: true};\n  }\n  return {framebuffer: source as unknown as WEBGLFramebuffer, destroyFramebuffer: false};\n}\n\n/**\n * Returns number of components in a specific readPixels WebGL format\n * @todo use shadertypes utils instead?\n */\nexport function glFormatToComponents(format): 1 | 2 | 3 | 4 {\n  switch (format) {\n    case GL.ALPHA:\n    case GL.R32F:\n    case GL.RED:\n      return 1;\n    case GL.RG32F:\n    case GL.RG:\n      return 2;\n    case GL.RGB:\n    case GL.RGB32F:\n      return 3;\n    case GL.RGBA:\n    case GL.RGBA32F:\n      return 4;\n    // TODO: Add support for additional WebGL2 formats\n    default:\n      throw new Error('GLFormat');\n  }\n}\n\n/**\n * Return byte count for given readPixels WebGL type\n * @todo use shadertypes utils instead?\n */\nexport function glTypeToBytes(type: GL): 1 | 2 | 4 {\n  switch (type) {\n    case GL.UNSIGNED_BYTE:\n      return 1;\n    case GL.UNSIGNED_SHORT_5_6_5:\n    case GL.UNSIGNED_SHORT_4_4_4_4:\n    case GL.UNSIGNED_SHORT_5_5_5_1:\n      return 2;\n    case GL.FLOAT:\n      return 4;\n    // TODO: Add support for additional WebGL2 types\n    default:\n      throw new Error('GLType');\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}