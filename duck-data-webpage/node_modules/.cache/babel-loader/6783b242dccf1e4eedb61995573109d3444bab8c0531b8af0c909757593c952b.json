{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { MAGIC_ARRAY } from \"../constants.js\";\nimport { encode3DTileHeader, encode3DTileByteLength } from \"./helpers/encode-3d-tile-header.js\";\nexport function encodeComposite3DTile(tile, dataView, byteOffset, options, encode3DTile) {\n  // Add default magic for this tile type\n  tile = {\n    magic: MAGIC_ARRAY.COMPOSITE,\n    tiles: [],\n    ...tile\n  };\n  const byteOffsetStart = byteOffset;\n  byteOffset += encode3DTileHeader(tile, dataView, byteOffset);\n  if (dataView) {\n    dataView.setUint32(byteOffset, tile.tiles.length, true); // tilesLength\n  }\n  byteOffset += 4;\n  for (let i = 0; i < tile.tiles.length; ++i) {\n    byteOffset += encode3DTile(tile.tiles[i], dataView, byteOffset, options);\n  }\n  // Go \"back\" and rewrite the tile's `byteLength` now that we know the value\n  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n  return byteOffset;\n}","map":{"version":3,"names":["MAGIC_ARRAY","encode3DTileHeader","encode3DTileByteLength","encodeComposite3DTile","tile","dataView","byteOffset","options","encode3DTile","magic","COMPOSITE","tiles","byteOffsetStart","setUint32","length","i"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/3d-tiles/dist/lib/encoders/encode-3d-tile-composite.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { MAGIC_ARRAY } from \"../constants.js\";\nimport { encode3DTileHeader, encode3DTileByteLength } from \"./helpers/encode-3d-tile-header.js\";\nexport function encodeComposite3DTile(tile, dataView, byteOffset, options, encode3DTile) {\n    // Add default magic for this tile type\n    tile = { magic: MAGIC_ARRAY.COMPOSITE, tiles: [], ...tile };\n    const byteOffsetStart = byteOffset;\n    byteOffset += encode3DTileHeader(tile, dataView, byteOffset);\n    if (dataView) {\n        dataView.setUint32(byteOffset, tile.tiles.length, true); // tilesLength\n    }\n    byteOffset += 4;\n    for (let i = 0; i < tile.tiles.length; ++i) {\n        byteOffset += encode3DTile(tile.tiles[i], dataView, byteOffset, options);\n    }\n    // Go \"back\" and rewrite the tile's `byteLength` now that we know the value\n    encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n    return byteOffset;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,SAASA,WAAW,QAAQ,iBAAiB;AAC7C,SAASC,kBAAkB,EAAEC,sBAAsB,QAAQ,oCAAoC;AAC/F,OAAO,SAASC,qBAAqBA,CAACC,IAAI,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,OAAO,EAAEC,YAAY,EAAE;EACrF;EACAJ,IAAI,GAAG;IAAEK,KAAK,EAAET,WAAW,CAACU,SAAS;IAAEC,KAAK,EAAE,EAAE;IAAE,GAAGP;EAAK,CAAC;EAC3D,MAAMQ,eAAe,GAAGN,UAAU;EAClCA,UAAU,IAAIL,kBAAkB,CAACG,IAAI,EAAEC,QAAQ,EAAEC,UAAU,CAAC;EAC5D,IAAID,QAAQ,EAAE;IACVA,QAAQ,CAACQ,SAAS,CAACP,UAAU,EAAEF,IAAI,CAACO,KAAK,CAACG,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC;EAC7D;EACAR,UAAU,IAAI,CAAC;EACf,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,IAAI,CAACO,KAAK,CAACG,MAAM,EAAE,EAAEC,CAAC,EAAE;IACxCT,UAAU,IAAIE,YAAY,CAACJ,IAAI,CAACO,KAAK,CAACI,CAAC,CAAC,EAAEV,QAAQ,EAAEC,UAAU,EAAEC,OAAO,CAAC;EAC5E;EACA;EACAL,sBAAsB,CAACG,QAAQ,EAAEO,eAAe,EAAEN,UAAU,GAAGM,eAAe,CAAC;EAC/E,OAAON,UAAU;AACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}