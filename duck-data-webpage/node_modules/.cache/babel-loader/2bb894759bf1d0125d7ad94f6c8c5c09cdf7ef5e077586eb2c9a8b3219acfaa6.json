{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* global importScripts */\nimport { isBrowser, isWorker } from \"../env-utils/globals.js\";\nimport { assert } from \"../env-utils/assert.js\";\nimport { VERSION } from \"../env-utils/version.js\";\nconst loadLibraryPromises = {}; // promises\n/**\n * Dynamically loads a library (\"module\")\n *\n * - wasm library: Array buffer is returned\n * - js library: Parse JS is returned\n *\n * Method depends on environment\n * - browser - script element is created and installed on document\n * - worker - eval is called on global context\n * - node - file is required\n *\n * @param libraryUrl\n * @param moduleName\n * @param options\n */\nexport async function loadLibrary(libraryUrl, moduleName = null, options = {}, libraryName = null) {\n  if (moduleName) {\n    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options, libraryName);\n  }\n  // Ensure libraries are only loaded once\n  loadLibraryPromises[libraryUrl] =\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);\n  return await loadLibraryPromises[libraryUrl];\n}\n// TODO - sort out how to resolve paths for main/worker and dev/prod\nexport function getLibraryUrl(library, moduleName, options = {}, libraryName = null) {\n  // Check if already a URL\n  if (!options.useLocalLibraries && library.startsWith('http')) {\n    return library;\n  }\n  libraryName = libraryName || library;\n  // Allow application to import and supply libraries through `options.modules`\n  // TODO - See js-module-utils in loader-utils\n  const modules = options.modules || {};\n  if (modules[libraryName]) {\n    return modules[libraryName];\n  }\n  // Load from local files, not from CDN scripts in Node.js\n  // TODO - needs to locate the modules directory when installed!\n  if (!isBrowser) {\n    return `modules/${moduleName}/dist/libs/${libraryName}`;\n  }\n  // In browser, load from external scripts\n  if (options.CDN) {\n    assert(options.CDN.startsWith('http'));\n    return `${options.CDN}/${moduleName}@${VERSION}/dist/libs/${libraryName}`;\n  }\n  // TODO - loading inside workers requires paths relative to worker script location...\n  if (isWorker) {\n    return `../src/libs/${libraryName}`;\n  }\n  return `modules/${moduleName}/src/libs/${libraryName}`;\n}\nasync function loadLibraryFromFile(libraryUrl) {\n  if (libraryUrl.endsWith('wasm')) {\n    return await loadAsArrayBuffer(libraryUrl);\n  }\n  if (!isBrowser) {\n    // TODO - Node doesn't yet support dynamic import from https URLs\n    // try {\n    //   return await import(libraryUrl);\n    // } catch (error) {\n    //   console.error(error);\n    // }\n    try {\n      const {\n        requireFromFile\n      } = globalThis.loaders || {};\n      return await requireFromFile?.(libraryUrl);\n    } catch (error) {\n      console.error(error); // eslint-disable-line no-console\n      return null;\n    }\n  }\n  if (isWorker) {\n    return importScripts(libraryUrl);\n  }\n  // TODO - fix - should be more secure than string parsing since observes CORS\n  // if (isBrowser) {\n  //   return await loadScriptFromFile(libraryUrl);\n  // }\n  const scriptSource = await loadAsText(libraryUrl);\n  return loadLibraryFromString(scriptSource, libraryUrl);\n}\n/*\nasync function loadScriptFromFile(libraryUrl) {\n  const script = document.createElement('script');\n  script.src = libraryUrl;\n  return await new Promise((resolve, reject) => {\n    script.onload = data => {\n      resolve(data);\n    };\n    script.onerror = reject;\n  });\n}\n*/\n// TODO - Needs security audit...\n//  - Raw eval call\n//  - Potentially bypasses CORS\n// Upside is that this separates fetching and parsing\n// we could create a`LibraryLoader` or`ModuleLoader`\nfunction loadLibraryFromString(scriptSource, id) {\n  if (!isBrowser) {\n    const {\n      requireFromString\n    } = globalThis.loaders || {};\n    return requireFromString?.(scriptSource, id);\n  }\n  if (isWorker) {\n    // Use lvalue trick to make eval run in global scope\n    eval.call(globalThis, scriptSource); // eslint-disable-line no-eval\n    // https://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript\n    // http://perfectionkills.com/global-eval-what-are-the-options/\n    return null;\n  }\n  const script = document.createElement('script');\n  script.id = id;\n  // most browsers like a separate text node but some throw an error. The second method covers those.\n  try {\n    script.appendChild(document.createTextNode(scriptSource));\n  } catch (e) {\n    script.text = scriptSource;\n  }\n  document.body.appendChild(script);\n  return null;\n}\n// TODO - technique for module injection into worker, from THREE.DracoLoader...\n/*\nfunction combineWorkerWithLibrary(worker, jsContent) {\n  var fn = wWorker.toString();\n  var body = [\n    '// injected',\n    jsContent,\n    '',\n    '// worker',\n    fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))\n  ].join('\\n');\n  this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n}\n*/\nasync function loadAsArrayBuffer(url) {\n  const {\n    readFileAsArrayBuffer\n  } = globalThis.loaders || {};\n  if (isBrowser || !readFileAsArrayBuffer || url.startsWith('http')) {\n    const response = await fetch(url);\n    return await response.arrayBuffer();\n  }\n  return await readFileAsArrayBuffer(url);\n}\n/**\n * Load a file from local file system\n * @param filename\n * @returns\n */\nasync function loadAsText(url) {\n  const {\n    readFileAsText\n  } = globalThis.loaders || {};\n  if (isBrowser || !readFileAsText || url.startsWith('http')) {\n    const response = await fetch(url);\n    return await response.text();\n  }\n  return await readFileAsText(url);\n}","map":{"version":3,"names":["isBrowser","isWorker","assert","VERSION","loadLibraryPromises","loadLibrary","libraryUrl","moduleName","options","libraryName","getLibraryUrl","loadLibraryFromFile","library","useLocalLibraries","startsWith","modules","CDN","endsWith","loadAsArrayBuffer","requireFromFile","globalThis","loaders","error","console","importScripts","scriptSource","loadAsText","loadLibraryFromString","id","requireFromString","eval","call","script","document","createElement","appendChild","createTextNode","e","text","body","url","readFileAsArrayBuffer","response","fetch","arrayBuffer","readFileAsText"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/worker-utils/dist/lib/library-utils/library-utils.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* global importScripts */\nimport { isBrowser, isWorker } from \"../env-utils/globals.js\";\nimport { assert } from \"../env-utils/assert.js\";\nimport { VERSION } from \"../env-utils/version.js\";\nconst loadLibraryPromises = {}; // promises\n/**\n * Dynamically loads a library (\"module\")\n *\n * - wasm library: Array buffer is returned\n * - js library: Parse JS is returned\n *\n * Method depends on environment\n * - browser - script element is created and installed on document\n * - worker - eval is called on global context\n * - node - file is required\n *\n * @param libraryUrl\n * @param moduleName\n * @param options\n */\nexport async function loadLibrary(libraryUrl, moduleName = null, options = {}, libraryName = null) {\n    if (moduleName) {\n        libraryUrl = getLibraryUrl(libraryUrl, moduleName, options, libraryName);\n    }\n    // Ensure libraries are only loaded once\n    loadLibraryPromises[libraryUrl] =\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);\n    return await loadLibraryPromises[libraryUrl];\n}\n// TODO - sort out how to resolve paths for main/worker and dev/prod\nexport function getLibraryUrl(library, moduleName, options = {}, libraryName = null) {\n    // Check if already a URL\n    if (!options.useLocalLibraries && library.startsWith('http')) {\n        return library;\n    }\n    libraryName = libraryName || library;\n    // Allow application to import and supply libraries through `options.modules`\n    // TODO - See js-module-utils in loader-utils\n    const modules = options.modules || {};\n    if (modules[libraryName]) {\n        return modules[libraryName];\n    }\n    // Load from local files, not from CDN scripts in Node.js\n    // TODO - needs to locate the modules directory when installed!\n    if (!isBrowser) {\n        return `modules/${moduleName}/dist/libs/${libraryName}`;\n    }\n    // In browser, load from external scripts\n    if (options.CDN) {\n        assert(options.CDN.startsWith('http'));\n        return `${options.CDN}/${moduleName}@${VERSION}/dist/libs/${libraryName}`;\n    }\n    // TODO - loading inside workers requires paths relative to worker script location...\n    if (isWorker) {\n        return `../src/libs/${libraryName}`;\n    }\n    return `modules/${moduleName}/src/libs/${libraryName}`;\n}\nasync function loadLibraryFromFile(libraryUrl) {\n    if (libraryUrl.endsWith('wasm')) {\n        return await loadAsArrayBuffer(libraryUrl);\n    }\n    if (!isBrowser) {\n        // TODO - Node doesn't yet support dynamic import from https URLs\n        // try {\n        //   return await import(libraryUrl);\n        // } catch (error) {\n        //   console.error(error);\n        // }\n        try {\n            const { requireFromFile } = globalThis.loaders || {};\n            return await requireFromFile?.(libraryUrl);\n        }\n        catch (error) {\n            console.error(error); // eslint-disable-line no-console\n            return null;\n        }\n    }\n    if (isWorker) {\n        return importScripts(libraryUrl);\n    }\n    // TODO - fix - should be more secure than string parsing since observes CORS\n    // if (isBrowser) {\n    //   return await loadScriptFromFile(libraryUrl);\n    // }\n    const scriptSource = await loadAsText(libraryUrl);\n    return loadLibraryFromString(scriptSource, libraryUrl);\n}\n/*\nasync function loadScriptFromFile(libraryUrl) {\n  const script = document.createElement('script');\n  script.src = libraryUrl;\n  return await new Promise((resolve, reject) => {\n    script.onload = data => {\n      resolve(data);\n    };\n    script.onerror = reject;\n  });\n}\n*/\n// TODO - Needs security audit...\n//  - Raw eval call\n//  - Potentially bypasses CORS\n// Upside is that this separates fetching and parsing\n// we could create a`LibraryLoader` or`ModuleLoader`\nfunction loadLibraryFromString(scriptSource, id) {\n    if (!isBrowser) {\n        const { requireFromString } = globalThis.loaders || {};\n        return requireFromString?.(scriptSource, id);\n    }\n    if (isWorker) {\n        // Use lvalue trick to make eval run in global scope\n        eval.call(globalThis, scriptSource); // eslint-disable-line no-eval\n        // https://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript\n        // http://perfectionkills.com/global-eval-what-are-the-options/\n        return null;\n    }\n    const script = document.createElement('script');\n    script.id = id;\n    // most browsers like a separate text node but some throw an error. The second method covers those.\n    try {\n        script.appendChild(document.createTextNode(scriptSource));\n    }\n    catch (e) {\n        script.text = scriptSource;\n    }\n    document.body.appendChild(script);\n    return null;\n}\n// TODO - technique for module injection into worker, from THREE.DracoLoader...\n/*\nfunction combineWorkerWithLibrary(worker, jsContent) {\n  var fn = wWorker.toString();\n  var body = [\n    '// injected',\n    jsContent,\n    '',\n    '// worker',\n    fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))\n  ].join('\\n');\n  this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n}\n*/\nasync function loadAsArrayBuffer(url) {\n    const { readFileAsArrayBuffer } = globalThis.loaders || {};\n    if (isBrowser || !readFileAsArrayBuffer || url.startsWith('http')) {\n        const response = await fetch(url);\n        return await response.arrayBuffer();\n    }\n    return await readFileAsArrayBuffer(url);\n}\n/**\n * Load a file from local file system\n * @param filename\n * @returns\n */\nasync function loadAsText(url) {\n    const { readFileAsText } = globalThis.loaders || {};\n    if (isBrowser || !readFileAsText || url.startsWith('http')) {\n        const response = await fetch(url);\n        return await response.text();\n    }\n    return await readFileAsText(url);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}