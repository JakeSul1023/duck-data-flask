{"ast":null,"code":"/* global setTimeout, clearTimeout */\nimport { Recognizer } from \"../recognizer/recognizer.js\";\nimport { TOUCH_ACTION_MANIPULATION } from \"../touchaction/touchaction-Consts.js\";\nimport { InputEvent } from \"../input/input-consts.js\";\nimport { RecognizerState } from \"../recognizer/recognizer-state.js\";\nimport { getPointDistance } from \"../input/get-distance.js\";\n/**\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n */\nexport class TapRecognizer extends Recognizer {\n  constructor(options = {}) {\n    super({\n      enable: true,\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      time: 250,\n      threshold: 9,\n      posThreshold: 10,\n      ...options\n    });\n    /** previous time for tap counting */\n    this.pTime = null;\n    /** previous center for tap counting */\n    this.pCenter = null;\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n  getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  }\n  process(input) {\n    const {\n      options\n    } = this;\n    const validPointers = input.pointers.length === options.pointers;\n    const validMovement = input.distance < options.threshold;\n    const validTouchTime = input.deltaTime < options.time;\n    this.reset();\n    if (input.eventType & InputEvent.Start && this.count === 0) {\n      return this.failTimeout();\n    }\n    // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== InputEvent.End) {\n        return this.failTimeout();\n      }\n      const validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n      const validMultiTap = !this.pCenter || getPointDistance(this.pCenter, input.center) < options.posThreshold;\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n      this._input = input;\n      // if tap count matches we have recognized it,\n      // else it has began recognizing...\n      const tapCount = this.count % options.taps;\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return RecognizerState.Recognized;\n        }\n        this._timer = setTimeout(() => {\n          this.state = RecognizerState.Recognized;\n          this.tryEmit(this._input);\n        }, options.interval);\n        return RecognizerState.Began;\n      }\n    }\n    return RecognizerState.Failed;\n  }\n  failTimeout() {\n    this._timer = setTimeout(() => {\n      this.state = RecognizerState.Failed;\n    }, this.options.interval);\n    return RecognizerState.Failed;\n  }\n  reset() {\n    clearTimeout(this._timer);\n  }\n  emit(input) {\n    if (this.state === RecognizerState.Recognized) {\n      input.tapCount = this.count;\n      this.manager.emit(this.options.event, input);\n    }\n  }\n}","map":{"version":3,"names":["Recognizer","TOUCH_ACTION_MANIPULATION","InputEvent","RecognizerState","getPointDistance","TapRecognizer","constructor","options","enable","event","pointers","taps","interval","time","threshold","posThreshold","pTime","pCenter","_timer","_input","count","getTouchAction","process","input","validPointers","length","validMovement","distance","validTouchTime","deltaTime","reset","eventType","Start","failTimeout","End","validInterval","timeStamp","validMultiTap","center","tapCount","hasRequireFailures","Recognized","setTimeout","state","tryEmit","Began","Failed","clearTimeout","emit","manager"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\mjolnir.js\\src\\hammerjs\\recognizers\\tap.ts"],"sourcesContent":["/* global setTimeout, clearTimeout */\nimport {Recognizer} from '../recognizer/recognizer';\nimport {TOUCH_ACTION_MANIPULATION} from '../touchaction/touchaction-Consts';\nimport {InputEvent} from '../input/input-consts';\nimport {RecognizerState} from '../recognizer/recognizer-state';\nimport {getPointDistance} from '../input/get-distance';\nimport type {Point, HammerInput} from '../input/types';\n\nexport type TapRecognizerOptions = {\n  /** Name of the event.\n   * @default 'tap'\n   */\n  event?: string;\n  /** Enable this event.\n   * @default true\n   */\n  enable?: boolean;\n  /** Required pointers.\n   * @default 1\n   */\n  pointers?: number;\n  /** Required number of taps in succession.\n   * @default 1\n   */\n  taps?: number;\n  /** Maximum time in ms between multiple taps.\n   * @default 300\n   */\n  interval?: number;\n  /** Maximum press time in ms.\n   * @default 250\n   */\n  time?: number;\n  /** While doing a tap some small movement is allowed.\n   * @default 9\n   */\n  threshold?: number;\n  /** The maximum position difference between multiple taps.\n   * @default 10\n   */\n  posThreshold?: number;\n};\n\n/**\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n */\nexport class TapRecognizer extends Recognizer<Required<TapRecognizerOptions>> {\n  /** previous time for tap counting */\n  private pTime: number | null = null;\n  /** previous center for tap counting */\n  private pCenter: Point | null = null;\n\n  private _timer: any = null;\n  private _input: HammerInput | null = null;\n\n  private count: number = 0;\n\n  constructor(options: TapRecognizerOptions = {}) {\n    super({\n      enable: true,\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      time: 250,\n      threshold: 9,\n      posThreshold: 10,\n      ...options\n    });\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  }\n\n  process(input: HammerInput) {\n    const {options} = this;\n\n    const validPointers = input.pointers.length === options.pointers;\n    const validMovement = input.distance < options.threshold;\n    const validTouchTime = input.deltaTime < options.time;\n\n    this.reset();\n\n    if (input.eventType & InputEvent.Start && this.count === 0) {\n      return this.failTimeout();\n    }\n\n    // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== InputEvent.End) {\n        return this.failTimeout();\n      }\n\n      const validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n      const validMultiTap =\n        !this.pCenter || getPointDistance(this.pCenter, input.center) < options.posThreshold;\n\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n\n      this._input = input;\n\n      // if tap count matches we have recognized it,\n      // else it has began recognizing...\n      const tapCount = this.count % options.taps;\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return RecognizerState.Recognized;\n        }\n        this._timer = setTimeout(() => {\n          this.state = RecognizerState.Recognized;\n          this.tryEmit(this._input!);\n        }, options.interval);\n        return RecognizerState.Began;\n      }\n    }\n    return RecognizerState.Failed;\n  }\n\n  failTimeout() {\n    this._timer = setTimeout(() => {\n      this.state = RecognizerState.Failed;\n    }, this.options.interval);\n    return RecognizerState.Failed;\n  }\n\n  reset() {\n    clearTimeout(this._timer);\n  }\n\n  emit(input: HammerInput) {\n    if (this.state === RecognizerState.Recognized) {\n      input.tapCount = this.count;\n      this.manager.emit(this.options.event, input);\n    }\n  }\n}\n"],"mappings":"AAAA;AACA,SAAQA,UAAU,QAAC;AACnB,SAAQC,yBAAyB,QAAC;AAClC,SAAQC,UAAU,QAAC;AACnB,SAAQC,eAAe,QAAC;AACxB,SAAQC,gBAAgB,QAAC;AAsCzB;;;;;;;;AAQA,OAAM,MAAOC,aAAc,SAAQL,UAA0C;EAW3EM,YAAYC,OAAA,GAAgC,EAAE;IAC5C,KAAK,CAAC;MACJC,MAAM,EAAE,IAAI;MACZC,KAAK,EAAE,KAAK;MACZC,QAAQ,EAAE,CAAC;MACXC,IAAI,EAAE,CAAC;MACPC,QAAQ,EAAE,GAAG;MACbC,IAAI,EAAE,GAAG;MACTC,SAAS,EAAE,CAAC;MACZC,YAAY,EAAE,EAAE;MAChB,GAAGR;KACJ,CAAC;IArBJ;IACQ,KAAAS,KAAK,GAAkB,IAAI;IACnC;IACQ,KAAAC,OAAO,GAAiB,IAAI;IAE5B,KAAAC,MAAM,GAAQ,IAAI;IAClB,KAAAC,MAAM,GAAuB,IAAI;IAEjC,KAAAC,KAAK,GAAW,CAAC;EAczB;EAEAC,cAAcA,CAAA;IACZ,OAAO,CAACpB,yBAAyB,CAAC;EACpC;EAEAqB,OAAOA,CAACC,KAAkB;IACxB,MAAM;MAAChB;IAAO,CAAC,GAAG,IAAI;IAEtB,MAAMiB,aAAa,GAAGD,KAAK,CAACb,QAAQ,CAACe,MAAM,KAAKlB,OAAO,CAACG,QAAQ;IAChE,MAAMgB,aAAa,GAAGH,KAAK,CAACI,QAAQ,GAAGpB,OAAO,CAACO,SAAS;IACxD,MAAMc,cAAc,GAAGL,KAAK,CAACM,SAAS,GAAGtB,OAAO,CAACM,IAAI;IAErD,IAAI,CAACiB,KAAK,EAAE;IAEZ,IAAIP,KAAK,CAACQ,SAAS,GAAG7B,UAAU,CAAC8B,KAAK,IAAI,IAAI,CAACZ,KAAK,KAAK,CAAC,EAAE;MAC1D,OAAO,IAAI,CAACa,WAAW,EAAE;IAC3B;IAEA;IACA;IACA,IAAIP,aAAa,IAAIE,cAAc,IAAIJ,aAAa,EAAE;MACpD,IAAID,KAAK,CAACQ,SAAS,KAAK7B,UAAU,CAACgC,GAAG,EAAE;QACtC,OAAO,IAAI,CAACD,WAAW,EAAE;MAC3B;MAEA,MAAME,aAAa,GAAG,IAAI,CAACnB,KAAK,GAAGO,KAAK,CAACa,SAAS,GAAG,IAAI,CAACpB,KAAK,GAAGT,OAAO,CAACK,QAAQ,GAAG,IAAI;MACzF,MAAMyB,aAAa,GACjB,CAAC,IAAI,CAACpB,OAAO,IAAIb,gBAAgB,CAAC,IAAI,CAACa,OAAO,EAAEM,KAAK,CAACe,MAAM,CAAC,GAAG/B,OAAO,CAACQ,YAAY;MAEtF,IAAI,CAACC,KAAK,GAAGO,KAAK,CAACa,SAAS;MAC5B,IAAI,CAACnB,OAAO,GAAGM,KAAK,CAACe,MAAM;MAE3B,IAAI,CAACD,aAAa,IAAI,CAACF,aAAa,EAAE;QACpC,IAAI,CAACf,KAAK,GAAG,CAAC;MAChB,CAAC,MAAM;QACL,IAAI,CAACA,KAAK,IAAI,CAAC;MACjB;MAEA,IAAI,CAACD,MAAM,GAAGI,KAAK;MAEnB;MACA;MACA,MAAMgB,QAAQ,GAAG,IAAI,CAACnB,KAAK,GAAGb,OAAO,CAACI,IAAI;MAC1C,IAAI4B,QAAQ,KAAK,CAAC,EAAE;QAClB;QACA;QACA,IAAI,CAAC,IAAI,CAACC,kBAAkB,EAAE,EAAE;UAC9B,OAAOrC,eAAe,CAACsC,UAAU;QACnC;QACA,IAAI,CAACvB,MAAM,GAAGwB,UAAU,CAAC,MAAK;UAC5B,IAAI,CAACC,KAAK,GAAGxC,eAAe,CAACsC,UAAU;UACvC,IAAI,CAACG,OAAO,CAAC,IAAI,CAACzB,MAAO,CAAC;QAC5B,CAAC,EAAEZ,OAAO,CAACK,QAAQ,CAAC;QACpB,OAAOT,eAAe,CAAC0C,KAAK;MAC9B;IACF;IACA,OAAO1C,eAAe,CAAC2C,MAAM;EAC/B;EAEAb,WAAWA,CAAA;IACT,IAAI,CAACf,MAAM,GAAGwB,UAAU,CAAC,MAAK;MAC5B,IAAI,CAACC,KAAK,GAAGxC,eAAe,CAAC2C,MAAM;IACrC,CAAC,EAAE,IAAI,CAACvC,OAAO,CAACK,QAAQ,CAAC;IACzB,OAAOT,eAAe,CAAC2C,MAAM;EAC/B;EAEAhB,KAAKA,CAAA;IACHiB,YAAY,CAAC,IAAI,CAAC7B,MAAM,CAAC;EAC3B;EAEA8B,IAAIA,CAACzB,KAAkB;IACrB,IAAI,IAAI,CAACoB,KAAK,KAAKxC,eAAe,CAACsC,UAAU,EAAE;MAC7ClB,KAAK,CAACgB,QAAQ,GAAG,IAAI,CAACnB,KAAK;MAC3B,IAAI,CAAC6B,OAAO,CAACD,IAAI,CAAC,IAAI,CAACzC,OAAO,CAACE,KAAK,EAAEc,KAAK,CAAC;IAC9C;EACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}