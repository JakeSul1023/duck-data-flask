{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT and ISC\n// Copyright (c) vis.gl contributors\nimport { getPolygonSignedArea, DimIndex } from \"./polygon-utils.js\";\n/**\n * Computes a triangulation of a polygon\n * @param positions a flat array of the vertex positions that define the polygon.\n * @param holeIndices an array of hole indices if any (e.g. [5, 8] for a 12-vertex input would mean one hole with vertices 5–7 and another with 8–11).\n * @param dim the number of elements in each vertex. Size `2` will interpret `positions` as `[x0, y0, x1, y1, ...]` and size `3` will interpret `positions` as `[x0, y0, z0, x1, y1, z1, ...]`. Default `2`.\n * @param areas areas of outer polygon and holes as computed by `getPolygonSignedArea()`. Can be optionally supplied to speed up triangulation\n * @returns array of indices into the `positions` array that describes the triangulation of the polygon\n * Adapted from https://github.com/mapbox/earcut\n */\nexport function earcut(positions, holeIndices, dim = 2, areas, plane = 'xy') {\n  const hasHoles = holeIndices && holeIndices.length;\n  const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;\n  let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0], plane);\n  const triangles = [];\n  if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n  let invSize;\n  let maxX;\n  let maxY;\n  let minX;\n  let minY;\n  let x;\n  let y;\n  if (hasHoles) outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas, plane);\n  // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n  if (positions.length > 80 * dim) {\n    minX = maxX = positions[0];\n    minY = maxY = positions[1];\n    for (let i = dim; i < outerLen; i += dim) {\n      x = positions[i];\n      y = positions[i + 1];\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n    }\n    // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n    invSize = Math.max(maxX - minX, maxY - minY);\n    invSize = invSize !== 0 ? 32767 / invSize : 0;\n  }\n  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n  return triangles;\n}\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise, area, plane) {\n  let i;\n  let last;\n  if (area === undefined) {\n    area = getPolygonSignedArea(data, {\n      start,\n      end,\n      size: dim,\n      plane\n    });\n  }\n  let i0 = DimIndex[plane[0]];\n  let i1 = DimIndex[plane[1]];\n  // Note that the signed area calculation in math.gl\n  // has the opposite sign to that which was originally\n  // present in earcut, thus the `< 0` is reversed\n  if (clockwise === area < 0) {\n    for (i = start; i < end; i += dim) last = insertNode(i, data[i + i0], data[i + i1], last);\n  } else {\n    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i + i0], data[i + i1], last);\n  }\n  if (last && equals(last, last.next)) {\n    removeNode(last);\n    last = last.next;\n  }\n  return last;\n}\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n  if (!start) return start;\n  if (!end) end = start;\n  let p = start;\n  let again;\n  do {\n    again = false;\n    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n      removeNode(p);\n      p = end = p.prev;\n      if (p === p.next) break;\n      again = true;\n    } else {\n      p = p.next;\n    }\n  } while (again || p !== end);\n  return end;\n}\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n  if (!ear) return;\n  // interlink polygon nodes in z-order\n  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n  let stop = ear;\n  let prev;\n  let next;\n  // iterate through ears, slicing them one by one\n  while (ear.prev !== ear.next) {\n    prev = ear.prev;\n    next = ear.next;\n    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n      // cut off the triangle\n      triangles.push(prev.i / dim | 0);\n      triangles.push(ear.i / dim | 0);\n      triangles.push(next.i / dim | 0);\n      removeNode(ear);\n      // skipping the next vertex leads to less sliver triangles\n      ear = next.next;\n      stop = next.next;\n      continue;\n    }\n    ear = next;\n    // if we looped through the whole remaining polygon and can't find any more ears\n    if (ear === stop) {\n      // try filtering points and slicing again\n      if (!pass) {\n        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n        // if this didn't work, try curing all small self-intersections locally\n      } else if (pass === 1) {\n        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n        // as a last resort, try splitting the remaining polygon into two\n      } else if (pass === 2) {\n        splitEarcut(ear, triangles, dim, minX, minY, invSize);\n      }\n      break;\n    }\n  }\n}\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n  const a = ear.prev;\n  const b = ear;\n  const c = ear.next;\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n  // now make sure we don't have other points inside the potential ear\n  const ax = a.x;\n  const bx = b.x;\n  const cx = c.x;\n  const ay = a.y;\n  const by = b.y;\n  const cy = c.y;\n  // triangle bbox; min & max are calculated like this for speed\n  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx;\n  const y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy;\n  const x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx;\n  const y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n  let p = c.next;\n  while (p !== a) {\n    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.next;\n  }\n  return true;\n}\nfunction isEarHashed(ear, minX, minY, invSize) {\n  const a = ear.prev;\n  const b = ear;\n  const c = ear.next;\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n  const ax = a.x;\n  const bx = b.x;\n  const cx = c.x;\n  const ay = a.y;\n  const by = b.y;\n  const cy = c.y;\n  // triangle bbox; min & max are calculated like this for speed\n  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx;\n  const y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy;\n  const x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx;\n  const y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n  // z-order range for the current triangle bbox;\n  const minZ = zOrder(x0, y0, minX, minY, invSize);\n  const maxZ = zOrder(x1, y1, minX, minY, invSize);\n  let p = ear.prevZ;\n  let n = ear.nextZ;\n  // look for points inside the triangle in both directions\n  while (p && p.z >= minZ && n && n.z <= maxZ) {\n    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  }\n  // look for remaining points in decreasing z-order\n  while (p && p.z >= minZ) {\n    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n  }\n  // look for remaining points in increasing z-order\n  while (n && n.z <= maxZ) {\n    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  }\n  return true;\n}\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n  let p = start;\n  do {\n    const a = p.prev;\n    const b = p.next.next;\n    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n      triangles.push(a.i / dim | 0);\n      triangles.push(p.i / dim | 0);\n      triangles.push(b.i / dim | 0);\n      // remove two nodes involved\n      removeNode(p);\n      removeNode(p.next);\n      p = start = b;\n    }\n    p = p.next;\n  } while (p !== start);\n  return filterPoints(p);\n}\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n  // look for a valid diagonal that divides the polygon into two\n  let a = start;\n  do {\n    let b = a.next.next;\n    while (b !== a.prev) {\n      if (a.i !== b.i && isValidDiagonal(a, b)) {\n        // split the polygon in two by the diagonal\n        let c = splitPolygon(a, b);\n        // filter colinear points around the cuts\n        a = filterPoints(a, a.next);\n        c = filterPoints(c, c.next);\n        // run earcut on each half\n        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n        return;\n      }\n      b = b.next;\n    }\n    a = a.next;\n  } while (a !== start);\n}\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim, areas, plane) {\n  const queue = [];\n  let i;\n  let len;\n  let start;\n  let end;\n  let list;\n  for (i = 0, len = holeIndices.length; i < len; i++) {\n    start = holeIndices[i] * dim;\n    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n    list = linkedList(data, start, end, dim, false, areas && areas[i + 1], plane);\n    if (list === list.next) list.steiner = true;\n    queue.push(getLeftmost(list));\n  }\n  queue.sort(compareX);\n  // process holes from left to right\n  for (i = 0; i < queue.length; i++) {\n    outerNode = eliminateHole(queue[i], outerNode);\n  }\n  return outerNode;\n}\nfunction compareX(a, b) {\n  return a.x - b.x;\n}\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n  const bridge = findHoleBridge(hole, outerNode);\n  if (!bridge) {\n    return outerNode;\n  }\n  const bridgeReverse = splitPolygon(bridge, hole);\n  // filter collinear points around the cuts\n  filterPoints(bridgeReverse, bridgeReverse.next);\n  return filterPoints(bridge, bridge.next);\n}\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n  let p = outerNode;\n  const hx = hole.x;\n  const hy = hole.y;\n  let qx = -Infinity;\n  let m;\n  // find a segment intersected by a ray from the hole's leftmost point to the left;\n  // segment's endpoint with lesser x will be potential connection point\n  do {\n    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n      if (x <= hx && x > qx) {\n        qx = x;\n        m = p.x < p.next.x ? p : p.next;\n        if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n      }\n    }\n    p = p.next;\n  } while (p !== outerNode);\n  if (!m) return null;\n  // look for points inside the triangle of hole point, segment intersection and endpoint;\n  // if there are no points found, we have a valid connection;\n  // otherwise choose the point of the minimum angle with the ray as connection point\n  const stop = m;\n  const mx = m.x;\n  const my = m.y;\n  let tanMin = Infinity;\n  let tan;\n  p = m;\n  do {\n    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {\n        m = p;\n        tanMin = tan;\n      }\n    }\n    p = p.next;\n  } while (p !== stop);\n  return m;\n}\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n  let p = start;\n  do {\n    if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n    p.prevZ = p.prev;\n    p.nextZ = p.next;\n    p = p.next;\n  } while (p !== start);\n  p.prevZ.nextZ = null;\n  p.prevZ = null;\n  sortLinked(p);\n}\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n  let e;\n  let i;\n  let inSize = 1;\n  let numMerges;\n  let p;\n  let pSize;\n  let q;\n  let qSize;\n  let tail;\n  do {\n    p = list;\n    list = null;\n    tail = null;\n    numMerges = 0;\n    while (p) {\n      numMerges++;\n      q = p;\n      pSize = 0;\n      for (i = 0; i < inSize; i++) {\n        pSize++;\n        q = q.nextZ;\n        if (!q) break;\n      }\n      qSize = inSize;\n      while (pSize > 0 || qSize > 0 && q) {\n        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n          e = p;\n          p = p.nextZ;\n          pSize--;\n        } else {\n          e = q;\n          q = q.nextZ;\n          qSize--;\n        }\n        if (tail) tail.nextZ = e;else list = e;\n        e.prevZ = tail;\n        tail = e;\n      }\n      p = q;\n    }\n    tail.nextZ = null;\n    inSize *= 2;\n  } while (numMerges > 1);\n  return list;\n}\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n  // coords are transformed into non-negative 15-bit integer range\n  x = (x - minX) * invSize | 0;\n  y = (y - minY) * invSize | 0;\n  x = (x | x << 8) & 0x00ff00ff;\n  x = (x | x << 4) & 0x0f0f0f0f;\n  x = (x | x << 2) & 0x33333333;\n  x = (x | x << 1) & 0x55555555;\n  y = (y | y << 8) & 0x00ff00ff;\n  y = (y | y << 4) & 0x0f0f0f0f;\n  y = (y | y << 2) & 0x33333333;\n  y = (y | y << 1) & 0x55555555;\n  return x | y << 1;\n}\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n  let p = start;\n  let leftmost = start;\n  do {\n    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n    p = p.next;\n  } while (p !== start);\n  return leftmost;\n}\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (\n  // dones't intersect other edges\n  locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (\n  // locally visible\n  area(a.prev, a, b.prev) || area(a, b.prev, b)) ||\n  // does not create opposite-facing sectors\n  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n// signed area of a triangle\nfunction area(p, q, r) {\n  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n// check if two points are equal\nfunction equals(p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n}\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n  const o1 = sign(area(p1, q1, p2));\n  const o2 = sign(area(p1, q1, q2));\n  const o3 = sign(area(p2, q2, p1));\n  const o4 = sign(area(p2, q2, q1));\n  if (o1 !== o2 && o3 !== o4) return true; // general case\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n  return false;\n}\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\nfunction sign(num) {\n  return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n  let p = a;\n  do {\n    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;\n    p = p.next;\n  } while (p !== a);\n  return false;\n}\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n  let p = a;\n  let inside = false;\n  const px = (a.x + b.x) / 2;\n  const py = (a.y + b.y) / 2;\n  do {\n    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n    p = p.next;\n  } while (p !== a);\n  return inside;\n}\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n  const a2 = new Vertex(a.i, a.x, a.y);\n  const b2 = new Vertex(b.i, b.x, b.y);\n  const an = a.next;\n  const bp = b.prev;\n  a.next = b;\n  b.prev = a;\n  a2.next = an;\n  an.prev = a2;\n  b2.next = a2;\n  a2.prev = b2;\n  bp.next = b2;\n  b2.prev = bp;\n  return b2;\n}\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n  const p = new Vertex(i, x, y);\n  if (!last) {\n    p.prev = p;\n    p.next = p;\n  } else {\n    p.next = last.next;\n    p.prev = last;\n    last.next.prev = p;\n    last.next = p;\n  }\n  return p;\n}\nfunction removeNode(p) {\n  p.next.prev = p.prev;\n  p.prev.next = p.next;\n  if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n  if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\nclass Vertex {\n  constructor(i, x, y) {\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n    // z-order curve value\n    this.z = 0;\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n    // indicates whether this is a steiner point\n    this.steiner = false;\n    this.i = i;\n    this.x = x;\n    this.y = y;\n  }\n}","map":{"version":3,"names":["getPolygonSignedArea","DimIndex","earcut","positions","holeIndices","dim","areas","plane","hasHoles","length","outerLen","outerNode","linkedList","triangles","next","prev","invSize","maxX","maxY","minX","minY","x","y","eliminateHoles","i","Math","max","earcutLinked","data","start","end","clockwise","area","last","undefined","size","i0","i1","insertNode","equals","removeNode","filterPoints","p","again","steiner","ear","pass","indexCurve","stop","isEarHashed","isEar","push","cureLocalIntersections","splitEarcut","a","b","c","ax","bx","cx","ay","by","cy","x0","y0","x1","y1","pointInTriangle","minZ","zOrder","maxZ","prevZ","n","nextZ","z","intersects","locallyInside","isValidDiagonal","splitPolygon","queue","len","list","getLeftmost","sort","compareX","eliminateHole","hole","bridge","findHoleBridge","bridgeReverse","hx","hy","qx","Infinity","m","mx","my","tanMin","tan","abs","sectorContainsSector","sortLinked","e","inSize","numMerges","pSize","q","qSize","tail","leftmost","px","py","intersectsPolygon","middleInside","r","p1","p2","q1","q2","o1","sign","o2","o3","o4","onSegment","min","num","inside","a2","Vertex","b2","an","bp","constructor"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\polygon\\src\\earcut.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT and ISC\n// Copyright (c) vis.gl contributors\n\n/*\n  Adapted from https://github.com/mapbox/earcut to allow passing in\n  of outline and hole areas using the `areas` parameter. As the\n  areas are calcuted as part of classifying the polygon rings\n  we can pass them in again to avoid recomputation\n\n  ISC License\n\n  Copyright (c) 2016, Mapbox\n\n  Permission to use, copy, modify, and/or distribute this software for any purpose\n  with or without fee is hereby granted, provided that the above copyright notice\n  and this permission notice appear in all copies.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n  FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n  THIS SOFTWARE.\n\n */\n\n// @ts-nocheck\n\n/* eslint-disable */\n\nimport type {NumericArray} from '@math.gl/core';\nimport {getPolygonSignedArea, DimIndex, Plane2D} from './polygon-utils';\n\n/**\n * Computes a triangulation of a polygon\n * @param positions a flat array of the vertex positions that define the polygon.\n * @param holeIndices an array of hole indices if any (e.g. [5, 8] for a 12-vertex input would mean one hole with vertices 5–7 and another with 8–11).\n * @param dim the number of elements in each vertex. Size `2` will interpret `positions` as `[x0, y0, x1, y1, ...]` and size `3` will interpret `positions` as `[x0, y0, z0, x1, y1, z1, ...]`. Default `2`.\n * @param areas areas of outer polygon and holes as computed by `getPolygonSignedArea()`. Can be optionally supplied to speed up triangulation\n * @returns array of indices into the `positions` array that describes the triangulation of the polygon\n * Adapted from https://github.com/mapbox/earcut\n */\nexport function earcut(\n  positions: NumericArray,\n  holeIndices?: NumericArray,\n  dim: number = 2,\n  areas?: NumericArray,\n  plane: Plane2D = 'xy'\n): number[] {\n  const hasHoles = holeIndices && holeIndices.length;\n  const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;\n  let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0], plane);\n  const triangles = [];\n\n  if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n  let invSize;\n  let maxX;\n  let maxY;\n  let minX;\n  let minY;\n  let x;\n  let y;\n\n  if (hasHoles) outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas, plane);\n\n  // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n  if (positions.length > 80 * dim) {\n    minX = maxX = positions[0];\n    minY = maxY = positions[1];\n\n    for (let i = dim; i < outerLen; i += dim) {\n      x = positions[i];\n      y = positions[i + 1];\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n    }\n\n    // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n    invSize = Math.max(maxX - minX, maxY - minY);\n    invSize = invSize !== 0 ? 32767 / invSize : 0;\n  }\n\n  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n  return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(\n  data: NumericArray,\n  start: number,\n  end: number,\n  dim: number,\n  clockwise: boolean,\n  area: number | undefined,\n  plane: Plane2D\n): Vertex {\n  let i;\n  let last;\n  if (area === undefined) {\n    area = getPolygonSignedArea(data, {start, end, size: dim, plane});\n  }\n\n  let i0 = DimIndex[plane[0]];\n  let i1 = DimIndex[plane[1]];\n  // Note that the signed area calculation in math.gl\n  // has the opposite sign to that which was originally\n  // present in earcut, thus the `< 0` is reversed\n  if (clockwise === area < 0) {\n    for (i = start; i < end; i += dim) last = insertNode(i, data[i + i0], data[i + i1], last);\n  } else {\n    for (i = end - dim; i >= start; i -= dim)\n      last = insertNode(i, data[i + i0], data[i + i1], last);\n  }\n\n  if (last && equals(last, last.next)) {\n    removeNode(last);\n    last = last.next;\n  }\n\n  return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end?) {\n  if (!start) return start;\n  if (!end) end = start;\n\n  let p = start;\n  let again;\n  do {\n    again = false;\n\n    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n      removeNode(p);\n      p = end = p.prev;\n      if (p === p.next) break;\n      again = true;\n    } else {\n      p = p.next;\n    }\n  } while (again || p !== end);\n\n  return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass?) {\n  if (!ear) return;\n\n  // interlink polygon nodes in z-order\n  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n  let stop = ear;\n  let prev;\n  let next;\n\n  // iterate through ears, slicing them one by one\n  while (ear.prev !== ear.next) {\n    prev = ear.prev;\n    next = ear.next;\n\n    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n      // cut off the triangle\n      triangles.push((prev.i / dim) | 0);\n      triangles.push((ear.i / dim) | 0);\n      triangles.push((next.i / dim) | 0);\n\n      removeNode(ear);\n\n      // skipping the next vertex leads to less sliver triangles\n      ear = next.next;\n      stop = next.next;\n\n      continue;\n    }\n\n    ear = next;\n\n    // if we looped through the whole remaining polygon and can't find any more ears\n    if (ear === stop) {\n      // try filtering points and slicing again\n      if (!pass) {\n        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n        // if this didn't work, try curing all small self-intersections locally\n      } else if (pass === 1) {\n        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n        // as a last resort, try splitting the remaining polygon into two\n      } else if (pass === 2) {\n        splitEarcut(ear, triangles, dim, minX, minY, invSize);\n      }\n\n      break;\n    }\n  }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n  const a = ear.prev;\n  const b = ear;\n  const c = ear.next;\n\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n  // now make sure we don't have other points inside the potential ear\n  const ax = a.x;\n  const bx = b.x;\n  const cx = c.x;\n  const ay = a.y;\n  const by = b.y;\n  const cy = c.y;\n\n  // triangle bbox; min & max are calculated like this for speed\n  const x0 = ax < bx ? (ax < cx ? ax : cx) : bx < cx ? bx : cx;\n  const y0 = ay < by ? (ay < cy ? ay : cy) : by < cy ? by : cy;\n  const x1 = ax > bx ? (ax > cx ? ax : cx) : bx > cx ? bx : cx;\n  const y1 = ay > by ? (ay > cy ? ay : cy) : by > cy ? by : cy;\n\n  let p = c.next;\n  while (p !== a) {\n    if (\n      p.x >= x0 &&\n      p.x <= x1 &&\n      p.y >= y0 &&\n      p.y <= y1 &&\n      pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n      area(p.prev, p, p.next) >= 0\n    )\n      return false;\n    p = p.next;\n  }\n\n  return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n  const a = ear.prev;\n  const b = ear;\n  const c = ear.next;\n\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n  const ax = a.x;\n  const bx = b.x;\n  const cx = c.x;\n  const ay = a.y;\n  const by = b.y;\n  const cy = c.y;\n\n  // triangle bbox; min & max are calculated like this for speed\n  const x0 = ax < bx ? (ax < cx ? ax : cx) : bx < cx ? bx : cx;\n  const y0 = ay < by ? (ay < cy ? ay : cy) : by < cy ? by : cy;\n  const x1 = ax > bx ? (ax > cx ? ax : cx) : bx > cx ? bx : cx;\n  const y1 = ay > by ? (ay > cy ? ay : cy) : by > cy ? by : cy;\n\n  // z-order range for the current triangle bbox;\n  const minZ = zOrder(x0, y0, minX, minY, invSize);\n  const maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n  let p = ear.prevZ;\n  let n = ear.nextZ;\n\n  // look for points inside the triangle in both directions\n  while (p && p.z >= minZ && n && n.z <= maxZ) {\n    if (\n      p.x >= x0 &&\n      p.x <= x1 &&\n      p.y >= y0 &&\n      p.y <= y1 &&\n      p !== a &&\n      p !== c &&\n      pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n      area(p.prev, p, p.next) >= 0\n    )\n      return false;\n    p = p.prevZ;\n\n    if (\n      n.x >= x0 &&\n      n.x <= x1 &&\n      n.y >= y0 &&\n      n.y <= y1 &&\n      n !== a &&\n      n !== c &&\n      pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) &&\n      area(n.prev, n, n.next) >= 0\n    )\n      return false;\n    n = n.nextZ;\n  }\n\n  // look for remaining points in decreasing z-order\n  while (p && p.z >= minZ) {\n    if (\n      p.x >= x0 &&\n      p.x <= x1 &&\n      p.y >= y0 &&\n      p.y <= y1 &&\n      p !== a &&\n      p !== c &&\n      pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n      area(p.prev, p, p.next) >= 0\n    )\n      return false;\n    p = p.prevZ;\n  }\n\n  // look for remaining points in increasing z-order\n  while (n && n.z <= maxZ) {\n    if (\n      n.x >= x0 &&\n      n.x <= x1 &&\n      n.y >= y0 &&\n      n.y <= y1 &&\n      n !== a &&\n      n !== c &&\n      pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) &&\n      area(n.prev, n, n.next) >= 0\n    )\n      return false;\n    n = n.nextZ;\n  }\n\n  return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n  let p = start;\n  do {\n    const a = p.prev;\n    const b = p.next.next;\n\n    if (\n      !equals(a, b) &&\n      intersects(a, p, p.next, b) &&\n      locallyInside(a, b) &&\n      locallyInside(b, a)\n    ) {\n      triangles.push((a.i / dim) | 0);\n      triangles.push((p.i / dim) | 0);\n      triangles.push((b.i / dim) | 0);\n\n      // remove two nodes involved\n      removeNode(p);\n      removeNode(p.next);\n\n      p = start = b;\n    }\n    p = p.next;\n  } while (p !== start);\n\n  return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n  // look for a valid diagonal that divides the polygon into two\n  let a = start;\n  do {\n    let b = a.next.next;\n    while (b !== a.prev) {\n      if (a.i !== b.i && isValidDiagonal(a, b)) {\n        // split the polygon in two by the diagonal\n        let c = splitPolygon(a, b);\n\n        // filter colinear points around the cuts\n        a = filterPoints(a, a.next);\n        c = filterPoints(c, c.next);\n\n        // run earcut on each half\n        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n        return;\n      }\n      b = b.next;\n    }\n    a = a.next;\n  } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(\n  data: NumericArray,\n  holeIndices: NumericArray,\n  outerNode: Vertex,\n  dim: number,\n  areas: NumericArray | undefined,\n  plane: Plane2D\n): Vertex {\n  const queue = [];\n  let i;\n  let len;\n  let start;\n  let end;\n  let list;\n\n  for (i = 0, len = holeIndices.length; i < len; i++) {\n    start = holeIndices[i] * dim;\n    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n    list = linkedList(data, start, end, dim, false, areas && areas[i + 1], plane);\n    if (list === list.next) list.steiner = true;\n    queue.push(getLeftmost(list));\n  }\n\n  queue.sort(compareX);\n\n  // process holes from left to right\n  for (i = 0; i < queue.length; i++) {\n    outerNode = eliminateHole(queue[i], outerNode);\n  }\n\n  return outerNode;\n}\n\nfunction compareX(a, b) {\n  return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n  const bridge = findHoleBridge(hole, outerNode);\n  if (!bridge) {\n    return outerNode;\n  }\n\n  const bridgeReverse = splitPolygon(bridge, hole);\n\n  // filter collinear points around the cuts\n  filterPoints(bridgeReverse, bridgeReverse.next);\n  return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n  let p = outerNode;\n  const hx = hole.x;\n  const hy = hole.y;\n  let qx = -Infinity;\n  let m;\n\n  // find a segment intersected by a ray from the hole's leftmost point to the left;\n  // segment's endpoint with lesser x will be potential connection point\n  do {\n    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n      const x = p.x + ((hy - p.y) * (p.next.x - p.x)) / (p.next.y - p.y);\n      if (x <= hx && x > qx) {\n        qx = x;\n        m = p.x < p.next.x ? p : p.next;\n        if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n      }\n    }\n    p = p.next;\n  } while (p !== outerNode);\n\n  if (!m) return null;\n\n  // look for points inside the triangle of hole point, segment intersection and endpoint;\n  // if there are no points found, we have a valid connection;\n  // otherwise choose the point of the minimum angle with the ray as connection point\n\n  const stop = m;\n  const mx = m.x;\n  const my = m.y;\n  let tanMin = Infinity;\n  let tan;\n\n  p = m;\n\n  do {\n    if (\n      hx >= p.x &&\n      p.x >= mx &&\n      hx !== p.x &&\n      pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)\n    ) {\n      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n      if (\n        locallyInside(p, hole) &&\n        (tan < tanMin ||\n          (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))\n      ) {\n        m = p;\n        tanMin = tan;\n      }\n    }\n\n    p = p.next;\n  } while (p !== stop);\n\n  return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n  let p = start;\n  do {\n    if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n    p.prevZ = p.prev;\n    p.nextZ = p.next;\n    p = p.next;\n  } while (p !== start);\n\n  p.prevZ.nextZ = null;\n  p.prevZ = null;\n\n  sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n  let e;\n  let i;\n  let inSize = 1;\n  let numMerges;\n  let p;\n  let pSize;\n  let q;\n  let qSize;\n  let tail;\n\n  do {\n    p = list;\n    list = null;\n    tail = null;\n    numMerges = 0;\n\n    while (p) {\n      numMerges++;\n      q = p;\n      pSize = 0;\n      for (i = 0; i < inSize; i++) {\n        pSize++;\n        q = q.nextZ;\n        if (!q) break;\n      }\n      qSize = inSize;\n\n      while (pSize > 0 || (qSize > 0 && q)) {\n        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n          e = p;\n          p = p.nextZ;\n          pSize--;\n        } else {\n          e = q;\n          q = q.nextZ;\n          qSize--;\n        }\n\n        if (tail) tail.nextZ = e;\n        else list = e;\n\n        e.prevZ = tail;\n        tail = e;\n      }\n\n      p = q;\n    }\n\n    tail.nextZ = null;\n    inSize *= 2;\n  } while (numMerges > 1);\n\n  return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n  // coords are transformed into non-negative 15-bit integer range\n  x = ((x - minX) * invSize) | 0;\n  y = ((y - minY) * invSize) | 0;\n\n  x = (x | (x << 8)) & 0x00ff00ff;\n  x = (x | (x << 4)) & 0x0f0f0f0f;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n\n  y = (y | (y << 8)) & 0x00ff00ff;\n  y = (y | (y << 4)) & 0x0f0f0f0f;\n  y = (y | (y << 2)) & 0x33333333;\n  y = (y | (y << 1)) & 0x55555555;\n\n  return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n  let p = start;\n  let leftmost = start;\n  do {\n    if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n    p = p.next;\n  } while (p !== start);\n\n  return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n  return (\n    (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n    (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n    (bx - px) * (cy - py) >= (cx - px) * (by - py)\n  );\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n  return (\n    a.next.i !== b.i &&\n    a.prev.i !== b.i &&\n    !intersectsPolygon(a, b) && // dones't intersect other edges\n    ((locallyInside(a, b) &&\n      locallyInside(b, a) &&\n      middleInside(a, b) && // locally visible\n      (area(a.prev, a, b.prev) || area(a, b.prev, b))) || // does not create opposite-facing sectors\n      (equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0))\n  ); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n  const o1 = sign(area(p1, q1, p2));\n  const o2 = sign(area(p1, q1, q2));\n  const o3 = sign(area(p2, q2, p1));\n  const o4 = sign(area(p2, q2, q1));\n\n  if (o1 !== o2 && o3 !== o4) return true; // general case\n\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n  return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n  return (\n    q.x <= Math.max(p.x, r.x) &&\n    q.x >= Math.min(p.x, r.x) &&\n    q.y <= Math.max(p.y, r.y) &&\n    q.y >= Math.min(p.y, r.y)\n  );\n}\n\nfunction sign(num) {\n  return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n  let p = a;\n  do {\n    if (\n      p.i !== a.i &&\n      p.next.i !== a.i &&\n      p.i !== b.i &&\n      p.next.i !== b.i &&\n      intersects(p, p.next, a, b)\n    )\n      return true;\n    p = p.next;\n  } while (p !== a);\n\n  return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n  return area(a.prev, a, a.next) < 0\n    ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0\n    : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n  let p = a;\n  let inside = false;\n  const px = (a.x + b.x) / 2;\n  const py = (a.y + b.y) / 2;\n  do {\n    if (\n      p.y > py !== p.next.y > py &&\n      p.next.y !== p.y &&\n      px < ((p.next.x - p.x) * (py - p.y)) / (p.next.y - p.y) + p.x\n    )\n      inside = !inside;\n    p = p.next;\n  } while (p !== a);\n\n  return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n  const a2 = new Vertex(a.i, a.x, a.y);\n  const b2 = new Vertex(b.i, b.x, b.y);\n  const an = a.next;\n  const bp = b.prev;\n\n  a.next = b;\n  b.prev = a;\n\n  a2.next = an;\n  an.prev = a2;\n\n  b2.next = a2;\n  a2.prev = b2;\n\n  bp.next = b2;\n  b2.prev = bp;\n\n  return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n  const p = new Vertex(i, x, y);\n\n  if (!last) {\n    p.prev = p;\n    p.next = p;\n  } else {\n    p.next = last.next;\n    p.prev = last;\n    last.next.prev = p;\n    last.next = p;\n  }\n  return p;\n}\n\nfunction removeNode(p) {\n  p.next.prev = p.prev;\n  p.prev.next = p.next;\n\n  if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n  if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nclass Vertex {\n  // vertex index in coordinates array\n  i: number;\n\n  // vertex coordinates\n  x: number;\n  y: number;\n\n  // previous and next vertex nodes in a polygon ring\n  prev: Vertex = null;\n  next: Vertex = null;\n\n  // z-order curve value\n  z: number = 0;\n\n  // previous and next nodes in z-order\n  prevZ: Vertex = null;\n  nextZ: Vertex = null;\n\n  // indicates whether this is a steiner point\n  steiner: boolean = false;\n\n  constructor(i: number, x: number, y: number) {\n    this.i = i;\n    this.x = x;\n    this.y = y;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}