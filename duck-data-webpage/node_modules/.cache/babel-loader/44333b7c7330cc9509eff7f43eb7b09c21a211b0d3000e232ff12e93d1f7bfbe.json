{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// deck.gl, MIT license\n// Attributions:\n// Copyright 2022 Foursquare Labs, Inc.\n/* eslint-disable camelcase */ // Some WMS parameters are not in camel case\n/* global setTimeout, clearTimeout */\nimport { CompositeLayer, COORDINATE_SYSTEM, _deepEqual as deepEqual } from '@deck.gl/core';\nimport { BitmapLayer } from '@deck.gl/layers';\nimport { ImageSource, createImageSource } from '@loaders.gl/wms';\nimport { WGS84ToPseudoMercator } from \"./utils.js\";\nconst defaultProps = {\n  id: 'imagery-layer',\n  data: '',\n  serviceType: 'auto',\n  srs: 'auto',\n  layers: {\n    type: 'array',\n    compare: true,\n    value: []\n  },\n  onMetadataLoad: {\n    type: 'function',\n    value: () => {}\n  },\n  // eslint-disable-next-line\n  onMetadataLoadError: {\n    type: 'function',\n    value: console.error\n  },\n  onImageLoadStart: {\n    type: 'function',\n    value: () => {}\n  },\n  onImageLoad: {\n    type: 'function',\n    value: () => {}\n  },\n  onImageLoadError: {\n    type: 'function',\n    compare: false,\n    // eslint-disable-next-line\n    value: (requestId, error) => console.error(error, requestId)\n  }\n};\n/**\n * The layer is used in Hex Tile layer in order to properly discard invisible elements during animation\n */\nexport class WMSLayer extends CompositeLayer {\n  /** Returns true if all async resources are loaded */\n  get isLoaded() {\n    // Track the explicit loading done by this layer\n    return this.state?.loadCounter === 0 && super.isLoaded;\n  }\n  /** Lets deck.gl know that we want viewport change events */\n  shouldUpdateState() {\n    return true;\n  }\n  initializeState() {\n    // intentionally empty, initialization is done in updateState\n    this.state._nextRequestId = 0;\n    this.state.lastRequestId = -1;\n    this.state.loadCounter = 0;\n  }\n  updateState({\n    changeFlags,\n    props,\n    oldProps\n  }) {\n    const {\n      viewport\n    } = this.context;\n    // Check if data source has changed\n    if (changeFlags.dataChanged || props.serviceType !== oldProps.serviceType) {\n      this.state.imageSource = this._createImageSource(props);\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._loadMetadata();\n      this.debounce(() => this.loadImage(viewport, 'image source changed'), 0);\n    } else if (!deepEqual(props.layers, oldProps.layers, 1)) {\n      this.debounce(() => this.loadImage(viewport, 'layers changed'), 0);\n    } else if (changeFlags.viewportChanged) {\n      this.debounce(() => this.loadImage(viewport, 'viewport changed'));\n    }\n  }\n  finalizeState() {\n    // TODO - we could cancel outstanding requests\n  }\n  renderLayers() {\n    // TODO - which bitmap layer is rendered should depend on the current viewport\n    // Currently Studio only uses one viewport\n    const {\n      bounds,\n      image,\n      lastRequestParameters\n    } = this.state;\n    return image && new BitmapLayer({\n      ...this.getSubLayerProps({\n        id: 'bitmap'\n      }),\n      _imageCoordinateSystem: lastRequestParameters.srs === 'EPSG:4326' ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN,\n      bounds,\n      image\n    });\n  }\n  async getFeatureInfoText(x, y) {\n    const {\n      lastRequestParameters\n    } = this.state;\n    if (lastRequestParameters) {\n      // @ts-expect-error Undocumented method\n      const featureInfo = await this.state.imageSource.getFeatureInfoText?.({\n        ...lastRequestParameters,\n        query_layers: lastRequestParameters.layers,\n        x,\n        y,\n        info_format: 'application/vnd.ogc.gml'\n      });\n      return featureInfo;\n    }\n    return '';\n  }\n  _createImageSource(props) {\n    if (props.data instanceof ImageSource) {\n      return props.data;\n    }\n    if (typeof props.data === 'string') {\n      return createImageSource({\n        url: props.data,\n        loadOptions: props.loadOptions,\n        type: props.serviceType\n      });\n    }\n    throw new Error('invalid image source in props.data');\n  }\n  /** Run a getMetadata on the image service */\n  async _loadMetadata() {\n    const {\n      imageSource\n    } = this.state;\n    try {\n      this.state.loadCounter++;\n      const metadata = await imageSource.getMetadata();\n      // If a request takes a long time, it may no longer be expected\n      if (this.state.imageSource === imageSource) {\n        this.getCurrentLayer()?.props.onMetadataLoad(metadata);\n      }\n    } catch (error) {\n      this.getCurrentLayer()?.props.onMetadataLoadError(error);\n    } finally {\n      this.state.loadCounter--;\n    }\n  }\n  /** Load an image */\n  async loadImage(viewport, reason) {\n    const {\n      layers,\n      serviceType\n    } = this.props;\n    // TODO - move to ImageSource?\n    if (serviceType === 'wms' && layers.length === 0) {\n      return;\n    }\n    const bounds = viewport.getBounds();\n    const {\n      width,\n      height\n    } = viewport;\n    const requestId = this.getRequestId();\n    let {\n      srs\n    } = this.props;\n    if (srs === 'auto') {\n      // BitmapLayer only supports LNGLAT or CARTESIAN (Web-Mercator)\n      srs = viewport.resolution ? 'EPSG:4326' : 'EPSG:3857';\n    }\n    const requestParams = {\n      width,\n      height,\n      boundingBox: [[bounds[0], bounds[1]], [bounds[2], bounds[3]]],\n      layers,\n      crs: srs\n    };\n    if (srs === 'EPSG:3857') {\n      const min = WGS84ToPseudoMercator([bounds[0], bounds[1]]);\n      const max = WGS84ToPseudoMercator([bounds[2], bounds[3]]);\n      requestParams.boundingBox = [min, max];\n    }\n    try {\n      this.state.loadCounter++;\n      this.props.onImageLoadStart(requestId);\n      const image = await this.state.imageSource.getImage(requestParams);\n      // If a request takes a long time, later requests may have already loaded.\n      if (this.state.lastRequestId < requestId) {\n        this.getCurrentLayer()?.props.onImageLoad(requestId);\n        // Not type safe...\n        this.setState({\n          image,\n          bounds,\n          lastRequestParameters: requestParams,\n          lastRequestId: requestId\n        });\n      }\n    } catch (error) {\n      this.raiseError(error, 'Load image');\n      this.getCurrentLayer()?.props.onImageLoadError(requestId, error);\n    } finally {\n      this.state.loadCounter--;\n    }\n  }\n  // HELPERS\n  /** Global counter for issuing unique request ids */\n  getRequestId() {\n    return this.state._nextRequestId++;\n  }\n  /** Runs an action in the future, cancels it if the new action is issued before it executes */\n  debounce(fn, ms = 500) {\n    clearTimeout(this.state._timeoutId);\n    this.state._timeoutId = setTimeout(() => fn(), ms);\n  }\n}\nWMSLayer.layerName = 'WMSLayer';\nWMSLayer.defaultProps = defaultProps;","map":{"version":3,"names":["CompositeLayer","COORDINATE_SYSTEM","_deepEqual","deepEqual","BitmapLayer","ImageSource","createImageSource","WGS84ToPseudoMercator","defaultProps","id","data","serviceType","srs","layers","type","compare","value","onMetadataLoad","onMetadataLoadError","console","error","onImageLoadStart","onImageLoad","onImageLoadError","requestId","WMSLayer","isLoaded","state","loadCounter","shouldUpdateState","initializeState","_nextRequestId","lastRequestId","updateState","changeFlags","props","oldProps","viewport","context","dataChanged","imageSource","_createImageSource","_loadMetadata","debounce","loadImage","viewportChanged","finalizeState","renderLayers","bounds","image","lastRequestParameters","getSubLayerProps","_imageCoordinateSystem","LNGLAT","CARTESIAN","getFeatureInfoText","x","y","featureInfo","query_layers","info_format","url","loadOptions","Error","metadata","getMetadata","getCurrentLayer","reason","length","getBounds","width","height","getRequestId","resolution","requestParams","boundingBox","crs","min","max","getImage","setState","raiseError","fn","ms","clearTimeout","_timeoutId","setTimeout","layerName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\geo-layers\\src\\wms-layer\\wms-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// deck.gl, MIT license\n// Attributions:\n// Copyright 2022 Foursquare Labs, Inc.\n\n/* eslint-disable camelcase */ // Some WMS parameters are not in camel case\n/* global setTimeout, clearTimeout */\n\nimport {\n  Layer,\n  CompositeLayer,\n  CompositeLayerProps,\n  UpdateParameters,\n  DefaultProps,\n  Viewport,\n  COORDINATE_SYSTEM,\n  _deepEqual as deepEqual\n} from '@deck.gl/core';\nimport {BitmapLayer} from '@deck.gl/layers';\nimport type {GetImageParameters, ImageSourceMetadata, ImageType} from '@loaders.gl/loader-utils';\nimport type {ImageServiceType} from '@loaders.gl/wms';\nimport {ImageSource, createImageSource} from '@loaders.gl/wms';\nimport {WGS84ToPseudoMercator} from './utils';\n\n/** All props supported by the TileLayer */\nexport type WMSLayerProps = CompositeLayerProps & _WMSLayerProps;\n\n/** Props added by the TileLayer */\ntype _WMSLayerProps = {\n  data: string | ImageSource;\n  serviceType?: ImageServiceType | 'auto';\n  layers?: string[];\n  srs?: 'EPSG:4326' | 'EPSG:3857' | 'auto';\n  onMetadataLoad?: (metadata: ImageSourceMetadata) => void;\n  onMetadataLoadError?: (error: Error) => void;\n  onImageLoadStart?: (requestId: unknown) => void;\n  onImageLoad?: (requestId: unknown) => void;\n  onImageLoadError?: (requestId: unknown, error: Error) => void;\n};\n\nconst defaultProps: DefaultProps<WMSLayerProps> = {\n  id: 'imagery-layer',\n  data: '',\n  serviceType: 'auto',\n  srs: 'auto',\n  layers: {type: 'array', compare: true, value: []},\n  onMetadataLoad: {type: 'function', value: () => {}},\n  // eslint-disable-next-line\n  onMetadataLoadError: {type: 'function', value: console.error},\n  onImageLoadStart: {type: 'function', value: () => {}},\n  onImageLoad: {type: 'function', value: () => {}},\n  onImageLoadError: {\n    type: 'function',\n    compare: false,\n    // eslint-disable-next-line\n    value: (requestId: unknown, error: Error) => console.error(error, requestId)\n  }\n};\n\n/**\n * The layer is used in Hex Tile layer in order to properly discard invisible elements during animation\n */\nexport class WMSLayer<ExtraPropsT extends {} = {}> extends CompositeLayer<\n  ExtraPropsT & Required<_WMSLayerProps>\n> {\n  static layerName = 'WMSLayer';\n  static defaultProps: DefaultProps = defaultProps;\n\n  state!: {\n    imageSource: ImageSource;\n    image: ImageType;\n    bounds: [number, number, number, number];\n    lastRequestParameters: {\n      bbox: [number, number, number, number];\n      layers: string[];\n      srs: 'EPSG:4326' | 'EPSG:3857';\n      width: number;\n      height: number;\n    };\n    lastRequestId: number;\n    _nextRequestId: number;\n    /** TODO: Change any => setTimeout return type. Different between Node and browser... */\n    _timeoutId: any;\n    loadCounter: number;\n  };\n\n  /** Returns true if all async resources are loaded */\n  get isLoaded(): boolean {\n    // Track the explicit loading done by this layer\n    return this.state?.loadCounter === 0 && super.isLoaded;\n  }\n\n  /** Lets deck.gl know that we want viewport change events */\n  override shouldUpdateState(): boolean {\n    return true;\n  }\n\n  override initializeState(): void {\n    // intentionally empty, initialization is done in updateState\n    this.state._nextRequestId = 0;\n    this.state.lastRequestId = -1;\n    this.state.loadCounter = 0;\n  }\n\n  override updateState({changeFlags, props, oldProps}: UpdateParameters<this>): void {\n    const {viewport} = this.context;\n\n    // Check if data source has changed\n    if (changeFlags.dataChanged || props.serviceType !== oldProps.serviceType) {\n      this.state.imageSource = this._createImageSource(props);\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._loadMetadata();\n      this.debounce(() => this.loadImage(viewport, 'image source changed'), 0);\n    } else if (!deepEqual(props.layers, oldProps.layers, 1)) {\n      this.debounce(() => this.loadImage(viewport, 'layers changed'), 0);\n    } else if (changeFlags.viewportChanged) {\n      this.debounce(() => this.loadImage(viewport, 'viewport changed'));\n    }\n  }\n\n  override finalizeState(): void {\n    // TODO - we could cancel outstanding requests\n  }\n\n  override renderLayers(): Layer {\n    // TODO - which bitmap layer is rendered should depend on the current viewport\n    // Currently Studio only uses one viewport\n    const {bounds, image, lastRequestParameters} = this.state;\n\n    return (\n      image &&\n      new BitmapLayer({\n        ...this.getSubLayerProps({id: 'bitmap'}),\n        _imageCoordinateSystem:\n          lastRequestParameters.srs === 'EPSG:4326'\n            ? COORDINATE_SYSTEM.LNGLAT\n            : COORDINATE_SYSTEM.CARTESIAN,\n        bounds,\n        image\n      })\n    );\n  }\n\n  async getFeatureInfoText(x: number, y: number): Promise<string | null> {\n    const {lastRequestParameters} = this.state;\n    if (lastRequestParameters) {\n      // @ts-expect-error Undocumented method\n      const featureInfo = await this.state.imageSource.getFeatureInfoText?.({\n        ...lastRequestParameters,\n        query_layers: lastRequestParameters.layers,\n        x,\n        y,\n        info_format: 'application/vnd.ogc.gml'\n      });\n      return featureInfo;\n    }\n    return '';\n  }\n\n  _createImageSource(props: WMSLayerProps): ImageSource {\n    if (props.data instanceof ImageSource) {\n      return props.data;\n    }\n\n    if (typeof props.data === 'string') {\n      return createImageSource({\n        url: props.data,\n        loadOptions: props.loadOptions,\n        type: props.serviceType\n      });\n    }\n\n    throw new Error('invalid image source in props.data');\n  }\n\n  /** Run a getMetadata on the image service */\n  async _loadMetadata(): Promise<void> {\n    const {imageSource} = this.state;\n    try {\n      this.state.loadCounter++;\n      const metadata = await imageSource.getMetadata();\n\n      // If a request takes a long time, it may no longer be expected\n      if (this.state.imageSource === imageSource) {\n        this.getCurrentLayer()?.props.onMetadataLoad(metadata);\n      }\n    } catch (error) {\n      this.getCurrentLayer()?.props.onMetadataLoadError(error as Error);\n    } finally {\n      this.state.loadCounter--;\n    }\n  }\n\n  /** Load an image */\n  async loadImage(viewport: Viewport, reason: string): Promise<void> {\n    const {layers, serviceType} = this.props;\n\n    // TODO - move to ImageSource?\n    if (serviceType === 'wms' && layers.length === 0) {\n      return;\n    }\n\n    const bounds = viewport.getBounds();\n    const {width, height} = viewport;\n    const requestId = this.getRequestId();\n    let {srs} = this.props;\n    if (srs === 'auto') {\n      // BitmapLayer only supports LNGLAT or CARTESIAN (Web-Mercator)\n      srs = viewport.resolution ? 'EPSG:4326' : 'EPSG:3857';\n    }\n    const requestParams: GetImageParameters = {\n      width,\n      height,\n      boundingBox: [\n        [bounds[0], bounds[1]],\n        [bounds[2], bounds[3]]\n      ],\n      layers,\n      crs: srs\n    };\n    if (srs === 'EPSG:3857') {\n      const min = WGS84ToPseudoMercator([bounds[0], bounds[1]]);\n      const max = WGS84ToPseudoMercator([bounds[2], bounds[3]]);\n      requestParams.boundingBox = [min, max];\n    }\n\n    try {\n      this.state.loadCounter++;\n      this.props.onImageLoadStart(requestId);\n\n      const image = await this.state.imageSource.getImage(requestParams);\n\n      // If a request takes a long time, later requests may have already loaded.\n      if (this.state.lastRequestId < requestId) {\n        this.getCurrentLayer()?.props.onImageLoad(requestId);\n        // Not type safe...\n        this.setState({\n          image,\n          bounds,\n          lastRequestParameters: requestParams,\n          lastRequestId: requestId\n        });\n      }\n    } catch (error) {\n      this.raiseError(error as Error, 'Load image');\n      this.getCurrentLayer()?.props.onImageLoadError(requestId, error as Error);\n    } finally {\n      this.state.loadCounter--;\n    }\n  }\n\n  // HELPERS\n\n  /** Global counter for issuing unique request ids */\n  private getRequestId(): number {\n    return this.state._nextRequestId++;\n  }\n\n  /** Runs an action in the future, cancels it if the new action is issued before it executes */\n  private debounce(fn: Function, ms = 500): void {\n    clearTimeout(this.state._timeoutId);\n    this.state._timeoutId = setTimeout(() => fn(), ms);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}