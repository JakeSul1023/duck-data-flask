{"ast":null,"code":"// GLTF EXTENSION: KHR_techniques_webgl\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_techniques_webgl\nimport { GLTFScenegraph } from \"../../api/gltf-scenegraph.js\";\nconst KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\nexport const name = KHR_TECHNIQUES_WEBGL;\nexport async function decode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = gltfScenegraph;\n  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n  if (extension) {\n    const techniques = resolveTechniques(extension, gltfScenegraph);\n    for (const material of json.materials || []) {\n      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n      if (materialExtension) {\n        // @ts-ignore TODO\n        material.technique = Object.assign({}, materialExtension,\n        // @ts-ignore\n        techniques[materialExtension.technique]);\n        // @ts-ignore TODO\n        material.technique.values = resolveValues(material.technique, gltfScenegraph);\n      }\n      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n    }\n    // Remove the top-level extension\n    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n  }\n}\n// eslint-disable-next-line\nexport async function encode(gltfData, options) {\n  // TODO\n}\nfunction resolveTechniques(techniquesExtension,\n// programs: {[key: string]: any}[],\n// shaders: {[key: string]: any}[],\n// techniques: {[key: string]: any}[]\ngltfScenegraph) {\n  const {\n    programs = [],\n    shaders = [],\n    techniques = []\n  } = techniquesExtension;\n  const textDecoder = new TextDecoder();\n  shaders.forEach(shader => {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));\n    } else {\n      // TODO: handle URI shader\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n  programs.forEach(program => {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n  techniques.forEach(technique => {\n    technique.program = programs[technique.program];\n  });\n  return techniques;\n}\nfunction resolveValues(technique, gltfScenegraph) {\n  const values = Object.assign({}, technique.values);\n  // merge values from uniforms\n  Object.keys(technique.uniforms || {}).forEach(uniform => {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n  // resolve textures\n  Object.keys(values).forEach(uniform => {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      // Assume this is a texture\n      // TODO: find if there are any other types that can be referenced\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n  return values;\n}","map":{"version":3,"names":["GLTFScenegraph","KHR_TECHNIQUES_WEBGL","name","decode","gltfData","gltfScenegraph","json","extension","getExtension","techniques","resolveTechniques","material","materials","materialExtension","getObjectExtension","technique","Object","assign","values","resolveValues","removeObjectExtension","removeExtension","encode","options","techniquesExtension","programs","shaders","textDecoder","TextDecoder","forEach","shader","Number","isFinite","bufferView","code","getTypedArrayForBufferView","Error","program","fragmentShader","vertexShader","keys","uniforms","uniform","value","index","undefined","texture","getTexture"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_techniques_webgl.js"],"sourcesContent":["// GLTF EXTENSION: KHR_techniques_webgl\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_techniques_webgl\nimport { GLTFScenegraph } from \"../../api/gltf-scenegraph.js\";\nconst KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\nexport const name = KHR_TECHNIQUES_WEBGL;\nexport async function decode(gltfData) {\n    const gltfScenegraph = new GLTFScenegraph(gltfData);\n    const { json } = gltfScenegraph;\n    const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n    if (extension) {\n        const techniques = resolveTechniques(extension, gltfScenegraph);\n        for (const material of json.materials || []) {\n            const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n            if (materialExtension) {\n                // @ts-ignore TODO\n                material.technique = Object.assign({}, materialExtension, \n                // @ts-ignore\n                techniques[materialExtension.technique]);\n                // @ts-ignore TODO\n                material.technique.values = resolveValues(material.technique, gltfScenegraph);\n            }\n            gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n        }\n        // Remove the top-level extension\n        gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n    }\n}\n// eslint-disable-next-line\nexport async function encode(gltfData, options) {\n    // TODO\n}\nfunction resolveTechniques(techniquesExtension, \n// programs: {[key: string]: any}[],\n// shaders: {[key: string]: any}[],\n// techniques: {[key: string]: any}[]\ngltfScenegraph) {\n    const { programs = [], shaders = [], techniques = [] } = techniquesExtension;\n    const textDecoder = new TextDecoder();\n    shaders.forEach((shader) => {\n        if (Number.isFinite(shader.bufferView)) {\n            shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));\n        }\n        else {\n            // TODO: handle URI shader\n            throw new Error('KHR_techniques_webgl: no shader code');\n        }\n    });\n    programs.forEach((program) => {\n        program.fragmentShader = shaders[program.fragmentShader];\n        program.vertexShader = shaders[program.vertexShader];\n    });\n    techniques.forEach((technique) => {\n        technique.program = programs[technique.program];\n    });\n    return techniques;\n}\nfunction resolveValues(technique, gltfScenegraph) {\n    const values = Object.assign({}, technique.values);\n    // merge values from uniforms\n    Object.keys(technique.uniforms || {}).forEach((uniform) => {\n        if (technique.uniforms[uniform].value && !(uniform in values)) {\n            values[uniform] = technique.uniforms[uniform].value;\n        }\n    });\n    // resolve textures\n    Object.keys(values).forEach((uniform) => {\n        if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n            // Assume this is a texture\n            // TODO: find if there are any other types that can be referenced\n            values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n        }\n    });\n    return values;\n}\n"],"mappings":"AAAA;AACA;AACA,SAASA,cAAc,QAAQ,8BAA8B;AAC7D,MAAMC,oBAAoB,GAAG,sBAAsB;AACnD,OAAO,MAAMC,IAAI,GAAGD,oBAAoB;AACxC,OAAO,eAAeE,MAAMA,CAACC,QAAQ,EAAE;EACnC,MAAMC,cAAc,GAAG,IAAIL,cAAc,CAACI,QAAQ,CAAC;EACnD,MAAM;IAAEE;EAAK,CAAC,GAAGD,cAAc;EAC/B,MAAME,SAAS,GAAGF,cAAc,CAACG,YAAY,CAACP,oBAAoB,CAAC;EACnE,IAAIM,SAAS,EAAE;IACX,MAAME,UAAU,GAAGC,iBAAiB,CAACH,SAAS,EAAEF,cAAc,CAAC;IAC/D,KAAK,MAAMM,QAAQ,IAAIL,IAAI,CAACM,SAAS,IAAI,EAAE,EAAE;MACzC,MAAMC,iBAAiB,GAAGR,cAAc,CAACS,kBAAkB,CAACH,QAAQ,EAAEV,oBAAoB,CAAC;MAC3F,IAAIY,iBAAiB,EAAE;QACnB;QACAF,QAAQ,CAACI,SAAS,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEJ,iBAAiB;QACxD;QACAJ,UAAU,CAACI,iBAAiB,CAACE,SAAS,CAAC,CAAC;QACxC;QACAJ,QAAQ,CAACI,SAAS,CAACG,MAAM,GAAGC,aAAa,CAACR,QAAQ,CAACI,SAAS,EAAEV,cAAc,CAAC;MACjF;MACAA,cAAc,CAACe,qBAAqB,CAACT,QAAQ,EAAEV,oBAAoB,CAAC;IACxE;IACA;IACAI,cAAc,CAACgB,eAAe,CAACpB,oBAAoB,CAAC;EACxD;AACJ;AACA;AACA,OAAO,eAAeqB,MAAMA,CAAClB,QAAQ,EAAEmB,OAAO,EAAE;EAC5C;AAAA;AAEJ,SAASb,iBAAiBA,CAACc,mBAAmB;AAC9C;AACA;AACA;AACAnB,cAAc,EAAE;EACZ,MAAM;IAAEoB,QAAQ,GAAG,EAAE;IAAEC,OAAO,GAAG,EAAE;IAAEjB,UAAU,GAAG;EAAG,CAAC,GAAGe,mBAAmB;EAC5E,MAAMG,WAAW,GAAG,IAAIC,WAAW,CAAC,CAAC;EACrCF,OAAO,CAACG,OAAO,CAAEC,MAAM,IAAK;IACxB,IAAIC,MAAM,CAACC,QAAQ,CAACF,MAAM,CAACG,UAAU,CAAC,EAAE;MACpCH,MAAM,CAACI,IAAI,GAAGP,WAAW,CAACxB,MAAM,CAACE,cAAc,CAAC8B,0BAA0B,CAACL,MAAM,CAACG,UAAU,CAAC,CAAC;IAClG,CAAC,MACI;MACD;MACA,MAAM,IAAIG,KAAK,CAAC,sCAAsC,CAAC;IAC3D;EACJ,CAAC,CAAC;EACFX,QAAQ,CAACI,OAAO,CAAEQ,OAAO,IAAK;IAC1BA,OAAO,CAACC,cAAc,GAAGZ,OAAO,CAACW,OAAO,CAACC,cAAc,CAAC;IACxDD,OAAO,CAACE,YAAY,GAAGb,OAAO,CAACW,OAAO,CAACE,YAAY,CAAC;EACxD,CAAC,CAAC;EACF9B,UAAU,CAACoB,OAAO,CAAEd,SAAS,IAAK;IAC9BA,SAAS,CAACsB,OAAO,GAAGZ,QAAQ,CAACV,SAAS,CAACsB,OAAO,CAAC;EACnD,CAAC,CAAC;EACF,OAAO5B,UAAU;AACrB;AACA,SAASU,aAAaA,CAACJ,SAAS,EAAEV,cAAc,EAAE;EAC9C,MAAMa,MAAM,GAAGF,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEF,SAAS,CAACG,MAAM,CAAC;EAClD;EACAF,MAAM,CAACwB,IAAI,CAACzB,SAAS,CAAC0B,QAAQ,IAAI,CAAC,CAAC,CAAC,CAACZ,OAAO,CAAEa,OAAO,IAAK;IACvD,IAAI3B,SAAS,CAAC0B,QAAQ,CAACC,OAAO,CAAC,CAACC,KAAK,IAAI,EAAED,OAAO,IAAIxB,MAAM,CAAC,EAAE;MAC3DA,MAAM,CAACwB,OAAO,CAAC,GAAG3B,SAAS,CAAC0B,QAAQ,CAACC,OAAO,CAAC,CAACC,KAAK;IACvD;EACJ,CAAC,CAAC;EACF;EACA3B,MAAM,CAACwB,IAAI,CAACtB,MAAM,CAAC,CAACW,OAAO,CAAEa,OAAO,IAAK;IACrC,IAAI,OAAOxB,MAAM,CAACwB,OAAO,CAAC,KAAK,QAAQ,IAAIxB,MAAM,CAACwB,OAAO,CAAC,CAACE,KAAK,KAAKC,SAAS,EAAE;MAC5E;MACA;MACA3B,MAAM,CAACwB,OAAO,CAAC,CAACI,OAAO,GAAGzC,cAAc,CAAC0C,UAAU,CAAC7B,MAAM,CAACwB,OAAO,CAAC,CAACE,KAAK,CAAC;IAC9E;EACJ,CAAC,CAAC;EACF,OAAO1B,MAAM;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}