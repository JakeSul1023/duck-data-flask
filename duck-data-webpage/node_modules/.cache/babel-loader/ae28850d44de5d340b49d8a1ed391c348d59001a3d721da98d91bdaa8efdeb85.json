{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { classifyRings, classifyRingsFlat, projectToLngLat, projectToLngLatFlat, convertToLocalCoordinates, convertToLocalCoordinatesFlat } from \"../utils/geometry-utils.js\";\nexport class VectorTileFeature {\n  properties;\n  extent;\n  type;\n  id;\n  _pbf;\n  _geometry;\n  _keys;\n  _values;\n  _geometryInfo;\n  static types = ['Unknown', 'Point', 'LineString', 'Polygon'];\n  // eslint-disable-next-line max-params\n  constructor(pbf, end, extent, keys, values, geometryInfo) {\n    // Public\n    this.properties = {};\n    this.extent = extent;\n    this.type = 0;\n    this.id = null;\n    // Private\n    this._pbf = pbf;\n    this._geometry = -1;\n    this._keys = keys;\n    this._values = values;\n    // Only used by binary tiles\n    this._geometryInfo = geometryInfo;\n    pbf.readFields(readFeature, this, end);\n  }\n  toGeoJSONFeature(coordinates, tileIndex) {\n    const coords = this.loadGeometry();\n    switch (coordinates) {\n      case 'wgs84':\n        return _toGeoJSONFeature(this, coords, line => projectToLngLat(line, tileIndex, this.extent));\n      default:\n        return _toGeoJSONFeature(this, coords, convertToLocalCoordinates);\n    }\n  }\n  /**\n   *\n   * @param options\n   * @returns\n   */\n  toBinaryFeature(coordinates, tileIndex) {\n    const geom = this.loadFlatGeometry();\n    switch (coordinates) {\n      case 'wgs84':\n        return this._toBinaryCoordinates(geom, coords => projectToLngLatFlat(coords, tileIndex, this.extent));\n      default:\n        return this._toBinaryCoordinates(geom, convertToLocalCoordinatesFlat);\n    }\n  }\n  /** Read a bounding box from the feature */\n  // eslint-disable-next-line max-statements\n  bbox() {\n    const pbf = this._pbf;\n    pbf.pos = this._geometry;\n    const end = pbf.readVarint() + pbf.pos;\n    let cmd = 1;\n    let length = 0;\n    let x = 0;\n    let y = 0;\n    let x1 = Infinity;\n    let x2 = -Infinity;\n    let y1 = Infinity;\n    let y2 = -Infinity;\n    while (pbf.pos < end) {\n      if (length <= 0) {\n        const cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n      length--;\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n        if (x < x1) x1 = x;\n        if (x > x2) x2 = x;\n        if (y < y1) y1 = y;\n        if (y > y2) y2 = y;\n      } else if (cmd !== 7) {\n        throw new Error(`unknown command ${cmd}`);\n      }\n    }\n    return [x1, y1, x2, y2];\n  }\n  // BINARY HELPERS\n  /**\n   *\n   * @param transform\n   * @returns result\n   */\n  _toBinaryCoordinates(geom, transform) {\n    let geometry;\n    // Apply the supplied transformation to data\n    transform(geom.data, this.extent);\n    const coordLength = 2;\n    // eslint-disable-next-line default-case\n    switch (this.type) {\n      case 1:\n        // Point\n        this._geometryInfo.pointFeaturesCount++;\n        this._geometryInfo.pointPositionsCount += geom.indices.length;\n        geometry = {\n          type: 'Point',\n          ...geom\n        };\n        break;\n      case 2:\n        // LineString\n        this._geometryInfo.lineFeaturesCount++;\n        this._geometryInfo.linePathsCount += geom.indices.length;\n        this._geometryInfo.linePositionsCount += geom.data.length / coordLength;\n        geometry = {\n          type: 'LineString',\n          ...geom\n        };\n        break;\n      case 3:\n        // Polygon\n        geometry = classifyRingsFlat(geom);\n        // Unlike Point & LineString geom.indices is a 2D array, thanks\n        // to the classifyRings method\n        this._geometryInfo.polygonFeaturesCount++;\n        this._geometryInfo.polygonObjectsCount += geometry.indices.length;\n        for (const indices of geometry.indices) {\n          this._geometryInfo.polygonRingsCount += indices.length;\n        }\n        this._geometryInfo.polygonPositionsCount += geometry.data.length / coordLength;\n        break;\n      default:\n        throw new Error(`Invalid geometry type: ${this.type}`);\n    }\n    const result = {\n      type: 'Feature',\n      geometry,\n      properties: this.properties\n    };\n    if (this.id !== null) {\n      result.id = this.id;\n    }\n    return result;\n  }\n  // GEOJSON HELPER\n  // eslint-disable-next-line complexity, max-statements\n  loadGeometry() {\n    const pbf = this._pbf;\n    pbf.pos = this._geometry;\n    const end = pbf.readVarint() + pbf.pos;\n    let cmd = 1;\n    let length = 0;\n    let x = 0;\n    let y = 0;\n    const lines = [];\n    let line;\n    while (pbf.pos < end) {\n      if (length <= 0) {\n        const cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n      length--;\n      switch (cmd) {\n        case 1:\n        case 2:\n          x += pbf.readSVarint();\n          y += pbf.readSVarint();\n          if (cmd === 1) {\n            // moveTo\n            if (line) lines.push(line);\n            line = [];\n          }\n          if (line) line.push([x, y]);\n          break;\n        case 7:\n          // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n          if (line) {\n            line.push(line[0].slice()); // closePolygon\n          }\n          break;\n        default:\n          throw new Error(`unknown command ${cmd}`);\n      }\n    }\n    if (line) lines.push(line);\n    return lines;\n  }\n  /**\n   * Expands the protobuf data to an intermediate Flat GeoJSON\n   * data format, which maps closely to the binary data buffers.\n   * It is similar to GeoJSON, but rather than storing the coordinates\n   * in multidimensional arrays, we have a 1D `data` with all the\n   * coordinates, and then index into this using the `indices`\n   * parameter, e.g.\n   *\n   * geometry: {\n   *   type: 'Point', data: [1,2], indices: [0]\n   * }\n   * geometry: {\n   *   type: 'LineString', data: [1,2,3,4,...], indices: [0]\n   * }\n   * geometry: {\n   *   type: 'Polygon', data: [1,2,3,4,...], indices: [[0, 2]]\n   * }\n   * Thus the indices member lets us look up the relevant range\n   * from the data array.\n   * The Multi* versions of the above types share the same data\n   * structure, just with multiple elements in the indices array\n   */\n  // eslint-disable-next-line complexity, max-statements\n  loadFlatGeometry() {\n    const pbf = this._pbf;\n    pbf.pos = this._geometry;\n    const endPos = pbf.readVarint() + pbf.pos;\n    let cmd = 1;\n    let cmdLen;\n    let length = 0;\n    let x = 0;\n    let y = 0;\n    let i = 0;\n    // Note: I attempted to replace the `data` array with a\n    // Float32Array, but performance was worse, both using\n    // `set()` and direct index access. Also, we cannot\n    // know how large the buffer should be, so it would\n    // increase memory usage\n    const indices = []; // Indices where geometries start\n    const data = []; // Flat array of coordinate data\n    while (pbf.pos < endPos) {\n      if (length <= 0) {\n        cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n      length--;\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n        if (cmd === 1) {\n          // New line\n          indices.push(i);\n        }\n        data.push(x, y);\n        i += 2;\n      } else if (cmd === 7) {\n        // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n        if (i > 0) {\n          const start = indices[indices.length - 1]; // start index of polygon\n          data.push(data[start], data[start + 1]); // closePolygon\n          i += 2;\n        }\n      } else {\n        throw new Error(`unknown command ${cmd}`);\n      }\n    }\n    return {\n      data,\n      indices\n    };\n  }\n}\nfunction _toGeoJSONFeature(vtFeature, coords, transform) {\n  let type = VectorTileFeature.types[vtFeature.type];\n  let i;\n  let j;\n  let coordinates;\n  switch (vtFeature.type) {\n    case 1:\n      const points = [];\n      for (i = 0; i < coords.length; i++) {\n        points[i] = coords[i][0];\n      }\n      coordinates = points;\n      transform(coordinates, vtFeature.extent);\n      break;\n    case 2:\n      coordinates = coords;\n      for (i = 0; i < coordinates.length; i++) {\n        transform(coordinates[i], vtFeature.extent);\n      }\n      break;\n    case 3:\n      coordinates = classifyRings(coords);\n      for (i = 0; i < coordinates.length; i++) {\n        for (j = 0; j < coordinates[i].length; j++) {\n          transform(coordinates[i][j], vtFeature.extent);\n        }\n      }\n      break;\n    default:\n      throw new Error('illegal vector tile type');\n  }\n  if (coordinates.length === 1) {\n    // @ts-expect-error\n    coordinates = coordinates[0];\n  } else {\n    type = `Multi${type}`;\n  }\n  const result = {\n    type: 'Feature',\n    geometry: {\n      type: type,\n      coordinates: coordinates\n    },\n    properties: vtFeature.properties\n  };\n  if (vtFeature.id !== null) {\n    result.properties ||= {};\n    result.properties.id = vtFeature.id;\n  }\n  return result;\n}\n// PBF READER UTILS\n/**\n *\n * @param tag\n * @param feature\n * @param pbf\n */\nfunction readFeature(tag, feature, pbf) {\n  if (feature && pbf) {\n    if (tag === 1) feature.id = pbf.readVarint();else if (tag === 2) readTag(pbf, feature);else if (tag === 3) feature.type = pbf.readVarint();else if (tag === 4) feature._geometry = pbf.pos;\n  }\n}\n/**\n *\n * @param pbf\n * @param feature\n */\nfunction readTag(pbf, feature) {\n  const end = pbf.readVarint() + pbf.pos;\n  while (pbf.pos < end) {\n    const key = feature._keys[pbf.readVarint()];\n    const value = feature._values[pbf.readVarint()];\n    feature.properties[key] = value;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}