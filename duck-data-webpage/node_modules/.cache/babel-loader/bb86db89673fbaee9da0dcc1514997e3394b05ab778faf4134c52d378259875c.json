{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// TODO\nexport const SOURCE_WGSL = /* WGSL */`\\  \nstruct dirlightUniforms {\n  lightDirection: vec3<f32>,\n};\n\nalias DirlightNormal = vec3<f32>;\n\nstruct DirlightInputs {\n  normal: DirlightNormal,\n};\n\n@binding(1) @group(0) var<uniform> dirlight : dirlightUniforms;\n\n// For vertex\nfn dirlight_setNormal(normal: vec3<f32>) -> DirlightNormal {\n  return normalize(normal);\n}\n\n// Returns color attenuated by angle from light source\nfn dirlight_filterColor(color: vec4<f32>, inputs: DirlightInputs) -> vec4<f32> {\n  // TODO - fix default light direction\n  // let lightDirection = dirlight.lightDirection;\n  let lightDirection = vec3<f32>(1, 1, 1);\n  let d: f32 = abs(dot(inputs.normal, normalize(lightDirection)));\n  return vec4<f32>(color.rgb * d, color.a);\n}\n`;\nconst VS_GLSL = /* glsl */`\\\nout vec3 dirlight_vNormal;\n\nvoid dirlight_setNormal(vec3 normal) {\n  dirlight_vNormal = normalize(normal);\n}\n`;\nconst FS_GLSL = /* glsl */`\\\nuniform dirlightUniforms {\n  vec3 lightDirection;\n} dirlight;\n\nin vec3 dirlight_vNormal;\n\n// Returns color attenuated by angle from light source\nvec4 dirlight_filterColor(vec4 color) {\n  float d = abs(dot(dirlight_vNormal, normalize(dirlight.lightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n`;\n/**\n * Cheap lighting - single directional light, single dot product, one uniform\n */\nexport const dirlight = {\n  props: {},\n  uniforms: {},\n  name: 'dirlight',\n  dependencies: [],\n  source: SOURCE_WGSL,\n  vs: VS_GLSL,\n  fs: FS_GLSL,\n  // fragmentInputs: [\n  //   {\n  //     name: 'dirlight_vNormal',\n  //     type: 'vec3<f32>'\n  //   }\n  // ],\n  uniformTypes: {\n    lightDirection: 'vec3<f32>'\n  },\n  defaultUniforms: {\n    lightDirection: [1, 1, 2]\n  },\n  getUniforms\n};\nfunction getUniforms(opts = dirlight.defaultUniforms) {\n  const uniforms = {};\n  if (opts.lightDirection) {\n    // eslint-disable-next-line camelcase\n    uniforms.dirlight_uLightDirection = opts.lightDirection;\n  }\n  return uniforms;\n}","map":{"version":3,"names":["SOURCE_WGSL","VS_GLSL","FS_GLSL","dirlight","props","uniforms","name","dependencies","source","vs","fs","uniformTypes","lightDirection","defaultUniforms","getUniforms","opts","dirlight_uLightDirection"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\shadertools\\src\\modules\\lighting\\no-material\\dirlight.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {NumberArray3} from '@math.gl/core';\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\n\nexport type DirlightProps = {\n  lightDirection?: NumberArray3;\n};\n\nexport type DirlightUniforms = DirlightProps;\n\n// TODO\nexport const SOURCE_WGSL = /* WGSL */ `\\  \nstruct dirlightUniforms {\n  lightDirection: vec3<f32>,\n};\n\nalias DirlightNormal = vec3<f32>;\n\nstruct DirlightInputs {\n  normal: DirlightNormal,\n};\n\n@binding(1) @group(0) var<uniform> dirlight : dirlightUniforms;\n\n// For vertex\nfn dirlight_setNormal(normal: vec3<f32>) -> DirlightNormal {\n  return normalize(normal);\n}\n\n// Returns color attenuated by angle from light source\nfn dirlight_filterColor(color: vec4<f32>, inputs: DirlightInputs) -> vec4<f32> {\n  // TODO - fix default light direction\n  // let lightDirection = dirlight.lightDirection;\n  let lightDirection = vec3<f32>(1, 1, 1);\n  let d: f32 = abs(dot(inputs.normal, normalize(lightDirection)));\n  return vec4<f32>(color.rgb * d, color.a);\n}\n`;\n\nconst VS_GLSL = /* glsl */ `\\\nout vec3 dirlight_vNormal;\n\nvoid dirlight_setNormal(vec3 normal) {\n  dirlight_vNormal = normalize(normal);\n}\n`;\n\nconst FS_GLSL = /* glsl */ `\\\nuniform dirlightUniforms {\n  vec3 lightDirection;\n} dirlight;\n\nin vec3 dirlight_vNormal;\n\n// Returns color attenuated by angle from light source\nvec4 dirlight_filterColor(vec4 color) {\n  float d = abs(dot(dirlight_vNormal, normalize(dirlight.lightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n`;\n\n/**\n * Cheap lighting - single directional light, single dot product, one uniform\n */\nexport const dirlight = {\n  props: {} as DirlightProps,\n  uniforms: {} as DirlightUniforms,\n\n  name: 'dirlight',\n  dependencies: [],\n  source: SOURCE_WGSL,\n  vs: VS_GLSL,\n  fs: FS_GLSL,\n\n  // fragmentInputs: [\n  //   {\n  //     name: 'dirlight_vNormal',\n  //     type: 'vec3<f32>'\n  //   }\n  // ],\n  uniformTypes: {\n    lightDirection: 'vec3<f32>'\n  },\n  defaultUniforms: {\n    lightDirection: [1, 1, 2]\n  },\n  getUniforms\n} as const satisfies ShaderModule<DirlightProps, DirlightUniforms>;\n\nfunction getUniforms(opts: DirlightProps = dirlight.defaultUniforms): DirlightUniforms {\n  const uniforms: Record<string, unknown> = {};\n  if (opts.lightDirection) {\n    // eslint-disable-next-line camelcase\n    uniforms.dirlight_uLightDirection = opts.lightDirection;\n  }\n  return uniforms;\n}\n"],"mappings":"AAAA;AACA;AACA;AAWA;AACA,OAAO,MAAMA,WAAW,GAAG,UAAW;;;;;;;;;;;;;;;;;;;;;;;;;;CA0BrC;AAED,MAAMC,OAAO,GAAG,UAAW;;;;;;CAM1B;AAED,MAAMC,OAAO,GAAG,UAAW;;;;;;;;;;;;CAY1B;AAED;;;AAGA,OAAO,MAAMC,QAAQ,GAAG;EACtBC,KAAK,EAAE,EAAmB;EAC1BC,QAAQ,EAAE,EAAsB;EAEhCC,IAAI,EAAE,UAAU;EAChBC,YAAY,EAAE,EAAE;EAChBC,MAAM,EAAER,WAAW;EACnBS,EAAE,EAAER,OAAO;EACXS,EAAE,EAAER,OAAO;EAEX;EACA;EACA;EACA;EACA;EACA;EACAS,YAAY,EAAE;IACZC,cAAc,EAAE;GACjB;EACDC,eAAe,EAAE;IACfD,cAAc,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC;GACzB;EACDE;CACgE;AAElE,SAASA,WAAWA,CAACC,IAAA,GAAsBZ,QAAQ,CAACU,eAAe;EACjE,MAAMR,QAAQ,GAA4B,EAAE;EAC5C,IAAIU,IAAI,CAACH,cAAc,EAAE;IACvB;IACAP,QAAQ,CAACW,wBAAwB,GAAGD,IAAI,CAACH,cAAc;EACzD;EACA,OAAOP,QAAQ;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}