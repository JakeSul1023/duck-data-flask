{"ast":null,"code":"import { AttrRecognizer } from \"./attribute.js\";\nimport { InputDirection } from \"../input/input-consts.js\";\nimport { RecognizerState } from \"../recognizer/recognizer-state.js\";\nimport { TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y } from \"../touchaction/touchaction-Consts.js\";\nconst EVENT_NAMES = ['', 'start', 'move', 'end', 'cancel', 'up', 'down', 'left', 'right'];\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n */\nexport class PanRecognizer extends AttrRecognizer {\n  constructor(options = {}) {\n    super({\n      enable: true,\n      pointers: 1,\n      event: 'pan',\n      threshold: 10,\n      direction: InputDirection.All,\n      ...options\n    });\n    this.pX = null;\n    this.pY = null;\n  }\n  getTouchAction() {\n    const {\n      options: {\n        direction\n      }\n    } = this;\n    const actions = [];\n    if (direction & InputDirection.Horizontal) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n    if (direction & InputDirection.Vertical) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n    return actions;\n  }\n  getEventNames() {\n    return EVENT_NAMES.map(suffix => this.options.event + suffix);\n  }\n  directionTest(input) {\n    const {\n      options\n    } = this;\n    let hasMoved = true;\n    let {\n      distance\n    } = input;\n    let {\n      direction\n    } = input;\n    const x = input.deltaX;\n    const y = input.deltaY;\n    // lock to axis?\n    if (!(direction & options.direction)) {\n      if (options.direction & InputDirection.Horizontal) {\n        direction = x === 0 ? InputDirection.None : x < 0 ? InputDirection.Left : InputDirection.Right;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = y === 0 ? InputDirection.None : y < 0 ? InputDirection.Up : InputDirection.Down;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && Boolean(direction & options.direction);\n  }\n  attrTest(input) {\n    return super.attrTest(input) && (Boolean(this.state & RecognizerState.Began) || !(this.state & RecognizerState.Began) && this.directionTest(input));\n  }\n  emit(input) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n    const direction = InputDirection[input.direction].toLowerCase();\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n    super.emit(input);\n  }\n}","map":{"version":3,"names":["AttrRecognizer","InputDirection","RecognizerState","TOUCH_ACTION_PAN_X","TOUCH_ACTION_PAN_Y","EVENT_NAMES","PanRecognizer","constructor","options","enable","pointers","event","threshold","direction","All","pX","pY","getTouchAction","actions","Horizontal","push","Vertical","getEventNames","map","suffix","directionTest","input","hasMoved","distance","x","deltaX","y","deltaY","None","Left","Right","Math","abs","Up","Down","Boolean","attrTest","state","Began","emit","toLowerCase","additionalEvent"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\mjolnir.js\\src\\hammerjs\\recognizers\\pan.ts"],"sourcesContent":["import {AttrRecognizer} from './attribute';\nimport {InputDirection} from '../input/input-consts';\nimport {RecognizerState} from '../recognizer/recognizer-state';\nimport {TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y} from '../touchaction/touchaction-Consts';\nimport type {HammerInput} from '../input/types';\n\nexport type PanRecognizerOptions = {\n  /** Name of the event.\n   * @default 'pan'\n   */\n  event?: string;\n  /** Enable this event.\n   * @default true\n   */\n  enable?: boolean;\n  /** Required number of pointers. 0 for all pointers.\n   * @default 1\n   */\n  pointers?: number;\n  /** Required direction of panning.\n   * @default InputDirection.All\n   */\n  direction?: InputDirection;\n  /** Minimal pan distance required before recognizing.\n   * @default 10\n   */\n  threshold?: number;\n};\n\nconst EVENT_NAMES = ['', 'start', 'move', 'end', 'cancel', 'up', 'down', 'left', 'right'] as const;\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n */\nexport class PanRecognizer extends AttrRecognizer<Required<PanRecognizerOptions>> {\n  pX: number | null;\n  pY: number | null;\n\n  constructor(options: PanRecognizerOptions = {}) {\n    super({\n      enable: true,\n      pointers: 1,\n      event: 'pan',\n      threshold: 10,\n      direction: InputDirection.All,\n      ...options\n    });\n    this.pX = null;\n    this.pY = null;\n  }\n\n  getTouchAction(): string[] {\n    const {\n      options: {direction}\n    } = this;\n    const actions: string[] = [];\n    if (direction & InputDirection.Horizontal) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n    if (direction & InputDirection.Vertical) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n    return actions;\n  }\n\n  getEventNames(): string[] {\n    return EVENT_NAMES.map((suffix) => this.options.event + suffix);\n  }\n\n  directionTest(input: HammerInput): boolean {\n    const {options} = this;\n    let hasMoved = true;\n    let {distance} = input;\n    let {direction} = input;\n    const x = input.deltaX;\n    const y = input.deltaY;\n\n    // lock to axis?\n    if (!(direction & options.direction)) {\n      if (options.direction & InputDirection.Horizontal) {\n        direction =\n          x === 0 ? InputDirection.None : x < 0 ? InputDirection.Left : InputDirection.Right;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = y === 0 ? InputDirection.None : y < 0 ? InputDirection.Up : InputDirection.Down;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && Boolean(direction & options.direction);\n  }\n\n  attrTest(input: HammerInput): boolean {\n    return (\n      super.attrTest(input) &&\n      (Boolean(this.state & RecognizerState.Began) ||\n        (!(this.state & RecognizerState.Began) && this.directionTest(input)))\n    );\n  }\n\n  emit(input: HammerInput) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n\n    const direction = InputDirection[input.direction].toLowerCase();\n\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n    super.emit(input);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}