{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// deck.gl, MIT license\nimport ComponentState from \"../lifecycle/component-state.js\";\nexport default class LayerState extends ComponentState {\n  constructor({\n    attributeManager,\n    layer\n  }) {\n    super(layer);\n    this.attributeManager = attributeManager;\n    this.needsRedraw = true;\n    this.needsUpdate = true;\n    this.subLayers = null;\n    this.usesPickingColorCache = false;\n  }\n  get layer() {\n    return this.component;\n  }\n  /* Override base Component methods with Layer-specific handling */\n  _fetch(propName, url) {\n    const layer = this.layer;\n    const fetch = layer?.props.fetch;\n    if (fetch) {\n      return fetch(url, {\n        propName,\n        layer\n      });\n    }\n    return super._fetch(propName, url);\n  }\n  _onResolve(propName, value) {\n    const layer = this.layer;\n    if (layer) {\n      const onDataLoad = layer.props.onDataLoad;\n      if (propName === 'data' && onDataLoad) {\n        onDataLoad(value, {\n          propName,\n          layer\n        });\n      }\n    }\n  }\n  _onError(propName, error) {\n    const layer = this.layer;\n    if (layer) {\n      layer.raiseError(error, `loading ${propName} of ${this.layer}`);\n    }\n  }\n}","map":{"version":3,"names":["ComponentState","LayerState","constructor","attributeManager","layer","needsRedraw","needsUpdate","subLayers","usesPickingColorCache","component","_fetch","propName","url","fetch","props","_onResolve","value","onDataLoad","_onError","error","raiseError"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\lib\\layer-state.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// deck.gl, MIT license\nimport ComponentState from '../lifecycle/component-state';\n\nimport type Layer from './layer';\nimport type AttributeManager from './attribute/attribute-manager';\nimport type Viewport from '../viewports/viewport';\nimport type UniformTransitionManager from './uniform-transition-manager';\n\nexport type ChangeFlags = {\n  // Primary changeFlags, can be strings stating reason for change\n  dataChanged: string | false | {startRow: number; endRow?: number}[];\n  propsChanged: string | false;\n  updateTriggersChanged: Record<string, true> | false;\n  extensionsChanged: boolean;\n  viewportChanged: boolean;\n  stateChanged: boolean;\n\n  // Derived changeFlags\n  propsOrDataChanged: boolean;\n  somethingChanged: boolean;\n};\n\nexport default class LayerState<LayerT extends Layer> extends ComponentState<LayerT> {\n  attributeManager: AttributeManager | null;\n  needsRedraw: boolean;\n  needsUpdate: boolean;\n  /**\n   * Sublayers rendered in a previous cycle\n   */\n  subLayers: Layer[] | null;\n  /**\n   * If the layer is using the shared instancedPickingColors buffer\n   */\n  usesPickingColorCache: boolean;\n  /**\n   * If the layer has picking buffer (pickingColors or instancePickingColors)\n   */\n  hasPickingBuffer?: boolean;\n  /**\n   * Dirty flags of the layer's props and state\n   */\n  changeFlags!: ChangeFlags;\n\n  /** The last viewport rendered by this layer */\n  viewport?: Viewport;\n\n  uniformTransitions!: UniformTransitionManager;\n  /** Populated during uniform transition to replace user-supplied values */\n  propsInTransition?: LayerT['props'];\n\n  constructor({\n    attributeManager,\n    layer\n  }: {\n    attributeManager: AttributeManager | null;\n    layer: LayerT;\n  }) {\n    super(layer);\n    this.attributeManager = attributeManager;\n    this.needsRedraw = true;\n    this.needsUpdate = true;\n    this.subLayers = null;\n    this.usesPickingColorCache = false;\n  }\n\n  get layer(): LayerT | null {\n    return this.component;\n  }\n\n  /* Override base Component methods with Layer-specific handling */\n\n  protected _fetch(propName, url: string) {\n    const layer = this.layer;\n    const fetch = layer?.props.fetch;\n    if (fetch) {\n      return fetch(url, {propName, layer});\n    }\n    return super._fetch(propName, url);\n  }\n\n  protected _onResolve(propName: string, value: any) {\n    const layer = this.layer;\n    if (layer) {\n      const onDataLoad = layer.props.onDataLoad;\n      if (propName === 'data' && onDataLoad) {\n        onDataLoad(value, {propName, layer});\n      }\n    }\n  }\n\n  protected _onError(propName: string, error: Error) {\n    const layer = this.layer;\n    if (layer) {\n      layer.raiseError(error, `loading ${propName} of ${this.layer}`);\n    }\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA;AACA,OAAOA,cAAc;AAqBrB,eAAc,MAAOC,UAAiC,SAAQD,cAAsB;EA4BlFE,YAAY;IACVC,gBAAgB;IAChBC;EAAK,CAIN;IACC,KAAK,CAACA,KAAK,CAAC;IACZ,IAAI,CAACD,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACE,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,SAAS,GAAG,IAAI;IACrB,IAAI,CAACC,qBAAqB,GAAG,KAAK;EACpC;EAEA,IAAIJ,KAAKA,CAAA;IACP,OAAO,IAAI,CAACK,SAAS;EACvB;EAEA;EAEUC,MAAMA,CAACC,QAAQ,EAAEC,GAAW;IACpC,MAAMR,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB,MAAMS,KAAK,GAAGT,KAAK,EAAEU,KAAK,CAACD,KAAK;IAChC,IAAIA,KAAK,EAAE;MACT,OAAOA,KAAK,CAACD,GAAG,EAAE;QAACD,QAAQ;QAAEP;MAAK,CAAC,CAAC;IACtC;IACA,OAAO,KAAK,CAACM,MAAM,CAACC,QAAQ,EAAEC,GAAG,CAAC;EACpC;EAEUG,UAAUA,CAACJ,QAAgB,EAAEK,KAAU;IAC/C,MAAMZ,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB,IAAIA,KAAK,EAAE;MACT,MAAMa,UAAU,GAAGb,KAAK,CAACU,KAAK,CAACG,UAAU;MACzC,IAAIN,QAAQ,KAAK,MAAM,IAAIM,UAAU,EAAE;QACrCA,UAAU,CAACD,KAAK,EAAE;UAACL,QAAQ;UAAEP;QAAK,CAAC,CAAC;MACtC;IACF;EACF;EAEUc,QAAQA,CAACP,QAAgB,EAAEQ,KAAY;IAC/C,MAAMf,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB,IAAIA,KAAK,EAAE;MACTA,KAAK,CAACgB,UAAU,CAACD,KAAK,EAAE,WAAWR,QAAQ,OAAO,IAAI,CAACP,KAAK,EAAE,CAAC;IACjE;EACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}