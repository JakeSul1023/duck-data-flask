{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\n// HELPER ENCODERS\nimport { assert } from '@loaders.gl/loader-utils';\nexport function encode3DTileHeader(tile, dataView, byteOffset) {\n  const HEADER_SIZE = 12;\n  if (!dataView) {\n    return byteOffset + HEADER_SIZE;\n  }\n  const {\n    magic,\n    version = 1,\n    byteLength = 12\n  } = tile;\n  assert(Array.isArray(magic) && Number.isFinite(version) && Number.isFinite(byteLength));\n  dataView.setUint8(byteOffset + 0, magic[0]);\n  dataView.setUint8(byteOffset + 1, magic[1]);\n  dataView.setUint8(byteOffset + 2, magic[2]);\n  dataView.setUint8(byteOffset + 3, magic[3]);\n  dataView.setUint32(byteOffset + 4, version, true); // version\n  dataView.setUint32(byteOffset + 8, byteLength, true); // byteLength\n  byteOffset += HEADER_SIZE;\n  return byteOffset;\n}\n// Bytelength is sometimes only known at the end of writing a tile\nexport function encode3DTileByteLength(dataView, byteOffsetTileStart, byteLength) {\n  if (!dataView) {\n    return;\n  }\n  dataView.setUint32(byteOffsetTileStart + 8, byteLength, true); // byteLength\n}","map":{"version":3,"names":["assert","encode3DTileHeader","tile","dataView","byteOffset","HEADER_SIZE","magic","version","byteLength","Array","isArray","Number","isFinite","setUint8","setUint32","encode3DTileByteLength","byteOffsetTileStart"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/3d-tiles/dist/lib/encoders/helpers/encode-3d-tile-header.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\n// HELPER ENCODERS\nimport { assert } from '@loaders.gl/loader-utils';\nexport function encode3DTileHeader(tile, dataView, byteOffset) {\n    const HEADER_SIZE = 12;\n    if (!dataView) {\n        return byteOffset + HEADER_SIZE;\n    }\n    const { magic, version = 1, byteLength = 12 } = tile;\n    assert(Array.isArray(magic) && Number.isFinite(version) && Number.isFinite(byteLength));\n    dataView.setUint8(byteOffset + 0, magic[0]);\n    dataView.setUint8(byteOffset + 1, magic[1]);\n    dataView.setUint8(byteOffset + 2, magic[2]);\n    dataView.setUint8(byteOffset + 3, magic[3]);\n    dataView.setUint32(byteOffset + 4, version, true); // version\n    dataView.setUint32(byteOffset + 8, byteLength, true); // byteLength\n    byteOffset += HEADER_SIZE;\n    return byteOffset;\n}\n// Bytelength is sometimes only known at the end of writing a tile\nexport function encode3DTileByteLength(dataView, byteOffsetTileStart, byteLength) {\n    if (!dataView) {\n        return;\n    }\n    dataView.setUint32(byteOffsetTileStart + 8, byteLength, true); // byteLength\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,MAAM,QAAQ,0BAA0B;AACjD,OAAO,SAASC,kBAAkBA,CAACC,IAAI,EAAEC,QAAQ,EAAEC,UAAU,EAAE;EAC3D,MAAMC,WAAW,GAAG,EAAE;EACtB,IAAI,CAACF,QAAQ,EAAE;IACX,OAAOC,UAAU,GAAGC,WAAW;EACnC;EACA,MAAM;IAAEC,KAAK;IAAEC,OAAO,GAAG,CAAC;IAAEC,UAAU,GAAG;EAAG,CAAC,GAAGN,IAAI;EACpDF,MAAM,CAACS,KAAK,CAACC,OAAO,CAACJ,KAAK,CAAC,IAAIK,MAAM,CAACC,QAAQ,CAACL,OAAO,CAAC,IAAII,MAAM,CAACC,QAAQ,CAACJ,UAAU,CAAC,CAAC;EACvFL,QAAQ,CAACU,QAAQ,CAACT,UAAU,GAAG,CAAC,EAAEE,KAAK,CAAC,CAAC,CAAC,CAAC;EAC3CH,QAAQ,CAACU,QAAQ,CAACT,UAAU,GAAG,CAAC,EAAEE,KAAK,CAAC,CAAC,CAAC,CAAC;EAC3CH,QAAQ,CAACU,QAAQ,CAACT,UAAU,GAAG,CAAC,EAAEE,KAAK,CAAC,CAAC,CAAC,CAAC;EAC3CH,QAAQ,CAACU,QAAQ,CAACT,UAAU,GAAG,CAAC,EAAEE,KAAK,CAAC,CAAC,CAAC,CAAC;EAC3CH,QAAQ,CAACW,SAAS,CAACV,UAAU,GAAG,CAAC,EAAEG,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC;EACnDJ,QAAQ,CAACW,SAAS,CAACV,UAAU,GAAG,CAAC,EAAEI,UAAU,EAAE,IAAI,CAAC,CAAC,CAAC;EACtDJ,UAAU,IAAIC,WAAW;EACzB,OAAOD,UAAU;AACrB;AACA;AACA,OAAO,SAASW,sBAAsBA,CAACZ,QAAQ,EAAEa,mBAAmB,EAAER,UAAU,EAAE;EAC9E,IAAI,CAACL,QAAQ,EAAE;IACX;EACJ;EACAA,QAAQ,CAACW,SAAS,CAACE,mBAAmB,GAAG,CAAC,EAAER,UAAU,EAAE,IAAI,CAAC,CAAC,CAAC;AACnE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}