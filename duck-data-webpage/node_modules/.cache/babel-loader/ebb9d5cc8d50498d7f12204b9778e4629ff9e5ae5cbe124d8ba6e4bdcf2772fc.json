{"ast":null,"code":"import { WorkerBody } from '@loaders.gl/worker-utils';\n// import {validateLoaderVersion} from './validate-loader-version';\nlet requestId = 0;\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n * @param loader\n */\nexport async function createLoaderWorker(loader) {\n  // Check that we are actually in a worker thread\n  if (!(await WorkerBody.inWorkerThread())) {\n    return;\n  }\n  WorkerBody.onmessage = async (type, payload) => {\n    switch (type) {\n      case 'process':\n        try {\n          // validateLoaderVersion(loader, data.source.split('@')[1]);\n          const {\n            input,\n            options = {},\n            context = {}\n          } = payload;\n          const result = await parseData({\n            loader,\n            arrayBuffer: input,\n            options,\n            // @ts-expect-error fetch missing\n            context: {\n              ...context,\n              _parse: parseOnMainThread\n            }\n          });\n          WorkerBody.postMessage('done', {\n            result\n          });\n        } catch (error) {\n          const message = error instanceof Error ? error.message : '';\n          WorkerBody.postMessage('error', {\n            error: message\n          });\n        }\n        break;\n      default:\n    }\n  };\n}\nfunction parseOnMainThread(arrayBuffer, loader, options, context) {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n    /**\n     */\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n        default:\n        // ignore\n      }\n    };\n    WorkerBody.addEventListener(onMessage);\n    // Ask the main thread to decode data\n    const payload = {\n      id,\n      input: arrayBuffer,\n      options\n    };\n    WorkerBody.postMessage('process', payload);\n  });\n}\n// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)\n// TODO - Why not support async loader.parse* funcs here?\n// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?\n// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse\nasync function parseData({\n  loader,\n  arrayBuffer,\n  options,\n  context\n}) {\n  let data;\n  let parser;\n  if (loader.parseSync || loader.parse) {\n    data = arrayBuffer;\n    parser = loader.parseSync || loader.parse;\n  } else if (loader.parseTextSync) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(arrayBuffer);\n    parser = loader.parseTextSync;\n  } else {\n    throw new Error(`Could not load data with ${loader.name} loader`);\n  }\n  // TODO - proper merge in of loader options...\n  options = {\n    ...options,\n    modules: loader && loader.options && loader.options.modules || {},\n    worker: false\n  };\n  return await parser(data, {\n    ...options\n  }, context, loader);\n}","map":{"version":3,"names":["WorkerBody","requestId","createLoaderWorker","loader","inWorkerThread","onmessage","type","payload","input","options","context","result","parseData","arrayBuffer","_parse","parseOnMainThread","postMessage","error","message","Error","Promise","resolve","reject","id","onMessage","removeEventListener","addEventListener","data","parser","parseSync","parse","parseTextSync","textDecoder","TextDecoder","decode","name","modules","worker"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/create-loader-worker.js"],"sourcesContent":["import { WorkerBody } from '@loaders.gl/worker-utils';\n// import {validateLoaderVersion} from './validate-loader-version';\nlet requestId = 0;\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n * @param loader\n */\nexport async function createLoaderWorker(loader) {\n    // Check that we are actually in a worker thread\n    if (!(await WorkerBody.inWorkerThread())) {\n        return;\n    }\n    WorkerBody.onmessage = async (type, payload) => {\n        switch (type) {\n            case 'process':\n                try {\n                    // validateLoaderVersion(loader, data.source.split('@')[1]);\n                    const { input, options = {}, context = {} } = payload;\n                    const result = await parseData({\n                        loader,\n                        arrayBuffer: input,\n                        options,\n                        // @ts-expect-error fetch missing\n                        context: {\n                            ...context,\n                            _parse: parseOnMainThread\n                        }\n                    });\n                    WorkerBody.postMessage('done', { result });\n                }\n                catch (error) {\n                    const message = error instanceof Error ? error.message : '';\n                    WorkerBody.postMessage('error', { error: message });\n                }\n                break;\n            default:\n        }\n    };\n}\nfunction parseOnMainThread(arrayBuffer, loader, options, context) {\n    return new Promise((resolve, reject) => {\n        const id = requestId++;\n        /**\n         */\n        const onMessage = (type, payload) => {\n            if (payload.id !== id) {\n                // not ours\n                return;\n            }\n            switch (type) {\n                case 'done':\n                    WorkerBody.removeEventListener(onMessage);\n                    resolve(payload.result);\n                    break;\n                case 'error':\n                    WorkerBody.removeEventListener(onMessage);\n                    reject(payload.error);\n                    break;\n                default:\n                // ignore\n            }\n        };\n        WorkerBody.addEventListener(onMessage);\n        // Ask the main thread to decode data\n        const payload = { id, input: arrayBuffer, options };\n        WorkerBody.postMessage('process', payload);\n    });\n}\n// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)\n// TODO - Why not support async loader.parse* funcs here?\n// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?\n// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse\nasync function parseData({ loader, arrayBuffer, options, context }) {\n    let data;\n    let parser;\n    if (loader.parseSync || loader.parse) {\n        data = arrayBuffer;\n        parser = loader.parseSync || loader.parse;\n    }\n    else if (loader.parseTextSync) {\n        const textDecoder = new TextDecoder();\n        data = textDecoder.decode(arrayBuffer);\n        parser = loader.parseTextSync;\n    }\n    else {\n        throw new Error(`Could not load data with ${loader.name} loader`);\n    }\n    // TODO - proper merge in of loader options...\n    options = {\n        ...options,\n        modules: (loader && loader.options && loader.options.modules) || {},\n        worker: false\n    };\n    return await parser(data, { ...options }, context, loader);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}