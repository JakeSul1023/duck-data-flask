{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBrowser } from '@probe.gl/env';\nimport { Device } from \"./device.js\";\nimport { lumaStats } from \"../utils/stats-manager.js\";\nimport { log } from \"../utils/log.js\";\nconst isPage = isBrowser() && typeof document !== 'undefined';\nconst isPageLoaded = () => isPage && document.readyState === 'complete';\nconst STARTUP_MESSAGE = 'set luma.log.level=1 (or higher) to trace rendering';\nconst ERROR_MESSAGE = 'No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.';\n/**\n * Entry point to the luma.gl GPU abstraction\n * Register WebGPU and/or WebGL adapters (controls application bundle size)\n * Run-time selection of the first available Device\n */\nexport class Luma {\n  static defaultProps = (() => ({\n    ...Device.defaultProps,\n    type: 'best-available',\n    adapters: undefined,\n    waitForPageLoad: true\n  }))();\n  /**\n   * Page load promise\n   * Get a 'lazy' promise that resolves when the DOM is loaded.\n   * @note Since there may be limitations on number of `load` event listeners,\n   * it is recommended avoid calling this function until actually needed.\n   * I.e. don't call it until you know that you will be looking up a string in the DOM.\n   */\n  static pageLoaded = (() => getPageLoadPromise().then(() => {\n    log.probe(2, 'DOM is loaded')();\n  }))();\n  /** Global stats for all devices */\n  stats = (() => lumaStats)();\n  /**\n   * Global log\n   *\n   * Assign luma.log.level in console to control logging: \\\n   * 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs\n   * luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;\n   */\n  log = (() => log)();\n  /** Version of luma.gl */\n  VERSION = (() =>\n  // Version detection using build plugin\n  // @ts-expect-error no-undef\n  typeof \"9.1.7\" !== 'undefined' ? \"9.1.7\" : 'running from source')();\n  spector;\n  preregisteredAdapters = (() => new Map())();\n  constructor() {\n    if (globalThis.luma) {\n      if (globalThis.luma.VERSION !== this.VERSION) {\n        log.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)();\n        log.error(`'yarn why @luma.gl/core' can help identify the source of the conflict`)();\n        throw new Error(`luma.gl - multiple versions detected: see console log`);\n      }\n      log.error('This version of luma.gl has already been initialized')();\n    }\n    log.log(1, `${this.VERSION} - ${STARTUP_MESSAGE}`)();\n    globalThis.luma = this;\n  }\n  registerAdapters(adapters) {\n    for (const deviceClass of adapters) {\n      this.preregisteredAdapters.set(deviceClass.type, deviceClass);\n    }\n  }\n  /** Get type strings for supported Devices */\n  getSupportedAdapters() {\n    let adapters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    const adapterMap = this.getAdapterMap(adapters);\n    return Array.from(adapterMap).map(_ref => {\n      let [, adapter] = _ref;\n      return adapter;\n    }).filter(adapter => adapter.isSupported?.()).map(adapter => adapter.type);\n  }\n  /** Get type strings for best available Device */\n  getBestAvailableAdapter() {\n    let adapters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    const adapterMap = this.getAdapterMap(adapters);\n    if (adapterMap.get('webgpu')?.isSupported?.()) {\n      return 'webgpu';\n    }\n    if (adapterMap.get('webgl')?.isSupported?.()) {\n      return 'webgl';\n    }\n    return null;\n  }\n  setDefaultDeviceProps(props) {\n    Object.assign(Luma.defaultProps, props);\n  }\n  /** Creates a device. Asynchronously. */\n  async createDevice() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    props = {\n      ...Luma.defaultProps,\n      ...props\n    };\n    if (props.waitForPageLoad) {\n      // || props.createCanvasContext) {\n      await Luma.pageLoaded;\n    }\n    const adapterMap = this.getAdapterMap(props.adapters);\n    let type = props.type || '';\n    if (type === 'best-available') {\n      type = this.getBestAvailableAdapter(props.adapters) || type;\n    }\n    const adapters = this.getAdapterMap(props.adapters) || adapterMap;\n    const adapter = adapters.get(type);\n    const device = await adapter?.create?.(props);\n    if (device) {\n      return device;\n    }\n    throw new Error(ERROR_MESSAGE);\n  }\n  /** Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice). */\n  async attachDevice(props) {\n    const adapters = this.getAdapterMap(props.adapters);\n    // WebGL\n    let type = '';\n    if (props.handle instanceof WebGL2RenderingContext) {\n      type = 'webgl';\n    }\n    if (props.createCanvasContext) {\n      await Luma.pageLoaded;\n    }\n    // TODO - WebGPU does not yet have a stable API\n    // if (props.handle instanceof GPUDevice) {\n    //   const WebGPUDevice = adapters.get('webgpu') as any;\n    //   if (WebGPUDevice) {\n    //     return (await WebGPUDevice.attach(props.handle)) as Device;\n    //   }\n    // }\n    // null\n    if (props.handle === null) {\n      type = 'unknown';\n    }\n    const adapter = adapters.get(type);\n    const device = await adapter?.attach?.(null);\n    if (device) {\n      return device;\n    }\n    throw new Error(ERROR_MESSAGE);\n  }\n  /**\n   * Override `HTMLCanvasContext.getCanvas()` to always create WebGL2 contexts with additional WebGL1 compatibility.\n   * Useful when attaching luma to a context from an external library does not support creating WebGL2 contexts.\n   */\n  enforceWebGL2() {\n    let enforce = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let adapters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const adapterMap = this.getAdapterMap(adapters);\n    const webgl2Adapter = adapterMap.get('webgl');\n    if (!webgl2Adapter) {\n      log.warn('enforceWebGL2: webgl adapter not found')();\n    }\n    webgl2Adapter?.enforceWebGL2?.(enforce);\n  }\n  /** Convert a list of adapters to a map */\n  getAdapterMap() {\n    let adapters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    const map = new Map(this.preregisteredAdapters);\n    for (const adapter of adapters) {\n      map.set(adapter.type, adapter);\n    }\n    return map;\n  }\n  // DEPRECATED\n  /** @deprecated Use registerAdapters */\n  registerDevices(deviceClasses) {\n    log.warn('luma.registerDevices() is deprecated, use luma.registerAdapters() instead');\n    for (const deviceClass of deviceClasses) {\n      const adapter = deviceClass.adapter;\n      if (adapter) {\n        this.preregisteredAdapters.set(adapter.type, adapter);\n      }\n    }\n  }\n}\n/**\n * Entry point to the luma.gl GPU abstraction\n * Register WebGPU and/or WebGL adapters (controls application bundle size)\n * Run-time selection of the first available Device\n */\nexport const luma = new Luma();\n// HELPER FUNCTIONS\n/** Returns a promise that resolves when the page is loaded */\nfunction getPageLoadPromise() {\n  if (isPageLoaded() || typeof window === 'undefined') {\n    return Promise.resolve();\n  }\n  return new Promise(resolve => {\n    window.addEventListener('load', () => resolve());\n  });\n}\n//# sourceMappingURL=luma.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}