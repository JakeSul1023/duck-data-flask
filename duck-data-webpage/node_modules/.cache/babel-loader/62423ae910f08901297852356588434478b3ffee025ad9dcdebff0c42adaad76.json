{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** Generate hook source code */\nexport function getShaderHooks(hookFunctions, hookInjections) {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a, b) => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n  return result;\n}\n/**\n * Parse string based hook functions\n * And split per shader\n */\nexport function normalizeShaderHooks(hookFunctions) {\n  const result = {\n    vertex: {},\n    fragment: {}\n  };\n  for (const hookFunction of hookFunctions) {\n    let opts;\n    let hook;\n    if (typeof hookFunction !== 'string') {\n      opts = hookFunction;\n      hook = opts.hook;\n    } else {\n      opts = {};\n      hook = hookFunction;\n    }\n    hook = hook.trim();\n    const [shaderStage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    const normalizedHook = Object.assign(opts, {\n      signature\n    });\n    switch (shaderStage) {\n      case 'vs':\n        result.vertex[name] = normalizedHook;\n        break;\n      case 'fs':\n        result.fragment[name] = normalizedHook;\n        break;\n      default:\n        throw new Error(shaderStage);\n    }\n  }\n  return result;\n}","map":{"version":3,"names":["getShaderHooks","hookFunctions","hookInjections","result","hookName","hookFunction","signature","header","injections","sort","a","b","order","injection","footer","normalizeShaderHooks","vertex","fragment","opts","hook","trim","shaderStage","split","name","replace","normalizedHook","Object","assign","Error"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\shadertools\\src\\lib\\shader-assembly\\shader-hooks.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderInjection} from './shader-injections';\n\n// A normalized hook function\n/**\n * The shader hook mechanism allows the application to create shaders\n * that can be automatically extended by the shader modules the application\n * includes.\n *\n * A shader hook function that shader modules can inject code into.\n * Shaders can call these functions, which will be no-ops by default.\n *\n * If a shader module injects code it will be executed upon the hook\n * function call.\n */\nexport type ShaderHook = {\n  /** `vs:` or `fs:` followed by the name and arguments of the function, e.g. `vs:MYHOOK_func(inout vec4 value)`. Hook name without arguments\n  will also be used as the name of the shader hook */\n  hook: string;\n  /** Code always included at the beginning of a hook function */\n  header: string;\n  /** Code always included at the end of a hook function */\n  footer: string;\n  /** To Be Documented */\n  signature?: string;\n};\n\n/** Normalized shader hooks per shader */\nexport type ShaderHooks = {\n  /** Normalized shader hooks for vertex shader */\n  vertex: Record<string, ShaderHook>;\n  /** Normalized shader hooks for fragment shader */\n  fragment: Record<string, ShaderHook>;\n};\n\n/** Generate hook source code */\nexport function getShaderHooks(\n  hookFunctions: Record<string, ShaderHook>,\n  hookInjections: Record<string, ShaderInjection[]>\n): string {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a: {order: number}, b: {order: number}): number => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\n\n/**\n * Parse string based hook functions\n * And split per shader\n */\nexport function normalizeShaderHooks(hookFunctions: (string | ShaderHook)[]): ShaderHooks {\n  const result: ShaderHooks = {vertex: {}, fragment: {}};\n\n  for (const hookFunction of hookFunctions) {\n    let opts: ShaderHook;\n    let hook: string;\n    if (typeof hookFunction !== 'string') {\n      opts = hookFunction;\n      hook = opts.hook;\n    } else {\n      opts = {} as ShaderHook;\n      hook = hookFunction;\n    }\n    hook = hook.trim();\n    const [shaderStage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    const normalizedHook: ShaderHook = Object.assign(opts, {signature});\n    switch (shaderStage) {\n      case 'vs':\n        result.vertex[name] = normalizedHook;\n        break;\n      case 'fs':\n        result.fragment[name] = normalizedHook;\n        break;\n      default:\n        throw new Error(shaderStage);\n    }\n  }\n\n  return result;\n}\n"],"mappings":"AAAA;AACA;AACA;AAoCA;AACA,OAAM,SAAUA,cAAcA,CAC5BC,aAAyC,EACzCC,cAAiD;EAEjD,IAAIC,MAAM,GAAG,EAAE;EACf,KAAK,MAAMC,QAAQ,IAAIH,aAAa,EAAE;IACpC,MAAMI,YAAY,GAAGJ,aAAa,CAACG,QAAQ,CAAC;IAC5CD,MAAM,IAAI,QAAQE,YAAY,CAACC,SAAS,MAAM;IAC9C,IAAID,YAAY,CAACE,MAAM,EAAE;MACvBJ,MAAM,IAAI,KAAKE,YAAY,CAACE,MAAM,EAAE;IACtC;IACA,IAAIL,cAAc,CAACE,QAAQ,CAAC,EAAE;MAC5B,MAAMI,UAAU,GAAGN,cAAc,CAACE,QAAQ,CAAC;MAC3CI,UAAU,CAACC,IAAI,CAAC,CAACC,CAAkB,EAAEC,CAAkB,KAAaD,CAAC,CAACE,KAAK,GAAGD,CAAC,CAACC,KAAK,CAAC;MACtF,KAAK,MAAMC,SAAS,IAAIL,UAAU,EAAE;QAClCL,MAAM,IAAI,KAAKU,SAAS,CAACA,SAAS,IAAI;MACxC;IACF;IACA,IAAIR,YAAY,CAACS,MAAM,EAAE;MACvBX,MAAM,IAAI,KAAKE,YAAY,CAACS,MAAM,EAAE;IACtC;IACAX,MAAM,IAAI,KAAK;EACjB;EAEA,OAAOA,MAAM;AACf;AAEA;;;;AAIA,OAAM,SAAUY,oBAAoBA,CAACd,aAAsC;EACzE,MAAME,MAAM,GAAgB;IAACa,MAAM,EAAE,EAAE;IAAEC,QAAQ,EAAE;EAAE,CAAC;EAEtD,KAAK,MAAMZ,YAAY,IAAIJ,aAAa,EAAE;IACxC,IAAIiB,IAAgB;IACpB,IAAIC,IAAY;IAChB,IAAI,OAAOd,YAAY,KAAK,QAAQ,EAAE;MACpCa,IAAI,GAAGb,YAAY;MACnBc,IAAI,GAAGD,IAAI,CAACC,IAAI;IAClB,CAAC,MAAM;MACLD,IAAI,GAAG,EAAgB;MACvBC,IAAI,GAAGd,YAAY;IACrB;IACAc,IAAI,GAAGA,IAAI,CAACC,IAAI,EAAE;IAClB,MAAM,CAACC,WAAW,EAAEf,SAAS,CAAC,GAAGa,IAAI,CAACG,KAAK,CAAC,GAAG,CAAC;IAChD,MAAMC,IAAI,GAAGJ,IAAI,CAACK,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;IACrC,MAAMC,cAAc,GAAeC,MAAM,CAACC,MAAM,CAACT,IAAI,EAAE;MAACZ;IAAS,CAAC,CAAC;IACnE,QAAQe,WAAW;MACjB,KAAK,IAAI;QACPlB,MAAM,CAACa,MAAM,CAACO,IAAI,CAAC,GAAGE,cAAc;QACpC;MACF,KAAK,IAAI;QACPtB,MAAM,CAACc,QAAQ,CAACM,IAAI,CAAC,GAAGE,cAAc;QACtC;MACF;QACE,MAAM,IAAIG,KAAK,CAACP,WAAW,CAAC;IAChC;EACF;EAEA,OAAOlB,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}