{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Layer, project32, picking, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/engine';\nimport { gouraudMaterial } from '@luma.gl/shadertools';\n// Polygon geometry generation is managed by the polygon tesselator\nimport PolygonTesselator from \"./polygon-tesselator.js\";\nimport { solidPolygonUniforms } from \"./solid-polygon-layer-uniforms.js\";\nimport vsTop from \"./solid-polygon-layer-vertex-top.glsl.js\";\nimport vsSide from \"./solid-polygon-layer-vertex-side.glsl.js\";\nimport fs from \"./solid-polygon-layer-fragment.glsl.js\";\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  _normalize: true,\n  _windingOrder: 'CW',\n  _full3d: false,\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  getPolygon: {\n    type: 'accessor',\n    value: f => f.polygon\n  },\n  getElevation: {\n    type: 'accessor',\n    value: 1000\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  material: true\n};\nconst ATTRIBUTE_TRANSITION = {\n  enter: (value, chunk) => {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\nclass SolidPolygonLayer extends Layer {\n  getShaders(type) {\n    return super.getShaders({\n      vs: type === 'top' ? vsTop : vsSide,\n      fs,\n      defines: {\n        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === 'CCW' ? 0 : 1\n      },\n      modules: [project32, gouraudMaterial, picking, solidPolygonUniforms]\n    });\n  }\n  get wrapLongitude() {\n    return false;\n  }\n  getBounds() {\n    return this.getAttributeManager()?.getBounds(['vertexPositions']);\n  }\n  initializeState() {\n    const {\n      viewport\n    } = this.context;\n    let {\n      coordinateSystem\n    } = this.props;\n    const {\n      _full3d\n    } = this.props;\n    if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n      coordinateSystem = COORDINATE_SYSTEM.LNGLAT;\n    }\n    let preproject;\n    if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n      if (_full3d) {\n        preproject = viewport.projectPosition.bind(viewport);\n      } else {\n        preproject = viewport.projectFlat.bind(viewport);\n      }\n    }\n    this.setState({\n      numInstances: 0,\n      polygonTesselator: new PolygonTesselator({\n        // Lnglat coordinates are usually projected non-linearly, which affects tesselation results\n        // Provide a preproject function if the coordinates are in lnglat\n        preproject,\n        fp64: this.use64bitPositions(),\n        IndexType: Uint32Array\n      })\n    });\n    const attributeManager = this.getAttributeManager();\n    const noAlloc = true;\n    attributeManager.remove(['instancePickingColors']);\n    /* eslint-disable max-len */\n    attributeManager.add({\n      indices: {\n        size: 1,\n        isIndexed: true,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        update: this.calculateIndices,\n        noAlloc\n      },\n      vertexPositions: {\n        size: 3,\n        type: 'float64',\n        stepMode: 'dynamic',\n        fp64: this.use64bitPositions(),\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getPolygon',\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        update: this.calculatePositions,\n        noAlloc,\n        shaderAttributes: {\n          nextVertexPositions: {\n            vertexOffset: 1\n          }\n        }\n      },\n      instanceVertexValid: {\n        size: 1,\n        type: 'uint16',\n        stepMode: 'instance',\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        update: this.calculateVertexValid,\n        noAlloc\n      },\n      elevations: {\n        size: 1,\n        stepMode: 'dynamic',\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getElevation'\n      },\n      fillColors: {\n        size: this.props.colorFormat.length,\n        type: 'unorm8',\n        stepMode: 'dynamic',\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getFillColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      lineColors: {\n        size: this.props.colorFormat.length,\n        type: 'unorm8',\n        stepMode: 'dynamic',\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getLineColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      pickingColors: {\n        size: 4,\n        type: 'uint8',\n        stepMode: 'dynamic',\n        accessor: (object, {\n          index,\n          target: value\n        }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)\n      }\n    });\n    /* eslint-enable max-len */\n  }\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {\n      index\n    } = info;\n    const data = this.props.data;\n    // Check if data comes from a composite layer, wrapped with getSubLayerRow\n    if (data[0] && data[0].__source) {\n      // index decoded from picking color refers to the source index\n      info.object = data.find(d => d.__source.index === index);\n    }\n    return info;\n  }\n  disablePickingIndex(objectIndex) {\n    const data = this.props.data;\n    // Check if data comes from a composite layer, wrapped with getSubLayerRow\n    if (data[0] && data[0].__source) {\n      // index decoded from picking color refers to the source index\n      for (let i = 0; i < data.length; i++) {\n        if (data[i].__source.index === objectIndex) {\n          this._disablePickingIndex(i);\n        }\n      }\n    } else {\n      super.disablePickingIndex(objectIndex);\n    }\n  }\n  draw({\n    uniforms\n  }) {\n    const {\n      extruded,\n      filled,\n      wireframe,\n      elevationScale\n    } = this.props;\n    const {\n      topModel,\n      sideModel,\n      wireframeModel,\n      polygonTesselator\n    } = this.state;\n    const renderUniforms = {\n      extruded: Boolean(extruded),\n      elevationScale,\n      isWireframe: false\n    };\n    // Note - the order is important\n    if (wireframeModel && wireframe) {\n      wireframeModel.setInstanceCount(polygonTesselator.instanceCount - 1);\n      wireframeModel.shaderInputs.setProps({\n        solidPolygon: {\n          ...renderUniforms,\n          isWireframe: true\n        }\n      });\n      wireframeModel.draw(this.context.renderPass);\n    }\n    if (sideModel && filled) {\n      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);\n      sideModel.shaderInputs.setProps({\n        solidPolygon: renderUniforms\n      });\n      sideModel.draw(this.context.renderPass);\n    }\n    if (topModel && filled) {\n      topModel.setVertexCount(polygonTesselator.vertexCount);\n      topModel.shaderInputs.setProps({\n        solidPolygon: renderUniforms\n      });\n      topModel.draw(this.context.renderPass);\n    }\n  }\n  updateState(updateParams) {\n    super.updateState(updateParams);\n    this.updateGeometry(updateParams);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = updateParams;\n    const attributeManager = this.getAttributeManager();\n    const regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;\n    if (regenerateModels) {\n      this.state.models?.forEach(model => model.destroy());\n      this.setState(this._getModels());\n      attributeManager.invalidateAll();\n    }\n  }\n  updateGeometry({\n    props,\n    oldProps,\n    changeFlags\n  }) {\n    const geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);\n    // When the geometry config  or the data is changed,\n    // tessellator needs to be invoked\n    if (geometryConfigChanged) {\n      const {\n        polygonTesselator\n      } = this.state;\n      const buffers = props.data.attributes || {};\n      polygonTesselator.updateGeometry({\n        data: props.data,\n        normalize: props._normalize,\n        geometryBuffer: buffers.getPolygon,\n        buffers,\n        getGeometry: props.getPolygon,\n        positionFormat: props.positionFormat,\n        wrapLongitude: props.wrapLongitude,\n        // TODO - move the flag out of the viewport\n        resolution: this.context.viewport.resolution,\n        fp64: this.use64bitPositions(),\n        dataChanged: changeFlags.dataChanged,\n        full3d: props._full3d\n      });\n      this.setState({\n        numInstances: polygonTesselator.instanceCount,\n        startIndices: polygonTesselator.vertexStarts\n      });\n      if (!changeFlags.dataChanged) {\n        // Base `layer.updateState` only invalidates all attributes on data change\n        // Cover the rest of the scenarios here\n        this.getAttributeManager().invalidateAll();\n      }\n    }\n  }\n  _getModels() {\n    const {\n      id,\n      filled,\n      extruded\n    } = this.props;\n    let topModel;\n    let sideModel;\n    let wireframeModel;\n    if (filled) {\n      const shaders = this.getShaders('top');\n      shaders.defines.NON_INSTANCED_MODEL = 1;\n      const bufferLayout = this.getAttributeManager().getBufferLayouts({\n        isInstanced: false\n      });\n      topModel = new Model(this.context.device, {\n        ...shaders,\n        id: `${id}-top`,\n        topology: 'triangle-list',\n        bufferLayout,\n        isIndexed: true,\n        userData: {\n          excludeAttributes: {\n            instanceVertexValid: true\n          }\n        }\n      });\n    }\n    if (extruded) {\n      const bufferLayout = this.getAttributeManager().getBufferLayouts({\n        isInstanced: true\n      });\n      sideModel = new Model(this.context.device, {\n        ...this.getShaders('side'),\n        id: `${id}-side`,\n        bufferLayout,\n        geometry: new Geometry({\n          topology: 'triangle-strip',\n          attributes: {\n            // top right - top left - bottom right - bottom left\n            positions: {\n              size: 2,\n              value: new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])\n            }\n          }\n        }),\n        isInstanced: true,\n        userData: {\n          excludeAttributes: {\n            indices: true\n          }\n        }\n      });\n      wireframeModel = new Model(this.context.device, {\n        ...this.getShaders('side'),\n        id: `${id}-wireframe`,\n        bufferLayout,\n        geometry: new Geometry({\n          topology: 'line-strip',\n          attributes: {\n            // top right - top left - bottom left - bottom right\n            positions: {\n              size: 2,\n              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])\n            }\n          }\n        }),\n        isInstanced: true,\n        userData: {\n          excludeAttributes: {\n            indices: true\n          }\n        }\n      });\n    }\n    return {\n      models: [sideModel, wireframeModel, topModel].filter(Boolean),\n      topModel,\n      sideModel,\n      wireframeModel\n    };\n  }\n  calculateIndices(attribute) {\n    const {\n      polygonTesselator\n    } = this.state;\n    attribute.startIndices = polygonTesselator.indexStarts;\n    attribute.value = polygonTesselator.get('indices');\n  }\n  calculatePositions(attribute) {\n    const {\n      polygonTesselator\n    } = this.state;\n    attribute.startIndices = polygonTesselator.vertexStarts;\n    attribute.value = polygonTesselator.get('positions');\n  }\n  calculateVertexValid(attribute) {\n    attribute.value = this.state.polygonTesselator.get('vertexValid');\n  }\n}\nSolidPolygonLayer.defaultProps = defaultProps;\nSolidPolygonLayer.layerName = 'SolidPolygonLayer';\nexport default SolidPolygonLayer;","map":{"version":3,"names":["Layer","project32","picking","COORDINATE_SYSTEM","Model","Geometry","gouraudMaterial","PolygonTesselator","solidPolygonUniforms","vsTop","vsSide","fs","DEFAULT_COLOR","defaultProps","filled","extruded","wireframe","_normalize","_windingOrder","_full3d","elevationScale","type","min","value","getPolygon","f","polygon","getElevation","getFillColor","getLineColor","material","ATTRIBUTE_TRANSITION","enter","chunk","length","subarray","SolidPolygonLayer","getShaders","vs","defines","RING_WINDING_ORDER_CW","props","modules","wrapLongitude","getBounds","getAttributeManager","initializeState","viewport","context","coordinateSystem","isGeospatial","DEFAULT","LNGLAT","preproject","projectPosition","bind","projectFlat","setState","numInstances","polygonTesselator","fp64","use64bitPositions","IndexType","Uint32Array","attributeManager","noAlloc","remove","add","indices","size","isIndexed","update","calculateIndices","vertexPositions","stepMode","transition","accessor","calculatePositions","shaderAttributes","nextVertexPositions","vertexOffset","instanceVertexValid","calculateVertexValid","elevations","fillColors","colorFormat","defaultValue","lineColors","pickingColors","object","index","target","encodePickingColor","__source","getPickingInfo","params","info","data","find","d","disablePickingIndex","objectIndex","i","_disablePickingIndex","draw","uniforms","topModel","sideModel","wireframeModel","state","renderUniforms","Boolean","isWireframe","setInstanceCount","instanceCount","shaderInputs","setProps","solidPolygon","renderPass","setVertexCount","vertexCount","updateState","updateParams","updateGeometry","oldProps","changeFlags","regenerateModels","extensionsChanged","models","forEach","model","destroy","_getModels","invalidateAll","geometryConfigChanged","dataChanged","updateTriggersChanged","all","buffers","attributes","normalize","geometryBuffer","getGeometry","positionFormat","resolution","full3d","startIndices","vertexStarts","id","shaders","NON_INSTANCED_MODEL","bufferLayout","getBufferLayouts","isInstanced","device","topology","userData","excludeAttributes","geometry","positions","Float32Array","filter","attribute","indexStarts","get","layerName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\layers\\src\\solid-polygon-layer\\solid-polygon-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Layer, project32, picking, COORDINATE_SYSTEM} from '@deck.gl/core';\nimport {Model, Geometry} from '@luma.gl/engine';\nimport {gouraudMaterial} from '@luma.gl/shadertools';\n\n// Polygon geometry generation is managed by the polygon tesselator\nimport PolygonTesselator from './polygon-tesselator';\n\nimport {solidPolygonUniforms, SolidPolygonProps} from './solid-polygon-layer-uniforms';\nimport vsTop from './solid-polygon-layer-vertex-top.glsl';\nimport vsSide from './solid-polygon-layer-vertex-side.glsl';\nimport fs from './solid-polygon-layer-fragment.glsl';\n\nimport type {\n  LayerProps,\n  LayerDataSource,\n  Color,\n  Material,\n  Accessor,\n  AccessorFunction,\n  UpdateParameters,\n  GetPickingInfoParams,\n  PickingInfo,\n  DefaultProps\n} from '@deck.gl/core';\nimport type {PolygonGeometry} from './polygon';\n\ntype _SolidPolygonLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  /** Whether to fill the polygons\n   * @default true\n   */\n  filled?: boolean;\n  /** Whether to extrude the polygons\n   * @default false\n   */\n  extruded?: boolean;\n  /** Whether to generate a line wireframe of the polygon.\n   * @default false\n   */\n  wireframe?: boolean;\n  /**\n   * (Experimental) If `false`, will skip normalizing the coordinates returned by `getPolygon`.\n   * @default true\n   */\n  _normalize?: boolean;\n  /**\n   * (Experimental) This prop is only effective with `_normalize: false`.\n   * It specifies the winding order of rings in the polygon data, one of 'CW' (clockwise) and 'CCW' (counter-clockwise)\n   */\n  _windingOrder?: 'CW' | 'CCW';\n\n  /**\n   * (Experimental) This prop is only effective with `XYZ` data.\n   * When true, polygon tesselation will be performed on the plane with the largest area, instead of the xy plane.\n   * @default false\n   */\n  _full3d?: boolean;\n\n  /** Elevation multiplier.\n   * @default 1\n   */\n  elevationScale?: number;\n\n  /** Polygon geometry accessor. */\n  getPolygon?: AccessorFunction<DataT, PolygonGeometry>;\n  /** Extrusion height accessor.\n   * @default 1000\n   */\n  getElevation?: Accessor<DataT, number>;\n  /** Fill color accessor.\n   * @default [0, 0, 0, 255]\n   */\n  getFillColor?: Accessor<DataT, Color>;\n  /** Stroke color accessor.\n   * @default [0, 0, 0, 255]\n   */\n  getLineColor?: Accessor<DataT, Color>;\n\n  /**\n   * Material settings for lighting effect. Applies if `extruded: true`\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n};\n\n/** Render filled and/or extruded polygons. */\nexport type SolidPolygonLayerProps<DataT = unknown> = _SolidPolygonLayerProps<DataT> & LayerProps;\n\nconst DEFAULT_COLOR: [number, number, number, number] = [0, 0, 0, 255];\n\nconst defaultProps: DefaultProps<SolidPolygonLayerProps> = {\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  _normalize: true,\n  _windingOrder: 'CW',\n  _full3d: false,\n\n  elevationScale: {type: 'number', min: 0, value: 1},\n\n  getPolygon: {type: 'accessor', value: (f: any) => f.polygon},\n  getElevation: {type: 'accessor', value: 1000},\n  getFillColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getLineColor: {type: 'accessor', value: DEFAULT_COLOR},\n\n  material: true\n};\n\nconst ATTRIBUTE_TRANSITION = {\n  enter: (value, chunk) => {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\n\nexport default class SolidPolygonLayer<DataT = any, ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_SolidPolygonLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'SolidPolygonLayer';\n\n  state!: {\n    topModel?: Model;\n    sideModel?: Model;\n    wireframeModel?: Model;\n    models?: Model[];\n    numInstances: number;\n    polygonTesselator: PolygonTesselator;\n  };\n\n  getShaders(type) {\n    return super.getShaders({\n      vs: type === 'top' ? vsTop : vsSide,\n      fs,\n      defines: {\n        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === 'CCW' ? 0 : 1\n      },\n      modules: [project32, gouraudMaterial, picking, solidPolygonUniforms]\n    });\n  }\n\n  get wrapLongitude(): boolean {\n    return false;\n  }\n\n  getBounds(): [number[], number[]] | null {\n    return this.getAttributeManager()?.getBounds(['vertexPositions']);\n  }\n\n  initializeState() {\n    const {viewport} = this.context;\n    let {coordinateSystem} = this.props;\n    const {_full3d} = this.props;\n    if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n      coordinateSystem = COORDINATE_SYSTEM.LNGLAT;\n    }\n\n    let preproject: ((xy: number[]) => number[]) | undefined;\n\n    if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n      if (_full3d) {\n        preproject = viewport.projectPosition.bind(viewport);\n      } else {\n        preproject = viewport.projectFlat.bind(viewport);\n      }\n    }\n\n    this.setState({\n      numInstances: 0,\n      polygonTesselator: new PolygonTesselator({\n        // Lnglat coordinates are usually projected non-linearly, which affects tesselation results\n        // Provide a preproject function if the coordinates are in lnglat\n        preproject,\n        fp64: this.use64bitPositions(),\n        IndexType: Uint32Array\n      })\n    });\n\n    const attributeManager = this.getAttributeManager()!;\n    const noAlloc = true;\n\n    attributeManager.remove(['instancePickingColors']);\n\n    /* eslint-disable max-len */\n    attributeManager.add({\n      indices: {\n        size: 1,\n        isIndexed: true,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        update: this.calculateIndices,\n        noAlloc\n      },\n      vertexPositions: {\n        size: 3,\n        type: 'float64',\n        stepMode: 'dynamic',\n        fp64: this.use64bitPositions(),\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getPolygon',\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        update: this.calculatePositions,\n        noAlloc,\n        shaderAttributes: {\n          nextVertexPositions: {\n            vertexOffset: 1\n          }\n        }\n      },\n      instanceVertexValid: {\n        size: 1,\n        type: 'uint16',\n        stepMode: 'instance',\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        update: this.calculateVertexValid,\n        noAlloc\n      },\n      elevations: {\n        size: 1,\n        stepMode: 'dynamic',\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getElevation'\n      },\n      fillColors: {\n        size: this.props.colorFormat.length,\n        type: 'unorm8',\n        stepMode: 'dynamic',\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getFillColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      lineColors: {\n        size: this.props.colorFormat.length,\n        type: 'unorm8',\n        stepMode: 'dynamic',\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getLineColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      pickingColors: {\n        size: 4,\n        type: 'uint8',\n        stepMode: 'dynamic',\n        accessor: (object, {index, target: value}) =>\n          this.encodePickingColor(object && object.__source ? object.__source.index : index, value)\n      }\n    });\n    /* eslint-enable max-len */\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): PickingInfo {\n    const info = super.getPickingInfo(params);\n    const {index} = info;\n    const data = this.props.data as any[];\n\n    // Check if data comes from a composite layer, wrapped with getSubLayerRow\n    if (data[0] && data[0].__source) {\n      // index decoded from picking color refers to the source index\n      info.object = data.find(d => d.__source.index === index);\n    }\n    return info;\n  }\n\n  disablePickingIndex(objectIndex: number) {\n    const data = this.props.data as any[];\n\n    // Check if data comes from a composite layer, wrapped with getSubLayerRow\n    if (data[0] && data[0].__source) {\n      // index decoded from picking color refers to the source index\n      for (let i = 0; i < data.length; i++) {\n        if (data[i].__source.index === objectIndex) {\n          this._disablePickingIndex(i);\n        }\n      }\n    } else {\n      super.disablePickingIndex(objectIndex);\n    }\n  }\n\n  draw({uniforms}) {\n    const {extruded, filled, wireframe, elevationScale} = this.props;\n    const {topModel, sideModel, wireframeModel, polygonTesselator} = this.state;\n\n    const renderUniforms: SolidPolygonProps = {\n      extruded: Boolean(extruded),\n      elevationScale,\n      isWireframe: false\n    };\n\n    // Note - the order is important\n    if (wireframeModel && wireframe) {\n      wireframeModel.setInstanceCount(polygonTesselator.instanceCount - 1);\n      wireframeModel.shaderInputs.setProps({solidPolygon: {...renderUniforms, isWireframe: true}});\n      wireframeModel.draw(this.context.renderPass);\n    }\n\n    if (sideModel && filled) {\n      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);\n      sideModel.shaderInputs.setProps({solidPolygon: renderUniforms});\n      sideModel.draw(this.context.renderPass);\n    }\n\n    if (topModel && filled) {\n      topModel.setVertexCount(polygonTesselator.vertexCount);\n      topModel.shaderInputs.setProps({solidPolygon: renderUniforms});\n      topModel.draw(this.context.renderPass);\n    }\n  }\n\n  updateState(updateParams: UpdateParameters<this>) {\n    super.updateState(updateParams);\n\n    this.updateGeometry(updateParams);\n\n    const {props, oldProps, changeFlags} = updateParams;\n    const attributeManager = this.getAttributeManager();\n\n    const regenerateModels =\n      changeFlags.extensionsChanged ||\n      props.filled !== oldProps.filled ||\n      props.extruded !== oldProps.extruded;\n\n    if (regenerateModels) {\n      this.state.models?.forEach(model => model.destroy());\n\n      this.setState(this._getModels());\n      attributeManager!.invalidateAll();\n    }\n  }\n\n  protected updateGeometry({props, oldProps, changeFlags}: UpdateParameters<this>) {\n    const geometryConfigChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon));\n\n    // When the geometry config  or the data is changed,\n    // tessellator needs to be invoked\n    if (geometryConfigChanged) {\n      const {polygonTesselator} = this.state;\n      const buffers = (props.data as any).attributes || {};\n      polygonTesselator.updateGeometry({\n        data: props.data,\n        normalize: props._normalize,\n        geometryBuffer: buffers.getPolygon,\n        buffers,\n        getGeometry: props.getPolygon,\n        positionFormat: props.positionFormat,\n        wrapLongitude: props.wrapLongitude,\n        // TODO - move the flag out of the viewport\n        resolution: this.context.viewport.resolution,\n        fp64: this.use64bitPositions(),\n        dataChanged: changeFlags.dataChanged,\n        full3d: props._full3d\n      });\n\n      this.setState({\n        numInstances: polygonTesselator.instanceCount,\n        startIndices: polygonTesselator.vertexStarts\n      });\n\n      if (!changeFlags.dataChanged) {\n        // Base `layer.updateState` only invalidates all attributes on data change\n        // Cover the rest of the scenarios here\n        this.getAttributeManager()!.invalidateAll();\n      }\n    }\n  }\n\n  protected _getModels() {\n    const {id, filled, extruded} = this.props;\n\n    let topModel;\n    let sideModel;\n    let wireframeModel;\n\n    if (filled) {\n      const shaders = this.getShaders('top');\n      shaders.defines.NON_INSTANCED_MODEL = 1;\n      const bufferLayout = this.getAttributeManager()!.getBufferLayouts({isInstanced: false});\n\n      topModel = new Model(this.context.device, {\n        ...shaders,\n        id: `${id}-top`,\n        topology: 'triangle-list',\n        bufferLayout,\n        isIndexed: true,\n        userData: {\n          excludeAttributes: {instanceVertexValid: true}\n        }\n      });\n    }\n    if (extruded) {\n      const bufferLayout = this.getAttributeManager()!.getBufferLayouts({isInstanced: true});\n\n      sideModel = new Model(this.context.device, {\n        ...this.getShaders('side'),\n        id: `${id}-side`,\n        bufferLayout,\n        geometry: new Geometry({\n          topology: 'triangle-strip',\n          attributes: {\n            // top right - top left - bottom right - bottom left\n            positions: {\n              size: 2,\n              value: new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])\n            }\n          }\n        }),\n        isInstanced: true,\n        userData: {\n          excludeAttributes: {indices: true}\n        }\n      });\n\n      wireframeModel = new Model(this.context.device, {\n        ...this.getShaders('side'),\n        id: `${id}-wireframe`,\n        bufferLayout,\n        geometry: new Geometry({\n          topology: 'line-strip',\n          attributes: {\n            // top right - top left - bottom left - bottom right\n            positions: {\n              size: 2,\n              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])\n            }\n          }\n        }),\n        isInstanced: true,\n        userData: {\n          excludeAttributes: {indices: true}\n        }\n      });\n    }\n\n    return {\n      models: [sideModel, wireframeModel, topModel].filter(Boolean),\n      topModel,\n      sideModel,\n      wireframeModel\n    };\n  }\n\n  protected calculateIndices(attribute) {\n    const {polygonTesselator} = this.state;\n    attribute.startIndices = polygonTesselator.indexStarts;\n    attribute.value = polygonTesselator.get('indices');\n  }\n\n  protected calculatePositions(attribute) {\n    const {polygonTesselator} = this.state;\n    attribute.startIndices = polygonTesselator.vertexStarts;\n    attribute.value = polygonTesselator.get('positions');\n  }\n\n  protected calculateVertexValid(attribute) {\n    attribute.value = this.state.polygonTesselator.get('vertexValid');\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}