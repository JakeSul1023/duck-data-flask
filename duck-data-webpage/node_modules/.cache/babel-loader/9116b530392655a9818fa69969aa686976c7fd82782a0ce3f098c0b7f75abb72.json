{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getTypedArrayFromDataType, getDataTypeFromTypedArray } from '@luma.gl/core';\nexport function typedArrayFromDataType(type) {\n  // Sorted in some order of likelihood to reduce amount of comparisons\n  switch (type) {\n    case 'float64':\n      return Float64Array;\n    case 'uint8':\n    case 'unorm8':\n      return Uint8ClampedArray;\n    default:\n      return getTypedArrayFromDataType(type);\n  }\n}\nexport const dataTypeFromTypedArray = getDataTypeFromTypedArray;\nexport function getBufferAttributeLayout(name, accessor, deviceType) {\n  // TODO(ibgreen): WebGPU change. Currently we always use normalized 8 bit integers\n  const type = deviceType === 'webgpu' && accessor.type === 'uint8' ? 'unorm8' : accessor.type;\n  return {\n    attribute: name,\n    // @ts-expect-error Not all combinations are valid vertex formats; it's up to DataColumn to ensure\n    format: accessor.size > 1 ? `${type}x${accessor.size}` : accessor.type,\n    byteOffset: accessor.offset || 0\n    // Note stride is set on the top level\n  };\n}\nexport function getStride(accessor) {\n  return accessor.stride || accessor.size * accessor.bytesPerElement;\n}\nexport function bufferLayoutEqual(accessor1, accessor2) {\n  return accessor1.type === accessor2.type && accessor1.size === accessor2.size && getStride(accessor1) === getStride(accessor2) && (accessor1.offset || 0) === (accessor2.offset || 0);\n}","map":{"version":3,"names":["getTypedArrayFromDataType","getDataTypeFromTypedArray","typedArrayFromDataType","type","Float64Array","Uint8ClampedArray","dataTypeFromTypedArray","getBufferAttributeLayout","name","accessor","deviceType","attribute","format","size","byteOffset","offset","getStride","stride","bytesPerElement","bufferLayoutEqual","accessor1","accessor2"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\lib\\attribute\\gl-utils.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {getTypedArrayFromDataType, getDataTypeFromTypedArray} from '@luma.gl/core';\nimport type {BufferAttributeLayout, VertexFormat} from '@luma.gl/core';\nimport type {TypedArrayConstructor} from '../../types/types';\nimport type {BufferAccessor, DataColumnSettings, LogicalDataType} from './data-column';\n\nexport function typedArrayFromDataType(type: LogicalDataType): TypedArrayConstructor {\n  // Sorted in some order of likelihood to reduce amount of comparisons\n  switch (type) {\n    case 'float64':\n      return Float64Array;\n    case 'uint8':\n    case 'unorm8':\n      return Uint8ClampedArray;\n    default:\n      return getTypedArrayFromDataType(type);\n  }\n}\n\nexport const dataTypeFromTypedArray = getDataTypeFromTypedArray;\n\nexport function getBufferAttributeLayout(\n  name: string,\n  accessor: BufferAccessor,\n  deviceType: 'webgpu' | 'wegbgl' | string\n): BufferAttributeLayout {\n  // TODO(ibgreen): WebGPU change. Currently we always use normalized 8 bit integers\n  const type = deviceType === 'webgpu' && accessor.type === 'uint8' ? 'unorm8' : accessor.type;\n  return {\n    attribute: name,\n    // @ts-expect-error Not all combinations are valid vertex formats; it's up to DataColumn to ensure\n    format:\n      (accessor.size as number) > 1 ? (`${type}x${accessor.size}` as VertexFormat) : accessor.type,\n    byteOffset: accessor.offset || 0\n    // Note stride is set on the top level\n  };\n}\n\nexport function getStride(accessor: DataColumnSettings<unknown>): number {\n  return accessor.stride || accessor.size * accessor.bytesPerElement;\n}\n\nexport function bufferLayoutEqual(\n  accessor1: DataColumnSettings<unknown>,\n  accessor2: DataColumnSettings<unknown>\n) {\n  return (\n    accessor1.type === accessor2.type &&\n    accessor1.size === accessor2.size &&\n    getStride(accessor1) === getStride(accessor2) &&\n    (accessor1.offset || 0) === (accessor2.offset || 0)\n  );\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA,SAAQA,yBAAyB,EAAEC,yBAAyB,QAAO,eAAe;AAKlF,OAAM,SAAUC,sBAAsBA,CAACC,IAAqB;EAC1D;EACA,QAAQA,IAAI;IACV,KAAK,SAAS;MACZ,OAAOC,YAAY;IACrB,KAAK,OAAO;IACZ,KAAK,QAAQ;MACX,OAAOC,iBAAiB;IAC1B;MACE,OAAOL,yBAAyB,CAACG,IAAI,CAAC;EAC1C;AACF;AAEA,OAAO,MAAMG,sBAAsB,GAAGL,yBAAyB;AAE/D,OAAM,SAAUM,wBAAwBA,CACtCC,IAAY,EACZC,QAAwB,EACxBC,UAAwC;EAExC;EACA,MAAMP,IAAI,GAAGO,UAAU,KAAK,QAAQ,IAAID,QAAQ,CAACN,IAAI,KAAK,OAAO,GAAG,QAAQ,GAAGM,QAAQ,CAACN,IAAI;EAC5F,OAAO;IACLQ,SAAS,EAAEH,IAAI;IACf;IACAI,MAAM,EACHH,QAAQ,CAACI,IAAe,GAAG,CAAC,GAAI,GAAGV,IAAI,IAAIM,QAAQ,CAACI,IAAI,EAAmB,GAAGJ,QAAQ,CAACN,IAAI;IAC9FW,UAAU,EAAEL,QAAQ,CAACM,MAAM,IAAI;IAC/B;GACD;AACH;AAEA,OAAM,SAAUC,SAASA,CAACP,QAAqC;EAC7D,OAAOA,QAAQ,CAACQ,MAAM,IAAIR,QAAQ,CAACI,IAAI,GAAGJ,QAAQ,CAACS,eAAe;AACpE;AAEA,OAAM,SAAUC,iBAAiBA,CAC/BC,SAAsC,EACtCC,SAAsC;EAEtC,OACED,SAAS,CAACjB,IAAI,KAAKkB,SAAS,CAAClB,IAAI,IACjCiB,SAAS,CAACP,IAAI,KAAKQ,SAAS,CAACR,IAAI,IACjCG,SAAS,CAACI,SAAS,CAAC,KAAKJ,SAAS,CAACK,SAAS,CAAC,IAC7C,CAACD,SAAS,CAACL,MAAM,IAAI,CAAC,OAAOM,SAAS,CAACN,MAAM,IAAI,CAAC,CAAC;AAEvD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}