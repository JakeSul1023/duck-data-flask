{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Resource } from \"./resource.js\";\n/**\n * Abstract Texture interface\n * Texture Object\n * https://gpuweb.github.io/gpuweb/#gputexture\n */\nexport class Texture extends Resource {\n  static COPY_SRC = 0x01;\n  static COPY_DST = 0x02;\n  static TEXTURE = 0x04;\n  static STORAGE = 0x08;\n  static RENDER_ATTACHMENT = 0x10;\n  static CubeFaces = ['+X', '-X', '+Y', '-Y', '+Z', '-Z'];\n  static defaultProps = (() => ({\n    ...Resource.defaultProps,\n    data: null,\n    dimension: '2d',\n    format: 'rgba8unorm',\n    width: undefined,\n    height: undefined,\n    depth: 1,\n    mipmaps: false,\n    compressed: false,\n    usage: 0,\n    mipLevels: undefined,\n    samples: undefined,\n    sampler: {},\n    view: undefined,\n    flipY: undefined\n  }))();\n  get [Symbol.toStringTag]() {\n    return 'Texture';\n  }\n  toString() {\n    return `Texture(${this.id},${this.format},${this.width}x${this.height})`;\n  }\n  /** dimension of this texture */\n  dimension;\n  /** format of this texture */\n  format;\n  /** width in pixels of this texture */\n  width;\n  /** height in pixels of this texture */\n  height;\n  /** depth of this texture */\n  depth;\n  /** mip levels in this texture */\n  mipLevels;\n  /** \"Time\" of last update. Monotonically increasing timestamp. TODO move to AsyncTexture? */\n  updateTimestamp;\n  /** Do not use directly. Create with device.createTexture() */\n  constructor(device, props) {\n    props = Texture.normalizeProps(device, props);\n    super(device, props, Texture.defaultProps);\n    this.dimension = this.props.dimension;\n    this.format = this.props.format;\n    // Size\n    this.width = this.props.width;\n    this.height = this.props.height;\n    this.depth = this.props.depth;\n    // Calculate size, if not provided\n    if (this.props.width === undefined || this.props.height === undefined) {\n      // @ts-ignore\n      const size = Texture.getTextureDataSize(this.props.data);\n      this.width = size?.width || 1;\n      this.height = size?.height || 1;\n    }\n    // mipLevels\n    // If mipmap generation is requested and mipLevels is not provided, initialize a full pyramid\n    if (this.props.mipmaps && this.props.mipLevels === undefined) {\n      this.props.mipLevels = 'pyramid';\n    }\n    // Auto-calculate the number of mip levels as a convenience\n    // TODO - Should we clamp to 1-getMipLevelCount?\n    this.mipLevels = this.props.mipLevels === 'pyramid' ? Texture.getMipLevelCount(this.width, this.height) : this.props.mipLevels || 1;\n    // TODO - perhaps this should be set on async write completion?\n    this.updateTimestamp = device.incrementTimestamp();\n  }\n  /**\n   * Create a new texture with the same parameters and optionally, a different size\n   * @note Textures are immutable and cannot be resized after creation, but we can create a similar texture with the same parameters but a new size.\n   * @note Does not copy contents of the texture\n   */\n  clone(size) {\n    return this.device.createTexture({\n      ...this.props,\n      ...size\n    });\n  }\n  /** Check if data is an external image */\n  static isExternalImage(data) {\n    return typeof ImageData !== 'undefined' && data instanceof ImageData || typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap || typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement || typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement || typeof VideoFrame !== 'undefined' && data instanceof VideoFrame || typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas;\n  }\n  /** Determine size (width and height) of provided image data */\n  static getExternalImageSize(data) {\n    if (typeof ImageData !== 'undefined' && data instanceof ImageData || typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap || typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas) {\n      return {\n        width: data.width,\n        height: data.height\n      };\n    }\n    if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {\n      return {\n        width: data.naturalWidth,\n        height: data.naturalHeight\n      };\n    }\n    if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {\n      return {\n        width: data.videoWidth,\n        height: data.videoHeight\n      };\n    }\n    if (typeof VideoFrame !== 'undefined' && data instanceof VideoFrame) {\n      // TODO: is this the right choice for width and height?\n      return {\n        width: data.displayWidth,\n        height: data.displayHeight\n      };\n    }\n    throw new Error('Unknown image type');\n  }\n  /** Check if texture data is a typed array */\n  static isTextureLevelData(data) {\n    const typedArray = data?.data;\n    return ArrayBuffer.isView(typedArray);\n  }\n  /** Get the size of the texture described by the provided TextureData */\n  static getTextureDataSize(data) {\n    if (!data) {\n      return null;\n    }\n    if (ArrayBuffer.isView(data)) {\n      return null;\n    }\n    // Recurse into arrays (array of miplevels)\n    if (Array.isArray(data)) {\n      return Texture.getTextureDataSize(data[0]);\n    }\n    if (Texture.isExternalImage(data)) {\n      return Texture.getExternalImageSize(data);\n    }\n    if (data && typeof data === 'object' && data.constructor === Object) {\n      const textureDataArray = Object.values(data);\n      const untypedData = textureDataArray[0];\n      return {\n        width: untypedData.width,\n        height: untypedData.height\n      };\n    }\n    throw new Error('texture size deduction failed');\n  }\n  /**\n   * Normalize TextureData to an array of TextureLevelData / ExternalImages\n   * @param data\n   * @param options\n   * @returns array of TextureLevelData / ExternalImages\n   */\n  static normalizeTextureData(data, options) {\n    let lodArray;\n    if (ArrayBuffer.isView(data)) {\n      lodArray = [{\n        // ts-expect-error does data really need to be Uint8ClampedArray?\n        data,\n        width: options.width,\n        height: options.height\n        // depth: options.depth\n      }];\n    } else if (!Array.isArray(data)) {\n      lodArray = [data];\n    } else {\n      lodArray = data;\n    }\n    return lodArray;\n  }\n  /** Calculate the number of mip levels for a texture of width and height */\n  static getMipLevelCount(width, height) {\n    return Math.floor(Math.log2(Math.max(width, height))) + 1;\n  }\n  /** Convert luma.gl cubemap face constants to depth index */\n  static getCubeFaceDepth(face) {\n    // prettier-ignore\n    switch (face) {\n      case '+X':\n        return 0;\n      case '-X':\n        return 1;\n      case '+Y':\n        return 2;\n      case '-Y':\n        return 3;\n      case '+Z':\n        return 4;\n      case '-Z':\n        return 5;\n      default:\n        throw new Error(face);\n    }\n  }\n  /** Default options */\n  static defaultCopyExternalImageOptions = (() => ({\n    image: undefined,\n    sourceX: 0,\n    sourceY: 0,\n    width: undefined,\n    height: undefined,\n    depth: 1,\n    mipLevel: 0,\n    x: 0,\n    y: 0,\n    z: 0,\n    aspect: 'all',\n    colorSpace: 'srgb',\n    premultipliedAlpha: false,\n    flipY: false\n  }))();\n  /** Ensure we have integer coordinates */\n  static normalizeProps(device, props) {\n    const newProps = {\n      ...props\n    };\n    // Allow device to override props (e.g. props.mipmaps)\n    const overriddenDefaultProps = device?.props?._resourceDefaults?.texture || {};\n    // TODO - Type issue with props.data circumvented with Object.assign\n    Object.assign(newProps, overriddenDefaultProps);\n    // Ensure we have integer coordinates\n    const {\n      width,\n      height\n    } = newProps;\n    if (typeof width === 'number') {\n      newProps.width = Math.max(1, Math.ceil(width));\n    }\n    if (typeof height === 'number') {\n      newProps.height = Math.max(1, Math.ceil(height));\n    }\n    return newProps;\n  }\n}\n//# sourceMappingURL=texture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}