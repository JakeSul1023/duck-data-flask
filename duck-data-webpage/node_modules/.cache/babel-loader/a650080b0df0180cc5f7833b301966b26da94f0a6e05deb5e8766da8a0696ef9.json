{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { _deepEqual as deepEqual, LayerExtension, log } from '@deck.gl/core';\nimport { dataFilter, dataFilter64 } from \"./shader-module.js\";\nimport * as aggregator from \"./aggregator.js\";\nconst defaultProps = {\n  getFilterValue: {\n    type: 'accessor',\n    value: 0\n  },\n  getFilterCategory: {\n    type: 'accessor',\n    value: 0\n  },\n  onFilteredItemsChange: {\n    type: 'function',\n    value: null,\n    optional: true\n  },\n  filterEnabled: true,\n  filterRange: [-1, 1],\n  filterSoftRange: null,\n  filterCategories: [0],\n  filterTransformSize: true,\n  filterTransformColor: true\n};\nconst defaultOptions = {\n  categorySize: 0,\n  filterSize: 1,\n  fp64: false,\n  countItems: false\n};\nconst CATEGORY_TYPE_FROM_SIZE = {\n  1: 'uint',\n  2: 'uvec2',\n  3: 'uvec3',\n  4: 'uvec4'\n};\nconst DATA_TYPE_FROM_SIZE = {\n  1: 'float',\n  2: 'vec2',\n  3: 'vec3',\n  4: 'vec4'\n};\n/** Adds GPU-based data filtering functionalities to layers. It allows the layer to show/hide objects based on user-defined properties. */\nclass DataFilterExtension extends LayerExtension {\n  constructor(opts = {}) {\n    super({\n      ...defaultOptions,\n      ...opts\n    });\n  }\n  getShaders(extension) {\n    const {\n      categorySize,\n      filterSize,\n      fp64\n    } = extension.opts;\n    const defines = {};\n    if (categorySize) {\n      defines.DATACATEGORY_TYPE = CATEGORY_TYPE_FROM_SIZE[categorySize];\n      defines.DATACATEGORY_CHANNELS = categorySize;\n    }\n    if (filterSize) {\n      defines.DATAFILTER_TYPE = DATA_TYPE_FROM_SIZE[filterSize];\n      defines.DATAFILTER_DOUBLE = Boolean(fp64);\n    }\n    const module = fp64 ? dataFilter64 : dataFilter;\n    module.uniformTypes = module.uniformTypesFromOptions(extension.opts);\n    return {\n      modules: [module],\n      defines\n    };\n  }\n  initializeState(context, extension) {\n    const attributeManager = this.getAttributeManager();\n    const {\n      categorySize,\n      filterSize,\n      fp64\n    } = extension.opts;\n    if (attributeManager) {\n      if (filterSize) {\n        attributeManager.add({\n          filterValues: {\n            size: filterSize,\n            type: fp64 ? 'float64' : 'float32',\n            stepMode: 'dynamic',\n            accessor: 'getFilterValue'\n          }\n        });\n      }\n      if (categorySize) {\n        attributeManager.add({\n          filterCategoryValues: {\n            size: categorySize,\n            stepMode: 'dynamic',\n            accessor: 'getFilterCategory',\n            type: 'uint32',\n            transform: categorySize === 1 ? d => extension._getCategoryKey.call(this, d, 0) : d => d.map((x, i) => extension._getCategoryKey.call(this, x, i))\n          }\n        });\n      }\n    }\n    const {\n      device\n    } = this.context;\n    if (attributeManager && extension.opts.countItems) {\n      const useFloatTarget = aggregator.supportsFloatTarget(device);\n      // This attribute is needed for variable-width data, e.g. Path, SolidPolygon, Text\n      // The vertex shader checks if a vertex has the same \"index\" as the previous vertex\n      // so that we only write one count cross multiple vertices of the same object\n      attributeManager.add({\n        filterVertexIndices: {\n          size: useFloatTarget ? 1 : 2,\n          vertexOffset: 1,\n          type: 'unorm8',\n          accessor: (object, {\n            index\n          }) => {\n            const i = object && object.__source ? object.__source.index : index;\n            return useFloatTarget ? (i + 1) % 255 : [(i + 1) % 255, Math.floor(i / 255) % 255];\n          },\n          shaderAttributes: {\n            filterPrevIndices: {\n              vertexOffset: 0\n            },\n            filterIndices: {\n              vertexOffset: 1\n            }\n          }\n        }\n      });\n      const filterFBO = aggregator.getFramebuffer(device, useFloatTarget);\n      const filterModel = aggregator.getModel(device, attributeManager.getBufferLayouts({\n        isInstanced: false\n      }), extension.getShaders.call(this, extension), useFloatTarget);\n      this.setState({\n        filterFBO,\n        filterModel\n      });\n    }\n  }\n  updateState({\n    props,\n    oldProps,\n    changeFlags\n  }, extension) {\n    const attributeManager = this.getAttributeManager();\n    const {\n      categorySize\n    } = extension.opts;\n    if (this.state.filterModel) {\n      const filterNeedsUpdate =\n      // attributeManager must be defined for filterModel to be set\n      attributeManager.attributes.filterValues?.needsUpdate() || attributeManager.attributes.filterCategoryValues?.needsUpdate() || props.filterEnabled !== oldProps.filterEnabled || props.filterRange !== oldProps.filterRange || props.filterSoftRange !== oldProps.filterSoftRange || props.filterCategories !== oldProps.filterCategories;\n      if (filterNeedsUpdate) {\n        this.setState({\n          filterNeedsUpdate\n        });\n      }\n    }\n    if (attributeManager?.attributes.filterCategoryValues) {\n      // Update bitmask if accessor or selected categories has changed\n      const categoryBitMaskNeedsUpdate = attributeManager.attributes.filterCategoryValues.needsUpdate() || !deepEqual(props.filterCategories, oldProps.filterCategories, 2);\n      if (categoryBitMaskNeedsUpdate) {\n        this.setState({\n          categoryBitMask: null\n        });\n      }\n      // Need to recreate category map if categorySize has changed\n      const resetCategories = changeFlags.dataChanged;\n      if (resetCategories) {\n        this.setState({\n          categoryMap: Array(categorySize).fill(0).map(() => ({}))\n        });\n        attributeManager.attributes.filterCategoryValues.setNeedsUpdate('categoryMap');\n      }\n    }\n  }\n  draw(params, extension) {\n    const filterFBO = this.state.filterFBO;\n    const filterModel = this.state.filterModel;\n    const filterNeedsUpdate = this.state.filterNeedsUpdate;\n    if (!this.state.categoryBitMask) {\n      extension._updateCategoryBitMask.call(this, params, extension);\n    }\n    const {\n      onFilteredItemsChange,\n      extensions,\n      filterEnabled,\n      filterRange,\n      filterSoftRange,\n      filterTransformSize,\n      filterTransformColor,\n      filterCategories\n    } = this.props;\n    const dataFilterProps = {\n      extensions,\n      filterEnabled,\n      filterRange,\n      filterSoftRange,\n      filterTransformSize,\n      filterTransformColor,\n      filterCategories\n    };\n    if (this.state.categoryBitMask) {\n      dataFilterProps.categoryBitMask = this.state.categoryBitMask;\n    }\n    this.setShaderModuleProps({\n      dataFilter: dataFilterProps\n    });\n    /* eslint-disable-next-line camelcase */\n    if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {\n      const attributeManager = this.getAttributeManager();\n      const {\n        attributes: {\n          filterValues,\n          filterCategoryValues,\n          filterVertexIndices\n        }\n      } = attributeManager;\n      filterModel.setVertexCount(this.getNumInstances());\n      // @ts-expect-error filterValue and filterVertexIndices should always have buffer value\n      const attributes = {\n        ...filterValues?.getValue(),\n        ...filterCategoryValues?.getValue(),\n        ...filterVertexIndices?.getValue()\n      };\n      filterModel.setAttributes(attributes);\n      filterModel.shaderInputs.setProps({\n        dataFilter: dataFilterProps\n      });\n      const viewport = [0, 0, filterFBO.width, filterFBO.height];\n      const renderPass = filterModel.device.beginRenderPass({\n        id: 'data-filter-aggregation',\n        framebuffer: filterFBO,\n        parameters: {\n          viewport\n        },\n        clearColor: [0, 0, 0, 0]\n      });\n      filterModel.setParameters(aggregator.parameters);\n      filterModel.draw(renderPass);\n      renderPass.end();\n      const color = filterModel.device.readPixelsToArrayWebGL(filterFBO);\n      let count = 0;\n      for (let i = 0; i < color.length; i++) {\n        count += color[i];\n      }\n      onFilteredItemsChange({\n        id: this.id,\n        count\n      });\n      this.state.filterNeedsUpdate = false;\n    }\n  }\n  finalizeState() {\n    const filterFBO = this.state.filterFBO;\n    const filterModel = this.state.filterModel;\n    // filterFBO.color.delete();\n    filterFBO?.destroy();\n    filterModel?.destroy();\n  }\n  /**\n   * Updates the bitmask used on the GPU to perform the filter based on the\n   * `filterCategories` prop. The mapping between categories and bit in the bitmask\n   * is performed by `_getCategoryKey()`\n   */\n  _updateCategoryBitMask(params, extension) {\n    const {\n      categorySize\n    } = extension.opts;\n    if (!categorySize) return;\n    const {\n      filterCategories\n    } = this.props;\n    const categoryBitMask = new Uint32Array([0, 0, 0, 0]);\n    const categoryFilters = categorySize === 1 ? [filterCategories] : filterCategories;\n    const maxCategories = categorySize === 1 ? 128 : categorySize === 2 ? 64 : 32;\n    for (let c = 0; c < categoryFilters.length; c++) {\n      const categoryFilter = categoryFilters[c];\n      for (const category of categoryFilter) {\n        const key = extension._getCategoryKey.call(this, category, c);\n        if (key < maxCategories) {\n          const channel = c * (maxCategories / 32) + Math.floor(key / 32);\n          categoryBitMask[channel] += Math.pow(2, key % 32); // 1 << key fails for key > 30\n        } else {\n          log.warn(`Exceeded maximum number of categories (${maxCategories})`)();\n        }\n      }\n    }\n    this.state.categoryBitMask = categoryBitMask;\n  }\n  /**\n   * Returns an index of bit in the bitmask for a given category. If the category has\n   * not yet been assigned a bit, a new one is assigned.\n   */\n  _getCategoryKey(category, channel) {\n    const categoryMap = this.state.categoryMap[channel];\n    if (!(category in categoryMap)) {\n      categoryMap[category] = Object.keys(categoryMap).length;\n    }\n    return categoryMap[category];\n  }\n}\nDataFilterExtension.defaultProps = defaultProps;\nDataFilterExtension.extensionName = 'DataFilterExtension';\nexport default DataFilterExtension;\n//# sourceMappingURL=data-filter-extension.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}