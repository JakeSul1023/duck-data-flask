{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport const dashShaders = {\n  inject: {\n    'vs:#decl': `\nin vec2 instanceDashArrays;\nin float instanceDashOffsets;\nout vec2 vDashArray;\nout float vDashOffset;\n`,\n    'vs:#main-end': `\nvDashArray = instanceDashArrays;\nvDashOffset = instanceDashOffsets / width.x;\n`,\n    'fs:#decl': `\nuniform pathStyleUniforms {\nfloat dashAlignMode;\nbool dashGapPickable;\n} pathStyle;\nin vec2 vDashArray;\nin float vDashOffset;\n`,\n    // if given position is in the gap part of the dashed line\n    // dashArray.x: solid stroke length, relative to width\n    // dashArray.y: gap length, relative to width\n    // alignMode:\n    // 0 - no adjustment\n    // o----     ----     ----     ---- o----     -o----     ----     o\n    // 1 - stretch to fit, draw half dash at each end for nicer joints\n    // o--    ----    ----    ----    --o--      --o--     ----     --o\n    'fs:#main-start': `\nfloat solidLength = vDashArray.x;\nfloat gapLength = vDashArray.y;\nfloat unitLength = solidLength + gapLength;\nfloat offset;\nif (unitLength > 0.0) {\nif (pathStyle.dashAlignMode == 0.0) {\noffset = vDashOffset;\n} else {\nunitLength = vPathLength / round(vPathLength / unitLength);\noffset = solidLength / 2.0;\n}\nfloat unitOffset = mod(vPathPosition.y + offset, unitLength);\nif (gapLength > 0.0 && unitOffset > solidLength) {\nif (path.capType <= 0.5) {\nif (!(pathStyle.dashGapPickable && bool(picking.isActive))) {\ndiscard;\n}\n} else {\nfloat distToEnd = length(vec2(\nmin(unitOffset - solidLength, unitLength - unitOffset),\nvPathPosition.x\n));\nif (distToEnd > 1.0) {\nif (!(pathStyle.dashGapPickable && bool(picking.isActive))) {\ndiscard;\n}\n}\n}\n}\n}\n`\n  }\n};\nexport const offsetShaders = {\n  inject: {\n    'vs:#decl': `\nin float instanceOffsets;\n`,\n    'vs:DECKGL_FILTER_SIZE': `\nfloat offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\nsize *= offsetWidth;\n`,\n    'vs:#main-end': `\nfloat offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\nfloat offsetDir = sign(instanceOffsets);\nvPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;\nvPathPosition.y *= offsetWidth;\nvPathLength *= offsetWidth;\n`,\n    'fs:#main-start': `\nfloat isInside;\nisInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);\nif (isInside == 0.0) {\ndiscard;\n}\n`\n  }\n};","map":{"version":3,"names":["dashShaders","inject","offsetShaders"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\extensions\\src\\path-style\\shaders.glsl.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const dashShaders = {\n  inject: {\n    'vs:#decl': `\nin vec2 instanceDashArrays;\nin float instanceDashOffsets;\nout vec2 vDashArray;\nout float vDashOffset;\n`,\n\n    'vs:#main-end': `\nvDashArray = instanceDashArrays;\nvDashOffset = instanceDashOffsets / width.x;\n`,\n\n    'fs:#decl': `\nuniform pathStyleUniforms {\n  float dashAlignMode;\n  bool dashGapPickable;\n} pathStyle;\n\nin vec2 vDashArray;\nin float vDashOffset;\n`,\n\n    // if given position is in the gap part of the dashed line\n    // dashArray.x: solid stroke length, relative to width\n    // dashArray.y: gap length, relative to width\n    // alignMode:\n    // 0 - no adjustment\n    // o----     ----     ----     ---- o----     -o----     ----     o\n    // 1 - stretch to fit, draw half dash at each end for nicer joints\n    // o--    ----    ----    ----    --o--      --o--     ----     --o\n    'fs:#main-start': `\n  float solidLength = vDashArray.x;\n  float gapLength = vDashArray.y;\n  float unitLength = solidLength + gapLength;\n\n  float offset;\n\n  if (unitLength > 0.0) {\n    if (pathStyle.dashAlignMode == 0.0) {\n      offset = vDashOffset;\n    } else {\n      unitLength = vPathLength / round(vPathLength / unitLength);\n      offset = solidLength / 2.0;\n    }\n\n    float unitOffset = mod(vPathPosition.y + offset, unitLength);\n\n    if (gapLength > 0.0 && unitOffset > solidLength) {\n      if (path.capType <= 0.5) {\n        if (!(pathStyle.dashGapPickable && bool(picking.isActive))) {\n          discard;\n        }\n      } else {\n        // caps are rounded, test the distance to solid ends\n        float distToEnd = length(vec2(\n          min(unitOffset - solidLength, unitLength - unitOffset),\n          vPathPosition.x\n        ));\n        if (distToEnd > 1.0) {\n          if (!(pathStyle.dashGapPickable && bool(picking.isActive))) {\n            discard;\n          }\n        }\n      }\n    }\n  }\n`\n  }\n};\n\nexport const offsetShaders = {\n  inject: {\n    'vs:#decl': `\nin float instanceOffsets;\n`,\n    'vs:DECKGL_FILTER_SIZE': `\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  size *= offsetWidth;\n`,\n    'vs:#main-end': `\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  float offsetDir = sign(instanceOffsets);\n  vPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;\n  vPathPosition.y *= offsetWidth;\n  vPathLength *= offsetWidth;\n`,\n    'fs:#main-start': `\n  float isInside;\n  isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);\n  if (isInside == 0.0) {\n    discard;\n  }\n`\n  }\n};\n"],"mappings":"AAAA;AACA;AACA;AAEA,OAAO,MAAMA,WAAW,GAAG;EACzBC,MAAM,EAAE;IACN,UAAU,EAAE;;;;;CAKf;IAEG,cAAc,EAAE;;;CAGnB;IAEG,UAAU;;;;;;;CAQb;IAEG;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsCnB;AAED,OAAO,MAAMC,aAAa,GAAG;EAC3BD,MAAM,EAAE;IACN,UAAU,EAAE;;CAEf;IACG,uBAAuB;;;CAG1B;IACG,cAAc;;;;;;CAMjB;IACG,gBAAgB;;;;;;;;CAQnB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}