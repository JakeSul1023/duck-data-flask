{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* global setTimeout clearTimeout */\nimport { getBounds, boundsContain, packVertices, scaleToAspectRatio, getTextureCoordinates } from \"./heatmap-layer-utils.js\";\nimport { TextureTransform } from '@luma.gl/engine';\nimport { AttributeManager, COORDINATE_SYSTEM, log, project32 } from '@deck.gl/core';\nimport TriangleLayer from \"./triangle-layer.js\";\nimport AggregationLayer from \"./aggregation-layer.js\";\nimport { defaultColorRange, colorRangeToFlatArray } from \"../common/utils/color-utils.js\";\nimport weightsVs from \"./weights-vs.glsl.js\";\nimport weightsFs from \"./weights-fs.glsl.js\";\nimport maxVs from \"./max-vs.glsl.js\";\nimport maxFs from \"./max-fs.glsl.js\";\nimport { maxWeightUniforms, weightUniforms } from \"./heatmap-layer-uniforms.js\";\nconst RESOLUTION = 2; // (number of common space pixels) / (number texels)\nconst TEXTURE_PROPS = {\n  format: 'rgba8unorm',\n  mipmaps: false,\n  sampler: {\n    minFilter: 'linear',\n    magFilter: 'linear',\n    addressModeU: 'clamp-to-edge',\n    addressModeV: 'clamp-to-edge'\n  }\n};\nconst DEFAULT_COLOR_DOMAIN = [0, 0];\nconst AGGREGATION_MODE = {\n  SUM: 0,\n  MEAN: 1\n};\nconst defaultProps = {\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  intensity: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  radiusPixels: {\n    type: 'number',\n    min: 1,\n    max: 100,\n    value: 50\n  },\n  colorRange: defaultColorRange,\n  threshold: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 0.05\n  },\n  colorDomain: {\n    type: 'array',\n    value: null,\n    optional: true\n  },\n  // 'SUM' or 'MEAN'\n  aggregation: 'SUM',\n  weightsTextureSize: {\n    type: 'number',\n    min: 128,\n    max: 2048,\n    value: 2048\n  },\n  debounceTimeout: {\n    type: 'number',\n    min: 0,\n    max: 1000,\n    value: 500\n  }\n};\nconst FLOAT_TARGET_FEATURES = ['float32-renderable-webgl',\n// ability to render to float texture\n'texture-blend-float-webgl' // ability to blend when rendering to float texture\n];\nconst DIMENSIONS = {\n  data: {\n    props: ['radiusPixels']\n  }\n};\n/** Visualizes the spatial distribution of data. */\nclass HeatmapLayer extends AggregationLayer {\n  getShaders(shaders) {\n    let modules = [project32];\n    if (shaders.modules) {\n      modules = [...modules, ...shaders.modules];\n    }\n    return super.getShaders({\n      ...shaders,\n      modules\n    });\n  }\n  initializeState() {\n    super.initializeAggregationLayer(DIMENSIONS);\n    this.setState({\n      colorDomain: DEFAULT_COLOR_DOMAIN\n    });\n    this._setupTextureParams();\n    this._setupAttributes();\n    this._setupResources();\n  }\n  shouldUpdateState({\n    changeFlags\n  }) {\n    // Need to be updated when viewport changes\n    return changeFlags.somethingChanged;\n  }\n  /* eslint-disable max-statements,complexity */\n  updateState(opts) {\n    super.updateState(opts);\n    this._updateHeatmapState(opts);\n  }\n  _updateHeatmapState(opts) {\n    const {\n      props,\n      oldProps\n    } = opts;\n    const changeFlags = this._getChangeFlags(opts);\n    if (changeFlags.dataChanged || changeFlags.viewportChanged) {\n      // if data is changed, do not debounce and immediately update the weight map\n      changeFlags.boundsChanged = this._updateBounds(changeFlags.dataChanged);\n      this._updateTextureRenderingBounds();\n    }\n    if (changeFlags.dataChanged || changeFlags.boundsChanged) {\n      // Update weight map immediately\n      clearTimeout(this.state.updateTimer);\n      this.setState({\n        isWeightMapDirty: true\n      });\n    } else if (changeFlags.viewportZoomChanged) {\n      // Update weight map when zoom stops\n      this._debouncedUpdateWeightmap();\n    }\n    if (props.colorRange !== oldProps.colorRange) {\n      this._updateColorTexture(opts);\n    }\n    if (this.state.isWeightMapDirty) {\n      this._updateWeightmap();\n    }\n    this.setState({\n      zoom: opts.context.viewport.zoom\n    });\n  }\n  renderLayers() {\n    const {\n      weightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      maxWeightsTexture,\n      colorTexture,\n      colorDomain\n    } = this.state;\n    const {\n      updateTriggers,\n      intensity,\n      threshold,\n      aggregation\n    } = this.props;\n    const TriangleLayerClass = this.getSubLayerClass('triangle', TriangleLayer);\n    return new TriangleLayerClass(this.getSubLayerProps({\n      id: 'triangle-layer',\n      updateTriggers\n    }), {\n      // position buffer is filled with world coordinates generated from viewport.unproject\n      // i.e. LNGLAT if geospatial, CARTESIAN otherwise\n      coordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n      data: {\n        attributes: {\n          positions: triPositionBuffer,\n          texCoords: triTexCoordBuffer\n        }\n      },\n      vertexCount: 4,\n      maxTexture: maxWeightsTexture,\n      colorTexture,\n      aggregationMode: AGGREGATION_MODE[aggregation] || 0,\n      weightsTexture,\n      intensity,\n      threshold,\n      colorDomain\n    });\n  }\n  finalizeState(context) {\n    super.finalizeState(context);\n    const {\n      weightsTransform,\n      weightsTexture,\n      maxWeightTransform,\n      maxWeightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      colorTexture,\n      updateTimer\n    } = this.state;\n    weightsTransform?.destroy();\n    weightsTexture?.destroy();\n    maxWeightTransform?.destroy();\n    maxWeightsTexture?.destroy();\n    triPositionBuffer?.destroy();\n    triTexCoordBuffer?.destroy();\n    colorTexture?.destroy();\n    if (updateTimer) {\n      clearTimeout(updateTimer);\n    }\n  }\n  // PRIVATE\n  // override Composite layer private method to create AttributeManager instance\n  _getAttributeManager() {\n    return new AttributeManager(this.context.device, {\n      id: this.props.id,\n      stats: this.context.stats\n    });\n  }\n  _getChangeFlags(opts) {\n    const changeFlags = {};\n    const {\n      dimensions\n    } = this.state;\n    changeFlags.dataChanged = this.isAttributeChanged() && 'attribute changed' ||\n    // if any attribute is changed\n    this.isAggregationDirty(opts, {\n      compareAll: true,\n      dimension: dimensions.data\n    }) && 'aggregation is dirty';\n    changeFlags.viewportChanged = opts.changeFlags.viewportChanged;\n    const {\n      zoom\n    } = this.state;\n    if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {\n      changeFlags.viewportZoomChanged = true;\n    }\n    return changeFlags;\n  }\n  _createTextures() {\n    const {\n      textureSize,\n      format\n    } = this.state;\n    this.setState({\n      weightsTexture: this.context.device.createTexture({\n        ...TEXTURE_PROPS,\n        width: textureSize,\n        height: textureSize,\n        format\n      }),\n      maxWeightsTexture: this.context.device.createTexture({\n        ...TEXTURE_PROPS,\n        width: 1,\n        height: 1,\n        format\n      })\n    });\n  }\n  _setupAttributes() {\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {\n        size: 3,\n        type: 'float64',\n        accessor: 'getPosition'\n      },\n      weights: {\n        size: 1,\n        accessor: 'getWeight'\n      }\n    });\n    this.setState({\n      positionAttributeName: 'positions'\n    });\n  }\n  _setupTextureParams() {\n    const {\n      device\n    } = this.context;\n    const {\n      weightsTextureSize\n    } = this.props;\n    const textureSize = Math.min(weightsTextureSize, device.limits.maxTextureDimension2D);\n    const floatTargetSupport = FLOAT_TARGET_FEATURES.every(feature => device.features.has(feature));\n    const format = floatTargetSupport ? 'rgba32float' : 'rgba8unorm';\n    const weightsScale = floatTargetSupport ? 1 : 1 / 255;\n    this.setState({\n      textureSize,\n      format,\n      weightsScale\n    });\n    if (!floatTargetSupport) {\n      log.warn(`HeatmapLayer: ${this.id} rendering to float texture not supported, falling back to low precision format`)();\n    }\n  }\n  _createWeightsTransform(shaders) {\n    let {\n      weightsTransform\n    } = this.state;\n    const {\n      weightsTexture\n    } = this.state;\n    const attributeManager = this.getAttributeManager();\n    weightsTransform?.destroy();\n    weightsTransform = new TextureTransform(this.context.device, {\n      id: `${this.id}-weights-transform`,\n      bufferLayout: attributeManager.getBufferLayouts(),\n      vertexCount: 1,\n      targetTexture: weightsTexture,\n      parameters: {\n        depthWriteEnabled: false,\n        blendColorOperation: 'add',\n        blendColorSrcFactor: 'one',\n        blendColorDstFactor: 'one',\n        blendAlphaSrcFactor: 'one',\n        blendAlphaDstFactor: 'one'\n      },\n      topology: 'point-list',\n      ...shaders,\n      modules: [...shaders.modules, weightUniforms]\n    });\n    this.setState({\n      weightsTransform\n    });\n  }\n  _setupResources() {\n    this._createTextures();\n    const {\n      device\n    } = this.context;\n    const {\n      textureSize,\n      weightsTexture,\n      maxWeightsTexture\n    } = this.state;\n    const weightsTransformShaders = this.getShaders({\n      vs: weightsVs,\n      fs: weightsFs\n    });\n    this._createWeightsTransform(weightsTransformShaders);\n    const maxWeightsTransformShaders = this.getShaders({\n      vs: maxVs,\n      fs: maxFs,\n      modules: [maxWeightUniforms]\n    });\n    const maxWeightTransform = new TextureTransform(device, {\n      id: `${this.id}-max-weights-transform`,\n      targetTexture: maxWeightsTexture,\n      ...maxWeightsTransformShaders,\n      vertexCount: textureSize * textureSize,\n      topology: 'point-list',\n      parameters: {\n        depthWriteEnabled: false,\n        blendColorOperation: 'max',\n        blendAlphaOperation: 'max',\n        blendColorSrcFactor: 'one',\n        blendColorDstFactor: 'one',\n        blendAlphaSrcFactor: 'one',\n        blendAlphaDstFactor: 'one'\n      }\n    });\n    const maxWeightProps = {\n      inTexture: weightsTexture,\n      textureSize\n    };\n    maxWeightTransform.model.shaderInputs.setProps({\n      maxWeight: maxWeightProps\n    });\n    this.setState({\n      weightsTexture,\n      maxWeightsTexture,\n      maxWeightTransform,\n      zoom: null,\n      triPositionBuffer: device.createBuffer({\n        byteLength: 48\n      }),\n      triTexCoordBuffer: device.createBuffer({\n        byteLength: 48\n      })\n    });\n  }\n  // overwrite super class method to update transform model\n  updateShaders(shaderOptions) {\n    // shader params (modules, injects) changed, update model object\n    this._createWeightsTransform({\n      vs: weightsVs,\n      fs: weightsFs,\n      ...shaderOptions\n    });\n  }\n  _updateMaxWeightValue() {\n    const {\n      maxWeightTransform\n    } = this.state;\n    maxWeightTransform.run({\n      parameters: {\n        viewport: [0, 0, 1, 1]\n      },\n      clearColor: [0, 0, 0, 0]\n    });\n  }\n  // Computes world bounds area that needs to be processed for generate heatmap\n  _updateBounds(forceUpdate = false) {\n    const {\n      viewport\n    } = this.context;\n    // Unproject all 4 corners of the current screen coordinates into world coordinates (lng/lat)\n    // Takes care of viewport has non zero bearing/pitch (i.e axis not aligned with world coordiante system)\n    const viewportCorners = [viewport.unproject([0, 0]), viewport.unproject([viewport.width, 0]), viewport.unproject([0, viewport.height]), viewport.unproject([viewport.width, viewport.height])].map(p => p.map(Math.fround));\n    // #1: get world bounds for current viewport extends\n    const visibleWorldBounds = getBounds(viewportCorners); // TODO: Change to visible bounds\n    const newState = {\n      visibleWorldBounds,\n      viewportCorners\n    };\n    let boundsChanged = false;\n    if (forceUpdate || !this.state.worldBounds || !boundsContain(this.state.worldBounds, visibleWorldBounds)) {\n      // #2 : convert world bounds to common (Flat) bounds\n      // #3 : extend common bounds to match aspect ratio with viewport\n      const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);\n      // #4 :convert aligned common bounds to world bounds\n      const worldBounds = this._commonToWorldBounds(scaledCommonBounds);\n      // Clip webmercator projection limits\n      if (this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n        worldBounds[1] = Math.max(worldBounds[1], -85.051129);\n        worldBounds[3] = Math.min(worldBounds[3], 85.051129);\n        worldBounds[0] = Math.max(worldBounds[0], -360);\n        worldBounds[2] = Math.min(worldBounds[2], 360);\n      }\n      // #5: now convert world bounds to common using Layer's coordiante system and origin\n      const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);\n      newState.worldBounds = worldBounds;\n      newState.normalizedCommonBounds = normalizedCommonBounds;\n      boundsChanged = true;\n    }\n    this.setState(newState);\n    return boundsChanged;\n  }\n  _updateTextureRenderingBounds() {\n    // Just render visible portion of the texture\n    const {\n      triPositionBuffer,\n      triTexCoordBuffer,\n      normalizedCommonBounds,\n      viewportCorners\n    } = this.state;\n    const {\n      viewport\n    } = this.context;\n    triPositionBuffer.write(packVertices(viewportCorners, 3));\n    const textureBounds = viewportCorners.map(p => getTextureCoordinates(viewport.projectPosition(p), normalizedCommonBounds));\n    triTexCoordBuffer.write(packVertices(textureBounds, 2));\n  }\n  _updateColorTexture(opts) {\n    const {\n      colorRange\n    } = opts.props;\n    let {\n      colorTexture\n    } = this.state;\n    const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);\n    if (colorTexture && colorTexture?.width === colorRange.length) {\n      // TODO(v9): Unclear whether `setSubImageData` is a public API, or what to use if not.\n      colorTexture.setTexture2DData({\n        data: colors\n      });\n    } else {\n      colorTexture?.destroy();\n      // @ts-expect-error TODO(ib) - texture API change\n      colorTexture = this.context.device.createTexture({\n        ...TEXTURE_PROPS,\n        data: colors,\n        width: colorRange.length,\n        height: 1\n      });\n    }\n    this.setState({\n      colorTexture\n    });\n  }\n  _updateWeightmap() {\n    const {\n      radiusPixels,\n      colorDomain,\n      aggregation\n    } = this.props;\n    const {\n      worldBounds,\n      textureSize,\n      weightsScale,\n      weightsTexture\n    } = this.state;\n    const weightsTransform = this.state.weightsTransform;\n    this.state.isWeightMapDirty = false;\n    // convert world bounds to common using Layer's coordiante system and origin\n    const commonBounds = this._worldToCommonBounds(worldBounds, {\n      useLayerCoordinateSystem: true\n    });\n    if (colorDomain && aggregation === 'SUM') {\n      // scale color domain to weight per pixel\n      const {\n        viewport\n      } = this.context;\n      const metersPerPixel = viewport.distanceScales.metersPerUnit[2] * (commonBounds[2] - commonBounds[0]) / textureSize;\n      this.state.colorDomain = colorDomain.map(x => x * metersPerPixel * weightsScale);\n    } else {\n      this.state.colorDomain = colorDomain || DEFAULT_COLOR_DOMAIN;\n    }\n    const attributeManager = this.getAttributeManager();\n    const attributes = attributeManager.getAttributes();\n    const moduleSettings = this.getModuleSettings();\n    this._setModelAttributes(weightsTransform.model, attributes);\n    weightsTransform.model.setVertexCount(this.getNumInstances());\n    const weightProps = {\n      radiusPixels,\n      commonBounds,\n      textureWidth: textureSize,\n      weightsScale,\n      weightsTexture: weightsTexture\n    };\n    const {\n      viewport,\n      devicePixelRatio,\n      coordinateSystem,\n      coordinateOrigin\n    } = moduleSettings;\n    const {\n      modelMatrix\n    } = this.props;\n    weightsTransform.model.shaderInputs.setProps({\n      project: {\n        viewport,\n        devicePixelRatio,\n        modelMatrix,\n        coordinateSystem,\n        coordinateOrigin\n      },\n      weight: weightProps\n    });\n    weightsTransform.run({\n      parameters: {\n        viewport: [0, 0, textureSize, textureSize]\n      },\n      clearColor: [0, 0, 0, 0]\n    });\n    this._updateMaxWeightValue();\n  }\n  _debouncedUpdateWeightmap(fromTimer = false) {\n    let {\n      updateTimer\n    } = this.state;\n    const {\n      debounceTimeout\n    } = this.props;\n    if (fromTimer) {\n      updateTimer = null;\n      // update\n      this._updateBounds(true);\n      this._updateTextureRenderingBounds();\n      this.setState({\n        isWeightMapDirty: true\n      });\n    } else {\n      this.setState({\n        isWeightMapDirty: false\n      });\n      clearTimeout(updateTimer);\n      updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), debounceTimeout);\n    }\n    this.setState({\n      updateTimer\n    });\n  }\n  // input: worldBounds: [minLong, minLat, maxLong, maxLat]\n  // input: opts.useLayerCoordinateSystem : layers coordiante system is used\n  // optput: commonBounds: [minX, minY, maxX, maxY] scaled to fit the current texture\n  _worldToCommonBounds(worldBounds, opts = {}) {\n    const {\n      useLayerCoordinateSystem = false\n    } = opts;\n    const [minLong, minLat, maxLong, maxLat] = worldBounds;\n    const {\n      viewport\n    } = this.context;\n    const {\n      textureSize\n    } = this.state;\n    const {\n      coordinateSystem\n    } = this.props;\n    const offsetMode = useLayerCoordinateSystem && (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS);\n    const offsetOriginCommon = offsetMode ? viewport.projectPosition(this.props.coordinateOrigin) : [0, 0];\n    const size = textureSize * RESOLUTION / viewport.scale;\n    let bottomLeftCommon;\n    let topRightCommon;\n    // Y-axis is flipped between World and Common bounds\n    if (useLayerCoordinateSystem && !offsetMode) {\n      bottomLeftCommon = this.projectPosition([minLong, minLat, 0]);\n      topRightCommon = this.projectPosition([maxLong, maxLat, 0]);\n    } else {\n      bottomLeftCommon = viewport.projectPosition([minLong, minLat, 0]);\n      topRightCommon = viewport.projectPosition([maxLong, maxLat, 0]);\n    }\n    // Ignore z component\n    return scaleToAspectRatio([bottomLeftCommon[0] - offsetOriginCommon[0], bottomLeftCommon[1] - offsetOriginCommon[1], topRightCommon[0] - offsetOriginCommon[0], topRightCommon[1] - offsetOriginCommon[1]], size, size);\n  }\n  // input commonBounds: [xMin, yMin, xMax, yMax]\n  // output worldBounds: [minLong, minLat, maxLong, maxLat]\n  _commonToWorldBounds(commonBounds) {\n    const [xMin, yMin, xMax, yMax] = commonBounds;\n    const {\n      viewport\n    } = this.context;\n    const bottomLeftWorld = viewport.unprojectPosition([xMin, yMin]);\n    const topRightWorld = viewport.unprojectPosition([xMax, yMax]);\n    return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));\n  }\n}\nHeatmapLayer.layerName = 'HeatmapLayer';\nHeatmapLayer.defaultProps = defaultProps;\nexport default HeatmapLayer;","map":{"version":3,"names":["getBounds","boundsContain","packVertices","scaleToAspectRatio","getTextureCoordinates","TextureTransform","AttributeManager","COORDINATE_SYSTEM","log","project32","TriangleLayer","AggregationLayer","defaultColorRange","colorRangeToFlatArray","weightsVs","weightsFs","maxVs","maxFs","maxWeightUniforms","weightUniforms","RESOLUTION","TEXTURE_PROPS","format","mipmaps","sampler","minFilter","magFilter","addressModeU","addressModeV","DEFAULT_COLOR_DOMAIN","AGGREGATION_MODE","SUM","MEAN","defaultProps","getPosition","type","value","x","position","getWeight","intensity","min","radiusPixels","max","colorRange","threshold","colorDomain","optional","aggregation","weightsTextureSize","debounceTimeout","FLOAT_TARGET_FEATURES","DIMENSIONS","data","props","HeatmapLayer","getShaders","shaders","modules","initializeState","initializeAggregationLayer","setState","_setupTextureParams","_setupAttributes","_setupResources","shouldUpdateState","changeFlags","somethingChanged","updateState","opts","_updateHeatmapState","oldProps","_getChangeFlags","dataChanged","viewportChanged","boundsChanged","_updateBounds","_updateTextureRenderingBounds","clearTimeout","state","updateTimer","isWeightMapDirty","viewportZoomChanged","_debouncedUpdateWeightmap","_updateColorTexture","_updateWeightmap","zoom","context","viewport","renderLayers","weightsTexture","triPositionBuffer","triTexCoordBuffer","maxWeightsTexture","colorTexture","updateTriggers","TriangleLayerClass","getSubLayerClass","getSubLayerProps","id","coordinateSystem","DEFAULT","attributes","positions","texCoords","vertexCount","maxTexture","aggregationMode","finalizeState","weightsTransform","maxWeightTransform","destroy","_getAttributeManager","device","stats","dimensions","isAttributeChanged","isAggregationDirty","compareAll","dimension","_createTextures","textureSize","createTexture","width","height","attributeManager","getAttributeManager","add","size","accessor","weights","positionAttributeName","Math","limits","maxTextureDimension2D","floatTargetSupport","every","feature","features","has","weightsScale","warn","_createWeightsTransform","bufferLayout","getBufferLayouts","targetTexture","parameters","depthWriteEnabled","blendColorOperation","blendColorSrcFactor","blendColorDstFactor","blendAlphaSrcFactor","blendAlphaDstFactor","topology","weightsTransformShaders","vs","fs","maxWeightsTransformShaders","blendAlphaOperation","maxWeightProps","inTexture","model","shaderInputs","setProps","maxWeight","createBuffer","byteLength","updateShaders","shaderOptions","_updateMaxWeightValue","run","clearColor","forceUpdate","viewportCorners","unproject","map","p","fround","visibleWorldBounds","newState","worldBounds","scaledCommonBounds","_worldToCommonBounds","_commonToWorldBounds","LNGLAT","normalizedCommonBounds","write","textureBounds","projectPosition","colors","Uint8Array","length","setTexture2DData","commonBounds","useLayerCoordinateSystem","metersPerPixel","distanceScales","metersPerUnit","getAttributes","moduleSettings","getModuleSettings","_setModelAttributes","setVertexCount","getNumInstances","weightProps","textureWidth","devicePixelRatio","coordinateOrigin","modelMatrix","project","weight","fromTimer","setTimeout","bind","minLong","minLat","maxLong","maxLat","offsetMode","LNGLAT_OFFSETS","METER_OFFSETS","offsetOriginCommon","scale","bottomLeftCommon","topRightCommon","xMin","yMin","xMax","yMax","bottomLeftWorld","unprojectPosition","topRightWorld","slice","concat","layerName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\aggregation-layers\\src\\heatmap-layer\\heatmap-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* global setTimeout clearTimeout */\nimport {\n  getBounds,\n  boundsContain,\n  packVertices,\n  scaleToAspectRatio,\n  getTextureCoordinates\n} from './heatmap-layer-utils';\nimport {Buffer, DeviceFeature, Texture, TextureProps, TextureFormat} from '@luma.gl/core';\nimport {TextureTransform, TextureTransformProps} from '@luma.gl/engine';\nimport {\n  Accessor,\n  AccessorFunction,\n  AttributeManager,\n  ChangeFlags,\n  Color,\n  COORDINATE_SYSTEM,\n  Layer,\n  LayerContext,\n  LayersList,\n  log,\n  Position,\n  UpdateParameters,\n  DefaultProps,\n  project32\n} from '@deck.gl/core';\nimport TriangleLayer from './triangle-layer';\nimport AggregationLayer, {AggregationLayerProps} from './aggregation-layer';\nimport {defaultColorRange, colorRangeToFlatArray} from '../common/utils/color-utils';\nimport weightsVs from './weights-vs.glsl';\nimport weightsFs from './weights-fs.glsl';\nimport maxVs from './max-vs.glsl';\nimport maxFs from './max-fs.glsl';\nimport {\n  MaxWeightProps,\n  maxWeightUniforms,\n  WeightProps,\n  weightUniforms\n} from './heatmap-layer-uniforms';\n\nconst RESOLUTION = 2; // (number of common space pixels) / (number texels)\nconst TEXTURE_PROPS: TextureProps = {\n  format: 'rgba8unorm',\n  mipmaps: false,\n  sampler: {\n    minFilter: 'linear',\n    magFilter: 'linear',\n    addressModeU: 'clamp-to-edge',\n    addressModeV: 'clamp-to-edge'\n  }\n};\nconst DEFAULT_COLOR_DOMAIN = [0, 0];\nconst AGGREGATION_MODE = {\n  SUM: 0,\n  MEAN: 1\n};\n\nconst defaultProps: DefaultProps<HeatmapLayerProps> = {\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\n  getWeight: {type: 'accessor', value: 1},\n  intensity: {type: 'number', min: 0, value: 1},\n  radiusPixels: {type: 'number', min: 1, max: 100, value: 50},\n  colorRange: defaultColorRange,\n  threshold: {type: 'number', min: 0, max: 1, value: 0.05},\n  colorDomain: {type: 'array', value: null, optional: true},\n  // 'SUM' or 'MEAN'\n  aggregation: 'SUM',\n  weightsTextureSize: {type: 'number', min: 128, max: 2048, value: 2048},\n  debounceTimeout: {type: 'number', min: 0, max: 1000, value: 500}\n};\n\nconst FLOAT_TARGET_FEATURES: DeviceFeature[] = [\n  'float32-renderable-webgl', // ability to render to float texture\n  'texture-blend-float-webgl' // ability to blend when rendering to float texture\n];\n\nconst DIMENSIONS = {\n  data: {\n    props: ['radiusPixels']\n  }\n};\n\nexport type HeatmapLayerProps<DataT = unknown> = _HeatmapLayerProps<DataT> &\n  AggregationLayerProps<DataT>;\n\ntype _HeatmapLayerProps<DataT> = {\n  /**\n   * Radius of the circle in pixels, to which the weight of an object is distributed.\n   *\n   * @default 30\n   */\n  radiusPixels?: number;\n\n  /**\n   * Specified as an array of colors [color1, color2, ...].\n   *\n   * @default `6-class YlOrRd` - [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6)\n   */\n  colorRange?: Color[];\n\n  /**\n   * Value that is multiplied with the total weight at a pixel to obtain the final weight.\n   *\n   * @default 1\n   */\n  intensity?: number;\n\n  /**\n   * Ratio of the fading weight to the max weight, between `0` and `1`.\n   *\n   * For example, `0.1` affects all pixels with weight under 10% of the max.\n   *\n   * Ignored when `colorDomain` is specified.\n   * @default 0.05\n   */\n  threshold?: number;\n\n  /**\n   * Controls how weight values are mapped to the `colorRange`, as an array of two numbers [`minValue`, `maxValue`].\n   *\n   * @default null\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Defines the type of aggregation operation\n   *\n   * V valid values are 'SUM', 'MEAN'.\n   *\n   * @default 'SUM'\n   */\n  aggregation?: 'SUM' | 'MEAN';\n\n  /**\n   * Specifies the size of weight texture.\n   * @default 2048\n   */\n  weightsTextureSize?: number;\n\n  /**\n   * Interval in milliseconds during which changes to the viewport don't trigger aggregation.\n   *\n   * @default 500\n   */\n  debounceTimeout?: number;\n\n  /**\n   * Method called to retrieve the position of each object.\n   *\n   * @default d => d.position\n   */\n  getPosition?: AccessorFunction<DataT, Position>;\n\n  /**\n   * The weight of each object.\n   *\n   * @default 1\n   */\n  getWeight?: Accessor<DataT, number>;\n};\n\n/** Visualizes the spatial distribution of data. */\nexport default class HeatmapLayer<\n  DataT = any,\n  ExtraPropsT extends {} = {}\n> extends AggregationLayer<DataT, ExtraPropsT & Required<_HeatmapLayerProps<DataT>>> {\n  static layerName = 'HeatmapLayer';\n  static defaultProps = defaultProps;\n\n  state!: AggregationLayer<DataT>['state'] & {\n    colorDomain?: number[];\n    isWeightMapDirty?: boolean;\n    weightsTexture?: Texture;\n    maxWeightsTexture?: Texture;\n    colorTexture?: Texture;\n    zoom?: number;\n    worldBounds?: number[];\n    normalizedCommonBounds?: number[];\n    updateTimer?: any;\n    triPositionBuffer?: Buffer;\n    triTexCoordBuffer?: Buffer;\n    weightsTransform?: TextureTransform;\n    maxWeightTransform?: TextureTransform;\n    textureSize: number;\n    format: TextureFormat;\n    weightsScale: number;\n    visibleWorldBounds: number[];\n    viewportCorners: number[][];\n  };\n\n  getShaders(shaders: any) {\n    let modules = [project32];\n    if (shaders.modules) {\n      modules = [...modules, ...shaders.modules];\n    }\n\n    return super.getShaders({...shaders, modules});\n  }\n\n  initializeState() {\n    super.initializeAggregationLayer(DIMENSIONS);\n    this.setState({colorDomain: DEFAULT_COLOR_DOMAIN});\n    this._setupTextureParams();\n    this._setupAttributes();\n    this._setupResources();\n  }\n\n  shouldUpdateState({changeFlags}: UpdateParameters<this>) {\n    // Need to be updated when viewport changes\n    return changeFlags.somethingChanged;\n  }\n\n  /* eslint-disable max-statements,complexity */\n  updateState(opts: UpdateParameters<this>) {\n    super.updateState(opts);\n    this._updateHeatmapState(opts);\n  }\n\n  _updateHeatmapState(opts: UpdateParameters<this>) {\n    const {props, oldProps} = opts;\n    const changeFlags = this._getChangeFlags(opts);\n\n    if (changeFlags.dataChanged || changeFlags.viewportChanged) {\n      // if data is changed, do not debounce and immediately update the weight map\n      changeFlags.boundsChanged = this._updateBounds(changeFlags.dataChanged);\n      this._updateTextureRenderingBounds();\n    }\n\n    if (changeFlags.dataChanged || changeFlags.boundsChanged) {\n      // Update weight map immediately\n      clearTimeout(this.state.updateTimer);\n      this.setState({isWeightMapDirty: true});\n    } else if (changeFlags.viewportZoomChanged) {\n      // Update weight map when zoom stops\n      this._debouncedUpdateWeightmap();\n    }\n\n    if (props.colorRange !== oldProps.colorRange) {\n      this._updateColorTexture(opts);\n    }\n\n    if (this.state.isWeightMapDirty) {\n      this._updateWeightmap();\n    }\n\n    this.setState({zoom: opts.context.viewport.zoom});\n  }\n\n  renderLayers(): LayersList | Layer {\n    const {\n      weightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      maxWeightsTexture,\n      colorTexture,\n      colorDomain\n    } = this.state;\n    const {updateTriggers, intensity, threshold, aggregation} = this.props;\n\n    const TriangleLayerClass = this.getSubLayerClass('triangle', TriangleLayer);\n\n    return new TriangleLayerClass(\n      this.getSubLayerProps({\n        id: 'triangle-layer',\n        updateTriggers\n      }),\n      {\n        // position buffer is filled with world coordinates generated from viewport.unproject\n        // i.e. LNGLAT if geospatial, CARTESIAN otherwise\n        coordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n        data: {\n          attributes: {\n            positions: triPositionBuffer,\n            texCoords: triTexCoordBuffer\n          }\n        },\n        vertexCount: 4,\n        maxTexture: maxWeightsTexture,\n        colorTexture,\n        aggregationMode: AGGREGATION_MODE[aggregation] || 0,\n        weightsTexture,\n        intensity,\n        threshold,\n        colorDomain\n      }\n    );\n  }\n\n  finalizeState(context: LayerContext) {\n    super.finalizeState(context);\n    const {\n      weightsTransform,\n      weightsTexture,\n      maxWeightTransform,\n      maxWeightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      colorTexture,\n      updateTimer\n    } = this.state;\n    weightsTransform?.destroy();\n    weightsTexture?.destroy();\n    maxWeightTransform?.destroy();\n    maxWeightsTexture?.destroy();\n    triPositionBuffer?.destroy();\n    triTexCoordBuffer?.destroy();\n    colorTexture?.destroy();\n    if (updateTimer) {\n      clearTimeout(updateTimer);\n    }\n  }\n\n  // PRIVATE\n\n  // override Composite layer private method to create AttributeManager instance\n  _getAttributeManager() {\n    return new AttributeManager(this.context.device, {\n      id: this.props.id,\n      stats: this.context.stats\n    });\n  }\n\n  _getChangeFlags(opts: UpdateParameters<this>) {\n    const changeFlags: Partial<ChangeFlags> & {\n      boundsChanged?: boolean;\n      viewportZoomChanged?: boolean;\n    } = {};\n    const {dimensions} = this.state;\n    changeFlags.dataChanged =\n      (this.isAttributeChanged() && 'attribute changed') || // if any attribute is changed\n      (this.isAggregationDirty(opts, {\n        compareAll: true,\n        dimension: dimensions.data\n      }) &&\n        'aggregation is dirty');\n    changeFlags.viewportChanged = opts.changeFlags.viewportChanged;\n\n    const {zoom} = this.state;\n    if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {\n      changeFlags.viewportZoomChanged = true;\n    }\n\n    return changeFlags;\n  }\n\n  _createTextures() {\n    const {textureSize, format} = this.state;\n\n    this.setState({\n      weightsTexture: this.context.device.createTexture({\n        ...TEXTURE_PROPS,\n        width: textureSize,\n        height: textureSize,\n        format\n      }),\n      maxWeightsTexture: this.context.device.createTexture({\n        ...TEXTURE_PROPS,\n        width: 1,\n        height: 1,\n        format\n      })\n    });\n  }\n\n  _setupAttributes() {\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      positions: {size: 3, type: 'float64', accessor: 'getPosition'},\n      weights: {size: 1, accessor: 'getWeight'}\n    });\n    this.setState({positionAttributeName: 'positions'});\n  }\n\n  _setupTextureParams() {\n    const {device} = this.context;\n    const {weightsTextureSize} = this.props;\n\n    const textureSize = Math.min(weightsTextureSize, device.limits.maxTextureDimension2D);\n    const floatTargetSupport = FLOAT_TARGET_FEATURES.every(feature => device.features.has(feature));\n    const format: TextureFormat = floatTargetSupport ? 'rgba32float' : 'rgba8unorm';\n    const weightsScale = floatTargetSupport ? 1 : 1 / 255;\n    this.setState({textureSize, format, weightsScale});\n    if (!floatTargetSupport) {\n      log.warn(\n        `HeatmapLayer: ${this.id} rendering to float texture not supported, falling back to low precision format`\n      )();\n    }\n  }\n\n  _createWeightsTransform(shaders: {vs: string; fs?: string; modules: any[]}) {\n    let {weightsTransform} = this.state;\n    const {weightsTexture} = this.state;\n    const attributeManager = this.getAttributeManager()!;\n\n    weightsTransform?.destroy();\n    weightsTransform = new TextureTransform(this.context.device, {\n      id: `${this.id}-weights-transform`,\n      bufferLayout: attributeManager.getBufferLayouts(),\n      vertexCount: 1,\n      targetTexture: weightsTexture!,\n      parameters: {\n        depthWriteEnabled: false,\n        blendColorOperation: 'add',\n        blendColorSrcFactor: 'one',\n        blendColorDstFactor: 'one',\n        blendAlphaSrcFactor: 'one',\n        blendAlphaDstFactor: 'one'\n      },\n      topology: 'point-list',\n      ...shaders,\n      modules: [...shaders.modules, weightUniforms]\n    } as TextureTransformProps);\n\n    this.setState({weightsTransform});\n  }\n\n  _setupResources() {\n    this._createTextures();\n    const {device} = this.context;\n    const {textureSize, weightsTexture, maxWeightsTexture} = this.state;\n\n    const weightsTransformShaders = this.getShaders({\n      vs: weightsVs,\n      fs: weightsFs\n    });\n    this._createWeightsTransform(weightsTransformShaders);\n\n    const maxWeightsTransformShaders = this.getShaders({\n      vs: maxVs,\n      fs: maxFs,\n      modules: [maxWeightUniforms]\n    });\n    const maxWeightTransform = new TextureTransform(device, {\n      id: `${this.id}-max-weights-transform`,\n      targetTexture: maxWeightsTexture!,\n      ...maxWeightsTransformShaders,\n      vertexCount: textureSize * textureSize,\n      topology: 'point-list',\n      parameters: {\n        depthWriteEnabled: false,\n        blendColorOperation: 'max',\n        blendAlphaOperation: 'max',\n        blendColorSrcFactor: 'one',\n        blendColorDstFactor: 'one',\n        blendAlphaSrcFactor: 'one',\n        blendAlphaDstFactor: 'one'\n      }\n    });\n\n    const maxWeightProps: MaxWeightProps = {inTexture: weightsTexture!, textureSize};\n    maxWeightTransform.model.shaderInputs.setProps({\n      maxWeight: maxWeightProps\n    });\n\n    this.setState({\n      weightsTexture,\n      maxWeightsTexture,\n      maxWeightTransform,\n      zoom: null,\n      triPositionBuffer: device.createBuffer({byteLength: 48}),\n      triTexCoordBuffer: device.createBuffer({byteLength: 48})\n    });\n  }\n\n  // overwrite super class method to update transform model\n  updateShaders(shaderOptions) {\n    // shader params (modules, injects) changed, update model object\n    this._createWeightsTransform({\n      vs: weightsVs,\n      fs: weightsFs,\n      ...shaderOptions\n    });\n  }\n\n  _updateMaxWeightValue() {\n    const {maxWeightTransform} = this.state;\n\n    maxWeightTransform!.run({\n      parameters: {viewport: [0, 0, 1, 1]},\n      clearColor: [0, 0, 0, 0]\n    });\n  }\n\n  // Computes world bounds area that needs to be processed for generate heatmap\n  _updateBounds(forceUpdate: any = false): boolean {\n    const {viewport} = this.context;\n\n    // Unproject all 4 corners of the current screen coordinates into world coordinates (lng/lat)\n    // Takes care of viewport has non zero bearing/pitch (i.e axis not aligned with world coordiante system)\n    const viewportCorners = [\n      viewport.unproject([0, 0]),\n      viewport.unproject([viewport.width, 0]),\n      viewport.unproject([0, viewport.height]),\n      viewport.unproject([viewport.width, viewport.height])\n    ].map(p => p.map(Math.fround));\n\n    // #1: get world bounds for current viewport extends\n    const visibleWorldBounds = getBounds(viewportCorners); // TODO: Change to visible bounds\n\n    const newState: Partial<HeatmapLayer['state']> = {visibleWorldBounds, viewportCorners};\n    let boundsChanged = false;\n\n    if (\n      forceUpdate ||\n      !this.state.worldBounds ||\n      !boundsContain(this.state.worldBounds, visibleWorldBounds)\n    ) {\n      // #2 : convert world bounds to common (Flat) bounds\n      // #3 : extend common bounds to match aspect ratio with viewport\n      const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);\n\n      // #4 :convert aligned common bounds to world bounds\n      const worldBounds = this._commonToWorldBounds(scaledCommonBounds);\n\n      // Clip webmercator projection limits\n      if (this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n        worldBounds[1] = Math.max(worldBounds[1], -85.051129);\n        worldBounds[3] = Math.min(worldBounds[3], 85.051129);\n        worldBounds[0] = Math.max(worldBounds[0], -360);\n        worldBounds[2] = Math.min(worldBounds[2], 360);\n      }\n\n      // #5: now convert world bounds to common using Layer's coordiante system and origin\n      const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);\n\n      newState.worldBounds = worldBounds;\n      newState.normalizedCommonBounds = normalizedCommonBounds;\n\n      boundsChanged = true;\n    }\n    this.setState(newState);\n    return boundsChanged;\n  }\n\n  _updateTextureRenderingBounds() {\n    // Just render visible portion of the texture\n    const {triPositionBuffer, triTexCoordBuffer, normalizedCommonBounds, viewportCorners} =\n      this.state;\n\n    const {viewport} = this.context;\n\n    triPositionBuffer!.write(packVertices(viewportCorners, 3));\n\n    const textureBounds = viewportCorners.map(p =>\n      getTextureCoordinates(viewport.projectPosition(p), normalizedCommonBounds!)\n    );\n    triTexCoordBuffer!.write(packVertices(textureBounds, 2));\n  }\n\n  _updateColorTexture(opts) {\n    const {colorRange} = opts.props;\n    let {colorTexture} = this.state;\n    const colors = colorRangeToFlatArray(colorRange, false, Uint8Array as any);\n\n    if (colorTexture && colorTexture?.width === colorRange.length) {\n      // TODO(v9): Unclear whether `setSubImageData` is a public API, or what to use if not.\n      (colorTexture as any).setTexture2DData({data: colors});\n    } else {\n      colorTexture?.destroy();\n      // @ts-expect-error TODO(ib) - texture API change\n      colorTexture = this.context.device.createTexture({\n        ...TEXTURE_PROPS,\n        data: colors,\n        width: colorRange.length,\n        height: 1\n      });\n    }\n    this.setState({colorTexture});\n  }\n\n  _updateWeightmap() {\n    const {radiusPixels, colorDomain, aggregation} = this.props;\n    const {worldBounds, textureSize, weightsScale, weightsTexture} = this.state;\n    const weightsTransform = this.state.weightsTransform!;\n    this.state.isWeightMapDirty = false;\n\n    // convert world bounds to common using Layer's coordiante system and origin\n    const commonBounds = this._worldToCommonBounds(worldBounds, {\n      useLayerCoordinateSystem: true\n    });\n\n    if (colorDomain && aggregation === 'SUM') {\n      // scale color domain to weight per pixel\n      const {viewport} = this.context;\n      const metersPerPixel =\n        (viewport.distanceScales.metersPerUnit[2] * (commonBounds[2] - commonBounds[0])) /\n        textureSize;\n      this.state.colorDomain = colorDomain.map(x => x * metersPerPixel * weightsScale);\n    } else {\n      this.state.colorDomain = colorDomain || DEFAULT_COLOR_DOMAIN;\n    }\n\n    const attributeManager = this.getAttributeManager()!;\n    const attributes = attributeManager.getAttributes();\n    const moduleSettings = this.getModuleSettings();\n    this._setModelAttributes(weightsTransform.model, attributes);\n    weightsTransform.model.setVertexCount(this.getNumInstances());\n\n    const weightProps: WeightProps = {\n      radiusPixels,\n      commonBounds,\n      textureWidth: textureSize,\n      weightsScale,\n      weightsTexture: weightsTexture!\n    };\n    const {viewport, devicePixelRatio, coordinateSystem, coordinateOrigin} = moduleSettings;\n    const {modelMatrix} = this.props;\n    weightsTransform.model.shaderInputs.setProps({\n      project: {viewport, devicePixelRatio, modelMatrix, coordinateSystem, coordinateOrigin},\n      weight: weightProps\n    });\n    weightsTransform.run({\n      parameters: {viewport: [0, 0, textureSize, textureSize]},\n      clearColor: [0, 0, 0, 0]\n    });\n\n    this._updateMaxWeightValue();\n  }\n\n  _debouncedUpdateWeightmap(fromTimer = false) {\n    let {updateTimer} = this.state;\n    const {debounceTimeout} = this.props;\n\n    if (fromTimer) {\n      updateTimer = null;\n      // update\n      this._updateBounds(true);\n      this._updateTextureRenderingBounds();\n      this.setState({isWeightMapDirty: true});\n    } else {\n      this.setState({isWeightMapDirty: false});\n      clearTimeout(updateTimer);\n      updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), debounceTimeout);\n    }\n\n    this.setState({updateTimer});\n  }\n\n  // input: worldBounds: [minLong, minLat, maxLong, maxLat]\n  // input: opts.useLayerCoordinateSystem : layers coordiante system is used\n  // optput: commonBounds: [minX, minY, maxX, maxY] scaled to fit the current texture\n  _worldToCommonBounds(\n    worldBounds,\n    opts: {useLayerCoordinateSystem?: boolean} = {}\n  ): [number, number, number, number] {\n    const {useLayerCoordinateSystem = false} = opts;\n    const [minLong, minLat, maxLong, maxLat] = worldBounds;\n    const {viewport} = this.context;\n    const {textureSize} = this.state;\n    const {coordinateSystem} = this.props;\n\n    const offsetMode =\n      useLayerCoordinateSystem &&\n      (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS ||\n        coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS);\n    const offsetOriginCommon = offsetMode\n      ? viewport.projectPosition(this.props.coordinateOrigin)\n      : [0, 0];\n    const size = (textureSize * RESOLUTION) / viewport.scale;\n\n    let bottomLeftCommon;\n    let topRightCommon;\n\n    // Y-axis is flipped between World and Common bounds\n    if (useLayerCoordinateSystem && !offsetMode) {\n      bottomLeftCommon = this.projectPosition([minLong, minLat, 0]);\n      topRightCommon = this.projectPosition([maxLong, maxLat, 0]);\n    } else {\n      bottomLeftCommon = viewport.projectPosition([minLong, minLat, 0]);\n      topRightCommon = viewport.projectPosition([maxLong, maxLat, 0]);\n    }\n    // Ignore z component\n    return scaleToAspectRatio(\n      [\n        bottomLeftCommon[0] - offsetOriginCommon[0],\n        bottomLeftCommon[1] - offsetOriginCommon[1],\n        topRightCommon[0] - offsetOriginCommon[0],\n        topRightCommon[1] - offsetOriginCommon[1]\n      ],\n      size,\n      size\n    );\n  }\n\n  // input commonBounds: [xMin, yMin, xMax, yMax]\n  // output worldBounds: [minLong, minLat, maxLong, maxLat]\n  _commonToWorldBounds(commonBounds) {\n    const [xMin, yMin, xMax, yMax] = commonBounds;\n    const {viewport} = this.context;\n    const bottomLeftWorld = viewport.unprojectPosition([xMin, yMin]);\n    const topRightWorld = viewport.unprojectPosition([xMax, yMax]);\n\n    return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA;AACA,SACEA,SAAS,EACTC,aAAa,EACbC,YAAY,EACZC,kBAAkB,EAClBC,qBAAqB,QACtB;AAED,SAAQC,gBAAgB,QAA8B,iBAAiB;AACvE,SAGEC,gBAAgB,EAGhBC,iBAAiB,EAIjBC,GAAG,EAIHC,SAAS,QACJ,eAAe;AACtB,OAAOC,aAAa;AACpB,OAAOC,gBAAyC;AAChD,SAAQC,iBAAiB,EAAEC,qBAAqB,QAAC;AACjD,OAAOC,SAAS;AAChB,OAAOC,SAAS;AAChB,OAAOC,KAAK;AACZ,OAAOC,KAAK;AACZ,SAEEC,iBAAiB,EAEjBC,cAAc,QACf;AAED,MAAMC,UAAU,GAAG,CAAC,CAAC,CAAC;AACtB,MAAMC,aAAa,GAAiB;EAClCC,MAAM,EAAE,YAAY;EACpBC,OAAO,EAAE,KAAK;EACdC,OAAO,EAAE;IACPC,SAAS,EAAE,QAAQ;IACnBC,SAAS,EAAE,QAAQ;IACnBC,YAAY,EAAE,eAAe;IAC7BC,YAAY,EAAE;;CAEjB;AACD,MAAMC,oBAAoB,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;AACnC,MAAMC,gBAAgB,GAAG;EACvBC,GAAG,EAAE,CAAC;EACNC,IAAI,EAAE;CACP;AAED,MAAMC,YAAY,GAAoC;EACpDC,WAAW,EAAE;IAACC,IAAI,EAAE,UAAU;IAAEC,KAAK,EAAGC,CAAM,IAAKA,CAAC,CAACC;EAAQ,CAAC;EAC9DC,SAAS,EAAE;IAACJ,IAAI,EAAE,UAAU;IAAEC,KAAK,EAAE;EAAC,CAAC;EACvCI,SAAS,EAAE;IAACL,IAAI,EAAE,QAAQ;IAAEM,GAAG,EAAE,CAAC;IAAEL,KAAK,EAAE;EAAC,CAAC;EAC7CM,YAAY,EAAE;IAACP,IAAI,EAAE,QAAQ;IAAEM,GAAG,EAAE,CAAC;IAAEE,GAAG,EAAE,GAAG;IAAEP,KAAK,EAAE;EAAE,CAAC;EAC3DQ,UAAU,EAAEhC,iBAAiB;EAC7BiC,SAAS,EAAE;IAACV,IAAI,EAAE,QAAQ;IAAEM,GAAG,EAAE,CAAC;IAAEE,GAAG,EAAE,CAAC;IAAEP,KAAK,EAAE;EAAI,CAAC;EACxDU,WAAW,EAAE;IAACX,IAAI,EAAE,OAAO;IAAEC,KAAK,EAAE,IAAI;IAAEW,QAAQ,EAAE;EAAI,CAAC;EACzD;EACAC,WAAW,EAAE,KAAK;EAClBC,kBAAkB,EAAE;IAACd,IAAI,EAAE,QAAQ;IAAEM,GAAG,EAAE,GAAG;IAAEE,GAAG,EAAE,IAAI;IAAEP,KAAK,EAAE;EAAI,CAAC;EACtEc,eAAe,EAAE;IAACf,IAAI,EAAE,QAAQ;IAAEM,GAAG,EAAE,CAAC;IAAEE,GAAG,EAAE,IAAI;IAAEP,KAAK,EAAE;EAAG;CAChE;AAED,MAAMe,qBAAqB,GAAoB,CAC7C,0BAA0B;AAAE;AAC5B,2BAA2B,CAAC;AAAA,CAC7B;AAED,MAAMC,UAAU,GAAG;EACjBC,IAAI,EAAE;IACJC,KAAK,EAAE,CAAC,cAAc;;CAEzB;AAiFD;AACA,MAAqBC,YAGnB,SAAQ5C,gBAA0E;EAyBlF6C,UAAUA,CAACC,OAAY;IACrB,IAAIC,OAAO,GAAG,CAACjD,SAAS,CAAC;IACzB,IAAIgD,OAAO,CAACC,OAAO,EAAE;MACnBA,OAAO,GAAG,CAAC,GAAGA,OAAO,EAAE,GAAGD,OAAO,CAACC,OAAO,CAAC;IAC5C;IAEA,OAAO,KAAK,CAACF,UAAU,CAAC;MAAC,GAAGC,OAAO;MAAEC;IAAO,CAAC,CAAC;EAChD;EAEAC,eAAeA,CAAA;IACb,KAAK,CAACC,0BAA0B,CAACR,UAAU,CAAC;IAC5C,IAAI,CAACS,QAAQ,CAAC;MAACf,WAAW,EAAEjB;IAAoB,CAAC,CAAC;IAClD,IAAI,CAACiC,mBAAmB,EAAE;IAC1B,IAAI,CAACC,gBAAgB,EAAE;IACvB,IAAI,CAACC,eAAe,EAAE;EACxB;EAEAC,iBAAiBA,CAAC;IAACC;EAAW,CAAyB;IACrD;IACA,OAAOA,WAAW,CAACC,gBAAgB;EACrC;EAEA;EACAC,WAAWA,CAACC,IAA4B;IACtC,KAAK,CAACD,WAAW,CAACC,IAAI,CAAC;IACvB,IAAI,CAACC,mBAAmB,CAACD,IAAI,CAAC;EAChC;EAEAC,mBAAmBA,CAACD,IAA4B;IAC9C,MAAM;MAACf,KAAK;MAAEiB;IAAQ,CAAC,GAAGF,IAAI;IAC9B,MAAMH,WAAW,GAAG,IAAI,CAACM,eAAe,CAACH,IAAI,CAAC;IAE9C,IAAIH,WAAW,CAACO,WAAW,IAAIP,WAAW,CAACQ,eAAe,EAAE;MAC1D;MACAR,WAAW,CAACS,aAAa,GAAG,IAAI,CAACC,aAAa,CAACV,WAAW,CAACO,WAAW,CAAC;MACvE,IAAI,CAACI,6BAA6B,EAAE;IACtC;IAEA,IAAIX,WAAW,CAACO,WAAW,IAAIP,WAAW,CAACS,aAAa,EAAE;MACxD;MACAG,YAAY,CAAC,IAAI,CAACC,KAAK,CAACC,WAAW,CAAC;MACpC,IAAI,CAACnB,QAAQ,CAAC;QAACoB,gBAAgB,EAAE;MAAI,CAAC,CAAC;IACzC,CAAC,MAAM,IAAIf,WAAW,CAACgB,mBAAmB,EAAE;MAC1C;MACA,IAAI,CAACC,yBAAyB,EAAE;IAClC;IAEA,IAAI7B,KAAK,CAACV,UAAU,KAAK2B,QAAQ,CAAC3B,UAAU,EAAE;MAC5C,IAAI,CAACwC,mBAAmB,CAACf,IAAI,CAAC;IAChC;IAEA,IAAI,IAAI,CAACU,KAAK,CAACE,gBAAgB,EAAE;MAC/B,IAAI,CAACI,gBAAgB,EAAE;IACzB;IAEA,IAAI,CAACxB,QAAQ,CAAC;MAACyB,IAAI,EAAEjB,IAAI,CAACkB,OAAO,CAACC,QAAQ,CAACF;IAAI,CAAC,CAAC;EACnD;EAEAG,YAAYA,CAAA;IACV,MAAM;MACJC,cAAc;MACdC,iBAAiB;MACjBC,iBAAiB;MACjBC,iBAAiB;MACjBC,YAAY;MACZhD;IAAW,CACZ,GAAG,IAAI,CAACiC,KAAK;IACd,MAAM;MAACgB,cAAc;MAAEvD,SAAS;MAAEK,SAAS;MAAEG;IAAW,CAAC,GAAG,IAAI,CAACM,KAAK;IAEtE,MAAM0C,kBAAkB,GAAG,IAAI,CAACC,gBAAgB,CAAC,UAAU,EAAEvF,aAAa,CAAC;IAE3E,OAAO,IAAIsF,kBAAkB,CAC3B,IAAI,CAACE,gBAAgB,CAAC;MACpBC,EAAE,EAAE,gBAAgB;MACpBJ;KACD,CAAC,EACF;MACE;MACA;MACAK,gBAAgB,EAAE7F,iBAAiB,CAAC8F,OAAO;MAC3ChD,IAAI,EAAE;QACJiD,UAAU,EAAE;UACVC,SAAS,EAAEZ,iBAAiB;UAC5Ba,SAAS,EAAEZ;;OAEd;MACDa,WAAW,EAAE,CAAC;MACdC,UAAU,EAAEb,iBAAiB;MAC7BC,YAAY;MACZa,eAAe,EAAE7E,gBAAgB,CAACkB,WAAW,CAAC,IAAI,CAAC;MACnD0C,cAAc;MACdlD,SAAS;MACTK,SAAS;MACTC;KACD,CACF;EACH;EAEA8D,aAAaA,CAACrB,OAAqB;IACjC,KAAK,CAACqB,aAAa,CAACrB,OAAO,CAAC;IAC5B,MAAM;MACJsB,gBAAgB;MAChBnB,cAAc;MACdoB,kBAAkB;MAClBjB,iBAAiB;MACjBF,iBAAiB;MACjBC,iBAAiB;MACjBE,YAAY;MACZd;IAAW,CACZ,GAAG,IAAI,CAACD,KAAK;IACd8B,gBAAgB,EAAEE,OAAO,EAAE;IAC3BrB,cAAc,EAAEqB,OAAO,EAAE;IACzBD,kBAAkB,EAAEC,OAAO,EAAE;IAC7BlB,iBAAiB,EAAEkB,OAAO,EAAE;IAC5BpB,iBAAiB,EAAEoB,OAAO,EAAE;IAC5BnB,iBAAiB,EAAEmB,OAAO,EAAE;IAC5BjB,YAAY,EAAEiB,OAAO,EAAE;IACvB,IAAI/B,WAAW,EAAE;MACfF,YAAY,CAACE,WAAW,CAAC;IAC3B;EACF;EAEA;EAEA;EACAgC,oBAAoBA,CAAA;IAClB,OAAO,IAAI1G,gBAAgB,CAAC,IAAI,CAACiF,OAAO,CAAC0B,MAAM,EAAE;MAC/Cd,EAAE,EAAE,IAAI,CAAC7C,KAAK,CAAC6C,EAAE;MACjBe,KAAK,EAAE,IAAI,CAAC3B,OAAO,CAAC2B;KACrB,CAAC;EACJ;EAEA1C,eAAeA,CAACH,IAA4B;IAC1C,MAAMH,WAAW,GAGb,EAAE;IACN,MAAM;MAACiD;IAAU,CAAC,GAAG,IAAI,CAACpC,KAAK;IAC/Bb,WAAW,CAACO,WAAW,GACpB,IAAI,CAAC2C,kBAAkB,EAAE,IAAI,mBAAmB;IAAK;IACrD,IAAI,CAACC,kBAAkB,CAAChD,IAAI,EAAE;MAC7BiD,UAAU,EAAE,IAAI;MAChBC,SAAS,EAAEJ,UAAU,CAAC9D;KACvB,CAAC,IACA,sBAAuB;IAC3Ba,WAAW,CAACQ,eAAe,GAAGL,IAAI,CAACH,WAAW,CAACQ,eAAe;IAE9D,MAAM;MAACY;IAAI,CAAC,GAAG,IAAI,CAACP,KAAK;IACzB,IAAI,CAACV,IAAI,CAACkB,OAAO,CAACC,QAAQ,IAAInB,IAAI,CAACkB,OAAO,CAACC,QAAQ,CAACF,IAAI,KAAKA,IAAI,EAAE;MACjEpB,WAAW,CAACgB,mBAAmB,GAAG,IAAI;IACxC;IAEA,OAAOhB,WAAW;EACpB;EAEAsD,eAAeA,CAAA;IACb,MAAM;MAACC,WAAW;MAAEnG;IAAM,CAAC,GAAG,IAAI,CAACyD,KAAK;IAExC,IAAI,CAAClB,QAAQ,CAAC;MACZ6B,cAAc,EAAE,IAAI,CAACH,OAAO,CAAC0B,MAAM,CAACS,aAAa,CAAC;QAChD,GAAGrG,aAAa;QAChBsG,KAAK,EAAEF,WAAW;QAClBG,MAAM,EAAEH,WAAW;QACnBnG;OACD,CAAC;MACFuE,iBAAiB,EAAE,IAAI,CAACN,OAAO,CAAC0B,MAAM,CAACS,aAAa,CAAC;QACnD,GAAGrG,aAAa;QAChBsG,KAAK,EAAE,CAAC;QACRC,MAAM,EAAE,CAAC;QACTtG;OACD;KACF,CAAC;EACJ;EAEAyC,gBAAgBA,CAAA;IACd,MAAM8D,gBAAgB,GAAG,IAAI,CAACC,mBAAmB,EAAG;IACpDD,gBAAgB,CAACE,GAAG,CAAC;MACnBxB,SAAS,EAAE;QAACyB,IAAI,EAAE,CAAC;QAAE7F,IAAI,EAAE,SAAS;QAAE8F,QAAQ,EAAE;MAAa,CAAC;MAC9DC,OAAO,EAAE;QAACF,IAAI,EAAE,CAAC;QAAEC,QAAQ,EAAE;MAAW;KACzC,CAAC;IACF,IAAI,CAACpE,QAAQ,CAAC;MAACsE,qBAAqB,EAAE;IAAW,CAAC,CAAC;EACrD;EAEArE,mBAAmBA,CAAA;IACjB,MAAM;MAACmD;IAAM,CAAC,GAAG,IAAI,CAAC1B,OAAO;IAC7B,MAAM;MAACtC;IAAkB,CAAC,GAAG,IAAI,CAACK,KAAK;IAEvC,MAAMmE,WAAW,GAAGW,IAAI,CAAC3F,GAAG,CAACQ,kBAAkB,EAAEgE,MAAM,CAACoB,MAAM,CAACC,qBAAqB,CAAC;IACrF,MAAMC,kBAAkB,GAAGpF,qBAAqB,CAACqF,KAAK,CAACC,OAAO,IAAIxB,MAAM,CAACyB,QAAQ,CAACC,GAAG,CAACF,OAAO,CAAC,CAAC;IAC/F,MAAMnH,MAAM,GAAkBiH,kBAAkB,GAAG,aAAa,GAAG,YAAY;IAC/E,MAAMK,YAAY,GAAGL,kBAAkB,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG;IACrD,IAAI,CAAC1E,QAAQ,CAAC;MAAC4D,WAAW;MAAEnG,MAAM;MAAEsH;IAAY,CAAC,CAAC;IAClD,IAAI,CAACL,kBAAkB,EAAE;MACvB/H,GAAG,CAACqI,IAAI,CACN,iBAAiB,IAAI,CAAC1C,EAAE,iFAAiF,CAC1G,EAAE;IACL;EACF;EAEA2C,uBAAuBA,CAACrF,OAAkD;IACxE,IAAI;MAACoD;IAAgB,CAAC,GAAG,IAAI,CAAC9B,KAAK;IACnC,MAAM;MAACW;IAAc,CAAC,GAAG,IAAI,CAACX,KAAK;IACnC,MAAM8C,gBAAgB,GAAG,IAAI,CAACC,mBAAmB,EAAG;IAEpDjB,gBAAgB,EAAEE,OAAO,EAAE;IAC3BF,gBAAgB,GAAG,IAAIxG,gBAAgB,CAAC,IAAI,CAACkF,OAAO,CAAC0B,MAAM,EAAE;MAC3Dd,EAAE,EAAE,GAAG,IAAI,CAACA,EAAE,oBAAoB;MAClC4C,YAAY,EAAElB,gBAAgB,CAACmB,gBAAgB,EAAE;MACjDvC,WAAW,EAAE,CAAC;MACdwC,aAAa,EAAEvD,cAAe;MAC9BwD,UAAU,EAAE;QACVC,iBAAiB,EAAE,KAAK;QACxBC,mBAAmB,EAAE,KAAK;QAC1BC,mBAAmB,EAAE,KAAK;QAC1BC,mBAAmB,EAAE,KAAK;QAC1BC,mBAAmB,EAAE,KAAK;QAC1BC,mBAAmB,EAAE;OACtB;MACDC,QAAQ,EAAE,YAAY;MACtB,GAAGhG,OAAO;MACVC,OAAO,EAAE,CAAC,GAAGD,OAAO,CAACC,OAAO,EAAEvC,cAAc;KACpB,CAAC;IAE3B,IAAI,CAAC0C,QAAQ,CAAC;MAACgD;IAAgB,CAAC,CAAC;EACnC;EAEA7C,eAAeA,CAAA;IACb,IAAI,CAACwD,eAAe,EAAE;IACtB,MAAM;MAACP;IAAM,CAAC,GAAG,IAAI,CAAC1B,OAAO;IAC7B,MAAM;MAACkC,WAAW;MAAE/B,cAAc;MAAEG;IAAiB,CAAC,GAAG,IAAI,CAACd,KAAK;IAEnE,MAAM2E,uBAAuB,GAAG,IAAI,CAAClG,UAAU,CAAC;MAC9CmG,EAAE,EAAE7I,SAAS;MACb8I,EAAE,EAAE7I;KACL,CAAC;IACF,IAAI,CAAC+H,uBAAuB,CAACY,uBAAuB,CAAC;IAErD,MAAMG,0BAA0B,GAAG,IAAI,CAACrG,UAAU,CAAC;MACjDmG,EAAE,EAAE3I,KAAK;MACT4I,EAAE,EAAE3I,KAAK;MACTyC,OAAO,EAAE,CAACxC,iBAAiB;KAC5B,CAAC;IACF,MAAM4F,kBAAkB,GAAG,IAAIzG,gBAAgB,CAAC4G,MAAM,EAAE;MACtDd,EAAE,EAAE,GAAG,IAAI,CAACA,EAAE,wBAAwB;MACtC8C,aAAa,EAAEpD,iBAAkB;MACjC,GAAGgE,0BAA0B;MAC7BpD,WAAW,EAAEgB,WAAW,GAAGA,WAAW;MACtCgC,QAAQ,EAAE,YAAY;MACtBP,UAAU,EAAE;QACVC,iBAAiB,EAAE,KAAK;QACxBC,mBAAmB,EAAE,KAAK;QAC1BU,mBAAmB,EAAE,KAAK;QAC1BT,mBAAmB,EAAE,KAAK;QAC1BC,mBAAmB,EAAE,KAAK;QAC1BC,mBAAmB,EAAE,KAAK;QAC1BC,mBAAmB,EAAE;;KAExB,CAAC;IAEF,MAAMO,cAAc,GAAmB;MAACC,SAAS,EAAEtE,cAAe;MAAE+B;IAAW,CAAC;IAChFX,kBAAkB,CAACmD,KAAK,CAACC,YAAY,CAACC,QAAQ,CAAC;MAC7CC,SAAS,EAAEL;KACZ,CAAC;IAEF,IAAI,CAAClG,QAAQ,CAAC;MACZ6B,cAAc;MACdG,iBAAiB;MACjBiB,kBAAkB;MAClBxB,IAAI,EAAE,IAAI;MACVK,iBAAiB,EAAEsB,MAAM,CAACoD,YAAY,CAAC;QAACC,UAAU,EAAE;MAAE,CAAC,CAAC;MACxD1E,iBAAiB,EAAEqB,MAAM,CAACoD,YAAY,CAAC;QAACC,UAAU,EAAE;MAAE,CAAC;KACxD,CAAC;EACJ;EAEA;EACAC,aAAaA,CAACC,aAAa;IACzB;IACA,IAAI,CAAC1B,uBAAuB,CAAC;MAC3Ba,EAAE,EAAE7I,SAAS;MACb8I,EAAE,EAAE7I,SAAS;MACb,GAAGyJ;KACJ,CAAC;EACJ;EAEAC,qBAAqBA,CAAA;IACnB,MAAM;MAAC3D;IAAkB,CAAC,GAAG,IAAI,CAAC/B,KAAK;IAEvC+B,kBAAmB,CAAC4D,GAAG,CAAC;MACtBxB,UAAU,EAAE;QAAC1D,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;MAAC,CAAC;MACpCmF,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;KACxB,CAAC;EACJ;EAEA;EACA/F,aAAaA,CAACgG,WAAA,GAAmB,KAAK;IACpC,MAAM;MAACpF;IAAQ,CAAC,GAAG,IAAI,CAACD,OAAO;IAE/B;IACA;IACA,MAAMsF,eAAe,GAAG,CACtBrF,QAAQ,CAACsF,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAC1BtF,QAAQ,CAACsF,SAAS,CAAC,CAACtF,QAAQ,CAACmC,KAAK,EAAE,CAAC,CAAC,CAAC,EACvCnC,QAAQ,CAACsF,SAAS,CAAC,CAAC,CAAC,EAAEtF,QAAQ,CAACoC,MAAM,CAAC,CAAC,EACxCpC,QAAQ,CAACsF,SAAS,CAAC,CAACtF,QAAQ,CAACmC,KAAK,EAAEnC,QAAQ,CAACoC,MAAM,CAAC,CAAC,CACtD,CAACmD,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACD,GAAG,CAAC3C,IAAI,CAAC6C,MAAM,CAAC,CAAC;IAE9B;IACA,MAAMC,kBAAkB,GAAGlL,SAAS,CAAC6K,eAAe,CAAC,CAAC,CAAC;IAEvD,MAAMM,QAAQ,GAAmC;MAACD,kBAAkB;MAAEL;IAAe,CAAC;IACtF,IAAIlG,aAAa,GAAG,KAAK;IAEzB,IACEiG,WAAW,IACX,CAAC,IAAI,CAAC7F,KAAK,CAACqG,WAAW,IACvB,CAACnL,aAAa,CAAC,IAAI,CAAC8E,KAAK,CAACqG,WAAW,EAAEF,kBAAkB,CAAC,EAC1D;MACA;MACA;MACA,MAAMG,kBAAkB,GAAG,IAAI,CAACC,oBAAoB,CAACJ,kBAAkB,CAAC;MAExE;MACA,MAAME,WAAW,GAAG,IAAI,CAACG,oBAAoB,CAACF,kBAAkB,CAAC;MAEjE;MACA,IAAI,IAAI,CAAC/H,KAAK,CAAC8C,gBAAgB,KAAK7F,iBAAiB,CAACiL,MAAM,EAAE;QAC5DJ,WAAW,CAAC,CAAC,CAAC,GAAGhD,IAAI,CAACzF,GAAG,CAACyI,WAAW,CAAC,CAAC,CAAC,EAAE,CAAC,SAAS,CAAC;QACrDA,WAAW,CAAC,CAAC,CAAC,GAAGhD,IAAI,CAAC3F,GAAG,CAAC2I,WAAW,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC;QACpDA,WAAW,CAAC,CAAC,CAAC,GAAGhD,IAAI,CAACzF,GAAG,CAACyI,WAAW,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC;QAC/CA,WAAW,CAAC,CAAC,CAAC,GAAGhD,IAAI,CAAC3F,GAAG,CAAC2I,WAAW,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC;MAChD;MAEA;MACA,MAAMK,sBAAsB,GAAG,IAAI,CAACH,oBAAoB,CAACF,WAAW,CAAC;MAErED,QAAQ,CAACC,WAAW,GAAGA,WAAW;MAClCD,QAAQ,CAACM,sBAAsB,GAAGA,sBAAsB;MAExD9G,aAAa,GAAG,IAAI;IACtB;IACA,IAAI,CAACd,QAAQ,CAACsH,QAAQ,CAAC;IACvB,OAAOxG,aAAa;EACtB;EAEAE,6BAA6BA,CAAA;IAC3B;IACA,MAAM;MAACc,iBAAiB;MAAEC,iBAAiB;MAAE6F,sBAAsB;MAAEZ;IAAe,CAAC,GACnF,IAAI,CAAC9F,KAAK;IAEZ,MAAM;MAACS;IAAQ,CAAC,GAAG,IAAI,CAACD,OAAO;IAE/BI,iBAAkB,CAAC+F,KAAK,CAACxL,YAAY,CAAC2K,eAAe,EAAE,CAAC,CAAC,CAAC;IAE1D,MAAMc,aAAa,GAAGd,eAAe,CAACE,GAAG,CAACC,CAAC,IACzC5K,qBAAqB,CAACoF,QAAQ,CAACoG,eAAe,CAACZ,CAAC,CAAC,EAAES,sBAAuB,CAAC,CAC5E;IACD7F,iBAAkB,CAAC8F,KAAK,CAACxL,YAAY,CAACyL,aAAa,EAAE,CAAC,CAAC,CAAC;EAC1D;EAEAvG,mBAAmBA,CAACf,IAAI;IACtB,MAAM;MAACzB;IAAU,CAAC,GAAGyB,IAAI,CAACf,KAAK;IAC/B,IAAI;MAACwC;IAAY,CAAC,GAAG,IAAI,CAACf,KAAK;IAC/B,MAAM8G,MAAM,GAAGhL,qBAAqB,CAAC+B,UAAU,EAAE,KAAK,EAAEkJ,UAAiB,CAAC;IAE1E,IAAIhG,YAAY,IAAIA,YAAY,EAAE6B,KAAK,KAAK/E,UAAU,CAACmJ,MAAM,EAAE;MAC7D;MACCjG,YAAoB,CAACkG,gBAAgB,CAAC;QAAC3I,IAAI,EAAEwI;MAAM,CAAC,CAAC;IACxD,CAAC,MAAM;MACL/F,YAAY,EAAEiB,OAAO,EAAE;MACvB;MACAjB,YAAY,GAAG,IAAI,CAACP,OAAO,CAAC0B,MAAM,CAACS,aAAa,CAAC;QAC/C,GAAGrG,aAAa;QAChBgC,IAAI,EAAEwI,MAAM;QACZlE,KAAK,EAAE/E,UAAU,CAACmJ,MAAM;QACxBnE,MAAM,EAAE;OACT,CAAC;IACJ;IACA,IAAI,CAAC/D,QAAQ,CAAC;MAACiC;IAAY,CAAC,CAAC;EAC/B;EAEAT,gBAAgBA,CAAA;IACd,MAAM;MAAC3C,YAAY;MAAEI,WAAW;MAAEE;IAAW,CAAC,GAAG,IAAI,CAACM,KAAK;IAC3D,MAAM;MAAC8H,WAAW;MAAE3D,WAAW;MAAEmB,YAAY;MAAElD;IAAc,CAAC,GAAG,IAAI,CAACX,KAAK;IAC3E,MAAM8B,gBAAgB,GAAG,IAAI,CAAC9B,KAAK,CAAC8B,gBAAiB;IACrD,IAAI,CAAC9B,KAAK,CAACE,gBAAgB,GAAG,KAAK;IAEnC;IACA,MAAMgH,YAAY,GAAG,IAAI,CAACX,oBAAoB,CAACF,WAAW,EAAE;MAC1Dc,wBAAwB,EAAE;KAC3B,CAAC;IAEF,IAAIpJ,WAAW,IAAIE,WAAW,KAAK,KAAK,EAAE;MACxC;MACA,MAAM;QAACwC;MAAQ,CAAC,GAAG,IAAI,CAACD,OAAO;MAC/B,MAAM4G,cAAc,GACjB3G,QAAQ,CAAC4G,cAAc,CAACC,aAAa,CAAC,CAAC,CAAC,IAAIJ,YAAY,CAAC,CAAC,CAAC,GAAGA,YAAY,CAAC,CAAC,CAAC,CAAC,GAC/ExE,WAAW;MACb,IAAI,CAAC1C,KAAK,CAACjC,WAAW,GAAGA,WAAW,CAACiI,GAAG,CAAC1I,CAAC,IAAIA,CAAC,GAAG8J,cAAc,GAAGvD,YAAY,CAAC;IAClF,CAAC,MAAM;MACL,IAAI,CAAC7D,KAAK,CAACjC,WAAW,GAAGA,WAAW,IAAIjB,oBAAoB;IAC9D;IAEA,MAAMgG,gBAAgB,GAAG,IAAI,CAACC,mBAAmB,EAAG;IACpD,MAAMxB,UAAU,GAAGuB,gBAAgB,CAACyE,aAAa,EAAE;IACnD,MAAMC,cAAc,GAAG,IAAI,CAACC,iBAAiB,EAAE;IAC/C,IAAI,CAACC,mBAAmB,CAAC5F,gBAAgB,CAACoD,KAAK,EAAE3D,UAAU,CAAC;IAC5DO,gBAAgB,CAACoD,KAAK,CAACyC,cAAc,CAAC,IAAI,CAACC,eAAe,EAAE,CAAC;IAE7D,MAAMC,WAAW,GAAgB;MAC/BlK,YAAY;MACZuJ,YAAY;MACZY,YAAY,EAAEpF,WAAW;MACzBmB,YAAY;MACZlD,cAAc,EAAEA;KACjB;IACD,MAAM;MAACF,QAAQ;MAAEsH,gBAAgB;MAAE1G,gBAAgB;MAAE2G;IAAgB,CAAC,GAAGR,cAAc;IACvF,MAAM;MAACS;IAAW,CAAC,GAAG,IAAI,CAAC1J,KAAK;IAChCuD,gBAAgB,CAACoD,KAAK,CAACC,YAAY,CAACC,QAAQ,CAAC;MAC3C8C,OAAO,EAAE;QAACzH,QAAQ;QAAEsH,gBAAgB;QAAEE,WAAW;QAAE5G,gBAAgB;QAAE2G;MAAgB,CAAC;MACtFG,MAAM,EAAEN;KACT,CAAC;IACF/F,gBAAgB,CAAC6D,GAAG,CAAC;MACnBxB,UAAU,EAAE;QAAC1D,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAEiC,WAAW,EAAEA,WAAW;MAAC,CAAC;MACxDkD,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;KACxB,CAAC;IAEF,IAAI,CAACF,qBAAqB,EAAE;EAC9B;EAEAtF,yBAAyBA,CAACgI,SAAS,GAAG,KAAK;IACzC,IAAI;MAACnI;IAAW,CAAC,GAAG,IAAI,CAACD,KAAK;IAC9B,MAAM;MAAC7B;IAAe,CAAC,GAAG,IAAI,CAACI,KAAK;IAEpC,IAAI6J,SAAS,EAAE;MACbnI,WAAW,GAAG,IAAI;MAClB;MACA,IAAI,CAACJ,aAAa,CAAC,IAAI,CAAC;MACxB,IAAI,CAACC,6BAA6B,EAAE;MACpC,IAAI,CAAChB,QAAQ,CAAC;QAACoB,gBAAgB,EAAE;MAAI,CAAC,CAAC;IACzC,CAAC,MAAM;MACL,IAAI,CAACpB,QAAQ,CAAC;QAACoB,gBAAgB,EAAE;MAAK,CAAC,CAAC;MACxCH,YAAY,CAACE,WAAW,CAAC;MACzBA,WAAW,GAAGoI,UAAU,CAAC,IAAI,CAACjI,yBAAyB,CAACkI,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,EAAEnK,eAAe,CAAC;IAC5F;IAEA,IAAI,CAACW,QAAQ,CAAC;MAACmB;IAAW,CAAC,CAAC;EAC9B;EAEA;EACA;EACA;EACAsG,oBAAoBA,CAClBF,WAAW,EACX/G,IAAA,GAA6C,EAAE;IAE/C,MAAM;MAAC6H,wBAAwB,GAAG;IAAK,CAAC,GAAG7H,IAAI;IAC/C,MAAM,CAACiJ,OAAO,EAAEC,MAAM,EAAEC,OAAO,EAAEC,MAAM,CAAC,GAAGrC,WAAW;IACtD,MAAM;MAAC5F;IAAQ,CAAC,GAAG,IAAI,CAACD,OAAO;IAC/B,MAAM;MAACkC;IAAW,CAAC,GAAG,IAAI,CAAC1C,KAAK;IAChC,MAAM;MAACqB;IAAgB,CAAC,GAAG,IAAI,CAAC9C,KAAK;IAErC,MAAMoK,UAAU,GACdxB,wBAAwB,KACvB9F,gBAAgB,KAAK7F,iBAAiB,CAACoN,cAAc,IACpDvH,gBAAgB,KAAK7F,iBAAiB,CAACqN,aAAa,CAAC;IACzD,MAAMC,kBAAkB,GAAGH,UAAU,GACjClI,QAAQ,CAACoG,eAAe,CAAC,IAAI,CAACtI,KAAK,CAACyJ,gBAAgB,CAAC,GACrD,CAAC,CAAC,EAAE,CAAC,CAAC;IACV,MAAM/E,IAAI,GAAIP,WAAW,GAAGrG,UAAU,GAAIoE,QAAQ,CAACsI,KAAK;IAExD,IAAIC,gBAAgB;IACpB,IAAIC,cAAc;IAElB;IACA,IAAI9B,wBAAwB,IAAI,CAACwB,UAAU,EAAE;MAC3CK,gBAAgB,GAAG,IAAI,CAACnC,eAAe,CAAC,CAAC0B,OAAO,EAAEC,MAAM,EAAE,CAAC,CAAC,CAAC;MAC7DS,cAAc,GAAG,IAAI,CAACpC,eAAe,CAAC,CAAC4B,OAAO,EAAEC,MAAM,EAAE,CAAC,CAAC,CAAC;IAC7D,CAAC,MAAM;MACLM,gBAAgB,GAAGvI,QAAQ,CAACoG,eAAe,CAAC,CAAC0B,OAAO,EAAEC,MAAM,EAAE,CAAC,CAAC,CAAC;MACjES,cAAc,GAAGxI,QAAQ,CAACoG,eAAe,CAAC,CAAC4B,OAAO,EAAEC,MAAM,EAAE,CAAC,CAAC,CAAC;IACjE;IACA;IACA,OAAOtN,kBAAkB,CACvB,CACE4N,gBAAgB,CAAC,CAAC,CAAC,GAAGF,kBAAkB,CAAC,CAAC,CAAC,EAC3CE,gBAAgB,CAAC,CAAC,CAAC,GAAGF,kBAAkB,CAAC,CAAC,CAAC,EAC3CG,cAAc,CAAC,CAAC,CAAC,GAAGH,kBAAkB,CAAC,CAAC,CAAC,EACzCG,cAAc,CAAC,CAAC,CAAC,GAAGH,kBAAkB,CAAC,CAAC,CAAC,CAC1C,EACD7F,IAAI,EACJA,IAAI,CACL;EACH;EAEA;EACA;EACAuD,oBAAoBA,CAACU,YAAY;IAC/B,MAAM,CAACgC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAEC,IAAI,CAAC,GAAGnC,YAAY;IAC7C,MAAM;MAACzG;IAAQ,CAAC,GAAG,IAAI,CAACD,OAAO;IAC/B,MAAM8I,eAAe,GAAG7I,QAAQ,CAAC8I,iBAAiB,CAAC,CAACL,IAAI,EAAEC,IAAI,CAAC,CAAC;IAChE,MAAMK,aAAa,GAAG/I,QAAQ,CAAC8I,iBAAiB,CAAC,CAACH,IAAI,EAAEC,IAAI,CAAC,CAAC;IAE9D,OAAOC,eAAe,CAACG,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAACC,MAAM,CAACF,aAAa,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EACtE;;AA/gBOjL,YAAA,CAAAmL,SAAS,GAAG,cAAc;AAC1BnL,YAAA,CAAAtB,YAAY,GAAGA,YAAY;eALfsB,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}