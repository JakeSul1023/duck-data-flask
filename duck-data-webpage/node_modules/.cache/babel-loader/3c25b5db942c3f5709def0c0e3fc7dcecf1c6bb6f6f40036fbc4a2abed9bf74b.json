{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getDataTypeFromTypedArray } from \"../table/simple-table/data-type.js\";\n/**\n * Create a schema for mesh attributes data\n * @param attributes\n * @param metadata\n * @returns\n */\nexport function deduceMeshSchema(attributes, metadata = {}) {\n  const fields = deduceMeshFields(attributes);\n  return {\n    fields,\n    metadata\n  };\n}\n/**\n * Create arrow-like schema field for mesh attribute\n * @param attributeName\n * @param attribute\n * @param optionalMetadata\n * @returns\n */\nexport function deduceMeshField(name, attribute, optionalMetadata) {\n  const type = getDataTypeFromTypedArray(attribute.value);\n  const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);\n  return {\n    name,\n    type: {\n      type: 'fixed-size-list',\n      listSize: attribute.size,\n      children: [{\n        name: 'value',\n        type\n      }]\n    },\n    nullable: false,\n    metadata\n  };\n}\n/**\n * Create fields array for mesh attributes\n * @param attributes\n * @returns\n */\nfunction deduceMeshFields(attributes) {\n  const fields = [];\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    fields.push(deduceMeshField(attributeName, attribute));\n  }\n  return fields;\n}\n/**\n * Make metadata by mesh attribute properties\n * @param attribute\n * @returns\n */\nexport function makeMeshAttributeMetadata(attribute) {\n  const result = {};\n  if ('byteOffset' in attribute) {\n    result.byteOffset = attribute.byteOffset.toString(10);\n  }\n  if ('byteStride' in attribute) {\n    result.byteStride = attribute.byteStride.toString(10);\n  }\n  if ('normalized' in attribute) {\n    result.normalized = attribute.normalized.toString();\n  }\n  return result;\n}","map":{"version":3,"names":["getDataTypeFromTypedArray","deduceMeshSchema","attributes","metadata","fields","deduceMeshFields","deduceMeshField","name","attribute","optionalMetadata","type","value","makeMeshAttributeMetadata","listSize","size","children","nullable","attributeName","push","result","byteOffset","toString","byteStride","normalized"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/schema/dist/lib/mesh/deduce-mesh-schema.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getDataTypeFromTypedArray } from \"../table/simple-table/data-type.js\";\n/**\n * Create a schema for mesh attributes data\n * @param attributes\n * @param metadata\n * @returns\n */\nexport function deduceMeshSchema(attributes, metadata = {}) {\n    const fields = deduceMeshFields(attributes);\n    return { fields, metadata };\n}\n/**\n * Create arrow-like schema field for mesh attribute\n * @param attributeName\n * @param attribute\n * @param optionalMetadata\n * @returns\n */\nexport function deduceMeshField(name, attribute, optionalMetadata) {\n    const type = getDataTypeFromTypedArray(attribute.value);\n    const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);\n    return {\n        name,\n        type: { type: 'fixed-size-list', listSize: attribute.size, children: [{ name: 'value', type }] },\n        nullable: false,\n        metadata\n    };\n}\n/**\n * Create fields array for mesh attributes\n * @param attributes\n * @returns\n */\nfunction deduceMeshFields(attributes) {\n    const fields = [];\n    for (const attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        fields.push(deduceMeshField(attributeName, attribute));\n    }\n    return fields;\n}\n/**\n * Make metadata by mesh attribute properties\n * @param attribute\n * @returns\n */\nexport function makeMeshAttributeMetadata(attribute) {\n    const result = {};\n    if ('byteOffset' in attribute) {\n        result.byteOffset = attribute.byteOffset.toString(10);\n    }\n    if ('byteStride' in attribute) {\n        result.byteStride = attribute.byteStride.toString(10);\n    }\n    if ('normalized' in attribute) {\n        result.normalized = attribute.normalized.toString();\n    }\n    return result;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,yBAAyB,QAAQ,oCAAoC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,gBAAgBA,CAACC,UAAU,EAAEC,QAAQ,GAAG,CAAC,CAAC,EAAE;EACxD,MAAMC,MAAM,GAAGC,gBAAgB,CAACH,UAAU,CAAC;EAC3C,OAAO;IAAEE,MAAM;IAAED;EAAS,CAAC;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,eAAeA,CAACC,IAAI,EAAEC,SAAS,EAAEC,gBAAgB,EAAE;EAC/D,MAAMC,IAAI,GAAGV,yBAAyB,CAACQ,SAAS,CAACG,KAAK,CAAC;EACvD,MAAMR,QAAQ,GAAGM,gBAAgB,GAAGA,gBAAgB,GAAGG,yBAAyB,CAACJ,SAAS,CAAC;EAC3F,OAAO;IACHD,IAAI;IACJG,IAAI,EAAE;MAAEA,IAAI,EAAE,iBAAiB;MAAEG,QAAQ,EAAEL,SAAS,CAACM,IAAI;MAAEC,QAAQ,EAAE,CAAC;QAAER,IAAI,EAAE,OAAO;QAAEG;MAAK,CAAC;IAAE,CAAC;IAChGM,QAAQ,EAAE,KAAK;IACfb;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,gBAAgBA,CAACH,UAAU,EAAE;EAClC,MAAME,MAAM,GAAG,EAAE;EACjB,KAAK,MAAMa,aAAa,IAAIf,UAAU,EAAE;IACpC,MAAMM,SAAS,GAAGN,UAAU,CAACe,aAAa,CAAC;IAC3Cb,MAAM,CAACc,IAAI,CAACZ,eAAe,CAACW,aAAa,EAAET,SAAS,CAAC,CAAC;EAC1D;EACA,OAAOJ,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASQ,yBAAyBA,CAACJ,SAAS,EAAE;EACjD,MAAMW,MAAM,GAAG,CAAC,CAAC;EACjB,IAAI,YAAY,IAAIX,SAAS,EAAE;IAC3BW,MAAM,CAACC,UAAU,GAAGZ,SAAS,CAACY,UAAU,CAACC,QAAQ,CAAC,EAAE,CAAC;EACzD;EACA,IAAI,YAAY,IAAIb,SAAS,EAAE;IAC3BW,MAAM,CAACG,UAAU,GAAGd,SAAS,CAACc,UAAU,CAACD,QAAQ,CAAC,EAAE,CAAC;EACzD;EACA,IAAI,YAAY,IAAIb,SAAS,EAAE;IAC3BW,MAAM,CAACI,UAAU,GAAGf,SAAS,CAACe,UAAU,CAACF,QAAQ,CAAC,CAAC;EACvD;EACA,OAAOF,MAAM;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}