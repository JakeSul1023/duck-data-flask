{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT AND ISC\n// Copyright (c) vis.gl contributors\n// Based on https://github.com/mapbox/geojson-vt under compatible ISC license\nimport { log } from '@loaders.gl/loader-utils';\nimport { deduceTableSchema } from '@loaders.gl/schema';\nimport { Stats, Stat } from '@probe.gl/stats';\nimport { createProtoTile } from \"./lib/vector-tiler/proto-tile.js\";\nimport { transformTile } from \"./lib/vector-tiler/transform-tile.js\"; // coordinate transformation\nimport { convertTileToGeoJSON } from \"./lib/vector-tiler/tile-to-geojson.js\"; // tile clipping and wrapping\nimport { convertFeaturesToProtoFeature } from \"./lib/vector-tiler/features/convert-feature.js\";\nimport { clipFeatures } from \"./lib/vector-tiler/features/clip-features.js\"; // stripe clipping algorithm\nimport { wrapFeatures } from \"./lib/vector-tiler/features/wrap-features.js\"; // date line processing\n/** Options to configure tiling */\nexport const TableTileSource = {\n  name: 'TableTiler',\n  id: 'table-tiler',\n  version: '0.0.0',\n  extensions: ['mvt'],\n  mimeTypes: ['application/octet-stream'],\n  options: {\n    table: {\n      coordinates: 'local',\n      promoteId: undefined,\n      maxZoom: 14,\n      indexMaxZoom: 5,\n      maxPointsPerTile: 10000,\n      tolerance: 3,\n      extent: 4096,\n      buffer: 64,\n      generateId: undefined\n    }\n  },\n  type: 'table',\n  testURL: url => url.endsWith('.geojson'),\n  createDataSource(url, options) {\n    const needsLoading = typeof url === 'string' || url instanceof Blob;\n    const loader = options?.table?.loaders?.[0];\n    const tablePromise = needsLoading ? loadTable(url, loader) : url;\n    return new DynamicVectorTileSource(tablePromise, options);\n  }\n  // @ts-expect-error\n};\nasync function loadTable(url, loader) {\n  if (typeof url === 'string') {\n    const response = await fetch(url);\n    const data = await response.arrayBuffer();\n    return await loader.parse(data);\n  }\n  const data = await url.arrayBuffer();\n  return await loader.parse(data); //  options.loaders, options.loadOptions)\n}\n/**\n * Dynamically vector tiles a table (the table needs a geometry column)\n * - Tiles are generated when requested.\n * - Each tile contains a tables of clipped features.\n *\n * @note - Currently only accepts `GeoJSONTable` tables\n * @note - Currently only outputs `GeoJSONTable`\n * @note - (can be initialized with a promise that resolves to GeoJSONTable).\n *\n * @todo - metadata should scan all rows to determine schema\n * @todo - metadata scan all rows to determine tilestats (field values[] etc).\n * @todo - handle binary input tables\n * @todo - generate binary output tables\n * @todo - how does TileSourceLayer specify coordinates / decided which layer to render with\n */\nexport class DynamicVectorTileSource {\n  /** Global stats for all DynamicVectorTileSources */\n  static stats = new Stats({\n    id: 'table-tile-source-all',\n    stats: [new Stat('count', 'tiles'), new Stat('count', 'features')]\n  });\n  /** Stats for this DynamicVectorTileSource */\n  stats = new Stats({\n    id: 'table-tile-source',\n    stats: [new Stat('tiles', 'count'), new Stat('features', 'count')]\n  });\n  /** MIME type of the tiles emitted by this tile source */\n  mimeType = 'application/vnd.mapbox-vector-tile';\n  localCoordinates = true;\n  /** The props that this tile source was created with */\n  // @ts-expect-error\n  props;\n  /* Schema of the data */\n  schema = null;\n  /** Map of generated tiles, indexed by stringified tile coordinates */\n  tiles = {};\n  /** Array of tile coordinates */\n  tileCoords = [];\n  /** Input data has loaded, initial top-level tiling is done, sync methods can now be called */\n  ready;\n  /** Metadata for the tile source (generated TileJSON/tilestats */\n  metadata;\n  constructor(table, props) {\n    // @ts-expect-error\n    this.props = {\n      ...TableTileSource.options.table,\n      ...props?.table\n    };\n    this.getTileData = this.getTileData.bind(this);\n    this.ready = this.initializeTilesAsync(table);\n    this.metadata = this.getMetadata();\n  }\n  async initializeTilesAsync(tablePromise) {\n    const table = await tablePromise;\n    this.schema = deduceTableSchema(table);\n    this.createRootTiles(table);\n  }\n  async getMetadata() {\n    await this.ready;\n    return {\n      schema: this.schema,\n      minZoom: 0,\n      maxZoom: this.props.maxZoom\n    };\n  }\n  async getSchema() {\n    await this.ready;\n    return this.schema;\n  }\n  /**\n   * Get a tile at the specified index\n   * @param tileIndex z, x, y of tile\n   * @returns\n   */\n  async getVectorTile(tileIndex) {\n    await this.ready;\n    const table = this.getTileSync(tileIndex);\n    log.info(2, 'getVectorTile', tileIndex, table)();\n    return table;\n  }\n  async getTile(tileIndex) {\n    await this.ready;\n    return this.getTileSync(tileIndex);\n  }\n  async getTileData(tileParams) {\n    const {\n      x,\n      y,\n      z\n    } = tileParams.index;\n    const tile = await this.getVectorTile({\n      x,\n      y,\n      z\n    });\n    return tile?.features || [];\n  }\n  // Implementation\n  /**\n   * Synchronously request a tile\n   * @note Application must await `source.ready` before calling sync methods.\n   */\n  getTileSync(tileIndex) {\n    const protoTile = this.getProtoTile(tileIndex);\n    if (!protoTile) {\n      return null;\n    }\n    return convertTileToGeoJSON(protoTile, {\n      coordinates: this.props.coordinates,\n      tileIndex,\n      extent: this.props.extent\n    });\n  }\n  /**\n   * Create the initial tiles\n   * @note the tiles stores all the features together with additional data\n   */\n  createRootTiles(table) {\n    if (this.props.maxZoom < 0 || this.props.maxZoom > 24) {\n      throw new Error('maxZoom should be in the 0-24 range');\n    }\n    if (this.props.promoteId && this.props.generateId) {\n      throw new Error('promoteId and generateId cannot be used together.');\n    }\n    log.log(1, 'DynamicVectorTileSource creating root tiles', this.props)();\n    // projects and adds simplification info\n    log.time(1, 'preprocess table')();\n    let features = convertFeaturesToProtoFeature(table, this.props);\n    log.timeEnd(1, 'preprocess table')();\n    // wraps features (ie extreme west and extreme east)\n    log.time(1, 'generate tiles')();\n    features = wrapFeatures(features, this.props);\n    // start slicing from the top tile down\n    if (features.length === 0) {\n      log.log(1, 'DynamicVectorTileSource: no features generated')();\n      return;\n    }\n    this.splitTile(features, 0, 0, 0);\n    const rootTile = this.tiles[0];\n    log.log(1, `root tile features: ${rootTile.numFeatures}, points: ${rootTile.numPoints}`)();\n    log.timeEnd(1, 'generate tiles')();\n    log.log(1, `DynamicVectorTileSource: tiles generated: ${this.stats.get('total').count}`, this.stats)();\n  }\n  /**\n   * Return geojsonvt-style \"half formed\" vector tile\n   * @note Application must await `source.ready` before calling sync methods.\n   */\n  // eslint-disable-next-line complexity, max-statements\n  getProtoTile(tileIndex) {\n    const {\n      z,\n      y\n    } = tileIndex;\n    let {\n      x\n    } = tileIndex;\n    // z = +z;\n    // x = +x;\n    // y = +y;\n    const {\n      extent\n    } = this.props;\n    if (z < 0 || z > 24) {\n      return null;\n    }\n    const z2 = 1 << z;\n    x = x + z2 & z2 - 1; // wrapFeatures tile x coordinate\n    const id = toID(z, x, y);\n    if (this.tiles[id]) {\n      return transformTile(this.tiles[id], extent);\n    }\n    log.log(log, 'drilling down to z%d-%d-%d', z, x, y)();\n    let z0 = z;\n    let x0 = x;\n    let y0 = y;\n    let parent;\n    while (!parent && z0 > 0) {\n      z0--;\n      x0 = x0 >> 1;\n      y0 = y0 >> 1;\n      parent = this.tiles[toID(z0, x0, y0)];\n    }\n    if (!parent || !parent.sourceFeatures) {\n      return null;\n    }\n    // if we found a parent tile containing the original geometry, we can drill down from it\n    log.log(1, 'found parent tile z%d-%d-%d', z0, x0, y0)();\n    log.time(1, 'drilling down')();\n    this.splitTile(parent.sourceFeatures, z0, x0, y0, z, x, y);\n    log.timeEnd(1, 'drilling down')();\n    return this.tiles[id] ? transformTile(this.tiles[id], extent) : null;\n  }\n  /**\n   * splits features from a parent tile to sub-tiles.\n   * @param z, x, and y are the coordinates of the parent tile\n   * @param cz, cx, and cy are the coordinates of the target tile\n   *\n   * If no target tile is specified, splitting stops when we reach the maximum\n   * zoom or the number of points is low as specified in the props.\n   */\n  // eslint-disable-next-line max-params, max-statements, complexity\n  splitTile(features, z, x, y, cz, cx, cy) {\n    const stack = [features, z, x, y];\n    // avoid recursion by using a processing queue\n    while (stack.length) {\n      y = stack.pop();\n      x = stack.pop();\n      z = stack.pop();\n      features = stack.pop();\n      const z2 = 1 << z;\n      const id = toID(z, x, y);\n      let tile = this.tiles[id];\n      if (!tile) {\n        log.time(2, 'tile creation')();\n        tile = this.tiles[id] = createProtoTile(features, z, x, y, this.props);\n        this.tileCoords.push({\n          z,\n          x,\n          y\n        });\n        const key = `z${z}`;\n        let stat = this.stats.get(key, 'count');\n        stat.incrementCount();\n        stat = this.stats.get('total');\n        stat.incrementCount();\n        stat = DynamicVectorTileSource.stats.get(key, 'count');\n        stat.incrementCount();\n        stat = DynamicVectorTileSource.stats.get('total');\n        stat.incrementCount();\n        log.log(2, 'tile z%d-%d-%d (features: %d, points: %d, simplified: %d)', z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified)();\n        log.timeEnd(2, 'tile creation')();\n      }\n      // save reference to original geometry in tile so that we can drill down later if we stop now\n      tile.sourceFeatures = features;\n      /* eslint-disable no-continue */\n      // if it's the first-pass tiling\n      if (cz === undefined) {\n        // stop tiling if we reached max zoom, or if the tile is too simple\n        if (z === this.props.indexMaxZoom || tile.numPoints <= this.props.maxPointsPerTile) {\n          continue;\n        }\n        // if a drilldown to a specific tile\n      } else if (z === this.props.maxZoom || z === cz) {\n        // stop tiling if we reached base zoom or our target tile zoom\n        continue;\n      } else if (cz !== undefined) {\n        // stop tiling if it's not an ancestor of the target tile\n        const zoomSteps = cz - z;\n        // @ts-expect-error TODO fix the types of cx cy\n        if (x !== cx >> zoomSteps || y !== cy >> zoomSteps) {\n          continue;\n        }\n      }\n      // if we slice further down, no need to keep source geometry\n      tile.sourceFeatures = null;\n      if (features.length === 0) continue;\n      log.time(2, 'clipping tile')();\n      // values we'll use for clipping\n      const k1 = 0.5 * this.props.buffer / this.props.extent;\n      const k2 = 0.5 - k1;\n      const k3 = 0.5 + k1;\n      const k4 = 1 + k1;\n      let tl = null;\n      let bl = null;\n      let tr = null;\n      let br = null;\n      let left = clipFeatures(features, z2, x - k1, x + k3, 0, tile.minX, tile.maxX, this.props);\n      let right = clipFeatures(features, z2, x + k2, x + k4, 0, tile.minX, tile.maxX, this.props);\n      // @ts-expect-error - unclear why this is needed?\n      features = null;\n      if (left) {\n        tl = clipFeatures(left, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, this.props);\n        bl = clipFeatures(left, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, this.props);\n        left = null;\n      }\n      if (right) {\n        tr = clipFeatures(right, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, this.props);\n        br = clipFeatures(right, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, this.props);\n        right = null;\n      }\n      log.timeEnd(2, 'clipping tile')();\n      stack.push(tl || [], z + 1, x * 2, y * 2);\n      stack.push(bl || [], z + 1, x * 2, y * 2 + 1);\n      stack.push(tr || [], z + 1, x * 2 + 1, y * 2);\n      stack.push(br || [], z + 1, x * 2 + 1, y * 2 + 1);\n    }\n  }\n}\nfunction toID(z, x, y) {\n  return ((1 << z) * y + x) * 32 + z;\n}\n/*\n\n// eslint-disable-next-line max-statements, complexity\nfunction convertToGeoJSONTable(\n  vtTile: ProtoTile,\n  props: {\n    coordinates: 'local' | 'wgs84' | 'EPSG:4326';\n    tileIndex: {x: number; y: number; z: number};\n    extent: number;\n  }\n): GeoJSONTable | null {\n  const features: Feature[] = [];\n  for (const rawFeature of vtTile.features) {\n    if (!rawFeature || !rawFeature.geometry) {\n      continue;\n    }\n\n    let type:\n      | 'Point'\n      | 'MultiPoint'\n      | 'LineString'\n      | 'MultiLineString'\n      | 'Polygon'\n      | 'MultiPolygon';\n\n    let coordinates: any;\n\n    // raw geometry\n    switch (rawFeature.type) {\n      case 1:\n        if (rawFeature.geometry.length === 1) {\n          type = 'Point';\n          coordinates = rawFeature.geometry[0];\n        } else {\n          type = 'MultiPoint';\n          coordinates = rawFeature.geometry;\n        }\n        break;\n      case 2:\n        if (rawFeature.geometry.length === 1) {\n          type = 'LineString';\n          coordinates = rawFeature.geometry[0];\n        } else {\n          type = 'MultiLineString';\n          coordinates = rawFeature.geometry;\n        }\n        break;\n      case 3:\n        if (rawFeature.geometry.length > 1) {\n          type = 'MultiPolygon';\n          coordinates = [rawFeature.geometry];\n        } else {\n          type = 'Polygon';\n          coordinates = rawFeature.geometry;\n        }\n        break;\n      default:\n        continue;\n    }\n\n    switch (props.coordinates) {\n      case 'EPSG:4326':\n      case 'wgs84':\n        projectToLngLat(coordinates, props.tileIndex, props.extent);\n        break;\n\n      case 'local':\n        convertToLocalCoordinates(coordinates, props.extent);\n        break;\n\n      default:\n        throw new Error(`Unsupported CRS ${props.coordinates}`);\n    }\n\n    const feature: Feature = {\n      type: 'Feature',\n      geometry: {\n        type,\n        coordinates\n      },\n      properties: rawFeature.tags || {},\n      id: rawFeature.id\n    };\n\n    features.push(feature);\n  }\n\n  if (features.length === 0) {\n    return null;\n  }\n\n  const table: GeoJSONTable = {\n    shape: 'geojson-table',\n    type: 'FeatureCollection',\n    features\n  };\n\n  return table;\n}\n*/","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}