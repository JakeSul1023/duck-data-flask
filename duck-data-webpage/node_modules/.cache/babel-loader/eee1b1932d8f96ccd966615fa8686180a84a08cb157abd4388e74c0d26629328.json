{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\nimport { Vector3, Matrix3, Quaternion } from '@math.gl/core';\nimport { BoundingSphere } from \"./bounding-sphere.js\";\nimport { INTERSECTION } from \"../../constants.js\";\nconst scratchVector3 = new Vector3();\nconst scratchOffset = new Vector3();\nconst scratchVectorU = new Vector3();\nconst scratchVectorV = new Vector3();\nconst scratchVectorW = new Vector3();\nconst scratchCorner = new Vector3();\nconst scratchToCenter = new Vector3();\nconst MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\n/**\n * An OrientedBoundingBox of some object is a closed and convex cuboid.\n * It can provide a tighter bounding volume than `BoundingSphere` or\n * `AxisAlignedBoundingBox` in many cases.\n */\nexport class OrientedBoundingBox {\n  constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {\n    this.center = new Vector3().from(center);\n    this.halfAxes = new Matrix3(halfAxes);\n  }\n  /** Returns an array with three halfSizes for the bounding box */\n  get halfSize() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];\n  }\n  /** Returns a quaternion describing the orientation of the bounding box */\n  get quaternion() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    const normXAxis = new Vector3(xAxis).normalize();\n    const normYAxis = new Vector3(yAxis).normalize();\n    const normZAxis = new Vector3(zAxis).normalize();\n    return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));\n  }\n  /**\n   * Create OrientedBoundingBox from quaternion based OBB,\n   */\n  fromCenterHalfSizeQuaternion(center, halfSize, quaternion) {\n    const quaternionObject = new Quaternion(quaternion);\n    const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);\n    directionsMatrix[0] = directionsMatrix[0] * halfSize[0];\n    directionsMatrix[1] = directionsMatrix[1] * halfSize[0];\n    directionsMatrix[2] = directionsMatrix[2] * halfSize[0];\n    directionsMatrix[3] = directionsMatrix[3] * halfSize[1];\n    directionsMatrix[4] = directionsMatrix[4] * halfSize[1];\n    directionsMatrix[5] = directionsMatrix[5] * halfSize[1];\n    directionsMatrix[6] = directionsMatrix[6] * halfSize[2];\n    directionsMatrix[7] = directionsMatrix[7] * halfSize[2];\n    directionsMatrix[8] = directionsMatrix[8] * halfSize[2];\n    this.center = new Vector3().from(center);\n    this.halfAxes = directionsMatrix;\n    return this;\n  }\n  /** Duplicates a OrientedBoundingBox instance. */\n  clone() {\n    return new OrientedBoundingBox(this.center, this.halfAxes);\n  }\n  /** Compares the provided OrientedBoundingBox component wise and returns */\n  equals(right) {\n    return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);\n  }\n  /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */\n  getBoundingSphere(result = new BoundingSphere()) {\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n    // Calculate \"corner\" vector\n    const cornerVector = scratchVector3.copy(u).add(v).add(w);\n    result.center.copy(this.center);\n    result.radius = cornerVector.magnitude();\n    return result;\n  }\n  /** Determines which side of a plane the oriented bounding box is located. */\n  intersectPlane(plane) {\n    const center = this.center;\n    const normal = plane.normal;\n    const halfAxes = this.halfAxes;\n    const normalX = normal.x;\n    const normalY = normal.y;\n    const normalZ = normal.z;\n    // Plane is used as if it is its normal; the first three components are assumed to be normalized\n    const radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);\n    const distanceToPlane = normal.dot(center) + plane.distance;\n    if (distanceToPlane <= -radEffective) {\n      // The entire box is on the negative side of the plane normal\n      return INTERSECTION.OUTSIDE;\n    } else if (distanceToPlane >= radEffective) {\n      // The entire box is on the positive side of the plane normal\n      return INTERSECTION.INSIDE;\n    }\n    return INTERSECTION.INTERSECTING;\n  }\n  /** Computes the estimated distance from the closest point on a bounding box to a point. */\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n  /**\n   * Computes the estimated distance squared from the closest point\n   * on a bounding box to a point.\n   * See Geometric Tools for Computer Graphics 10.4.2\n   */\n  distanceSquaredTo(point) {\n    // Computes the estimated distance squared from the\n    // closest point on a bounding box to a point.\n    // See Geometric Tools for Computer Graphics 10.4.2\n    const offset = scratchOffset.from(point).subtract(this.center);\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n    const uHalf = u.magnitude();\n    const vHalf = v.magnitude();\n    const wHalf = w.magnitude();\n    u.normalize();\n    v.normalize();\n    w.normalize();\n    let distanceSquared = 0.0;\n    let d;\n    d = Math.abs(offset.dot(u)) - uHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n    d = Math.abs(offset.dot(v)) - vHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n    d = Math.abs(offset.dot(w)) - wHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n    return distanceSquared;\n  }\n  /**\n   * The distances calculated by the vector from the center of the bounding box\n   * to position projected onto direction.\n   *\n   * - If you imagine the infinite number of planes with normal direction,\n   *   this computes the smallest distance to the closest and farthest planes\n   *   from `position` that intersect the bounding box.\n   *\n   * @param position The position to calculate the distance from.\n   * @param direction The direction from position.\n   * @param result An Interval (array of length 2) to store the nearest and farthest distances.\n   * @returns Interval (array of length 2) with nearest and farthest distances\n   *   on the bounding box from position in direction.\n   */\n  // eslint-disable-next-line max-statements\n  computePlaneDistances(position, direction, result = [-0, -0]) {\n    let minDist = Number.POSITIVE_INFINITY;\n    let maxDist = Number.NEGATIVE_INFINITY;\n    const center = this.center;\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n    // project first corner\n    const corner = scratchCorner.copy(u).add(v).add(w).add(center);\n    const toCenter = scratchToCenter.copy(corner).subtract(position);\n    let mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    // project second corner\n    corner.copy(center).add(u).add(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    // project third corner\n    corner.copy(center).add(u).subtract(v).add(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    // project fourth corner\n    corner.copy(center).add(u).subtract(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    // project fifth corner\n    center.copy(corner).subtract(u).add(v).add(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    // project sixth corner\n    center.copy(corner).subtract(u).add(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    // project seventh corner\n    center.copy(corner).subtract(u).subtract(v).add(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    // project eighth corner\n    center.copy(corner).subtract(u).subtract(v).subtract(w);\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n    result[0] = minDist;\n    result[1] = maxDist;\n    return result;\n  }\n  /**\n   * Applies a 4x4 affine transformation matrix to a bounding sphere.\n   * @param transform The transformation matrix to apply to the bounding sphere.\n   * @returns itself, i.e. the modified BoundingVolume.\n   */\n  transform(transformation) {\n    this.center.transformAsPoint(transformation);\n    const xAxis = this.halfAxes.getColumn(0, scratchVectorU);\n    xAxis.transformAsPoint(transformation);\n    const yAxis = this.halfAxes.getColumn(1, scratchVectorV);\n    yAxis.transformAsPoint(transformation);\n    const zAxis = this.halfAxes.getColumn(2, scratchVectorW);\n    zAxis.transformAsPoint(transformation);\n    this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);\n    return this;\n  }\n  getTransform() {\n    // const modelMatrix = Matrix4.fromRotationTranslation(this.boundingVolume.halfAxes, this.boundingVolume.center);\n    // return modelMatrix;\n    throw new Error('not implemented');\n  }\n}","map":{"version":3,"names":["Vector3","Matrix3","Quaternion","BoundingSphere","INTERSECTION","scratchVector3","scratchOffset","scratchVectorU","scratchVectorV","scratchVectorW","scratchCorner","scratchToCenter","MATRIX3","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","OrientedBoundingBox","constructor","center","halfAxes","from","halfSize","xAxis","getColumn","yAxis","zAxis","len","quaternion","normXAxis","normalize","normYAxis","normZAxis","fromMatrix3","fromCenterHalfSizeQuaternion","quaternionObject","directionsMatrix","fromQuaternion","clone","equals","right","Boolean","getBoundingSphere","result","u","v","w","cornerVector","copy","add","radius","magnitude","intersectPlane","plane","normal","normalX","x","normalY","y","normalZ","z","radEffective","Math","abs","distanceToPlane","dot","distance","OUTSIDE","INSIDE","INTERSECTING","distanceTo","point","sqrt","distanceSquaredTo","offset","subtract","uHalf","vHalf","wHalf","distanceSquared","d","computePlaneDistances","position","direction","minDist","Number","POSITIVE_INFINITY","maxDist","NEGATIVE_INFINITY","corner","toCenter","mag","min","max","transform","transformation","transformAsPoint","getTransform","Error"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\culling\\src\\lib\\bounding-volumes\\oriented-bounding-box.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\n\n// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {NumericArray} from '@math.gl/types';\nimport {Vector3, Matrix3, Matrix4, Quaternion} from '@math.gl/core';\nimport type {BoundingVolume} from './bounding-volume';\nimport {BoundingSphere} from './bounding-sphere';\nimport type {Plane} from '../plane';\nimport {INTERSECTION} from '../../constants';\n\nconst scratchVector3 = new Vector3();\nconst scratchOffset = new Vector3();\nconst scratchVectorU = new Vector3();\nconst scratchVectorV = new Vector3();\nconst scratchVectorW = new Vector3();\nconst scratchCorner = new Vector3();\nconst scratchToCenter = new Vector3();\n\nconst MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\n\n/**\n * An OrientedBoundingBox of some object is a closed and convex cuboid.\n * It can provide a tighter bounding volume than `BoundingSphere` or\n * `AxisAlignedBoundingBox` in many cases.\n */\nexport class OrientedBoundingBox implements BoundingVolume {\n  center: Vector3;\n  halfAxes: Matrix3;\n\n  /**\n   * An OrientedBoundingBox of some object is a closed and convex cuboid.\n   * It can provide a tighter bounding volume than\n   * `BoundingSphere` or `AxisAlignedBoundingBox` in many cases.\n   */\n  constructor(center?: Readonly<NumericArray>, halfAxes?: Readonly<NumericArray>);\n  constructor(\n    center: Readonly<NumericArray> = [0, 0, 0],\n    halfAxes: Readonly<NumericArray> = [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  ) {\n    this.center = new Vector3().from(center);\n    this.halfAxes = new Matrix3(halfAxes);\n  }\n\n  /** Returns an array with three halfSizes for the bounding box */\n  get halfSize(): number[] {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];\n  }\n\n  /** Returns a quaternion describing the orientation of the bounding box */\n  get quaternion(): Quaternion {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    const normXAxis = new Vector3(xAxis).normalize();\n    const normYAxis = new Vector3(yAxis).normalize();\n    const normZAxis = new Vector3(zAxis).normalize();\n    return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));\n  }\n\n  /**\n   * Create OrientedBoundingBox from quaternion based OBB,\n   */\n  fromCenterHalfSizeQuaternion(\n    center: number[],\n    halfSize: number[],\n    quaternion: number[]\n  ): OrientedBoundingBox {\n    const quaternionObject = new Quaternion(quaternion);\n    const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);\n    directionsMatrix[0] = directionsMatrix[0] * halfSize[0];\n    directionsMatrix[1] = directionsMatrix[1] * halfSize[0];\n    directionsMatrix[2] = directionsMatrix[2] * halfSize[0];\n    directionsMatrix[3] = directionsMatrix[3] * halfSize[1];\n    directionsMatrix[4] = directionsMatrix[4] * halfSize[1];\n    directionsMatrix[5] = directionsMatrix[5] * halfSize[1];\n    directionsMatrix[6] = directionsMatrix[6] * halfSize[2];\n    directionsMatrix[7] = directionsMatrix[7] * halfSize[2];\n    directionsMatrix[8] = directionsMatrix[8] * halfSize[2];\n    this.center = new Vector3().from(center);\n    this.halfAxes = directionsMatrix;\n    return this;\n  }\n\n  /** Duplicates a OrientedBoundingBox instance. */\n  clone(): OrientedBoundingBox {\n    return new OrientedBoundingBox(this.center, this.halfAxes);\n  }\n\n  /** Compares the provided OrientedBoundingBox component wise and returns */\n  equals(right: OrientedBoundingBox): boolean {\n    return (\n      this === right ||\n      (Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes))\n    );\n  }\n\n  /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */\n  getBoundingSphere(result = new BoundingSphere()): BoundingSphere {\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    // Calculate \"corner\" vector\n    const cornerVector = scratchVector3.copy(u).add(v).add(w);\n\n    result.center.copy(this.center);\n    result.radius = cornerVector.magnitude();\n\n    return result;\n  }\n\n  /** Determines which side of a plane the oriented bounding box is located. */\n  intersectPlane(plane: Plane): number {\n    const center = this.center;\n    const normal = plane.normal;\n    const halfAxes = this.halfAxes;\n\n    const normalX = normal.x;\n    const normalY = normal.y;\n    const normalZ = normal.z;\n\n    // Plane is used as if it is its normal; the first three components are assumed to be normalized\n    const radEffective =\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN0ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN0ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN0ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN1ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN1ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN1ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN2ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN2ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN2ROW2]\n      );\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    if (distanceToPlane <= -radEffective) {\n      // The entire box is on the negative side of the plane normal\n      return INTERSECTION.OUTSIDE;\n    } else if (distanceToPlane >= radEffective) {\n      // The entire box is on the positive side of the plane normal\n      return INTERSECTION.INSIDE;\n    }\n    return INTERSECTION.INTERSECTING;\n  }\n\n  /** Computes the estimated distance from the closest point on a bounding box to a point. */\n  distanceTo(point: readonly number[]): number {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  /**\n   * Computes the estimated distance squared from the closest point\n   * on a bounding box to a point.\n   * See Geometric Tools for Computer Graphics 10.4.2\n   */\n  distanceSquaredTo(point: readonly number[]): number {\n    // Computes the estimated distance squared from the\n    // closest point on a bounding box to a point.\n    // See Geometric Tools for Computer Graphics 10.4.2\n    const offset = scratchOffset.from(point).subtract(this.center);\n\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    const uHalf = u.magnitude();\n    const vHalf = v.magnitude();\n    const wHalf = w.magnitude();\n\n    u.normalize();\n    v.normalize();\n    w.normalize();\n\n    let distanceSquared = 0.0;\n    let d;\n\n    d = Math.abs(offset.dot(u)) - uHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(v)) - vHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(w)) - wHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n\n  /**\n   * The distances calculated by the vector from the center of the bounding box\n   * to position projected onto direction.\n   *\n   * - If you imagine the infinite number of planes with normal direction,\n   *   this computes the smallest distance to the closest and farthest planes\n   *   from `position` that intersect the bounding box.\n   *\n   * @param position The position to calculate the distance from.\n   * @param direction The direction from position.\n   * @param result An Interval (array of length 2) to store the nearest and farthest distances.\n   * @returns Interval (array of length 2) with nearest and farthest distances\n   *   on the bounding box from position in direction.\n   */\n  // eslint-disable-next-line max-statements\n  computePlaneDistances(\n    position: readonly number[],\n    direction: Vector3,\n    result: number[] = [-0, -0]\n  ): number[] {\n    let minDist = Number.POSITIVE_INFINITY;\n    let maxDist = Number.NEGATIVE_INFINITY;\n\n    const center = this.center;\n    const halfAxes = this.halfAxes;\n\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    // project first corner\n    const corner = scratchCorner.copy(u).add(v).add(w).add(center);\n\n    const toCenter = scratchToCenter.copy(corner).subtract(position);\n    let mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project second corner\n    corner.copy(center).add(u).add(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project third corner\n    corner.copy(center).add(u).subtract(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fourth corner\n    corner.copy(center).add(u).subtract(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fifth corner\n    center.copy(corner).subtract(u).add(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project sixth corner\n    center.copy(corner).subtract(u).add(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project seventh corner\n    center.copy(corner).subtract(u).subtract(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project eighth corner\n    center.copy(corner).subtract(u).subtract(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    result[0] = minDist;\n    result[1] = maxDist;\n    return result;\n  }\n\n  /**\n   * Applies a 4x4 affine transformation matrix to a bounding sphere.\n   * @param transform The transformation matrix to apply to the bounding sphere.\n   * @returns itself, i.e. the modified BoundingVolume.\n   */\n  transform(transformation: readonly number[]): this {\n    this.center.transformAsPoint(transformation);\n\n    const xAxis = this.halfAxes.getColumn(0, scratchVectorU);\n    xAxis.transformAsPoint(transformation);\n\n    const yAxis = this.halfAxes.getColumn(1, scratchVectorV);\n    yAxis.transformAsPoint(transformation);\n\n    const zAxis = this.halfAxes.getColumn(2, scratchVectorW);\n    zAxis.transformAsPoint(transformation);\n\n    this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);\n    return this;\n  }\n\n  getTransform(): Matrix4 {\n    // const modelMatrix = Matrix4.fromRotationTranslation(this.boundingVolume.halfAxes, this.boundingVolume.center);\n    // return modelMatrix;\n    throw new Error('not implemented');\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}