{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { WebMercatorViewport, OrthographicViewport } from '@deck.gl/core';\n/*\n * Compute the union of bounds from multiple layers\n * Returns bounds in CARTESIAN coordinates\n */\nexport function joinLayerBounds(/** The layers to combine */\nlayers, /** A Viewport instance that is used to determine the type of the view */\nviewport) {\n  // Join the bounds of layer data\n  const bounds = [Infinity, Infinity, -Infinity, -Infinity];\n  for (const layer of layers) {\n    const layerBounds = layer.getBounds();\n    if (layerBounds) {\n      const bottomLeftCommon = layer.projectPosition(layerBounds[0], {\n        viewport,\n        autoOffset: false\n      });\n      const topRightCommon = layer.projectPosition(layerBounds[1], {\n        viewport,\n        autoOffset: false\n      });\n      bounds[0] = Math.min(bounds[0], bottomLeftCommon[0]);\n      bounds[1] = Math.min(bounds[1], bottomLeftCommon[1]);\n      bounds[2] = Math.max(bounds[2], topRightCommon[0]);\n      bounds[3] = Math.max(bounds[3], topRightCommon[1]);\n    }\n  }\n  if (Number.isFinite(bounds[0])) {\n    return bounds;\n  }\n  return null;\n}\nconst MAX_VIEWPORT_SIZE = 2048;\n/** Construct a viewport that just covers the target bounds. Used for rendering to common space indexed texture. */\nexport function makeViewport(opts) {\n  const {\n    bounds,\n    viewport,\n    border = 0\n  } = opts;\n  const {\n    isGeospatial\n  } = viewport;\n  if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {\n    return null;\n  }\n  const centerWorld = viewport.unprojectPosition([(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2, 0]);\n  let {\n    width,\n    height,\n    zoom\n  } = opts;\n  if (zoom === undefined) {\n    // Use width and height to determine zoom\n    width = width - border * 2;\n    height = height - border * 2;\n    const scale = Math.min(width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));\n    zoom = Math.min(Math.log2(scale), 20);\n  } else if (!width || !height) {\n    // Use zoom to determine width and height\n    const scale = 2 ** zoom;\n    width = Math.round(Math.abs(bounds[2] - bounds[0]) * scale);\n    height = Math.round(Math.abs(bounds[3] - bounds[1]) * scale);\n    const maxSize = MAX_VIEWPORT_SIZE - border * 2;\n    if (width > maxSize || height > maxSize) {\n      const r = maxSize / Math.max(width, height);\n      width = Math.round(width * r);\n      height = Math.round(height * r);\n      zoom += Math.log2(r);\n    }\n  }\n  // TODO - find a more generic way to construct this viewport\n  // Geospatial viewports may not be web-mercator\n  return isGeospatial ? new WebMercatorViewport({\n    id: viewport.id,\n    x: border,\n    y: border,\n    width,\n    height,\n    longitude: centerWorld[0],\n    latitude: centerWorld[1],\n    zoom,\n    orthographic: true\n  }) : new OrthographicViewport({\n    id: viewport.id,\n    x: border,\n    y: border,\n    width,\n    height,\n    target: centerWorld,\n    zoom,\n    flipY: false\n  });\n}\n/** Returns viewport bounds in CARTESIAN coordinates */\nexport function getViewportBounds(viewport, zRange) {\n  // Viewport bounds in world coordinates\n  let viewportBoundsWorld;\n  if (zRange && zRange.length === 2) {\n    const [minZ, maxZ] = zRange;\n    const bounds0 = viewport.getBounds({\n      z: minZ\n    });\n    const bounds1 = viewport.getBounds({\n      z: maxZ\n    });\n    viewportBoundsWorld = [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];\n  } else {\n    viewportBoundsWorld = viewport.getBounds();\n  }\n  // Viewport bounds in cartesian coordinates\n  const viewportBottomLeftCommon = viewport.projectPosition(viewportBoundsWorld.slice(0, 2));\n  const viewportTopRightCommon = viewport.projectPosition(viewportBoundsWorld.slice(2, 4));\n  return [viewportBottomLeftCommon[0], viewportBottomLeftCommon[1], viewportTopRightCommon[0], viewportTopRightCommon[1]];\n}\n/*\n * Determine the common space bounds that best cover the given data for the given viewport\n * Returns bounds in CARTESIAN coordinates\n */\nexport function getRenderBounds(layerBounds, viewport, zRange) {\n  if (!layerBounds) {\n    return [0, 0, 1, 1];\n  }\n  const viewportBounds = getViewportBounds(viewport, zRange);\n  // Expand viewport bounds by 2X. Heurestically chosen to avoid masking\n  // errors when mask is partially out of view\n  const paddedBounds = doubleBounds(viewportBounds);\n  // When bounds of the layers are smaller than the viewport bounds simply use\n  // mask bounds, so as to maximize resolution & avoid rerenders\n  if (layerBounds[2] - layerBounds[0] <= paddedBounds[2] - paddedBounds[0] && layerBounds[3] - layerBounds[1] <= paddedBounds[3] - paddedBounds[1]) {\n    return layerBounds;\n  }\n  // As viewport shrinks, to avoid pixelation along mask edges\n  // we need to reduce the bounds and only render the visible portion\n  // of the mask.\n  // We pad the viewport bounds to capture the section\n  // of the mask just outside the viewport to correctly maskByInstance.\n  // Intersect mask & padded viewport bounds\n  return [Math.max(layerBounds[0], paddedBounds[0]), Math.max(layerBounds[1], paddedBounds[1]), Math.min(layerBounds[2], paddedBounds[2]), Math.min(layerBounds[3], paddedBounds[3])];\n}\nfunction doubleBounds(bounds) {\n  const dx = bounds[2] - bounds[0];\n  const dy = bounds[3] - bounds[1];\n  const centerX = (bounds[0] + bounds[2]) / 2;\n  const centerY = (bounds[1] + bounds[3]) / 2;\n  return [centerX - dx, centerY - dy, centerX + dx, centerY + dy];\n}","map":{"version":3,"names":["WebMercatorViewport","OrthographicViewport","joinLayerBounds","layers","viewport","bounds","Infinity","layer","layerBounds","getBounds","bottomLeftCommon","projectPosition","autoOffset","topRightCommon","Math","min","max","Number","isFinite","MAX_VIEWPORT_SIZE","makeViewport","opts","border","isGeospatial","centerWorld","unprojectPosition","width","height","zoom","undefined","scale","log2","round","abs","maxSize","r","id","x","y","longitude","latitude","orthographic","target","flipY","getViewportBounds","zRange","viewportBoundsWorld","length","minZ","maxZ","bounds0","z","bounds1","viewportBottomLeftCommon","slice","viewportTopRightCommon","getRenderBounds","viewportBounds","paddedBounds","doubleBounds","dx","dy","centerX","centerY"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\extensions\\src\\utils\\projection-utils.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {WebMercatorViewport, OrthographicViewport} from '@deck.gl/core';\nimport type {Layer, Viewport} from '@deck.gl/core';\n\n/** Bounds in CARTESIAN coordinates */\nexport type Bounds = [minX: number, minY: number, maxX: number, maxY: number];\n\n/*\n * Compute the union of bounds from multiple layers\n * Returns bounds in CARTESIAN coordinates\n */\nexport function joinLayerBounds(\n  /** The layers to combine */\n  layers: Layer[],\n  /** A Viewport instance that is used to determine the type of the view */\n  viewport: Viewport\n): Bounds | null {\n  // Join the bounds of layer data\n  const bounds: Bounds = [Infinity, Infinity, -Infinity, -Infinity];\n  for (const layer of layers) {\n    const layerBounds = layer.getBounds();\n    if (layerBounds) {\n      const bottomLeftCommon = layer.projectPosition(layerBounds[0], {viewport, autoOffset: false});\n      const topRightCommon = layer.projectPosition(layerBounds[1], {viewport, autoOffset: false});\n\n      bounds[0] = Math.min(bounds[0], bottomLeftCommon[0]);\n      bounds[1] = Math.min(bounds[1], bottomLeftCommon[1]);\n      bounds[2] = Math.max(bounds[2], topRightCommon[0]);\n      bounds[3] = Math.max(bounds[3], topRightCommon[1]);\n    }\n  }\n\n  if (Number.isFinite(bounds[0])) {\n    return bounds;\n  }\n  return null;\n}\n\nconst MAX_VIEWPORT_SIZE = 2048;\n\n/** Construct a viewport that just covers the target bounds. Used for rendering to common space indexed texture. */\nexport function makeViewport(opts: {\n  /** The cartesian bounds of layers that will render into this texture */\n  bounds: Bounds;\n  /** Target width. If not specified, will be deduced from zoom */\n  width?: number;\n  /** Target height. If not specified, will be deduced from zoom */\n  height?: number;\n  /** Target zoom. If not specified, will be deduced from width and height */\n  zoom?: number;\n  /** Border around the viewport in pixels */\n  border?: number;\n  /** A viewport used to determine the output type */\n  viewport: Viewport;\n}): Viewport | null {\n  const {bounds, viewport, border = 0} = opts;\n  const {isGeospatial} = viewport;\n\n  if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {\n    return null;\n  }\n\n  const centerWorld = viewport.unprojectPosition([\n    (bounds[0] + bounds[2]) / 2,\n    (bounds[1] + bounds[3]) / 2,\n    0\n  ]);\n\n  let {width, height, zoom} = opts;\n  if (zoom === undefined) {\n    // Use width and height to determine zoom\n    width = width! - border * 2;\n    height = height! - border * 2;\n    const scale = Math.min(width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));\n    zoom = Math.min(Math.log2(scale), 20);\n  } else if (!width || !height) {\n    // Use zoom to determine width and height\n    const scale = 2 ** zoom;\n    width = Math.round(Math.abs(bounds[2] - bounds[0]) * scale);\n    height = Math.round(Math.abs(bounds[3] - bounds[1]) * scale);\n    const maxSize = MAX_VIEWPORT_SIZE - border * 2;\n    if (width > maxSize || height > maxSize) {\n      const r = maxSize / Math.max(width, height);\n      width = Math.round(width * r);\n      height = Math.round(height * r);\n      zoom += Math.log2(r);\n    }\n  }\n\n  // TODO - find a more generic way to construct this viewport\n  // Geospatial viewports may not be web-mercator\n  return isGeospatial\n    ? new WebMercatorViewport({\n        id: viewport.id,\n        x: border,\n        y: border,\n        width,\n        height,\n        longitude: centerWorld[0],\n        latitude: centerWorld[1],\n        zoom,\n        orthographic: true\n      })\n    : new OrthographicViewport({\n        id: viewport.id,\n        x: border,\n        y: border,\n        width,\n        height,\n        target: centerWorld,\n        zoom,\n        flipY: false\n      });\n}\n\n/** Returns viewport bounds in CARTESIAN coordinates */\nexport function getViewportBounds(viewport: Viewport, zRange?: [number, number]): Bounds {\n  // Viewport bounds in world coordinates\n  let viewportBoundsWorld: Bounds;\n  if (zRange && zRange.length === 2) {\n    const [minZ, maxZ] = zRange;\n    const bounds0 = viewport.getBounds({z: minZ});\n    const bounds1 = viewport.getBounds({z: maxZ});\n    viewportBoundsWorld = [\n      Math.min(bounds0[0], bounds1[0]),\n      Math.min(bounds0[1], bounds1[1]),\n      Math.max(bounds0[2], bounds1[2]),\n      Math.max(bounds0[3], bounds1[3])\n    ];\n  } else {\n    viewportBoundsWorld = viewport.getBounds();\n  }\n\n  // Viewport bounds in cartesian coordinates\n  const viewportBottomLeftCommon = viewport.projectPosition(viewportBoundsWorld.slice(0, 2));\n  const viewportTopRightCommon = viewport.projectPosition(viewportBoundsWorld.slice(2, 4));\n  return [\n    viewportBottomLeftCommon[0],\n    viewportBottomLeftCommon[1],\n    viewportTopRightCommon[0],\n    viewportTopRightCommon[1]\n  ];\n}\n\n/*\n * Determine the common space bounds that best cover the given data for the given viewport\n * Returns bounds in CARTESIAN coordinates\n */\nexport function getRenderBounds(\n  layerBounds: Bounds,\n  viewport: Viewport,\n  zRange?: [number, number]\n): Bounds {\n  if (!layerBounds) {\n    return [0, 0, 1, 1];\n  }\n\n  const viewportBounds = getViewportBounds(viewport, zRange);\n  // Expand viewport bounds by 2X. Heurestically chosen to avoid masking\n  // errors when mask is partially out of view\n  const paddedBounds = doubleBounds(viewportBounds);\n\n  // When bounds of the layers are smaller than the viewport bounds simply use\n  // mask bounds, so as to maximize resolution & avoid rerenders\n  if (\n    layerBounds[2] - layerBounds[0] <= paddedBounds[2] - paddedBounds[0] &&\n    layerBounds[3] - layerBounds[1] <= paddedBounds[3] - paddedBounds[1]\n  ) {\n    return layerBounds;\n  }\n\n  // As viewport shrinks, to avoid pixelation along mask edges\n  // we need to reduce the bounds and only render the visible portion\n  // of the mask.\n  // We pad the viewport bounds to capture the section\n  // of the mask just outside the viewport to correctly maskByInstance.\n  // Intersect mask & padded viewport bounds\n  return [\n    Math.max(layerBounds[0], paddedBounds[0]),\n    Math.max(layerBounds[1], paddedBounds[1]),\n    Math.min(layerBounds[2], paddedBounds[2]),\n    Math.min(layerBounds[3], paddedBounds[3])\n  ];\n}\n\nfunction doubleBounds(bounds: Bounds): Bounds {\n  const dx = bounds[2] - bounds[0];\n  const dy = bounds[3] - bounds[1];\n  const centerX = (bounds[0] + bounds[2]) / 2;\n  const centerY = (bounds[1] + bounds[3]) / 2;\n  return [centerX - dx, centerY - dy, centerX + dx, centerY + dy];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}