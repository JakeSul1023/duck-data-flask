{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getTypedArrayFromDataType, getDataTypeFromTypedArray } from '@luma.gl/core';\nexport function typedArrayFromDataType(type) {\n  // Sorted in some order of likelihood to reduce amount of comparisons\n  switch (type) {\n    case 'float64':\n      return Float64Array;\n    case 'uint8':\n    case 'unorm8':\n      return Uint8ClampedArray;\n    default:\n      return getTypedArrayFromDataType(type);\n  }\n}\nexport const dataTypeFromTypedArray = getDataTypeFromTypedArray;\nexport function getBufferAttributeLayout(name, accessor, deviceType) {\n  // TODO(ibgreen): WebGPU change. Currently we always use normalized 8 bit integers\n  const type = deviceType === 'webgpu' && accessor.type === 'uint8' ? 'unorm8' : accessor.type;\n  return {\n    attribute: name,\n    // @ts-expect-error Not all combinations are valid vertex formats; it's up to DataColumn to ensure\n    format: accessor.size > 1 ? `${type}x${accessor.size}` : accessor.type,\n    byteOffset: accessor.offset || 0\n    // Note stride is set on the top level\n  };\n}\nexport function getStride(accessor) {\n  return accessor.stride || accessor.size * accessor.bytesPerElement;\n}\nexport function bufferLayoutEqual(accessor1, accessor2) {\n  return accessor1.type === accessor2.type && accessor1.size === accessor2.size && getStride(accessor1) === getStride(accessor2) && (accessor1.offset || 0) === (accessor2.offset || 0);\n}\n//# sourceMappingURL=gl-utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}