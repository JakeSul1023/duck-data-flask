{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT and Apache-2.0\n// Copyright (c) vis.gl contributors\nimport { Vector3 } from '@math.gl/core';\nimport { INTERSECTION } from \"../../constants.js\";\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\n/**\n * An axis aligned bounding box - aligned with coordinate axes\n * @see BoundingVolume\n * @see BoundingRectangle\n * @see OrientedBoundingBox\n */\nexport class AxisAlignedBoundingBox {\n  /**\n   * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n   * @param minimum=[0, 0, 0] The minimum point along the x, y, and z axes.\n   * @param maximum=[0, 0, 0] The maximum point along the x, y, and z axes.\n   * @param center The center of the box; automatically computed if not supplied.\n   */\n  constructor() {\n    let minimum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];\n    let maximum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n    let center = arguments.length > 2 ? arguments[2] : undefined;\n    // If center was not defined, compute it.\n    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);\n    this.center = new Vector3(center);\n    this.halfDiagonal = new Vector3(maximum).subtract(this.center);\n    /**\n     * The minimum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.minimum = new Vector3(minimum);\n    /**\n     * The maximum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.maximum = new Vector3(maximum);\n  }\n  /**\n   * Duplicates a AxisAlignedBoundingBox instance.\n   *\n   * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.\n   */\n  clone() {\n    return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n  }\n  /**\n   * Compares the provided AxisAlignedBoundingBox componentwise and returns\n   * <code>true</code> if they are equal, <code>false</code> otherwise.\n   *\n   * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.\n   * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n   */\n  equals(right) {\n    return this === right || Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);\n  }\n  /**\n   * Applies a 4x4 affine transformation matrix to a bounding sphere.\n   * @param transform The transformation matrix to apply to the bounding sphere.\n   * @returns itself, i.e. the modified BoundingVolume.\n   */\n  transform(transform) {\n    this.center.transformAsPoint(transform);\n    // TODO - this.halfDiagonal.transformAsVector(transform);\n    this.halfDiagonal.transform(transform);\n    this.minimum.transform(transform);\n    this.maximum.transform(transform);\n    return this;\n  }\n  /**\n   * Determines which side of a plane a box is located.\n   */\n  intersectPlane(plane) {\n    const {\n      halfDiagonal\n    } = this;\n    const normal = scratchNormal.from(plane.normal);\n    const e = halfDiagonal.x * Math.abs(normal.x) + halfDiagonal.y * Math.abs(normal.y) + halfDiagonal.z * Math.abs(normal.z);\n    const s = this.center.dot(normal) + plane.distance; // signed distance from center\n    if (s - e > 0) {\n      return INTERSECTION.INSIDE;\n    }\n    if (s + e < 0) {\n      // Not in front because normals point inward\n      return INTERSECTION.OUTSIDE;\n    }\n    return INTERSECTION.INTERSECTING;\n  }\n  /** Computes the estimated distance from the closest point on a bounding box to a point. */\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n  /** Computes the estimated distance squared from the closest point on a bounding box to a point. */\n  distanceSquaredTo(point) {\n    const offset = scratchVector.from(point).subtract(this.center);\n    const {\n      halfDiagonal\n    } = this;\n    let distanceSquared = 0.0;\n    let d;\n    d = Math.abs(offset.x) - halfDiagonal.x;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n    d = Math.abs(offset.y) - halfDiagonal.y;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n    d = Math.abs(offset.z) - halfDiagonal.z;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n    return distanceSquared;\n  }\n}\n//# sourceMappingURL=axis-aligned-bounding-box.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}