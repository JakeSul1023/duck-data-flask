{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Framebuffer } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\nimport { getDepthStencilAttachmentWebGL } from \"../converters/webgl-texture-table.js\";\n/** luma.gl Framebuffer, WebGL implementation  */\nexport class WEBGLFramebuffer extends Framebuffer {\n  device;\n  gl;\n  handle;\n  colorAttachments = [];\n  depthStencilAttachment = null;\n  constructor(device, props) {\n    super(device, props);\n    // WebGL default framebuffer handle is null\n    const isDefaultFramebuffer = props.handle === null;\n    this.device = device;\n    this.gl = device.gl;\n    this.handle = this.props.handle || isDefaultFramebuffer ? this.props.handle : this.gl.createFramebuffer();\n    if (!isDefaultFramebuffer) {\n      // default framebuffer handle is null, so we can't set spector metadata...\n      device.setSpectorMetadata(this.handle, {\n        id: this.props.id,\n        props: this.props\n      });\n      // Auto create textures for attachments if needed\n      this.autoCreateAttachmentTextures();\n      this.updateAttachments();\n    }\n  }\n  /** destroys any auto created resources etc. */\n  destroy() {\n    super.destroy(); // destroys owned resources etc.\n    if (!this.destroyed && this.handle !== null) {\n      this.gl.deleteFramebuffer(this.handle);\n      // this.handle = null;\n    }\n  }\n  updateAttachments() {\n    /** Attach from a map of attachments */\n    // @ts-expect-error native bindFramebuffer is overridden by our state tracker\n    const prevHandle = this.gl.bindFramebuffer(36160, this.handle);\n    // Walk the attachments\n    for (let i = 0; i < this.colorAttachments.length; ++i) {\n      const attachment = this.colorAttachments[i];\n      if (attachment) {\n        const attachmentPoint = 36064 + i;\n        this._attachTextureView(attachmentPoint, attachment);\n      }\n    }\n    if (this.depthStencilAttachment) {\n      const attachmentPoint = getDepthStencilAttachmentWebGL(this.depthStencilAttachment.props.format);\n      this._attachTextureView(attachmentPoint, this.depthStencilAttachment);\n    }\n    /** Check the status */\n    if (this.device.props.debug) {\n      const status = this.gl.checkFramebufferStatus(36160);\n      if (status !== 36053) {\n        throw new Error(`Framebuffer ${_getFrameBufferStatus(status)}`);\n      }\n    }\n    this.gl.bindFramebuffer(36160, prevHandle);\n  }\n  // PRIVATE\n  /** In WebGL we must use renderbuffers for depth/stencil attachments (unless we have extensions) */\n  // protected override createDepthStencilTexture(format: TextureFormat): Texture {\n  //   // return new WEBGLRenderbuffer(this.device, {\n  //   return new WEBGLTexture(this.device, {\n  //     id: `${this.id}-depth-stencil`,\n  //     format,\n  //     width: this.width,\n  //     height: this.height,\n  //     mipmaps: false\n  //   });\n  // }\n  /**\n   * @param attachment\n   * @param texture\n   * @param layer = 0 - index into WEBGLTextureArray and Texture3D or face for `TextureCubeMap`\n   * @param level = 0 - mipmapLevel\n   */\n  _attachTextureView(attachment, textureView) {\n    const {\n      gl\n    } = this.device;\n    const {\n      texture\n    } = textureView;\n    const level = textureView.props.baseMipLevel;\n    const layer = textureView.props.baseArrayLayer;\n    gl.bindTexture(texture.glTarget, texture.handle);\n    switch (texture.glTarget) {\n      case 35866:\n      case 32879:\n        gl.framebufferTextureLayer(36160, attachment, texture.handle, level, layer);\n        break;\n      case 34067:\n        // layer must be a cubemap face (or if index, converted to cube map face)\n        const face = mapIndexToCubeMapFace(layer);\n        gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);\n        break;\n      case 3553:\n        gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);\n        break;\n      default:\n        throw new Error('Illegal texture type');\n    }\n    gl.bindTexture(texture.glTarget, null);\n  }\n}\n// Helper functions\n// Map an index to a cube map face constant\nfunction mapIndexToCubeMapFace(layer) {\n  // TEXTURE_CUBE_MAP_POSITIVE_X is a big value (0x8515)\n  // if smaller assume layer is index, otherwise assume it is already a cube map face constant\n  return layer < 34069 ? layer + 34069 : layer;\n}\n// Helper METHODS\n// Get a string describing the framebuffer error if installed\nfunction _getFrameBufferStatus(status) {\n  switch (status) {\n    case 36053:\n      return 'success';\n    case 36054:\n      return 'Mismatched attachments';\n    case 36055:\n      return 'No attachments';\n    case 36057:\n      return 'Height/width mismatch';\n    case 36061:\n      return 'Unsupported or split attachments';\n    // WebGL2\n    case 36182:\n      return 'Samples mismatch';\n    // OVR_multiview2 extension\n    // case GL.FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR: return 'baseViewIndex mismatch';\n    default:\n      return `${status}`;\n  }\n}\n/**\n * Attachment resize is expected to be a noop if size is same\n *\nprotected override resizeAttachments(width: number, height: number): this {\n  // for default framebuffer, just update the stored size\n  if (this.handle === null) {\n    // assert(width === undefined && height === undefined);\n    this.width = this.gl.drawingBufferWidth;\n    this.height = this.gl.drawingBufferHeight;\n    return this;\n  }\n\n  if (width === undefined) {\n    width = this.gl.drawingBufferWidth;\n  }\n  if (height === undefined) {\n    height = this.gl.drawingBufferHeight;\n  }\n\n  // TODO Not clear that this is better than default destroy/create implementation\n\n  for (const colorAttachment of this.colorAttachments) {\n    colorAttachment.texture.clone({width, height});\n  }\n  if (this.depthStencilAttachment) {\n    this.depthStencilAttachment.texture.resize({width, height});\n  }\n  return this;\n}\n*/\n//# sourceMappingURL=webgl-framebuffer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}