{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Buffer } from \"../adapter/resources/buffer.js\";\nimport { log } from \"../utils/log.js\";\nimport { UniformBlock } from \"./uniform-block.js\";\nimport { UniformBufferLayout } from \"./uniform-buffer-layout.js\";\n/**\n * A uniform store holds a uniform values for one or more uniform blocks,\n * - It can generate binary data for any uniform buffer\n * - It can manage a uniform buffer for each block\n * - It can update managed uniform buffers with a single call\n * - It performs some book keeping on what has changed to minimize unnecessary writes to uniform buffers.\n */\nexport class UniformStore {\n  /** Stores the uniform values for each uniform block */\n  uniformBlocks = new Map();\n  /** Can generate data for a uniform buffer for each block from data */\n  uniformBufferLayouts = new Map();\n  /** Actual buffer for the blocks */\n  uniformBuffers = new Map();\n  /**\n   * Create a new UniformStore instance\n   * @param blocks\n   */\n  constructor(blocks) {\n    for (const [bufferName, block] of Object.entries(blocks)) {\n      const uniformBufferName = bufferName;\n      // Create a layout object to help us generate correctly formatted binary uniform buffers\n      const uniformBufferLayout = new UniformBufferLayout(block.uniformTypes || {});\n      this.uniformBufferLayouts.set(uniformBufferName, uniformBufferLayout);\n      // Create a Uniform block to store the uniforms for each buffer.\n      const uniformBlock = new UniformBlock({\n        name: bufferName\n      });\n      uniformBlock.setUniforms(block.defaultUniforms || {});\n      this.uniformBlocks.set(uniformBufferName, uniformBlock);\n    }\n  }\n  /** Destroy any managed uniform buffers */\n  destroy() {\n    for (const uniformBuffer of this.uniformBuffers.values()) {\n      uniformBuffer.destroy();\n    }\n  }\n  /**\n   * Set uniforms\n   * Makes all properties partial\n   */\n  setUniforms(uniforms) {\n    for (const [blockName, uniformValues] of Object.entries(uniforms)) {\n      this.uniformBlocks.get(blockName)?.setUniforms(uniformValues);\n      // We leverage logging in updateUniformBuffers(), even though slightly less efficient\n      // this.updateUniformBuffer(blockName);\n    }\n    this.updateUniformBuffers();\n  }\n  /** Get the required minimum length of the uniform buffer */\n  getUniformBufferByteLength(uniformBufferName) {\n    return this.uniformBufferLayouts.get(uniformBufferName)?.byteLength || 0;\n  }\n  /** Get formatted binary memory that can be uploaded to a buffer */\n  getUniformBufferData(uniformBufferName) {\n    const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms() || {};\n    // @ts-ignore\n    return this.uniformBufferLayouts.get(uniformBufferName)?.getData(uniformValues);\n  }\n  /**\n   * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)\n   * The new buffer is initialized with current / supplied values\n   */\n  createUniformBuffer(device, uniformBufferName, uniforms) {\n    if (uniforms) {\n      this.setUniforms(uniforms);\n    }\n    const byteLength = this.getUniformBufferByteLength(uniformBufferName);\n    const uniformBuffer = device.createBuffer({\n      usage: Buffer.UNIFORM | Buffer.COPY_DST,\n      byteLength\n    });\n    // Note that this clears the needs redraw flag\n    const uniformBufferData = this.getUniformBufferData(uniformBufferName);\n    uniformBuffer.write(uniformBufferData);\n    return uniformBuffer;\n  }\n  /** Get the managed uniform buffer. \"managed\" resources are destroyed when the uniformStore is destroyed. */\n  getManagedUniformBuffer(device, uniformBufferName) {\n    if (!this.uniformBuffers.get(uniformBufferName)) {\n      const byteLength = this.getUniformBufferByteLength(uniformBufferName);\n      const uniformBuffer = device.createBuffer({\n        usage: Buffer.UNIFORM | Buffer.COPY_DST,\n        byteLength\n      });\n      this.uniformBuffers.set(uniformBufferName, uniformBuffer);\n    }\n    // this.updateUniformBuffers();\n    // @ts-ignore\n    return this.uniformBuffers.get(uniformBufferName);\n  }\n  /** Updates all uniform buffers where values have changed */\n  updateUniformBuffers() {\n    let reason = false;\n    for (const uniformBufferName of this.uniformBlocks.keys()) {\n      const bufferReason = this.updateUniformBuffer(uniformBufferName);\n      reason ||= bufferReason;\n    }\n    if (reason) {\n      log.log(3, `UniformStore.updateUniformBuffers(): ${reason}`)();\n    }\n    return reason;\n  }\n  /** Update one uniform buffer. Only updates if values have changed */\n  updateUniformBuffer(uniformBufferName) {\n    const uniformBlock = this.uniformBlocks.get(uniformBufferName);\n    let uniformBuffer = this.uniformBuffers.get(uniformBufferName);\n    let reason = false;\n    if (uniformBuffer && uniformBlock?.needsRedraw) {\n      reason ||= uniformBlock.needsRedraw;\n      // This clears the needs redraw flag\n      const uniformBufferData = this.getUniformBufferData(uniformBufferName);\n      uniformBuffer = this.uniformBuffers.get(uniformBufferName);\n      uniformBuffer?.write(uniformBufferData);\n      // logging - TODO - don't query the values unnecessarily\n      const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms();\n      log.log(4, `Writing to uniform buffer ${String(uniformBufferName)}`, uniformBufferData, uniformValues)();\n    }\n    return reason;\n  }\n}","map":{"version":3,"names":["Buffer","log","UniformBlock","UniformBufferLayout","UniformStore","uniformBlocks","Map","uniformBufferLayouts","uniformBuffers","constructor","blocks","bufferName","block","Object","entries","uniformBufferName","uniformBufferLayout","uniformTypes","set","uniformBlock","name","setUniforms","defaultUniforms","destroy","uniformBuffer","values","uniforms","blockName","uniformValues","get","updateUniformBuffers","getUniformBufferByteLength","byteLength","getUniformBufferData","getAllUniforms","getData","createUniformBuffer","device","createBuffer","usage","UNIFORM","COPY_DST","uniformBufferData","write","getManagedUniformBuffer","reason","keys","bufferReason","updateUniformBuffer","needsRedraw","String"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\core\\src\\portable\\uniform-store.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderUniformType} from '../gpu-type-utils/shader-types';\nimport type {UniformValue} from '../adapter/types/uniforms';\nimport type {Device} from '../adapter/device';\nimport {Buffer} from '../adapter/resources/buffer';\nimport {log} from '../utils/log';\nimport {UniformBlock} from './uniform-block';\nimport {UniformBufferLayout} from './uniform-buffer-layout';\n\n/**\n * A uniform store holds a uniform values for one or more uniform blocks,\n * - It can generate binary data for any uniform buffer\n * - It can manage a uniform buffer for each block\n * - It can update managed uniform buffers with a single call\n * - It performs some book keeping on what has changed to minimize unnecessary writes to uniform buffers.\n */\nexport class UniformStore<\n  TPropGroups extends Record<string, Record<string, unknown>> = Record<\n    string,\n    Record<string, unknown>\n  >\n> {\n  /** Stores the uniform values for each uniform block */\n  uniformBlocks = new Map<keyof TPropGroups, UniformBlock>();\n  /** Can generate data for a uniform buffer for each block from data */\n  uniformBufferLayouts = new Map<keyof TPropGroups, UniformBufferLayout>();\n  /** Actual buffer for the blocks */\n  uniformBuffers = new Map<keyof TPropGroups, Buffer>();\n\n  /**\n   * Create a new UniformStore instance\n   * @param blocks\n   */\n  constructor(\n    blocks: Record<\n      keyof TPropGroups,\n      {\n        uniformTypes?: Record<string, ShaderUniformType>;\n        defaultProps?: Record<string, unknown>;\n        defaultUniforms?: Record<string, UniformValue>;\n      }\n    >\n  ) {\n    for (const [bufferName, block] of Object.entries(blocks)) {\n      const uniformBufferName = bufferName as keyof TPropGroups;\n\n      // Create a layout object to help us generate correctly formatted binary uniform buffers\n      const uniformBufferLayout = new UniformBufferLayout(block.uniformTypes || {});\n      this.uniformBufferLayouts.set(uniformBufferName, uniformBufferLayout);\n\n      // Create a Uniform block to store the uniforms for each buffer.\n      const uniformBlock = new UniformBlock({name: bufferName});\n      uniformBlock.setUniforms(block.defaultUniforms || {});\n      this.uniformBlocks.set(uniformBufferName, uniformBlock);\n    }\n  }\n\n  /** Destroy any managed uniform buffers */\n  destroy(): void {\n    for (const uniformBuffer of this.uniformBuffers.values()) {\n      uniformBuffer.destroy();\n    }\n  }\n\n  /**\n   * Set uniforms\n   * Makes all properties partial\n   */\n  setUniforms(\n    uniforms: Partial<{[group in keyof TPropGroups]: Partial<TPropGroups[group]>}>\n  ): void {\n    for (const [blockName, uniformValues] of Object.entries(uniforms)) {\n      this.uniformBlocks.get(blockName)?.setUniforms(uniformValues);\n      // We leverage logging in updateUniformBuffers(), even though slightly less efficient\n      // this.updateUniformBuffer(blockName);\n    }\n\n    this.updateUniformBuffers();\n  }\n\n  /** Get the required minimum length of the uniform buffer */\n  getUniformBufferByteLength(uniformBufferName: keyof TPropGroups): number {\n    return this.uniformBufferLayouts.get(uniformBufferName)?.byteLength || 0;\n  }\n\n  /** Get formatted binary memory that can be uploaded to a buffer */\n  getUniformBufferData(uniformBufferName: keyof TPropGroups): Uint8Array {\n    const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms() || {};\n    // @ts-ignore\n    return this.uniformBufferLayouts.get(uniformBufferName)?.getData(uniformValues);\n  }\n\n  /**\n   * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)\n   * The new buffer is initialized with current / supplied values\n   */\n  createUniformBuffer(\n    device: Device,\n    uniformBufferName: keyof TPropGroups,\n    uniforms?: Partial<{[group in keyof TPropGroups]: Partial<TPropGroups[group]>}>\n  ): Buffer {\n    if (uniforms) {\n      this.setUniforms(uniforms);\n    }\n    const byteLength = this.getUniformBufferByteLength(uniformBufferName);\n    const uniformBuffer = device.createBuffer({\n      usage: Buffer.UNIFORM | Buffer.COPY_DST,\n      byteLength\n    });\n    // Note that this clears the needs redraw flag\n    const uniformBufferData = this.getUniformBufferData(uniformBufferName);\n    uniformBuffer.write(uniformBufferData);\n    return uniformBuffer;\n  }\n\n  /** Get the managed uniform buffer. \"managed\" resources are destroyed when the uniformStore is destroyed. */\n  getManagedUniformBuffer(device: Device, uniformBufferName: keyof TPropGroups): Buffer {\n    if (!this.uniformBuffers.get(uniformBufferName)) {\n      const byteLength = this.getUniformBufferByteLength(uniformBufferName);\n      const uniformBuffer = device.createBuffer({\n        usage: Buffer.UNIFORM | Buffer.COPY_DST,\n        byteLength\n      });\n      this.uniformBuffers.set(uniformBufferName, uniformBuffer);\n    }\n    // this.updateUniformBuffers();\n    // @ts-ignore\n    return this.uniformBuffers.get(uniformBufferName);\n  }\n\n  /** Updates all uniform buffers where values have changed */\n  updateUniformBuffers(): false | string {\n    let reason: false | string = false;\n    for (const uniformBufferName of this.uniformBlocks.keys()) {\n      const bufferReason = this.updateUniformBuffer(uniformBufferName);\n      reason ||= bufferReason;\n    }\n    if (reason) {\n      log.log(3, `UniformStore.updateUniformBuffers(): ${reason}`)();\n    }\n    return reason;\n  }\n\n  /** Update one uniform buffer. Only updates if values have changed */\n  updateUniformBuffer(uniformBufferName: keyof TPropGroups): false | string {\n    const uniformBlock = this.uniformBlocks.get(uniformBufferName);\n    let uniformBuffer = this.uniformBuffers.get(uniformBufferName);\n\n    let reason: false | string = false;\n    if (uniformBuffer && uniformBlock?.needsRedraw) {\n      reason ||= uniformBlock.needsRedraw;\n      // This clears the needs redraw flag\n      const uniformBufferData = this.getUniformBufferData(uniformBufferName);\n\n      uniformBuffer = this.uniformBuffers.get(uniformBufferName);\n      uniformBuffer?.write(uniformBufferData);\n\n      // logging - TODO - don't query the values unnecessarily\n      const uniformValues = this.uniformBlocks.get(uniformBufferName)?.getAllUniforms();\n      log.log(\n        4,\n        `Writing to uniform buffer ${String(uniformBufferName)}`,\n        uniformBufferData,\n        uniformValues\n      )();\n    }\n    return reason;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}