{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { EVENT_HANDLERS } from \"./constants.js\";\nimport { deepEqual } from \"../utils/deep-equal.js\";\nconst PLACEMENTS = {\n  'top-left': {\n    top: 0,\n    left: 0\n  },\n  'top-right': {\n    top: 0,\n    right: 0\n  },\n  'bottom-left': {\n    bottom: 0,\n    left: 0\n  },\n  'bottom-right': {\n    bottom: 0,\n    right: 0\n  },\n  fill: {\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0\n  }\n};\nconst DEFAULT_PLACEMENT = 'top-left';\nconst ROOT_CONTAINER_ID = '__root';\nexport class WidgetManager {\n  constructor({\n    deck,\n    parentElement\n  }) {\n    /** Widgets added via the imperative API */\n    this.defaultWidgets = [];\n    /** Widgets received from the declarative API */\n    this.widgets = [];\n    /** Resolved widgets from both imperative and declarative APIs */\n    this.resolvedWidgets = [];\n    /** Mounted HTML containers */\n    this.containers = {};\n    /** Viewport provided to widget on redraw */\n    this.lastViewports = {};\n    this.deck = deck;\n    this.parentElement = parentElement;\n  }\n  getWidgets() {\n    return this.resolvedWidgets;\n  }\n  /** Declarative API to configure widgets */\n  setProps(props) {\n    if (props.widgets && !deepEqual(props.widgets, this.widgets, 1)) {\n      this._setWidgets(props.widgets);\n    }\n  }\n  finalize() {\n    for (const widget of this.getWidgets()) {\n      this._remove(widget);\n    }\n    this.defaultWidgets.length = 0;\n    this.resolvedWidgets.length = 0;\n    for (const id in this.containers) {\n      this.containers[id].remove();\n    }\n  }\n  /** Imperative API. Widgets added this way are not affected by the declarative prop. */\n  addDefault(widget) {\n    if (!this.defaultWidgets.find(w => w.id === widget.id)) {\n      this._add(widget);\n      this.defaultWidgets.push(widget);\n      // Update widget list\n      this._setWidgets(this.widgets);\n    }\n  }\n  /** Resolve widgets from the declarative prop */\n  _setWidgets(nextWidgets) {\n    const oldWidgetMap = {};\n    for (const widget of this.resolvedWidgets) {\n      oldWidgetMap[widget.id] = widget;\n    }\n    // Clear and rebuild the list\n    this.resolvedWidgets.length = 0;\n    // Add all default widgets\n    for (const widget of this.defaultWidgets) {\n      oldWidgetMap[widget.id] = null;\n      this.resolvedWidgets.push(widget);\n    }\n    for (let widget of nextWidgets) {\n      const oldWidget = oldWidgetMap[widget.id];\n      if (!oldWidget) {\n        // Widget is new\n        this._add(widget);\n      } else if (\n      // Widget placement changed\n      oldWidget.viewId !== widget.viewId || oldWidget.placement !== widget.placement) {\n        this._remove(oldWidget);\n        this._add(widget);\n      } else if (widget !== oldWidget) {\n        // Widget props changed\n        oldWidget.setProps(widget.props);\n        widget = oldWidget;\n      }\n      // mark as matched\n      oldWidgetMap[widget.id] = null;\n      this.resolvedWidgets.push(widget);\n    }\n    for (const id in oldWidgetMap) {\n      const oldWidget = oldWidgetMap[id];\n      if (oldWidget) {\n        // No longer exists\n        this._remove(oldWidget);\n      }\n    }\n    this.widgets = nextWidgets;\n  }\n  _add(widget) {\n    const {\n      viewId = null,\n      placement = DEFAULT_PLACEMENT\n    } = widget;\n    const element = widget.onAdd({\n      deck: this.deck,\n      viewId\n    });\n    if (element) {\n      this._getContainer(viewId, placement).append(element);\n    }\n    widget._element = element;\n  }\n  _remove(widget) {\n    widget.onRemove?.();\n    if (widget._element) {\n      widget._element.remove();\n    }\n    widget._element = undefined;\n  }\n  /* global document */\n  _getContainer(viewId, placement) {\n    const containerId = viewId || ROOT_CONTAINER_ID;\n    let viewContainer = this.containers[containerId];\n    if (!viewContainer) {\n      viewContainer = document.createElement('div');\n      viewContainer.style.pointerEvents = 'none';\n      viewContainer.style.position = 'absolute';\n      viewContainer.style.overflow = 'hidden';\n      this.parentElement?.append(viewContainer);\n      this.containers[containerId] = viewContainer;\n    }\n    let container = viewContainer.querySelector(`.${placement}`);\n    if (!container) {\n      container = document.createElement('div');\n      container.className = placement;\n      container.style.position = 'absolute';\n      container.style.zIndex = '2';\n      Object.assign(container.style, PLACEMENTS[placement]);\n      viewContainer.append(container);\n    }\n    return container;\n  }\n  _updateContainers() {\n    const canvasWidth = this.deck.width;\n    const canvasHeight = this.deck.height;\n    for (const id in this.containers) {\n      const viewport = this.lastViewports[id] || null;\n      const visible = id === ROOT_CONTAINER_ID || viewport;\n      const container = this.containers[id];\n      if (visible) {\n        container.style.display = 'block';\n        // Align the container with the view\n        container.style.left = `${viewport ? viewport.x : 0}px`;\n        container.style.top = `${viewport ? viewport.y : 0}px`;\n        container.style.width = `${viewport ? viewport.width : canvasWidth}px`;\n        container.style.height = `${viewport ? viewport.height : canvasHeight}px`;\n      } else {\n        container.style.display = 'none';\n      }\n    }\n  }\n  onRedraw({\n    viewports,\n    layers\n  }) {\n    const viewportsById = viewports.reduce((acc, v) => {\n      acc[v.id] = v;\n      return acc;\n    }, {});\n    for (const widget of this.getWidgets()) {\n      const {\n        viewId\n      } = widget;\n      if (viewId) {\n        // Attached to a specific view\n        const viewport = viewportsById[viewId];\n        if (viewport) {\n          if (widget.onViewportChange) {\n            widget.onViewportChange(viewport);\n          }\n          widget.onRedraw?.({\n            viewports: [viewport],\n            layers\n          });\n        }\n      } else {\n        // Not attached to a specific view\n        if (widget.onViewportChange) {\n          for (const viewport of viewports) {\n            widget.onViewportChange(viewport);\n          }\n        }\n        widget.onRedraw?.({\n          viewports,\n          layers\n        });\n      }\n    }\n    this.lastViewports = viewportsById;\n    this._updateContainers();\n  }\n  onHover(info, event) {\n    for (const widget of this.getWidgets()) {\n      const {\n        viewId\n      } = widget;\n      if (!viewId || viewId === info.viewport?.id) {\n        widget.onHover?.(info, event);\n      }\n    }\n  }\n  onEvent(info, event) {\n    const eventHandlerProp = EVENT_HANDLERS[event.type];\n    if (!eventHandlerProp) {\n      return;\n    }\n    for (const widget of this.getWidgets()) {\n      const {\n        viewId\n      } = widget;\n      if (!viewId || viewId === info.viewport?.id) {\n        widget[eventHandlerProp]?.(info, event);\n      }\n    }\n  }\n}","map":{"version":3,"names":["EVENT_HANDLERS","deepEqual","PLACEMENTS","top","left","right","bottom","fill","DEFAULT_PLACEMENT","ROOT_CONTAINER_ID","WidgetManager","constructor","deck","parentElement","defaultWidgets","widgets","resolvedWidgets","containers","lastViewports","getWidgets","setProps","props","_setWidgets","finalize","widget","_remove","length","id","remove","addDefault","find","w","_add","push","nextWidgets","oldWidgetMap","oldWidget","viewId","placement","element","onAdd","_getContainer","append","_element","onRemove","undefined","containerId","viewContainer","document","createElement","style","pointerEvents","position","overflow","container","querySelector","className","zIndex","Object","assign","_updateContainers","canvasWidth","width","canvasHeight","height","viewport","visible","display","x","y","onRedraw","viewports","layers","viewportsById","reduce","acc","v","onViewportChange","onHover","info","event","onEvent","eventHandlerProp","type"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\lib\\widget-manager.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type Deck from './deck';\nimport type Viewport from '../viewports/viewport';\nimport type {PickingInfo} from './picking/pick-info';\nimport type {MjolnirPointerEvent, MjolnirGestureEvent} from 'mjolnir.js';\nimport type Layer from './layer';\n\nimport {EVENT_HANDLERS} from './constants';\nimport {deepEqual} from '../utils/deep-equal';\n\nexport interface Widget<PropsT = any> {\n  /** Unique identifier of the widget. */\n  id: string;\n  /** Widget prop types. */\n  props: PropsT;\n  /**\n   * The view id that this widget is being attached to. Default `null`.\n   * If assigned, this widget will only respond to events occurred inside the specific view that matches this id.\n   */\n  viewId?: string | null;\n  /** Widget positioning within the view. Default 'top-left'. */\n  placement?: WidgetPlacement;\n\n  // Populated by core when mounted\n  _element?: HTMLDivElement | null;\n\n  // Lifecycle hooks\n  /** Called when the widget is added to a Deck instance.\n   * @returns an optional UI element that should be appended to the Deck container */\n  onAdd: (params: {\n    /** The Deck instance that the widget is attached to */\n    deck: Deck<any>;\n    /** The id of the view that the widget is attached to */\n    viewId: string | null;\n  }) => HTMLDivElement | null;\n  /** Called when the widget is removed */\n  onRemove?: () => void;\n  /** Called to update widget options */\n  setProps: (props: Partial<PropsT>) => void;\n\n  // Optional event hooks\n  /** Called when the containing view is changed */\n  onViewportChange?: (viewport: Viewport) => void;\n  /** Called when the containing view is redrawn */\n  onRedraw?: (params: {viewports: Viewport[]; layers: Layer[]}) => void;\n  /** Called when a hover event occurs */\n  onHover?: (info: PickingInfo, event: MjolnirPointerEvent) => void;\n  /** Called when a click event occurs */\n  onClick?: (info: PickingInfo, event: MjolnirGestureEvent) => void;\n  /** Called when a drag event occurs */\n  onDrag?: (info: PickingInfo, event: MjolnirGestureEvent) => void;\n  /** Called when a dragstart event occurs */\n  onDragStart?: (info: PickingInfo, event: MjolnirGestureEvent) => void;\n  /** Called when a dragend event occurs */\n  onDragEnd?: (info: PickingInfo, event: MjolnirGestureEvent) => void;\n}\n\nconst PLACEMENTS = {\n  'top-left': {top: 0, left: 0},\n  'top-right': {top: 0, right: 0},\n  'bottom-left': {bottom: 0, left: 0},\n  'bottom-right': {bottom: 0, right: 0},\n  fill: {top: 0, left: 0, bottom: 0, right: 0}\n} as const;\nconst DEFAULT_PLACEMENT = 'top-left';\n\nexport type WidgetPlacement = keyof typeof PLACEMENTS;\n\nconst ROOT_CONTAINER_ID = '__root';\n\nexport class WidgetManager {\n  deck: Deck<any>;\n  parentElement?: HTMLElement | null;\n\n  /** Widgets added via the imperative API */\n  private defaultWidgets: Widget[] = [];\n  /** Widgets received from the declarative API */\n  private widgets: Widget[] = [];\n  /** Resolved widgets from both imperative and declarative APIs */\n  private resolvedWidgets: Widget[] = [];\n\n  /** Mounted HTML containers */\n  private containers: {[id: string]: HTMLDivElement} = {};\n  /** Viewport provided to widget on redraw */\n  private lastViewports: {[id: string]: Viewport} = {};\n\n  constructor({deck, parentElement}: {deck: Deck<any>; parentElement?: HTMLElement | null}) {\n    this.deck = deck;\n    this.parentElement = parentElement;\n  }\n\n  getWidgets(): Widget[] {\n    return this.resolvedWidgets;\n  }\n\n  /** Declarative API to configure widgets */\n  setProps(props: {widgets?: Widget[]}) {\n    if (props.widgets && !deepEqual(props.widgets, this.widgets, 1)) {\n      this._setWidgets(props.widgets);\n    }\n  }\n\n  finalize() {\n    for (const widget of this.getWidgets()) {\n      this._remove(widget);\n    }\n    this.defaultWidgets.length = 0;\n    this.resolvedWidgets.length = 0;\n    for (const id in this.containers) {\n      this.containers[id].remove();\n    }\n  }\n\n  /** Imperative API. Widgets added this way are not affected by the declarative prop. */\n  addDefault(widget: Widget) {\n    if (!this.defaultWidgets.find(w => w.id === widget.id)) {\n      this._add(widget);\n      this.defaultWidgets.push(widget);\n      // Update widget list\n      this._setWidgets(this.widgets);\n    }\n  }\n\n  /** Resolve widgets from the declarative prop */\n  private _setWidgets(nextWidgets: Widget[]) {\n    const oldWidgetMap: Record<string, Widget | null> = {};\n\n    for (const widget of this.resolvedWidgets) {\n      oldWidgetMap[widget.id] = widget;\n    }\n    // Clear and rebuild the list\n    this.resolvedWidgets.length = 0;\n\n    // Add all default widgets\n    for (const widget of this.defaultWidgets) {\n      oldWidgetMap[widget.id] = null;\n      this.resolvedWidgets.push(widget);\n    }\n\n    for (let widget of nextWidgets) {\n      const oldWidget = oldWidgetMap[widget.id];\n      if (!oldWidget) {\n        // Widget is new\n        this._add(widget);\n      } else if (\n        // Widget placement changed\n        oldWidget.viewId !== widget.viewId ||\n        oldWidget.placement !== widget.placement\n      ) {\n        this._remove(oldWidget);\n        this._add(widget);\n      } else if (widget !== oldWidget) {\n        // Widget props changed\n        oldWidget.setProps(widget.props);\n        widget = oldWidget;\n      }\n\n      // mark as matched\n      oldWidgetMap[widget.id] = null;\n      this.resolvedWidgets.push(widget);\n    }\n\n    for (const id in oldWidgetMap) {\n      const oldWidget = oldWidgetMap[id];\n      if (oldWidget) {\n        // No longer exists\n        this._remove(oldWidget);\n      }\n    }\n    this.widgets = nextWidgets;\n  }\n\n  private _add(widget: Widget) {\n    const {viewId = null, placement = DEFAULT_PLACEMENT} = widget;\n    const element = widget.onAdd({deck: this.deck, viewId});\n\n    if (element) {\n      this._getContainer(viewId, placement).append(element);\n    }\n    widget._element = element;\n  }\n\n  private _remove(widget: Widget) {\n    widget.onRemove?.();\n\n    if (widget._element) {\n      widget._element.remove();\n    }\n    widget._element = undefined;\n  }\n\n  /* global document */\n  private _getContainer(viewId: string | null, placement: WidgetPlacement): HTMLDivElement {\n    const containerId = viewId || ROOT_CONTAINER_ID;\n    let viewContainer = this.containers[containerId];\n    if (!viewContainer) {\n      viewContainer = document.createElement('div');\n      viewContainer.style.pointerEvents = 'none';\n      viewContainer.style.position = 'absolute';\n      viewContainer.style.overflow = 'hidden';\n      this.parentElement?.append(viewContainer);\n      this.containers[containerId] = viewContainer;\n    }\n    let container = viewContainer.querySelector<HTMLDivElement>(`.${placement}`);\n    if (!container) {\n      container = document.createElement('div');\n      container.className = placement;\n      container.style.position = 'absolute';\n      container.style.zIndex = '2';\n      Object.assign(container.style, PLACEMENTS[placement]);\n      viewContainer.append(container);\n    }\n    return container;\n  }\n\n  private _updateContainers() {\n    const canvasWidth = this.deck.width;\n    const canvasHeight = this.deck.height;\n    for (const id in this.containers) {\n      const viewport = this.lastViewports[id] || null;\n      const visible = id === ROOT_CONTAINER_ID || viewport;\n\n      const container = this.containers[id];\n      if (visible) {\n        container.style.display = 'block';\n        // Align the container with the view\n        container.style.left = `${viewport ? viewport.x : 0}px`;\n        container.style.top = `${viewport ? viewport.y : 0}px`;\n        container.style.width = `${viewport ? viewport.width : canvasWidth}px`;\n        container.style.height = `${viewport ? viewport.height : canvasHeight}px`;\n      } else {\n        container.style.display = 'none';\n      }\n    }\n  }\n\n  onRedraw({viewports, layers}: {viewports: Viewport[]; layers: Layer[]}) {\n    const viewportsById: {[id: string]: Viewport} = viewports.reduce((acc, v) => {\n      acc[v.id] = v;\n      return acc;\n    }, {});\n\n    for (const widget of this.getWidgets()) {\n      const {viewId} = widget;\n      if (viewId) {\n        // Attached to a specific view\n        const viewport = viewportsById[viewId];\n        if (viewport) {\n          if (widget.onViewportChange) {\n            widget.onViewportChange(viewport);\n          }\n          widget.onRedraw?.({viewports: [viewport], layers});\n        }\n      } else {\n        // Not attached to a specific view\n        if (widget.onViewportChange) {\n          for (const viewport of viewports) {\n            widget.onViewportChange(viewport);\n          }\n        }\n        widget.onRedraw?.({viewports, layers});\n      }\n    }\n    this.lastViewports = viewportsById;\n    this._updateContainers();\n  }\n\n  onHover(info: PickingInfo, event: MjolnirPointerEvent) {\n    for (const widget of this.getWidgets()) {\n      const {viewId} = widget;\n      if (!viewId || viewId === info.viewport?.id) {\n        widget.onHover?.(info, event);\n      }\n    }\n  }\n\n  onEvent(info: PickingInfo, event: MjolnirGestureEvent) {\n    const eventHandlerProp = EVENT_HANDLERS[event.type];\n    if (!eventHandlerProp) {\n      return;\n    }\n    for (const widget of this.getWidgets()) {\n      const {viewId} = widget;\n      if (!viewId || viewId === info.viewport?.id) {\n        widget[eventHandlerProp]?.(info, event);\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}