{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { IJToST, STToUV, FaceUVToXYZ, XYZToLngLat } from \"../s2geometry/s2-geometry.js\";\nconst MAX_RESOLUTION = 100;\n/**\n * Get a polygon with corner coordinates for an S2 cell\n * @param s2cell {S2Cell} S2 cell\n * @return {Float64Array} - a simple polygon in flat array format: [lng0, lat0, lng1, lat1, ...]\n *   - the polygon is closed, i.e. last coordinate is a copy of the first coordinate\n */\n// eslint-disable-next-line max-statements\nexport function getS2BoundaryFlatFromS2Cell(s2cell) {\n  const {\n    face,\n    ij,\n    level\n  } = s2cell;\n  const offsets = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];\n  // The S2 cell edge is curved: http://s2geometry.io/\n  // This is more prominent at lower levels\n  // resolution is the number of segments to generate per edge.\n  // We exponentially reduce resolution as level increases so it doesn't affect perf\n  // when there are a large number of cells\n  const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));\n  const result = new Float64Array(4 * resolution * 2 + 2);\n  let ptIndex = 0;\n  let prevLng = 0;\n  for (let i = 0; i < 4; i++) {\n    const offset = offsets[i].slice(0);\n    const nextOffset = offsets[i + 1];\n    const stepI = (nextOffset[0] - offset[0]) / resolution;\n    const stepJ = (nextOffset[1] - offset[1]) / resolution;\n    for (let j = 0; j < resolution; j++) {\n      offset[0] += stepI;\n      offset[1] += stepJ;\n      // Cell can be represented by coordinates IJ, ST, UV, XYZ\n      // http://s2geometry.io/devguide/s2cell_hierarchy#coordinate-systems\n      const st = IJToST(ij, level, offset);\n      const uv = STToUV(st);\n      const xyz = FaceUVToXYZ(face, uv);\n      const lngLat = XYZToLngLat(xyz);\n      // Adjust longitude for Web Mercator projection\n      if (Math.abs(lngLat[1]) > 89.999) {\n        lngLat[0] = prevLng;\n      }\n      const deltaLng = lngLat[0] - prevLng;\n      lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;\n      result[ptIndex++] = lngLat[0];\n      result[ptIndex++] = lngLat[1];\n      prevLng = lngLat[0];\n    }\n  }\n  // close the loop\n  result[ptIndex++] = result[0];\n  result[ptIndex++] = result[1];\n  return result;\n}","map":{"version":3,"names":["IJToST","STToUV","FaceUVToXYZ","XYZToLngLat","MAX_RESOLUTION","getS2BoundaryFlatFromS2Cell","s2cell","face","ij","level","offsets","resolution","Math","max","ceil","pow","result","Float64Array","ptIndex","prevLng","i","offset","slice","nextOffset","stepI","stepJ","j","st","uv","xyz","lngLat","abs","deltaLng"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/converters/s2-to-boundary.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { IJToST, STToUV, FaceUVToXYZ, XYZToLngLat } from \"../s2geometry/s2-geometry.js\";\nconst MAX_RESOLUTION = 100;\n/**\n * Get a polygon with corner coordinates for an S2 cell\n * @param s2cell {S2Cell} S2 cell\n * @return {Float64Array} - a simple polygon in flat array format: [lng0, lat0, lng1, lat1, ...]\n *   - the polygon is closed, i.e. last coordinate is a copy of the first coordinate\n */\n// eslint-disable-next-line max-statements\nexport function getS2BoundaryFlatFromS2Cell(s2cell) {\n    const { face, ij, level } = s2cell;\n    const offsets = [\n        [0, 0],\n        [0, 1],\n        [1, 1],\n        [1, 0],\n        [0, 0]\n    ];\n    // The S2 cell edge is curved: http://s2geometry.io/\n    // This is more prominent at lower levels\n    // resolution is the number of segments to generate per edge.\n    // We exponentially reduce resolution as level increases so it doesn't affect perf\n    // when there are a large number of cells\n    const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));\n    const result = new Float64Array(4 * resolution * 2 + 2);\n    let ptIndex = 0;\n    let prevLng = 0;\n    for (let i = 0; i < 4; i++) {\n        const offset = offsets[i].slice(0);\n        const nextOffset = offsets[i + 1];\n        const stepI = (nextOffset[0] - offset[0]) / resolution;\n        const stepJ = (nextOffset[1] - offset[1]) / resolution;\n        for (let j = 0; j < resolution; j++) {\n            offset[0] += stepI;\n            offset[1] += stepJ;\n            // Cell can be represented by coordinates IJ, ST, UV, XYZ\n            // http://s2geometry.io/devguide/s2cell_hierarchy#coordinate-systems\n            const st = IJToST(ij, level, offset);\n            const uv = STToUV(st);\n            const xyz = FaceUVToXYZ(face, uv);\n            const lngLat = XYZToLngLat(xyz);\n            // Adjust longitude for Web Mercator projection\n            if (Math.abs(lngLat[1]) > 89.999) {\n                lngLat[0] = prevLng;\n            }\n            const deltaLng = lngLat[0] - prevLng;\n            lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;\n            result[ptIndex++] = lngLat[0];\n            result[ptIndex++] = lngLat[1];\n            prevLng = lngLat[0];\n        }\n    }\n    // close the loop\n    result[ptIndex++] = result[0];\n    result[ptIndex++] = result[1];\n    return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}