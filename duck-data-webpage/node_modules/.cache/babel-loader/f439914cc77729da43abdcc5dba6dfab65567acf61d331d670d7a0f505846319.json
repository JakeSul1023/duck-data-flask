{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { compareArrayBuffers, path, log } from '@loaders.gl/loader-utils';\nimport { normalizeLoader } from \"../loader-utils/normalize-loader.js\";\nimport { getResourceUrl, getResourceMIMEType } from \"../utils/resource-utils.js\";\nimport { compareMIMETypes } from \"../utils/mime-type-utils.js\";\nimport { getRegisteredLoaders } from \"./register-loaders.js\";\nimport { isBlob } from \"../../javascript-utils/is-type.js\";\nimport { stripQueryString } from \"../utils/url-utils.js\";\nconst EXT_PATTERN = /\\.([^.]+)$/;\n// TODO - Need a variant that peeks at streams for parseInBatches\n// TODO - Detect multiple matching loaders? Use heuristics to grade matches?\n// TODO - Allow apps to pass context to disambiguate between multiple matches (e.g. multiple .json formats)?\n/**\n * Find a loader that matches file extension and/or initial file content\n * Search the loaders array argument for a loader that matches url extension or initial data\n * Returns: a normalized loader\n * @param data data to assist\n * @param loaders\n * @param options\n * @param context used internally, applications should not provide this parameter\n */\nexport async function selectLoader(data, loaders = [], options, context) {\n  if (!validHTTPResponse(data)) {\n    return null;\n  }\n  // First make a sync attempt, disabling exceptions\n  let loader = selectLoaderSync(data, loaders, {\n    ...options,\n    nothrow: true\n  }, context);\n  if (loader) {\n    return loader;\n  }\n  // For Blobs and Files, try to asynchronously read a small initial slice and test again with that\n  // to see if we can detect by initial content\n  if (isBlob(data)) {\n    data = await data.slice(0, 10).arrayBuffer();\n    loader = selectLoaderSync(data, loaders, options, context);\n  }\n  // no loader available\n  if (!loader && !options?.nothrow) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n  return loader;\n}\n/**\n * Find a loader that matches file extension and/or initial file content\n * Search the loaders array argument for a loader that matches url extension or initial data\n * Returns: a normalized loader\n * @param data data to assist\n * @param loaders\n * @param options\n * @param context used internally, applications should not provide this parameter\n */\nexport function selectLoaderSync(data, loaders = [], options, context) {\n  if (!validHTTPResponse(data)) {\n    return null;\n  }\n  // eslint-disable-next-line complexity\n  // if only a single loader was provided (not as array), force its use\n  // TODO - Should this behavior be kept and documented?\n  if (loaders && !Array.isArray(loaders)) {\n    // TODO - remove support for legacy loaders\n    return normalizeLoader(loaders);\n  }\n  // Build list of candidate loaders that will be searched in order for a match\n  let candidateLoaders = [];\n  // First search supplied loaders\n  if (loaders) {\n    candidateLoaders = candidateLoaders.concat(loaders);\n  }\n  // Then fall back to registered loaders\n  if (!options?.ignoreRegisteredLoaders) {\n    candidateLoaders.push(...getRegisteredLoaders());\n  }\n  // TODO - remove support for legacy loaders\n  normalizeLoaders(candidateLoaders);\n  const loader = selectLoaderInternal(data, candidateLoaders, options, context);\n  // no loader available\n  if (!loader && !options?.nothrow) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n  return loader;\n}\n/** Implements loaders selection logic */\n// eslint-disable-next-line complexity\nfunction selectLoaderInternal(data, loaders, options, context) {\n  const url = getResourceUrl(data);\n  const type = getResourceMIMEType(data);\n  const testUrl = stripQueryString(url) || context?.url;\n  let loader = null;\n  let reason = '';\n  // if options.mimeType is supplied, it takes precedence\n  if (options?.mimeType) {\n    loader = findLoaderByMIMEType(loaders, options?.mimeType);\n    reason = `match forced by supplied MIME type ${options?.mimeType}`;\n  }\n  // Look up loader by url\n  loader = loader || findLoaderByUrl(loaders, testUrl);\n  reason = reason || (loader ? `matched url ${testUrl}` : '');\n  // Look up loader by mime type\n  loader = loader || findLoaderByMIMEType(loaders, type);\n  reason = reason || (loader ? `matched MIME type ${type}` : '');\n  // Look for loader via initial bytes (Note: not always accessible (e.g. Response, stream, async iterator)\n  // @ts-ignore Blob | Response\n  loader = loader || findLoaderByInitialBytes(loaders, data);\n  // @ts-ignore Blob | Response\n  reason = reason || (loader ? `matched initial data ${getFirstCharacters(data)}` : '');\n  // Look up loader by fallback mime type\n  if (options?.fallbackMimeType) {\n    loader = loader || findLoaderByMIMEType(loaders, options?.fallbackMimeType);\n    reason = reason || (loader ? `matched fallback MIME type ${type}` : '');\n  }\n  if (reason) {\n    log.log(1, `selectLoader selected ${loader?.name}: ${reason}.`);\n  }\n  return loader;\n}\n/** Check HTTP Response */\nfunction validHTTPResponse(data) {\n  // HANDLE HTTP status\n  if (data instanceof Response) {\n    // 204 - NO CONTENT. This handles cases where e.g. a tile server responds with 204 for a missing tile\n    if (data.status === 204) {\n      return false;\n    }\n  }\n  return true;\n}\n/** Generate a helpful message to help explain why loader selection failed. */\nfunction getNoValidLoaderMessage(data) {\n  const url = getResourceUrl(data);\n  const type = getResourceMIMEType(data);\n  let message = 'No valid loader found (';\n  message += url ? `${path.filename(url)}, ` : 'no url provided, ';\n  message += `MIME type: ${type ? `\"${type}\"` : 'not provided'}, `;\n  // First characters are only accessible when called on data (string or arrayBuffer).\n  // @ts-ignore Blob | Response\n  const firstCharacters = data ? getFirstCharacters(data) : '';\n  message += firstCharacters ? ` first bytes: \"${firstCharacters}\"` : 'first bytes: not available';\n  message += ')';\n  return message;\n}\nfunction normalizeLoaders(loaders) {\n  for (const loader of loaders) {\n    normalizeLoader(loader);\n  }\n}\n// TODO - Would be nice to support http://example.com/file.glb?parameter=1\n// E.g: x = new URL('http://example.com/file.glb?load=1'; x.pathname\nfunction findLoaderByUrl(loaders, url) {\n  // Get extension\n  const match = url && EXT_PATTERN.exec(url);\n  const extension = match && match[1];\n  return extension ? findLoaderByExtension(loaders, extension) : null;\n}\nfunction findLoaderByExtension(loaders, extension) {\n  extension = extension.toLowerCase();\n  for (const loader of loaders) {\n    for (const loaderExtension of loader.extensions) {\n      if (loaderExtension.toLowerCase() === extension) {\n        return loader;\n      }\n    }\n  }\n  return null;\n}\nfunction findLoaderByMIMEType(loaders, mimeType) {\n  for (const loader of loaders) {\n    if (loader.mimeTypes?.some(mimeType1 => compareMIMETypes(mimeType, mimeType1))) {\n      return loader;\n    }\n    // Support referring to loaders using the \"unregistered tree\"\n    // https://en.wikipedia.org/wiki/Media_type#Unregistered_tree\n    if (compareMIMETypes(mimeType, `application/x.${loader.id}`)) {\n      return loader;\n    }\n  }\n  return null;\n}\nfunction findLoaderByInitialBytes(loaders, data) {\n  if (!data) {\n    return null;\n  }\n  for (const loader of loaders) {\n    if (typeof data === 'string') {\n      if (testDataAgainstText(data, loader)) {\n        return loader;\n      }\n    } else if (ArrayBuffer.isView(data)) {\n      // Typed Arrays can have offsets into underlying buffer\n      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {\n        return loader;\n      }\n    } else if (data instanceof ArrayBuffer) {\n      const byteOffset = 0;\n      if (testDataAgainstBinary(data, byteOffset, loader)) {\n        return loader;\n      }\n    }\n    // TODO Handle streaming case (requires creating a new AsyncIterator)\n  }\n  return null;\n}\nfunction testDataAgainstText(data, loader) {\n  if (loader.testText) {\n    return loader.testText(data);\n  }\n  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some(test => data.startsWith(test));\n}\nfunction testDataAgainstBinary(data, byteOffset, loader) {\n  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some(test => testBinary(data, byteOffset, loader, test));\n}\nfunction testBinary(data, byteOffset, loader, test) {\n  if (test instanceof ArrayBuffer) {\n    return compareArrayBuffers(test, data, test.byteLength);\n  }\n  switch (typeof test) {\n    case 'function':\n      return test(data);\n    case 'string':\n      // Magic bytes check: If `test` is a string, check if binary data starts with that strings\n      const magic = getMagicString(data, byteOffset, test.length);\n      return test === magic;\n    default:\n      return false;\n  }\n}\nfunction getFirstCharacters(data, length = 5) {\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    // Typed Arrays can have offsets into underlying buffer\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n  return '';\n}\nfunction getMagicString(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength < byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}","map":{"version":3,"names":["compareArrayBuffers","path","log","normalizeLoader","getResourceUrl","getResourceMIMEType","compareMIMETypes","getRegisteredLoaders","isBlob","stripQueryString","EXT_PATTERN","selectLoader","data","loaders","options","context","validHTTPResponse","loader","selectLoaderSync","nothrow","slice","arrayBuffer","Error","getNoValidLoaderMessage","Array","isArray","candidateLoaders","concat","ignoreRegisteredLoaders","push","normalizeLoaders","selectLoaderInternal","url","type","testUrl","reason","mimeType","findLoaderByMIMEType","findLoaderByUrl","findLoaderByInitialBytes","getFirstCharacters","fallbackMimeType","name","Response","status","message","filename","firstCharacters","match","exec","extension","findLoaderByExtension","toLowerCase","loaderExtension","extensions","mimeTypes","some","mimeType1","id","testDataAgainstText","ArrayBuffer","isView","testDataAgainstBinary","buffer","byteOffset","testText","tests","test","startsWith","testBinary","byteLength","magic","getMagicString","length","dataView","DataView","i","String","fromCharCode","getUint8"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/core/dist/lib/api/select-loader.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { compareArrayBuffers, path, log } from '@loaders.gl/loader-utils';\nimport { normalizeLoader } from \"../loader-utils/normalize-loader.js\";\nimport { getResourceUrl, getResourceMIMEType } from \"../utils/resource-utils.js\";\nimport { compareMIMETypes } from \"../utils/mime-type-utils.js\";\nimport { getRegisteredLoaders } from \"./register-loaders.js\";\nimport { isBlob } from \"../../javascript-utils/is-type.js\";\nimport { stripQueryString } from \"../utils/url-utils.js\";\nconst EXT_PATTERN = /\\.([^.]+)$/;\n// TODO - Need a variant that peeks at streams for parseInBatches\n// TODO - Detect multiple matching loaders? Use heuristics to grade matches?\n// TODO - Allow apps to pass context to disambiguate between multiple matches (e.g. multiple .json formats)?\n/**\n * Find a loader that matches file extension and/or initial file content\n * Search the loaders array argument for a loader that matches url extension or initial data\n * Returns: a normalized loader\n * @param data data to assist\n * @param loaders\n * @param options\n * @param context used internally, applications should not provide this parameter\n */\nexport async function selectLoader(data, loaders = [], options, context) {\n    if (!validHTTPResponse(data)) {\n        return null;\n    }\n    // First make a sync attempt, disabling exceptions\n    let loader = selectLoaderSync(data, loaders, { ...options, nothrow: true }, context);\n    if (loader) {\n        return loader;\n    }\n    // For Blobs and Files, try to asynchronously read a small initial slice and test again with that\n    // to see if we can detect by initial content\n    if (isBlob(data)) {\n        data = await data.slice(0, 10).arrayBuffer();\n        loader = selectLoaderSync(data, loaders, options, context);\n    }\n    // no loader available\n    if (!loader && !options?.nothrow) {\n        throw new Error(getNoValidLoaderMessage(data));\n    }\n    return loader;\n}\n/**\n * Find a loader that matches file extension and/or initial file content\n * Search the loaders array argument for a loader that matches url extension or initial data\n * Returns: a normalized loader\n * @param data data to assist\n * @param loaders\n * @param options\n * @param context used internally, applications should not provide this parameter\n */\nexport function selectLoaderSync(data, loaders = [], options, context) {\n    if (!validHTTPResponse(data)) {\n        return null;\n    }\n    // eslint-disable-next-line complexity\n    // if only a single loader was provided (not as array), force its use\n    // TODO - Should this behavior be kept and documented?\n    if (loaders && !Array.isArray(loaders)) {\n        // TODO - remove support for legacy loaders\n        return normalizeLoader(loaders);\n    }\n    // Build list of candidate loaders that will be searched in order for a match\n    let candidateLoaders = [];\n    // First search supplied loaders\n    if (loaders) {\n        candidateLoaders = candidateLoaders.concat(loaders);\n    }\n    // Then fall back to registered loaders\n    if (!options?.ignoreRegisteredLoaders) {\n        candidateLoaders.push(...getRegisteredLoaders());\n    }\n    // TODO - remove support for legacy loaders\n    normalizeLoaders(candidateLoaders);\n    const loader = selectLoaderInternal(data, candidateLoaders, options, context);\n    // no loader available\n    if (!loader && !options?.nothrow) {\n        throw new Error(getNoValidLoaderMessage(data));\n    }\n    return loader;\n}\n/** Implements loaders selection logic */\n// eslint-disable-next-line complexity\nfunction selectLoaderInternal(data, loaders, options, context) {\n    const url = getResourceUrl(data);\n    const type = getResourceMIMEType(data);\n    const testUrl = stripQueryString(url) || context?.url;\n    let loader = null;\n    let reason = '';\n    // if options.mimeType is supplied, it takes precedence\n    if (options?.mimeType) {\n        loader = findLoaderByMIMEType(loaders, options?.mimeType);\n        reason = `match forced by supplied MIME type ${options?.mimeType}`;\n    }\n    // Look up loader by url\n    loader = loader || findLoaderByUrl(loaders, testUrl);\n    reason = reason || (loader ? `matched url ${testUrl}` : '');\n    // Look up loader by mime type\n    loader = loader || findLoaderByMIMEType(loaders, type);\n    reason = reason || (loader ? `matched MIME type ${type}` : '');\n    // Look for loader via initial bytes (Note: not always accessible (e.g. Response, stream, async iterator)\n    // @ts-ignore Blob | Response\n    loader = loader || findLoaderByInitialBytes(loaders, data);\n    // @ts-ignore Blob | Response\n    reason = reason || (loader ? `matched initial data ${getFirstCharacters(data)}` : '');\n    // Look up loader by fallback mime type\n    if (options?.fallbackMimeType) {\n        loader = loader || findLoaderByMIMEType(loaders, options?.fallbackMimeType);\n        reason = reason || (loader ? `matched fallback MIME type ${type}` : '');\n    }\n    if (reason) {\n        log.log(1, `selectLoader selected ${loader?.name}: ${reason}.`);\n    }\n    return loader;\n}\n/** Check HTTP Response */\nfunction validHTTPResponse(data) {\n    // HANDLE HTTP status\n    if (data instanceof Response) {\n        // 204 - NO CONTENT. This handles cases where e.g. a tile server responds with 204 for a missing tile\n        if (data.status === 204) {\n            return false;\n        }\n    }\n    return true;\n}\n/** Generate a helpful message to help explain why loader selection failed. */\nfunction getNoValidLoaderMessage(data) {\n    const url = getResourceUrl(data);\n    const type = getResourceMIMEType(data);\n    let message = 'No valid loader found (';\n    message += url ? `${path.filename(url)}, ` : 'no url provided, ';\n    message += `MIME type: ${type ? `\"${type}\"` : 'not provided'}, `;\n    // First characters are only accessible when called on data (string or arrayBuffer).\n    // @ts-ignore Blob | Response\n    const firstCharacters = data ? getFirstCharacters(data) : '';\n    message += firstCharacters ? ` first bytes: \"${firstCharacters}\"` : 'first bytes: not available';\n    message += ')';\n    return message;\n}\nfunction normalizeLoaders(loaders) {\n    for (const loader of loaders) {\n        normalizeLoader(loader);\n    }\n}\n// TODO - Would be nice to support http://example.com/file.glb?parameter=1\n// E.g: x = new URL('http://example.com/file.glb?load=1'; x.pathname\nfunction findLoaderByUrl(loaders, url) {\n    // Get extension\n    const match = url && EXT_PATTERN.exec(url);\n    const extension = match && match[1];\n    return extension ? findLoaderByExtension(loaders, extension) : null;\n}\nfunction findLoaderByExtension(loaders, extension) {\n    extension = extension.toLowerCase();\n    for (const loader of loaders) {\n        for (const loaderExtension of loader.extensions) {\n            if (loaderExtension.toLowerCase() === extension) {\n                return loader;\n            }\n        }\n    }\n    return null;\n}\nfunction findLoaderByMIMEType(loaders, mimeType) {\n    for (const loader of loaders) {\n        if (loader.mimeTypes?.some((mimeType1) => compareMIMETypes(mimeType, mimeType1))) {\n            return loader;\n        }\n        // Support referring to loaders using the \"unregistered tree\"\n        // https://en.wikipedia.org/wiki/Media_type#Unregistered_tree\n        if (compareMIMETypes(mimeType, `application/x.${loader.id}`)) {\n            return loader;\n        }\n    }\n    return null;\n}\nfunction findLoaderByInitialBytes(loaders, data) {\n    if (!data) {\n        return null;\n    }\n    for (const loader of loaders) {\n        if (typeof data === 'string') {\n            if (testDataAgainstText(data, loader)) {\n                return loader;\n            }\n        }\n        else if (ArrayBuffer.isView(data)) {\n            // Typed Arrays can have offsets into underlying buffer\n            if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {\n                return loader;\n            }\n        }\n        else if (data instanceof ArrayBuffer) {\n            const byteOffset = 0;\n            if (testDataAgainstBinary(data, byteOffset, loader)) {\n                return loader;\n            }\n        }\n        // TODO Handle streaming case (requires creating a new AsyncIterator)\n    }\n    return null;\n}\nfunction testDataAgainstText(data, loader) {\n    if (loader.testText) {\n        return loader.testText(data);\n    }\n    const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n    return tests.some((test) => data.startsWith(test));\n}\nfunction testDataAgainstBinary(data, byteOffset, loader) {\n    const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n    return tests.some((test) => testBinary(data, byteOffset, loader, test));\n}\nfunction testBinary(data, byteOffset, loader, test) {\n    if (test instanceof ArrayBuffer) {\n        return compareArrayBuffers(test, data, test.byteLength);\n    }\n    switch (typeof test) {\n        case 'function':\n            return test(data);\n        case 'string':\n            // Magic bytes check: If `test` is a string, check if binary data starts with that strings\n            const magic = getMagicString(data, byteOffset, test.length);\n            return test === magic;\n        default:\n            return false;\n    }\n}\nfunction getFirstCharacters(data, length = 5) {\n    if (typeof data === 'string') {\n        return data.slice(0, length);\n    }\n    else if (ArrayBuffer.isView(data)) {\n        // Typed Arrays can have offsets into underlying buffer\n        return getMagicString(data.buffer, data.byteOffset, length);\n    }\n    else if (data instanceof ArrayBuffer) {\n        const byteOffset = 0;\n        return getMagicString(data, byteOffset, length);\n    }\n    return '';\n}\nfunction getMagicString(arrayBuffer, byteOffset, length) {\n    if (arrayBuffer.byteLength < byteOffset + length) {\n        return '';\n    }\n    const dataView = new DataView(arrayBuffer);\n    let magic = '';\n    for (let i = 0; i < length; i++) {\n        magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n    }\n    return magic;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}