{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\nimport { bitCode, intersect } from \"./lineclip.js\";\nimport { getPointAtIndex, copy, push } from \"./utils.js\";\nexport function cutPolylineByGrid(positions, options) {\n  const {\n    size = 2,\n    broken = false,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    startIndex = 0,\n    endIndex = positions.length\n  } = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  let part = [];\n  const result = [part];\n  const a = getPointAtIndex(positions, 0, size, startIndex);\n  let b;\n  let codeB;\n  const cell = getGridCell(a, gridResolution, gridOffset, []);\n  const scratchPoint = [];\n  push(part, a);\n  for (let i = 1; i < numPoints; i++) {\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n    while (codeB) {\n      // find the intersection with the current cell\n      intersect(a, b, codeB, cell, scratchPoint);\n      const codeAlt = bitCode(scratchPoint, cell);\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n      push(part, scratchPoint);\n      // move to the next cell\n      copy(a, scratchPoint);\n      moveToNeighborCell(cell, gridResolution, codeB);\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        push(part, a);\n      }\n      codeB = bitCode(b, cell);\n    }\n    push(part, b);\n    copy(a, b);\n  }\n  return broken ? result : result[0];\n}\nconst TYPE_INSIDE = 0;\nconst TYPE_BORDER = 1;\n/**\n * Cuts a polygon by a pre-defined grid\n */\nexport function cutPolygonByGrid(positions, holeIndices = null, options) {\n  if (!positions.length) {\n    // input is empty\n    return [];\n  }\n  const {\n    size = 2,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    edgeTypes = false\n  } = options || {};\n  const result = [];\n  const queue = [{\n    pos: positions,\n    types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,\n    holes: holeIndices || []\n  }];\n  const bbox = [[], []];\n  // @ts-ignore\n  let cell = [];\n  // Recursively bisect polygon until every part fit in a single grid cell\n  while (queue.length) {\n    const {\n      pos,\n      types,\n      holes\n    } = queue.shift();\n    // Get the bounding box of the outer polygon\n    getBoundingBox(pos, size, holes[0] || pos.length, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    const code = bitCode(bbox[1], cell);\n    if (code) {\n      // Split the outer ring at the boundary\n      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      const polygonLow = {\n        pos: parts[0].pos,\n        types: parts[0].types,\n        holes: []\n      };\n      const polygonHigh = {\n        pos: parts[1].pos,\n        types: parts[1].types,\n        holes: []\n      };\n      queue.push(polygonLow, polygonHigh);\n      // Split each hole at the boundary\n      for (let i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);\n          if (edgeTypes) {\n            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);\n          }\n        }\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);\n          if (edgeTypes) {\n            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);\n          }\n        }\n      }\n    } else {\n      // Polygon fits in a single cell, no more processing required\n      const polygon = {\n        positions: pos\n      };\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n      result.push(polygon);\n    }\n  }\n  return result;\n}\n// edgeTypes:\n// TYPE_BORDER - edge from the original polygon\n// TYPE_INSIDE - inside the original polygon\n// eslint-disable-next-line max-params\nfunction bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {\n  const numPoints = (endIndex - startIndex) / size;\n  const resultLow = [];\n  const resultHigh = [];\n  const typesLow = [];\n  const typesHigh = [];\n  const scratchPoint = [];\n  let p;\n  let side;\n  let type;\n  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  let prevType = edgeTypes && edgeTypes[numPoints - 1];\n  let lowPointCount = 0;\n  let highPointCount = 0;\n  for (let i = 0; i < numPoints; i++) {\n    p = getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n    // if segment goes through the boundary, add an intersection\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      push(resultLow, scratchPoint) && typesLow.push(prevType);\n      push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n    if (side <= 0) {\n      push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n    if (side >= 0) {\n      push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n    copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n  return [lowPointCount ? {\n    pos: resultLow,\n    types: edgeTypes && typesLow\n  } : null, highPointCount ? {\n    pos: resultHigh,\n    types: edgeTypes && typesHigh\n  } : null];\n}\nfunction getGridCell(p, gridResolution, gridOffset, out) {\n  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  const bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out;\n}\nfunction moveToNeighborCell(cell, gridResolution, edge) {\n  if (edge & 8) {\n    // top\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    // bottom\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    // right\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    // left\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\nfunction getBoundingBox(positions, size, endIndex, out) {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n  for (let i = 0; i < endIndex; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}\nfunction concatInPlace(arr1, arr2) {\n  for (let i = 0; i < arr2.length; i++) {\n    arr1.push(arr2[i]);\n  }\n  return arr1;\n}","map":{"version":3,"names":["bitCode","intersect","getPointAtIndex","copy","push","cutPolylineByGrid","positions","options","size","broken","gridResolution","gridOffset","startIndex","endIndex","length","numPoints","part","result","a","b","codeB","cell","getGridCell","scratchPoint","i","codeAlt","moveToNeighborCell","TYPE_INSIDE","TYPE_BORDER","cutPolygonByGrid","holeIndices","edgeTypes","queue","pos","types","Array","fill","holes","bbox","shift","getBoundingBox","code","parts","bisectPolygon","polygonLow","polygonHigh","concatInPlace","polygon","edge","resultLow","resultHigh","typesLow","typesHigh","p","side","type","prev","prevSide","Math","sign","prevType","lowPointCount","highPointCount","out","left","floor","bottom","minX","Infinity","maxX","minY","maxY","x","y","arr1","arr2"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\polygon\\src\\cut-by-grid.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\nimport {bitCode, intersect, BoundingBox} from './lineclip';\nimport {getPointAtIndex, copy, push} from './utils';\n\nimport type {NumericArray} from '@math.gl/core';\n\nexport type Polygon = {\n  positions: Readonly<NumericArray>;\n  holeIndices?: Readonly<NumericArray>;\n  edgeTypes?: Readonly<NumericArray>;\n};\n\nexport function cutPolylineByGrid(\n  positions: NumericArray,\n  options?: {\n    size?: number;\n    broken?: boolean;\n    gridResolution?: number;\n    gridOffset?: [number, number];\n    startIndex?: number;\n    endIndex?: number;\n  }\n): number[] | number[][] {\n  const {\n    size = 2,\n    broken = false,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    startIndex = 0,\n    endIndex = positions.length\n  } = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  let part: number[] = [];\n  const result: number[][] = [part];\n  const a: number[] = getPointAtIndex(positions, 0, size, startIndex);\n  let b: number[];\n  let codeB: number;\n  const cell: BoundingBox = getGridCell(a, gridResolution, gridOffset, []);\n  const scratchPoint: number[] = [];\n  push(part, a);\n\n  for (let i = 1; i < numPoints; i++) {\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n\n    while (codeB) {\n      // find the intersection with the current cell\n      intersect(a, b, codeB, cell, scratchPoint);\n      const codeAlt = bitCode(scratchPoint, cell);\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n      push(part, scratchPoint);\n      // move to the next cell\n      copy(a, scratchPoint);\n\n      moveToNeighborCell(cell, gridResolution, codeB);\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        push(part, a);\n      }\n\n      codeB = bitCode(b, cell);\n    }\n\n    push(part, b);\n    copy(a, b);\n  }\n\n  return broken ? result : result[0];\n}\n\nconst TYPE_INSIDE = 0;\nconst TYPE_BORDER = 1;\n\n/** Internal helper type during cutting, name TBD */\ntype PolygonCut = {\n  pos: Readonly<NumericArray>;\n  types: number[];\n  holes: Readonly<NumericArray>;\n};\n\n/** Internal helper type during cutting, name TBD */\ntype MutablePolygonCut = {\n  pos: number[];\n  types: number[];\n  holes: number[];\n};\n\n/**\n * Cuts a polygon by a pre-defined grid\n */\nexport function cutPolygonByGrid(\n  positions: Readonly<NumericArray>,\n  holeIndices: Readonly<NumericArray> | null = null,\n  options?: {\n    size?: number;\n    gridResolution?: number;\n    gridOffset?: [number, number];\n    edgeTypes?: boolean;\n  }\n): Polygon[] {\n  if (!positions.length) {\n    // input is empty\n    return [];\n  }\n  const {size = 2, gridResolution = 10, gridOffset = [0, 0], edgeTypes = false} = options || {};\n  const result: Polygon[] = [];\n  const queue: PolygonCut[] = [\n    {\n      pos: positions,\n      types: edgeTypes ? (new Array(positions.length / size).fill(TYPE_BORDER) as number[]) : null,\n      holes: holeIndices || []\n    }\n  ];\n  const bbox: number[][] = [[], []];\n  // @ts-ignore\n  let cell: BoundingBox = [];\n\n  // Recursively bisect polygon until every part fit in a single grid cell\n  while (queue.length) {\n    const {pos, types, holes} = queue.shift();\n\n    // Get the bounding box of the outer polygon\n    getBoundingBox(pos, size, holes[0] || pos.length, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    const code = bitCode(bbox[1], cell);\n\n    if (code) {\n      // Split the outer ring at the boundary\n      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      const polygonLow: MutablePolygonCut = {pos: parts[0].pos, types: parts[0].types, holes: []};\n      const polygonHigh: MutablePolygonCut = {pos: parts[1].pos, types: parts[1].types, holes: []};\n      queue.push(polygonLow, polygonHigh);\n\n      // Split each hole at the boundary\n      for (let i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);\n          if (edgeTypes) {\n            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);\n          }\n        }\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);\n          if (edgeTypes) {\n            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);\n          }\n        }\n      }\n    } else {\n      // Polygon fits in a single cell, no more processing required\n      const polygon: Polygon = {positions: pos};\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n\n      result.push(polygon);\n    }\n  }\n  return result;\n}\n\n// edgeTypes:\n// TYPE_BORDER - edge from the original polygon\n// TYPE_INSIDE - inside the original polygon\n// eslint-disable-next-line max-params\nfunction bisectPolygon(\n  positions: Readonly<NumericArray>,\n  edgeTypes: number[] | undefined,\n  size: number,\n  startIndex: number,\n  endIndex: number,\n  bbox: BoundingBox,\n  edge: number\n): {\n  pos: number[];\n  types?: number[];\n}[] {\n  const numPoints = (endIndex - startIndex) / size;\n  const resultLow: number[] = [];\n  const resultHigh: number[] = [];\n  const typesLow: number[] = [];\n  const typesHigh: number[] = [];\n  const scratchPoint: number[] = [];\n\n  let p: number[];\n  let side: number;\n  let type: number;\n  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  let prevType = edgeTypes && edgeTypes[numPoints - 1];\n  let lowPointCount = 0;\n  let highPointCount = 0;\n\n  for (let i = 0; i < numPoints; i++) {\n    p = getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n\n    // if segment goes through the boundary, add an intersection\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      push(resultLow, scratchPoint) && typesLow.push(prevType);\n      push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n\n    if (side <= 0) {\n      push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n    if (side >= 0) {\n      push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n\n    copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n\n  return [\n    lowPointCount ? {pos: resultLow, types: edgeTypes && typesLow} : null,\n    highPointCount ? {pos: resultHigh, types: edgeTypes && typesHigh} : null\n  ];\n}\n\nfunction getGridCell(\n  p: number[],\n  gridResolution: number,\n  gridOffset: [number, number],\n  out: number[]\n): BoundingBox {\n  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  const bottom =\n    Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out as BoundingBox;\n}\n\nfunction moveToNeighborCell(cell: number[], gridResolution: number, edge: number): void {\n  if (edge & 8) {\n    // top\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    // bottom\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    // right\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    // left\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\n\nfunction getBoundingBox(\n  positions: Readonly<NumericArray>,\n  size: number,\n  endIndex: number,\n  out: number[][]\n): number[][] {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  for (let i = 0; i < endIndex; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}\n\nfunction concatInPlace(arr1: number[], arr2: number[]): number[] {\n  for (let i = 0; i < arr2.length; i++) {\n    arr1.push(arr2[i]);\n  }\n  return arr1;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}