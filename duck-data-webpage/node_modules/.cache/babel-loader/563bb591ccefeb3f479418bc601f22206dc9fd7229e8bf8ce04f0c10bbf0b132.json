{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { uid } from \"../utils/uid.js\";\nexport class Geometry {\n  id;\n  /** Determines how vertices are read from the 'vertex' attributes */\n  topology;\n  vertexCount;\n  indices;\n  attributes;\n  userData = {};\n  constructor(props) {\n    const {\n      attributes = {},\n      indices = null,\n      vertexCount = null\n    } = props;\n    this.id = props.id || uid('geometry');\n    this.topology = props.topology;\n    if (indices) {\n      this.indices = ArrayBuffer.isView(indices) ? {\n        value: indices,\n        size: 1\n      } : indices;\n    }\n    // @ts-expect-error\n    this.attributes = {};\n    for (const [attributeName, attributeValue] of Object.entries(attributes)) {\n      // Wrap \"unwrapped\" arrays and try to autodetect their type\n      const attribute = ArrayBuffer.isView(attributeValue) ? {\n        value: attributeValue\n      } : attributeValue;\n      if (!ArrayBuffer.isView(attribute.value)) {\n        throw new Error(`${this._print(attributeName)}: must be typed array or object with value as typed array`);\n      }\n      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {\n        attribute.size = 3;\n      }\n      // Move indices to separate field\n      if (attributeName === 'indices') {\n        if (this.indices) {\n          throw new Error('Multiple indices detected');\n        }\n        this.indices = attribute;\n      } else {\n        this.attributes[attributeName] = attribute;\n      }\n    }\n    if (this.indices && this.indices.isIndexed !== undefined) {\n      this.indices = Object.assign({}, this.indices);\n      delete this.indices.isIndexed;\n    }\n    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);\n  }\n  getVertexCount() {\n    return this.vertexCount;\n  }\n  /**\n   * Return an object with all attributes plus indices added as a field.\n   * TODO Geometry types are a mess\n   */\n  getAttributes() {\n    return this.indices ? {\n      indices: this.indices,\n      ...this.attributes\n    } : this.attributes;\n  }\n  // PRIVATE\n  _print(attributeName) {\n    return `Geometry ${this.id} attribute ${attributeName}`;\n  }\n  /**\n   * GeometryAttribute\n   * value: typed array\n   * type: indices, vertices, uvs\n   * size: elements per vertex\n   * target: WebGL buffer type (string or constant)\n   *\n   * @param attributes\n   * @param indices\n   * @returns\n   */\n  _setAttributes(attributes, indices) {\n    return this;\n  }\n  _calculateVertexCount(attributes, indices) {\n    if (indices) {\n      return indices.value.length;\n    }\n    let vertexCount = Infinity;\n    for (const attribute of Object.values(attributes)) {\n      const {\n        value,\n        size,\n        constant\n      } = attribute;\n      if (!constant && value && size !== undefined && size >= 1) {\n        vertexCount = Math.min(vertexCount, value.length / size);\n      }\n    }\n    // assert(Number.isFinite(vertexCount));\n    return vertexCount;\n  }\n}\n//# sourceMappingURL=geometry.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}