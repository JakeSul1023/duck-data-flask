{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { canEncodeWithWorker, NodeFile, resolvePath, isBrowser } from '@loaders.gl/loader-utils';\nimport { processOnWorker } from '@loaders.gl/worker-utils';\nimport { fetchFile } from \"../fetch/fetch-file.js\";\nimport { getLoaderOptions } from \"./loader-options.js\";\n/**\n * Encode loaded data into a binary ArrayBuffer using the specified Writer.\n */\nexport async function encode(data, writer, options_) {\n  const globalOptions = getLoaderOptions();\n  // const globalOptions: WriterOptions = {}; // getWriterOptions();\n  const options = {\n    ...globalOptions,\n    ...options_\n  };\n  // Handle the special case where we are invoking external command-line tools\n  if (writer.encodeURLtoURL) {\n    return encodeWithCommandLineTool(writer, data, options);\n  }\n  // Worker support\n  if (canEncodeWithWorker(writer, options)) {\n    return await processOnWorker(writer, data, options);\n  }\n  // TODO Merge default writer options with options argument like it is done in load module.\n  return await writer.encode(data, options);\n}\n/**\n * Encode loaded data into a binary ArrayBuffer using the specified Writer.\n */\nexport function encodeSync(data, writer, options) {\n  if (writer.encodeSync) {\n    return writer.encodeSync(data, options);\n  }\n  if (writer.encodeTextSync) {\n    return new TextEncoder().encode(writer.encodeTextSync(data, options));\n  }\n  throw new Error(`Writer ${writer.name} could not synchronously encode data`);\n}\n/**\n * Encode loaded data to text using the specified Writer\n * @note This is a convenience function not intended for production use on large input data.\n * It is not optimized for performance. Data maybe converted from text to binary and back.\n * @throws if the writer does not generate text output\n */\nexport async function encodeText(data, writer, options) {\n  if (writer.encodeText) {\n    return await writer.encodeText(data, options);\n  }\n  if (writer.encodeTextSync) {\n    return writer.encodeTextSync(data, options);\n  }\n  if (writer.text) {\n    const arrayBuffer = await writer.encode(data, options);\n    return new TextDecoder().decode(arrayBuffer);\n  }\n  throw new Error(`Writer ${writer.name} could not encode data as text`);\n}\n/**\n * Encode loaded data to text using the specified Writer\n * @note This is a convenience function not intended for production use on large input data.\n * It is not optimized for performance. Data maybe converted from text to binary and back.\n * @throws if the writer does not generate text output\n */\nexport function encodeTextSync(data, writer, options) {\n  if (writer.encodeTextSync) {\n    return writer.encodeTextSync(data, options);\n  }\n  if (writer.text && writer.encodeSync) {\n    const arrayBuffer = encodeSync(data, writer, options);\n    return new TextDecoder().decode(arrayBuffer);\n  }\n  throw new Error(`Writer ${writer.name} could not encode data as text`);\n}\n/**\n * Encode loaded data into a sequence (iterator) of binary ArrayBuffers using the specified Writer.\n */\nexport function encodeInBatches(data, writer, options) {\n  if (writer.encodeInBatches) {\n    const dataIterator = getIterator(data);\n    // @ts-expect-error\n    return writer.encodeInBatches(dataIterator, options);\n  }\n  // TODO -fall back to atomic encode?\n  throw new Error(`Writer ${writer.name} could not encode in batches`);\n}\n/**\n * Encode loaded data into a sequence (iterator) of binary ArrayBuffers using the specified Writer.\n */\nexport function encodeTextInBatches(data, writer, options) {\n  if (writer.encodeTextInBatches) {\n    const dataIterator = getIterator(data);\n    // @ts-expect-error\n    return writer.encodeTextInBatches(dataIterator, options);\n  }\n  // TODO -fall back to atomic encode?\n  throw new Error(`Writer ${writer.name} could not encode text in batches`);\n}\n/**\n * Encode data stored in a file (on disk) to another file.\n * @note Node.js only. This function enables using command-line converters as \"writers\".\n */\nexport async function encodeURLtoURL(inputUrl, outputUrl, writer, options) {\n  inputUrl = resolvePath(inputUrl);\n  outputUrl = resolvePath(outputUrl);\n  if (isBrowser || !writer.encodeURLtoURL) {\n    throw new Error();\n  }\n  const outputFilename = await writer.encodeURLtoURL(inputUrl, outputUrl, options);\n  return outputFilename;\n}\n/** Helper function to encode via external tool (typically command line execution in Node.js) */\nasync function encodeWithCommandLineTool(writer, data, options) {\n  if (isBrowser) {\n    throw new Error(`Writer ${writer.name} not supported in browser`);\n  }\n  // TODO - how to generate filenames with correct extensions?\n  const tmpInputFilename = getTemporaryFilename('input');\n  const file = new NodeFile(tmpInputFilename, 'w');\n  await file.write(data);\n  const tmpOutputFilename = getTemporaryFilename('output');\n  const outputFilename = await encodeURLtoURL(tmpInputFilename, tmpOutputFilename, writer, options);\n  const response = await fetchFile(outputFilename);\n  return response.arrayBuffer();\n}\n/**\n * @todo TODO - this is an unacceptable hack!!!\n */\nfunction getIterator(data) {\n  const dataIterator = [{\n    ...data,\n    start: 0,\n    end: data.length\n  }];\n  return dataIterator;\n}\n/**\n * @todo Move to utils\n */\nfunction getTemporaryFilename(filename) {\n  return `/tmp/${filename}`;\n}","map":{"version":3,"names":["canEncodeWithWorker","NodeFile","resolvePath","isBrowser","processOnWorker","fetchFile","getLoaderOptions","encode","data","writer","options_","globalOptions","options","encodeURLtoURL","encodeWithCommandLineTool","encodeSync","encodeTextSync","TextEncoder","Error","name","encodeText","text","arrayBuffer","TextDecoder","decode","encodeInBatches","dataIterator","getIterator","encodeTextInBatches","inputUrl","outputUrl","outputFilename","tmpInputFilename","getTemporaryFilename","file","write","tmpOutputFilename","response","start","end","length","filename"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/core/dist/lib/api/encode.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { canEncodeWithWorker, NodeFile, resolvePath, isBrowser } from '@loaders.gl/loader-utils';\nimport { processOnWorker } from '@loaders.gl/worker-utils';\nimport { fetchFile } from \"../fetch/fetch-file.js\";\nimport { getLoaderOptions } from \"./loader-options.js\";\n/**\n * Encode loaded data into a binary ArrayBuffer using the specified Writer.\n */\nexport async function encode(data, writer, options_) {\n    const globalOptions = getLoaderOptions();\n    // const globalOptions: WriterOptions = {}; // getWriterOptions();\n    const options = { ...globalOptions, ...options_ };\n    // Handle the special case where we are invoking external command-line tools\n    if (writer.encodeURLtoURL) {\n        return encodeWithCommandLineTool(writer, data, options);\n    }\n    // Worker support\n    if (canEncodeWithWorker(writer, options)) {\n        return await processOnWorker(writer, data, options);\n    }\n    // TODO Merge default writer options with options argument like it is done in load module.\n    return await writer.encode(data, options);\n}\n/**\n * Encode loaded data into a binary ArrayBuffer using the specified Writer.\n */\nexport function encodeSync(data, writer, options) {\n    if (writer.encodeSync) {\n        return writer.encodeSync(data, options);\n    }\n    if (writer.encodeTextSync) {\n        return new TextEncoder().encode(writer.encodeTextSync(data, options));\n    }\n    throw new Error(`Writer ${writer.name} could not synchronously encode data`);\n}\n/**\n * Encode loaded data to text using the specified Writer\n * @note This is a convenience function not intended for production use on large input data.\n * It is not optimized for performance. Data maybe converted from text to binary and back.\n * @throws if the writer does not generate text output\n */\nexport async function encodeText(data, writer, options) {\n    if (writer.encodeText) {\n        return await writer.encodeText(data, options);\n    }\n    if (writer.encodeTextSync) {\n        return writer.encodeTextSync(data, options);\n    }\n    if (writer.text) {\n        const arrayBuffer = await writer.encode(data, options);\n        return new TextDecoder().decode(arrayBuffer);\n    }\n    throw new Error(`Writer ${writer.name} could not encode data as text`);\n}\n/**\n * Encode loaded data to text using the specified Writer\n * @note This is a convenience function not intended for production use on large input data.\n * It is not optimized for performance. Data maybe converted from text to binary and back.\n * @throws if the writer does not generate text output\n */\nexport function encodeTextSync(data, writer, options) {\n    if (writer.encodeTextSync) {\n        return writer.encodeTextSync(data, options);\n    }\n    if (writer.text && writer.encodeSync) {\n        const arrayBuffer = encodeSync(data, writer, options);\n        return new TextDecoder().decode(arrayBuffer);\n    }\n    throw new Error(`Writer ${writer.name} could not encode data as text`);\n}\n/**\n * Encode loaded data into a sequence (iterator) of binary ArrayBuffers using the specified Writer.\n */\nexport function encodeInBatches(data, writer, options) {\n    if (writer.encodeInBatches) {\n        const dataIterator = getIterator(data);\n        // @ts-expect-error\n        return writer.encodeInBatches(dataIterator, options);\n    }\n    // TODO -fall back to atomic encode?\n    throw new Error(`Writer ${writer.name} could not encode in batches`);\n}\n/**\n * Encode loaded data into a sequence (iterator) of binary ArrayBuffers using the specified Writer.\n */\nexport function encodeTextInBatches(data, writer, options) {\n    if (writer.encodeTextInBatches) {\n        const dataIterator = getIterator(data);\n        // @ts-expect-error\n        return writer.encodeTextInBatches(dataIterator, options);\n    }\n    // TODO -fall back to atomic encode?\n    throw new Error(`Writer ${writer.name} could not encode text in batches`);\n}\n/**\n * Encode data stored in a file (on disk) to another file.\n * @note Node.js only. This function enables using command-line converters as \"writers\".\n */\nexport async function encodeURLtoURL(inputUrl, outputUrl, writer, options) {\n    inputUrl = resolvePath(inputUrl);\n    outputUrl = resolvePath(outputUrl);\n    if (isBrowser || !writer.encodeURLtoURL) {\n        throw new Error();\n    }\n    const outputFilename = await writer.encodeURLtoURL(inputUrl, outputUrl, options);\n    return outputFilename;\n}\n/** Helper function to encode via external tool (typically command line execution in Node.js) */\nasync function encodeWithCommandLineTool(writer, data, options) {\n    if (isBrowser) {\n        throw new Error(`Writer ${writer.name} not supported in browser`);\n    }\n    // TODO - how to generate filenames with correct extensions?\n    const tmpInputFilename = getTemporaryFilename('input');\n    const file = new NodeFile(tmpInputFilename, 'w');\n    await file.write(data);\n    const tmpOutputFilename = getTemporaryFilename('output');\n    const outputFilename = await encodeURLtoURL(tmpInputFilename, tmpOutputFilename, writer, options);\n    const response = await fetchFile(outputFilename);\n    return response.arrayBuffer();\n}\n/**\n * @todo TODO - this is an unacceptable hack!!!\n */\nfunction getIterator(data) {\n    const dataIterator = [{ ...data, start: 0, end: data.length }];\n    return dataIterator;\n}\n/**\n * @todo Move to utils\n */\nfunction getTemporaryFilename(filename) {\n    return `/tmp/${filename}`;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}