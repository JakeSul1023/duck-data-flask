{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { CommandBuffer, Texture } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\nimport { WEBGLTexture } from \"./webgl-texture.js\";\nimport { getTextureFormatWebGL } from \"../converters/webgl-texture-table.js\";\nexport class WEBGLCommandBuffer extends CommandBuffer {\n  device;\n  commands = [];\n  constructor(device) {\n    super(device, {});\n    this.device = device;\n  }\n  submitCommands() {\n    let commands = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.commands;\n    for (const command of commands) {\n      switch (command.name) {\n        case 'copy-buffer-to-buffer':\n          _copyBufferToBuffer(this.device, command.options);\n          break;\n        case 'copy-buffer-to-texture':\n          _copyBufferToTexture(this.device, command.options);\n          break;\n        case 'copy-texture-to-buffer':\n          _copyTextureToBuffer(this.device, command.options);\n          break;\n        case 'copy-texture-to-texture':\n          _copyTextureToTexture(this.device, command.options);\n          break;\n        // case 'clear-texture':\n        //   _clearTexture(this.device, command.options);\n        //   break;\n        default:\n          throw new Error(command.name);\n      }\n    }\n  }\n}\nfunction _copyBufferToBuffer(device, options) {\n  const source = options.sourceBuffer;\n  const destination = options.destinationBuffer;\n  // {In WebGL2 we can p}erform the copy on the GPU\n  // Use GL.COPY_READ_BUFFER+GL.COPY_WRITE_BUFFER avoid disturbing other targets and locking type\n  device.gl.bindBuffer(36662, source.handle);\n  device.gl.bindBuffer(36663, destination.handle);\n  device.gl.copyBufferSubData(36662, 36663, options.sourceOffset ?? 0, options.destinationOffset ?? 0, options.size);\n  device.gl.bindBuffer(36662, null);\n  device.gl.bindBuffer(36663, null);\n}\n/**\n * Copies data from a Buffer object into a Texture object\n * NOTE: doesn't wait for copy to be complete\n */\nfunction _copyBufferToTexture(device, options) {\n  throw new Error('Not implemented');\n}\n/**\n * Copies data from a Texture object into a Buffer object.\n * NOTE: doesn't wait for copy to be complete\n */\nfunction _copyTextureToBuffer(device, options) {\n  const {\n    /** Texture to copy to/from. */\n    sourceTexture,\n    /**  Mip-map level of the texture to copy to/from. (Default 0) */\n    mipLevel = 0,\n    /** Defines which aspects of the texture to copy to/from. */\n    aspect = 'all',\n    /** Width to copy */\n    width = options.sourceTexture.width,\n    /** Height to copy */\n    height = options.sourceTexture.height,\n    depthOrArrayLayers = 0,\n    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */\n    origin = [0, 0],\n    /** Destination buffer */\n    destinationBuffer,\n    /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */\n    byteOffset = 0,\n    /**\n     * The stride, in bytes, between the beginning of each block row and the subsequent block row.\n     * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).\n     */\n    bytesPerRow,\n    /**\n     * Number of block rows per single image of the texture.\n     * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.\n     * Required if there are multiple images (i.e. the copy depth is more than one).\n     */\n    rowsPerImage\n  } = options;\n  // TODO - Not possible to read just stencil or depth part in WebGL?\n  if (aspect !== 'all') {\n    throw new Error('aspect not supported in WebGL');\n  }\n  // TODO - mipLevels are set when attaching texture to framebuffer\n  if (mipLevel !== 0 || depthOrArrayLayers !== 0 || bytesPerRow || rowsPerImage) {\n    throw new Error('not implemented');\n  }\n  // Asynchronous read (PIXEL_PACK_BUFFER) is WebGL2 only feature\n  const {\n    framebuffer,\n    destroyFramebuffer\n  } = getFramebuffer(sourceTexture);\n  let prevHandle;\n  try {\n    const webglBuffer = destinationBuffer;\n    const sourceWidth = width || framebuffer.width;\n    const sourceHeight = height || framebuffer.height;\n    const sourceParams = getTextureFormatWebGL(framebuffer.colorAttachments[0].texture.props.format);\n    const sourceFormat = sourceParams.format;\n    const sourceType = sourceParams.type;\n    // if (!target) {\n    //   // Create new buffer with enough size\n    //   const components = glFormatToComponents(sourceFormat);\n    //   const byteCount = glTypeToBytes(sourceType);\n    //   const byteLength = byteOffset + sourceWidth * sourceHeight * components * byteCount;\n    //   target = device.createBuffer({byteLength});\n    // }\n    device.gl.bindBuffer(35051, webglBuffer.handle);\n    // @ts-expect-error native bindFramebuffer is overridden by our state tracker\n    prevHandle = device.gl.bindFramebuffer(36160, framebuffer.handle);\n    device.gl.readPixels(origin[0], origin[1], sourceWidth, sourceHeight, sourceFormat, sourceType, byteOffset);\n  } finally {\n    device.gl.bindBuffer(35051, null);\n    // prevHandle may be unassigned if the try block failed before binding\n    if (prevHandle !== undefined) {\n      device.gl.bindFramebuffer(36160, prevHandle);\n    }\n    if (destroyFramebuffer) {\n      framebuffer.destroy();\n    }\n  }\n}\n/**\n * Copies data from a Framebuffer or a Texture object into a Buffer object.\n * NOTE: doesn't wait for copy to be complete, it programs GPU to perform a DMA transfer.\nexport function readPixelsToBuffer(\n  source: Framebuffer | Texture,\n  options?: {\n    sourceX?: number;\n    sourceY?: number;\n    sourceFormat?: number;\n    target?: Buffer; // A new Buffer object is created when not provided.\n    targetByteOffset?: number; // byte offset in buffer object\n    // following parameters are auto deduced if not provided\n    sourceWidth?: number;\n    sourceHeight?: number;\n    sourceType?: number;\n  }\n): Buffer\n */\n/**\n * Copy a rectangle from a Framebuffer or Texture object into a texture (at an offset)\n */\n// eslint-disable-next-line complexity, max-statements\nfunction _copyTextureToTexture(device, options) {\n  const {\n    /** Texture to copy to/from. */\n    sourceTexture,\n    /**  Mip-map level of the texture to copy to (Default 0) */\n    destinationMipLevel = 0,\n    /** Defines which aspects of the texture to copy to/from. */\n    // aspect = 'all',\n    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */\n    origin = [0, 0],\n    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */\n    destinationOrigin = [0, 0],\n    /** Texture to copy to/from. */\n    destinationTexture\n    /**  Mip-map level of the texture to copy to/from. (Default 0) */\n    // destinationMipLevel = options.mipLevel,\n    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */\n    // destinationOrigin = [0, 0],\n    /** Defines which aspects of the texture to copy to/from. */\n    // destinationAspect = options.aspect,\n  } = options;\n  let {\n    width = options.destinationTexture.width,\n    height = options.destinationTexture.height\n    // depthOrArrayLayers = 0\n  } = options;\n  const {\n    framebuffer,\n    destroyFramebuffer\n  } = getFramebuffer(sourceTexture);\n  const [sourceX, sourceY] = origin;\n  const [destinationX, destinationY, destinationZ] = destinationOrigin;\n  // @ts-expect-error native bindFramebuffer is overridden by our state tracker\n  const prevHandle = device.gl.bindFramebuffer(36160, framebuffer.handle);\n  // TODO - support gl.readBuffer (WebGL2 only)\n  // const prevBuffer = gl.readBuffer(attachment);\n  let texture = null;\n  let textureTarget;\n  if (destinationTexture instanceof WEBGLTexture) {\n    texture = destinationTexture;\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n    texture.bind(0);\n    textureTarget = texture.glTarget;\n  } else {\n    throw new Error('invalid destination');\n  }\n  switch (textureTarget) {\n    case 3553:\n    case 34067:\n      device.gl.copyTexSubImage2D(textureTarget, destinationMipLevel, destinationX, destinationY, sourceX, sourceY, width, height);\n      break;\n    case 35866:\n    case 32879:\n      device.gl.copyTexSubImage3D(textureTarget, destinationMipLevel, destinationX, destinationY, destinationZ, sourceX, sourceY, width, height);\n      break;\n    default:\n  }\n  if (texture) {\n    texture.unbind();\n  }\n  device.gl.bindFramebuffer(36160, prevHandle);\n  if (destroyFramebuffer) {\n    framebuffer.destroy();\n  }\n}\n/** Clear one mip level of a texture *\nfunction _clearTexture(device: WebGLDevice, options: ClearTextureOptions) {\n  const BORDER = 0;\n  const {dimension, width, height, depth = 0, mipLevel = 0} = options;\n  const {glInternalFormat, glFormat, glType, compressed} = options;\n  const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);\n\n  switch (dimension) {\n    case '2d-array':\n    case '3d':\n      if (compressed) {\n        // prettier-ignore\n        device.gl.compressedTexImage3D(glTarget, mipLevel, glInternalFormat, width, height, depth, BORDER, null);\n      } else {\n        // prettier-ignore\n        device.gl.texImage3D( glTarget, mipLevel, glInternalFormat, width, height, depth, BORDER, glFormat, glType, null);\n      }\n      break;\n\n    case '2d':\n    case 'cube':\n      if (compressed) {\n        // prettier-ignore\n        device.gl.compressedTexImage2D(glTarget, mipLevel, glInternalFormat, width, height, BORDER, null);\n      } else {\n        // prettier-ignore\n        device.gl.texImage2D(glTarget, mipLevel, glInternalFormat, width, height, BORDER, glFormat, glType, null);\n      }\n      break;\n\n    default:\n      throw new Error(dimension);\n  }\n}\n  */\n// function _readTexture(device: WebGLDevice, options: CopyTextureToBufferOptions) {}\n// HELPERS\n/**\n * In WebGL, cube maps specify faces by overriding target instead of using the depth parameter.\n * @note We still bind the texture using GL.TEXTURE_CUBE_MAP, but we need to use the face-specific target when setting mip levels.\n * @returns glTarget unchanged, if dimension !== 'cube'.\n */\nexport function getWebGLCubeFaceTarget(glTarget, dimension, level) {\n  return dimension === 'cube' ? 34069 + level : glTarget;\n}\n/** Wrap a texture in a framebuffer so that we can use WebGL APIs that work on framebuffers */\nfunction getFramebuffer(source) {\n  if (source instanceof Texture) {\n    const {\n      width,\n      height,\n      id\n    } = source;\n    const framebuffer = source.device.createFramebuffer({\n      id: `framebuffer-for-${id}`,\n      width,\n      height,\n      colorAttachments: [source]\n    });\n    return {\n      framebuffer,\n      destroyFramebuffer: true\n    };\n  }\n  return {\n    framebuffer: source,\n    destroyFramebuffer: false\n  };\n}\n/**\n * Returns number of components in a specific readPixels WebGL format\n * @todo use shadertypes utils instead?\n */\nexport function glFormatToComponents(format) {\n  switch (format) {\n    case 6406:\n    case 33326:\n    case 6403:\n      return 1;\n    case 33328:\n    case 33319:\n      return 2;\n    case 6407:\n    case 34837:\n      return 3;\n    case 6408:\n    case 34836:\n      return 4;\n    // TODO: Add support for additional WebGL2 formats\n    default:\n      throw new Error('GLFormat');\n  }\n}\n/**\n * Return byte count for given readPixels WebGL type\n * @todo use shadertypes utils instead?\n */\nexport function glTypeToBytes(type) {\n  switch (type) {\n    case 5121:\n      return 1;\n    case 33635:\n    case 32819:\n    case 32820:\n      return 2;\n    case 5126:\n      return 4;\n    // TODO: Add support for additional WebGL2 types\n    default:\n      throw new Error('GLType');\n  }\n}\n//# sourceMappingURL=webgl-command-buffer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}