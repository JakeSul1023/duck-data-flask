{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Flattens a nested array into a single level array,\n * or a single value into an array with one value\n * @example flatten([[1, [2]], [3], 4]) => [1, 2, 3, 4]\n * @example flatten(1) => [1]\n * @param array The array to flatten.\n * @param filter= - Optional predicate called on each `value` to\n *   determine if it should be included (pushed onto) the resulting array.\n * @return Returns the new flattened array (new array or `result` if provided)\n */\nexport function flatten(array, filter = () => true) {\n  // Wrap single object in array\n  if (!Array.isArray(array)) {\n    return filter(array) ? [array] : [];\n  }\n  // Deep flatten and filter the array\n  return flattenArray(array, filter, []);\n}\n/** Deep flattens an array. Helper to `flatten`, see its parameters */\nfunction flattenArray(array, filter, result) {\n  let index = -1;\n  while (++index < array.length) {\n    const value = array[index];\n    if (Array.isArray(value)) {\n      flattenArray(value, filter, result);\n    } else if (filter(value)) {\n      result.push(value);\n    }\n  }\n  return result;\n}\n/** Uses copyWithin to significantly speed up typed array value filling */\nexport function fillArray({\n  target,\n  source,\n  start = 0,\n  count = 1\n}) {\n  const length = source.length;\n  const total = count * length;\n  let copied = 0;\n  for (let i = start; copied < length; copied++) {\n    target[i++] = source[copied];\n  }\n  while (copied < total) {\n    // If we have copied less than half, copy everything we got\n    // else copy remaining in one operation\n    if (copied < total - copied) {\n      target.copyWithin(start + copied, start, start + copied);\n      copied *= 2;\n    } else {\n      target.copyWithin(start + copied, start, start + total - copied);\n      copied = total;\n    }\n  }\n  return target;\n}","map":{"version":3,"names":["flatten","array","filter","Array","isArray","flattenArray","result","index","length","value","push","fillArray","target","source","start","count","total","copied","i","copyWithin"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\utils\\flatten.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\ntype NestedArray<T> = (T | NestedArray<T>)[];\n\n/**\n * Flattens a nested array into a single level array,\n * or a single value into an array with one value\n * @example flatten([[1, [2]], [3], 4]) => [1, 2, 3, 4]\n * @example flatten(1) => [1]\n * @param array The array to flatten.\n * @param filter= - Optional predicate called on each `value` to\n *   determine if it should be included (pushed onto) the resulting array.\n * @return Returns the new flattened array (new array or `result` if provided)\n */\nexport function flatten<T>(\n  array: T | NestedArray<T>,\n  filter: (element: T) => boolean = () => true\n): T[] {\n  // Wrap single object in array\n  if (!Array.isArray(array)) {\n    return filter(array) ? [array] : [];\n  }\n  // Deep flatten and filter the array\n  return flattenArray(array, filter, []);\n}\n\n/** Deep flattens an array. Helper to `flatten`, see its parameters */\nfunction flattenArray<T>(array: NestedArray<T>, filter: (element: T) => boolean, result: T[]): T[] {\n  let index = -1;\n  while (++index < array.length) {\n    const value = array[index];\n    if (Array.isArray(value)) {\n      flattenArray(value, filter, result);\n    } else if (filter(value)) {\n      result.push(value);\n    }\n  }\n  return result;\n}\n\n/** Uses copyWithin to significantly speed up typed array value filling */\nexport function fillArray({target, source, start = 0, count = 1}) {\n  const length = source.length;\n  const total = count * length;\n  let copied = 0;\n  for (let i = start; copied < length; copied++) {\n    target[i++] = source[copied];\n  }\n\n  while (copied < total) {\n    // If we have copied less than half, copy everything we got\n    // else copy remaining in one operation\n    if (copied < total - copied) {\n      target.copyWithin(start + copied, start, start + copied);\n      copied *= 2;\n    } else {\n      target.copyWithin(start + copied, start, start + total - copied);\n      copied = total;\n    }\n  }\n\n  return target;\n}\n"],"mappings":"AAAA;AACA;AACA;AAIA;;;;;;;;;;AAUA,OAAM,SAAUA,OAAOA,CACrBC,KAAyB,EACzBC,MAAA,GAAkCA,CAAA,KAAM,IAAI;EAE5C;EACA,IAAI,CAACC,KAAK,CAACC,OAAO,CAACH,KAAK,CAAC,EAAE;IACzB,OAAOC,MAAM,CAACD,KAAK,CAAC,GAAG,CAACA,KAAK,CAAC,GAAG,EAAE;EACrC;EACA;EACA,OAAOI,YAAY,CAACJ,KAAK,EAAEC,MAAM,EAAE,EAAE,CAAC;AACxC;AAEA;AACA,SAASG,YAAYA,CAAIJ,KAAqB,EAAEC,MAA+B,EAAEI,MAAW;EAC1F,IAAIC,KAAK,GAAG,CAAC,CAAC;EACd,OAAO,EAAEA,KAAK,GAAGN,KAAK,CAACO,MAAM,EAAE;IAC7B,MAAMC,KAAK,GAAGR,KAAK,CAACM,KAAK,CAAC;IAC1B,IAAIJ,KAAK,CAACC,OAAO,CAACK,KAAK,CAAC,EAAE;MACxBJ,YAAY,CAACI,KAAK,EAAEP,MAAM,EAAEI,MAAM,CAAC;IACrC,CAAC,MAAM,IAAIJ,MAAM,CAACO,KAAK,CAAC,EAAE;MACxBH,MAAM,CAACI,IAAI,CAACD,KAAK,CAAC;IACpB;EACF;EACA,OAAOH,MAAM;AACf;AAEA;AACA,OAAM,SAAUK,SAASA,CAAC;EAACC,MAAM;EAAEC,MAAM;EAAEC,KAAK,GAAG,CAAC;EAAEC,KAAK,GAAG;AAAC,CAAC;EAC9D,MAAMP,MAAM,GAAGK,MAAM,CAACL,MAAM;EAC5B,MAAMQ,KAAK,GAAGD,KAAK,GAAGP,MAAM;EAC5B,IAAIS,MAAM,GAAG,CAAC;EACd,KAAK,IAAIC,CAAC,GAAGJ,KAAK,EAAEG,MAAM,GAAGT,MAAM,EAAES,MAAM,EAAE,EAAE;IAC7CL,MAAM,CAACM,CAAC,EAAE,CAAC,GAAGL,MAAM,CAACI,MAAM,CAAC;EAC9B;EAEA,OAAOA,MAAM,GAAGD,KAAK,EAAE;IACrB;IACA;IACA,IAAIC,MAAM,GAAGD,KAAK,GAAGC,MAAM,EAAE;MAC3BL,MAAM,CAACO,UAAU,CAACL,KAAK,GAAGG,MAAM,EAAEH,KAAK,EAAEA,KAAK,GAAGG,MAAM,CAAC;MACxDA,MAAM,IAAI,CAAC;IACb,CAAC,MAAM;MACLL,MAAM,CAACO,UAAU,CAACL,KAAK,GAAGG,MAAM,EAAEH,KAAK,EAAEA,KAAK,GAAGE,KAAK,GAAGC,MAAM,CAAC;MAChEA,MAAM,GAAGD,KAAK;IAChB;EACF;EAEA,OAAOJ,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}