{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { LayerExtension } from '@deck.gl/core';\nconst defaultProps = {\n  clipBounds: [0, 0, 1, 1],\n  clipByInstance: undefined\n};\nconst shaderFunction = /* glsl */`\nuniform clipUniforms {\n  vec4 bounds;\n} clip;\n\nbool clip_isInBounds(vec2 position) {\n  return position.x >= clip.bounds[0] && position.y >= clip.bounds[1] && position.x < clip.bounds[2] && position.y < clip.bounds[3];\n}\n`;\n/*\n * The vertex-shader version clips geometries by their anchor position\n * e.g. ScatterplotLayer - show if the center of a circle is within bounds\n */\nconst shaderModuleVs = {\n  name: 'clip',\n  vs: shaderFunction,\n  uniformTypes: {\n    bounds: 'vec4<f32>'\n  }\n};\nconst injectionVs = {\n  'vs:#decl': /* glsl */`\nout float clip_isVisible;\n`,\n  'vs:DECKGL_FILTER_GL_POSITION': /* glsl */`\n  clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));\n`,\n  'fs:#decl': /* glsl */`\nin float clip_isVisible;\n`,\n  'fs:DECKGL_FILTER_COLOR': /* glsl */`\n  if (clip_isVisible < 0.5) discard;\n`\n};\n/*\n * The fragment-shader version clips pixels at the bounds\n * e.g. PolygonLayer - show the part of the polygon that intersect with the bounds\n */\nconst shaderModuleFs = {\n  name: 'clip',\n  fs: shaderFunction,\n  uniformTypes: {\n    bounds: 'vec4<f32>'\n  }\n};\nconst injectionFs = {\n  'vs:#decl': /* glsl */`\nout vec2 clip_commonPosition;\n`,\n  'vs:DECKGL_FILTER_GL_POSITION': /* glsl */`\n  clip_commonPosition = geometry.position.xy;\n`,\n  'fs:#decl': /* glsl */`\nin vec2 clip_commonPosition;\n`,\n  'fs:DECKGL_FILTER_COLOR': /* glsl */`\n  if (!clip_isInBounds(clip_commonPosition)) discard;\n`\n};\n/** Adds support for clipping rendered layers by rectangular bounds. */\nclass ClipExtension extends LayerExtension {\n  getShaders() {\n    // If `clipByInstance: true`, the entire object is shown/hidden based on its anchor position (done by vertex shader)\n    // Otherwise, the object is trimmed by the clip bounds (done by fragment shader)\n    // Default behavior: consider a layer instanced if it has attribute `instancePositions`\n    let clipByInstance = 'instancePositions' in this.getAttributeManager().attributes;\n    // Users can override by setting the `clipByInstance` prop\n    if (this.props.clipByInstance !== undefined) {\n      clipByInstance = Boolean(this.props.clipByInstance);\n    }\n    this.state.clipByInstance = clipByInstance;\n    return clipByInstance ? {\n      modules: [shaderModuleVs],\n      inject: injectionVs\n    } : {\n      modules: [shaderModuleFs],\n      inject: injectionFs\n    };\n  }\n  /* eslint-disable camelcase */\n  draw() {\n    const {\n      clipBounds\n    } = this.props;\n    const clipProps = {};\n    if (this.state.clipByInstance) {\n      clipProps.bounds = clipBounds;\n    } else {\n      const corner0 = this.projectPosition([clipBounds[0], clipBounds[1], 0]);\n      const corner1 = this.projectPosition([clipBounds[2], clipBounds[3], 0]);\n      clipProps.bounds = [Math.min(corner0[0], corner1[0]), Math.min(corner0[1], corner1[1]), Math.max(corner0[0], corner1[0]), Math.max(corner0[1], corner1[1])];\n    }\n    this.setShaderModuleProps({\n      clip: clipProps\n    });\n  }\n}\nClipExtension.defaultProps = defaultProps;\nClipExtension.extensionName = 'ClipExtension';\nexport default ClipExtension;\n//# sourceMappingURL=clip-extension.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}