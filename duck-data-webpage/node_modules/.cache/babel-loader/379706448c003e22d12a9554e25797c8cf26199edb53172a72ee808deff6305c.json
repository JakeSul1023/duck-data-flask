{"ast":null,"code":"// loaders./gl, MIT license\nimport { padToNBytes } from \"./memory-copy-utils.js\";\n/**\n * Helper function that pads a string with spaces to fit a certain byte alignment\n * @param string\n * @param byteAlignment\n * @returns\n *\n * @todo PERFORMANCE IDEA: No need to copy string twice...\n */\nexport function padStringToByteAlignment(string, byteAlignment) {\n  const length = string.length;\n  const paddedLength = Math.ceil(length / byteAlignment) * byteAlignment; // Round up to the required alignment\n  const padding = paddedLength - length;\n  let whitespace = '';\n  for (let i = 0; i < padding; ++i) {\n    whitespace += ' ';\n  }\n  return string + whitespace;\n}\n/**\n *\n * @param dataView\n * @param byteOffset\n * @param string\n * @param byteLength\n * @returns\n */\nexport function copyStringToDataView(dataView, byteOffset, string, byteLength) {\n  if (dataView) {\n    for (let i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, string.charCodeAt(i));\n    }\n  }\n  return byteOffset + byteLength;\n}\nexport function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {\n  if (dataView) {\n    for (let i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, binary[i]);\n    }\n  }\n  return byteOffset + byteLength;\n}\n/**\n * Copy sourceBuffer to dataView with some padding\n *\n * @param dataView - destination data container. If null - only new offset is calculated\n * @param byteOffset - destination byte offset to copy to\n * @param sourceBuffer - source data buffer\n * @param padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer, padding) {\n  const paddedLength = padToNBytes(sourceBuffer.byteLength, padding);\n  const padLength = paddedLength - sourceBuffer.byteLength;\n  if (dataView) {\n    // Copy array\n    const targetArray = new Uint8Array(dataView.buffer, dataView.byteOffset + byteOffset, sourceBuffer.byteLength);\n    const sourceArray = new Uint8Array(sourceBuffer);\n    targetArray.set(sourceArray);\n    // Add PADDING\n    for (let i = 0; i < padLength; ++i) {\n      // json chunk is padded with spaces (ASCII 0x20)\n      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);\n    }\n  }\n  byteOffset += paddedLength;\n  return byteOffset;\n}\n/**\n * Copy string to dataView with some padding\n *\n * @param {DataView | null} dataView - destination data container. If null - only new offset is calculated\n * @param {number} byteOffset - destination byte offset to copy to\n * @param {string} string - source string\n * @param {number} padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedStringToDataView(dataView, byteOffset, string, padding) {\n  const textEncoder = new TextEncoder();\n  // PERFORMANCE IDEA: We encode twice, once to get size and once to store\n  // PERFORMANCE IDEA: Use TextEncoder.encodeInto() to avoid temporary copy\n  const stringBuffer = textEncoder.encode(string);\n  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);\n  return byteOffset;\n}","map":{"version":3,"names":["padToNBytes","padStringToByteAlignment","string","byteAlignment","length","paddedLength","Math","ceil","padding","whitespace","i","copyStringToDataView","dataView","byteOffset","byteLength","setUint8","charCodeAt","copyBinaryToDataView","binary","copyPaddedArrayBufferToDataView","sourceBuffer","padLength","targetArray","Uint8Array","buffer","sourceArray","set","copyPaddedStringToDataView","textEncoder","TextEncoder","stringBuffer","encode"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/dataview-copy-utils.js"],"sourcesContent":["// loaders./gl, MIT license\nimport { padToNBytes } from \"./memory-copy-utils.js\";\n/**\n * Helper function that pads a string with spaces to fit a certain byte alignment\n * @param string\n * @param byteAlignment\n * @returns\n *\n * @todo PERFORMANCE IDEA: No need to copy string twice...\n */\nexport function padStringToByteAlignment(string, byteAlignment) {\n    const length = string.length;\n    const paddedLength = Math.ceil(length / byteAlignment) * byteAlignment; // Round up to the required alignment\n    const padding = paddedLength - length;\n    let whitespace = '';\n    for (let i = 0; i < padding; ++i) {\n        whitespace += ' ';\n    }\n    return string + whitespace;\n}\n/**\n *\n * @param dataView\n * @param byteOffset\n * @param string\n * @param byteLength\n * @returns\n */\nexport function copyStringToDataView(dataView, byteOffset, string, byteLength) {\n    if (dataView) {\n        for (let i = 0; i < byteLength; i++) {\n            dataView.setUint8(byteOffset + i, string.charCodeAt(i));\n        }\n    }\n    return byteOffset + byteLength;\n}\nexport function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {\n    if (dataView) {\n        for (let i = 0; i < byteLength; i++) {\n            dataView.setUint8(byteOffset + i, binary[i]);\n        }\n    }\n    return byteOffset + byteLength;\n}\n/**\n * Copy sourceBuffer to dataView with some padding\n *\n * @param dataView - destination data container. If null - only new offset is calculated\n * @param byteOffset - destination byte offset to copy to\n * @param sourceBuffer - source data buffer\n * @param padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer, padding) {\n    const paddedLength = padToNBytes(sourceBuffer.byteLength, padding);\n    const padLength = paddedLength - sourceBuffer.byteLength;\n    if (dataView) {\n        // Copy array\n        const targetArray = new Uint8Array(dataView.buffer, dataView.byteOffset + byteOffset, sourceBuffer.byteLength);\n        const sourceArray = new Uint8Array(sourceBuffer);\n        targetArray.set(sourceArray);\n        // Add PADDING\n        for (let i = 0; i < padLength; ++i) {\n            // json chunk is padded with spaces (ASCII 0x20)\n            dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);\n        }\n    }\n    byteOffset += paddedLength;\n    return byteOffset;\n}\n/**\n * Copy string to dataView with some padding\n *\n * @param {DataView | null} dataView - destination data container. If null - only new offset is calculated\n * @param {number} byteOffset - destination byte offset to copy to\n * @param {string} string - source string\n * @param {number} padding - pad the resulting array to multiple of \"padding\" bytes. Additional bytes are filled with 0x20 (ASCII space)\n *\n * @return new byteOffset of resulting dataView\n */\nexport function copyPaddedStringToDataView(dataView, byteOffset, string, padding) {\n    const textEncoder = new TextEncoder();\n    // PERFORMANCE IDEA: We encode twice, once to get size and once to store\n    // PERFORMANCE IDEA: Use TextEncoder.encodeInto() to avoid temporary copy\n    const stringBuffer = textEncoder.encode(string);\n    byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);\n    return byteOffset;\n}\n"],"mappings":"AAAA;AACA,SAASA,WAAW,QAAQ,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,wBAAwBA,CAACC,MAAM,EAAEC,aAAa,EAAE;EAC5D,MAAMC,MAAM,GAAGF,MAAM,CAACE,MAAM;EAC5B,MAAMC,YAAY,GAAGC,IAAI,CAACC,IAAI,CAACH,MAAM,GAAGD,aAAa,CAAC,GAAGA,aAAa,CAAC,CAAC;EACxE,MAAMK,OAAO,GAAGH,YAAY,GAAGD,MAAM;EACrC,IAAIK,UAAU,GAAG,EAAE;EACnB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,OAAO,EAAE,EAAEE,CAAC,EAAE;IAC9BD,UAAU,IAAI,GAAG;EACrB;EACA,OAAOP,MAAM,GAAGO,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,oBAAoBA,CAACC,QAAQ,EAAEC,UAAU,EAAEX,MAAM,EAAEY,UAAU,EAAE;EAC3E,IAAIF,QAAQ,EAAE;IACV,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGI,UAAU,EAAEJ,CAAC,EAAE,EAAE;MACjCE,QAAQ,CAACG,QAAQ,CAACF,UAAU,GAAGH,CAAC,EAAER,MAAM,CAACc,UAAU,CAACN,CAAC,CAAC,CAAC;IAC3D;EACJ;EACA,OAAOG,UAAU,GAAGC,UAAU;AAClC;AACA,OAAO,SAASG,oBAAoBA,CAACL,QAAQ,EAAEC,UAAU,EAAEK,MAAM,EAAEJ,UAAU,EAAE;EAC3E,IAAIF,QAAQ,EAAE;IACV,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGI,UAAU,EAAEJ,CAAC,EAAE,EAAE;MACjCE,QAAQ,CAACG,QAAQ,CAACF,UAAU,GAAGH,CAAC,EAAEQ,MAAM,CAACR,CAAC,CAAC,CAAC;IAChD;EACJ;EACA,OAAOG,UAAU,GAAGC,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,+BAA+BA,CAACP,QAAQ,EAAEC,UAAU,EAAEO,YAAY,EAAEZ,OAAO,EAAE;EACzF,MAAMH,YAAY,GAAGL,WAAW,CAACoB,YAAY,CAACN,UAAU,EAAEN,OAAO,CAAC;EAClE,MAAMa,SAAS,GAAGhB,YAAY,GAAGe,YAAY,CAACN,UAAU;EACxD,IAAIF,QAAQ,EAAE;IACV;IACA,MAAMU,WAAW,GAAG,IAAIC,UAAU,CAACX,QAAQ,CAACY,MAAM,EAAEZ,QAAQ,CAACC,UAAU,GAAGA,UAAU,EAAEO,YAAY,CAACN,UAAU,CAAC;IAC9G,MAAMW,WAAW,GAAG,IAAIF,UAAU,CAACH,YAAY,CAAC;IAChDE,WAAW,CAACI,GAAG,CAACD,WAAW,CAAC;IAC5B;IACA,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGW,SAAS,EAAE,EAAEX,CAAC,EAAE;MAChC;MACAE,QAAQ,CAACG,QAAQ,CAACF,UAAU,GAAGO,YAAY,CAACN,UAAU,GAAGJ,CAAC,EAAE,IAAI,CAAC;IACrE;EACJ;EACAG,UAAU,IAAIR,YAAY;EAC1B,OAAOQ,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASc,0BAA0BA,CAACf,QAAQ,EAAEC,UAAU,EAAEX,MAAM,EAAEM,OAAO,EAAE;EAC9E,MAAMoB,WAAW,GAAG,IAAIC,WAAW,CAAC,CAAC;EACrC;EACA;EACA,MAAMC,YAAY,GAAGF,WAAW,CAACG,MAAM,CAAC7B,MAAM,CAAC;EAC/CW,UAAU,GAAGM,+BAA+B,CAACP,QAAQ,EAAEC,UAAU,EAAEiB,YAAY,EAAEtB,OAAO,CAAC;EACzF,OAAOK,UAAU;AACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}