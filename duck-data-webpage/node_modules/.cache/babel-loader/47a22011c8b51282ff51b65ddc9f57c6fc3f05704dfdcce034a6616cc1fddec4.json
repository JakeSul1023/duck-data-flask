{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Geometry } from '@luma.gl/engine';\nimport { CompositeLayer, COORDINATE_SYSTEM, log } from '@deck.gl/core';\nimport { PointCloudLayer } from '@deck.gl/layers';\nimport { ScenegraphLayer } from '@deck.gl/mesh-layers';\nimport { default as MeshLayer } from \"../mesh-layer/mesh-layer.js\";\nimport { load } from '@loaders.gl/core';\nimport { Tileset3D, TILE_TYPE } from '@loaders.gl/tiles';\nimport { Tiles3DLoader } from '@loaders.gl/3d-tiles';\nconst SINGLE_DATA = [0];\nconst defaultProps = {\n  getPointColor: {\n    type: 'accessor',\n    value: [0, 0, 0, 255]\n  },\n  pointSize: 1.0,\n  // Disable async data loading (handling it in _loadTileSet)\n  data: '',\n  loader: Tiles3DLoader,\n  onTilesetLoad: {\n    type: 'function',\n    value: tileset3d => {}\n  },\n  onTileLoad: {\n    type: 'function',\n    value: tileHeader => {}\n  },\n  onTileUnload: {\n    type: 'function',\n    value: tileHeader => {}\n  },\n  onTileError: {\n    type: 'function',\n    value: (tile, message, url) => {}\n  },\n  _getMeshColor: {\n    type: 'function',\n    value: tileHeader => [255, 255, 255]\n  }\n};\n/** Render 3d tiles data formatted according to the [3D Tiles Specification](https://www.opengeospatial.org/standards/3DTiles) and [`ESRI I3S`](https://github.com/Esri/i3s-spec) */\nclass Tile3DLayer extends CompositeLayer {\n  initializeState() {\n    if ('onTileLoadFail' in this.props) {\n      log.removed('onTileLoadFail', 'onTileError')();\n    }\n    // prop verification\n    this.state = {\n      layerMap: {},\n      tileset3d: null,\n      activeViewports: {},\n      lastUpdatedViewports: null\n    };\n  }\n  get isLoaded() {\n    return Boolean(this.state?.tileset3d?.isLoaded() && super.isLoaded);\n  }\n  shouldUpdateState(_ref) {\n    let {\n      changeFlags\n    } = _ref;\n    return changeFlags.somethingChanged;\n  }\n  updateState(_ref2) {\n    let {\n      props,\n      oldProps,\n      changeFlags\n    } = _ref2;\n    if (props.data && props.data !== oldProps.data) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._loadTileset(props.data);\n    }\n    if (changeFlags.viewportChanged) {\n      const {\n        activeViewports\n      } = this.state;\n      const viewportsNumber = Object.keys(activeViewports).length;\n      if (viewportsNumber) {\n        this._updateTileset(activeViewports);\n        this.state.lastUpdatedViewports = activeViewports;\n        this.state.activeViewports = {};\n      }\n    }\n    if (changeFlags.propsChanged) {\n      const {\n        layerMap\n      } = this.state;\n      for (const key in layerMap) {\n        layerMap[key].needsUpdate = true;\n      }\n    }\n  }\n  activateViewport(viewport) {\n    const {\n      activeViewports,\n      lastUpdatedViewports\n    } = this.state;\n    this.internalState.viewport = viewport;\n    activeViewports[viewport.id] = viewport;\n    const lastViewport = lastUpdatedViewports?.[viewport.id];\n    if (!lastViewport || !viewport.equals(lastViewport)) {\n      this.setChangeFlags({\n        viewportChanged: true\n      });\n      this.setNeedsUpdate();\n    }\n  }\n  getPickingInfo(_ref3) {\n    let {\n      info,\n      sourceLayer\n    } = _ref3;\n    const sourceTile = sourceLayer && sourceLayer.props.tile;\n    if (info.picked) {\n      info.object = sourceTile;\n    }\n    info.sourceTile = sourceTile;\n    return info;\n  }\n  filterSubLayer(_ref4) {\n    let {\n      layer,\n      viewport\n    } = _ref4;\n    // All sublayers will have a tile prop\n    const {\n      tile\n    } = layer.props;\n    const {\n      id: viewportId\n    } = viewport;\n    return tile.selected && tile.viewportIds.includes(viewportId);\n  }\n  _updateAutoHighlight(info) {\n    const sourceTile = info.sourceTile;\n    const layerCache = this.state.layerMap[sourceTile?.id];\n    if (layerCache && layerCache.layer) {\n      layerCache.layer.updateAutoHighlight(info);\n    }\n  }\n  async _loadTileset(tilesetUrl) {\n    const {\n      loadOptions = {}\n    } = this.props;\n    // TODO: deprecate `loader` in v9.0\n    // @ts-ignore\n    const loaders = this.props.loader || this.props.loaders;\n    const loader = Array.isArray(loaders) ? loaders[0] : loaders;\n    const options = {\n      loadOptions: {\n        ...loadOptions\n      }\n    };\n    let actualTilesetUrl = tilesetUrl;\n    if (loader.preload) {\n      const preloadOptions = await loader.preload(tilesetUrl, loadOptions);\n      if (preloadOptions.url) {\n        actualTilesetUrl = preloadOptions.url;\n      }\n      if (preloadOptions.headers) {\n        options.loadOptions.fetch = {\n          ...options.loadOptions.fetch,\n          headers: preloadOptions.headers\n        };\n      }\n      Object.assign(options, preloadOptions);\n    }\n    const tilesetJson = await load(actualTilesetUrl, loader, options.loadOptions);\n    const tileset3d = new Tileset3D(tilesetJson, {\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileUnload: this._onTileUnload.bind(this),\n      onTileError: this.props.onTileError,\n      ...options\n    });\n    this.setState({\n      tileset3d,\n      layerMap: {}\n    });\n    this._updateTileset(this.state.activeViewports);\n    this.props.onTilesetLoad(tileset3d);\n  }\n  _onTileLoad(tileHeader) {\n    const {\n      lastUpdatedViewports\n    } = this.state;\n    this.props.onTileLoad(tileHeader);\n    this._updateTileset(lastUpdatedViewports);\n    this.setNeedsUpdate();\n  }\n  _onTileUnload(tileHeader) {\n    // Was cleaned up from tileset cache. We no longer need to track it.\n    delete this.state.layerMap[tileHeader.id];\n    this.props.onTileUnload(tileHeader);\n  }\n  _updateTileset(viewports) {\n    if (!viewports) {\n      return;\n    }\n    const {\n      tileset3d\n    } = this.state;\n    const {\n      timeline\n    } = this.context;\n    const viewportsNumber = Object.keys(viewports).length;\n    if (!timeline || !viewportsNumber || !tileset3d) {\n      return;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    tileset3d.selectTiles(Object.values(viewports)).then(frameNumber => {\n      const tilesetChanged = this.state.frameNumber !== frameNumber;\n      if (tilesetChanged) {\n        this.setState({\n          frameNumber\n        });\n      }\n    });\n  }\n  _getSubLayer(tileHeader, oldLayer) {\n    if (!tileHeader.content) {\n      return null;\n    }\n    switch (tileHeader.type) {\n      case TILE_TYPE.POINTCLOUD:\n        return this._makePointCloudLayer(tileHeader, oldLayer);\n      case TILE_TYPE.SCENEGRAPH:\n        return this._make3DModelLayer(tileHeader);\n      case TILE_TYPE.MESH:\n        return this._makeSimpleMeshLayer(tileHeader, oldLayer);\n      default:\n        throw new Error(`Tile3DLayer: Failed to render layer of type ${tileHeader.content.type}`);\n    }\n  }\n  _makePointCloudLayer(tileHeader, oldLayer) {\n    const {\n      attributes,\n      pointCount,\n      constantRGBA,\n      cartographicOrigin,\n      modelMatrix\n    } = tileHeader.content;\n    const {\n      positions,\n      normals,\n      colors\n    } = attributes;\n    if (!positions) {\n      return null;\n    }\n    const data = oldLayer && oldLayer.props.data || {\n      header: {\n        vertexCount: pointCount\n      },\n      attributes: {\n        POSITION: positions,\n        NORMAL: normals,\n        COLOR_0: colors\n      }\n    };\n    const {\n      pointSize,\n      getPointColor\n    } = this.props;\n    const SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n    return new SubLayerClass({\n      pointSize\n    }, this.getSubLayerProps({\n      id: 'pointcloud'\n    }), {\n      id: `${this.id}-pointcloud-${tileHeader.id}`,\n      tile: tileHeader,\n      data,\n      coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n      coordinateOrigin: cartographicOrigin,\n      modelMatrix,\n      getColor: constantRGBA || getPointColor,\n      _offset: 0\n    });\n  }\n  _make3DModelLayer(tileHeader) {\n    const {\n      gltf,\n      instances,\n      cartographicOrigin,\n      modelMatrix\n    } = tileHeader.content;\n    const SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n    return new SubLayerClass({\n      _lighting: 'pbr'\n    }, this.getSubLayerProps({\n      id: 'scenegraph'\n    }), {\n      id: `${this.id}-scenegraph-${tileHeader.id}`,\n      tile: tileHeader,\n      data: instances || SINGLE_DATA,\n      scenegraph: gltf,\n      coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n      coordinateOrigin: cartographicOrigin,\n      modelMatrix,\n      getTransformMatrix: instance => instance.modelMatrix,\n      getPosition: [0, 0, 0],\n      _offset: 0\n    });\n  }\n  _makeSimpleMeshLayer(tileHeader, oldLayer) {\n    const content = tileHeader.content;\n    const {\n      attributes,\n      indices,\n      modelMatrix,\n      cartographicOrigin,\n      coordinateSystem = COORDINATE_SYSTEM.METER_OFFSETS,\n      material,\n      featureIds\n    } = content;\n    const {\n      _getMeshColor\n    } = this.props;\n    const geometry = oldLayer && oldLayer.props.mesh || new Geometry({\n      topology: 'triangle-list',\n      attributes: getMeshGeometry(attributes),\n      indices\n    });\n    const SubLayerClass = this.getSubLayerClass('mesh', MeshLayer);\n    return new SubLayerClass(this.getSubLayerProps({\n      id: 'mesh'\n    }), {\n      id: `${this.id}-mesh-${tileHeader.id}`,\n      tile: tileHeader,\n      mesh: geometry,\n      data: SINGLE_DATA,\n      getColor: _getMeshColor(tileHeader),\n      pbrMaterial: material,\n      modelMatrix,\n      coordinateOrigin: cartographicOrigin,\n      coordinateSystem,\n      featureIds,\n      _offset: 0\n    });\n  }\n  renderLayers() {\n    const {\n      tileset3d,\n      layerMap\n    } = this.state;\n    if (!tileset3d) {\n      return null;\n    }\n    // loaders.gl doesn't provide a type for tileset3d.tiles\n    return tileset3d.tiles.map(tile => {\n      const layerCache = layerMap[tile.id] = layerMap[tile.id] || {\n        tile\n      };\n      let {\n        layer\n      } = layerCache;\n      if (tile.selected) {\n        // render selected tiles\n        if (!layer) {\n          // create layer\n          layer = this._getSubLayer(tile);\n        } else if (layerCache.needsUpdate) {\n          // props have changed, rerender layer\n          layer = this._getSubLayer(tile, layer);\n          layerCache.needsUpdate = false;\n        }\n      }\n      layerCache.layer = layer;\n      return layer;\n    }).filter(Boolean);\n  }\n}\nTile3DLayer.defaultProps = defaultProps;\nTile3DLayer.layerName = 'Tile3DLayer';\nexport default Tile3DLayer;\nfunction getMeshGeometry(contentAttributes) {\n  const attributes = {};\n  attributes.positions = {\n    ...contentAttributes.positions,\n    value: new Float32Array(contentAttributes.positions.value)\n  };\n  if (contentAttributes.normals) {\n    attributes.normals = contentAttributes.normals;\n  }\n  if (contentAttributes.texCoords) {\n    attributes.texCoords = contentAttributes.texCoords;\n  }\n  if (contentAttributes.colors) {\n    attributes.colors = contentAttributes.colors;\n  }\n  if (contentAttributes.uvRegions) {\n    attributes.uvRegions = contentAttributes.uvRegions;\n  }\n  return attributes;\n}\n//# sourceMappingURL=tile-3d-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}