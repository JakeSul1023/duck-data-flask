{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** Decodes a vertex type, returning byte length and flags (integer, signed, normalized) */\nexport function decodeShaderAttributeType(attributeType) {\n  const [dataType, components] = TYPE_INFO[attributeType];\n  const integer = dataType === 'i32' || dataType === 'u32';\n  const signed = dataType !== 'u32';\n  const byteLength = TYPE_SIZES[dataType] * components;\n  const defaultVertexFormat = getCompatibleVertexFormat(dataType, components);\n  return {\n    dataType,\n    components,\n    defaultVertexFormat,\n    byteLength,\n    integer,\n    signed\n  };\n}\n/** Get the \"default\" vertex format for a certain shader data type */\nfunction getCompatibleVertexFormat(dataType, components) {\n  let vertexType;\n  switch (dataType) {\n    case 'f32':\n      vertexType = 'float32';\n      break;\n    case 'i32':\n      vertexType = 'sint32';\n      break;\n    case 'u32':\n      vertexType = 'uint32';\n      break;\n    case 'f16':\n      return components <= 2 ? 'float16x2' : 'float16x4';\n  }\n  // TODO logic does not work for float16\n  if (components === 1) {\n    return vertexType;\n  }\n  return `${vertexType}x${components}`;\n}\n/** All valid shader attribute types. A table guarantees exhaustive list and fast execution */\nconst TYPE_INFO = {\n  f32: ['f32', 1],\n  'vec2<f32>': ['f32', 2],\n  'vec3<f32>': ['f32', 3],\n  'vec4<f32>': ['f32', 4],\n  f16: ['f16', 1],\n  'vec2<f16>': ['f16', 2],\n  'vec3<f16>': ['f16', 3],\n  'vec4<f16>': ['f16', 4],\n  i32: ['i32', 1],\n  'vec2<i32>': ['i32', 2],\n  'vec3<i32>': ['i32', 3],\n  'vec4<i32>': ['i32', 4],\n  u32: ['u32', 1],\n  'vec2<u32>': ['u32', 2],\n  'vec3<u32>': ['u32', 3],\n  'vec4<u32>': ['u32', 4]\n};\nconst TYPE_SIZES = {\n  f32: 4,\n  f16: 2,\n  i32: 4,\n  u32: 4\n  // 'bool-webgl': 4,\n};\n//# sourceMappingURL=decode-attribute-type.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}