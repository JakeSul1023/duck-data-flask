{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { flatGeojsonToBinary } from '@loaders.gl/gis';\nimport { log } from '@loaders.gl/loader-utils';\nimport Protobuf from 'pbf';\nimport { VectorTile } from \"./vector-tile/vector-tile.js\";\n/**\n * Parse MVT arrayBuffer and return GeoJSON.\n *\n * @param arrayBuffer A MVT arrayBuffer\n * @param options\n * @returns A GeoJSON geometry object or a binary representation\n */\nexport function parseMVT(arrayBuffer, options) {\n  const mvtOptions = checkOptions(options);\n  const shape = options?.gis?.format || options?.mvt?.shape || options?.shape;\n  switch (shape) {\n    case 'columnar-table':\n      // binary + some JS arrays\n      return {\n        shape: 'columnar-table',\n        data: parseToBinary(arrayBuffer, mvtOptions)\n      };\n    case 'geojson-table':\n      {\n        const table = {\n          shape: 'geojson-table',\n          type: 'FeatureCollection',\n          features: parseToGeojsonFeatures(arrayBuffer, mvtOptions)\n        };\n        return table;\n      }\n    case 'geojson':\n      return parseToGeojsonFeatures(arrayBuffer, mvtOptions);\n    case 'binary-geometry':\n      return parseToBinary(arrayBuffer, mvtOptions);\n    case 'binary':\n      return parseToBinary(arrayBuffer, mvtOptions);\n    default:\n      throw new Error(shape || 'undefined shape');\n  }\n}\nfunction parseToBinary(arrayBuffer, options) {\n  const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer, options);\n  const binaryData = flatGeojsonToBinary(flatGeoJsonFeatures, geometryInfo);\n  // Add the original byteLength (as a reasonable approximation of the size of the binary data)\n  // TODO decide where to store extra fields like byteLength (header etc) and document\n  // @ts-ignore\n  binaryData.byteLength = arrayBuffer.byteLength;\n  return binaryData;\n}\nfunction parseToFlatGeoJson(arrayBuffer, options) {\n  const features = [];\n  const geometryInfo = {\n    coordLength: 2,\n    pointPositionsCount: 0,\n    pointFeaturesCount: 0,\n    linePositionsCount: 0,\n    linePathsCount: 0,\n    lineFeaturesCount: 0,\n    polygonPositionsCount: 0,\n    polygonObjectsCount: 0,\n    polygonRingsCount: 0,\n    polygonFeaturesCount: 0\n  };\n  if (arrayBuffer.byteLength <= 0) {\n    return [features, geometryInfo];\n  }\n  const tile = new VectorTile(new Protobuf(arrayBuffer));\n  const selectedLayers = options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);\n  selectedLayers.forEach(layerName => {\n    const vectorTileLayer = tile.layers[layerName];\n    if (!vectorTileLayer) {\n      return;\n    }\n    for (let i = 0; i < vectorTileLayer.length; i++) {\n      const vectorTileFeature = vectorTileLayer.getBinaryFeature(i, geometryInfo);\n      const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);\n      features.push(decodedFeature);\n    }\n  });\n  return [features, geometryInfo];\n}\nfunction parseToGeojsonFeatures(arrayBuffer, options) {\n  if (arrayBuffer.byteLength <= 0) {\n    return [];\n  }\n  const features = [];\n  const tile = new VectorTile(new Protobuf(arrayBuffer));\n  const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);\n  selectedLayers.forEach(layerName => {\n    const vectorTileLayer = tile.layers[layerName];\n    if (!vectorTileLayer) {\n      return;\n    }\n    for (let i = 0; i < vectorTileLayer.length; i++) {\n      const vectorTileFeature = vectorTileLayer.getGeoJSONFeature(i);\n      const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);\n      features.push(decodedFeature);\n    }\n  });\n  return features;\n}\n/** Check that options are good */\nfunction checkOptions(options) {\n  if (!options?.mvt) {\n    throw new Error('mvt options required');\n  }\n  if (options.mvt?.coordinates === 'wgs84' && !options.mvt.tileIndex) {\n    throw new Error('MVT Loader: WGS84 coordinates need tileIndex property');\n  }\n  if (options.gis) {\n    log.warn('MVTLoader: \"options.gis\" is deprecated, use \"options.mvt.shape\" instead')();\n  }\n  return options.mvt;\n}\n/**\n * @param feature\n * @param options\n * @returns decoded feature\n */\nfunction getDecodedFeature(feature, options, layerName) {\n  const decodedFeature = feature.toGeoJSONFeature(options.coordinates || 'local', options.tileIndex);\n  // Add layer name to GeoJSON properties\n  if (options.layerProperty) {\n    decodedFeature.properties ||= {};\n    decodedFeature.properties[options.layerProperty] = layerName;\n  }\n  return decodedFeature;\n}\n/**\n * @param feature\n * @param options\n * @returns decoded binary feature\n */\nfunction getDecodedFeatureBinary(feature, options, layerName) {\n  const decodedFeature = feature.toBinaryFeature(options.coordinates || 'local', options.tileIndex);\n  // Add layer name to GeoJSON properties\n  if (options.layerProperty && decodedFeature.properties) {\n    decodedFeature.properties[options.layerProperty] = layerName;\n  }\n  return decodedFeature;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}