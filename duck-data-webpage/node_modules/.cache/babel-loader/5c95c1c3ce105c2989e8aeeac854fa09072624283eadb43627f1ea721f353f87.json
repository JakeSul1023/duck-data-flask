{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { WebGLBinSorter } from \"./webgl-bin-sorter.js\";\nimport { WebGLAggregationTransform } from \"./webgl-aggregation-transform.js\";\nimport { _deepEqual as deepEqual, log } from '@deck.gl/core';\n/** An Aggregator implementation that calculates aggregation on the GPU */\nexport class WebGLAggregator {\n  /** Checks if the current device supports GPU aggregation */\n  static isSupported(device) {\n    return device.features.has('float32-renderable-webgl') && device.features.has('texture-blend-float-webgl');\n  }\n  constructor(device, props) {\n    this.binCount = 0;\n    /** Cached outputs */\n    this.binIds = null;\n    this.results = [];\n    this.device = device;\n    this.dimensions = props.dimensions;\n    this.channelCount = props.channelCount;\n    this.props = {\n      ...props,\n      pointCount: 0,\n      binIdRange: [[0, 0]],\n      operations: [],\n      attributes: {},\n      binOptions: {}\n    };\n    this.needsUpdate = new Array(this.channelCount).fill(true);\n    this.binSorter = new WebGLBinSorter(device, props);\n    this.aggregationTransform = new WebGLAggregationTransform(device, props);\n    this.setProps(props);\n  }\n  getBins() {\n    const buffer = this.aggregationTransform.binBuffer;\n    if (!buffer) {\n      return null;\n    }\n    if (this.binIds?.buffer !== buffer) {\n      // deck.gl Attribute.setBinaryValue uses shallow comparison to determine if attribute value has changed\n      // For performance, only create a new binary attribute descriptor when Buffer changes\n      this.binIds = {\n        buffer,\n        type: 'float32',\n        size: this.dimensions\n      };\n    }\n    return this.binIds;\n  }\n  /** Returns an accessor to the output for a given channel. */\n  getResult(channel) {\n    const buffer = this.aggregationTransform.valueBuffer;\n    if (!buffer || channel >= this.channelCount) {\n      return null;\n    }\n    if (this.results[channel]?.buffer !== buffer) {\n      this.results[channel] = {\n        buffer,\n        type: 'float32',\n        size: 1,\n        stride: this.channelCount * 4,\n        offset: channel * 4\n      };\n    }\n    return this.results[channel];\n  }\n  /** Returns the [min, max] of aggregated values for a given channel. */\n  getResultDomain(channel) {\n    return this.aggregationTransform.domains[channel];\n  }\n  /** Returns the information for a given bin. */\n  getBin(index) {\n    if (index < 0 || index >= this.binCount) {\n      return null;\n    }\n    const {\n      binIdRange\n    } = this.props;\n    let id;\n    if (this.dimensions === 1) {\n      id = [index + binIdRange[0][0]];\n    } else {\n      const [[x0, x1], [y0]] = binIdRange;\n      const width = x1 - x0;\n      id = [index % width + x0, Math.floor(index / width) + y0];\n    }\n    const pixel = this.binSorter.getBinValues(index);\n    if (!pixel) {\n      return null;\n    }\n    const count = pixel[3];\n    const value = [];\n    for (let channel = 0; channel < this.channelCount; channel++) {\n      const operation = this.props.operations[channel];\n      if (operation === 'COUNT') {\n        value[channel] = count;\n      } else if (count === 0) {\n        value[channel] = NaN;\n      } else {\n        value[channel] = operation === 'MEAN' ? pixel[channel] / count : pixel[channel];\n      }\n    }\n    return {\n      id,\n      value,\n      count\n    };\n  }\n  /** Release GPU resources */\n  destroy() {\n    this.binSorter.destroy();\n    this.aggregationTransform.destroy();\n  }\n  /** Update aggregation props. Normalize prop values and set change flags. */\n  setProps(props) {\n    const oldProps = this.props;\n    // Update local settings. These will set the flag this._needsUpdate\n    if ('binIdRange' in props && !deepEqual(props.binIdRange, oldProps.binIdRange, 2)) {\n      const binIdRange = props.binIdRange;\n      log.assert(binIdRange.length === this.dimensions);\n      if (this.dimensions === 1) {\n        const [[x0, x1]] = binIdRange;\n        this.binCount = x1 - x0;\n      } else {\n        const [[x0, x1], [y0, y1]] = binIdRange;\n        this.binCount = (x1 - x0) * (y1 - y0);\n      }\n      this.binSorter.setDimensions(this.binCount, binIdRange);\n      this.aggregationTransform.setDimensions(this.binCount, binIdRange);\n      this.setNeedsUpdate();\n    }\n    if (props.operations) {\n      for (let channel = 0; channel < this.channelCount; channel++) {\n        if (props.operations[channel] !== oldProps.operations[channel]) {\n          this.setNeedsUpdate(channel);\n        }\n      }\n    }\n    if (props.pointCount !== undefined && props.pointCount !== oldProps.pointCount) {\n      this.binSorter.setModelProps({\n        vertexCount: props.pointCount\n      });\n      this.setNeedsUpdate();\n    }\n    if (props.binOptions) {\n      if (!deepEqual(props.binOptions, oldProps.binOptions, 2)) {\n        this.setNeedsUpdate();\n      }\n      this.binSorter.model.shaderInputs.setProps({\n        binOptions: props.binOptions\n      });\n    }\n    if (props.attributes) {\n      const attributeBuffers = {};\n      const constantAttributes = {};\n      for (const attribute of Object.values(props.attributes)) {\n        for (const [attributeName, value] of Object.entries(attribute.getValue())) {\n          if (ArrayBuffer.isView(value)) {\n            constantAttributes[attributeName] = value;\n          } else if (value) {\n            attributeBuffers[attributeName] = value;\n          }\n        }\n      }\n      this.binSorter.setModelProps({\n        attributes: attributeBuffers,\n        constantAttributes\n      });\n    }\n    if (props.shaderModuleProps) {\n      this.binSorter.setModelProps({\n        shaderModuleProps: props.shaderModuleProps\n      });\n    }\n    Object.assign(this.props, props);\n  }\n  /** Flags a channel to need update.\n   * This is called internally by setProps() if certain props change\n   * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed\n   * the underlying buffers could have been updated and require rerunning the aggregation\n   * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.\n   */\n  setNeedsUpdate(channel) {\n    if (channel === undefined) {\n      this.needsUpdate.fill(true);\n    } else {\n      this.needsUpdate[channel] = true;\n    }\n  }\n  update() {}\n  /** Run aggregation */\n  preDraw() {\n    if (!this.needsUpdate.some(Boolean)) {\n      return;\n    }\n    const {\n      operations\n    } = this.props;\n    const operationsToUpdate = this.needsUpdate.map((needsUpdate, i) => needsUpdate ? operations[i] : null);\n    // Render data to bins\n    this.binSorter.update(operationsToUpdate);\n    // Read to buffer and calculate domain\n    this.aggregationTransform.update(this.binSorter.texture, operations);\n    for (let i = 0; i < this.channelCount; i++) {\n      if (this.needsUpdate[i]) {\n        this.needsUpdate[i] = false;\n        this.props.onUpdate?.({\n          channel: i\n        });\n      }\n    }\n    // Uncomment to debug\n    // console.log('binsFBO', new Float32Array(this.device.readPixelsToArrayWebGL(this.binSorter.texture!).buffer));\n    // console.log('binsBuffer', new Float32Array(this.aggregationTransform.binBuffer?.readSyncWebGL().buffer!));\n    // console.log('resultBuffer', new Float32Array(this.aggregationTransform.valueBuffer?.readSyncWebGL().buffer!));\n  }\n}","map":{"version":3,"names":["WebGLBinSorter","WebGLAggregationTransform","_deepEqual","deepEqual","log","WebGLAggregator","isSupported","device","features","has","constructor","props","binCount","binIds","results","dimensions","channelCount","pointCount","binIdRange","operations","attributes","binOptions","needsUpdate","Array","fill","binSorter","aggregationTransform","setProps","getBins","buffer","binBuffer","type","size","getResult","channel","valueBuffer","stride","offset","getResultDomain","domains","getBin","index","id","x0","x1","y0","width","Math","floor","pixel","getBinValues","count","value","operation","NaN","destroy","oldProps","assert","length","y1","setDimensions","setNeedsUpdate","undefined","setModelProps","vertexCount","model","shaderInputs","attributeBuffers","constantAttributes","attribute","Object","values","attributeName","entries","getValue","ArrayBuffer","isView","shaderModuleProps","assign","update","preDraw","some","Boolean","operationsToUpdate","map","i","texture","onUpdate"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\aggregation-layers\\src\\common\\aggregator\\gpu-aggregator\\webgl-aggregator.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ModelProps} from '@luma.gl/engine';\nimport {WebGLBinSorter} from './webgl-bin-sorter';\nimport {WebGLAggregationTransform} from './webgl-aggregation-transform';\nimport {_deepEqual as deepEqual, log, BinaryAttribute} from '@deck.gl/core';\n\nimport type {Aggregator, AggregationProps, AggregatedBin} from '../aggregator';\nimport type {Device, Buffer, BufferLayout, TypedArray} from '@luma.gl/core';\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\n/** Options used to construct a new WebGLAggregator */\nexport type WebGLAggregatorProps = {\n  /** Size of bin IDs */\n  dimensions: 1 | 2;\n  /** How many properties to perform aggregation on */\n  channelCount: 1 | 2 | 3;\n  /** Buffer layout for input attributes */\n  bufferLayout?: BufferLayout[];\n  /** Define a shader function with one of the signatures\n   *  `void getBin(out int binId)`: if dimensions=1\n   *  `void getBin(out ivec2 binId)`: if dimensions=2\n   * And a shader function with one of the signatures\n   *  `void getValue(out float value)`: if channelCount=1\n   *  `void getValue(out vec2 value)`: if channelCount=2\n   *  `void getValue(out vec3 value)`: if channelCount=3\n   */\n  vs: string;\n  /** Shader modules\n   * Required to support certain layer extensions (e.g. data filter)\n   */\n  modules?: ShaderModule[];\n  /** Shadertool module defines */\n  defines?: Record<string, string | number | boolean>;\n} & Partial<WebGLAggregationProps>;\n\n/** Props used to run GPU aggregation, can be changed at any time */\ntype WebGLAggregationProps = AggregationProps & {\n  /** Limits of binId defined for each dimension. Ids outside of the [start, end) are ignored.\n   */\n  binIdRange: [start: number, end: number][];\n  /** Context props passed to the shader modules */\n  shaderModuleProps?: Record<string, any>;\n};\n\n/** An Aggregator implementation that calculates aggregation on the GPU */\nexport class WebGLAggregator implements Aggregator {\n  /** Checks if the current device supports GPU aggregation */\n  static isSupported(device: Device): boolean {\n    return (\n      device.features.has('float32-renderable-webgl') &&\n      device.features.has('texture-blend-float-webgl')\n    );\n  }\n\n  readonly dimensions: 1 | 2;\n  readonly channelCount: 1 | 2 | 3;\n  binCount: number = 0;\n\n  readonly device: Device;\n  props: WebGLAggregatorProps & WebGLAggregationProps;\n\n  /** Dirty flag per channel */\n  protected needsUpdate: boolean[];\n  /** Step 1. sort data points into bins, blended using an aggregation opera†ion */\n  protected binSorter: WebGLBinSorter;\n  /** Step 2. (optional) calculate the min/max across all bins */\n  protected aggregationTransform: WebGLAggregationTransform;\n\n  /** Cached outputs */\n  protected binIds: BinaryAttribute | null = null;\n  protected results: BinaryAttribute[] = [];\n\n  constructor(device: Device, props: WebGLAggregatorProps) {\n    this.device = device;\n    this.dimensions = props.dimensions;\n    this.channelCount = props.channelCount;\n    this.props = {\n      ...props,\n      pointCount: 0,\n      binIdRange: [[0, 0]],\n      operations: [],\n      attributes: {},\n      binOptions: {}\n    };\n    this.needsUpdate = new Array(this.channelCount).fill(true);\n    this.binSorter = new WebGLBinSorter(device, props);\n    this.aggregationTransform = new WebGLAggregationTransform(device, props);\n    this.setProps(props);\n  }\n\n  getBins(): BinaryAttribute | null {\n    const buffer = this.aggregationTransform.binBuffer;\n    if (!buffer) {\n      return null;\n    }\n    if (this.binIds?.buffer !== buffer) {\n      // deck.gl Attribute.setBinaryValue uses shallow comparison to determine if attribute value has changed\n      // For performance, only create a new binary attribute descriptor when Buffer changes\n      this.binIds = {buffer, type: 'float32', size: this.dimensions};\n    }\n    return this.binIds;\n  }\n\n  /** Returns an accessor to the output for a given channel. */\n  getResult(channel: 0 | 1 | 2): BinaryAttribute | null {\n    const buffer = this.aggregationTransform.valueBuffer;\n    if (!buffer || channel >= this.channelCount) {\n      return null;\n    }\n    if (this.results[channel]?.buffer !== buffer) {\n      this.results[channel] = {\n        buffer,\n        type: 'float32',\n        size: 1,\n        stride: this.channelCount * 4,\n        offset: channel * 4\n      };\n    }\n    return this.results[channel];\n  }\n\n  /** Returns the [min, max] of aggregated values for a given channel. */\n  getResultDomain(channel: 0 | 1 | 2): [min: number, max: number] {\n    return this.aggregationTransform.domains[channel];\n  }\n\n  /** Returns the information for a given bin. */\n  getBin(index: number): AggregatedBin | null {\n    if (index < 0 || index >= this.binCount) {\n      return null;\n    }\n    const {binIdRange} = this.props;\n    let id: number[];\n\n    if (this.dimensions === 1) {\n      id = [index + binIdRange[0][0]];\n    } else {\n      const [[x0, x1], [y0]] = binIdRange;\n      const width = x1 - x0;\n      id = [(index % width) + x0, Math.floor(index / width) + y0];\n    }\n\n    const pixel = this.binSorter.getBinValues(index);\n    if (!pixel) {\n      return null;\n    }\n    const count = pixel[3];\n    const value: number[] = [];\n    for (let channel = 0; channel < this.channelCount; channel++) {\n      const operation = this.props.operations[channel];\n      if (operation === 'COUNT') {\n        value[channel] = count;\n      } else if (count === 0) {\n        value[channel] = NaN;\n      } else {\n        value[channel] = operation === 'MEAN' ? pixel[channel] / count : pixel[channel];\n      }\n    }\n    return {id, value, count};\n  }\n\n  /** Release GPU resources */\n  destroy() {\n    this.binSorter.destroy();\n    this.aggregationTransform.destroy();\n  }\n\n  /** Update aggregation props. Normalize prop values and set change flags. */\n  setProps(props: Partial<WebGLAggregationProps>) {\n    const oldProps = this.props;\n\n    // Update local settings. These will set the flag this._needsUpdate\n    if ('binIdRange' in props && !deepEqual(props.binIdRange, oldProps.binIdRange, 2)) {\n      const binIdRange = props.binIdRange!;\n      log.assert(binIdRange.length === this.dimensions);\n\n      if (this.dimensions === 1) {\n        const [[x0, x1]] = binIdRange;\n        this.binCount = x1 - x0;\n      } else {\n        const [[x0, x1], [y0, y1]] = binIdRange;\n        this.binCount = (x1 - x0) * (y1 - y0);\n      }\n\n      this.binSorter.setDimensions(this.binCount, binIdRange);\n      this.aggregationTransform.setDimensions(this.binCount, binIdRange);\n      this.setNeedsUpdate();\n    }\n    if (props.operations) {\n      for (let channel = 0; channel < this.channelCount; channel++) {\n        if (props.operations[channel] !== oldProps.operations[channel]) {\n          this.setNeedsUpdate(channel);\n        }\n      }\n    }\n    if (props.pointCount !== undefined && props.pointCount !== oldProps.pointCount) {\n      this.binSorter.setModelProps({vertexCount: props.pointCount});\n      this.setNeedsUpdate();\n    }\n    if (props.binOptions) {\n      if (!deepEqual(props.binOptions, oldProps.binOptions, 2)) {\n        this.setNeedsUpdate();\n      }\n      this.binSorter.model.shaderInputs.setProps({binOptions: props.binOptions});\n    }\n    if (props.attributes) {\n      const attributeBuffers: Record<string, Buffer> = {};\n      const constantAttributes: Record<string, TypedArray> = {};\n\n      for (const attribute of Object.values(props.attributes)) {\n        for (const [attributeName, value] of Object.entries(attribute.getValue())) {\n          if (ArrayBuffer.isView(value)) {\n            constantAttributes[attributeName] = value;\n          } else if (value) {\n            attributeBuffers[attributeName] = value;\n          }\n        }\n      }\n      this.binSorter.setModelProps({attributes: attributeBuffers, constantAttributes});\n    }\n    if (props.shaderModuleProps) {\n      this.binSorter.setModelProps({shaderModuleProps: props.shaderModuleProps});\n    }\n\n    Object.assign(this.props, props);\n  }\n\n  /** Flags a channel to need update.\n   * This is called internally by setProps() if certain props change\n   * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed\n   * the underlying buffers could have been updated and require rerunning the aggregation\n   * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.\n   */\n  setNeedsUpdate(channel?: number) {\n    if (channel === undefined) {\n      this.needsUpdate.fill(true);\n    } else {\n      this.needsUpdate[channel] = true;\n    }\n  }\n\n  update() {}\n\n  /** Run aggregation */\n  preDraw() {\n    if (!this.needsUpdate.some(Boolean)) {\n      return;\n    }\n\n    const {operations} = this.props;\n    const operationsToUpdate = this.needsUpdate.map((needsUpdate, i) =>\n      needsUpdate ? operations[i] : null\n    );\n    // Render data to bins\n    this.binSorter.update(operationsToUpdate);\n    // Read to buffer and calculate domain\n    this.aggregationTransform.update(this.binSorter.texture, operations);\n\n    for (let i = 0; i < this.channelCount; i++) {\n      if (this.needsUpdate[i]) {\n        this.needsUpdate[i] = false;\n        this.props.onUpdate?.({channel: i});\n      }\n    }\n\n    // Uncomment to debug\n    // console.log('binsFBO', new Float32Array(this.device.readPixelsToArrayWebGL(this.binSorter.texture!).buffer));\n    // console.log('binsBuffer', new Float32Array(this.aggregationTransform.binBuffer?.readSyncWebGL().buffer!));\n    // console.log('resultBuffer', new Float32Array(this.aggregationTransform.valueBuffer?.readSyncWebGL().buffer!));\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}