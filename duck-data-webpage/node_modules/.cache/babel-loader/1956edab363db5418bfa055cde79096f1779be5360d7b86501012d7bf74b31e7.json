{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport Pass from \"./pass.js\";\n/** A Pass that renders all layers */\nexport default class LayersPass extends Pass {\n  constructor() {\n    super(...arguments);\n    this._lastRenderIndex = -1;\n  }\n  render(options) {\n    // @ts-expect-error TODO - assuming WebGL context\n    const [width, height] = this.device.canvasContext.getDrawingBufferSize();\n    // Explicitly specify clearColor and clearDepth, overriding render pass defaults.\n    const clearCanvas = options.clearCanvas ?? true;\n    const clearColor = options.clearColor ?? (clearCanvas ? [0, 0, 0, 0] : false);\n    const clearDepth = clearCanvas ? 1 : false;\n    const clearStencil = clearCanvas ? 0 : false;\n    const colorMask = options.colorMask ?? 0xf;\n    const parameters = {\n      viewport: [0, 0, width, height]\n    };\n    if (options.colorMask) {\n      parameters.colorMask = colorMask;\n    }\n    if (options.scissorRect) {\n      parameters.scissorRect = options.scissorRect;\n    }\n    const renderPass = this.device.beginRenderPass({\n      framebuffer: options.target,\n      parameters,\n      clearColor: clearColor,\n      clearDepth,\n      clearStencil\n    });\n    try {\n      return this._drawLayers(renderPass, options);\n    } finally {\n      renderPass.end();\n      // TODO(ibgreen): WebGPU - submit may not be needed here but initial port had issues with out of render loop rendering\n      this.device.submit();\n    }\n  }\n  /** Draw a list of layers in a list of viewports */\n  _drawLayers(renderPass, options) {\n    const {\n      target,\n      shaderModuleProps,\n      viewports,\n      views,\n      onViewportActive,\n      clearStack = true\n    } = options;\n    options.pass = options.pass || 'unknown';\n    if (clearStack) {\n      this._lastRenderIndex = -1;\n    }\n    const renderStats = [];\n    for (const viewport of viewports) {\n      const view = views && views[viewport.id];\n      // Update context to point to this viewport\n      onViewportActive?.(viewport);\n      const drawLayerParams = this._getDrawLayerParams(viewport, options);\n      // render this viewport\n      const subViewports = viewport.subViewports || [viewport];\n      for (const subViewport of subViewports) {\n        const stats = this._drawLayersInViewport(renderPass, {\n          target,\n          shaderModuleProps,\n          viewport: subViewport,\n          view,\n          pass: options.pass,\n          layers: options.layers\n        }, drawLayerParams);\n        renderStats.push(stats);\n      }\n    }\n    return renderStats;\n  }\n  // When a viewport contains multiple subviewports (e.g. repeated web mercator map),\n  // this is only done once for the parent viewport\n  /* Resolve the parameters needed to draw each layer */\n  _getDrawLayerParams(viewport, {\n    layers,\n    pass,\n    isPicking = false,\n    layerFilter,\n    cullRect,\n    effects,\n    shaderModuleProps\n  }, /** Internal flag, true if only used to determine whether each layer should be drawn */\n  evaluateShouldDrawOnly = false) {\n    const drawLayerParams = [];\n    const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);\n    const drawContext = {\n      layer: layers[0],\n      viewport,\n      isPicking,\n      renderPass: pass,\n      cullRect\n    };\n    const layerFilterCache = {};\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex];\n      // Check if we should draw layer\n      const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);\n      const layerParam = {\n        shouldDrawLayer\n      };\n      if (shouldDrawLayer && !evaluateShouldDrawOnly) {\n        layerParam.shouldDrawLayer = true;\n        // This is the \"logical\" index for ordering this layer in the stack\n        // used to calculate polygon offsets\n        // It can be the same as another layer\n        layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);\n        layerParam.shaderModuleProps = this._getShaderModuleProps(layer, effects, pass, shaderModuleProps);\n        layerParam.layerParameters = {\n          ...layer.context.deck?.props.parameters,\n          ...this.getLayerParameters(layer, layerIndex, viewport)\n        };\n      }\n      drawLayerParams[layerIndex] = layerParam;\n    }\n    return drawLayerParams;\n  }\n  // Draws a list of layers in one viewport\n  // TODO - when picking we could completely skip rendering viewports that dont\n  // intersect with the picking rect\n  /* eslint-disable max-depth, max-statements */\n  _drawLayersInViewport(renderPass, {\n    layers,\n    shaderModuleProps: globalModuleParameters,\n    pass,\n    target,\n    viewport,\n    view\n  }, drawLayerParams) {\n    const glViewport = getGLViewport(this.device, {\n      shaderModuleProps: globalModuleParameters,\n      target,\n      viewport\n    });\n    if (view && view.props.clear) {\n      const clearOpts = view.props.clear === true ? {\n        color: true,\n        depth: true\n      } : view.props.clear;\n      const clearRenderPass = this.device.beginRenderPass({\n        framebuffer: target,\n        parameters: {\n          viewport: glViewport,\n          scissorRect: glViewport\n        },\n        clearColor: clearOpts.color ? [0, 0, 0, 0] : false,\n        clearDepth: clearOpts.depth ? 1 : false\n      });\n      clearRenderPass.end();\n    }\n    // render layers in normal colors\n    const renderStatus = {\n      totalCount: layers.length,\n      visibleCount: 0,\n      compositeCount: 0,\n      pickableCount: 0\n    };\n    renderPass.setParameters({\n      viewport: glViewport\n    });\n    // render layers in normal colors\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex];\n      const drawLayerParameters = drawLayerParams[layerIndex];\n      const {\n        shouldDrawLayer\n      } = drawLayerParameters;\n      // Calculate stats\n      if (shouldDrawLayer && layer.props.pickable) {\n        renderStatus.pickableCount++;\n      }\n      if (layer.isComposite) {\n        renderStatus.compositeCount++;\n      }\n      if (layer.isDrawable && drawLayerParameters.shouldDrawLayer) {\n        const {\n          layerRenderIndex,\n          shaderModuleProps,\n          layerParameters\n        } = drawLayerParameters;\n        // Draw the layer\n        renderStatus.visibleCount++;\n        this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);\n        // overwrite layer.context.viewport with the sub viewport\n        if (shaderModuleProps.project) {\n          shaderModuleProps.project.viewport = viewport;\n        }\n        // TODO v9 - we are sending renderPass both as a parameter and through the context.\n        // Long-term, it is likely better not to have user defined layer methods have to access\n        // the \"global\" layer context.\n        layer.context.renderPass = renderPass;\n        try {\n          layer._drawLayer({\n            renderPass,\n            shaderModuleProps,\n            uniforms: {\n              layerIndex: layerRenderIndex\n            },\n            parameters: layerParameters\n          });\n        } catch (err) {\n          layer.raiseError(err, `drawing ${layer} to ${pass}`);\n        }\n      }\n    }\n    return renderStatus;\n  }\n  /* eslint-enable max-depth, max-statements */\n  /* Methods for subclass overrides */\n  shouldDrawLayer(layer) {\n    return true;\n  }\n  getShaderModuleProps(layer, effects, otherShaderModuleProps) {\n    return null;\n  }\n  getLayerParameters(layer, layerIndex, viewport) {\n    return layer.props.parameters;\n  }\n  /* Private */\n  _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {\n    const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);\n    if (!shouldDrawLayer) {\n      return false;\n    }\n    drawContext.layer = layer;\n    let parent = layer.parent;\n    while (parent) {\n      // @ts-ignore\n      if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {\n        return false;\n      }\n      drawContext.layer = parent;\n      parent = parent.parent;\n    }\n    if (layerFilter) {\n      const rootLayerId = drawContext.layer.id;\n      if (!(rootLayerId in layerFilterCache)) {\n        layerFilterCache[rootLayerId] = layerFilter(drawContext);\n      }\n      if (!layerFilterCache[rootLayerId]) {\n        return false;\n      }\n    }\n    // If a layer is drawn, update its viewportChanged flag\n    layer.activateViewport(drawContext.viewport);\n    return true;\n  }\n  _getShaderModuleProps(layer, effects, pass, overrides) {\n    // @ts-expect-error TODO - assuming WebGL context\n    const devicePixelRatio = this.device.canvasContext.cssToDeviceRatio();\n    const layerProps = layer.internalState?.propsInTransition || layer.props;\n    const shaderModuleProps = {\n      layer: layerProps,\n      picking: {\n        isActive: false\n      },\n      project: {\n        viewport: layer.context.viewport,\n        devicePixelRatio,\n        modelMatrix: layerProps.modelMatrix,\n        coordinateSystem: layerProps.coordinateSystem,\n        coordinateOrigin: layerProps.coordinateOrigin,\n        autoWrapLongitude: layer.wrapLongitude\n      }\n    };\n    if (effects) {\n      for (const effect of effects) {\n        mergeModuleParameters(shaderModuleProps, effect.getShaderModuleProps?.(layer, shaderModuleProps));\n      }\n    }\n    return mergeModuleParameters(shaderModuleProps, this.getShaderModuleProps(layer, effects, shaderModuleProps), overrides);\n  }\n}\n// If the _index prop is defined, return a layer index that's relative to its parent\n// Otherwise return the index of the layer among all rendered layers\n// This is done recursively, i.e. if the user overrides a layer's default index,\n// all its descendants will be resolved relative to that index.\n// This implementation assumes that parent layers always appear before its children\n// which is true if the layer array comes from the LayerManager\nexport function layerIndexResolver(startIndex = 0, layerIndices = {}) {\n  const resolvers = {};\n  const resolveLayerIndex = (layer, isDrawn) => {\n    const indexOverride = layer.props._offset;\n    const layerId = layer.id;\n    const parentId = layer.parent && layer.parent.id;\n    let index;\n    if (parentId && !(parentId in layerIndices)) {\n      // Populate layerIndices with the parent layer's index\n      resolveLayerIndex(layer.parent, false);\n    }\n    if (parentId in resolvers) {\n      const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);\n      index = resolver(layer, isDrawn);\n      resolvers[layerId] = resolver;\n    } else if (Number.isFinite(indexOverride)) {\n      index = indexOverride + (layerIndices[parentId] || 0);\n      // Mark layer as needing its own resolver\n      // We don't actually create it until it's used for the first time\n      resolvers[layerId] = null;\n    } else {\n      index = startIndex;\n    }\n    if (isDrawn && index >= startIndex) {\n      startIndex = index + 1;\n    }\n    layerIndices[layerId] = index;\n    return index;\n  };\n  return resolveLayerIndex;\n}\n// Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\nfunction getGLViewport(device, {\n  shaderModuleProps,\n  target,\n  viewport\n}) {\n  const pixelRatio = shaderModuleProps?.project?.devicePixelRatio ??\n  // @ts-expect-error TODO - assuming WebGL context\n  device.canvasContext.cssToDeviceRatio();\n  // Default framebuffer is used when writing to canvas\n  // @ts-expect-error TODO - assuming WebGL context\n  const [, drawingBufferHeight] = device.canvasContext.getDrawingBufferSize();\n  const height = target ? target.height : drawingBufferHeight;\n  // Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\n  const dimensions = viewport;\n  return [dimensions.x * pixelRatio, height - (dimensions.y + dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];\n}\nfunction mergeModuleParameters(target, ...sources) {\n  for (const source of sources) {\n    if (source) {\n      for (const key in source) {\n        if (target[key]) {\n          Object.assign(target[key], source[key]);\n        } else {\n          target[key] = source[key];\n        }\n      }\n    }\n  }\n  return target;\n}","map":{"version":3,"names":["Pass","LayersPass","constructor","_lastRenderIndex","render","options","width","height","device","canvasContext","getDrawingBufferSize","clearCanvas","clearColor","clearDepth","clearStencil","colorMask","parameters","viewport","scissorRect","renderPass","beginRenderPass","framebuffer","target","_drawLayers","end","submit","shaderModuleProps","viewports","views","onViewportActive","clearStack","pass","renderStats","view","id","drawLayerParams","_getDrawLayerParams","subViewports","subViewport","stats","_drawLayersInViewport","layers","push","isPicking","layerFilter","cullRect","effects","evaluateShouldDrawOnly","indexResolver","layerIndexResolver","drawContext","layer","layerFilterCache","layerIndex","length","shouldDrawLayer","_shouldDrawLayer","layerParam","layerRenderIndex","_getShaderModuleProps","layerParameters","context","deck","props","getLayerParameters","globalModuleParameters","glViewport","getGLViewport","clear","clearOpts","color","depth","clearRenderPass","renderStatus","totalCount","visibleCount","compositeCount","pickableCount","setParameters","drawLayerParameters","pickable","isComposite","isDrawable","Math","max","project","_drawLayer","uniforms","err","raiseError","getShaderModuleProps","otherShaderModuleProps","visible","parent","filterSubLayer","rootLayerId","activateViewport","overrides","devicePixelRatio","cssToDeviceRatio","layerProps","internalState","propsInTransition","picking","isActive","modelMatrix","coordinateSystem","coordinateOrigin","autoWrapLongitude","wrapLongitude","effect","mergeModuleParameters","startIndex","layerIndices","resolvers","resolveLayerIndex","isDrawn","indexOverride","_offset","layerId","parentId","index","resolver","Number","isFinite","pixelRatio","drawingBufferHeight","dimensions","x","y","sources","source","key","Object","assign"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\passes\\layers-pass.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device, Parameters, RenderPassParameters} from '@luma.gl/core';\nimport type {Framebuffer, RenderPass} from '@luma.gl/core';\n\nimport Pass from './pass';\nimport type Viewport from '../viewports/viewport';\nimport type View from '../views/view';\nimport type Layer from '../lib/layer';\nimport type {Effect} from '../lib/effect';\nimport type {ProjectProps} from '../shaderlib/project/viewport-uniforms';\nimport type {PickingProps} from '@luma.gl/shadertools';\n\nexport type Rect = {x: number; y: number; width: number; height: number};\n\nexport type LayersPassRenderOptions = {\n  /** @deprecated TODO v9 recommend we rename this to framebuffer to minimize confusion */\n  target?: Framebuffer | null;\n  isPicking?: boolean;\n  pass: string;\n  layers: Layer[];\n  viewports: Viewport[];\n  onViewportActive?: (viewport: Viewport) => void;\n  cullRect?: Rect;\n  views?: Record<string, View>;\n  effects?: Effect[];\n  /** If true, recalculates render index (z) from 0. Set to false if a stack of layers are rendered in multiple passes. */\n  clearStack?: boolean;\n  clearCanvas?: boolean;\n  clearColor?: number[];\n  colorMask?: number;\n  scissorRect?: number[];\n  layerFilter?: ((context: FilterContext) => boolean) | null;\n  shaderModuleProps?: any;\n  /** Stores returned results from Effect.preRender, for use downstream in the render pipeline */\n  preRenderStats?: Record<string, any>;\n};\n\nexport type DrawLayerParameters = {\n  shouldDrawLayer: boolean;\n  layerRenderIndex: number;\n  shaderModuleProps: any;\n  layerParameters: Parameters;\n};\n\nexport type FilterContext = {\n  layer: Layer;\n  viewport: Viewport;\n  isPicking: boolean;\n  renderPass: string;\n  cullRect?: Rect;\n};\n\nexport type RenderStats = {\n  totalCount: number;\n  visibleCount: number;\n  compositeCount: number;\n  pickableCount: number;\n};\n\n/** A Pass that renders all layers */\nexport default class LayersPass extends Pass {\n  _lastRenderIndex: number = -1;\n\n  render(options: LayersPassRenderOptions): any {\n    // @ts-expect-error TODO - assuming WebGL context\n    const [width, height] = this.device.canvasContext.getDrawingBufferSize();\n\n    // Explicitly specify clearColor and clearDepth, overriding render pass defaults.\n    const clearCanvas = options.clearCanvas ?? true;\n    const clearColor = options.clearColor ?? (clearCanvas ? [0, 0, 0, 0] : false);\n    const clearDepth = clearCanvas ? 1 : false;\n    const clearStencil = clearCanvas ? 0 : false;\n    const colorMask = options.colorMask ?? 0xf;\n\n    const parameters: RenderPassParameters = {viewport: [0, 0, width, height]};\n    if (options.colorMask) {\n      parameters.colorMask = colorMask;\n    }\n    if (options.scissorRect) {\n      parameters.scissorRect = options.scissorRect as [number, number, number, number];\n    }\n\n    const renderPass = this.device.beginRenderPass({\n      framebuffer: options.target,\n      parameters,\n      clearColor: clearColor as [number, number, number, number],\n      clearDepth,\n      clearStencil\n    });\n\n    try {\n      return this._drawLayers(renderPass, options);\n    } finally {\n      renderPass.end();\n      // TODO(ibgreen): WebGPU - submit may not be needed here but initial port had issues with out of render loop rendering\n      this.device.submit();\n    }\n  }\n\n  /** Draw a list of layers in a list of viewports */\n  private _drawLayers(renderPass: RenderPass, options: LayersPassRenderOptions) {\n    const {\n      target,\n      shaderModuleProps,\n      viewports,\n      views,\n      onViewportActive,\n      clearStack = true\n    } = options;\n    options.pass = options.pass || 'unknown';\n\n    if (clearStack) {\n      this._lastRenderIndex = -1;\n    }\n\n    const renderStats: RenderStats[] = [];\n\n    for (const viewport of viewports) {\n      const view = views && views[viewport.id];\n\n      // Update context to point to this viewport\n      onViewportActive?.(viewport);\n\n      const drawLayerParams = this._getDrawLayerParams(viewport, options);\n\n      // render this viewport\n      const subViewports = viewport.subViewports || [viewport];\n      for (const subViewport of subViewports) {\n        const stats = this._drawLayersInViewport(\n          renderPass,\n          {\n            target,\n            shaderModuleProps,\n            viewport: subViewport,\n            view,\n            pass: options.pass,\n            layers: options.layers\n          },\n          drawLayerParams\n        );\n        renderStats.push(stats);\n      }\n    }\n    return renderStats;\n  }\n\n  // When a viewport contains multiple subviewports (e.g. repeated web mercator map),\n  // this is only done once for the parent viewport\n  /* Resolve the parameters needed to draw each layer */\n  protected _getDrawLayerParams(\n    viewport: Viewport,\n    {\n      layers,\n      pass,\n      isPicking = false,\n      layerFilter,\n      cullRect,\n      effects,\n      shaderModuleProps\n    }: LayersPassRenderOptions,\n    /** Internal flag, true if only used to determine whether each layer should be drawn */\n    evaluateShouldDrawOnly: boolean = false\n  ): DrawLayerParameters[] {\n    const drawLayerParams: DrawLayerParameters[] = [];\n    const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);\n    const drawContext: FilterContext = {\n      layer: layers[0],\n      viewport,\n      isPicking,\n      renderPass: pass,\n      cullRect\n    };\n    const layerFilterCache = {};\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex];\n      // Check if we should draw layer\n      const shouldDrawLayer = this._shouldDrawLayer(\n        layer,\n        drawContext,\n        layerFilter,\n        layerFilterCache\n      );\n\n      const layerParam = {shouldDrawLayer} as DrawLayerParameters;\n\n      if (shouldDrawLayer && !evaluateShouldDrawOnly) {\n        layerParam.shouldDrawLayer = true;\n\n        // This is the \"logical\" index for ordering this layer in the stack\n        // used to calculate polygon offsets\n        // It can be the same as another layer\n        layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);\n\n        layerParam.shaderModuleProps = this._getShaderModuleProps(\n          layer,\n          effects,\n          pass,\n          shaderModuleProps\n        );\n        layerParam.layerParameters = {\n          ...layer.context.deck?.props.parameters,\n          ...this.getLayerParameters(layer, layerIndex, viewport)\n        };\n      }\n\n      drawLayerParams[layerIndex] = layerParam;\n    }\n    return drawLayerParams;\n  }\n\n  // Draws a list of layers in one viewport\n  // TODO - when picking we could completely skip rendering viewports that dont\n  // intersect with the picking rect\n  /* eslint-disable max-depth, max-statements */\n  private _drawLayersInViewport(\n    renderPass: RenderPass,\n    {layers, shaderModuleProps: globalModuleParameters, pass, target, viewport, view},\n    drawLayerParams: DrawLayerParameters[]\n  ): RenderStats {\n    const glViewport = getGLViewport(this.device, {\n      shaderModuleProps: globalModuleParameters,\n      target,\n      viewport\n    });\n\n    if (view && view.props.clear) {\n      const clearOpts = view.props.clear === true ? {color: true, depth: true} : view.props.clear;\n      const clearRenderPass = this.device.beginRenderPass({\n        framebuffer: target,\n        parameters: {\n          viewport: glViewport,\n          scissorRect: glViewport\n        },\n        clearColor: clearOpts.color ? [0, 0, 0, 0] : false,\n        clearDepth: clearOpts.depth ? 1 : false\n      });\n      clearRenderPass.end();\n    }\n\n    // render layers in normal colors\n    const renderStatus = {\n      totalCount: layers.length,\n      visibleCount: 0,\n      compositeCount: 0,\n      pickableCount: 0\n    };\n\n    renderPass.setParameters({viewport: glViewport});\n\n    // render layers in normal colors\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex] as Layer;\n      const drawLayerParameters = drawLayerParams[layerIndex];\n      const {shouldDrawLayer} = drawLayerParameters;\n\n      // Calculate stats\n      if (shouldDrawLayer && layer.props.pickable) {\n        renderStatus.pickableCount++;\n      }\n      if (layer.isComposite) {\n        renderStatus.compositeCount++;\n      }\n      if (layer.isDrawable && drawLayerParameters.shouldDrawLayer) {\n        const {layerRenderIndex, shaderModuleProps, layerParameters} = drawLayerParameters;\n        // Draw the layer\n        renderStatus.visibleCount++;\n\n        this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);\n\n        // overwrite layer.context.viewport with the sub viewport\n        if (shaderModuleProps.project) {\n          shaderModuleProps.project.viewport = viewport;\n        }\n\n        // TODO v9 - we are sending renderPass both as a parameter and through the context.\n        // Long-term, it is likely better not to have user defined layer methods have to access\n        // the \"global\" layer context.\n        layer.context.renderPass = renderPass;\n\n        try {\n          layer._drawLayer({\n            renderPass,\n            shaderModuleProps,\n            uniforms: {layerIndex: layerRenderIndex},\n            parameters: layerParameters\n          });\n        } catch (err) {\n          layer.raiseError(err as Error, `drawing ${layer} to ${pass}`);\n        }\n      }\n    }\n\n    return renderStatus;\n  }\n  /* eslint-enable max-depth, max-statements */\n\n  /* Methods for subclass overrides */\n  shouldDrawLayer(layer: Layer): boolean {\n    return true;\n  }\n\n  protected getShaderModuleProps(\n    layer: Layer,\n    effects: Effect[] | undefined,\n    otherShaderModuleProps: Record<string, any>\n  ): any {\n    return null;\n  }\n\n  protected getLayerParameters(layer: Layer, layerIndex: number, viewport: Viewport): Parameters {\n    return layer.props.parameters;\n  }\n\n  /* Private */\n  private _shouldDrawLayer(\n    layer: Layer,\n    drawContext: FilterContext,\n    layerFilter: ((params: FilterContext) => boolean) | undefined | null,\n    layerFilterCache: Record<string, boolean>\n  ) {\n    const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);\n\n    if (!shouldDrawLayer) {\n      return false;\n    }\n\n    drawContext.layer = layer;\n\n    let parent = layer.parent;\n    while (parent) {\n      // @ts-ignore\n      if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {\n        return false;\n      }\n      drawContext.layer = parent;\n      parent = parent.parent;\n    }\n\n    if (layerFilter) {\n      const rootLayerId = drawContext.layer.id;\n      if (!(rootLayerId in layerFilterCache)) {\n        layerFilterCache[rootLayerId] = layerFilter(drawContext);\n      }\n      if (!layerFilterCache[rootLayerId]) {\n        return false;\n      }\n    }\n\n    // If a layer is drawn, update its viewportChanged flag\n    layer.activateViewport(drawContext.viewport);\n\n    return true;\n  }\n\n  private _getShaderModuleProps(\n    layer: Layer,\n    effects: Effect[] | undefined,\n    pass: string,\n    overrides: any\n  ): any {\n    // @ts-expect-error TODO - assuming WebGL context\n    const devicePixelRatio = this.device.canvasContext.cssToDeviceRatio();\n    const layerProps = layer.internalState?.propsInTransition || layer.props;\n\n    const shaderModuleProps = {\n      layer: layerProps,\n      picking: {\n        isActive: false\n      } satisfies PickingProps,\n      project: {\n        viewport: layer.context.viewport,\n        devicePixelRatio,\n        modelMatrix: layerProps.modelMatrix,\n        coordinateSystem: layerProps.coordinateSystem,\n        coordinateOrigin: layerProps.coordinateOrigin,\n        autoWrapLongitude: layer.wrapLongitude\n      } satisfies ProjectProps\n    };\n\n    if (effects) {\n      for (const effect of effects) {\n        mergeModuleParameters(\n          shaderModuleProps,\n          effect.getShaderModuleProps?.(layer, shaderModuleProps)\n        );\n      }\n    }\n\n    return mergeModuleParameters(\n      shaderModuleProps,\n      this.getShaderModuleProps(layer, effects, shaderModuleProps),\n      overrides\n    );\n  }\n}\n\n// If the _index prop is defined, return a layer index that's relative to its parent\n// Otherwise return the index of the layer among all rendered layers\n// This is done recursively, i.e. if the user overrides a layer's default index,\n// all its descendants will be resolved relative to that index.\n// This implementation assumes that parent layers always appear before its children\n// which is true if the layer array comes from the LayerManager\nexport function layerIndexResolver(\n  startIndex: number = 0,\n  layerIndices: Record<string, number> = {}\n): (layer: Layer, isDrawn: boolean) => number {\n  const resolvers = {};\n\n  const resolveLayerIndex = (layer, isDrawn) => {\n    const indexOverride = layer.props._offset;\n    const layerId = layer.id;\n    const parentId = layer.parent && layer.parent.id;\n\n    let index;\n\n    if (parentId && !(parentId in layerIndices)) {\n      // Populate layerIndices with the parent layer's index\n      resolveLayerIndex(layer.parent, false);\n    }\n\n    if (parentId in resolvers) {\n      const resolver = (resolvers[parentId] =\n        resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices));\n      index = resolver(layer, isDrawn);\n      resolvers[layerId] = resolver;\n    } else if (Number.isFinite(indexOverride)) {\n      index = indexOverride + (layerIndices[parentId] || 0);\n      // Mark layer as needing its own resolver\n      // We don't actually create it until it's used for the first time\n      resolvers[layerId] = null;\n    } else {\n      index = startIndex;\n    }\n\n    if (isDrawn && index >= startIndex) {\n      startIndex = index + 1;\n    }\n\n    layerIndices[layerId] = index;\n    return index;\n  };\n  return resolveLayerIndex;\n}\n\n// Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\nfunction getGLViewport(\n  device: Device,\n  {\n    shaderModuleProps,\n    target,\n    viewport\n  }: {\n    shaderModuleProps: any;\n    target?: Framebuffer;\n    viewport: Viewport;\n  }\n): [number, number, number, number] {\n  const pixelRatio =\n    shaderModuleProps?.project?.devicePixelRatio ??\n    // @ts-expect-error TODO - assuming WebGL context\n    device.canvasContext.cssToDeviceRatio();\n\n  // Default framebuffer is used when writing to canvas\n  // @ts-expect-error TODO - assuming WebGL context\n  const [, drawingBufferHeight] = device.canvasContext.getDrawingBufferSize();\n  const height = target ? target.height : drawingBufferHeight;\n\n  // Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\n  const dimensions = viewport;\n  return [\n    dimensions.x * pixelRatio,\n    height - (dimensions.y + dimensions.height) * pixelRatio,\n    dimensions.width * pixelRatio,\n    dimensions.height * pixelRatio\n  ];\n}\n\nfunction mergeModuleParameters(\n  target: Record<string, any>,\n  ...sources: Record<string, any>[]\n): Record<string, any> {\n  for (const source of sources) {\n    if (source) {\n      for (const key in source) {\n        if (target[key]) {\n          Object.assign(target[key], source[key]);\n        } else {\n          target[key] = source[key];\n        }\n      }\n    }\n  }\n  return target;\n}\n"],"mappings":"AAAA;AACA;AACA;AAKA,OAAOA,IAAI;AAuDX;AACA,eAAc,MAAOC,UAAW,SAAQD,IAAI;EAA5CE,YAAA;;IACE,KAAAC,gBAAgB,GAAW,CAAC,CAAC;EA6U/B;EA3UEC,MAAMA,CAACC,OAAgC;IACrC;IACA,MAAM,CAACC,KAAK,EAAEC,MAAM,CAAC,GAAG,IAAI,CAACC,MAAM,CAACC,aAAa,CAACC,oBAAoB,EAAE;IAExE;IACA,MAAMC,WAAW,GAAGN,OAAO,CAACM,WAAW,IAAI,IAAI;IAC/C,MAAMC,UAAU,GAAGP,OAAO,CAACO,UAAU,KAAKD,WAAW,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,KAAK,CAAC;IAC7E,MAAME,UAAU,GAAGF,WAAW,GAAG,CAAC,GAAG,KAAK;IAC1C,MAAMG,YAAY,GAAGH,WAAW,GAAG,CAAC,GAAG,KAAK;IAC5C,MAAMI,SAAS,GAAGV,OAAO,CAACU,SAAS,IAAI,GAAG;IAE1C,MAAMC,UAAU,GAAyB;MAACC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAEX,KAAK,EAAEC,MAAM;IAAC,CAAC;IAC1E,IAAIF,OAAO,CAACU,SAAS,EAAE;MACrBC,UAAU,CAACD,SAAS,GAAGA,SAAS;IAClC;IACA,IAAIV,OAAO,CAACa,WAAW,EAAE;MACvBF,UAAU,CAACE,WAAW,GAAGb,OAAO,CAACa,WAA+C;IAClF;IAEA,MAAMC,UAAU,GAAG,IAAI,CAACX,MAAM,CAACY,eAAe,CAAC;MAC7CC,WAAW,EAAEhB,OAAO,CAACiB,MAAM;MAC3BN,UAAU;MACVJ,UAAU,EAAEA,UAA8C;MAC1DC,UAAU;MACVC;KACD,CAAC;IAEF,IAAI;MACF,OAAO,IAAI,CAACS,WAAW,CAACJ,UAAU,EAAEd,OAAO,CAAC;IAC9C,CAAC,SAAS;MACRc,UAAU,CAACK,GAAG,EAAE;MAChB;MACA,IAAI,CAAChB,MAAM,CAACiB,MAAM,EAAE;IACtB;EACF;EAEA;EACQF,WAAWA,CAACJ,UAAsB,EAAEd,OAAgC;IAC1E,MAAM;MACJiB,MAAM;MACNI,iBAAiB;MACjBC,SAAS;MACTC,KAAK;MACLC,gBAAgB;MAChBC,UAAU,GAAG;IAAI,CAClB,GAAGzB,OAAO;IACXA,OAAO,CAAC0B,IAAI,GAAG1B,OAAO,CAAC0B,IAAI,IAAI,SAAS;IAExC,IAAID,UAAU,EAAE;MACd,IAAI,CAAC3B,gBAAgB,GAAG,CAAC,CAAC;IAC5B;IAEA,MAAM6B,WAAW,GAAkB,EAAE;IAErC,KAAK,MAAMf,QAAQ,IAAIU,SAAS,EAAE;MAChC,MAAMM,IAAI,GAAGL,KAAK,IAAIA,KAAK,CAACX,QAAQ,CAACiB,EAAE,CAAC;MAExC;MACAL,gBAAgB,GAAGZ,QAAQ,CAAC;MAE5B,MAAMkB,eAAe,GAAG,IAAI,CAACC,mBAAmB,CAACnB,QAAQ,EAAEZ,OAAO,CAAC;MAEnE;MACA,MAAMgC,YAAY,GAAGpB,QAAQ,CAACoB,YAAY,IAAI,CAACpB,QAAQ,CAAC;MACxD,KAAK,MAAMqB,WAAW,IAAID,YAAY,EAAE;QACtC,MAAME,KAAK,GAAG,IAAI,CAACC,qBAAqB,CACtCrB,UAAU,EACV;UACEG,MAAM;UACNI,iBAAiB;UACjBT,QAAQ,EAAEqB,WAAW;UACrBL,IAAI;UACJF,IAAI,EAAE1B,OAAO,CAAC0B,IAAI;UAClBU,MAAM,EAAEpC,OAAO,CAACoC;SACjB,EACDN,eAAe,CAChB;QACDH,WAAW,CAACU,IAAI,CAACH,KAAK,CAAC;MACzB;IACF;IACA,OAAOP,WAAW;EACpB;EAEA;EACA;EACA;EACUI,mBAAmBA,CAC3BnB,QAAkB,EAClB;IACEwB,MAAM;IACNV,IAAI;IACJY,SAAS,GAAG,KAAK;IACjBC,WAAW;IACXC,QAAQ;IACRC,OAAO;IACPpB;EAAiB,CACO,EAC1B;EACAqB,sBAAA,GAAkC,KAAK;IAEvC,MAAMZ,eAAe,GAA0B,EAAE;IACjD,MAAMa,aAAa,GAAGC,kBAAkB,CAAC,IAAI,CAAC9C,gBAAgB,GAAG,CAAC,CAAC;IACnE,MAAM+C,WAAW,GAAkB;MACjCC,KAAK,EAAEV,MAAM,CAAC,CAAC,CAAC;MAChBxB,QAAQ;MACR0B,SAAS;MACTxB,UAAU,EAAEY,IAAI;MAChBc;KACD;IACD,MAAMO,gBAAgB,GAAG,EAAE;IAC3B,KAAK,IAAIC,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAGZ,MAAM,CAACa,MAAM,EAAED,UAAU,EAAE,EAAE;MACjE,MAAMF,KAAK,GAAGV,MAAM,CAACY,UAAU,CAAC;MAChC;MACA,MAAME,eAAe,GAAG,IAAI,CAACC,gBAAgB,CAC3CL,KAAK,EACLD,WAAW,EACXN,WAAW,EACXQ,gBAAgB,CACjB;MAED,MAAMK,UAAU,GAAG;QAACF;MAAe,CAAwB;MAE3D,IAAIA,eAAe,IAAI,CAACR,sBAAsB,EAAE;QAC9CU,UAAU,CAACF,eAAe,GAAG,IAAI;QAEjC;QACA;QACA;QACAE,UAAU,CAACC,gBAAgB,GAAGV,aAAa,CAACG,KAAK,EAAEI,eAAe,CAAC;QAEnEE,UAAU,CAAC/B,iBAAiB,GAAG,IAAI,CAACiC,qBAAqB,CACvDR,KAAK,EACLL,OAAO,EACPf,IAAI,EACJL,iBAAiB,CAClB;QACD+B,UAAU,CAACG,eAAe,GAAG;UAC3B,GAAGT,KAAK,CAACU,OAAO,CAACC,IAAI,EAAEC,KAAK,CAAC/C,UAAU;UACvC,GAAG,IAAI,CAACgD,kBAAkB,CAACb,KAAK,EAAEE,UAAU,EAAEpC,QAAQ;SACvD;MACH;MAEAkB,eAAe,CAACkB,UAAU,CAAC,GAAGI,UAAU;IAC1C;IACA,OAAOtB,eAAe;EACxB;EAEA;EACA;EACA;EACA;EACQK,qBAAqBA,CAC3BrB,UAAsB,EACtB;IAACsB,MAAM;IAAEf,iBAAiB,EAAEuC,sBAAsB;IAAElC,IAAI;IAAET,MAAM;IAAEL,QAAQ;IAAEgB;EAAI,CAAC,EACjFE,eAAsC;IAEtC,MAAM+B,UAAU,GAAGC,aAAa,CAAC,IAAI,CAAC3D,MAAM,EAAE;MAC5CkB,iBAAiB,EAAEuC,sBAAsB;MACzC3C,MAAM;MACNL;KACD,CAAC;IAEF,IAAIgB,IAAI,IAAIA,IAAI,CAAC8B,KAAK,CAACK,KAAK,EAAE;MAC5B,MAAMC,SAAS,GAAGpC,IAAI,CAAC8B,KAAK,CAACK,KAAK,KAAK,IAAI,GAAG;QAACE,KAAK,EAAE,IAAI;QAAEC,KAAK,EAAE;MAAI,CAAC,GAAGtC,IAAI,CAAC8B,KAAK,CAACK,KAAK;MAC3F,MAAMI,eAAe,GAAG,IAAI,CAAChE,MAAM,CAACY,eAAe,CAAC;QAClDC,WAAW,EAAEC,MAAM;QACnBN,UAAU,EAAE;UACVC,QAAQ,EAAEiD,UAAU;UACpBhD,WAAW,EAAEgD;SACd;QACDtD,UAAU,EAAEyD,SAAS,CAACC,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,KAAK;QAClDzD,UAAU,EAAEwD,SAAS,CAACE,KAAK,GAAG,CAAC,GAAG;OACnC,CAAC;MACFC,eAAe,CAAChD,GAAG,EAAE;IACvB;IAEA;IACA,MAAMiD,YAAY,GAAG;MACnBC,UAAU,EAAEjC,MAAM,CAACa,MAAM;MACzBqB,YAAY,EAAE,CAAC;MACfC,cAAc,EAAE,CAAC;MACjBC,aAAa,EAAE;KAChB;IAED1D,UAAU,CAAC2D,aAAa,CAAC;MAAC7D,QAAQ,EAAEiD;IAAU,CAAC,CAAC;IAEhD;IACA,KAAK,IAAIb,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAGZ,MAAM,CAACa,MAAM,EAAED,UAAU,EAAE,EAAE;MACjE,MAAMF,KAAK,GAAGV,MAAM,CAACY,UAAU,CAAU;MACzC,MAAM0B,mBAAmB,GAAG5C,eAAe,CAACkB,UAAU,CAAC;MACvD,MAAM;QAACE;MAAe,CAAC,GAAGwB,mBAAmB;MAE7C;MACA,IAAIxB,eAAe,IAAIJ,KAAK,CAACY,KAAK,CAACiB,QAAQ,EAAE;QAC3CP,YAAY,CAACI,aAAa,EAAE;MAC9B;MACA,IAAI1B,KAAK,CAAC8B,WAAW,EAAE;QACrBR,YAAY,CAACG,cAAc,EAAE;MAC/B;MACA,IAAIzB,KAAK,CAAC+B,UAAU,IAAIH,mBAAmB,CAACxB,eAAe,EAAE;QAC3D,MAAM;UAACG,gBAAgB;UAAEhC,iBAAiB;UAAEkC;QAAe,CAAC,GAAGmB,mBAAmB;QAClF;QACAN,YAAY,CAACE,YAAY,EAAE;QAE3B,IAAI,CAACxE,gBAAgB,GAAGgF,IAAI,CAACC,GAAG,CAAC,IAAI,CAACjF,gBAAgB,EAAEuD,gBAAgB,CAAC;QAEzE;QACA,IAAIhC,iBAAiB,CAAC2D,OAAO,EAAE;UAC7B3D,iBAAiB,CAAC2D,OAAO,CAACpE,QAAQ,GAAGA,QAAQ;QAC/C;QAEA;QACA;QACA;QACAkC,KAAK,CAACU,OAAO,CAAC1C,UAAU,GAAGA,UAAU;QAErC,IAAI;UACFgC,KAAK,CAACmC,UAAU,CAAC;YACfnE,UAAU;YACVO,iBAAiB;YACjB6D,QAAQ,EAAE;cAAClC,UAAU,EAAEK;YAAgB,CAAC;YACxC1C,UAAU,EAAE4C;WACb,CAAC;QACJ,CAAC,CAAC,OAAO4B,GAAG,EAAE;UACZrC,KAAK,CAACsC,UAAU,CAACD,GAAY,EAAE,WAAWrC,KAAK,OAAOpB,IAAI,EAAE,CAAC;QAC/D;MACF;IACF;IAEA,OAAO0C,YAAY;EACrB;EACA;EAEA;EACAlB,eAAeA,CAACJ,KAAY;IAC1B,OAAO,IAAI;EACb;EAEUuC,oBAAoBA,CAC5BvC,KAAY,EACZL,OAA6B,EAC7B6C,sBAA2C;IAE3C,OAAO,IAAI;EACb;EAEU3B,kBAAkBA,CAACb,KAAY,EAAEE,UAAkB,EAAEpC,QAAkB;IAC/E,OAAOkC,KAAK,CAACY,KAAK,CAAC/C,UAAU;EAC/B;EAEA;EACQwC,gBAAgBA,CACtBL,KAAY,EACZD,WAA0B,EAC1BN,WAAoE,EACpEQ,gBAAyC;IAEzC,MAAMG,eAAe,GAAGJ,KAAK,CAACY,KAAK,CAAC6B,OAAO,IAAI,IAAI,CAACrC,eAAe,CAACJ,KAAK,CAAC;IAE1E,IAAI,CAACI,eAAe,EAAE;MACpB,OAAO,KAAK;IACd;IAEAL,WAAW,CAACC,KAAK,GAAGA,KAAK;IAEzB,IAAI0C,MAAM,GAAG1C,KAAK,CAAC0C,MAAM;IACzB,OAAOA,MAAM,EAAE;MACb;MACA,IAAI,CAACA,MAAM,CAAC9B,KAAK,CAAC6B,OAAO,IAAI,CAACC,MAAM,CAACC,cAAc,CAAC5C,WAAW,CAAC,EAAE;QAChE,OAAO,KAAK;MACd;MACAA,WAAW,CAACC,KAAK,GAAG0C,MAAM;MAC1BA,MAAM,GAAGA,MAAM,CAACA,MAAM;IACxB;IAEA,IAAIjD,WAAW,EAAE;MACf,MAAMmD,WAAW,GAAG7C,WAAW,CAACC,KAAK,CAACjB,EAAE;MACxC,IAAI,EAAE6D,WAAW,IAAI3C,gBAAgB,CAAC,EAAE;QACtCA,gBAAgB,CAAC2C,WAAW,CAAC,GAAGnD,WAAW,CAACM,WAAW,CAAC;MAC1D;MACA,IAAI,CAACE,gBAAgB,CAAC2C,WAAW,CAAC,EAAE;QAClC,OAAO,KAAK;MACd;IACF;IAEA;IACA5C,KAAK,CAAC6C,gBAAgB,CAAC9C,WAAW,CAACjC,QAAQ,CAAC;IAE5C,OAAO,IAAI;EACb;EAEQ0C,qBAAqBA,CAC3BR,KAAY,EACZL,OAA6B,EAC7Bf,IAAY,EACZkE,SAAc;IAEd;IACA,MAAMC,gBAAgB,GAAG,IAAI,CAAC1F,MAAM,CAACC,aAAa,CAAC0F,gBAAgB,EAAE;IACrE,MAAMC,UAAU,GAAGjD,KAAK,CAACkD,aAAa,EAAEC,iBAAiB,IAAInD,KAAK,CAACY,KAAK;IAExE,MAAMrC,iBAAiB,GAAG;MACxByB,KAAK,EAAEiD,UAAU;MACjBG,OAAO,EAAE;QACPC,QAAQ,EAAE;OACY;MACxBnB,OAAO,EAAE;QACPpE,QAAQ,EAAEkC,KAAK,CAACU,OAAO,CAAC5C,QAAQ;QAChCiF,gBAAgB;QAChBO,WAAW,EAAEL,UAAU,CAACK,WAAW;QACnCC,gBAAgB,EAAEN,UAAU,CAACM,gBAAgB;QAC7CC,gBAAgB,EAAEP,UAAU,CAACO,gBAAgB;QAC7CC,iBAAiB,EAAEzD,KAAK,CAAC0D;;KAE5B;IAED,IAAI/D,OAAO,EAAE;MACX,KAAK,MAAMgE,MAAM,IAAIhE,OAAO,EAAE;QAC5BiE,qBAAqB,CACnBrF,iBAAiB,EACjBoF,MAAM,CAACpB,oBAAoB,GAAGvC,KAAK,EAAEzB,iBAAiB,CAAC,CACxD;MACH;IACF;IAEA,OAAOqF,qBAAqB,CAC1BrF,iBAAiB,EACjB,IAAI,CAACgE,oBAAoB,CAACvC,KAAK,EAAEL,OAAO,EAAEpB,iBAAiB,CAAC,EAC5DuE,SAAS,CACV;EACH;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA,OAAM,SAAUhD,kBAAkBA,CAChC+D,UAAA,GAAqB,CAAC,EACtBC,YAAA,GAAuC,EAAE;EAEzC,MAAMC,SAAS,GAAG,EAAE;EAEpB,MAAMC,iBAAiB,GAAGA,CAAChE,KAAK,EAAEiE,OAAO,KAAI;IAC3C,MAAMC,aAAa,GAAGlE,KAAK,CAACY,KAAK,CAACuD,OAAO;IACzC,MAAMC,OAAO,GAAGpE,KAAK,CAACjB,EAAE;IACxB,MAAMsF,QAAQ,GAAGrE,KAAK,CAAC0C,MAAM,IAAI1C,KAAK,CAAC0C,MAAM,CAAC3D,EAAE;IAEhD,IAAIuF,KAAK;IAET,IAAID,QAAQ,IAAI,EAAEA,QAAQ,IAAIP,YAAY,CAAC,EAAE;MAC3C;MACAE,iBAAiB,CAAChE,KAAK,CAAC0C,MAAM,EAAE,KAAK,CAAC;IACxC;IAEA,IAAI2B,QAAQ,IAAIN,SAAS,EAAE;MACzB,MAAMQ,QAAQ,GAAIR,SAAS,CAACM,QAAQ,CAAC,GACnCN,SAAS,CAACM,QAAQ,CAAC,IAAIvE,kBAAkB,CAACgE,YAAY,CAACO,QAAQ,CAAC,EAAEP,YAAY,CAAE;MAClFQ,KAAK,GAAGC,QAAQ,CAACvE,KAAK,EAAEiE,OAAO,CAAC;MAChCF,SAAS,CAACK,OAAO,CAAC,GAAGG,QAAQ;IAC/B,CAAC,MAAM,IAAIC,MAAM,CAACC,QAAQ,CAACP,aAAa,CAAC,EAAE;MACzCI,KAAK,GAAGJ,aAAa,IAAIJ,YAAY,CAACO,QAAQ,CAAC,IAAI,CAAC,CAAC;MACrD;MACA;MACAN,SAAS,CAACK,OAAO,CAAC,GAAG,IAAI;IAC3B,CAAC,MAAM;MACLE,KAAK,GAAGT,UAAU;IACpB;IAEA,IAAII,OAAO,IAAIK,KAAK,IAAIT,UAAU,EAAE;MAClCA,UAAU,GAAGS,KAAK,GAAG,CAAC;IACxB;IAEAR,YAAY,CAACM,OAAO,CAAC,GAAGE,KAAK;IAC7B,OAAOA,KAAK;EACd,CAAC;EACD,OAAON,iBAAiB;AAC1B;AAEA;AACA,SAAShD,aAAaA,CACpB3D,MAAc,EACd;EACEkB,iBAAiB;EACjBJ,MAAM;EACNL;AAAQ,CAKT;EAED,MAAM4G,UAAU,GACdnG,iBAAiB,EAAE2D,OAAO,EAAEa,gBAAgB;EAC5C;EACA1F,MAAM,CAACC,aAAa,CAAC0F,gBAAgB,EAAE;EAEzC;EACA;EACA,MAAM,GAAG2B,mBAAmB,CAAC,GAAGtH,MAAM,CAACC,aAAa,CAACC,oBAAoB,EAAE;EAC3E,MAAMH,MAAM,GAAGe,MAAM,GAAGA,MAAM,CAACf,MAAM,GAAGuH,mBAAmB;EAE3D;EACA,MAAMC,UAAU,GAAG9G,QAAQ;EAC3B,OAAO,CACL8G,UAAU,CAACC,CAAC,GAAGH,UAAU,EACzBtH,MAAM,GAAG,CAACwH,UAAU,CAACE,CAAC,GAAGF,UAAU,CAACxH,MAAM,IAAIsH,UAAU,EACxDE,UAAU,CAACzH,KAAK,GAAGuH,UAAU,EAC7BE,UAAU,CAACxH,MAAM,GAAGsH,UAAU,CAC/B;AACH;AAEA,SAASd,qBAAqBA,CAC5BzF,MAA2B,EAC3B,GAAG4G,OAA8B;EAEjC,KAAK,MAAMC,MAAM,IAAID,OAAO,EAAE;IAC5B,IAAIC,MAAM,EAAE;MACV,KAAK,MAAMC,GAAG,IAAID,MAAM,EAAE;QACxB,IAAI7G,MAAM,CAAC8G,GAAG,CAAC,EAAE;UACfC,MAAM,CAACC,MAAM,CAAChH,MAAM,CAAC8G,GAAG,CAAC,EAAED,MAAM,CAACC,GAAG,CAAC,CAAC;QACzC,CAAC,MAAM;UACL9G,MAAM,CAAC8G,GAAG,CAAC,GAAGD,MAAM,CAACC,GAAG,CAAC;QAC3B;MACF;IACF;EACF;EACA,OAAO9G,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}