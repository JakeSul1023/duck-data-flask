{"ast":null,"code":"// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { Stats } from '@probe.gl/stats';\nimport { RequestScheduler, path } from '@loaders.gl/loader-utils';\nimport { TilesetCache } from \"./tileset-cache.js\";\nimport { calculateTransformProps } from \"./helpers/transform-utils.js\";\nimport { getFrameState, limitSelectedTiles } from \"./helpers/frame-state.js\";\nimport { getZoomFromBoundingVolume, getZoomFromExtent, getZoomFromFullExtent } from \"./helpers/zoom.js\";\nimport { Tile3D } from \"./tile-3d.js\";\nimport { TILESET_TYPE } from \"../constants.js\";\nimport { TilesetTraverser } from \"./tileset-traverser.js\";\n// TODO - these should be moved into their respective modules\nimport { Tileset3DTraverser } from \"./format-3d-tiles/tileset-3d-traverser.js\";\nimport { I3STilesetTraverser } from \"./format-i3s/i3s-tileset-traverser.js\";\nconst DEFAULT_PROPS = {\n  description: '',\n  ellipsoid: Ellipsoid.WGS84,\n  modelMatrix: new Matrix4(),\n  throttleRequests: true,\n  maxRequests: 64,\n  /** Default memory values optimized for viewing mesh-based 3D Tiles on both mobile and desktop devices */\n  maximumMemoryUsage: 32,\n  memoryCacheOverflow: 1,\n  maximumTilesSelected: 0,\n  debounceTime: 0,\n  onTileLoad: () => {},\n  onTileUnload: () => {},\n  onTileError: () => {},\n  onTraversalComplete: selectedTiles => selectedTiles,\n  contentLoader: undefined,\n  viewDistanceScale: 1.0,\n  maximumScreenSpaceError: 8,\n  memoryAdjustedScreenSpaceError: false,\n  loadTiles: true,\n  updateTransforms: true,\n  viewportTraversersMap: null,\n  loadOptions: {\n    fetch: {}\n  },\n  attributions: [],\n  basePath: '',\n  i3s: {}\n};\n// Tracked Stats\nconst TILES_TOTAL = 'Tiles In Tileset(s)';\nconst TILES_IN_MEMORY = 'Tiles In Memory';\nconst TILES_IN_VIEW = 'Tiles In View';\nconst TILES_RENDERABLE = 'Tiles To Render';\nconst TILES_LOADED = 'Tiles Loaded';\nconst TILES_LOADING = 'Tiles Loading';\nconst TILES_UNLOADED = 'Tiles Unloaded';\nconst TILES_LOAD_FAILED = 'Failed Tile Loads';\nconst POINTS_COUNT = 'Points/Vertices';\nconst TILES_GPU_MEMORY = 'Tile Memory Use';\nconst MAXIMUM_SSE = 'Maximum Screen Space Error';\n/**\n * The Tileset loading and rendering flow is as below,\n * A rendered (i.e. deck.gl `Tile3DLayer`) triggers `tileset.update()` after a `tileset` is loaded\n * `tileset` starts traversing the tile tree and update `requestTiles` (tiles of which content need\n * to be fetched) and `selectedTiles` (tiles ready for rendering under the current viewport).\n * `Tile3DLayer` will update rendering based on `selectedTiles`.\n * `Tile3DLayer` also listens to `onTileLoad` callback and trigger another round of `update and then traversal`\n * when new tiles are loaded.\n\n * As I3S tileset have stored `tileHeader` file (metadata) and tile content files (geometry, texture, ...) separately.\n * During each traversal, it issues `tilHeader` requests if that `tileHeader` is not yet fetched,\n * after the tile header is fulfilled, it will resume the traversal starting from the tile just fetched (not root).\n\n * Tile3DLayer\n *      |\n *  await load(tileset)\n *      |\n *  tileset.update()\n *      |                async load tileHeader\n *  tileset.traverse() -------------------------- Queued\n *      |        resume traversal after fetched  |\n *      |----------------------------------------|\n *      |\n *      |                     async load tile content\n * tilset.requestedTiles  ----------------------------- RequestScheduler\n *                                                             |\n * tilset.selectedTiles (ready for rendering)                  |\n *      |         Listen to                                    |\n *   Tile3DLayer ----------- onTileLoad  ----------------------|\n *      |                         |   notify new tile is available\n *   updateLayers                 |\n *                       tileset.update // trigger another round of update\n*/\nexport class Tileset3D {\n  // props: Tileset3DProps;\n  options;\n  loadOptions;\n  type;\n  tileset;\n  loader;\n  url;\n  basePath;\n  modelMatrix;\n  ellipsoid;\n  lodMetricType;\n  lodMetricValue;\n  refine;\n  root = null;\n  roots = {};\n  /** @todo any->unknown */\n  asset = {};\n  // Metadata for the entire tileset\n  description = '';\n  properties;\n  extras = null;\n  attributions = {};\n  credits = {};\n  stats;\n  /** flags that contain information about data types in nested tiles */\n  contentFormats = {\n    draco: false,\n    meshopt: false,\n    dds: false,\n    ktx2: false\n  };\n  // view props\n  cartographicCenter = null;\n  cartesianCenter = null;\n  zoom = 1;\n  boundingVolume = null;\n  /** Updated based on the camera position and direction */\n  dynamicScreenSpaceErrorComputedDensity = 0.0;\n  // METRICS\n  /**\n   * The maximum amount of GPU memory (in MB) that may be used to cache tiles\n   * Tiles not in view are unloaded to enforce private\n   */\n  maximumMemoryUsage = 32;\n  /** The total amount of GPU memory in bytes used by the tileset. */\n  gpuMemoryUsageInBytes = 0;\n  /**\n   * If loading the level of detail required by maximumScreenSpaceError\n   * results in the memory usage exceeding maximumMemoryUsage (GPU), level of detail refinement\n   * will instead use this (larger) adjusted screen space error to achieve the\n   * best possible visual quality within the available memory.\n   */\n  memoryAdjustedScreenSpaceError = 0.0;\n  _cacheBytes = 0;\n  _cacheOverflowBytes = 0;\n  /** Update tracker. increase in each update cycle. */\n  _frameNumber = 0;\n  _queryParams = {};\n  _extensionsUsed = [];\n  _tiles = {};\n  /** counter for tracking tiles requests */\n  _pendingCount = 0;\n  /** Hold traversal results */\n  selectedTiles = [];\n  // TRAVERSAL\n  traverseCounter = 0;\n  geometricError = 0;\n  lastUpdatedVieports = null;\n  _requestedTiles = [];\n  _emptyTiles = [];\n  frameStateData = {};\n  _traverser;\n  _cache = new TilesetCache();\n  _requestScheduler;\n  // Promise tracking\n  updatePromise = null;\n  tilesetInitializationPromise;\n  /**\n   * Create a new Tileset3D\n   * @param json\n   * @param props\n   */\n  // eslint-disable-next-line max-statements\n  constructor(tileset, options) {\n    // PUBLIC MEMBERS\n    this.options = {\n      ...DEFAULT_PROPS,\n      ...options\n    };\n    // raw data\n    this.tileset = tileset;\n    this.loader = tileset.loader;\n    // could be  3d tiles, i3s\n    this.type = tileset.type;\n    // The url to a tileset JSON file.\n    this.url = tileset.url;\n    this.basePath = tileset.basePath || path.dirname(this.url);\n    this.modelMatrix = this.options.modelMatrix;\n    this.ellipsoid = this.options.ellipsoid;\n    // Geometric error when the tree is not rendered at all\n    this.lodMetricType = tileset.lodMetricType;\n    this.lodMetricValue = tileset.lodMetricValue;\n    this.refine = tileset.root.refine;\n    this.loadOptions = this.options.loadOptions || {};\n    // TRAVERSAL\n    this._traverser = this._initializeTraverser();\n    this._requestScheduler = new RequestScheduler({\n      throttleRequests: this.options.throttleRequests,\n      maxRequests: this.options.maxRequests\n    });\n    this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError;\n    this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024;\n    this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024;\n    // METRICS\n    // The total amount of GPU memory in bytes used by the tileset.\n    this.stats = new Stats({\n      id: this.url\n    });\n    this._initializeStats();\n    this.tilesetInitializationPromise = this._initializeTileSet(tileset);\n  }\n  /** Release resources */\n  destroy() {\n    this._destroy();\n  }\n  /** Is the tileset loaded (update needs to have been called at least once) */\n  isLoaded() {\n    // Check that `_frameNumber !== 0` which means that update was called at least once\n    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;\n  }\n  get tiles() {\n    return Object.values(this._tiles);\n  }\n  get frameNumber() {\n    return this._frameNumber;\n  }\n  get queryParams() {\n    return new URLSearchParams(this._queryParams).toString();\n  }\n  setProps(props) {\n    this.options = {\n      ...this.options,\n      ...props\n    };\n  }\n  /** @deprecated */\n  // setOptions(options: Tileset3DProps): void {\n  //   this.options = {...this.options, ...options};\n  // }\n  /**\n   * Return a loadable tile url for a specific tile subpath\n   * @param tilePath a tile subpath\n   */\n  getTileUrl(tilePath) {\n    const isDataUrl = tilePath.startsWith('data:');\n    if (isDataUrl) {\n      return tilePath;\n    }\n    let tileUrl = tilePath;\n    if (this.queryParams.length) {\n      tileUrl = `${tilePath}${tilePath.includes('?') ? '&' : '?'}${this.queryParams}`;\n    }\n    return tileUrl;\n  }\n  // TODO CESIUM specific\n  hasExtension(extensionName) {\n    return Boolean(this._extensionsUsed.indexOf(extensionName) > -1);\n  }\n  /**\n   * Update visible tiles relying on a list of viewports\n   * @param viewports - list of viewports\n   * @deprecated\n   */\n  update(viewports = null) {\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.tilesetInitializationPromise.then(() => {\n      if (!viewports && this.lastUpdatedVieports) {\n        viewports = this.lastUpdatedVieports;\n      } else {\n        this.lastUpdatedVieports = viewports;\n      }\n      if (viewports) {\n        this.doUpdate(viewports);\n      }\n    });\n  }\n  /**\n   * Update visible tiles relying on a list of viewports.\n   * Do it with debounce delay to prevent update spam\n   * @param viewports viewports\n   * @returns Promise of new frameNumber\n   */\n  async selectTiles(viewports = null) {\n    await this.tilesetInitializationPromise;\n    if (viewports) {\n      this.lastUpdatedVieports = viewports;\n    }\n    if (!this.updatePromise) {\n      this.updatePromise = new Promise(resolve => {\n        setTimeout(() => {\n          if (this.lastUpdatedVieports) {\n            this.doUpdate(this.lastUpdatedVieports);\n          }\n          resolve(this._frameNumber);\n          this.updatePromise = null;\n        }, this.options.debounceTime);\n      });\n    }\n    return this.updatePromise;\n  }\n  adjustScreenSpaceError() {\n    if (this.gpuMemoryUsageInBytes < this._cacheBytes) {\n      this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError);\n    } else if (this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes) {\n      this.memoryAdjustedScreenSpaceError *= 1.02;\n    }\n  }\n  /**\n   * Update visible tiles relying on a list of viewports\n   * @param viewports viewports\n   */\n  // eslint-disable-next-line max-statements, complexity\n  doUpdate(viewports) {\n    if ('loadTiles' in this.options && !this.options.loadTiles) {\n      return;\n    }\n    if (this.traverseCounter > 0) {\n      return;\n    }\n    const preparedViewports = viewports instanceof Array ? viewports : [viewports];\n    this._cache.reset();\n    this._frameNumber++;\n    this.traverseCounter = preparedViewports.length;\n    const viewportsToTraverse = [];\n    // First loop to decrement traverseCounter\n    for (const viewport of preparedViewports) {\n      const id = viewport.id;\n      if (this._needTraverse(id)) {\n        viewportsToTraverse.push(id);\n      } else {\n        this.traverseCounter--;\n      }\n    }\n    // Second loop to traverse\n    for (const viewport of preparedViewports) {\n      const id = viewport.id;\n      if (!this.roots[id]) {\n        this.roots[id] = this._initializeTileHeaders(this.tileset, null);\n      }\n      if (!viewportsToTraverse.includes(id)) {\n        continue; // eslint-disable-line no-continue\n      }\n      const frameState = getFrameState(viewport, this._frameNumber);\n      this._traverser.traverse(this.roots[id], frameState, this.options);\n    }\n  }\n  /**\n   * Check if traversal is needed for particular viewport\n   * @param {string} viewportId - id of a viewport\n   * @return {boolean}\n   */\n  _needTraverse(viewportId) {\n    let traverserId = viewportId;\n    if (this.options.viewportTraversersMap) {\n      traverserId = this.options.viewportTraversersMap[viewportId];\n    }\n    if (traverserId !== viewportId) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * The callback to post-process tiles after traversal procedure\n   * @param frameState - frame state for tile culling\n   */\n  _onTraversalEnd(frameState) {\n    const id = frameState.viewport.id;\n    if (!this.frameStateData[id]) {\n      this.frameStateData[id] = {\n        selectedTiles: [],\n        _requestedTiles: [],\n        _emptyTiles: []\n      };\n    }\n    const currentFrameStateData = this.frameStateData[id];\n    const selectedTiles = Object.values(this._traverser.selectedTiles);\n    const [filteredSelectedTiles, unselectedTiles] = limitSelectedTiles(selectedTiles, frameState, this.options.maximumTilesSelected);\n    currentFrameStateData.selectedTiles = filteredSelectedTiles;\n    for (const tile of unselectedTiles) {\n      tile.unselect();\n    }\n    currentFrameStateData._requestedTiles = Object.values(this._traverser.requestedTiles);\n    currentFrameStateData._emptyTiles = Object.values(this._traverser.emptyTiles);\n    this.traverseCounter--;\n    if (this.traverseCounter > 0) {\n      return;\n    }\n    this._updateTiles();\n  }\n  /**\n   * Update tiles relying on data from all traversers\n   */\n  _updateTiles() {\n    this.selectedTiles = [];\n    this._requestedTiles = [];\n    this._emptyTiles = [];\n    for (const frameStateKey in this.frameStateData) {\n      const frameStateDataValue = this.frameStateData[frameStateKey];\n      this.selectedTiles = this.selectedTiles.concat(frameStateDataValue.selectedTiles);\n      this._requestedTiles = this._requestedTiles.concat(frameStateDataValue._requestedTiles);\n      this._emptyTiles = this._emptyTiles.concat(frameStateDataValue._emptyTiles);\n    }\n    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);\n    for (const tile of this.selectedTiles) {\n      this._tiles[tile.id] = tile;\n    }\n    this._loadTiles();\n    this._unloadTiles();\n    this._updateStats();\n  }\n  _tilesChanged(oldSelectedTiles, selectedTiles) {\n    if (oldSelectedTiles.length !== selectedTiles.length) {\n      return true;\n    }\n    const set1 = new Set(oldSelectedTiles.map(t => t.id));\n    const set2 = new Set(selectedTiles.map(t => t.id));\n    let changed = oldSelectedTiles.filter(x => !set2.has(x.id)).length > 0;\n    changed = changed || selectedTiles.filter(x => !set1.has(x.id)).length > 0;\n    return changed;\n  }\n  _loadTiles() {\n    // Sort requests by priority before making any requests.\n    // This makes it less likely this requests will be cancelled after being issued.\n    // requestedTiles.sort((a, b) => a._priority - b._priority);\n    for (const tile of this._requestedTiles) {\n      if (tile.contentUnloaded) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._loadTile(tile);\n      }\n    }\n  }\n  _unloadTiles() {\n    // unload tiles from cache when hit maximumMemoryUsage\n    this._cache.unloadTiles(this, (tileset, tile) => tileset._unloadTile(tile));\n  }\n  _updateStats() {\n    let tilesRenderable = 0;\n    let pointsRenderable = 0;\n    for (const tile of this.selectedTiles) {\n      if (tile.contentAvailable && tile.content) {\n        tilesRenderable++;\n        if (tile.content.pointCount) {\n          pointsRenderable += tile.content.pointCount;\n        } else {\n          // Calculate vertices for non point cloud tiles.\n          pointsRenderable += tile.content.vertexCount;\n        }\n      }\n    }\n    this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;\n    this.stats.get(TILES_RENDERABLE).count = tilesRenderable;\n    this.stats.get(POINTS_COUNT).count = pointsRenderable;\n    this.stats.get(MAXIMUM_SSE).count = this.memoryAdjustedScreenSpaceError;\n  }\n  async _initializeTileSet(tilesetJson) {\n    if (this.type === TILESET_TYPE.I3S) {\n      this.calculateViewPropsI3S();\n      tilesetJson.root = await tilesetJson.root;\n    }\n    this.root = this._initializeTileHeaders(tilesetJson, null);\n    if (this.type === TILESET_TYPE.TILES3D) {\n      this._initializeTiles3DTileset(tilesetJson);\n      this.calculateViewPropsTiles3D();\n    }\n    if (this.type === TILESET_TYPE.I3S) {\n      this._initializeI3STileset();\n    }\n  }\n  /**\n   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.\n   * These metrics help apps center view on tileset\n   * For I3S there is extent (<1.8 version) or fullExtent (>=1.8 version) to calculate view props\n   * @returns\n   */\n  calculateViewPropsI3S() {\n    // for I3S 1.8 try to calculate with fullExtent\n    const fullExtent = this.tileset.fullExtent;\n    if (fullExtent) {\n      const {\n        xmin,\n        xmax,\n        ymin,\n        ymax,\n        zmin,\n        zmax\n      } = fullExtent;\n      this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, zmin + (zmax - zmin) / 2);\n      this.cartesianCenter = new Vector3();\n      Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter);\n      this.zoom = getZoomFromFullExtent(fullExtent, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n    // for I3S 1.6-1.7 try to calculate with extent\n    const extent = this.tileset.store?.extent;\n    if (extent) {\n      const [xmin, ymin, xmax, ymax] = extent;\n      this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, 0);\n      this.cartesianCenter = new Vector3();\n      Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter);\n      this.zoom = getZoomFromExtent(extent, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n    // eslint-disable-next-line no-console\n    console.warn('Extent is not defined in the tileset header');\n    this.cartographicCenter = new Vector3();\n    this.zoom = 1;\n    return;\n  }\n  /**\n   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.\n   * These metrics help apps center view on tileset.\n   * For 3DTiles the root tile data is used to calculate view props.\n   * @returns\n   */\n  calculateViewPropsTiles3D() {\n    const root = this.root;\n    const {\n      center\n    } = root.boundingVolume;\n    // TODO - handle all cases\n    if (!center) {\n      // eslint-disable-next-line no-console\n      console.warn('center was not pre-calculated for the root tile');\n      this.cartographicCenter = new Vector3();\n      this.zoom = 1;\n      return;\n    }\n    // cartographic coordinates are undefined at the center of the ellipsoid\n    if (center[0] !== 0 || center[1] !== 0 || center[2] !== 0) {\n      this.cartographicCenter = new Vector3();\n      Ellipsoid.WGS84.cartesianToCartographic(center, this.cartographicCenter);\n    } else {\n      this.cartographicCenter = new Vector3(0, 0, -Ellipsoid.WGS84.radii[0]);\n    }\n    this.cartesianCenter = center;\n    this.zoom = getZoomFromBoundingVolume(root.boundingVolume, this.cartographicCenter);\n  }\n  _initializeStats() {\n    this.stats.get(TILES_TOTAL);\n    this.stats.get(TILES_LOADING);\n    this.stats.get(TILES_IN_MEMORY);\n    this.stats.get(TILES_IN_VIEW);\n    this.stats.get(TILES_RENDERABLE);\n    this.stats.get(TILES_LOADED);\n    this.stats.get(TILES_UNLOADED);\n    this.stats.get(TILES_LOAD_FAILED);\n    this.stats.get(POINTS_COUNT);\n    this.stats.get(TILES_GPU_MEMORY, 'memory');\n    this.stats.get(MAXIMUM_SSE);\n  }\n  // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.\n  // eslint-disable-next-line max-statements\n  _initializeTileHeaders(tilesetJson, parentTileHeader) {\n    // A tileset JSON file referenced from a tile may exist in a different directory than the root tileset.\n    // Get the basePath relative to the external tileset.\n    const rootTile = new Tile3D(this, tilesetJson.root, parentTileHeader); // resource\n    // If there is a parentTileHeader, add the root of the currently loading tileset\n    // to parentTileHeader's children, and update its depth.\n    if (parentTileHeader) {\n      parentTileHeader.children.push(rootTile);\n      rootTile.depth = parentTileHeader.depth + 1;\n    }\n    // 3DTiles knows the hierarchy beforehand\n    if (this.type === TILESET_TYPE.TILES3D) {\n      const stack = [];\n      stack.push(rootTile);\n      while (stack.length > 0) {\n        const tile = stack.pop();\n        this.stats.get(TILES_TOTAL).incrementCount();\n        const children = tile.header.children || [];\n        for (const childHeader of children) {\n          const childTile = new Tile3D(this, childHeader, tile);\n          // Special handling for Google\n          // A session key must be used for all tile requests\n          if (childTile.contentUrl?.includes('?session=')) {\n            const url = new URL(childTile.contentUrl);\n            const session = url.searchParams.get('session');\n            // eslint-disable-next-line max-depth\n            if (session) {\n              this._queryParams.session = session;\n            }\n          }\n          tile.children.push(childTile);\n          childTile.depth = tile.depth + 1;\n          stack.push(childTile);\n        }\n      }\n    }\n    return rootTile;\n  }\n  _initializeTraverser() {\n    let TraverserClass;\n    const type = this.type;\n    switch (type) {\n      case TILESET_TYPE.TILES3D:\n        TraverserClass = Tileset3DTraverser;\n        break;\n      case TILESET_TYPE.I3S:\n        TraverserClass = I3STilesetTraverser;\n        break;\n      default:\n        TraverserClass = TilesetTraverser;\n    }\n    return new TraverserClass({\n      basePath: this.basePath,\n      onTraversalEnd: this._onTraversalEnd.bind(this)\n    });\n  }\n  _destroyTileHeaders(parentTile) {\n    this._destroySubtree(parentTile);\n  }\n  async _loadTile(tile) {\n    let loaded;\n    try {\n      this._onStartTileLoading();\n      loaded = await tile.loadContent();\n    } catch (error) {\n      this._onTileLoadError(tile, error instanceof Error ? error : new Error('load failed'));\n    } finally {\n      this._onEndTileLoading();\n      this._onTileLoad(tile, loaded);\n    }\n  }\n  _onTileLoadError(tile, error) {\n    this.stats.get(TILES_LOAD_FAILED).incrementCount();\n    const message = error.message || error.toString();\n    const url = tile.url;\n    // TODO - Allow for probe log to be injected instead of console?\n    console.error(`A 3D tile failed to load: ${tile.url} ${message}`); // eslint-disable-line\n    this.options.onTileError(tile, message, url);\n  }\n  _onTileLoad(tile, loaded) {\n    if (!loaded) {\n      return;\n    }\n    if (this.type === TILESET_TYPE.I3S) {\n      // We can't calculate tiles total in I3S in advance so we calculate it dynamically.\n      const nodesInNodePages = this.tileset?.nodePagesTile?.nodesInNodePages || 0;\n      this.stats.get(TILES_TOTAL).reset();\n      this.stats.get(TILES_TOTAL).addCount(nodesInNodePages);\n    }\n    // add coordinateOrigin and modelMatrix to tile\n    if (tile && tile.content) {\n      calculateTransformProps(tile, tile.content);\n    }\n    this.updateContentTypes(tile);\n    this._addTileToCache(tile);\n    this.options.onTileLoad(tile);\n  }\n  /**\n   * Update information about data types in nested tiles\n   * @param tile instance of a nested Tile3D\n   */\n  updateContentTypes(tile) {\n    if (this.type === TILESET_TYPE.I3S) {\n      if (tile.header.isDracoGeometry) {\n        this.contentFormats.draco = true;\n      }\n      switch (tile.header.textureFormat) {\n        case 'dds':\n          this.contentFormats.dds = true;\n          break;\n        case 'ktx2':\n          this.contentFormats.ktx2 = true;\n          break;\n        default:\n      }\n    } else if (this.type === TILESET_TYPE.TILES3D) {\n      const {\n        extensionsRemoved = []\n      } = tile.content?.gltf || {};\n      if (extensionsRemoved.includes('KHR_draco_mesh_compression')) {\n        this.contentFormats.draco = true;\n      }\n      if (extensionsRemoved.includes('EXT_meshopt_compression')) {\n        this.contentFormats.meshopt = true;\n      }\n      if (extensionsRemoved.includes('KHR_texture_basisu')) {\n        this.contentFormats.ktx2 = true;\n      }\n    }\n  }\n  _onStartTileLoading() {\n    this._pendingCount++;\n    this.stats.get(TILES_LOADING).incrementCount();\n  }\n  _onEndTileLoading() {\n    this._pendingCount--;\n    this.stats.get(TILES_LOADING).decrementCount();\n  }\n  _addTileToCache(tile) {\n    this._cache.add(this, tile, tileset => tileset._updateCacheStats(tile));\n  }\n  _updateCacheStats(tile) {\n    this.stats.get(TILES_LOADED).incrementCount();\n    this.stats.get(TILES_IN_MEMORY).incrementCount();\n    // TODO: Calculate GPU memory usage statistics for a tile.\n    this.gpuMemoryUsageInBytes += tile.gpuMemoryUsageInBytes || 0;\n    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n    // Adjust SSE based on cache limits\n    if (this.options.memoryAdjustedScreenSpaceError) {\n      this.adjustScreenSpaceError();\n    }\n  }\n  _unloadTile(tile) {\n    this.gpuMemoryUsageInBytes -= tile.gpuMemoryUsageInBytes || 0;\n    this.stats.get(TILES_IN_MEMORY).decrementCount();\n    this.stats.get(TILES_UNLOADED).incrementCount();\n    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n    this.options.onTileUnload(tile);\n    tile.unloadContent();\n  }\n  // Traverse the tree and destroy all tiles\n  _destroy() {\n    const stack = [];\n    if (this.root) {\n      stack.push(this.root);\n    }\n    while (stack.length > 0) {\n      const tile = stack.pop();\n      for (const child of tile.children) {\n        stack.push(child);\n      }\n      this._destroyTile(tile);\n    }\n    this.root = null;\n  }\n  // Traverse the tree and destroy all sub tiles\n  _destroySubtree(tile) {\n    const root = tile;\n    const stack = [];\n    stack.push(root);\n    while (stack.length > 0) {\n      tile = stack.pop();\n      for (const child of tile.children) {\n        stack.push(child);\n      }\n      if (tile !== root) {\n        this._destroyTile(tile);\n      }\n    }\n    root.children = [];\n  }\n  _destroyTile(tile) {\n    this._cache.unloadTile(this, tile);\n    this._unloadTile(tile);\n    tile.destroy();\n  }\n  _initializeTiles3DTileset(tilesetJson) {\n    if (tilesetJson.queryString) {\n      const searchParams = new URLSearchParams(tilesetJson.queryString);\n      const queryParams = Object.fromEntries(searchParams.entries());\n      this._queryParams = {\n        ...this._queryParams,\n        ...queryParams\n      };\n    }\n    this.asset = tilesetJson.asset;\n    if (!this.asset) {\n      throw new Error('Tileset must have an asset property.');\n    }\n    if (this.asset.version !== '0.0' && this.asset.version !== '1.0' && this.asset.version !== '1.1') {\n      throw new Error('The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.');\n    }\n    // Note: `asset.tilesetVersion` is version of the tileset itself (not the version of the 3D TILES standard)\n    // We add this version as a `v=1.0` query param to fetch the right version and not get an older cached version\n    if ('tilesetVersion' in this.asset) {\n      this._queryParams.v = this.asset.tilesetVersion;\n    }\n    // TODO - ion resources have a credits property we can use for additional attribution.\n    this.credits = {\n      attributions: this.options.attributions || []\n    };\n    this.description = this.options.description || '';\n    // Gets the tileset's properties dictionary object, which contains metadata about per-feature properties.\n    this.properties = tilesetJson.properties;\n    this.geometricError = tilesetJson.geometricError;\n    this._extensionsUsed = tilesetJson.extensionsUsed || [];\n    // Returns the extras property at the top of the tileset JSON (application specific metadata).\n    this.extras = tilesetJson.extras;\n  }\n  _initializeI3STileset() {\n    // @ts-expect-error\n    if (this.loadOptions.i3s && 'token' in this.loadOptions.i3s) {\n      // @ts-ignore\n      this._queryParams.token = this.loadOptions.i3s.token;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}