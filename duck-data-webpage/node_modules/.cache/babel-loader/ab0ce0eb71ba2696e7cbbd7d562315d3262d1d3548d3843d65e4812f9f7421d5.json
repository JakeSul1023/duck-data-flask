{"ast":null,"code":"// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* eslint-disable no-undef, no-console */\nimport { isArray } from '@math.gl/core';\nimport { getPolygonSignedArea, forEachSegmentInPolygon, modifyPolygonWindingDirection, getPolygonSignedAreaPoints, forEachSegmentInPolygonPoints, modifyPolygonWindingDirectionPoints } from \"./polygon-utils.js\";\nexport class Polygon {\n  constructor(points, options = {}) {\n    this.points = points;\n    this.isFlatArray = !isArray(points[0]);\n    this.options = {\n      start: options.start || 0,\n      end: options.end || points.length,\n      size: options.size || 2,\n      isClosed: options.isClosed\n    };\n    Object.freeze(this);\n  }\n  /**\n   * Returns signed area of the polygon.\n   * @returns Signed area of the polygon.\n   */\n  getSignedArea() {\n    if (this.isFlatArray) return getPolygonSignedArea(this.points, this.options);\n    return getPolygonSignedAreaPoints(this.points, this.options);\n  }\n  /**\n   * Returns absolute area of the polygon.\n   * @returns Absolute area of the polygon.\n   */\n  getArea() {\n    return Math.abs(this.getSignedArea());\n  }\n  /**\n   * Returns winding direction of the polygon.\n   * @returns Winding direction of the polygon. 1 is for clockwise, -1 for counterclockwise winding direction.\n   */\n  getWindingDirection() {\n    return Math.sign(this.getSignedArea());\n  }\n  /**\n   * Calls the visitor callback for each segment in the polygon.\n   * @param visitor A callback to call for each segment.\n   */\n  forEachSegment(visitor) {\n    if (this.isFlatArray) {\n      forEachSegmentInPolygon(this.points,\n      // eslint-disable-next-line max-params\n      (x1, y1, x2, y2, i1, i2) => {\n        // TODO @igorDykhta original visitor uses arrays for each point, but with flat arrays performance degrades if we allocate points for each segment\n        visitor([x1, y1], [x2, y2], i1, i2);\n      }, this.options);\n    } else {\n      forEachSegmentInPolygonPoints(this.points, visitor, this.options);\n    }\n  }\n  /**\n   * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n   * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n   * @return Returns true if the winding direction was changed.\n   */\n  modifyWindingDirection(direction) {\n    if (this.isFlatArray) {\n      return modifyPolygonWindingDirection(this.points, direction, this.options);\n    }\n    return modifyPolygonWindingDirectionPoints(this.points, direction, this.options);\n  }\n}","map":{"version":3,"names":["isArray","getPolygonSignedArea","forEachSegmentInPolygon","modifyPolygonWindingDirection","getPolygonSignedAreaPoints","forEachSegmentInPolygonPoints","modifyPolygonWindingDirectionPoints","Polygon","constructor","points","options","isFlatArray","start","end","length","size","isClosed","Object","freeze","getSignedArea","getArea","Math","abs","getWindingDirection","sign","forEachSegment","visitor","x1","y1","x2","y2","i1","i2","modifyWindingDirection","direction"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@math.gl\\polygon\\src\\polygon.ts"],"sourcesContent":["// math.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable no-undef, no-console */\nimport {isArray} from '@math.gl/core';\nimport type {SegmentVisitorPoints} from './polygon-utils';\nimport type {NumericArray} from '@math.gl/core';\n\nimport {\n  getPolygonSignedArea,\n  forEachSegmentInPolygon,\n  modifyPolygonWindingDirection,\n  getPolygonSignedAreaPoints,\n  forEachSegmentInPolygonPoints,\n  modifyPolygonWindingDirectionPoints\n} from './polygon-utils';\n\nexport type PolygonOptions = {\n  start?: number;\n  end?: number;\n  size?: number;\n  isClosed?: boolean;\n};\n\nexport class Polygon {\n  points: NumericArray | number[][];\n  isFlatArray: boolean;\n  options: PolygonOptions;\n\n  constructor(points: NumericArray | number[][], options: PolygonOptions = {}) {\n    this.points = points;\n    this.isFlatArray = !isArray(points[0]);\n\n    this.options = {\n      start: options.start || 0,\n      end: options.end || points.length,\n      size: options.size || 2,\n      isClosed: options.isClosed\n    };\n\n    Object.freeze(this);\n  }\n\n  /**\n   * Returns signed area of the polygon.\n   * @returns Signed area of the polygon.\n   */\n  getSignedArea(): number {\n    if (this.isFlatArray) return getPolygonSignedArea(this.points as NumericArray, this.options);\n\n    return getPolygonSignedAreaPoints(this.points as number[][], this.options);\n  }\n\n  /**\n   * Returns absolute area of the polygon.\n   * @returns Absolute area of the polygon.\n   */\n  getArea(): number {\n    return Math.abs(this.getSignedArea());\n  }\n\n  /**\n   * Returns winding direction of the polygon.\n   * @returns Winding direction of the polygon. 1 is for clockwise, -1 for counterclockwise winding direction.\n   */\n  getWindingDirection(): number {\n    return Math.sign(this.getSignedArea());\n  }\n\n  /**\n   * Calls the visitor callback for each segment in the polygon.\n   * @param visitor A callback to call for each segment.\n   */\n  forEachSegment(visitor: SegmentVisitorPoints): void {\n    if (this.isFlatArray) {\n      forEachSegmentInPolygon(\n        this.points as NumericArray,\n        // eslint-disable-next-line max-params\n        (x1, y1, x2, y2, i1, i2) => {\n          // TODO @igorDykhta original visitor uses arrays for each point, but with flat arrays performance degrades if we allocate points for each segment\n          visitor([x1, y1], [x2, y2], i1, i2);\n        },\n        this.options\n      );\n    } else {\n      forEachSegmentInPolygonPoints(this.points as number[][], visitor, this.options);\n    }\n  }\n\n  /**\n   * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n   * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n   * @return Returns true if the winding direction was changed.\n   */\n  modifyWindingDirection(direction: number): boolean {\n    if (this.isFlatArray) {\n      return modifyPolygonWindingDirection(this.points as NumericArray, direction, this.options);\n    }\n    return modifyPolygonWindingDirectionPoints(this.points as number[][], direction, this.options);\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA;AACA,SAAQA,OAAO,QAAO,eAAe;AAIrC,SACEC,oBAAoB,EACpBC,uBAAuB,EACvBC,6BAA6B,EAC7BC,0BAA0B,EAC1BC,6BAA6B,EAC7BC,mCAAmC,QACpC;AASD,OAAM,MAAOC,OAAO;EAKlBC,YAAYC,MAAiC,EAAEC,OAAA,GAA0B,EAAE;IACzE,IAAI,CAACD,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACE,WAAW,GAAG,CAACX,OAAO,CAACS,MAAM,CAAC,CAAC,CAAC,CAAC;IAEtC,IAAI,CAACC,OAAO,GAAG;MACbE,KAAK,EAAEF,OAAO,CAACE,KAAK,IAAI,CAAC;MACzBC,GAAG,EAAEH,OAAO,CAACG,GAAG,IAAIJ,MAAM,CAACK,MAAM;MACjCC,IAAI,EAAEL,OAAO,CAACK,IAAI,IAAI,CAAC;MACvBC,QAAQ,EAAEN,OAAO,CAACM;KACnB;IAEDC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EACrB;EAEA;;;;EAIAC,aAAaA,CAAA;IACX,IAAI,IAAI,CAACR,WAAW,EAAE,OAAOV,oBAAoB,CAAC,IAAI,CAACQ,MAAsB,EAAE,IAAI,CAACC,OAAO,CAAC;IAE5F,OAAON,0BAA0B,CAAC,IAAI,CAACK,MAAoB,EAAE,IAAI,CAACC,OAAO,CAAC;EAC5E;EAEA;;;;EAIAU,OAAOA,CAAA;IACL,OAAOC,IAAI,CAACC,GAAG,CAAC,IAAI,CAACH,aAAa,EAAE,CAAC;EACvC;EAEA;;;;EAIAI,mBAAmBA,CAAA;IACjB,OAAOF,IAAI,CAACG,IAAI,CAAC,IAAI,CAACL,aAAa,EAAE,CAAC;EACxC;EAEA;;;;EAIAM,cAAcA,CAACC,OAA6B;IAC1C,IAAI,IAAI,CAACf,WAAW,EAAE;MACpBT,uBAAuB,CACrB,IAAI,CAACO,MAAsB;MAC3B;MACA,CAACkB,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,KAAI;QACzB;QACAN,OAAO,CAAC,CAACC,EAAE,EAAEC,EAAE,CAAC,EAAE,CAACC,EAAE,EAAEC,EAAE,CAAC,EAAEC,EAAE,EAAEC,EAAE,CAAC;MACrC,CAAC,EACD,IAAI,CAACtB,OAAO,CACb;IACH,CAAC,MAAM;MACLL,6BAA6B,CAAC,IAAI,CAACI,MAAoB,EAAEiB,OAAO,EAAE,IAAI,CAAChB,OAAO,CAAC;IACjF;EACF;EAEA;;;;;EAKAuB,sBAAsBA,CAACC,SAAiB;IACtC,IAAI,IAAI,CAACvB,WAAW,EAAE;MACpB,OAAOR,6BAA6B,CAAC,IAAI,CAACM,MAAsB,EAAEyB,SAAS,EAAE,IAAI,CAACxB,OAAO,CAAC;IAC5F;IACA,OAAOJ,mCAAmC,CAAC,IAAI,CAACG,MAAoB,EAAEyB,SAAS,EAAE,IAAI,CAACxB,OAAO,CAAC;EAChG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}