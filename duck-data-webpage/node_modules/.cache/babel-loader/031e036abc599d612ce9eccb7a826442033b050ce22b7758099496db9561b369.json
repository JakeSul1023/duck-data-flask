{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Tesselator } from '@deck.gl/core';\nimport { normalizePath } from \"./path.js\";\nconst START_CAP = 1;\nconst END_CAP = 2;\nconst INVALID = 4;\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PathTesselator extends Tesselator {\n  constructor(opts) {\n    super({\n      ...opts,\n      attributes: {\n        // Padding covers shaderAttributes for last segment in largest case fp64\n        // additional vertex + hi & low parts, 3 * 6\n        positions: {\n          size: 3,\n          padding: 18,\n          initialize: true,\n          type: opts.fp64 ? Float64Array : Float32Array\n        },\n        segmentTypes: {\n          size: 1,\n          type: Uint8ClampedArray\n        }\n      }\n    });\n  }\n  /** Get packed attribute by name */\n  get(attributeName) {\n    return this.attributes[attributeName];\n  }\n  /* Implement base Tesselator interface */\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization\n    return null;\n  }\n  /* Implement base Tesselator interface */\n  normalizeGeometry(path) {\n    if (this.normalize) {\n      return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);\n    }\n    return path;\n  }\n  /* Implement base Tesselator interface */\n  getGeometrySize(path) {\n    if (isCut(path)) {\n      let size = 0;\n      for (const subPath of path) {\n        size += this.getGeometrySize(subPath);\n      }\n      return size;\n    }\n    const numPoints = this.getPathLength(path);\n    if (numPoints < 2) {\n      // invalid path\n      return 0;\n    }\n    if (this.isClosed(path)) {\n      // minimum 3 vertices\n      return numPoints < 3 ? 0 : numPoints + 2;\n    }\n    return numPoints;\n  }\n  /* Implement base Tesselator interface */\n  updateGeometryAttributes(path, context) {\n    if (context.geometrySize === 0) {\n      return;\n    }\n    if (path && isCut(path)) {\n      for (const subPath of path) {\n        const geometrySize = this.getGeometrySize(subPath);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPath, context);\n        context.vertexStart += geometrySize;\n      }\n    } else {\n      this._updateSegmentTypes(path, context);\n      this._updatePositions(path, context);\n    }\n  }\n  _updateSegmentTypes(path, context) {\n    const segmentTypes = this.attributes.segmentTypes;\n    const isPathClosed = path ? this.isClosed(path) : false;\n    const {\n      vertexStart,\n      geometrySize\n    } = context;\n    // positions   --  A0 A1 B0 B1 B2 B3 B0 B1 B2 --\n    // segmentTypes     3  4  4  0  0  0  0  4  4\n    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);\n    if (isPathClosed) {\n      segmentTypes[vertexStart] = INVALID;\n      segmentTypes[vertexStart + geometrySize - 2] = INVALID;\n    } else {\n      segmentTypes[vertexStart] += START_CAP;\n      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;\n    }\n    segmentTypes[vertexStart + geometrySize - 1] = INVALID;\n  }\n  _updatePositions(path, context) {\n    const {\n      positions\n    } = this.attributes;\n    if (!positions || !path) {\n      return;\n    }\n    const {\n      vertexStart,\n      geometrySize\n    } = context;\n    const p = new Array(3);\n    // positions   --  A0 A1 B0 B1 B2 B3 B0 B1 B2 --\n    // segmentTypes     3  4  4  0  0  0  0  4  4\n    for (let i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {\n      this.getPointOnPath(path, ptIndex, p);\n      positions[i * 3] = p[0];\n      positions[i * 3 + 1] = p[1];\n      positions[i * 3 + 2] = p[2];\n    }\n  }\n  // Utilities\n  /** Returns the number of points in the path */\n  getPathLength(path) {\n    return path.length / this.positionSize;\n  }\n  /** Returns a point on the path at the specified index */\n  getPointOnPath(path, index, target = []) {\n    const {\n      positionSize\n    } = this;\n    if (index * positionSize >= path.length) {\n      // loop\n      index += 1 - path.length / positionSize;\n    }\n    const i = index * positionSize;\n    target[0] = path[i];\n    target[1] = path[i + 1];\n    target[2] = positionSize === 3 && path[i + 2] || 0;\n    return target;\n  }\n  // Returns true if the first and last points are identical\n  isClosed(path) {\n    if (!this.normalize) {\n      return Boolean(this.opts.loop);\n    }\n    const {\n      positionSize\n    } = this;\n    const lastPointIndex = path.length - positionSize;\n    return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);\n  }\n}\nfunction isCut(path) {\n  return Array.isArray(path[0]);\n}\n//# sourceMappingURL=path-tesselator.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}