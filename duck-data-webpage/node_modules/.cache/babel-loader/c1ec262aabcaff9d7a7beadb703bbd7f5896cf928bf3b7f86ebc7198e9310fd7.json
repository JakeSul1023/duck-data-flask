{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Compression } from \"./compression.js\";\nimport { isBrowser, toArrayBuffer, promisify1 } from '@loaders.gl/loader-utils';\nimport pako from 'pako'; // https://bundlephobia.com/package/pako\nimport zlib from 'zlib';\n/**\n * DEFLATE compression / decompression\n */\nexport class DeflateCompression extends Compression {\n  name = 'deflate';\n  extensions = [];\n  contentEncodings = ['deflate'];\n  isSupported = true;\n  options;\n  _chunks = [];\n  constructor(options = {}) {\n    super(options);\n    this.options = options;\n  }\n  async compress(input) {\n    // On Node.js we can use built-in zlib\n    if (!isBrowser && this.options.deflate?.useZlib) {\n      const buffer = this.options.deflate?.gzip ? await promisify1(zlib.gzip)(input) : await promisify1(zlib.deflate)(input);\n      return toArrayBuffer(buffer);\n    }\n    return this.compressSync(input);\n  }\n  async decompress(input) {\n    // On Node.js we can use built-in zlib\n    if (!isBrowser && this.options.deflate?.useZlib) {\n      const buffer = this.options.deflate?.gzip ? await promisify1(zlib.gunzip)(input) : await promisify1(zlib.inflate)(input);\n      return toArrayBuffer(buffer);\n    }\n    return this.decompressSync(input);\n  }\n  compressSync(input) {\n    // On Node.js we can use built-in zlib\n    if (!isBrowser && this.options.deflate?.useZlib) {\n      const buffer = this.options.deflate?.gzip ? zlib.gzipSync(input) : zlib.deflateSync(input);\n      return toArrayBuffer(buffer);\n    }\n    const pakoOptions = this.options?.deflate || {};\n    const inputArray = new Uint8Array(input);\n    const deflate = this.options?.raw ? pako.deflateRaw : pako.deflate;\n    return deflate(inputArray, pakoOptions).buffer;\n  }\n  decompressSync(input) {\n    // On Node.js we can use built-in zlib\n    if (!isBrowser && this.options.deflate?.useZlib) {\n      const buffer = this.options.deflate?.gzip ? zlib.gunzipSync(input) : zlib.inflateSync(input);\n      return toArrayBuffer(buffer);\n    }\n    const pakoOptions = this.options?.deflate || {};\n    const inputArray = new Uint8Array(input);\n    const inflate = this.options?.raw ? pako.inflateRaw : pako.inflate;\n    return inflate(inputArray, pakoOptions).buffer;\n  }\n  async *compressBatches(asyncIterator) {\n    const pakoOptions = this.options?.deflate || {};\n    const pakoProcessor = new pako.Deflate(pakoOptions);\n    yield* this.transformBatches(pakoProcessor, asyncIterator);\n  }\n  async *decompressBatches(asyncIterator) {\n    const pakoOptions = this.options?.deflate || {};\n    const pakoProcessor = new pako.Inflate(pakoOptions);\n    yield* this.transformBatches(pakoProcessor, asyncIterator);\n  }\n  async *transformBatches(pakoProcessor, asyncIterator) {\n    pakoProcessor.onData = this._onData.bind(this);\n    pakoProcessor.onEnd = this._onEnd.bind(this);\n    for await (const chunk of asyncIterator) {\n      const uint8Array = new Uint8Array(chunk);\n      const ok = pakoProcessor.push(uint8Array, false); // false -> not last chunk\n      if (!ok) {\n        throw new Error(`${this._getError()}write`);\n      }\n      const chunks = this._getChunks();\n      yield* chunks;\n    }\n    // End\n    const emptyChunk = new Uint8Array(0);\n    const ok = pakoProcessor.push(emptyChunk, true); // true -> last chunk\n    if (!ok) {\n      // For some reason we get error but it still works???\n      // throw new Error(this._getError() + 'end');\n    }\n    const chunks = this._getChunks();\n    yield* chunks;\n  }\n  _onData(chunk) {\n    this._chunks.push(chunk);\n  }\n  _onEnd(status) {\n    if (status !== 0) {\n      throw new Error(this._getError(status) + this._chunks.length);\n    }\n  }\n  _getChunks() {\n    const chunks = this._chunks;\n    this._chunks = [];\n    return chunks;\n  }\n  // TODO - For some reason we don't get the error message from pako in _onEnd?\n  _getError(code = 0) {\n    const MESSAGES = {\n      /* Z_NEED_DICT       2  */\n      2: 'need dictionary',\n      /* Z_STREAM_END      1  */\n      1: 'stream end',\n      /* Z_OK              0  */\n      0: '',\n      /* Z_ERRNO         (-1) */\n      '-1': 'file error',\n      /* Z_STREAM_ERROR  (-2) */\n      '-2': 'stream error',\n      /* Z_DATA_ERROR    (-3) */\n      '-3': 'data error',\n      /* Z_MEM_ERROR     (-4) */\n      '-4': 'insufficient memory',\n      /* Z_BUF_ERROR     (-5) */\n      '-5': 'buffer error',\n      /* Z_VERSION_ERROR (-6) */\n      '-6': 'incompatible version'\n    };\n    return `${this.name}: ${MESSAGES[code]}`;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}