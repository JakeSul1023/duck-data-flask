{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { WebMercatorViewport, OrthographicViewport } from '@deck.gl/core';\n/*\n * Compute the union of bounds from multiple layers\n * Returns bounds in CARTESIAN coordinates\n */\nexport function joinLayerBounds(/** The layers to combine */\nlayers, /** A Viewport instance that is used to determine the type of the view */\nviewport) {\n  // Join the bounds of layer data\n  const bounds = [Infinity, Infinity, -Infinity, -Infinity];\n  for (const layer of layers) {\n    const layerBounds = layer.getBounds();\n    if (layerBounds) {\n      const bottomLeftCommon = layer.projectPosition(layerBounds[0], {\n        viewport,\n        autoOffset: false\n      });\n      const topRightCommon = layer.projectPosition(layerBounds[1], {\n        viewport,\n        autoOffset: false\n      });\n      bounds[0] = Math.min(bounds[0], bottomLeftCommon[0]);\n      bounds[1] = Math.min(bounds[1], bottomLeftCommon[1]);\n      bounds[2] = Math.max(bounds[2], topRightCommon[0]);\n      bounds[3] = Math.max(bounds[3], topRightCommon[1]);\n    }\n  }\n  if (Number.isFinite(bounds[0])) {\n    return bounds;\n  }\n  return null;\n}\nconst MAX_VIEWPORT_SIZE = 2048;\n/** Construct a viewport that just covers the target bounds. Used for rendering to common space indexed texture. */\nexport function makeViewport(opts) {\n  const {\n    bounds,\n    viewport,\n    border = 0\n  } = opts;\n  const {\n    isGeospatial\n  } = viewport;\n  if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {\n    return null;\n  }\n  const centerWorld = viewport.unprojectPosition([(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2, 0]);\n  let {\n    width,\n    height,\n    zoom\n  } = opts;\n  if (zoom === undefined) {\n    // Use width and height to determine zoom\n    width = width - border * 2;\n    height = height - border * 2;\n    const scale = Math.min(width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));\n    zoom = Math.min(Math.log2(scale), 20);\n  } else if (!width || !height) {\n    // Use zoom to determine width and height\n    const scale = 2 ** zoom;\n    width = Math.round(Math.abs(bounds[2] - bounds[0]) * scale);\n    height = Math.round(Math.abs(bounds[3] - bounds[1]) * scale);\n    const maxSize = MAX_VIEWPORT_SIZE - border * 2;\n    if (width > maxSize || height > maxSize) {\n      const r = maxSize / Math.max(width, height);\n      width = Math.round(width * r);\n      height = Math.round(height * r);\n      zoom += Math.log2(r);\n    }\n  }\n  // TODO - find a more generic way to construct this viewport\n  // Geospatial viewports may not be web-mercator\n  return isGeospatial ? new WebMercatorViewport({\n    id: viewport.id,\n    x: border,\n    y: border,\n    width,\n    height,\n    longitude: centerWorld[0],\n    latitude: centerWorld[1],\n    zoom,\n    orthographic: true\n  }) : new OrthographicViewport({\n    id: viewport.id,\n    x: border,\n    y: border,\n    width,\n    height,\n    target: centerWorld,\n    zoom,\n    flipY: false\n  });\n}\n/** Returns viewport bounds in CARTESIAN coordinates */\nexport function getViewportBounds(viewport, zRange) {\n  // Viewport bounds in world coordinates\n  let viewportBoundsWorld;\n  if (zRange && zRange.length === 2) {\n    const [minZ, maxZ] = zRange;\n    const bounds0 = viewport.getBounds({\n      z: minZ\n    });\n    const bounds1 = viewport.getBounds({\n      z: maxZ\n    });\n    viewportBoundsWorld = [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];\n  } else {\n    viewportBoundsWorld = viewport.getBounds();\n  }\n  // Viewport bounds in cartesian coordinates\n  const viewportBottomLeftCommon = viewport.projectPosition(viewportBoundsWorld.slice(0, 2));\n  const viewportTopRightCommon = viewport.projectPosition(viewportBoundsWorld.slice(2, 4));\n  return [viewportBottomLeftCommon[0], viewportBottomLeftCommon[1], viewportTopRightCommon[0], viewportTopRightCommon[1]];\n}\n/*\n * Determine the common space bounds that best cover the given data for the given viewport\n * Returns bounds in CARTESIAN coordinates\n */\nexport function getRenderBounds(layerBounds, viewport, zRange) {\n  if (!layerBounds) {\n    return [0, 0, 1, 1];\n  }\n  const viewportBounds = getViewportBounds(viewport, zRange);\n  // Expand viewport bounds by 2X. Heurestically chosen to avoid masking\n  // errors when mask is partially out of view\n  const paddedBounds = doubleBounds(viewportBounds);\n  // When bounds of the layers are smaller than the viewport bounds simply use\n  // mask bounds, so as to maximize resolution & avoid rerenders\n  if (layerBounds[2] - layerBounds[0] <= paddedBounds[2] - paddedBounds[0] && layerBounds[3] - layerBounds[1] <= paddedBounds[3] - paddedBounds[1]) {\n    return layerBounds;\n  }\n  // As viewport shrinks, to avoid pixelation along mask edges\n  // we need to reduce the bounds and only render the visible portion\n  // of the mask.\n  // We pad the viewport bounds to capture the section\n  // of the mask just outside the viewport to correctly maskByInstance.\n  // Intersect mask & padded viewport bounds\n  return [Math.max(layerBounds[0], paddedBounds[0]), Math.max(layerBounds[1], paddedBounds[1]), Math.min(layerBounds[2], paddedBounds[2]), Math.min(layerBounds[3], paddedBounds[3])];\n}\nfunction doubleBounds(bounds) {\n  const dx = bounds[2] - bounds[0];\n  const dy = bounds[3] - bounds[1];\n  const centerX = (bounds[0] + bounds[2]) / 2;\n  const centerY = (bounds[1] + bounds[3]) / 2;\n  return [centerX - dx, centerY - dy, centerX + dx, centerY + dy];\n}\n//# sourceMappingURL=projection-utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}