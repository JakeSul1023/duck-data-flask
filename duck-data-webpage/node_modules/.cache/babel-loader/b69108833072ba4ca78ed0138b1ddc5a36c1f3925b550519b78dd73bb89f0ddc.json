{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Layer, project32, picking, UNIT } from '@deck.gl/core';\nimport { gouraudMaterial, phongMaterial } from '@luma.gl/shadertools';\nimport { Model } from '@luma.gl/engine';\nimport ColumnGeometry from \"./column-geometry.js\";\nimport { columnUniforms } from \"./column-layer-uniforms.js\";\nimport vs from \"./column-layer-vertex.glsl.js\";\nimport fs from \"./column-layer-fragment.glsl.js\";\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  diskResolution: {\n    type: 'number',\n    min: 4,\n    value: 20\n  },\n  vertices: null,\n  radius: {\n    type: 'number',\n    min: 0,\n    value: 1000\n  },\n  angle: {\n    type: 'number',\n    value: 0\n  },\n  offset: {\n    type: 'array',\n    value: [0, 0]\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  radiusUnits: 'meters',\n  lineWidthUnits: 'meters',\n  lineWidthScale: 1,\n  lineWidthMinPixels: 0,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  extruded: true,\n  wireframe: false,\n  filled: true,\n  stroked: false,\n  flatShading: false,\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getLineWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  getElevation: {\n    type: 'accessor',\n    value: 1000\n  },\n  material: true,\n  getColor: {\n    deprecatedFor: ['getFillColor', 'getLineColor']\n  }\n};\n/** Render extruded cylinders (tessellated regular polygons) at given coordinates. */\nclass ColumnLayer extends Layer {\n  getShaders() {\n    const defines = {};\n    const {\n      flatShading\n    } = this.props;\n    if (flatShading) {\n      defines.FLAT_SHADING = 1;\n    }\n    return super.getShaders({\n      vs,\n      fs,\n      defines,\n      modules: [project32, flatShading ? phongMaterial : gouraudMaterial, picking, columnUniforms]\n    });\n  }\n  /**\n   * DeckGL calls initializeState when GL context is available\n   * Essentially a deferred constructor\n   */\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 'float64',\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceElevations: {\n        size: 1,\n        transition: true,\n        accessor: 'getElevation'\n      },\n      instanceFillColors: {\n        size: this.props.colorFormat.length,\n        type: 'unorm8',\n        transition: true,\n        accessor: 'getFillColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceLineColors: {\n        size: this.props.colorFormat.length,\n        type: 'unorm8',\n        transition: true,\n        accessor: 'getLineColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceStrokeWidths: {\n        size: 1,\n        accessor: 'getLineWidth',\n        transition: true\n      }\n    });\n    /* eslint-enable max-len */\n  }\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps,\n      changeFlags\n    } = params;\n    const regenerateModels = changeFlags.extensionsChanged || props.flatShading !== oldProps.flatShading;\n    if (regenerateModels) {\n      this.state.models?.forEach(model => model.destroy());\n      this.setState(this._getModels());\n      this.getAttributeManager().invalidateAll();\n    }\n    const instanceCount = this.getNumInstances();\n    this.state.fillModel.setInstanceCount(instanceCount);\n    this.state.wireframeModel.setInstanceCount(instanceCount);\n    if (regenerateModels || props.diskResolution !== oldProps.diskResolution || props.vertices !== oldProps.vertices || (props.extruded || props.stroked) !== (oldProps.extruded || oldProps.stroked)) {\n      this._updateGeometry(props);\n    }\n  }\n  getGeometry(diskResolution, vertices, hasThinkness) {\n    const geometry = new ColumnGeometry({\n      radius: 1,\n      height: hasThinkness ? 2 : 0,\n      vertices,\n      nradial: diskResolution\n    });\n    let meanVertexDistance = 0;\n    if (vertices) {\n      for (let i = 0; i < diskResolution; i++) {\n        const p = vertices[i];\n        const d = Math.sqrt(p[0] * p[0] + p[1] * p[1]);\n        meanVertexDistance += d / diskResolution;\n      }\n    } else {\n      meanVertexDistance = 1;\n    }\n    this.setState({\n      edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance\n    });\n    return geometry;\n  }\n  _getModels() {\n    const shaders = this.getShaders();\n    const bufferLayout = this.getAttributeManager().getBufferLayouts();\n    const fillModel = new Model(this.context.device, {\n      ...shaders,\n      id: `${this.props.id}-fill`,\n      bufferLayout,\n      isInstanced: true\n    });\n    const wireframeModel = new Model(this.context.device, {\n      ...shaders,\n      id: `${this.props.id}-wireframe`,\n      bufferLayout,\n      isInstanced: true\n    });\n    return {\n      fillModel,\n      wireframeModel,\n      models: [wireframeModel, fillModel]\n    };\n  }\n  _updateGeometry({\n    diskResolution,\n    vertices,\n    extruded,\n    stroked\n  }) {\n    const geometry = this.getGeometry(diskResolution, vertices, extruded || stroked);\n    this.setState({\n      fillVertexCount: geometry.attributes.POSITION.value.length / 3\n    });\n    const fillModel = this.state.fillModel;\n    const wireframeModel = this.state.wireframeModel;\n    fillModel.setGeometry(geometry);\n    fillModel.setTopology('triangle-strip');\n    // Disable indices\n    fillModel.setIndexBuffer(null);\n    wireframeModel.setGeometry(geometry);\n    wireframeModel.setTopology('line-list');\n  }\n  draw({\n    uniforms\n  }) {\n    const {\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      radiusUnits,\n      elevationScale,\n      extruded,\n      filled,\n      stroked,\n      wireframe,\n      offset,\n      coverage,\n      radius,\n      angle\n    } = this.props;\n    const fillModel = this.state.fillModel;\n    const wireframeModel = this.state.wireframeModel;\n    const {\n      fillVertexCount,\n      edgeDistance\n    } = this.state;\n    const columnProps = {\n      radius,\n      angle: angle / 180 * Math.PI,\n      offset,\n      extruded,\n      stroked,\n      coverage,\n      elevationScale,\n      edgeDistance,\n      radiusUnits: UNIT[radiusUnits],\n      widthUnits: UNIT[lineWidthUnits],\n      widthScale: lineWidthScale,\n      widthMinPixels: lineWidthMinPixels,\n      widthMaxPixels: lineWidthMaxPixels\n    };\n    // When drawing 3d: draw wireframe first so it doesn't get occluded by depth test\n    if (extruded && wireframe) {\n      wireframeModel.shaderInputs.setProps({\n        column: {\n          ...columnProps,\n          isStroke: true\n        }\n      });\n      wireframeModel.draw(this.context.renderPass);\n    }\n    if (filled) {\n      // model.setProps({isIndexed: false});\n      fillModel.setVertexCount(fillVertexCount);\n      fillModel.shaderInputs.setProps({\n        column: {\n          ...columnProps,\n          isStroke: false\n        }\n      });\n      fillModel.draw(this.context.renderPass);\n    }\n    // When drawing 2d: draw fill before stroke so that the outline is always on top\n    if (!extruded && stroked) {\n      // model.setProps({isIndexed: false});\n      // The width of the stroke is achieved by flattening the side of the cylinder.\n      // Skip the last 1/3 of the vertices which is the top.\n      fillModel.setVertexCount(fillVertexCount * 2 / 3);\n      fillModel.shaderInputs.setProps({\n        column: {\n          ...columnProps,\n          isStroke: true\n        }\n      });\n      fillModel.draw(this.context.renderPass);\n    }\n  }\n}\nColumnLayer.layerName = 'ColumnLayer';\nColumnLayer.defaultProps = defaultProps;\nexport default ColumnLayer;\n//# sourceMappingURL=column-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}