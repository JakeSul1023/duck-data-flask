{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { equals } from '@math.gl/core';\nimport { _deepEqual as deepEqual } from '@deck.gl/core';\nimport CollisionFilterPass from \"./collision-filter-pass.js\";\n// Factor by which to downscale Collision FBO relative to canvas\nconst DOWNSCALE = 2;\nexport default class CollisionFilterEffect {\n  constructor() {\n    this.id = 'collision-filter-effect';\n    this.props = null;\n    this.useInPicking = true;\n    this.order = 1;\n    this.channels = {};\n    this.collisionFBOs = {};\n  }\n  setup(context) {\n    this.context = context;\n    const {\n      device\n    } = context;\n    this.dummyCollisionMap = device.createTexture({\n      width: 1,\n      height: 1\n    });\n    this.collisionFilterPass = new CollisionFilterPass(device, {\n      id: 'default-collision-filter'\n    });\n  }\n  preRender({\n    effects: allEffects,\n    layers,\n    layerFilter,\n    viewports,\n    onViewportActive,\n    views,\n    isPicking,\n    preRenderStats = {}\n  }) {\n    // This can only be called in preRender() after setup() where context is populated\n    const {\n      device\n    } = this.context;\n    if (isPicking) {\n      // Do not update on picking pass\n      return;\n    }\n    const collisionLayers = layers.filter(\n    // @ts-ignore\n    ({\n      props: {\n        visible,\n        collisionEnabled\n      }\n    }) => visible && collisionEnabled);\n    if (collisionLayers.length === 0) {\n      this.channels = {};\n      return;\n    }\n    // Detect if mask has rendered. TODO: better dependency system for Effects\n    const effects = allEffects?.filter(e => e.useInPicking && preRenderStats[e.id]);\n    const maskEffectRendered = preRenderStats['mask-effect']?.didRender;\n    // Collect layers to render\n    const channels = this._groupByCollisionGroup(device, collisionLayers);\n    const viewport = viewports[0];\n    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport) || maskEffectRendered;\n    // Resize framebuffers to match canvas\n    for (const collisionGroup in channels) {\n      const collisionFBO = this.collisionFBOs[collisionGroup];\n      const renderInfo = channels[collisionGroup];\n      // @ts-expect-error TODO - assuming WebGL context\n      const [width, height] = device.canvasContext.getPixelSize();\n      collisionFBO.resize({\n        width: width / DOWNSCALE,\n        height: height / DOWNSCALE\n      });\n      this._render(renderInfo, {\n        effects,\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n    }\n    // debugFBO(this.collisionFBOs[Object.keys(channels)[0]], {minimap: true});\n  }\n  _render(renderInfo, {\n    effects,\n    layerFilter,\n    onViewportActive,\n    views,\n    viewport,\n    viewportChanged\n  }) {\n    const {\n      collisionGroup\n    } = renderInfo;\n    const oldRenderInfo = this.channels[collisionGroup];\n    if (!oldRenderInfo) {\n      return;\n    }\n    const needsRender = viewportChanged ||\n    // If render info is new\n    renderInfo === oldRenderInfo ||\n    // If sublayers have changed\n    !deepEqual(oldRenderInfo.layers, renderInfo.layers, 1) ||\n    // If a sublayer's bounds have been updated\n    renderInfo.layerBounds.some((b, i) => !equals(b, oldRenderInfo.layerBounds[i])) ||\n    // If a sublayer's isLoaded state has been updated\n    renderInfo.allLayersLoaded !== oldRenderInfo.allLayersLoaded ||\n    // Some prop is in transition\n    renderInfo.layers.some(layer => layer.props.transitions);\n    this.channels[collisionGroup] = renderInfo;\n    if (needsRender) {\n      this.lastViewport = viewport;\n      const collisionFBO = this.collisionFBOs[collisionGroup];\n      // Rerender collision FBO\n      this.collisionFilterPass.renderCollisionMap(collisionFBO, {\n        pass: 'collision-filter',\n        isPicking: true,\n        layers: renderInfo.layers,\n        effects,\n        layerFilter,\n        viewports: viewport ? [viewport] : [],\n        onViewportActive,\n        views,\n        shaderModuleProps: {\n          collision: {\n            enabled: true,\n            // To avoid feedback loop forming between Framebuffer and active Texture.\n            dummyCollisionMap: this.dummyCollisionMap\n          },\n          project: {\n            // @ts-expect-error TODO - assuming WebGL context\n            devicePixelRatio: collisionFBO.device.canvasContext.getDevicePixelRatio() / DOWNSCALE\n          }\n        }\n      });\n    }\n  }\n  /**\n   * Group layers by collisionGroup\n   * Returns a map from collisionGroup to render info\n   */\n  _groupByCollisionGroup(device, collisionLayers) {\n    const channelMap = {};\n    for (const layer of collisionLayers) {\n      const collisionGroup = layer.props.collisionGroup;\n      let channelInfo = channelMap[collisionGroup];\n      if (!channelInfo) {\n        channelInfo = {\n          collisionGroup,\n          layers: [],\n          layerBounds: [],\n          allLayersLoaded: true\n        };\n        channelMap[collisionGroup] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n      if (!layer.isLoaded) {\n        channelInfo.allLayersLoaded = false;\n      }\n    }\n    // Create any new passes and remove any old ones\n    for (const collisionGroup of Object.keys(channelMap)) {\n      if (!this.collisionFBOs[collisionGroup]) {\n        this.createFBO(device, collisionGroup);\n      }\n      if (!this.channels[collisionGroup]) {\n        this.channels[collisionGroup] = channelMap[collisionGroup];\n      }\n    }\n    for (const collisionGroup of Object.keys(this.collisionFBOs)) {\n      if (!channelMap[collisionGroup]) {\n        this.destroyFBO(collisionGroup);\n      }\n    }\n    return channelMap;\n  }\n  getShaderModuleProps(layer) {\n    const {\n      collisionGroup,\n      collisionEnabled\n    } = layer.props;\n    const {\n      collisionFBOs,\n      dummyCollisionMap\n    } = this;\n    const collisionFBO = collisionFBOs[collisionGroup];\n    const enabled = collisionEnabled && Boolean(collisionFBO);\n    return {\n      collision: {\n        enabled,\n        collisionFBO,\n        dummyCollisionMap: dummyCollisionMap\n      }\n    };\n  }\n  cleanup() {\n    if (this.dummyCollisionMap) {\n      this.dummyCollisionMap.delete();\n      this.dummyCollisionMap = undefined;\n    }\n    this.channels = {};\n    for (const collisionGroup of Object.keys(this.collisionFBOs)) {\n      this.destroyFBO(collisionGroup);\n    }\n    this.collisionFBOs = {};\n    this.lastViewport = undefined;\n  }\n  createFBO(device, collisionGroup) {\n    // @ts-expect-error\n    const {\n      width,\n      height\n    } = device.gl.canvas;\n    const collisionMap = device.createTexture({\n      format: 'rgba8unorm',\n      width,\n      height,\n      sampler: {\n        minFilter: 'nearest',\n        magFilter: 'nearest',\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge'\n      }\n    });\n    // @ts-ignore\n    const depthStencilAttachment = device.createTexture({\n      format: 'depth16unorm',\n      width,\n      height,\n      mipmaps: false\n    });\n    this.collisionFBOs[collisionGroup] = device.createFramebuffer({\n      id: `collision-${collisionGroup}`,\n      width,\n      height,\n      colorAttachments: [collisionMap],\n      depthStencilAttachment\n    });\n  }\n  destroyFBO(collisionGroup) {\n    const fbo = this.collisionFBOs[collisionGroup];\n    fbo.colorAttachments[0]?.destroy();\n    fbo.depthStencilAttachment?.destroy();\n    fbo.destroy();\n    delete this.collisionFBOs[collisionGroup];\n  }\n}","map":{"version":3,"names":["equals","_deepEqual","deepEqual","CollisionFilterPass","DOWNSCALE","CollisionFilterEffect","constructor","id","props","useInPicking","order","channels","collisionFBOs","setup","context","device","dummyCollisionMap","createTexture","width","height","collisionFilterPass","preRender","effects","allEffects","layers","layerFilter","viewports","onViewportActive","views","isPicking","preRenderStats","collisionLayers","filter","visible","collisionEnabled","length","e","maskEffectRendered","didRender","_groupByCollisionGroup","viewport","viewportChanged","lastViewport","collisionGroup","collisionFBO","renderInfo","canvasContext","getPixelSize","resize","_render","oldRenderInfo","needsRender","layerBounds","some","b","i","allLayersLoaded","layer","transitions","renderCollisionMap","pass","shaderModuleProps","collision","enabled","project","devicePixelRatio","getDevicePixelRatio","channelMap","channelInfo","push","getBounds","isLoaded","Object","keys","createFBO","destroyFBO","getShaderModuleProps","Boolean","cleanup","delete","undefined","gl","canvas","collisionMap","format","sampler","minFilter","magFilter","addressModeU","addressModeV","depthStencilAttachment","mipmaps","createFramebuffer","colorAttachments","fbo","destroy"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\extensions\\src\\collision-filter\\collision-filter-effect.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, Framebuffer, Texture} from '@luma.gl/core';\nimport {equals} from '@math.gl/core';\nimport {_deepEqual as deepEqual} from '@deck.gl/core';\nimport type {Effect, EffectContext, Layer, PreRenderOptions, Viewport} from '@deck.gl/core';\nimport CollisionFilterPass from './collision-filter-pass';\nimport {MaskPreRenderStats} from '../mask/mask-effect';\n// import {debugFBO} from '../utils/debug';\n\nimport type {CollisionFilterExtensionProps} from './collision-filter-extension';\nimport type {CollisionModuleProps} from './shader-module';\n\n// Factor by which to downscale Collision FBO relative to canvas\nconst DOWNSCALE = 2;\n\ntype RenderInfo = {\n  collisionGroup: string;\n  layers: Layer<CollisionFilterExtensionProps>[];\n  layerBounds: ([number[], number[]] | null)[];\n  allLayersLoaded: boolean;\n};\n\nexport default class CollisionFilterEffect implements Effect {\n  id = 'collision-filter-effect';\n  props = null;\n  useInPicking = true;\n  order = 1;\n\n  private context?: EffectContext;\n  private channels: Record<string, RenderInfo> = {};\n  private collisionFilterPass?: CollisionFilterPass;\n  private collisionFBOs: Record<string, Framebuffer> = {};\n  private dummyCollisionMap?: Texture;\n  private lastViewport?: Viewport;\n\n  setup(context: EffectContext) {\n    this.context = context;\n    const {device} = context;\n    this.dummyCollisionMap = device.createTexture({width: 1, height: 1});\n    this.collisionFilterPass = new CollisionFilterPass(device, {id: 'default-collision-filter'});\n  }\n\n  preRender({\n    effects: allEffects,\n    layers,\n    layerFilter,\n    viewports,\n    onViewportActive,\n    views,\n    isPicking,\n    preRenderStats = {}\n  }: PreRenderOptions): void {\n    // This can only be called in preRender() after setup() where context is populated\n    const {device} = this.context!;\n\n    if (isPicking) {\n      // Do not update on picking pass\n      return;\n    }\n\n    const collisionLayers = layers.filter(\n      // @ts-ignore\n      ({props: {visible, collisionEnabled}}) => visible && collisionEnabled\n    ) as Layer<CollisionFilterExtensionProps>[];\n    if (collisionLayers.length === 0) {\n      this.channels = {};\n      return;\n    }\n\n    // Detect if mask has rendered. TODO: better dependency system for Effects\n    const effects = allEffects?.filter(e => e.useInPicking && preRenderStats[e.id]);\n    const maskEffectRendered = (preRenderStats['mask-effect'] as MaskPreRenderStats)?.didRender;\n\n    // Collect layers to render\n    const channels = this._groupByCollisionGroup(device, collisionLayers);\n\n    const viewport = viewports[0];\n    const viewportChanged =\n      !this.lastViewport || !this.lastViewport.equals(viewport) || maskEffectRendered;\n\n    // Resize framebuffers to match canvas\n    for (const collisionGroup in channels) {\n      const collisionFBO = this.collisionFBOs[collisionGroup];\n      const renderInfo = channels[collisionGroup];\n      // @ts-expect-error TODO - assuming WebGL context\n      const [width, height] = device.canvasContext.getPixelSize();\n      collisionFBO.resize({\n        width: width / DOWNSCALE,\n        height: height / DOWNSCALE\n      });\n      this._render(renderInfo, {\n        effects,\n        layerFilter,\n        onViewportActive,\n        views,\n        viewport,\n        viewportChanged\n      });\n    }\n\n    // debugFBO(this.collisionFBOs[Object.keys(channels)[0]], {minimap: true});\n  }\n\n  private _render(\n    renderInfo: RenderInfo,\n    {\n      effects,\n      layerFilter,\n      onViewportActive,\n      views,\n      viewport,\n      viewportChanged\n    }: {\n      effects: PreRenderOptions['effects'];\n      layerFilter: PreRenderOptions['layerFilter'];\n      onViewportActive: PreRenderOptions['onViewportActive'];\n      views: PreRenderOptions['views'];\n      viewport: Viewport;\n      viewportChanged: boolean;\n    }\n  ) {\n    const {collisionGroup} = renderInfo;\n    const oldRenderInfo = this.channels[collisionGroup];\n    if (!oldRenderInfo) {\n      return;\n    }\n\n    const needsRender =\n      viewportChanged ||\n      // If render info is new\n      renderInfo === oldRenderInfo ||\n      // If sublayers have changed\n      !deepEqual(oldRenderInfo.layers, renderInfo.layers, 1) ||\n      // If a sublayer's bounds have been updated\n      renderInfo.layerBounds.some((b, i) => !equals(b, oldRenderInfo.layerBounds[i])) ||\n      // If a sublayer's isLoaded state has been updated\n      renderInfo.allLayersLoaded !== oldRenderInfo.allLayersLoaded ||\n      // Some prop is in transition\n      renderInfo.layers.some(layer => layer.props.transitions);\n\n    this.channels[collisionGroup] = renderInfo;\n\n    if (needsRender) {\n      this.lastViewport = viewport;\n      const collisionFBO = this.collisionFBOs[collisionGroup];\n\n      // Rerender collision FBO\n      this.collisionFilterPass!.renderCollisionMap(collisionFBO, {\n        pass: 'collision-filter',\n        isPicking: true,\n        layers: renderInfo.layers,\n        effects,\n        layerFilter,\n        viewports: viewport ? [viewport] : [],\n        onViewportActive,\n        views,\n        shaderModuleProps: {\n          collision: {\n            enabled: true,\n            // To avoid feedback loop forming between Framebuffer and active Texture.\n            dummyCollisionMap: this.dummyCollisionMap\n          },\n          project: {\n            // @ts-expect-error TODO - assuming WebGL context\n            devicePixelRatio: collisionFBO.device.canvasContext.getDevicePixelRatio() / DOWNSCALE\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Group layers by collisionGroup\n   * Returns a map from collisionGroup to render info\n   */\n  private _groupByCollisionGroup(\n    device: Device,\n    collisionLayers: Layer<CollisionFilterExtensionProps>[]\n  ): Record<string, RenderInfo> {\n    const channelMap = {};\n    for (const layer of collisionLayers) {\n      const collisionGroup = layer.props.collisionGroup!;\n      let channelInfo = channelMap[collisionGroup];\n      if (!channelInfo) {\n        channelInfo = {collisionGroup, layers: [], layerBounds: [], allLayersLoaded: true};\n        channelMap[collisionGroup] = channelInfo;\n      }\n      channelInfo.layers.push(layer);\n      channelInfo.layerBounds.push(layer.getBounds());\n      if (!layer.isLoaded) {\n        channelInfo.allLayersLoaded = false;\n      }\n    }\n\n    // Create any new passes and remove any old ones\n    for (const collisionGroup of Object.keys(channelMap)) {\n      if (!this.collisionFBOs[collisionGroup]) {\n        this.createFBO(device, collisionGroup);\n      }\n      if (!this.channels[collisionGroup]) {\n        this.channels[collisionGroup] = channelMap[collisionGroup];\n      }\n    }\n    for (const collisionGroup of Object.keys(this.collisionFBOs)) {\n      if (!channelMap[collisionGroup]) {\n        this.destroyFBO(collisionGroup);\n      }\n    }\n\n    return channelMap;\n  }\n\n  getShaderModuleProps(layer: Layer): {\n    collision: CollisionModuleProps;\n  } {\n    const {collisionGroup, collisionEnabled} = (layer as Layer<CollisionFilterExtensionProps>)\n      .props;\n    const {collisionFBOs, dummyCollisionMap} = this;\n    const collisionFBO = collisionFBOs[collisionGroup!];\n    const enabled = collisionEnabled && Boolean(collisionFBO);\n    return {\n      collision: {\n        enabled,\n        collisionFBO,\n        dummyCollisionMap: dummyCollisionMap!\n      }\n    };\n  }\n\n  cleanup(): void {\n    if (this.dummyCollisionMap) {\n      this.dummyCollisionMap.delete();\n      this.dummyCollisionMap = undefined;\n    }\n    this.channels = {};\n    for (const collisionGroup of Object.keys(this.collisionFBOs)) {\n      this.destroyFBO(collisionGroup);\n    }\n    this.collisionFBOs = {};\n    this.lastViewport = undefined;\n  }\n\n  createFBO(device: Device, collisionGroup: string) {\n    // @ts-expect-error\n    const {width, height} = device.gl.canvas;\n    const collisionMap = device.createTexture({\n      format: 'rgba8unorm',\n      width,\n      height,\n      sampler: {\n        minFilter: 'nearest',\n        magFilter: 'nearest',\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge'\n      }\n    });\n\n    // @ts-ignore\n    const depthStencilAttachment = device.createTexture({\n      format: 'depth16unorm',\n      width,\n      height,\n      mipmaps: false\n    });\n    this.collisionFBOs[collisionGroup] = device.createFramebuffer({\n      id: `collision-${collisionGroup}`,\n      width,\n      height,\n      colorAttachments: [collisionMap],\n      depthStencilAttachment\n    });\n  }\n\n  destroyFBO(collisionGroup: string) {\n    const fbo = this.collisionFBOs[collisionGroup];\n    fbo.colorAttachments[0]?.destroy();\n    fbo.depthStencilAttachment?.destroy();\n    fbo.destroy();\n    delete this.collisionFBOs[collisionGroup];\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}