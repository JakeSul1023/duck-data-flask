{"ast":null,"code":"import { log } from '@luma.gl/core';\n// NOTE: Modules other than `@luma.gl/webgl` should not import `GL` from\n// `@luma.gl/constants`. Locally we use `GLEnum` instead of `GL` to avoid\n// conflicts with the `babel-plugin-inline-webgl-constants` plugin.\n// eslint-disable-next-line no-shadow\nvar GLEnum;\n(function (GLEnum) {\n  GLEnum[GLEnum[\"FUNC_ADD\"] = 32774] = \"FUNC_ADD\";\n  GLEnum[GLEnum[\"ONE\"] = 1] = \"ONE\";\n  GLEnum[GLEnum[\"SRC_ALPHA\"] = 770] = \"SRC_ALPHA\";\n  GLEnum[GLEnum[\"ONE_MINUS_SRC_ALPHA\"] = 771] = \"ONE_MINUS_SRC_ALPHA\";\n  GLEnum[GLEnum[\"TEXTURE_MIN_FILTER\"] = 10241] = \"TEXTURE_MIN_FILTER\";\n  GLEnum[GLEnum[\"LINEAR\"] = 9729] = \"LINEAR\";\n  GLEnum[GLEnum[\"LINEAR_MIPMAP_NEAREST\"] = 9985] = \"LINEAR_MIPMAP_NEAREST\";\n  GLEnum[GLEnum[\"UNPACK_FLIP_Y_WEBGL\"] = 37440] = \"UNPACK_FLIP_Y_WEBGL\";\n})(GLEnum || (GLEnum = {}));\n/**\n * Parses a GLTF material definition into uniforms and parameters for the PBR shader module\n */\nexport function parsePBRMaterial(device, material, attributes, options) {\n  const parsedMaterial = {\n    defines: {\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    },\n    bindings: {},\n    uniforms: {\n      // TODO: find better values?\n      camera: [0, 0, 0],\n      // Model should override\n      metallicRoughnessValues: [1, 1] // Default is 1 and 1\n    },\n    parameters: {},\n    glParameters: {},\n    generatedTextures: []\n  };\n  // TODO - always available\n  parsedMaterial.defines.USE_TEX_LOD = 1;\n  const {\n    imageBasedLightingEnvironment\n  } = options;\n  if (imageBasedLightingEnvironment) {\n    parsedMaterial.bindings.pbr_diffuseEnvSampler = imageBasedLightingEnvironment.diffuseEnvSampler.texture;\n    parsedMaterial.bindings.pbr_specularEnvSampler = imageBasedLightingEnvironment.specularEnvSampler.texture;\n    parsedMaterial.bindings.pbr_BrdfLUT = imageBasedLightingEnvironment.brdfLutTexture.texture;\n    parsedMaterial.uniforms.scaleIBLAmbient = [1, 1];\n  }\n  if (options?.pbrDebug) {\n    parsedMaterial.defines.PBR_DEBUG = 1;\n    // Override final color for reference app visualization of various parameters in the lighting equation.\n    parsedMaterial.uniforms.scaleDiffBaseMR = [0, 0, 0, 0];\n    parsedMaterial.uniforms.scaleFGDSpec = [0, 0, 0, 0];\n  }\n  if (attributes.NORMAL) parsedMaterial.defines.HAS_NORMALS = 1;\n  if (attributes.TANGENT && options?.useTangents) parsedMaterial.defines.HAS_TANGENTS = 1;\n  if (attributes.TEXCOORD_0) parsedMaterial.defines.HAS_UV = 1;\n  if (options?.imageBasedLightingEnvironment) parsedMaterial.defines.USE_IBL = 1;\n  if (options?.lights) parsedMaterial.defines.USE_LIGHTS = 1;\n  if (material) {\n    parseMaterial(device, material, parsedMaterial);\n  }\n  return parsedMaterial;\n}\n/** Parse GLTF material record */\nfunction parseMaterial(device, material, parsedMaterial) {\n  parsedMaterial.uniforms.unlit = Boolean(material.unlit);\n  if (material.pbrMetallicRoughness) {\n    parsePbrMetallicRoughness(device, material.pbrMetallicRoughness, parsedMaterial);\n  }\n  if (material.normalTexture) {\n    addTexture(device, material.normalTexture, 'pbr_normalSampler', 'HAS_NORMALMAP', parsedMaterial);\n    const {\n      scale = 1\n    } = material.normalTexture;\n    parsedMaterial.uniforms.normalScale = scale;\n  }\n  if (material.occlusionTexture) {\n    addTexture(device, material.occlusionTexture, 'pbr_occlusionSampler', 'HAS_OCCLUSIONMAP', parsedMaterial);\n    const {\n      strength = 1\n    } = material.occlusionTexture;\n    parsedMaterial.uniforms.occlusionStrength = strength;\n  }\n  if (material.emissiveTexture) {\n    addTexture(device, material.emissiveTexture, 'pbr_emissiveSampler', 'HAS_EMISSIVEMAP', parsedMaterial);\n    parsedMaterial.uniforms.emissiveFactor = material.emissiveFactor || [0, 0, 0];\n  }\n  switch (material.alphaMode) {\n    case 'MASK':\n      const {\n        alphaCutoff = 0.5\n      } = material;\n      parsedMaterial.defines.ALPHA_CUTOFF = 1;\n      parsedMaterial.uniforms.alphaCutoff = alphaCutoff;\n      break;\n    case 'BLEND':\n      log.warn('glTF BLEND alphaMode might not work well because it requires mesh sorting')();\n      // WebGPU style parameters\n      parsedMaterial.parameters.blendColorOperation = 'add';\n      parsedMaterial.parameters.blendColorSrcFactor = 'src-alpha';\n      parsedMaterial.parameters.blendColorDstFactor = 'one-minus-src-alpha';\n      parsedMaterial.parameters.blendAlphaOperation = 'add';\n      parsedMaterial.parameters.blendAlphaSrcFactor = 'one';\n      parsedMaterial.parameters.blendAlphaDstFactor = 'one-minus-src-alpha';\n      // GL parameters\n      parsedMaterial.glParameters.blend = true;\n      parsedMaterial.glParameters.blendEquation = GLEnum.FUNC_ADD;\n      parsedMaterial.glParameters.blendFunc = [GLEnum.SRC_ALPHA, GLEnum.ONE_MINUS_SRC_ALPHA, GLEnum.ONE, GLEnum.ONE_MINUS_SRC_ALPHA];\n      break;\n  }\n}\n/** Parse GLTF material sub record */\nfunction parsePbrMetallicRoughness(device, pbrMetallicRoughness, parsedMaterial) {\n  if (pbrMetallicRoughness.baseColorTexture) {\n    addTexture(device, pbrMetallicRoughness.baseColorTexture, 'pbr_baseColorSampler', 'HAS_BASECOLORMAP', parsedMaterial);\n  }\n  parsedMaterial.uniforms.baseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n  if (pbrMetallicRoughness.metallicRoughnessTexture) {\n    addTexture(device, pbrMetallicRoughness.metallicRoughnessTexture, 'pbr_metallicRoughnessSampler', 'HAS_METALROUGHNESSMAP', parsedMaterial);\n  }\n  const {\n    metallicFactor = 1,\n    roughnessFactor = 1\n  } = pbrMetallicRoughness;\n  parsedMaterial.uniforms.metallicRoughnessValues = [metallicFactor, roughnessFactor];\n}\n/** Create a texture from a glTF texture/sampler/image combo and add it to bindings */\nfunction addTexture(device, gltfTexture, uniformName, define = null, parsedMaterial) {\n  const parameters = gltfTexture?.texture?.sampler?.parameters || {};\n  const image = gltfTexture.texture.source.image;\n  let textureOptions;\n  let specialTextureParameters = {};\n  if (image.compressed) {\n    textureOptions = image;\n    specialTextureParameters = {\n      [GLEnum.TEXTURE_MIN_FILTER]: image.data.length > 1 ? GLEnum.LINEAR_MIPMAP_NEAREST : GLEnum.LINEAR\n    };\n  } else {\n    // Texture2D accepts a promise that returns an image as data (Async Textures)\n    textureOptions = {\n      data: image\n    };\n  }\n  const texture = device.createTexture({\n    id: gltfTexture.uniformName || gltfTexture.id,\n    parameters: {\n      ...parameters,\n      ...specialTextureParameters\n    },\n    pixelStore: {\n      [GLEnum.UNPACK_FLIP_Y_WEBGL]: false\n    },\n    ...textureOptions\n  });\n  parsedMaterial.bindings[uniformName] = texture;\n  if (define) parsedMaterial.defines[define] = 1;\n  parsedMaterial.generatedTextures.push(texture);\n}\n/*\n/**\n * Parses a GLTF material definition into uniforms and parameters for the PBR shader module\n *\nexport class PBRMaterialParser {\n  readonly device: Device;\n\n  readonly defines: Record<string, number | boolean>;\n  readonly bindings: Record<string, Binding>;\n  readonly uniforms: Record<string, any>;\n  readonly parameters: Record<string, any>;\n\n  /** Hold on to generated textures, we destroy them in the destroy method *\n  readonly generatedTextures: Texture[];\n\n  constructor(device: Device, props: PBRMaterialParserProps) {\n    const {attributes, material, pbrDebug, imageBasedLightingEnvironment, lights, useTangents} =\n      props;\n    this.device = device;\n\n    this.defines = {\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    };\n\n    if (this.device.features.has('glsl-texture-lod')) {\n      this.defines.USE_TEX_LOD = 1;\n    }\n\n    this.uniforms = {\n      // TODO: find better values?\n      camera: [0, 0, 0], // Model should override\n\n      metallicRoughnessValues: [1, 1] // Default is 1 and 1\n    };\n\n    this.bindings = {};\n\n    this.parameters = {};\n    this.generatedTextures = [];\n\n    if (imageBasedLightingEnvironment) {\n      this.bindings.pbr_diffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();\n      this.bindings.pbr_specularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();\n      this.bindings.pbr_BrdfLUT = imageBasedLightingEnvironment.getBrdfTexture();\n      this.uniforms.scaleIBLAmbient = [1, 1];\n    }\n\n    if (pbrDebug) {\n      // Override final color for reference app visualization\n      // of various parameters in the lighting equation.\n      this.uniforms.scaleDiffBaseMR = [0, 0, 0, 0];\n      this.uniforms.scaleFGDSpec = [0, 0, 0, 0];\n    }\n\n    this.defineIfPresent(attributes.NORMAL, 'HAS_NORMALS');\n    this.defineIfPresent(attributes.TANGENT && useTangents, 'HAS_TANGENTS');\n    this.defineIfPresent(attributes.TEXCOORD_0, 'HAS_UV');\n\n    this.defineIfPresent(imageBasedLightingEnvironment, 'USE_IBL');\n    this.defineIfPresent(lights, 'USE_LIGHTS');\n    this.defineIfPresent(pbrDebug, 'PBR_DEBUG');\n\n    if (material) {\n      this.parseMaterial(material);\n    }\n  }\n\n  /**\n   * Destroy all generated resources to release memory.\n   *\n  destroy(): void {\n    this.generatedTextures.forEach(texture => texture.destroy());\n  }\n\n  /** Add a define if the the value is non-nullish *\n  defineIfPresent(value: unknown, name: string): void {\n    if (value) {\n      this.defines[name] = 1;\n    }\n  }\n\n  /** Parse GLTF material record *\n  parseMaterial(material) {\n    this.uniforms.unlit = Boolean(material.unlit);\n\n    if (material.pbrMetallicRoughness) {\n      this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);\n    }\n    if (material.normalTexture) {\n      this.addTexture(material.normalTexture, 'pbr_normalSampler', 'HAS_NORMALMAP');\n\n      const {scale = 1} = material.normalTexture;\n      this.uniforms.normalScale = scale;\n    }\n    if (material.occlusionTexture) {\n      this.addTexture(material.occlusionTexture, 'pbr_occlusionSampler', 'HAS_OCCLUSIONMAP');\n\n      const {strength = 1} = material.occlusionTexture;\n      this.uniforms.occlusionStrength = strength;\n    }\n    if (material.emissiveTexture) {\n      this.addTexture(material.emissiveTexture, 'pbr_emissiveSampler', 'HAS_EMISSIVEMAP');\n      this.uniforms.emissiveFactor = material.emissiveFactor || [0, 0, 0];\n    }\n    if (material.alphaMode === 'MASK') {\n      const {alphaCutoff = 0.5} = material;\n      this.defines.ALPHA_CUTOFF = 1;\n      this.uniforms.alphaCutoff = alphaCutoff;\n    } else if (material.alphaMode === 'BLEND') {\n      log.warn('BLEND alphaMode might not work well because it requires mesh sorting')();\n      Object.assign(this.parameters, {\n        blend: true,\n        blendEquation: GL.FUNC_ADD,\n        blendFunc: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA, GL.ONE, GL.ONE_MINUS_SRC_ALPHA]\n      });\n    }\n  }\n\n  /** Parse GLTF material sub record *\n  parsePbrMetallicRoughness(pbrMetallicRoughness) {\n    if (pbrMetallicRoughness.baseColorTexture) {\n      this.addTexture(\n        pbrMetallicRoughness.baseColorTexture,\n        'pbr_baseColorSampler',\n        'HAS_BASECOLORMAP'\n      );\n    }\n    this.uniforms.baseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n    if (pbrMetallicRoughness.metallicRoughnessTexture) {\n      this.addTexture(\n        pbrMetallicRoughness.metallicRoughnessTexture,\n        'pbr_metallicRoughnessSampler',\n        'HAS_METALROUGHNESSMAP'\n      );\n    }\n    const {metallicFactor = 1, roughnessFactor = 1} = pbrMetallicRoughness;\n    this.uniforms.metallicRoughnessValues = [metallicFactor, roughnessFactor];\n  }\n\n  /** Create a texture from a glTF texture/sampler/image combo and add it to bindings *\n  addTexture(gltfTexture, name, define = null) {\n    const parameters = gltfTexture?.texture?.sampler?.parameters || {};\n\n    const image = gltfTexture.texture.source.image;\n    let textureOptions;\n    let specialTextureParameters = {};\n    if (image.compressed) {\n      textureOptions = image;\n      specialTextureParameters = {\n        [GL.TEXTURE_MIN_FILTER]: image.data.length > 1 ? GL.LINEAR_MIPMAP_NEAREST : GL.LINEAR\n      };\n    } else {\n      // Texture2D accepts a promise that returns an image as data (Async Textures)\n      textureOptions = {data: image};\n    }\n\n    const texture: Texture = this.device.createTexture({\n      id: gltfTexture.name || gltfTexture.id,\n      parameters: {\n        ...parameters,\n        ...specialTextureParameters\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      },\n      ...textureOptions\n    });\n    this.bindings[name] = texture;\n    this.defineIfPresent(define, define);\n    this.generatedTextures.push(texture);\n  }\n}\n*/\n//# sourceMappingURL=parse-pbr-material.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}