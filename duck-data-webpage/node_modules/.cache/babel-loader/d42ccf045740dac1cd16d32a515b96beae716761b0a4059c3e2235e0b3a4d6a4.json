{"ast":null,"code":"/**\n * https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_transform/README.md\n */\nimport { Vector3, Matrix3 } from '@math.gl/core';\nimport { getAccessorArrayTypeAndLength } from \"../gltf-utils/gltf-utils.js\";\nimport { BYTES, COMPONENTS } from \"../gltf-utils/gltf-constants.js\";\nimport { GLTFScenegraph } from \"../api/gltf-scenegraph.js\";\n/** Extension name */\nconst KHR_TEXTURE_TRANSFORM = 'KHR_texture_transform';\nexport const name = KHR_TEXTURE_TRANSFORM;\nconst scratchVector = new Vector3();\nconst scratchRotationMatrix = new Matrix3();\nconst scratchScaleMatrix = new Matrix3();\n/**\n * The extension entry to process the transformation\n * @param gltfData gltf buffers and json\n * @param options GLTFLoader options\n */\nexport async function decode(gltfData, options) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const hasExtension = gltfScenegraph.hasExtension(KHR_TEXTURE_TRANSFORM);\n  if (!hasExtension || !options.gltf?.loadBuffers) {\n    return;\n  }\n  const materials = gltfData.json.materials || [];\n  for (let i = 0; i < materials.length; i++) {\n    transformTexCoords(i, gltfData);\n  }\n}\n/**\n * Transform TEXCOORD by material\n * @param materialIndex processing material index\n * @param gltfData gltf buffers and json\n */\nfunction transformTexCoords(materialIndex, gltfData) {\n  const material = gltfData.json.materials?.[materialIndex];\n  const materialTextures = [material?.pbrMetallicRoughness?.baseColorTexture, material?.emissiveTexture, material?.normalTexture, material?.occlusionTexture, material?.pbrMetallicRoughness?.metallicRoughnessTexture];\n  // Save processed texCoords in order no to process the same twice\n  const processedTexCoords = [];\n  for (const textureInfo of materialTextures) {\n    if (textureInfo && textureInfo?.extensions?.[KHR_TEXTURE_TRANSFORM]) {\n      transformPrimitives(gltfData, materialIndex, textureInfo, processedTexCoords);\n    }\n  }\n}\n/**\n * Transform primitives of the particular material\n * @param gltfData gltf data\n * @param materialIndex primitives with this material will be transformed\n * @param texture texture object\n * @param processedTexCoords storage to save already processed texCoords\n */\nfunction transformPrimitives(gltfData, materialIndex, texture, processedTexCoords) {\n  const transformParameters = getTransformParameters(texture, processedTexCoords);\n  if (!transformParameters) {\n    return;\n  }\n  const meshes = gltfData.json.meshes || [];\n  for (const mesh of meshes) {\n    for (const primitive of mesh.primitives) {\n      const material = primitive.material;\n      if (Number.isFinite(material) && materialIndex === material) {\n        transformPrimitive(gltfData, primitive, transformParameters);\n      }\n    }\n  }\n}\n/**\n * Get parameters for TEXCOORD transformation\n * @param texture texture object\n * @param processedTexCoords storage to save already processed texCoords\n * @returns texCoord couple and transformation matrix\n */\nfunction getTransformParameters(texture, processedTexCoords) {\n  const textureInfo = texture.extensions?.[KHR_TEXTURE_TRANSFORM];\n  const {\n    texCoord: originalTexCoord = 0\n  } = texture;\n  // If texCoord is not set in the extension, original attribute data will be replaced\n  const {\n    texCoord = originalTexCoord\n  } = textureInfo;\n  // Make sure that couple [originalTexCoord, extensionTexCoord] is not processed twice\n  const isProcessed = processedTexCoords.findIndex(([original, newTexCoord]) => original === originalTexCoord && newTexCoord === texCoord) !== -1;\n  if (!isProcessed) {\n    const matrix = makeTransformationMatrix(textureInfo);\n    if (originalTexCoord !== texCoord) {\n      texture.texCoord = texCoord;\n    }\n    processedTexCoords.push([originalTexCoord, texCoord]);\n    return {\n      originalTexCoord,\n      texCoord,\n      matrix\n    };\n  }\n  return null;\n}\n/**\n * Transform `TEXCOORD_0` attribute in the primitive\n * @param gltfData gltf data\n * @param primitive primitive object\n * @param transformParameters texCoord couple and transformation matrix\n */\nfunction transformPrimitive(gltfData, primitive, transformParameters) {\n  const {\n    originalTexCoord,\n    texCoord,\n    matrix\n  } = transformParameters;\n  const texCoordAccessor = primitive.attributes[`TEXCOORD_${originalTexCoord}`];\n  if (Number.isFinite(texCoordAccessor)) {\n    // Get accessor of the `TEXCOORD_0` attribute\n    const accessor = gltfData.json.accessors?.[texCoordAccessor];\n    if (accessor && accessor.bufferView) {\n      // Get `bufferView` of the `accessor`\n      const bufferView = gltfData.json.bufferViews?.[accessor.bufferView];\n      if (bufferView) {\n        // Get `arrayBuffer` the `bufferView` look at\n        const {\n          arrayBuffer,\n          byteOffset: bufferByteOffset\n        } = gltfData.buffers[bufferView.buffer];\n        // Resulting byteOffset is sum of the buffer, accessor and bufferView byte offsets\n        const byteOffset = (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);\n        // Deduce TypedArray type and its length from `accessor` and `bufferView` data\n        const {\n          ArrayType,\n          length\n        } = getAccessorArrayTypeAndLength(accessor, bufferView);\n        // Number of bytes each component occupies\n        const bytes = BYTES[accessor.componentType];\n        // Number of components. For the `TEXCOORD_0` with `VEC2` type, it must return 2\n        const components = COMPONENTS[accessor.type];\n        // Multiplier to calculate the address of the `TEXCOORD_0` element in the arrayBuffer\n        const elementAddressScale = bufferView.byteStride || bytes * components;\n        // Data transform to Float32Array\n        const result = new Float32Array(length);\n        for (let i = 0; i < accessor.count; i++) {\n          // Take [u, v] couple from the arrayBuffer\n          const uv = new ArrayType(arrayBuffer, byteOffset + i * elementAddressScale, 2);\n          // Set and transform Vector3 per https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#overview\n          scratchVector.set(uv[0], uv[1], 1);\n          scratchVector.transformByMatrix3(matrix);\n          // Save result in Float32Array\n          result.set([scratchVector[0], scratchVector[1]], i * components);\n        }\n        // If texCoord the same, replace gltf structural data\n        if (originalTexCoord === texCoord) {\n          updateGltf(accessor, bufferView, gltfData.buffers, result);\n        } else {\n          // If texCoord change, create new attribute\n          createAttribute(texCoord, accessor, primitive, gltfData, result);\n        }\n      }\n    }\n  }\n}\n/**\n * Update GLTF structural objects with new data as we create new `Float32Array` for `TEXCOORD_0`.\n * @param accessor accessor to change\n * @param bufferView bufferView to change\n * @param buffers binary buffers\n * @param newTexcoordArray typed array with data after transformation\n */\nfunction updateGltf(accessor, bufferView, buffers, newTexCoordArray) {\n  accessor.componentType = 5126;\n  buffers.push({\n    arrayBuffer: newTexCoordArray.buffer,\n    byteOffset: 0,\n    byteLength: newTexCoordArray.buffer.byteLength\n  });\n  bufferView.buffer = buffers.length - 1;\n  bufferView.byteLength = newTexCoordArray.buffer.byteLength;\n  bufferView.byteOffset = 0;\n  delete bufferView.byteStride;\n}\n/**\n *\n * @param newTexCoord new `texCoord` value\n * @param originalAccessor original accessor object, that store data before transformation\n * @param primitive primitive object\n * @param gltfData gltf data\n * @param newTexCoordArray typed array with data after transformation\n * @returns\n */\nfunction createAttribute(newTexCoord, originalAccessor, primitive, gltfData, newTexCoordArray) {\n  gltfData.buffers.push({\n    arrayBuffer: newTexCoordArray.buffer,\n    byteOffset: 0,\n    byteLength: newTexCoordArray.buffer.byteLength\n  });\n  const bufferViews = gltfData.json.bufferViews;\n  if (!bufferViews) {\n    return;\n  }\n  bufferViews.push({\n    buffer: gltfData.buffers.length - 1,\n    byteLength: newTexCoordArray.buffer.byteLength,\n    byteOffset: 0\n  });\n  const accessors = gltfData.json.accessors;\n  if (!accessors) {\n    return;\n  }\n  accessors.push({\n    bufferView: bufferViews?.length - 1,\n    byteOffset: 0,\n    componentType: 5126,\n    count: originalAccessor.count,\n    type: 'VEC2'\n  });\n  primitive.attributes[`TEXCOORD_${newTexCoord}`] = accessors.length - 1;\n}\n/**\n * Construct transformation matrix from the extension data (transition, rotation, scale)\n * @param extensionData extension data\n * @returns transformation matrix\n */\nfunction makeTransformationMatrix(extensionData) {\n  const {\n    offset = [0, 0],\n    rotation = 0,\n    scale = [1, 1]\n  } = extensionData;\n  const translationMatrix = new Matrix3().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);\n  const rotationMatrix = scratchRotationMatrix.set(Math.cos(rotation), Math.sin(rotation), 0, -Math.sin(rotation), Math.cos(rotation), 0, 0, 0, 1);\n  const scaleMatrix = scratchScaleMatrix.set(scale[0], 0, 0, 0, scale[1], 0, 0, 0, 1);\n  return translationMatrix.multiplyRight(rotationMatrix).multiplyRight(scaleMatrix);\n}","map":{"version":3,"names":["Vector3","Matrix3","getAccessorArrayTypeAndLength","BYTES","COMPONENTS","GLTFScenegraph","KHR_TEXTURE_TRANSFORM","name","scratchVector","scratchRotationMatrix","scratchScaleMatrix","decode","gltfData","options","gltfScenegraph","hasExtension","gltf","loadBuffers","materials","json","i","length","transformTexCoords","materialIndex","material","materialTextures","pbrMetallicRoughness","baseColorTexture","emissiveTexture","normalTexture","occlusionTexture","metallicRoughnessTexture","processedTexCoords","textureInfo","extensions","transformPrimitives","texture","transformParameters","getTransformParameters","meshes","mesh","primitive","primitives","Number","isFinite","transformPrimitive","texCoord","originalTexCoord","isProcessed","findIndex","original","newTexCoord","matrix","makeTransformationMatrix","push","texCoordAccessor","attributes","accessor","accessors","bufferView","bufferViews","arrayBuffer","byteOffset","bufferByteOffset","buffers","buffer","ArrayType","bytes","componentType","components","type","elementAddressScale","byteStride","result","Float32Array","count","uv","set","transformByMatrix3","updateGltf","createAttribute","newTexCoordArray","byteLength","originalAccessor","extensionData","offset","rotation","scale","translationMatrix","rotationMatrix","Math","cos","sin","scaleMatrix","multiplyRight"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_texture_transform.js"],"sourcesContent":["/**\n * https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_transform/README.md\n */\nimport { Vector3, Matrix3 } from '@math.gl/core';\nimport { getAccessorArrayTypeAndLength } from \"../gltf-utils/gltf-utils.js\";\nimport { BYTES, COMPONENTS } from \"../gltf-utils/gltf-constants.js\";\nimport { GLTFScenegraph } from \"../api/gltf-scenegraph.js\";\n/** Extension name */\nconst KHR_TEXTURE_TRANSFORM = 'KHR_texture_transform';\nexport const name = KHR_TEXTURE_TRANSFORM;\nconst scratchVector = new Vector3();\nconst scratchRotationMatrix = new Matrix3();\nconst scratchScaleMatrix = new Matrix3();\n/**\n * The extension entry to process the transformation\n * @param gltfData gltf buffers and json\n * @param options GLTFLoader options\n */\nexport async function decode(gltfData, options) {\n    const gltfScenegraph = new GLTFScenegraph(gltfData);\n    const hasExtension = gltfScenegraph.hasExtension(KHR_TEXTURE_TRANSFORM);\n    if (!hasExtension || !options.gltf?.loadBuffers) {\n        return;\n    }\n    const materials = gltfData.json.materials || [];\n    for (let i = 0; i < materials.length; i++) {\n        transformTexCoords(i, gltfData);\n    }\n}\n/**\n * Transform TEXCOORD by material\n * @param materialIndex processing material index\n * @param gltfData gltf buffers and json\n */\nfunction transformTexCoords(materialIndex, gltfData) {\n    const material = gltfData.json.materials?.[materialIndex];\n    const materialTextures = [\n        material?.pbrMetallicRoughness?.baseColorTexture,\n        material?.emissiveTexture,\n        material?.normalTexture,\n        material?.occlusionTexture,\n        material?.pbrMetallicRoughness?.metallicRoughnessTexture\n    ];\n    // Save processed texCoords in order no to process the same twice\n    const processedTexCoords = [];\n    for (const textureInfo of materialTextures) {\n        if (textureInfo && textureInfo?.extensions?.[KHR_TEXTURE_TRANSFORM]) {\n            transformPrimitives(gltfData, materialIndex, textureInfo, processedTexCoords);\n        }\n    }\n}\n/**\n * Transform primitives of the particular material\n * @param gltfData gltf data\n * @param materialIndex primitives with this material will be transformed\n * @param texture texture object\n * @param processedTexCoords storage to save already processed texCoords\n */\nfunction transformPrimitives(gltfData, materialIndex, texture, processedTexCoords) {\n    const transformParameters = getTransformParameters(texture, processedTexCoords);\n    if (!transformParameters) {\n        return;\n    }\n    const meshes = gltfData.json.meshes || [];\n    for (const mesh of meshes) {\n        for (const primitive of mesh.primitives) {\n            const material = primitive.material;\n            if (Number.isFinite(material) && materialIndex === material) {\n                transformPrimitive(gltfData, primitive, transformParameters);\n            }\n        }\n    }\n}\n/**\n * Get parameters for TEXCOORD transformation\n * @param texture texture object\n * @param processedTexCoords storage to save already processed texCoords\n * @returns texCoord couple and transformation matrix\n */\nfunction getTransformParameters(texture, processedTexCoords) {\n    const textureInfo = texture.extensions?.[KHR_TEXTURE_TRANSFORM];\n    const { texCoord: originalTexCoord = 0 } = texture;\n    // If texCoord is not set in the extension, original attribute data will be replaced\n    const { texCoord = originalTexCoord } = textureInfo;\n    // Make sure that couple [originalTexCoord, extensionTexCoord] is not processed twice\n    const isProcessed = processedTexCoords.findIndex(([original, newTexCoord]) => original === originalTexCoord && newTexCoord === texCoord) !== -1;\n    if (!isProcessed) {\n        const matrix = makeTransformationMatrix(textureInfo);\n        if (originalTexCoord !== texCoord) {\n            texture.texCoord = texCoord;\n        }\n        processedTexCoords.push([originalTexCoord, texCoord]);\n        return { originalTexCoord, texCoord, matrix };\n    }\n    return null;\n}\n/**\n * Transform `TEXCOORD_0` attribute in the primitive\n * @param gltfData gltf data\n * @param primitive primitive object\n * @param transformParameters texCoord couple and transformation matrix\n */\nfunction transformPrimitive(gltfData, primitive, transformParameters) {\n    const { originalTexCoord, texCoord, matrix } = transformParameters;\n    const texCoordAccessor = primitive.attributes[`TEXCOORD_${originalTexCoord}`];\n    if (Number.isFinite(texCoordAccessor)) {\n        // Get accessor of the `TEXCOORD_0` attribute\n        const accessor = gltfData.json.accessors?.[texCoordAccessor];\n        if (accessor && accessor.bufferView) {\n            // Get `bufferView` of the `accessor`\n            const bufferView = gltfData.json.bufferViews?.[accessor.bufferView];\n            if (bufferView) {\n                // Get `arrayBuffer` the `bufferView` look at\n                const { arrayBuffer, byteOffset: bufferByteOffset } = gltfData.buffers[bufferView.buffer];\n                // Resulting byteOffset is sum of the buffer, accessor and bufferView byte offsets\n                const byteOffset = (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);\n                // Deduce TypedArray type and its length from `accessor` and `bufferView` data\n                const { ArrayType, length } = getAccessorArrayTypeAndLength(accessor, bufferView);\n                // Number of bytes each component occupies\n                const bytes = BYTES[accessor.componentType];\n                // Number of components. For the `TEXCOORD_0` with `VEC2` type, it must return 2\n                const components = COMPONENTS[accessor.type];\n                // Multiplier to calculate the address of the `TEXCOORD_0` element in the arrayBuffer\n                const elementAddressScale = bufferView.byteStride || bytes * components;\n                // Data transform to Float32Array\n                const result = new Float32Array(length);\n                for (let i = 0; i < accessor.count; i++) {\n                    // Take [u, v] couple from the arrayBuffer\n                    const uv = new ArrayType(arrayBuffer, byteOffset + i * elementAddressScale, 2);\n                    // Set and transform Vector3 per https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#overview\n                    scratchVector.set(uv[0], uv[1], 1);\n                    scratchVector.transformByMatrix3(matrix);\n                    // Save result in Float32Array\n                    result.set([scratchVector[0], scratchVector[1]], i * components);\n                }\n                // If texCoord the same, replace gltf structural data\n                if (originalTexCoord === texCoord) {\n                    updateGltf(accessor, bufferView, gltfData.buffers, result);\n                }\n                else {\n                    // If texCoord change, create new attribute\n                    createAttribute(texCoord, accessor, primitive, gltfData, result);\n                }\n            }\n        }\n    }\n}\n/**\n * Update GLTF structural objects with new data as we create new `Float32Array` for `TEXCOORD_0`.\n * @param accessor accessor to change\n * @param bufferView bufferView to change\n * @param buffers binary buffers\n * @param newTexcoordArray typed array with data after transformation\n */\nfunction updateGltf(accessor, bufferView, buffers, newTexCoordArray) {\n    accessor.componentType = 5126;\n    buffers.push({\n        arrayBuffer: newTexCoordArray.buffer,\n        byteOffset: 0,\n        byteLength: newTexCoordArray.buffer.byteLength\n    });\n    bufferView.buffer = buffers.length - 1;\n    bufferView.byteLength = newTexCoordArray.buffer.byteLength;\n    bufferView.byteOffset = 0;\n    delete bufferView.byteStride;\n}\n/**\n *\n * @param newTexCoord new `texCoord` value\n * @param originalAccessor original accessor object, that store data before transformation\n * @param primitive primitive object\n * @param gltfData gltf data\n * @param newTexCoordArray typed array with data after transformation\n * @returns\n */\nfunction createAttribute(newTexCoord, originalAccessor, primitive, gltfData, newTexCoordArray) {\n    gltfData.buffers.push({\n        arrayBuffer: newTexCoordArray.buffer,\n        byteOffset: 0,\n        byteLength: newTexCoordArray.buffer.byteLength\n    });\n    const bufferViews = gltfData.json.bufferViews;\n    if (!bufferViews) {\n        return;\n    }\n    bufferViews.push({\n        buffer: gltfData.buffers.length - 1,\n        byteLength: newTexCoordArray.buffer.byteLength,\n        byteOffset: 0\n    });\n    const accessors = gltfData.json.accessors;\n    if (!accessors) {\n        return;\n    }\n    accessors.push({\n        bufferView: bufferViews?.length - 1,\n        byteOffset: 0,\n        componentType: 5126,\n        count: originalAccessor.count,\n        type: 'VEC2'\n    });\n    primitive.attributes[`TEXCOORD_${newTexCoord}`] = accessors.length - 1;\n}\n/**\n * Construct transformation matrix from the extension data (transition, rotation, scale)\n * @param extensionData extension data\n * @returns transformation matrix\n */\nfunction makeTransformationMatrix(extensionData) {\n    const { offset = [0, 0], rotation = 0, scale = [1, 1] } = extensionData;\n    const translationMatrix = new Matrix3().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);\n    const rotationMatrix = scratchRotationMatrix.set(Math.cos(rotation), Math.sin(rotation), 0, -Math.sin(rotation), Math.cos(rotation), 0, 0, 0, 1);\n    const scaleMatrix = scratchScaleMatrix.set(scale[0], 0, 0, 0, scale[1], 0, 0, 0, 1);\n    return translationMatrix.multiplyRight(rotationMatrix).multiplyRight(scaleMatrix);\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,OAAO,EAAEC,OAAO,QAAQ,eAAe;AAChD,SAASC,6BAA6B,QAAQ,6BAA6B;AAC3E,SAASC,KAAK,EAAEC,UAAU,QAAQ,iCAAiC;AACnE,SAASC,cAAc,QAAQ,2BAA2B;AAC1D;AACA,MAAMC,qBAAqB,GAAG,uBAAuB;AACrD,OAAO,MAAMC,IAAI,GAAGD,qBAAqB;AACzC,MAAME,aAAa,GAAG,IAAIR,OAAO,CAAC,CAAC;AACnC,MAAMS,qBAAqB,GAAG,IAAIR,OAAO,CAAC,CAAC;AAC3C,MAAMS,kBAAkB,GAAG,IAAIT,OAAO,CAAC,CAAC;AACxC;AACA;AACA;AACA;AACA;AACA,OAAO,eAAeU,MAAMA,CAACC,QAAQ,EAAEC,OAAO,EAAE;EAC5C,MAAMC,cAAc,GAAG,IAAIT,cAAc,CAACO,QAAQ,CAAC;EACnD,MAAMG,YAAY,GAAGD,cAAc,CAACC,YAAY,CAACT,qBAAqB,CAAC;EACvE,IAAI,CAACS,YAAY,IAAI,CAACF,OAAO,CAACG,IAAI,EAAEC,WAAW,EAAE;IAC7C;EACJ;EACA,MAAMC,SAAS,GAAGN,QAAQ,CAACO,IAAI,CAACD,SAAS,IAAI,EAAE;EAC/C,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,SAAS,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;IACvCE,kBAAkB,CAACF,CAAC,EAAER,QAAQ,CAAC;EACnC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,SAASU,kBAAkBA,CAACC,aAAa,EAAEX,QAAQ,EAAE;EACjD,MAAMY,QAAQ,GAAGZ,QAAQ,CAACO,IAAI,CAACD,SAAS,GAAGK,aAAa,CAAC;EACzD,MAAME,gBAAgB,GAAG,CACrBD,QAAQ,EAAEE,oBAAoB,EAAEC,gBAAgB,EAChDH,QAAQ,EAAEI,eAAe,EACzBJ,QAAQ,EAAEK,aAAa,EACvBL,QAAQ,EAAEM,gBAAgB,EAC1BN,QAAQ,EAAEE,oBAAoB,EAAEK,wBAAwB,CAC3D;EACD;EACA,MAAMC,kBAAkB,GAAG,EAAE;EAC7B,KAAK,MAAMC,WAAW,IAAIR,gBAAgB,EAAE;IACxC,IAAIQ,WAAW,IAAIA,WAAW,EAAEC,UAAU,GAAG5B,qBAAqB,CAAC,EAAE;MACjE6B,mBAAmB,CAACvB,QAAQ,EAAEW,aAAa,EAAEU,WAAW,EAAED,kBAAkB,CAAC;IACjF;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,mBAAmBA,CAACvB,QAAQ,EAAEW,aAAa,EAAEa,OAAO,EAAEJ,kBAAkB,EAAE;EAC/E,MAAMK,mBAAmB,GAAGC,sBAAsB,CAACF,OAAO,EAAEJ,kBAAkB,CAAC;EAC/E,IAAI,CAACK,mBAAmB,EAAE;IACtB;EACJ;EACA,MAAME,MAAM,GAAG3B,QAAQ,CAACO,IAAI,CAACoB,MAAM,IAAI,EAAE;EACzC,KAAK,MAAMC,IAAI,IAAID,MAAM,EAAE;IACvB,KAAK,MAAME,SAAS,IAAID,IAAI,CAACE,UAAU,EAAE;MACrC,MAAMlB,QAAQ,GAAGiB,SAAS,CAACjB,QAAQ;MACnC,IAAImB,MAAM,CAACC,QAAQ,CAACpB,QAAQ,CAAC,IAAID,aAAa,KAAKC,QAAQ,EAAE;QACzDqB,kBAAkB,CAACjC,QAAQ,EAAE6B,SAAS,EAAEJ,mBAAmB,CAAC;MAChE;IACJ;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,sBAAsBA,CAACF,OAAO,EAAEJ,kBAAkB,EAAE;EACzD,MAAMC,WAAW,GAAGG,OAAO,CAACF,UAAU,GAAG5B,qBAAqB,CAAC;EAC/D,MAAM;IAAEwC,QAAQ,EAAEC,gBAAgB,GAAG;EAAE,CAAC,GAAGX,OAAO;EAClD;EACA,MAAM;IAAEU,QAAQ,GAAGC;EAAiB,CAAC,GAAGd,WAAW;EACnD;EACA,MAAMe,WAAW,GAAGhB,kBAAkB,CAACiB,SAAS,CAAC,CAAC,CAACC,QAAQ,EAAEC,WAAW,CAAC,KAAKD,QAAQ,KAAKH,gBAAgB,IAAII,WAAW,KAAKL,QAAQ,CAAC,KAAK,CAAC,CAAC;EAC/I,IAAI,CAACE,WAAW,EAAE;IACd,MAAMI,MAAM,GAAGC,wBAAwB,CAACpB,WAAW,CAAC;IACpD,IAAIc,gBAAgB,KAAKD,QAAQ,EAAE;MAC/BV,OAAO,CAACU,QAAQ,GAAGA,QAAQ;IAC/B;IACAd,kBAAkB,CAACsB,IAAI,CAAC,CAACP,gBAAgB,EAAED,QAAQ,CAAC,CAAC;IACrD,OAAO;MAAEC,gBAAgB;MAAED,QAAQ;MAAEM;IAAO,CAAC;EACjD;EACA,OAAO,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASP,kBAAkBA,CAACjC,QAAQ,EAAE6B,SAAS,EAAEJ,mBAAmB,EAAE;EAClE,MAAM;IAAEU,gBAAgB;IAAED,QAAQ;IAAEM;EAAO,CAAC,GAAGf,mBAAmB;EAClE,MAAMkB,gBAAgB,GAAGd,SAAS,CAACe,UAAU,CAAC,YAAYT,gBAAgB,EAAE,CAAC;EAC7E,IAAIJ,MAAM,CAACC,QAAQ,CAACW,gBAAgB,CAAC,EAAE;IACnC;IACA,MAAME,QAAQ,GAAG7C,QAAQ,CAACO,IAAI,CAACuC,SAAS,GAAGH,gBAAgB,CAAC;IAC5D,IAAIE,QAAQ,IAAIA,QAAQ,CAACE,UAAU,EAAE;MACjC;MACA,MAAMA,UAAU,GAAG/C,QAAQ,CAACO,IAAI,CAACyC,WAAW,GAAGH,QAAQ,CAACE,UAAU,CAAC;MACnE,IAAIA,UAAU,EAAE;QACZ;QACA,MAAM;UAAEE,WAAW;UAAEC,UAAU,EAAEC;QAAiB,CAAC,GAAGnD,QAAQ,CAACoD,OAAO,CAACL,UAAU,CAACM,MAAM,CAAC;QACzF;QACA,MAAMH,UAAU,GAAG,CAACC,gBAAgB,IAAI,CAAC,KAAKN,QAAQ,CAACK,UAAU,IAAI,CAAC,CAAC,IAAIH,UAAU,CAACG,UAAU,IAAI,CAAC,CAAC;QACtG;QACA,MAAM;UAAEI,SAAS;UAAE7C;QAAO,CAAC,GAAGnB,6BAA6B,CAACuD,QAAQ,EAAEE,UAAU,CAAC;QACjF;QACA,MAAMQ,KAAK,GAAGhE,KAAK,CAACsD,QAAQ,CAACW,aAAa,CAAC;QAC3C;QACA,MAAMC,UAAU,GAAGjE,UAAU,CAACqD,QAAQ,CAACa,IAAI,CAAC;QAC5C;QACA,MAAMC,mBAAmB,GAAGZ,UAAU,CAACa,UAAU,IAAIL,KAAK,GAAGE,UAAU;QACvE;QACA,MAAMI,MAAM,GAAG,IAAIC,YAAY,CAACrD,MAAM,CAAC;QACvC,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqC,QAAQ,CAACkB,KAAK,EAAEvD,CAAC,EAAE,EAAE;UACrC;UACA,MAAMwD,EAAE,GAAG,IAAIV,SAAS,CAACL,WAAW,EAAEC,UAAU,GAAG1C,CAAC,GAAGmD,mBAAmB,EAAE,CAAC,CAAC;UAC9E;UACA/D,aAAa,CAACqE,GAAG,CAACD,EAAE,CAAC,CAAC,CAAC,EAAEA,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;UAClCpE,aAAa,CAACsE,kBAAkB,CAAC1B,MAAM,CAAC;UACxC;UACAqB,MAAM,CAACI,GAAG,CAAC,CAACrE,aAAa,CAAC,CAAC,CAAC,EAAEA,aAAa,CAAC,CAAC,CAAC,CAAC,EAAEY,CAAC,GAAGiD,UAAU,CAAC;QACpE;QACA;QACA,IAAItB,gBAAgB,KAAKD,QAAQ,EAAE;UAC/BiC,UAAU,CAACtB,QAAQ,EAAEE,UAAU,EAAE/C,QAAQ,CAACoD,OAAO,EAAES,MAAM,CAAC;QAC9D,CAAC,MACI;UACD;UACAO,eAAe,CAAClC,QAAQ,EAAEW,QAAQ,EAAEhB,SAAS,EAAE7B,QAAQ,EAAE6D,MAAM,CAAC;QACpE;MACJ;IACJ;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,UAAUA,CAACtB,QAAQ,EAAEE,UAAU,EAAEK,OAAO,EAAEiB,gBAAgB,EAAE;EACjExB,QAAQ,CAACW,aAAa,GAAG,IAAI;EAC7BJ,OAAO,CAACV,IAAI,CAAC;IACTO,WAAW,EAAEoB,gBAAgB,CAAChB,MAAM;IACpCH,UAAU,EAAE,CAAC;IACboB,UAAU,EAAED,gBAAgB,CAAChB,MAAM,CAACiB;EACxC,CAAC,CAAC;EACFvB,UAAU,CAACM,MAAM,GAAGD,OAAO,CAAC3C,MAAM,GAAG,CAAC;EACtCsC,UAAU,CAACuB,UAAU,GAAGD,gBAAgB,CAAChB,MAAM,CAACiB,UAAU;EAC1DvB,UAAU,CAACG,UAAU,GAAG,CAAC;EACzB,OAAOH,UAAU,CAACa,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASQ,eAAeA,CAAC7B,WAAW,EAAEgC,gBAAgB,EAAE1C,SAAS,EAAE7B,QAAQ,EAAEqE,gBAAgB,EAAE;EAC3FrE,QAAQ,CAACoD,OAAO,CAACV,IAAI,CAAC;IAClBO,WAAW,EAAEoB,gBAAgB,CAAChB,MAAM;IACpCH,UAAU,EAAE,CAAC;IACboB,UAAU,EAAED,gBAAgB,CAAChB,MAAM,CAACiB;EACxC,CAAC,CAAC;EACF,MAAMtB,WAAW,GAAGhD,QAAQ,CAACO,IAAI,CAACyC,WAAW;EAC7C,IAAI,CAACA,WAAW,EAAE;IACd;EACJ;EACAA,WAAW,CAACN,IAAI,CAAC;IACbW,MAAM,EAAErD,QAAQ,CAACoD,OAAO,CAAC3C,MAAM,GAAG,CAAC;IACnC6D,UAAU,EAAED,gBAAgB,CAAChB,MAAM,CAACiB,UAAU;IAC9CpB,UAAU,EAAE;EAChB,CAAC,CAAC;EACF,MAAMJ,SAAS,GAAG9C,QAAQ,CAACO,IAAI,CAACuC,SAAS;EACzC,IAAI,CAACA,SAAS,EAAE;IACZ;EACJ;EACAA,SAAS,CAACJ,IAAI,CAAC;IACXK,UAAU,EAAEC,WAAW,EAAEvC,MAAM,GAAG,CAAC;IACnCyC,UAAU,EAAE,CAAC;IACbM,aAAa,EAAE,IAAI;IACnBO,KAAK,EAAEQ,gBAAgB,CAACR,KAAK;IAC7BL,IAAI,EAAE;EACV,CAAC,CAAC;EACF7B,SAAS,CAACe,UAAU,CAAC,YAAYL,WAAW,EAAE,CAAC,GAAGO,SAAS,CAACrC,MAAM,GAAG,CAAC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,SAASgC,wBAAwBA,CAAC+B,aAAa,EAAE;EAC7C,MAAM;IAAEC,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;IAAEC,QAAQ,GAAG,CAAC;IAAEC,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC;EAAE,CAAC,GAAGH,aAAa;EACvE,MAAMI,iBAAiB,GAAG,IAAIvF,OAAO,CAAC,CAAC,CAAC4E,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEQ,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;EACtF,MAAMI,cAAc,GAAGhF,qBAAqB,CAACoE,GAAG,CAACa,IAAI,CAACC,GAAG,CAACL,QAAQ,CAAC,EAAEI,IAAI,CAACE,GAAG,CAACN,QAAQ,CAAC,EAAE,CAAC,EAAE,CAACI,IAAI,CAACE,GAAG,CAACN,QAAQ,CAAC,EAAEI,IAAI,CAACC,GAAG,CAACL,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAChJ,MAAMO,WAAW,GAAGnF,kBAAkB,CAACmE,GAAG,CAACU,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACnF,OAAOC,iBAAiB,CAACM,aAAa,CAACL,cAAc,CAAC,CAACK,aAAa,CAACD,WAAW,CAAC;AACrF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}