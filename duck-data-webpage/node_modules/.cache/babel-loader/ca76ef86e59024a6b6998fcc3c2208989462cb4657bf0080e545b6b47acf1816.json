{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst GEOM_TYPES = ['points', 'lines', 'polygons'];\n/**\n * Return the index of feature (numericProps or featureIds) for given feature id\n * Example: findIndexBinary(data, 'id', 33) will return the index in the array of numericProps\n * of the feature 33.\n */\nexport default function findIndexBinary(data,\n// The data in binary format\nuniqueIdProperty,\n// Name of the unique id property\nfeatureId,\n// feature id to find\nlayerName // the layer to search in\n) {\n  for (const gt of GEOM_TYPES) {\n    const index = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);\n    if (index >= 0) {\n      return index;\n    }\n  }\n  return -1;\n}\nfunction findIndexByType(geomData, uniqueIdProperty, featureId, layerName) {\n  const featureIds = geomData.featureIds.value;\n  if (!featureIds.length) {\n    return -1;\n  }\n  let startFeatureIndex = 0;\n  let endFeatureIndex = featureIds[featureIds.length - 1] + 1;\n  if (layerName) {\n    const layerRange = getLayerRange(geomData, layerName);\n    if (layerRange) {\n      startFeatureIndex = layerRange[0];\n      endFeatureIndex = layerRange[1] + 1;\n    } else {\n      return -1;\n    }\n  }\n  // Look for the uniqueIdProperty\n  let featureIndex = -1;\n  if (uniqueIdProperty in geomData.numericProps) {\n    const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex((x, i) => x === featureId && featureIds[i] >= startFeatureIndex && featureIds[i] < endFeatureIndex);\n    return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;\n  } else if (uniqueIdProperty) {\n    featureIndex = findIndex(geomData.properties, elem => elem[uniqueIdProperty] === featureId, startFeatureIndex, endFeatureIndex);\n  } else if (geomData.fields) {\n    featureIndex = findIndex(geomData.fields, elem => elem.id === featureId, startFeatureIndex, endFeatureIndex);\n  }\n  return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;\n}\n// Returns [firstFeatureIndex, lastFeatureIndex]\n// MVTLoader parses tiles layer-by-layer, so each layer is a continuous range\nfunction getLayerRange(geomData, layerName) {\n  if (!geomData.__layers) {\n    // Cache a map from properties.layerName to index ranges\n    const layerNames = {};\n    const {\n      properties\n    } = geomData;\n    for (let i = 0; i < properties.length; i++) {\n      const {\n        layerName: key\n      } = properties[i];\n      if (!key) {\n        // ignore\n      } else if (layerNames[key]) {\n        layerNames[key][1] = i;\n      } else {\n        layerNames[key] = [i, i];\n      }\n    }\n    geomData.__layers = layerNames;\n  }\n  return geomData.__layers[layerName];\n}\n// Returns global feature id\nfunction getGlobalFeatureId(geomData, featureIndex) {\n  if (!geomData.__ids) {\n    // Cache a map from featureId to globalFeatureId\n    const result = [];\n    const featureIds = geomData.featureIds.value;\n    const globalFeatureIds = geomData.globalFeatureIds.value;\n    for (let i = 0; i < featureIds.length; i++) {\n      result[featureIds[i]] = globalFeatureIds[i];\n    }\n    geomData.__ids = result;\n  }\n  return geomData.__ids[featureIndex];\n}\n// Like array.findIndex, but only search within a range\nfunction findIndex(array, predicate, startIndex, endIndex) {\n  for (let i = startIndex; i < endIndex; i++) {\n    if (predicate(array[i], i)) {\n      return i;\n    }\n  }\n  return -1;\n}","map":{"version":3,"names":["GEOM_TYPES","findIndexBinary","data","uniqueIdProperty","featureId","layerName","gt","index","findIndexByType","geomData","featureIds","value","length","startFeatureIndex","endFeatureIndex","layerRange","getLayerRange","featureIndex","numericProps","vertexIndex","findIndex","x","i","globalFeatureIds","properties","elem","fields","id","getGlobalFeatureId","__layers","layerNames","key","__ids","result","array","predicate","startIndex","endIndex"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\geo-layers\\src\\mvt-layer\\find-index-binary.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {\n  BinaryFeatureCollection,\n  BinaryLineFeature,\n  BinaryPointFeature,\n  BinaryPolygonFeature\n} from '@loaders.gl/schema';\n\ntype FeatureTypes = BinaryPointFeature | BinaryLineFeature | BinaryPolygonFeature;\n\nconst GEOM_TYPES = ['points', 'lines', 'polygons'];\n/**\n * Return the index of feature (numericProps or featureIds) for given feature id\n * Example: findIndexBinary(data, 'id', 33) will return the index in the array of numericProps\n * of the feature 33.\n */\nexport default function findIndexBinary(\n  data: BinaryFeatureCollection, // The data in binary format\n  uniqueIdProperty: string, // Name of the unique id property\n  featureId: string | number, // feature id to find\n  layerName: string | null // the layer to search in\n): number {\n  for (const gt of GEOM_TYPES) {\n    const index = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);\n    if (index >= 0) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n\nfunction findIndexByType(\n  geomData: FeatureTypes,\n  uniqueIdProperty: string,\n  featureId: string | number,\n  layerName: string | null\n): number {\n  const featureIds = geomData.featureIds.value;\n\n  if (!featureIds.length) {\n    return -1;\n  }\n\n  let startFeatureIndex = 0;\n  let endFeatureIndex = featureIds[featureIds.length - 1] + 1;\n  if (layerName) {\n    const layerRange = getLayerRange(geomData, layerName);\n    if (layerRange) {\n      startFeatureIndex = layerRange[0];\n      endFeatureIndex = layerRange[1] + 1;\n    } else {\n      return -1;\n    }\n  }\n\n  // Look for the uniqueIdProperty\n  let featureIndex = -1;\n  if (uniqueIdProperty in geomData.numericProps) {\n    const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex(\n      (x, i) =>\n        x === featureId && featureIds[i] >= startFeatureIndex && featureIds[i] < endFeatureIndex\n    );\n    return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;\n  } else if (uniqueIdProperty) {\n    featureIndex = findIndex(\n      geomData.properties,\n      elem => elem[uniqueIdProperty] === featureId,\n      startFeatureIndex,\n      endFeatureIndex\n    );\n  } else if (geomData.fields) {\n    featureIndex = findIndex(\n      geomData.fields,\n      (elem: any) => elem.id === featureId,\n      startFeatureIndex,\n      endFeatureIndex\n    );\n  }\n  return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;\n}\n\ntype LayerRange = [firstFeatureIndex: number, lastFeatureIndex: number];\n\n// Returns [firstFeatureIndex, lastFeatureIndex]\n// MVTLoader parses tiles layer-by-layer, so each layer is a continuous range\nfunction getLayerRange(\n  geomData: FeatureTypes & {\n    __layers?: Record<string, LayerRange>;\n  },\n  layerName: string\n): LayerRange | undefined {\n  if (!geomData.__layers) {\n    // Cache a map from properties.layerName to index ranges\n    const layerNames: Record<string, LayerRange> = {};\n    const {properties} = geomData;\n    for (let i = 0; i < properties.length; i++) {\n      const {layerName: key} = properties[i] as Record<string, any>;\n      if (!key) {\n        // ignore\n      } else if (layerNames[key]) {\n        layerNames[key][1] = i;\n      } else {\n        layerNames[key] = [i, i];\n      }\n    }\n    geomData.__layers = layerNames;\n  }\n  return geomData.__layers[layerName];\n}\n\n// Returns global feature id\nfunction getGlobalFeatureId(geomData, featureIndex: number) {\n  if (!geomData.__ids) {\n    // Cache a map from featureId to globalFeatureId\n    const result: string[] = [];\n    const featureIds = geomData.featureIds.value;\n    const globalFeatureIds = geomData.globalFeatureIds.value;\n    for (let i = 0; i < featureIds.length; i++) {\n      result[featureIds[i]] = globalFeatureIds[i];\n    }\n    geomData.__ids = result;\n  }\n  return geomData.__ids[featureIndex];\n}\n\n// Like array.findIndex, but only search within a range\nfunction findIndex<T>(\n  array: T[],\n  predicate: (v: T, index: number) => boolean,\n  startIndex: number,\n  endIndex: number\n): number {\n  for (let i = startIndex; i < endIndex; i++) {\n    if (predicate(array[i], i)) {\n      return i;\n    }\n  }\n  return -1;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}