{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Vector3, Matrix3, Matrix4, Quaternion } from '@math.gl/core';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { GL } from '@loaders.gl/math'; // 'math.gl/geometry';\nimport Tile3DFeatureTable from \"../classes/tile-3d-feature-table.js\";\nimport Tile3DBatchTable from \"../classes/tile-3d-batch-table.js\";\nimport { parse3DTileHeaderSync } from \"./helpers/parse-3d-tile-header.js\";\nimport { parse3DTileTablesHeaderSync, parse3DTileTablesSync } from \"./helpers/parse-3d-tile-tables.js\";\nimport { parse3DTileGLTFViewSync, extractGLTF } from \"./helpers/parse-3d-tile-gltf-view.js\";\nexport async function parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options, context);\n  await extractGLTF(tile, tile.gltfFormat || 0, options, context);\n  return byteOffset;\n}\nfunction parseInstancedModel(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n  if (tile.version !== 1) {\n    throw new Error(`Instanced 3D Model version ${tile.version} is not supported`);\n  }\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n  const view = new DataView(arrayBuffer);\n  tile.gltfFormat = view.getUint32(byteOffset, true);\n  byteOffset += 4;\n  // PARSE FEATURE TABLE\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);\n  // TODO - Is the feature table sometimes optional or can check be moved into table header parser?\n  if (!tile?.header?.featureTableJsonByteLength || tile.header.featureTableJsonByteLength === 0) {\n    throw new Error('i3dm parser: featureTableJsonByteLength is zero.');\n  }\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n  const instancesLength = featureTable.getGlobalProperty('INSTANCES_LENGTH');\n  featureTable.featuresLength = instancesLength;\n  if (!Number.isFinite(instancesLength)) {\n    throw new Error('i3dm parser: INSTANCES_LENGTH must be defined');\n  }\n  tile.eastNorthUp = featureTable.getGlobalProperty('EAST_NORTH_UP');\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n  const batchTable = new Tile3DBatchTable(tile.batchTableJson, tile.batchTableBinary, instancesLength);\n  extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);\n  return byteOffset;\n}\n// eslint-disable-next-line max-statements, complexity\nfunction extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {\n  const instances = new Array(instancesLength);\n  const instancePosition = new Vector3();\n  const instanceNormalRight = new Vector3();\n  const instanceNormalUp = new Vector3();\n  const instanceNormalForward = new Vector3();\n  const instanceRotation = new Matrix3();\n  const instanceQuaternion = new Quaternion();\n  const instanceScale = new Vector3();\n  const instanceTranslationRotationScale = {};\n  const instanceTransform = new Matrix4();\n  const scratch1 = [];\n  const scratch2 = [];\n  const scratch3 = [];\n  const scratch4 = [];\n  for (let i = 0; i < instancesLength; i++) {\n    let position;\n    // Get the instance position\n    if (featureTable.hasProperty('POSITION')) {\n      position = featureTable.getProperty('POSITION', GL.FLOAT, 3, i, instancePosition);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      position = featureTable.getProperty('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3, i, instancePosition);\n      const quantizedVolumeOffset = featureTable.getGlobalProperty('QUANTIZED_VOLUME_OFFSET', GL.FLOAT, 3);\n      if (!quantizedVolumeOffset) {\n        throw new Error('i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n      }\n      const quantizedVolumeScale = featureTable.getGlobalProperty('QUANTIZED_VOLUME_SCALE', GL.FLOAT, 3);\n      if (!quantizedVolumeScale) {\n        throw new Error('i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n      }\n      const MAX_UNSIGNED_SHORT = 65535.0;\n      for (let j = 0; j < 3; j++) {\n        position[j] = position[j] / MAX_UNSIGNED_SHORT * quantizedVolumeScale[j] + quantizedVolumeOffset[j];\n      }\n    }\n    if (!position) {\n      throw new Error('i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.');\n    }\n    instancePosition.copy(position);\n    // @ts-expect-error\n    instanceTranslationRotationScale.translation = instancePosition;\n    // Get the instance rotation\n    tile.normalUp = featureTable.getProperty('NORMAL_UP', GL.FLOAT, 3, i, scratch1);\n    tile.normalRight = featureTable.getProperty('NORMAL_RIGHT', GL.FLOAT, 3, i, scratch2);\n    const hasCustomOrientation = false;\n    if (tile.normalUp) {\n      if (!tile.normalRight) {\n        throw new Error('i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.');\n      }\n      // Vector3.unpack(normalUp, 0, instanceNormalUp);\n      // Vector3.unpack(normalRight, 0, instanceNormalRight);\n      tile.hasCustomOrientation = true;\n    } else {\n      tile.octNormalUp = featureTable.getProperty('NORMAL_UP_OCT32P', GL.UNSIGNED_SHORT, 2, i, scratch1);\n      tile.octNormalRight = featureTable.getProperty('NORMAL_RIGHT_OCT32P', GL.UNSIGNED_SHORT, 2, i, scratch2);\n      if (tile.octNormalUp) {\n        if (!tile.octNormalRight) {\n          throw new Error('i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P');\n        }\n        throw new Error('i3dm: oct-encoded orientation not implemented');\n        /*\n        AttributeCompression.octDecodeInRange(octNormalUp[0], octNormalUp[1], 65535, instanceNormalUp);\n        AttributeCompression.octDecodeInRange(octNormalRight[0], octNormalRight[1], 65535, instanceNormalRight);\n        hasCustomOrientation = true;\n        */\n      } else if (tile.eastNorthUp) {\n        Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);\n        instanceTransform.getRotationMatrix3(instanceRotation);\n      } else {\n        instanceRotation.identity();\n      }\n    }\n    if (hasCustomOrientation) {\n      instanceNormalForward.copy(instanceNormalRight).cross(instanceNormalUp).normalize();\n      instanceRotation.setColumn(0, instanceNormalRight);\n      instanceRotation.setColumn(1, instanceNormalUp);\n      instanceRotation.setColumn(2, instanceNormalForward);\n    }\n    instanceQuaternion.fromMatrix3(instanceRotation);\n    // @ts-expect-error\n    instanceTranslationRotationScale.rotation = instanceQuaternion;\n    // Get the instance scale\n    instanceScale.set(1.0, 1.0, 1.0);\n    const scale = featureTable.getProperty('SCALE', GL.FLOAT, 1, i, scratch3);\n    if (Number.isFinite(scale)) {\n      instanceScale.multiplyByScalar(scale);\n    }\n    const nonUniformScale = featureTable.getProperty('SCALE_NON_UNIFORM', GL.FLOAT, 3, i, scratch1);\n    if (nonUniformScale) {\n      instanceScale.scale(nonUniformScale);\n    }\n    // @ts-expect-error\n    instanceTranslationRotationScale.scale = instanceScale;\n    // Get the batchId\n    let batchId = featureTable.getProperty('BATCH_ID', GL.UNSIGNED_SHORT, 1, i, scratch4);\n    if (batchId === undefined) {\n      // If BATCH_ID semantic is undefined, batchId is just the instance number\n      batchId = i;\n    }\n    // @ts-expect-error\n    const rotationMatrix = new Matrix4().fromQuaternion(instanceTranslationRotationScale.rotation);\n    // Create the model matrix and the instance\n    instanceTransform.identity();\n    // @ts-expect-error\n    instanceTransform.translate(instanceTranslationRotationScale.translation);\n    instanceTransform.multiplyRight(rotationMatrix);\n    // @ts-expect-error\n    instanceTransform.scale(instanceTranslationRotationScale.scale);\n    const modelMatrix = instanceTransform.clone();\n    instances[i] = {\n      modelMatrix,\n      batchId\n    };\n  }\n  tile.instances = instances;\n}","map":{"version":3,"names":["Vector3","Matrix3","Matrix4","Quaternion","Ellipsoid","GL","Tile3DFeatureTable","Tile3DBatchTable","parse3DTileHeaderSync","parse3DTileTablesHeaderSync","parse3DTileTablesSync","parse3DTileGLTFViewSync","extractGLTF","parseInstancedModel3DTile","tile","arrayBuffer","byteOffset","options","context","parseInstancedModel","gltfFormat","version","Error","view","DataView","getUint32","header","featureTableJsonByteLength","featureTable","featureTableJson","featureTableBinary","instancesLength","getGlobalProperty","featuresLength","Number","isFinite","eastNorthUp","rtcCenter","FLOAT","batchTable","batchTableJson","batchTableBinary","extractInstancedAttributes","instances","Array","instancePosition","instanceNormalRight","instanceNormalUp","instanceNormalForward","instanceRotation","instanceQuaternion","instanceScale","instanceTranslationRotationScale","instanceTransform","scratch1","scratch2","scratch3","scratch4","i","position","hasProperty","getProperty","UNSIGNED_SHORT","quantizedVolumeOffset","quantizedVolumeScale","MAX_UNSIGNED_SHORT","j","copy","translation","normalUp","normalRight","hasCustomOrientation","octNormalUp","octNormalRight","WGS84","eastNorthUpToFixedFrame","getRotationMatrix3","identity","cross","normalize","setColumn","fromMatrix3","rotation","set","scale","multiplyByScalar","nonUniformScale","batchId","undefined","rotationMatrix","fromQuaternion","translate","multiplyRight","modelMatrix","clone"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-instanced-model.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Vector3, Matrix3, Matrix4, Quaternion } from '@math.gl/core';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { GL } from '@loaders.gl/math'; // 'math.gl/geometry';\nimport Tile3DFeatureTable from \"../classes/tile-3d-feature-table.js\";\nimport Tile3DBatchTable from \"../classes/tile-3d-batch-table.js\";\nimport { parse3DTileHeaderSync } from \"./helpers/parse-3d-tile-header.js\";\nimport { parse3DTileTablesHeaderSync, parse3DTileTablesSync } from \"./helpers/parse-3d-tile-tables.js\";\nimport { parse3DTileGLTFViewSync, extractGLTF } from \"./helpers/parse-3d-tile-gltf-view.js\";\nexport async function parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {\n    byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options, context);\n    await extractGLTF(tile, tile.gltfFormat || 0, options, context);\n    return byteOffset;\n}\nfunction parseInstancedModel(tile, arrayBuffer, byteOffset, options, context) {\n    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n    if (tile.version !== 1) {\n        throw new Error(`Instanced 3D Model version ${tile.version} is not supported`);\n    }\n    byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n    const view = new DataView(arrayBuffer);\n    tile.gltfFormat = view.getUint32(byteOffset, true);\n    byteOffset += 4;\n    // PARSE FEATURE TABLE\n    byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n    byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);\n    // TODO - Is the feature table sometimes optional or can check be moved into table header parser?\n    if (!tile?.header?.featureTableJsonByteLength || tile.header.featureTableJsonByteLength === 0) {\n        throw new Error('i3dm parser: featureTableJsonByteLength is zero.');\n    }\n    const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n    const instancesLength = featureTable.getGlobalProperty('INSTANCES_LENGTH');\n    featureTable.featuresLength = instancesLength;\n    if (!Number.isFinite(instancesLength)) {\n        throw new Error('i3dm parser: INSTANCES_LENGTH must be defined');\n    }\n    tile.eastNorthUp = featureTable.getGlobalProperty('EAST_NORTH_UP');\n    tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n    const batchTable = new Tile3DBatchTable(tile.batchTableJson, tile.batchTableBinary, instancesLength);\n    extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);\n    return byteOffset;\n}\n// eslint-disable-next-line max-statements, complexity\nfunction extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {\n    const instances = new Array(instancesLength);\n    const instancePosition = new Vector3();\n    const instanceNormalRight = new Vector3();\n    const instanceNormalUp = new Vector3();\n    const instanceNormalForward = new Vector3();\n    const instanceRotation = new Matrix3();\n    const instanceQuaternion = new Quaternion();\n    const instanceScale = new Vector3();\n    const instanceTranslationRotationScale = {};\n    const instanceTransform = new Matrix4();\n    const scratch1 = [];\n    const scratch2 = [];\n    const scratch3 = [];\n    const scratch4 = [];\n    for (let i = 0; i < instancesLength; i++) {\n        let position;\n        // Get the instance position\n        if (featureTable.hasProperty('POSITION')) {\n            position = featureTable.getProperty('POSITION', GL.FLOAT, 3, i, instancePosition);\n        }\n        else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n            position = featureTable.getProperty('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3, i, instancePosition);\n            const quantizedVolumeOffset = featureTable.getGlobalProperty('QUANTIZED_VOLUME_OFFSET', GL.FLOAT, 3);\n            if (!quantizedVolumeOffset) {\n                throw new Error('i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n            }\n            const quantizedVolumeScale = featureTable.getGlobalProperty('QUANTIZED_VOLUME_SCALE', GL.FLOAT, 3);\n            if (!quantizedVolumeScale) {\n                throw new Error('i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n            }\n            const MAX_UNSIGNED_SHORT = 65535.0;\n            for (let j = 0; j < 3; j++) {\n                position[j] =\n                    (position[j] / MAX_UNSIGNED_SHORT) * quantizedVolumeScale[j] + quantizedVolumeOffset[j];\n            }\n        }\n        if (!position) {\n            throw new Error('i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.');\n        }\n        instancePosition.copy(position);\n        // @ts-expect-error\n        instanceTranslationRotationScale.translation = instancePosition;\n        // Get the instance rotation\n        tile.normalUp = featureTable.getProperty('NORMAL_UP', GL.FLOAT, 3, i, scratch1);\n        tile.normalRight = featureTable.getProperty('NORMAL_RIGHT', GL.FLOAT, 3, i, scratch2);\n        const hasCustomOrientation = false;\n        if (tile.normalUp) {\n            if (!tile.normalRight) {\n                throw new Error('i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.');\n            }\n            // Vector3.unpack(normalUp, 0, instanceNormalUp);\n            // Vector3.unpack(normalRight, 0, instanceNormalRight);\n            tile.hasCustomOrientation = true;\n        }\n        else {\n            tile.octNormalUp = featureTable.getProperty('NORMAL_UP_OCT32P', GL.UNSIGNED_SHORT, 2, i, scratch1);\n            tile.octNormalRight = featureTable.getProperty('NORMAL_RIGHT_OCT32P', GL.UNSIGNED_SHORT, 2, i, scratch2);\n            if (tile.octNormalUp) {\n                if (!tile.octNormalRight) {\n                    throw new Error('i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P');\n                }\n                throw new Error('i3dm: oct-encoded orientation not implemented');\n                /*\n                AttributeCompression.octDecodeInRange(octNormalUp[0], octNormalUp[1], 65535, instanceNormalUp);\n                AttributeCompression.octDecodeInRange(octNormalRight[0], octNormalRight[1], 65535, instanceNormalRight);\n                hasCustomOrientation = true;\n                */\n            }\n            else if (tile.eastNorthUp) {\n                Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);\n                instanceTransform.getRotationMatrix3(instanceRotation);\n            }\n            else {\n                instanceRotation.identity();\n            }\n        }\n        if (hasCustomOrientation) {\n            instanceNormalForward.copy(instanceNormalRight).cross(instanceNormalUp).normalize();\n            instanceRotation.setColumn(0, instanceNormalRight);\n            instanceRotation.setColumn(1, instanceNormalUp);\n            instanceRotation.setColumn(2, instanceNormalForward);\n        }\n        instanceQuaternion.fromMatrix3(instanceRotation);\n        // @ts-expect-error\n        instanceTranslationRotationScale.rotation = instanceQuaternion;\n        // Get the instance scale\n        instanceScale.set(1.0, 1.0, 1.0);\n        const scale = featureTable.getProperty('SCALE', GL.FLOAT, 1, i, scratch3);\n        if (Number.isFinite(scale)) {\n            instanceScale.multiplyByScalar(scale);\n        }\n        const nonUniformScale = featureTable.getProperty('SCALE_NON_UNIFORM', GL.FLOAT, 3, i, scratch1);\n        if (nonUniformScale) {\n            instanceScale.scale(nonUniformScale);\n        }\n        // @ts-expect-error\n        instanceTranslationRotationScale.scale = instanceScale;\n        // Get the batchId\n        let batchId = featureTable.getProperty('BATCH_ID', GL.UNSIGNED_SHORT, 1, i, scratch4);\n        if (batchId === undefined) {\n            // If BATCH_ID semantic is undefined, batchId is just the instance number\n            batchId = i;\n        }\n        // @ts-expect-error\n        const rotationMatrix = new Matrix4().fromQuaternion(instanceTranslationRotationScale.rotation);\n        // Create the model matrix and the instance\n        instanceTransform.identity();\n        // @ts-expect-error\n        instanceTransform.translate(instanceTranslationRotationScale.translation);\n        instanceTransform.multiplyRight(rotationMatrix);\n        // @ts-expect-error\n        instanceTransform.scale(instanceTranslationRotationScale.scale);\n        const modelMatrix = instanceTransform.clone();\n        instances[i] = {\n            modelMatrix,\n            batchId\n        };\n    }\n    tile.instances = instances;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}