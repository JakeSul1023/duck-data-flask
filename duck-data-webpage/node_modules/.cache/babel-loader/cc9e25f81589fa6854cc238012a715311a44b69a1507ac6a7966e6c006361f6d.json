{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { BufferTransform } from '@luma.gl/engine';\nimport { createRenderTarget } from \"./utils.js\";\nimport { TEXTURE_WIDTH } from \"./webgl-bin-sorter.js\";\nimport { aggregatorTransformUniforms } from \"./aggregation-transform-uniforms.js\";\nconst MAX_FLOAT32 = 3e38;\nexport class WebGLAggregationTransform {\n  constructor(device, props) {\n    /** Packed from bin ids */\n    this.binBuffer = null;\n    /** Packed values from each channel of each bin\n     * Stride is number of channels * 4 bytes (float32)\n     */\n    this.valueBuffer = null;\n    /** Aggregated [min, max] for each channel */\n    this._domains = null;\n    this.device = device;\n    this.channelCount = props.channelCount;\n    this.transform = createTransform(device, props);\n    this.domainFBO = createRenderTarget(device, 2, 1);\n  }\n  destroy() {\n    this.transform.destroy();\n    this.binBuffer?.destroy();\n    this.valueBuffer?.destroy();\n    this.domainFBO.colorAttachments[0].texture.destroy();\n    this.domainFBO.destroy();\n  }\n  get domains() {\n    if (!this._domains) {\n      // Domain model has run, but result has not been read to CPU\n      const buffer = this.device.readPixelsToArrayWebGL(this.domainFBO).buffer;\n      const domain = new Float32Array(buffer);\n      this._domains = [[-domain[4], domain[0]], [-domain[5], domain[1]], [-domain[6], domain[2]]].slice(0, this.channelCount);\n    }\n    return this._domains;\n  }\n  setDimensions(binCount, binIdRange) {\n    const {\n      model,\n      transformFeedback\n    } = this.transform;\n    model.setVertexCount(binCount);\n    const aggregatorTransformProps = {\n      binIdRange: [binIdRange[0][0], binIdRange[0][1], binIdRange[1]?.[0] || 0, binIdRange[1]?.[1] || 0]\n    };\n    model.shaderInputs.setProps({\n      aggregatorTransform: aggregatorTransformProps\n    });\n    // Only destroy existing buffer if it is not large enough\n    const binBufferByteLength = binCount * binIdRange.length * 4;\n    if (!this.binBuffer || this.binBuffer.byteLength < binBufferByteLength) {\n      this.binBuffer?.destroy();\n      this.binBuffer = this.device.createBuffer({\n        byteLength: binBufferByteLength\n      });\n      transformFeedback.setBuffer('binIds', this.binBuffer);\n    }\n    const valueBufferByteLength = binCount * this.channelCount * 4;\n    if (!this.valueBuffer || this.valueBuffer.byteLength < valueBufferByteLength) {\n      this.valueBuffer?.destroy();\n      this.valueBuffer = this.device.createBuffer({\n        byteLength: valueBufferByteLength\n      });\n      transformFeedback.setBuffer('values', this.valueBuffer);\n    }\n  }\n  update(bins, operations) {\n    if (!bins) {\n      return;\n    }\n    const transform = this.transform;\n    const target = this.domainFBO;\n    const isCount = [0, 1, 2].map(i => operations[i] === 'COUNT' ? 1 : 0);\n    const isMean = [0, 1, 2].map(i => operations[i] === 'MEAN' ? 1 : 0);\n    const aggregatorTransformProps = {\n      isCount: isCount,\n      isMean: isMean,\n      bins\n    };\n    transform.model.shaderInputs.setProps({\n      aggregatorTransform: aggregatorTransformProps\n    });\n    transform.run({\n      id: 'gpu-aggregation-domain',\n      framebuffer: target,\n      parameters: {\n        viewport: [0, 0, 2, 1]\n      },\n      clearColor: [-MAX_FLOAT32, -MAX_FLOAT32, -MAX_FLOAT32, 0],\n      clearDepth: false,\n      clearStencil: false\n    });\n    // Clear the last read results. This will be lazy-populated if used.\n    this._domains = null;\n  }\n}\nfunction createTransform(device, props) {\n  const vs = /* glsl */`\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-domain-vertex\n\nuniform sampler2D bins;\n\n#if NUM_DIMS == 1\nout float binIds;\n#else\nout vec2 binIds;\n#endif\n\n#if NUM_CHANNELS == 1\nflat out float values;\n#elif NUM_CHANNELS == 2\nflat out vec2 values;\n#else\nflat out vec3 values;\n#endif\n\nconst float NAN = intBitsToFloat(-1);\n\nvoid main() {\n  int row = gl_VertexID / SAMPLER_WIDTH;\n  int col = gl_VertexID - row * SAMPLER_WIDTH;\n  vec4 weights = texelFetch(bins, ivec2(col, row), 0);\n  vec3 value3 = mix(\n    mix(weights.rgb, vec3(weights.a), aggregatorTransform.isCount),\n    weights.rgb / max(weights.a, 1.0),\n    aggregatorTransform.isMean\n  );\n  if (weights.a == 0.0) {\n    value3 = vec3(NAN);\n  }\n\n#if NUM_DIMS == 1\n  binIds = float(gl_VertexID + aggregatorTransform.binIdRange.x);\n#else\n  int y = gl_VertexID / (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);\n  int x = gl_VertexID - y * (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);\n  binIds.y = float(y + aggregatorTransform.binIdRange.z);\n  binIds.x = float(x + aggregatorTransform.binIdRange.x);\n#endif\n\n#if NUM_CHANNELS == 3\n  values = value3;\n#elif NUM_CHANNELS == 2\n  values = value3.xy;\n#else\n  values = value3.x;\n#endif\n\n  gl_Position = vec4(0., 0., 0., 1.);\n  // This model renders into a 2x1 texture to obtain min and max simultaneously.\n  // See comments in fragment shader\n  gl_PointSize = 2.0;\n}\n`;\n  const fs = /* glsl */`\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-domain-fragment\n\nprecision highp float;\n\n#if NUM_CHANNELS == 1\nflat in float values;\n#elif NUM_CHANNELS == 2\nflat in vec2 values;\n#else\nflat in vec3 values;\n#endif\n\nout vec4 fragColor;\n\nvoid main() {\n  vec3 value3;\n#if NUM_CHANNELS == 3\n  value3 = values;\n#elif NUM_CHANNELS == 2\n  value3.xy = values;\n#else\n  value3.x = values;\n#endif\n  if (isnan(value3.x)) discard;\n  // This shader renders into a 2x1 texture with blending=max\n  // The left pixel yields the max value of each channel\n  // The right pixel yields the min value of each channel\n  if (gl_FragCoord.x < 1.0) {\n    fragColor = vec4(value3, 1.0);\n  } else {\n    fragColor = vec4(-value3, 1.0);\n  }\n}\n`;\n  return new BufferTransform(device, {\n    vs,\n    fs,\n    topology: 'point-list',\n    modules: [aggregatorTransformUniforms],\n    parameters: {\n      blend: true,\n      blendColorSrcFactor: 'one',\n      blendColorDstFactor: 'one',\n      blendColorOperation: 'max',\n      blendAlphaSrcFactor: 'one',\n      blendAlphaDstFactor: 'one',\n      blendAlphaOperation: 'max'\n    },\n    defines: {\n      NUM_DIMS: props.dimensions,\n      NUM_CHANNELS: props.channelCount,\n      SAMPLER_WIDTH: TEXTURE_WIDTH\n    },\n    varyings: ['binIds', 'values'],\n    disableWarnings: true\n  });\n}\n//# sourceMappingURL=webgl-aggregation-transform.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}