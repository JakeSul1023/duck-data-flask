{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { load } from '@loaders.gl/core';\nimport { createIterable } from '@deck.gl/core';\nconst DEFAULT_CANVAS_WIDTH = 1024;\nconst DEFAULT_BUFFER = 4;\nconst noop = () => {};\nconst DEFAULT_SAMPLER_PARAMETERS = {\n  minFilter: 'linear',\n  mipmapFilter: 'linear',\n  // LINEAR is the default value but explicitly set it here\n  magFilter: 'linear',\n  // minimize texture boundary artifacts\n  addressModeU: 'clamp-to-edge',\n  addressModeV: 'clamp-to-edge'\n};\nconst MISSING_ICON = {\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0\n};\nfunction nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n// update comment to create a new texture and copy original data.\nfunction resizeImage(ctx, imageData, maxWidth, maxHeight) {\n  const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);\n  const width = Math.floor(imageData.width * resizeRatio);\n  const height = Math.floor(imageData.height * resizeRatio);\n  if (resizeRatio === 1) {\n    // No resizing required\n    return {\n      image: imageData,\n      width,\n      height\n    };\n  }\n  ctx.canvas.height = height;\n  ctx.canvas.width = width;\n  ctx.clearRect(0, 0, width, height);\n  // image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight\n  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);\n  return {\n    image: ctx.canvas,\n    width,\n    height\n  };\n}\nfunction getIconId(icon) {\n  return icon && (icon.id || icon.url);\n}\n// resize texture without losing original data\nfunction resizeTexture(texture, width, height, sampler) {\n  const {\n    width: oldWidth,\n    height: oldHeight,\n    device\n  } = texture;\n  const newTexture = device.createTexture({\n    format: 'rgba8unorm',\n    width,\n    height,\n    sampler,\n    mipmaps: true\n  });\n  const commandEncoder = device.createCommandEncoder();\n  commandEncoder.copyTextureToTexture({\n    sourceTexture: texture,\n    destinationTexture: newTexture,\n    width: oldWidth,\n    height: oldHeight\n  });\n  commandEncoder.finish();\n  texture.destroy();\n  return newTexture;\n}\n// traverse icons in a row of icon atlas\n// extend each icon with left-top coordinates\nfunction buildRowMapping(mapping, columns, yOffset) {\n  for (let i = 0; i < columns.length; i++) {\n    const {\n      icon,\n      xOffset\n    } = columns[i];\n    const id = getIconId(icon);\n    mapping[id] = {\n      ...icon,\n      x: xOffset,\n      y: yOffset\n    };\n  }\n}\n/**\n * Generate coordinate mapping to retrieve icon left-top position from an icon atlas\n */\nexport function buildMapping({\n  icons,\n  buffer,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0,\n  rowHeight = 0,\n  canvasWidth\n}) {\n  let columns = [];\n  // Strategy to layout all the icons into a texture:\n  // traverse the icons sequentially, layout the icons from left to right, top to bottom\n  // when the sum of the icons width is equal or larger than canvasWidth,\n  // move to next row starting from total height so far plus max height of the icons in previous row\n  // row width is equal to canvasWidth\n  // row height is decided by the max height of the icons in that row\n  // mapping coordinates of each icon is its left-top position in the texture\n  for (let i = 0; i < icons.length; i++) {\n    const icon = icons[i];\n    const id = getIconId(icon);\n    if (!mapping[id]) {\n      const {\n        height,\n        width\n      } = icon;\n      // fill one row\n      if (xOffset + width + buffer > canvasWidth) {\n        buildRowMapping(mapping, columns, yOffset);\n        xOffset = 0;\n        yOffset = rowHeight + yOffset + buffer;\n        rowHeight = 0;\n        columns = [];\n      }\n      columns.push({\n        icon,\n        xOffset\n      });\n      xOffset = xOffset + width + buffer;\n      rowHeight = Math.max(rowHeight, height);\n    }\n  }\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset);\n  }\n  return {\n    mapping,\n    rowHeight,\n    xOffset,\n    yOffset,\n    canvasWidth,\n    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)\n  };\n}\n// extract icons from data\n// return icons should be unique, and not cached or cached but url changed\nexport function getDiffIcons(data, getIcon, cachedIcons) {\n  if (!data || !getIcon) {\n    return null;\n  }\n  cachedIcons = cachedIcons || {};\n  const icons = {};\n  const {\n    iterable,\n    objectInfo\n  } = createIterable(data);\n  for (const object of iterable) {\n    objectInfo.index++;\n    const icon = getIcon(object, objectInfo);\n    const id = getIconId(icon);\n    if (!icon) {\n      throw new Error('Icon is missing.');\n    }\n    if (!icon.url) {\n      throw new Error('Icon url is missing.');\n    }\n    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {\n      icons[id] = {\n        ...icon,\n        source: object,\n        sourceIndex: objectInfo.index\n      };\n    }\n  }\n  return icons;\n}\nexport default class IconManager {\n  constructor(device, {\n    onUpdate = noop,\n    onError = noop\n  }) {\n    this._loadOptions = null;\n    this._texture = null;\n    this._externalTexture = null;\n    this._mapping = {};\n    this._samplerParameters = null;\n    /** count of pending requests to fetch icons */\n    this._pendingCount = 0;\n    this._autoPacking = false;\n    // / internal state used for autoPacking\n    this._xOffset = 0;\n    this._yOffset = 0;\n    this._rowHeight = 0;\n    this._buffer = DEFAULT_BUFFER;\n    this._canvasWidth = DEFAULT_CANVAS_WIDTH;\n    this._canvasHeight = 0;\n    this._canvas = null;\n    this.device = device;\n    this.onUpdate = onUpdate;\n    this.onError = onError;\n  }\n  finalize() {\n    this._texture?.delete();\n  }\n  getTexture() {\n    return this._texture || this._externalTexture;\n  }\n  getIconMapping(icon) {\n    const id = this._autoPacking ? getIconId(icon) : icon;\n    return this._mapping[id] || MISSING_ICON;\n  }\n  setProps({\n    loadOptions,\n    autoPacking,\n    iconAtlas,\n    iconMapping,\n    textureParameters\n  }) {\n    if (loadOptions) {\n      this._loadOptions = loadOptions;\n    }\n    if (autoPacking !== undefined) {\n      this._autoPacking = autoPacking;\n    }\n    if (iconMapping) {\n      this._mapping = iconMapping;\n    }\n    if (iconAtlas) {\n      this._texture?.delete();\n      this._texture = null;\n      this._externalTexture = iconAtlas;\n    }\n    if (textureParameters) {\n      this._samplerParameters = textureParameters;\n    }\n  }\n  get isLoaded() {\n    return this._pendingCount === 0;\n  }\n  packIcons(data, getIcon) {\n    if (!this._autoPacking || typeof document === 'undefined') {\n      return;\n    }\n    const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});\n    if (icons.length > 0) {\n      // generate icon mapping\n      const {\n        mapping,\n        xOffset,\n        yOffset,\n        rowHeight,\n        canvasHeight\n      } = buildMapping({\n        icons,\n        buffer: this._buffer,\n        canvasWidth: this._canvasWidth,\n        mapping: this._mapping,\n        rowHeight: this._rowHeight,\n        xOffset: this._xOffset,\n        yOffset: this._yOffset\n      });\n      this._rowHeight = rowHeight;\n      this._mapping = mapping;\n      this._xOffset = xOffset;\n      this._yOffset = yOffset;\n      this._canvasHeight = canvasHeight;\n      // create new texture\n      if (!this._texture) {\n        this._texture = this.device.createTexture({\n          format: 'rgba8unorm',\n          width: this._canvasWidth,\n          height: this._canvasHeight,\n          sampler: this._samplerParameters || DEFAULT_SAMPLER_PARAMETERS,\n          mipmaps: true\n        });\n      }\n      if (this._texture.height !== this._canvasHeight) {\n        this._texture = resizeTexture(this._texture, this._canvasWidth, this._canvasHeight, this._samplerParameters || DEFAULT_SAMPLER_PARAMETERS);\n      }\n      this.onUpdate();\n      // load images\n      this._canvas = this._canvas || document.createElement('canvas');\n      this._loadIcons(icons);\n    }\n  }\n  _loadIcons(icons) {\n    // This method is only called in the auto packing case, where _canvas is defined\n    const ctx = this._canvas.getContext('2d', {\n      willReadFrequently: true\n    });\n    for (const icon of icons) {\n      this._pendingCount++;\n      load(icon.url, this._loadOptions).then(imageData => {\n        const id = getIconId(icon);\n        const iconDef = this._mapping[id];\n        const {\n          x,\n          y,\n          width: maxWidth,\n          height: maxHeight\n        } = iconDef;\n        const {\n          image,\n          width,\n          height\n        } = resizeImage(ctx, imageData, maxWidth, maxHeight);\n        this._texture?.copyExternalImage({\n          image,\n          x: x + (maxWidth - width) / 2,\n          y: y + (maxHeight - height) / 2,\n          width,\n          height\n        });\n        iconDef.width = width;\n        iconDef.height = height;\n        // Call to regenerate mipmaps after modifying texture(s)\n        // @ts-expect-error TODO v9 API not yet clear\n        this._texture.generateMipmap();\n        this.onUpdate();\n      }).catch(error => {\n        this.onError({\n          url: icon.url,\n          source: icon.source,\n          sourceIndex: icon.sourceIndex,\n          loadOptions: this._loadOptions,\n          error\n        });\n      }).finally(() => {\n        this._pendingCount--;\n      });\n    }\n  }\n}","map":{"version":3,"names":["load","createIterable","DEFAULT_CANVAS_WIDTH","DEFAULT_BUFFER","noop","DEFAULT_SAMPLER_PARAMETERS","minFilter","mipmapFilter","magFilter","addressModeU","addressModeV","MISSING_ICON","x","y","width","height","nextPowOfTwo","number","Math","pow","ceil","log2","resizeImage","ctx","imageData","maxWidth","maxHeight","resizeRatio","min","floor","image","canvas","clearRect","drawImage","getIconId","icon","id","url","resizeTexture","texture","sampler","oldWidth","oldHeight","device","newTexture","createTexture","format","mipmaps","commandEncoder","createCommandEncoder","copyTextureToTexture","sourceTexture","destinationTexture","finish","destroy","buildRowMapping","mapping","columns","yOffset","i","length","xOffset","buildMapping","icons","buffer","rowHeight","canvasWidth","push","max","canvasHeight","getDiffIcons","data","getIcon","cachedIcons","iterable","objectInfo","object","index","Error","source","sourceIndex","IconManager","constructor","onUpdate","onError","_loadOptions","_texture","_externalTexture","_mapping","_samplerParameters","_pendingCount","_autoPacking","_xOffset","_yOffset","_rowHeight","_buffer","_canvasWidth","_canvasHeight","_canvas","finalize","delete","getTexture","getIconMapping","setProps","loadOptions","autoPacking","iconAtlas","iconMapping","textureParameters","undefined","isLoaded","packIcons","document","Object","values","createElement","_loadIcons","getContext","willReadFrequently","then","iconDef","copyExternalImage","generateMipmap","catch","error","finally"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\layers\\src\\icon-layer\\icon-manager.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* global document */\nimport {Device, Texture, SamplerProps} from '@luma.gl/core';\nimport {load} from '@loaders.gl/core';\nimport {createIterable} from '@deck.gl/core';\n\nimport type {AccessorFunction} from '@deck.gl/core';\n\nconst DEFAULT_CANVAS_WIDTH = 1024;\nconst DEFAULT_BUFFER = 4;\n\nconst noop = () => {};\n\nconst DEFAULT_SAMPLER_PARAMETERS: SamplerProps = {\n  minFilter: 'linear',\n  mipmapFilter: 'linear',\n  // LINEAR is the default value but explicitly set it here\n  magFilter: 'linear',\n  // minimize texture boundary artifacts\n  addressModeU: 'clamp-to-edge',\n  addressModeV: 'clamp-to-edge'\n};\n\ntype IconDef = {\n  /** Width of the icon */\n  width: number;\n  /** Height of the icon */\n  height: number;\n  /** Horizontal position of icon anchor. Default: half width. */\n  anchorX?: number;\n  /** Vertical position of icon anchor. Default: half height. */\n  anchorY?: number;\n  /**\n   * Whether the icon is treated as a transparency mask.\n   * If `true`, color defined by `getColor` is applied.\n   * If `false`, pixel color from the icon image is applied.\n   * @default false\n   */\n  mask?: boolean;\n};\n\nexport type UnpackedIcon = {\n  /** Url to fetch the icon */\n  url: string;\n  /** Unique identifier of the icon. Icons of the same id are only fetched once. Fallback to `url` if not specified. */\n  id?: string;\n} & IconDef;\n\ntype PrepackedIcon = {\n  /** Left position of the icon on the atlas */\n  x: number;\n  /** Top position of the icon on the atlas */\n  y: number;\n} & IconDef;\n\nconst MISSING_ICON: PrepackedIcon = {\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0\n};\n\nexport type IconMapping = Record<string, PrepackedIcon>;\n\nexport type LoadIconErrorContext = {\n  error: Error;\n  /** The URL that was trying to fetch */\n  url: string;\n  /** The original data object that requested this icon */\n  source: any;\n  /** The index of the original data object that requested this icon */\n  sourceIndex: number;\n  /** The load options used for the fetch */\n  loadOptions: any;\n};\n\nfunction nextPowOfTwo(number: number): number {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\n// update comment to create a new texture and copy original data.\nfunction resizeImage(\n  ctx: CanvasRenderingContext2D,\n  imageData: HTMLImageElement | ImageBitmap,\n  maxWidth: number,\n  maxHeight: number\n): {\n  image: HTMLImageElement | HTMLCanvasElement | ImageBitmap;\n  width: number;\n  height: number;\n} {\n  const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);\n  const width = Math.floor(imageData.width * resizeRatio);\n  const height = Math.floor(imageData.height * resizeRatio);\n\n  if (resizeRatio === 1) {\n    // No resizing required\n    return {image: imageData, width, height};\n  }\n\n  ctx.canvas.height = height;\n  ctx.canvas.width = width;\n\n  ctx.clearRect(0, 0, width, height);\n\n  // image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight\n  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);\n  return {image: ctx.canvas, width, height};\n}\n\nfunction getIconId(icon: UnpackedIcon): string {\n  return icon && (icon.id || icon.url);\n}\n\n// resize texture without losing original data\nfunction resizeTexture(\n  texture: Texture,\n  width: number,\n  height: number,\n  sampler: SamplerProps\n): Texture {\n  const {width: oldWidth, height: oldHeight, device} = texture;\n\n  const newTexture = device.createTexture({\n    format: 'rgba8unorm',\n    width,\n    height,\n    sampler,\n    mipmaps: true\n  });\n  const commandEncoder = device.createCommandEncoder();\n  commandEncoder.copyTextureToTexture({\n    sourceTexture: texture,\n    destinationTexture: newTexture,\n    width: oldWidth,\n    height: oldHeight\n  });\n  commandEncoder.finish();\n\n  texture.destroy();\n  return newTexture;\n}\n\n// traverse icons in a row of icon atlas\n// extend each icon with left-top coordinates\nfunction buildRowMapping(\n  mapping: IconMapping,\n  columns: {\n    icon: UnpackedIcon;\n    xOffset: number;\n  }[],\n  yOffset: number\n): void {\n  for (let i = 0; i < columns.length; i++) {\n    const {icon, xOffset} = columns[i];\n    const id = getIconId(icon);\n    mapping[id] = {\n      ...icon,\n      x: xOffset,\n      y: yOffset\n    };\n  }\n}\n\n/**\n * Generate coordinate mapping to retrieve icon left-top position from an icon atlas\n */\nexport function buildMapping({\n  icons,\n  buffer,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0,\n  rowHeight = 0,\n  canvasWidth\n}: {\n  /** list of icon definitions */\n  icons: UnpackedIcon[];\n  /** add bleeding buffer to the right and bottom side of the image */\n  buffer: number;\n  /** right position of last icon in old mapping */\n  xOffset: number;\n  /** top position in last icon in old mapping */\n  yOffset: number;\n  /** height of the last icon's row */\n  rowHeight: number;\n  /** max width of canvas */\n  canvasWidth: number;\n  mapping: IconMapping;\n}): {\n  mapping: IconMapping;\n  rowHeight: number;\n  xOffset: number;\n  yOffset: number;\n  canvasWidth: number;\n  canvasHeight: number;\n} {\n  let columns: {\n    icon: UnpackedIcon;\n    xOffset: number;\n  }[] = [];\n  // Strategy to layout all the icons into a texture:\n  // traverse the icons sequentially, layout the icons from left to right, top to bottom\n  // when the sum of the icons width is equal or larger than canvasWidth,\n  // move to next row starting from total height so far plus max height of the icons in previous row\n  // row width is equal to canvasWidth\n  // row height is decided by the max height of the icons in that row\n  // mapping coordinates of each icon is its left-top position in the texture\n  for (let i = 0; i < icons.length; i++) {\n    const icon = icons[i];\n    const id = getIconId(icon);\n\n    if (!mapping[id]) {\n      const {height, width} = icon;\n\n      // fill one row\n      if (xOffset + width + buffer > canvasWidth) {\n        buildRowMapping(mapping, columns, yOffset);\n\n        xOffset = 0;\n        yOffset = rowHeight + yOffset + buffer;\n        rowHeight = 0;\n        columns = [];\n      }\n\n      columns.push({\n        icon,\n        xOffset\n      });\n\n      xOffset = xOffset + width + buffer;\n      rowHeight = Math.max(rowHeight, height);\n    }\n  }\n\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset);\n  }\n\n  return {\n    mapping,\n    rowHeight,\n    xOffset,\n    yOffset,\n    canvasWidth,\n    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)\n  };\n}\n\n// extract icons from data\n// return icons should be unique, and not cached or cached but url changed\nexport function getDiffIcons(\n  data: any,\n  getIcon: AccessorFunction<any, UnpackedIcon> | null,\n  cachedIcons: Record<string, PrepackedIcon & {url?: string}>\n): Record<\n  string,\n  UnpackedIcon & {\n    source: any;\n    sourceIndex: number;\n  }\n> | null {\n  if (!data || !getIcon) {\n    return null;\n  }\n\n  cachedIcons = cachedIcons || {};\n  const icons = {};\n  const {iterable, objectInfo} = createIterable(data);\n  for (const object of iterable) {\n    objectInfo.index++;\n    const icon = getIcon(object, objectInfo);\n    const id = getIconId(icon);\n\n    if (!icon) {\n      throw new Error('Icon is missing.');\n    }\n\n    if (!icon.url) {\n      throw new Error('Icon url is missing.');\n    }\n\n    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {\n      icons[id] = {...icon, source: object, sourceIndex: objectInfo.index};\n    }\n  }\n  return icons;\n}\n\nexport default class IconManager {\n  device: Device;\n\n  private onUpdate: () => void;\n  private onError: (context: LoadIconErrorContext) => void;\n  private _loadOptions: any = null;\n  private _texture: Texture | null = null;\n  private _externalTexture: Texture | null = null;\n  private _mapping: IconMapping = {};\n  private _samplerParameters: SamplerProps | null = null;\n\n  /** count of pending requests to fetch icons */\n  private _pendingCount: number = 0;\n\n  private _autoPacking: boolean = false;\n\n  // / internal state used for autoPacking\n\n  private _xOffset: number = 0;\n  private _yOffset: number = 0;\n  private _rowHeight: number = 0;\n  private _buffer: number = DEFAULT_BUFFER;\n  private _canvasWidth: number = DEFAULT_CANVAS_WIDTH;\n  private _canvasHeight: number = 0;\n  private _canvas: HTMLCanvasElement | null = null;\n\n  constructor(\n    device: Device,\n    {\n      onUpdate = noop,\n      onError = noop\n    }: {\n      /** Callback when the texture updates */\n      onUpdate: () => void;\n      /** Callback when an error is encountered */\n      onError: (context: LoadIconErrorContext) => void;\n    }\n  ) {\n    this.device = device;\n    this.onUpdate = onUpdate;\n    this.onError = onError;\n  }\n\n  finalize(): void {\n    this._texture?.delete();\n  }\n\n  getTexture(): Texture | null {\n    return this._texture || this._externalTexture;\n  }\n\n  getIconMapping(icon: string | UnpackedIcon): PrepackedIcon {\n    const id = this._autoPacking ? getIconId(icon as UnpackedIcon) : (icon as string);\n    return this._mapping[id] || MISSING_ICON;\n  }\n\n  setProps({\n    loadOptions,\n    autoPacking,\n    iconAtlas,\n    iconMapping,\n    textureParameters\n  }: {\n    loadOptions?: any;\n    autoPacking?: boolean;\n    iconAtlas?: Texture | null;\n    iconMapping?: IconMapping | null;\n    textureParameters?: SamplerProps | null;\n  }) {\n    if (loadOptions) {\n      this._loadOptions = loadOptions;\n    }\n\n    if (autoPacking !== undefined) {\n      this._autoPacking = autoPacking;\n    }\n\n    if (iconMapping) {\n      this._mapping = iconMapping;\n    }\n\n    if (iconAtlas) {\n      this._texture?.delete();\n      this._texture = null;\n      this._externalTexture = iconAtlas;\n    }\n\n    if (textureParameters) {\n      this._samplerParameters = textureParameters;\n    }\n  }\n\n  get isLoaded(): boolean {\n    return this._pendingCount === 0;\n  }\n\n  packIcons(data: any, getIcon: AccessorFunction<any, UnpackedIcon>): void {\n    if (!this._autoPacking || typeof document === 'undefined') {\n      return;\n    }\n\n    const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});\n\n    if (icons.length > 0) {\n      // generate icon mapping\n      const {mapping, xOffset, yOffset, rowHeight, canvasHeight} = buildMapping({\n        icons,\n        buffer: this._buffer,\n        canvasWidth: this._canvasWidth,\n        mapping: this._mapping,\n        rowHeight: this._rowHeight,\n        xOffset: this._xOffset,\n        yOffset: this._yOffset\n      });\n\n      this._rowHeight = rowHeight;\n      this._mapping = mapping;\n      this._xOffset = xOffset;\n      this._yOffset = yOffset;\n      this._canvasHeight = canvasHeight;\n\n      // create new texture\n      if (!this._texture) {\n        this._texture = this.device.createTexture({\n          format: 'rgba8unorm',\n          width: this._canvasWidth,\n          height: this._canvasHeight,\n          sampler: this._samplerParameters || DEFAULT_SAMPLER_PARAMETERS,\n          mipmaps: true\n        });\n      }\n\n      if (this._texture.height !== this._canvasHeight) {\n        this._texture = resizeTexture(\n          this._texture,\n          this._canvasWidth,\n          this._canvasHeight,\n          this._samplerParameters || DEFAULT_SAMPLER_PARAMETERS\n        );\n      }\n\n      this.onUpdate();\n\n      // load images\n      this._canvas = this._canvas || document.createElement('canvas');\n      this._loadIcons(icons);\n    }\n  }\n\n  private _loadIcons(\n    icons: (UnpackedIcon & {\n      source: any;\n      sourceIndex: number;\n    })[]\n  ): void {\n    // This method is only called in the auto packing case, where _canvas is defined\n    const ctx = this._canvas!.getContext('2d', {\n      willReadFrequently: true\n    }) as CanvasRenderingContext2D;\n\n    for (const icon of icons) {\n      this._pendingCount++;\n      load(icon.url, this._loadOptions)\n        .then(imageData => {\n          const id = getIconId(icon);\n\n          const iconDef = this._mapping[id];\n          const {x, y, width: maxWidth, height: maxHeight} = iconDef;\n\n          const {image, width, height} = resizeImage(\n            ctx,\n            imageData as ImageBitmap,\n            maxWidth,\n            maxHeight\n          );\n\n          this._texture?.copyExternalImage({\n            image,\n            x: x + (maxWidth - width) / 2,\n            y: y + (maxHeight - height) / 2,\n            width,\n            height\n          });\n          iconDef.width = width;\n          iconDef.height = height;\n\n          // Call to regenerate mipmaps after modifying texture(s)\n          // @ts-expect-error TODO v9 API not yet clear\n          this._texture.generateMipmap();\n\n          this.onUpdate();\n        })\n        .catch(error => {\n          this.onError({\n            url: icon.url,\n            source: icon.source,\n            sourceIndex: icon.sourceIndex,\n            loadOptions: this._loadOptions,\n            error\n          });\n        })\n        .finally(() => {\n          this._pendingCount--;\n        });\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}