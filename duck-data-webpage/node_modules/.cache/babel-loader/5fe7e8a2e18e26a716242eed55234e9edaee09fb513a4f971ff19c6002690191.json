{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Buffer, Texture, TextureView, Sampler, RenderPipeline, UniformStore, log, getTypedArrayFromDataType, getAttributeInfosFromLayouts, _BufferLayoutHelper } from '@luma.gl/core';\nimport { ShaderAssembler, getShaderLayoutFromWGSL } from '@luma.gl/shadertools';\nimport { makeGPUGeometry } from \"../geometry/gpu-geometry.js\";\nimport { PipelineFactory } from \"../factories/pipeline-factory.js\";\nimport { ShaderFactory } from \"../factories/shader-factory.js\";\nimport { getDebugTableForShaderLayout } from \"../debug/debug-shader-layout.js\";\nimport { debugFramebuffer } from \"../debug/debug-framebuffer.js\";\nimport { deepEqual } from \"../utils/deep-equal.js\";\nimport { uid } from \"../utils/uid.js\";\nimport { ShaderInputs } from \"../shader-inputs.js\";\n// import type {AsyncTextureProps} from '../async-texture/async-texture';\nimport { AsyncTexture } from \"../async-texture/async-texture.js\";\nimport { splitUniformsAndBindings } from \"./split-uniforms-and-bindings.js\";\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n/**\n * v9 Model API\n * A model\n * - automatically reuses pipelines (programs) when possible\n * - automatically rebuilds pipelines if necessary to accommodate changed settings\n * shadertools integration\n * - accepts modules and performs shader transpilation\n */\nexport class Model {\n  static defaultProps = {\n    ...RenderPipeline.defaultProps,\n    source: undefined,\n    vs: null,\n    fs: null,\n    id: 'unnamed',\n    handle: undefined,\n    userData: {},\n    defines: {},\n    modules: [],\n    moduleSettings: undefined,\n    geometry: null,\n    indexBuffer: null,\n    attributes: {},\n    constantAttributes: {},\n    varyings: [],\n    isInstanced: undefined,\n    instanceCount: 0,\n    vertexCount: 0,\n    shaderInputs: undefined,\n    pipelineFactory: undefined,\n    shaderFactory: undefined,\n    transformFeedback: undefined,\n    shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),\n    debugShaders: undefined,\n    disableWarnings: undefined\n  };\n  device;\n  id;\n  // @ts-expect-error assigned in function called from constructor\n  source;\n  // @ts-expect-error assigned in function called from constructor\n  vs;\n  // @ts-expect-error assigned in function called from constructor\n  fs;\n  pipelineFactory;\n  shaderFactory;\n  userData = {};\n  // Fixed properties (change can trigger pipeline rebuild)\n  /** The render pipeline GPU parameters, depth testing etc */\n  parameters;\n  /** The primitive topology */\n  topology;\n  /** Buffer layout */\n  bufferLayout;\n  // Dynamic properties\n  /** Use instanced rendering */\n  isInstanced = undefined;\n  /** instance count. `undefined` means not instanced */\n  instanceCount = 0;\n  /** Vertex count */\n  vertexCount;\n  /** Index buffer */\n  indexBuffer = null;\n  /** Buffer-valued attributes */\n  bufferAttributes = {};\n  /** Constant-valued attributes */\n  constantAttributes = {};\n  /** Bindings (textures, samplers, uniform buffers) */\n  bindings = {};\n  /** Sets uniforms @deprecated Use uniform buffers and setBindings() for portability*/\n  uniforms = {};\n  /**\n   * VertexArray\n   * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!\n   * @todo - allow application to define multiple vertex arrays?\n   * */\n  vertexArray;\n  /** TransformFeedback, WebGL 2 only. */\n  transformFeedback = null;\n  /** The underlying GPU \"program\". @note May be recreated if parameters change */\n  pipeline;\n  /** ShaderInputs instance */\n  // @ts-expect-error Assigned in function called by constructor\n  shaderInputs;\n  // @ts-expect-error Assigned in function called by constructor\n  _uniformStore;\n  _attributeInfos = {};\n  _gpuGeometry = null;\n  _getModuleUniforms;\n  props;\n  _pipelineNeedsUpdate = 'newly created';\n  _needsRedraw = 'initializing';\n  _destroyed = false;\n  /** \"Time\" of last draw. Monotonically increasing timestamp */\n  _lastDrawTimestamp = -1;\n  get [Symbol.toStringTag]() {\n    return 'Model';\n  }\n  toString() {\n    return `Model(${this.id})`;\n  }\n  constructor(device, props) {\n    this.props = {\n      ...Model.defaultProps,\n      ...props\n    };\n    props = this.props;\n    this.id = props.id || uid('model');\n    this.device = device;\n    Object.assign(this.userData, props.userData);\n    // Setup shader module inputs\n    const moduleMap = Object.fromEntries(this.props.modules?.map(module => [module.name, module]) || []);\n    const shaderInputs = props.shaderInputs || new ShaderInputs(moduleMap, {\n      disableWarnings: this.props.disableWarnings\n    });\n    // @ts-ignore\n    this.setShaderInputs(shaderInputs);\n    // Setup shader assembler\n    const platformInfo = getPlatformInfo(device);\n    // Extract modules from shader inputs if not supplied\n    const modules =\n    // @ts-ignore shaderInputs is assigned in setShaderInputs above.\n    (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];\n    const isWebGPU = this.device.type === 'webgpu';\n    // WebGPU\n    // TODO - hack to support unified WGSL shader\n    // TODO - this is wrong, compile a single shader\n    if (isWebGPU && this.props.source) {\n      // WGSL\n      const {\n        source,\n        getUniforms\n      } = this.props.shaderAssembler.assembleWGSLShader({\n        platformInfo,\n        ...this.props,\n        modules\n      });\n      this.source = source;\n      // @ts-expect-error\n      this._getModuleUniforms = getUniforms;\n      // Extract shader layout after modules have been added to WGSL source, to include any bindings added by modules\n      this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.source);\n    } else {\n      // GLSL\n      const {\n        vs,\n        fs,\n        getUniforms\n      } = this.props.shaderAssembler.assembleGLSLShaderPair({\n        platformInfo,\n        ...this.props,\n        modules\n      });\n      this.vs = vs;\n      this.fs = fs;\n      // @ts-expect-error\n      this._getModuleUniforms = getUniforms;\n    }\n    this.vertexCount = this.props.vertexCount;\n    this.instanceCount = this.props.instanceCount;\n    this.topology = this.props.topology;\n    this.bufferLayout = this.props.bufferLayout;\n    this.parameters = this.props.parameters;\n    // Geometry, if provided, sets topology and vertex cound\n    if (props.geometry) {\n      this.setGeometry(props.geometry);\n    }\n    this.pipelineFactory = props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);\n    this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);\n    // Create the pipeline\n    // @note order is important\n    this.pipeline = this._updatePipeline();\n    this.vertexArray = device.createVertexArray({\n      renderPipeline: this.pipeline\n    });\n    // Now we can apply geometry attributes\n    if (this._gpuGeometry) {\n      this._setGeometryAttributes(this._gpuGeometry);\n    }\n    // Apply any dynamic settings that will not trigger pipeline change\n    if ('isInstanced' in props) {\n      this.isInstanced = props.isInstanced;\n    }\n    if (props.instanceCount) {\n      this.setInstanceCount(props.instanceCount);\n    }\n    if (props.vertexCount) {\n      this.setVertexCount(props.vertexCount);\n    }\n    if (props.indexBuffer) {\n      this.setIndexBuffer(props.indexBuffer);\n    }\n    if (props.attributes) {\n      this.setAttributes(props.attributes);\n    }\n    if (props.constantAttributes) {\n      this.setConstantAttributes(props.constantAttributes);\n    }\n    if (props.bindings) {\n      this.setBindings(props.bindings);\n    }\n    if (props.uniforms) {\n      this.setUniformsWebGL(props.uniforms);\n    }\n    if (props.moduleSettings) {\n      // log.warn('Model.props.moduleSettings is deprecated. Use Model.shaderInputs.setProps()')();\n      this.updateModuleSettingsWebGL(props.moduleSettings);\n    }\n    if (props.transformFeedback) {\n      this.transformFeedback = props.transformFeedback;\n    }\n    // Catch any access to non-standard props\n    Object.seal(this);\n  }\n  destroy() {\n    if (this._destroyed) return;\n    this.pipelineFactory.release(this.pipeline);\n    this.shaderFactory.release(this.pipeline.vs);\n    if (this.pipeline.fs) {\n      this.shaderFactory.release(this.pipeline.fs);\n    }\n    this._uniformStore.destroy();\n    // TODO - mark resource as managed and destroyIfManaged() ?\n    this._gpuGeometry?.destroy();\n    this._destroyed = true;\n  }\n  // Draw call\n  /** Query redraw status. Clears the status. */\n  needsRedraw() {\n    // Catch any writes to already bound resources\n    if (this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp) {\n      this.setNeedsRedraw('contents of bound textures or buffers updated');\n    }\n    const needsRedraw = this._needsRedraw;\n    this._needsRedraw = false;\n    return needsRedraw;\n  }\n  /** Mark the model as needing a redraw */\n  setNeedsRedraw(reason) {\n    this._needsRedraw ||= reason;\n  }\n  predraw() {\n    // Update uniform buffers if needed\n    this.updateShaderInputs();\n    // Check if the pipeline is invalidated\n    this.pipeline = this._updatePipeline();\n  }\n  draw(renderPass) {\n    const loadingBinding = this._areBindingsLoading();\n    if (loadingBinding) {\n      log.info(LOG_DRAW_PRIORITY, `>>> DRAWING ABORTED ${this.id}: ${loadingBinding} not loaded`)();\n      return false;\n    }\n    try {\n      renderPass.pushDebugGroup(`${this}.predraw(${renderPass})`);\n      this.predraw();\n    } finally {\n      renderPass.popDebugGroup();\n    }\n    let drawSuccess;\n    try {\n      renderPass.pushDebugGroup(`${this}.draw(${renderPass})`);\n      this._logDrawCallStart();\n      // Update the pipeline if invalidated\n      // TODO - inside RenderPass is likely the worst place to do this from performance perspective.\n      // Application can call Model.predraw() to avoid this.\n      this.pipeline = this._updatePipeline();\n      // Set pipeline state, we may be sharing a pipeline so we need to set all state on every draw\n      // Any caching needs to be done inside the pipeline functions\n      // TODO this is a busy initialized check for all bindings every frame\n      const syncBindings = this._getBindings();\n      this.pipeline.setBindings(syncBindings, {\n        disableWarnings: this.props.disableWarnings\n      });\n      if (!isObjectEmpty(this.uniforms)) {\n        this.pipeline.setUniformsWebGL(this.uniforms);\n      }\n      const {\n        indexBuffer\n      } = this.vertexArray;\n      const indexCount = indexBuffer ? indexBuffer.byteLength / (indexBuffer.indexType === 'uint32' ? 4 : 2) : undefined;\n      drawSuccess = this.pipeline.draw({\n        renderPass,\n        vertexArray: this.vertexArray,\n        isInstanced: this.isInstanced,\n        vertexCount: this.vertexCount,\n        instanceCount: this.instanceCount,\n        indexCount,\n        transformFeedback: this.transformFeedback || undefined,\n        // WebGL shares underlying cached pipelines even for models that have different parameters and topology,\n        // so we must provide our unique parameters to each draw\n        // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)\n        parameters: this.parameters,\n        topology: this.topology\n      });\n    } finally {\n      renderPass.popDebugGroup();\n      this._logDrawCallEnd();\n    }\n    this._logFramebuffer(renderPass);\n    // Update needsRedraw flag\n    if (drawSuccess) {\n      this._lastDrawTimestamp = this.device.timestamp;\n      this._needsRedraw = false;\n    } else {\n      this._needsRedraw = 'waiting for resource initialization';\n    }\n    return drawSuccess;\n  }\n  // Update fixed fields (can trigger pipeline rebuild)\n  /**\n   * Updates the optional geometry\n   * Geometry, set topology and bufferLayout\n   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU\n   */\n  setGeometry(geometry) {\n    this._gpuGeometry?.destroy();\n    const gpuGeometry = geometry && makeGPUGeometry(this.device, geometry);\n    if (gpuGeometry) {\n      this.setTopology(gpuGeometry.topology || 'triangle-list');\n      const bufferLayoutHelper = new _BufferLayoutHelper(this.bufferLayout);\n      this.bufferLayout = bufferLayoutHelper.mergeBufferLayouts(gpuGeometry.bufferLayout, this.bufferLayout);\n      if (this.vertexArray) {\n        this._setGeometryAttributes(gpuGeometry);\n      }\n    }\n    this._gpuGeometry = gpuGeometry;\n  }\n  /**\n   * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).\n   * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU\n   */\n  setTopology(topology) {\n    if (topology !== this.topology) {\n      this.topology = topology;\n      this._setPipelineNeedsUpdate('topology');\n    }\n  }\n  /**\n   * Updates the buffer layout.\n   * @note Triggers a pipeline rebuild / pipeline cache fetch\n   */\n  setBufferLayout(bufferLayout) {\n    const bufferLayoutHelper = new _BufferLayoutHelper(this.bufferLayout);\n    this.bufferLayout = this._gpuGeometry ? bufferLayoutHelper.mergeBufferLayouts(bufferLayout, this._gpuGeometry.bufferLayout) : bufferLayout;\n    this._setPipelineNeedsUpdate('bufferLayout');\n    // Recreate the pipeline\n    this.pipeline = this._updatePipeline();\n    // vertex array needs to be updated if we update buffer layout,\n    // but not if we update parameters\n    this.vertexArray = this.device.createVertexArray({\n      renderPipeline: this.pipeline\n    });\n    // Reapply geometry attributes to the new vertex array\n    if (this._gpuGeometry) {\n      this._setGeometryAttributes(this._gpuGeometry);\n    }\n  }\n  /**\n   * Set GPU parameters.\n   * @note Can trigger a pipeline rebuild / pipeline cache fetch.\n   * @param parameters\n   */\n  setParameters(parameters) {\n    if (!deepEqual(parameters, this.parameters, 2)) {\n      this.parameters = parameters;\n      this._setPipelineNeedsUpdate('parameters');\n    }\n  }\n  // Update dynamic fields\n  /**\n   * Updates the instance count (used in draw calls)\n   * @note Any attributes with stepMode=instance need to be at least this big\n   */\n  setInstanceCount(instanceCount) {\n    this.instanceCount = instanceCount;\n    // luma.gl examples don't set props.isInstanced and rely on auto-detection\n    // but deck.gl sets instanceCount even for models that are not instanced.\n    if (this.isInstanced === undefined && instanceCount > 0) {\n      this.isInstanced = true;\n    }\n    this.setNeedsRedraw('instanceCount');\n  }\n  /**\n   * Updates the vertex count (used in draw calls)\n   * @note Any attributes with stepMode=vertex need to be at least this big\n   */\n  setVertexCount(vertexCount) {\n    this.vertexCount = vertexCount;\n    this.setNeedsRedraw('vertexCount');\n  }\n  /** Set the shader inputs */\n  setShaderInputs(shaderInputs) {\n    this.shaderInputs = shaderInputs;\n    this._uniformStore = new UniformStore(this.shaderInputs.modules);\n    // Create uniform buffer bindings for all modules that actually have uniforms\n    for (const [moduleName, module] of Object.entries(this.shaderInputs.modules)) {\n      if (shaderModuleHasUniforms(module)) {\n        const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);\n        this.bindings[`${moduleName}Uniforms`] = uniformBuffer;\n      }\n    }\n    this.setNeedsRedraw('shaderInputs');\n  }\n  /** Update uniform buffers from the model's shader inputs */\n  updateShaderInputs() {\n    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());\n    this.setBindings(this.shaderInputs.getBindingValues());\n    // TODO - this is already tracked through buffer/texture update times?\n    this.setNeedsRedraw('shaderInputs');\n  }\n  /**\n   * Sets bindings (textures, samplers, uniform buffers)\n   */\n  setBindings(bindings) {\n    Object.assign(this.bindings, bindings);\n    this.setNeedsRedraw('bindings');\n  }\n  /**\n   * Updates optional transform feedback. WebGL only.\n   */\n  setTransformFeedback(transformFeedback) {\n    this.transformFeedback = transformFeedback;\n    this.setNeedsRedraw('transformFeedback');\n  }\n  /**\n   * Sets the index buffer\n   * @todo - how to unset it if we change geometry?\n   */\n  setIndexBuffer(indexBuffer) {\n    this.vertexArray.setIndexBuffer(indexBuffer);\n    this.setNeedsRedraw('indexBuffer');\n  }\n  /**\n   * Sets attributes (buffers)\n   * @note Overrides any attributes previously set with the same name\n   */\n  setAttributes(buffers, options) {\n    const disableWarnings = options?.disableWarnings ?? this.props.disableWarnings;\n    if (buffers.indices) {\n      log.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();\n    }\n    const bufferLayoutHelper = new _BufferLayoutHelper(this.bufferLayout);\n    // Check if all buffers have a layout\n    for (const [bufferName, buffer] of Object.entries(buffers)) {\n      const bufferLayout = bufferLayoutHelper.getBufferLayout(bufferName);\n      if (!bufferLayout) {\n        if (!disableWarnings) {\n          log.warn(`Model(${this.id}): Missing layout for buffer \"${bufferName}\".`)();\n        }\n        continue; // eslint-disable-line no-continue\n      }\n      // For an interleaved attribute we may need to set multiple attributes\n      const attributeNames = bufferLayoutHelper.getAttributeNamesForBuffer(bufferLayout);\n      let set = false;\n      for (const attributeName of attributeNames) {\n        const attributeInfo = this._attributeInfos[attributeName];\n        if (attributeInfo) {\n          this.vertexArray.setBuffer(attributeInfo.location, buffer);\n          set = true;\n        }\n      }\n      if (!set && !disableWarnings) {\n        log.warn(`Model(${this.id}): Ignoring buffer \"${buffer.id}\" for unknown attribute \"${bufferName}\"`)();\n      }\n    }\n    this.setNeedsRedraw('attributes');\n  }\n  /**\n   * Sets constant attributes\n   * @note Overrides any attributes previously set with the same name\n   * Constant attributes are only supported in WebGL, not in WebGPU\n   * Any attribute that is disabled in the current vertex array object\n   * is read from the context's global constant value for that attribute location.\n   * @param constantAttributes\n   */\n  setConstantAttributes(attributes, options) {\n    for (const [attributeName, value] of Object.entries(attributes)) {\n      const attributeInfo = this._attributeInfos[attributeName];\n      if (attributeInfo) {\n        this.vertexArray.setConstantWebGL(attributeInfo.location, value);\n      } else if (!(options?.disableWarnings ?? this.props.disableWarnings)) {\n        log.warn(`Model \"${this.id}: Ignoring constant supplied for unknown attribute \"${attributeName}\"`)();\n      }\n    }\n    this.setNeedsRedraw('constants');\n  }\n  // DEPRECATED METHODS\n  /**\n   * Sets individual uniforms\n   * @deprecated WebGL only, use uniform buffers for portability\n   * @param uniforms\n   */\n  setUniforms(uniforms) {\n    this.setUniformsWebGL(uniforms);\n  }\n  /**\n   * Sets individual uniforms\n   * @deprecated WebGL only, use uniform buffers for portability\n   * @param uniforms\n   */\n  setUniformsWebGL(uniforms) {\n    if (!isObjectEmpty(uniforms)) {\n      this.pipeline.setUniformsWebGL(uniforms);\n      Object.assign(this.uniforms, uniforms);\n    }\n    this.setNeedsRedraw('uniforms');\n  }\n  /**\n   * @deprecated Updates shader module settings (which results in uniforms being set)\n   */\n  updateModuleSettingsWebGL(props) {\n    // log.warn('Model.updateModuleSettings is deprecated. Use Model.shaderInputs.setProps()')();\n    const {\n      bindings,\n      uniforms\n    } = splitUniformsAndBindings(this._getModuleUniforms(props));\n    Object.assign(this.bindings, bindings);\n    Object.assign(this.uniforms, uniforms);\n    this.setNeedsRedraw('moduleSettings');\n  }\n  // Internal methods\n  /** Check that bindings are loaded. Returns id of first binding that is still loading. */\n  _areBindingsLoading() {\n    for (const binding of Object.values(this.bindings)) {\n      if (binding instanceof AsyncTexture && !binding.isReady) {\n        return binding.id;\n      }\n    }\n    return false;\n  }\n  /** Extracts texture view from loaded async textures. Returns null if any textures have not yet been loaded. */\n  _getBindings() {\n    const validBindings = {};\n    for (const [name, binding] of Object.entries(this.bindings)) {\n      if (binding instanceof AsyncTexture) {\n        // Check that async textures are loaded\n        if (binding.isReady) {\n          validBindings[name] = binding.texture;\n        }\n      } else {\n        validBindings[name] = binding;\n      }\n    }\n    return validBindings;\n  }\n  /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */\n  _getBindingsUpdateTimestamp() {\n    let timestamp = 0;\n    for (const binding of Object.values(this.bindings)) {\n      if (binding instanceof TextureView) {\n        timestamp = Math.max(timestamp, binding.texture.updateTimestamp);\n      } else if (binding instanceof Buffer || binding instanceof Texture) {\n        timestamp = Math.max(timestamp, binding.updateTimestamp);\n      } else if (binding instanceof AsyncTexture) {\n        timestamp = binding.texture ? Math.max(timestamp, binding.texture.updateTimestamp) :\n        // The texture will become available in the future\n        Infinity;\n      } else if (!(binding instanceof Sampler)) {\n        timestamp = Math.max(timestamp, binding.buffer.updateTimestamp);\n      }\n    }\n    return timestamp;\n  }\n  /**\n   * Updates the optional geometry attributes\n   * Geometry, sets several attributes, indexBuffer, and also vertex count\n   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU\n   */\n  _setGeometryAttributes(gpuGeometry) {\n    // Filter geometry attribute so that we don't issue warnings for unused attributes\n    const attributes = {\n      ...gpuGeometry.attributes\n    };\n    for (const [attributeName] of Object.entries(attributes)) {\n      if (!this.pipeline.shaderLayout.attributes.find(layout => layout.name === attributeName) && attributeName !== 'positions') {\n        delete attributes[attributeName];\n      }\n    }\n    // TODO - delete previous geometry?\n    this.vertexCount = gpuGeometry.vertexCount;\n    this.setIndexBuffer(gpuGeometry.indices || null);\n    this.setAttributes(gpuGeometry.attributes, {\n      disableWarnings: true\n    });\n    this.setAttributes(attributes, {\n      disableWarnings: this.props.disableWarnings\n    });\n    this.setNeedsRedraw('geometry attributes');\n  }\n  /** Mark pipeline as needing update */\n  _setPipelineNeedsUpdate(reason) {\n    this._pipelineNeedsUpdate ||= reason;\n    this.setNeedsRedraw(reason);\n  }\n  /** Update pipeline if needed */\n  _updatePipeline() {\n    if (this._pipelineNeedsUpdate) {\n      let prevShaderVs = null;\n      let prevShaderFs = null;\n      if (this.pipeline) {\n        log.log(1, `Model ${this.id}: Recreating pipeline because \"${this._pipelineNeedsUpdate}\".`)();\n        prevShaderVs = this.pipeline.vs;\n        prevShaderFs = this.pipeline.fs;\n      }\n      this._pipelineNeedsUpdate = false;\n      const vs = this.shaderFactory.createShader({\n        id: `${this.id}-vertex`,\n        stage: 'vertex',\n        source: this.source || this.vs,\n        debugShaders: this.props.debugShaders\n      });\n      let fs = null;\n      if (this.source) {\n        fs = vs;\n      } else if (this.fs) {\n        fs = this.shaderFactory.createShader({\n          id: `${this.id}-fragment`,\n          stage: 'fragment',\n          source: this.source || this.fs,\n          debugShaders: this.props.debugShaders\n        });\n      }\n      this.pipeline = this.pipelineFactory.createRenderPipeline({\n        ...this.props,\n        bufferLayout: this.bufferLayout,\n        topology: this.topology,\n        parameters: this.parameters,\n        // TODO - why set bindings here when we reset them every frame?\n        // Should we expose a BindGroup abstraction?\n        bindings: this._getBindings(),\n        vs,\n        fs\n      });\n      this._attributeInfos = getAttributeInfosFromLayouts(this.pipeline.shaderLayout, this.bufferLayout);\n      if (prevShaderVs) this.shaderFactory.release(prevShaderVs);\n      if (prevShaderFs) this.shaderFactory.release(prevShaderFs);\n    }\n    return this.pipeline;\n  }\n  /** Throttle draw call logging */\n  _lastLogTime = 0;\n  _logOpen = false;\n  _logDrawCallStart() {\n    // IF level is 4 or higher, log every frame.\n    const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {\n      return;\n    }\n    this._lastLogTime = Date.now();\n    this._logOpen = true;\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {\n      collapsed: log.level <= 2\n    })();\n  }\n  _logDrawCallEnd() {\n    if (this._logOpen) {\n      const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.shaderLayout, this.id);\n      // log.table(logLevel, attributeTable)();\n      // log.table(logLevel, uniformTable)();\n      log.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();\n      const uniformTable = this.shaderInputs.getDebugTable();\n      // Add any global uniforms\n      for (const [name, value] of Object.entries(this.uniforms)) {\n        uniformTable[name] = {\n          value\n        };\n      }\n      log.table(LOG_DRAW_PRIORITY, uniformTable)();\n      const attributeTable = this._getAttributeDebugTable();\n      log.table(LOG_DRAW_PRIORITY, this._attributeInfos)();\n      log.table(LOG_DRAW_PRIORITY, attributeTable)();\n      log.groupEnd(LOG_DRAW_PRIORITY)();\n      this._logOpen = false;\n    }\n  }\n  _drawCount = 0;\n  _logFramebuffer(renderPass) {\n    const debugFramebuffers = this.device.props.debugFramebuffers;\n    this._drawCount++;\n    // Update first 3 frames and then every 60 frames\n    if (!debugFramebuffers) {\n      // } || (this._drawCount++ > 3 && this._drawCount % 60)) {\n      return;\n    }\n    // TODO - display framebuffer output in debug window\n    const framebuffer = renderPass.props.framebuffer;\n    if (framebuffer) {\n      debugFramebuffer(framebuffer, {\n        id: framebuffer.id,\n        minimap: true\n      });\n      // log.image({logLevel: LOG_DRAW_PRIORITY, message: `${framebuffer.id} %c sup?`, image})();\n    }\n  }\n  _getAttributeDebugTable() {\n    const table = {};\n    for (const [name, attributeInfo] of Object.entries(this._attributeInfos)) {\n      const values = this.vertexArray.attributes[attributeInfo.location];\n      table[attributeInfo.location] = {\n        name,\n        type: attributeInfo.shaderType,\n        values: values ? this._getBufferOrConstantValues(values, attributeInfo.bufferDataType) : 'null'\n      };\n    }\n    if (this.vertexArray.indexBuffer) {\n      const {\n        indexBuffer\n      } = this.vertexArray;\n      const values = indexBuffer.indexType === 'uint32' ? new Uint32Array(indexBuffer.debugData) : new Uint16Array(indexBuffer.debugData);\n      table.indices = {\n        name: 'indices',\n        type: indexBuffer.indexType,\n        values: values.toString()\n      };\n    }\n    return table;\n  }\n  // TODO - fix typing of luma data types\n  _getBufferOrConstantValues(attribute, dataType) {\n    const TypedArrayConstructor = getTypedArrayFromDataType(dataType);\n    const typedArray = attribute instanceof Buffer ? new TypedArrayConstructor(attribute.debugData) : attribute;\n    return typedArray.toString();\n  }\n}\nfunction shaderModuleHasUniforms(module) {\n  return Boolean(module.uniformTypes && !isObjectEmpty(module.uniformTypes));\n}\n// HELPERS\n/** Create a shadertools platform info from the Device */\nexport function getPlatformInfo(device) {\n  return {\n    type: device.type,\n    shaderLanguage: device.info.shadingLanguage,\n    shaderLanguageVersion: device.info.shadingLanguageVersion,\n    gpu: device.info.gpu,\n    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API\n    features: device.features\n  };\n}\n/** Returns true if given object is empty, false otherwise. */\nfunction isObjectEmpty(obj) {\n  // @ts-ignore key is unused\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for (const key in obj) {\n    return false;\n  }\n  return true;\n}\n//# sourceMappingURL=model.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}