{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { CompositeLayer } from '@deck.gl/core';\nimport { replaceInRange } from \"../utils.js\";\nimport { binaryToFeatureForAccesor } from \"./geojson-binary.js\";\nimport { POINT_LAYER, LINE_LAYER, POLYGON_LAYER, getDefaultProps, forwardProps } from \"./sub-layer-map.js\";\nimport { getGeojsonFeatures, separateGeojsonFeatures } from \"./geojson.js\";\nimport { createLayerPropsFromFeatures, createLayerPropsFromBinary } from \"./geojson-layer-props.js\";\nconst FEATURE_TYPES = ['points', 'linestrings', 'polygons'];\nconst defaultProps = {\n  ...getDefaultProps(POINT_LAYER.circle),\n  ...getDefaultProps(POINT_LAYER.icon),\n  ...getDefaultProps(POINT_LAYER.text),\n  ...getDefaultProps(LINE_LAYER),\n  ...getDefaultProps(POLYGON_LAYER),\n  // Overwrite sub layer defaults\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  _full3d: false,\n  iconAtlas: {\n    type: 'object',\n    value: null\n  },\n  iconMapping: {\n    type: 'object',\n    value: {}\n  },\n  getIcon: {\n    type: 'accessor',\n    value: f => f.properties.icon\n  },\n  getText: {\n    type: 'accessor',\n    value: f => f.properties.text\n  },\n  // Self props\n  pointType: 'circle',\n  // TODO: deprecated, remove in v9\n  getRadius: {\n    deprecatedFor: 'getPointRadius'\n  }\n};\n/** Render GeoJSON formatted data as polygons, lines and points (circles, icons and/or texts). */\nclass GeoJsonLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      layerProps: {},\n      features: {},\n      featuresDiff: {}\n    };\n  }\n  updateState({\n    props,\n    changeFlags\n  }) {\n    if (!changeFlags.dataChanged) {\n      return;\n    }\n    const {\n      data\n    } = this.props;\n    const binary = data && 'points' in data && 'polygons' in data && 'lines' in data;\n    this.setState({\n      binary\n    });\n    if (binary) {\n      this._updateStateBinary({\n        props,\n        changeFlags\n      });\n    } else {\n      this._updateStateJSON({\n        props,\n        changeFlags\n      });\n    }\n  }\n  _updateStateBinary({\n    props,\n    changeFlags\n  }) {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);\n    this.setState({\n      layerProps\n    });\n  }\n  _updateStateJSON({\n    props,\n    changeFlags\n  }) {\n    const features = getGeojsonFeatures(props.data);\n    const wrapFeature = this.getSubLayerRow.bind(this);\n    let newFeatures = {};\n    const featuresDiff = {};\n    if (Array.isArray(changeFlags.dataChanged)) {\n      const oldFeatures = this.state.features;\n      for (const key in oldFeatures) {\n        newFeatures[key] = oldFeatures[key].slice();\n        featuresDiff[key] = [];\n      }\n      for (const dataRange of changeFlags.dataChanged) {\n        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);\n        for (const key in oldFeatures) {\n          featuresDiff[key].push(replaceInRange({\n            data: newFeatures[key],\n            getIndex: f => f.__source.index,\n            dataRange,\n            replace: partialFeatures[key]\n          }));\n        }\n      }\n    } else {\n      newFeatures = separateGeojsonFeatures(features, wrapFeature);\n    }\n    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);\n    this.setState({\n      features: newFeatures,\n      featuresDiff,\n      layerProps\n    });\n  }\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {\n      index,\n      sourceLayer\n    } = info;\n    info.featureType = FEATURE_TYPES.find(ft => sourceLayer.id.startsWith(`${this.id}-${ft}-`));\n    if (index >= 0 && sourceLayer.id.startsWith(`${this.id}-points-text`) && this.state.binary) {\n      info.index = this.props.data.points.globalFeatureIds.value[index];\n    }\n    return info;\n  }\n  _updateAutoHighlight(info) {\n    // All sub layers except the points layer use source feature index to encode the picking color\n    // The points layer uses indices from the points data array.\n    const pointLayerIdPrefix = `${this.id}-points-`;\n    const sourceIsPoints = info.featureType === 'points';\n    for (const layer of this.getSubLayers()) {\n      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {\n        layer.updateAutoHighlight(info);\n      }\n    }\n  }\n  _renderPolygonLayer() {\n    const {\n      extruded,\n      wireframe\n    } = this.props;\n    const {\n      layerProps\n    } = this.state;\n    const id = 'polygons-fill';\n    const PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons?.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);\n    if (PolygonFillLayer) {\n      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);\n      // Avoid building the lineColors attribute if wireframe is off\n      const useLineColor = extruded && wireframe;\n      if (!useLineColor) {\n        delete forwardedProps.getLineColor;\n      }\n      // using a legacy API to invalid lineColor attributes\n      forwardedProps.updateTriggers.lineColors = useLineColor;\n      return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({\n        id,\n        updateTriggers: forwardedProps.updateTriggers\n      }), layerProps.polygons);\n    }\n    return null;\n  }\n  _renderLineLayers() {\n    const {\n      extruded,\n      stroked\n    } = this.props;\n    const {\n      layerProps\n    } = this.state;\n    const polygonStrokeLayerId = 'polygons-stroke';\n    const lineStringsLayerId = 'linestrings';\n    const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline?.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);\n    const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines?.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);\n    if (PolygonStrokeLayer || LineStringsLayer) {\n      const forwardedProps = forwardProps(this, LINE_LAYER.props);\n      return [PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({\n        id: polygonStrokeLayerId,\n        updateTriggers: forwardedProps.updateTriggers\n      }), layerProps.polygonsOutline), LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({\n        id: lineStringsLayerId,\n        updateTriggers: forwardedProps.updateTriggers\n      }), layerProps.lines)];\n    }\n    return null;\n  }\n  _renderPointLayers() {\n    const {\n      pointType\n    } = this.props;\n    const {\n      layerProps,\n      binary\n    } = this.state;\n    let {\n      highlightedObjectIndex\n    } = this.props;\n    if (!binary && Number.isFinite(highlightedObjectIndex)) {\n      // @ts-expect-error TODO - type non-binary data\n      highlightedObjectIndex = layerProps.points.data.findIndex(d => d.__source.index === highlightedObjectIndex);\n    }\n    // Avoid duplicate sub layer ids\n    const types = new Set(pointType.split('+'));\n    const pointLayers = [];\n    for (const type of types) {\n      const id = `points-${type}`;\n      const PointLayerMapping = POINT_LAYER[type];\n      const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points?.data) && this.getSubLayerClass(id, PointLayerMapping.type);\n      if (PointsLayer) {\n        const forwardedProps = forwardProps(this, PointLayerMapping.props);\n        let pointsLayerProps = layerProps.points;\n        if (type === 'text' && binary) {\n          // Picking colors are per-point but for text per-character are required\n          // getPickingInfo() maps back to the correct index\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          // @ts-expect-error TODO - type binary data\n          const {\n            instancePickingColors,\n            ...rest\n          } = pointsLayerProps.data.attributes;\n          pointsLayerProps = {\n            ...pointsLayerProps,\n            // @ts-expect-error TODO - type binary data\n            data: {\n              ...pointsLayerProps.data,\n              attributes: rest\n            }\n          };\n        }\n        pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({\n          id,\n          updateTriggers: forwardedProps.updateTriggers,\n          highlightedObjectIndex\n        }), pointsLayerProps));\n      }\n    }\n    return pointLayers;\n  }\n  renderLayers() {\n    const {\n      extruded\n    } = this.props;\n    const polygonFillLayer = this._renderPolygonLayer();\n    const lineLayers = this._renderLineLayers();\n    const pointLayers = this._renderPointLayers();\n    return [\n    // If not extruded: flat fill layer is drawn below outlines\n    !extruded && polygonFillLayer, lineLayers, pointLayers,\n    // If extruded: draw fill layer last for correct blending behavior\n    extruded && polygonFillLayer];\n  }\n  getSubLayerAccessor(accessor) {\n    const {\n      binary\n    } = this.state;\n    if (!binary || typeof accessor !== 'function') {\n      return super.getSubLayerAccessor(accessor);\n    }\n    return (object, info) => {\n      const {\n        data,\n        index\n      } = info;\n      const feature = binaryToFeatureForAccesor(data, index);\n      // @ts-ignore (TS2349) accessor is always function\n      return accessor(feature, info);\n    };\n  }\n}\nGeoJsonLayer.layerName = 'GeoJsonLayer';\nGeoJsonLayer.defaultProps = defaultProps;\nexport default GeoJsonLayer;","map":{"version":3,"names":["CompositeLayer","replaceInRange","binaryToFeatureForAccesor","POINT_LAYER","LINE_LAYER","POLYGON_LAYER","getDefaultProps","forwardProps","getGeojsonFeatures","separateGeojsonFeatures","createLayerPropsFromFeatures","createLayerPropsFromBinary","FEATURE_TYPES","defaultProps","circle","icon","text","stroked","filled","extruded","wireframe","_full3d","iconAtlas","type","value","iconMapping","getIcon","f","properties","getText","pointType","getRadius","deprecatedFor","GeoJsonLayer","initializeState","state","layerProps","features","featuresDiff","updateState","props","changeFlags","dataChanged","data","binary","setState","_updateStateBinary","_updateStateJSON","encodePickingColor","wrapFeature","getSubLayerRow","bind","newFeatures","Array","isArray","oldFeatures","key","slice","dataRange","partialFeatures","push","getIndex","__source","index","replace","getPickingInfo","params","info","sourceLayer","featureType","find","ft","id","startsWith","points","globalFeatureIds","_updateAutoHighlight","pointLayerIdPrefix","sourceIsPoints","layer","getSubLayers","updateAutoHighlight","_renderPolygonLayer","PolygonFillLayer","shouldRenderSubLayer","polygons","getSubLayerClass","forwardedProps","useLineColor","getLineColor","updateTriggers","lineColors","getSubLayerProps","_renderLineLayers","polygonStrokeLayerId","lineStringsLayerId","PolygonStrokeLayer","polygonsOutline","LineStringsLayer","lines","_renderPointLayers","highlightedObjectIndex","Number","isFinite","findIndex","d","types","Set","split","pointLayers","PointLayerMapping","PointsLayer","pointsLayerProps","instancePickingColors","rest","attributes","renderLayers","polygonFillLayer","lineLayers","getSubLayerAccessor","accessor","object","feature","layerName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\layers\\src\\geojson-layer\\geojson-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  Accessor,\n  Color,\n  CompositeLayer,\n  CompositeLayerProps,\n  Layer,\n  LayerData,\n  PickingInfo,\n  Unit,\n  Material,\n  UpdateParameters,\n  _ConstructorOf,\n  DefaultProps\n} from '@deck.gl/core';\n\nimport type {BinaryFeatureCollection} from '@loaders.gl/schema';\nimport type {Feature, Geometry, GeoJSON} from 'geojson';\n\nimport {replaceInRange} from '../utils';\nimport {BinaryFeatureTypes, binaryToFeatureForAccesor} from './geojson-binary';\nimport {\n  POINT_LAYER,\n  LINE_LAYER,\n  POLYGON_LAYER,\n  getDefaultProps,\n  forwardProps\n} from './sub-layer-map';\n\nimport {getGeojsonFeatures, SeparatedGeometries, separateGeojsonFeatures} from './geojson';\nimport {\n  createLayerPropsFromFeatures,\n  createLayerPropsFromBinary,\n  SubLayersProps\n} from './geojson-layer-props';\n\n/** All properties supported by GeoJsonLayer */\nexport type GeoJsonLayerProps<FeaturePropertiesT = unknown> =\n  _GeoJsonLayerProps<FeaturePropertiesT> & CompositeLayerProps;\n\n/** Properties added by GeoJsonLayer */\nexport type _GeoJsonLayerProps<FeaturePropertiesT> = {\n  data:\n    | string\n    | GeoJSON\n    | Feature[]\n    | BinaryFeatureCollection\n    | Promise<GeoJSON | Feature[] | BinaryFeatureCollection>;\n  /**\n   * How to render Point and MultiPoint features in the data.\n   *\n   * Supported types are:\n   *  * `'circle'`\n   *  * `'icon'`\n   *  * `'text'`\n   *\n   * @default 'circle'\n   */\n  pointType?: string;\n} & _GeoJsonLayerFillProps<FeaturePropertiesT> &\n  _GeoJsonLayerStrokeProps<FeaturePropertiesT> &\n  _GeoJsonLayer3DProps<FeaturePropertiesT> &\n  _GeoJsonLayerPointCircleProps<FeaturePropertiesT> &\n  _GeojsonLayerIconPointProps<FeaturePropertiesT> &\n  _GeojsonLayerTextPointProps<FeaturePropertiesT>;\n\n/** GeoJsonLayer fill options. */\ntype _GeoJsonLayerFillProps<FeaturePropertiesT> = {\n  /**\n   * Whether to draw a filled polygon (solid fill).\n   *\n   * Note that only the area between the outer polygon and any holes will be filled.\n   *\n   * @default true\n   */\n  filled?: boolean;\n\n  /**\n   * Fill collor value or accessor.\n   *\n   * @default [0, 0, 0, 255]\n   */\n  getFillColor?: Accessor<Feature<Geometry, FeaturePropertiesT>, Color>;\n};\n\n/** GeoJsonLayer stroke options. */\ntype _GeoJsonLayerStrokeProps<FeaturePropertiesT> = {\n  /**\n   * Whether to draw an outline around the polygon (solid fill).\n   *\n   * Note that both the outer polygon as well the outlines of any holes will be drawn.\n   *\n   * @default true\n   */\n  stroked?: boolean;\n\n  /**\n   * Line color value or accessor.\n   *\n   * @default [0, 0, 0, 255]\n   */\n  getLineColor?: Accessor<Feature<Geometry, FeaturePropertiesT>, Color>;\n\n  /**\n   * Line width value or accessor.\n   *\n   * @default 1\n   */\n  getLineWidth?: Accessor<Feature<Geometry, FeaturePropertiesT>, number>;\n\n  /**\n   * The units of the line width, one of `meters`, `common`, and `pixels`.\n   *\n   * @default 'meters'\n   * @see Unit.\n   */\n  lineWidthUnits?: Unit;\n\n  /**\n   * A multiplier that is applied to all line widths\n   *\n   * @default 1\n   */\n  lineWidthScale?: number;\n\n  /**\n   * The minimum line width in pixels.\n   *\n   * @default 0\n   */\n  lineWidthMinPixels?: number;\n\n  /**\n   * The maximum line width in pixels\n   *\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  lineWidthMaxPixels?: number;\n\n  /**\n   * Type of joint. If `true`, draw round joints. Otherwise draw miter joints.\n   *\n   * @default false\n   */\n  lineJointRounded?: boolean;\n\n  /**\n   * The maximum extent of a joint in ratio to the stroke width.\n   *\n   * Only works if `lineJointRounded` is false.\n   *\n   * @default 4\n   */\n  lineMiterLimit?: number;\n\n  /**\n   * Type of line caps.\n   *\n   * If `true`, draw round caps. Otherwise draw square caps.\n   *\n   * @default false\n   */\n  lineCapRounded?: boolean;\n\n  /**\n   * If `true`, extrude the line in screen space (width always faces the camera).\n   * If `false`, the width always faces up.\n   *\n   * @default false\n   */\n  lineBillboard?: boolean;\n};\n\n/** GeoJsonLayer 3D options. */\ntype _GeoJsonLayer3DProps<FeaturePropertiesT> = {\n  /**\n   * Extrude Polygon and MultiPolygon features along the z-axis if set to true\n   *\n   * Based on the elevations provided by the `getElevation` accessor.\n   *\n   * @default false\n   */\n  extruded?: boolean;\n\n  /**\n   * Whether to generate a line wireframe of the hexagon.\n   *\n   * @default false\n   */\n  wireframe?: boolean;\n\n  /**\n   * (Experimental) This prop is only effective with `XYZ` data.\n   * When true, polygon tesselation will be performed on the plane with the largest area, instead of the xy plane.\n   * @default false\n   */\n  _full3d?: boolean;\n\n  /**\n   * Elevation valur or accessor.\n   *\n   * Only used if `extruded: true`.\n   *\n   * @default 1000\n   */\n  getElevation?: Accessor<Feature<Geometry, FeaturePropertiesT>, number>;\n\n  /**\n   * Elevation multiplier.\n   *\n   * The final elevation is calculated by `elevationScale * getElevation(d)`.\n   * `elevationScale` is a handy property to scale all elevation without updating the data.\n   *\n   * @default 1\n   */\n  elevationScale?: boolean;\n\n  /**\n   * Material settings for lighting effect. Applies to extruded polgons.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n};\n\n/** GeoJsonLayer Properties forwarded to `ScatterPlotLayer` if `pointType` is `'circle'` */\nexport type _GeoJsonLayerPointCircleProps<FeaturePropertiesT> = {\n  getPointRadius?: Accessor<Feature<Geometry, FeaturePropertiesT>, number>;\n  pointRadiusUnits?: Unit;\n  pointRadiusScale?: number;\n  pointRadiusMinPixels?: number;\n  pointRadiusMaxPixels?: number;\n  pointAntialiasing?: boolean;\n  pointBillboard?: boolean;\n\n  /** @deprecated use getPointRadius */\n  getRadius?: Accessor<Feature<Geometry, FeaturePropertiesT>, number>;\n};\n\n/** GeoJsonLayer properties forwarded to `IconLayer` if `pointType` is `'icon'` */\ntype _GeojsonLayerIconPointProps<FeaturePropertiesT> = {\n  iconAtlas?: any;\n  iconMapping?: any;\n  getIcon?: Accessor<Feature<Geometry, FeaturePropertiesT>, any>;\n  getIconSize?: Accessor<Feature<Geometry, FeaturePropertiesT>, number>;\n  getIconColor?: Accessor<Feature<Geometry, FeaturePropertiesT>, Color>;\n  getIconAngle?: Accessor<Feature<Geometry, FeaturePropertiesT>, number>;\n  getIconPixelOffset?: Accessor<Feature<Geometry, FeaturePropertiesT>, number[]>;\n  iconSizeUnits?: Unit;\n  iconSizeScale?: number;\n  iconSizeMinPixels?: number;\n  iconSizeMaxPixels?: number;\n  iconBillboard?: boolean;\n  iconAlphaCutoff?: number;\n};\n\n/** GeoJsonLayer properties forwarded to `TextLayer` if `pointType` is `'text'` */\ntype _GeojsonLayerTextPointProps<FeaturePropertiesT> = {\n  getText?: Accessor<Feature<Geometry, FeaturePropertiesT>, any>;\n  getTextColor?: Accessor<Feature<Geometry, FeaturePropertiesT>, Color>;\n  getTextAngle?: Accessor<Feature<Geometry, FeaturePropertiesT>, number>;\n  getTextSize?: Accessor<Feature<Geometry, FeaturePropertiesT>, number>;\n  getTextAnchor?: Accessor<Feature<Geometry, FeaturePropertiesT>, string>;\n  getTextAlignmentBaseline?: Accessor<Feature<Geometry, FeaturePropertiesT>, string>;\n  getTextPixelOffset?: Accessor<Feature<Geometry, FeaturePropertiesT>, number[]>;\n  getTextBackgroundColor?: Accessor<Feature<Geometry, FeaturePropertiesT>, Color>;\n  getTextBorderColor?: Accessor<Feature<Geometry, FeaturePropertiesT>, Color>;\n  getTextBorderWidth?: Accessor<Feature<Geometry, FeaturePropertiesT>, number>;\n  textSizeUnits?: Unit;\n  textSizeScale?: number;\n  textSizeMinPixels?: number;\n  textSizeMaxPixels?: number;\n  textCharacterSet?: any;\n  textFontFamily?: string;\n  textFontWeight?: number;\n  textLineHeight?: number;\n  textMaxWidth?: number;\n  textWordBreak?: string; // TODO\n  textBackground?: boolean;\n  textBackgroundPadding?: number[];\n  textOutlineColor?: Color;\n  textOutlineWidth?: number;\n  textBillboard?: boolean;\n  textFontSettings?: any;\n};\n\nconst FEATURE_TYPES = ['points', 'linestrings', 'polygons'];\n\nconst defaultProps: DefaultProps<GeoJsonLayerProps> = {\n  ...getDefaultProps(POINT_LAYER.circle),\n  ...getDefaultProps(POINT_LAYER.icon),\n  ...getDefaultProps(POINT_LAYER.text),\n  ...getDefaultProps(LINE_LAYER),\n  ...getDefaultProps(POLYGON_LAYER),\n\n  // Overwrite sub layer defaults\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  _full3d: false,\n  iconAtlas: {type: 'object', value: null},\n  iconMapping: {type: 'object', value: {}},\n  getIcon: {type: 'accessor', value: f => f.properties.icon},\n  getText: {type: 'accessor', value: f => f.properties.text},\n\n  // Self props\n  pointType: 'circle',\n\n  // TODO: deprecated, remove in v9\n  getRadius: {deprecatedFor: 'getPointRadius'}\n};\n\ntype GeoJsonPickingInfo = PickingInfo & {\n  featureType?: string | null;\n  info?: any;\n};\n\n/** Render GeoJSON formatted data as polygons, lines and points (circles, icons and/or texts). */\nexport default class GeoJsonLayer<\n  FeaturePropertiesT = any,\n  ExtraProps extends {} = {}\n> extends CompositeLayer<Required<_GeoJsonLayerProps<FeaturePropertiesT>> & ExtraProps> {\n  static layerName = 'GeoJsonLayer';\n  static defaultProps = defaultProps;\n\n  state!: {\n    layerProps: Partial<SubLayersProps>;\n    features: Partial<SeparatedGeometries>;\n    featuresDiff: Partial<{\n      [key in keyof SeparatedGeometries]: {\n        startRow: number;\n        endRow: number;\n      }[];\n    }>;\n    binary?: boolean;\n  };\n\n  initializeState(): void {\n    this.state = {\n      layerProps: {},\n      features: {},\n      featuresDiff: {}\n    };\n  }\n\n  updateState({props, changeFlags}: UpdateParameters<this>): void {\n    if (!changeFlags.dataChanged) {\n      return;\n    }\n    const {data} = this.props;\n    const binary =\n      data && 'points' in (data as {}) && 'polygons' in (data as {}) && 'lines' in (data as {});\n\n    this.setState({binary});\n\n    if (binary) {\n      this._updateStateBinary({props, changeFlags});\n    } else {\n      this._updateStateJSON({props, changeFlags});\n    }\n  }\n\n  private _updateStateBinary({props, changeFlags}): void {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);\n    this.setState({layerProps});\n  }\n\n  private _updateStateJSON({props, changeFlags}): void {\n    const features: Feature[] = getGeojsonFeatures(props.data) as any;\n    const wrapFeature = this.getSubLayerRow.bind(this);\n    let newFeatures: SeparatedGeometries = {} as SeparatedGeometries;\n    const featuresDiff = {};\n\n    if (Array.isArray(changeFlags.dataChanged)) {\n      const oldFeatures = this.state.features;\n      for (const key in oldFeatures) {\n        newFeatures[key] = oldFeatures[key].slice();\n        featuresDiff[key] = [];\n      }\n\n      for (const dataRange of changeFlags.dataChanged) {\n        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);\n        for (const key in oldFeatures) {\n          featuresDiff[key].push(\n            replaceInRange({\n              data: newFeatures[key],\n              getIndex: f => f.__source.index,\n              dataRange,\n              replace: partialFeatures[key]\n            })\n          );\n        }\n      }\n    } else {\n      newFeatures = separateGeojsonFeatures(features, wrapFeature);\n    }\n\n    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);\n\n    this.setState({\n      features: newFeatures,\n      featuresDiff,\n      layerProps\n    });\n  }\n\n  getPickingInfo(params): GeoJsonPickingInfo {\n    const info = super.getPickingInfo(params) as GeoJsonPickingInfo;\n    const {index, sourceLayer} = info;\n    info.featureType = FEATURE_TYPES.find(ft => sourceLayer!.id.startsWith(`${this.id}-${ft}-`));\n    if (index >= 0 && sourceLayer!.id.startsWith(`${this.id}-points-text`) && this.state.binary) {\n      info.index = (this.props.data as BinaryFeatureCollection).points!.globalFeatureIds.value[\n        index\n      ];\n    }\n    return info;\n  }\n\n  _updateAutoHighlight(info: GeoJsonPickingInfo): void {\n    // All sub layers except the points layer use source feature index to encode the picking color\n    // The points layer uses indices from the points data array.\n    const pointLayerIdPrefix = `${this.id}-points-`;\n    const sourceIsPoints = info.featureType === 'points';\n    for (const layer of this.getSubLayers()) {\n      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {\n        layer.updateAutoHighlight(info);\n      }\n    }\n  }\n\n  private _renderPolygonLayer(): Layer | null {\n    const {extruded, wireframe} = this.props;\n    const {layerProps} = this.state;\n    const id = 'polygons-fill';\n\n    const PolygonFillLayer =\n      this.shouldRenderSubLayer(id, layerProps.polygons?.data) &&\n      this.getSubLayerClass(id, POLYGON_LAYER.type);\n\n    if (PolygonFillLayer) {\n      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);\n      // Avoid building the lineColors attribute if wireframe is off\n      const useLineColor = extruded && wireframe;\n      if (!useLineColor) {\n        delete forwardedProps.getLineColor;\n      }\n      // using a legacy API to invalid lineColor attributes\n      forwardedProps.updateTriggers.lineColors = useLineColor;\n\n      return new PolygonFillLayer(\n        forwardedProps,\n        this.getSubLayerProps({\n          id,\n          updateTriggers: forwardedProps.updateTriggers\n        }),\n        layerProps.polygons\n      );\n    }\n    return null;\n  }\n\n  private _renderLineLayers(): (Layer | false)[] | null {\n    const {extruded, stroked} = this.props;\n    const {layerProps} = this.state;\n    const polygonStrokeLayerId = 'polygons-stroke';\n    const lineStringsLayerId = 'linestrings';\n\n    const PolygonStrokeLayer =\n      !extruded &&\n      stroked &&\n      this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline?.data) &&\n      this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);\n    const LineStringsLayer =\n      this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines?.data) &&\n      this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);\n\n    if (PolygonStrokeLayer || LineStringsLayer) {\n      const forwardedProps = forwardProps(this, LINE_LAYER.props);\n\n      return [\n        PolygonStrokeLayer &&\n          new PolygonStrokeLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id: polygonStrokeLayerId,\n              updateTriggers: forwardedProps.updateTriggers\n            }),\n            layerProps.polygonsOutline\n          ),\n\n        LineStringsLayer &&\n          new LineStringsLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id: lineStringsLayerId,\n              updateTriggers: forwardedProps.updateTriggers\n            }),\n            layerProps.lines\n          )\n      ];\n    }\n    return null;\n  }\n\n  private _renderPointLayers(): Layer[] | null {\n    const {pointType} = this.props;\n    const {layerProps, binary} = this.state;\n    let {highlightedObjectIndex} = this.props;\n\n    if (!binary && Number.isFinite(highlightedObjectIndex)) {\n      // @ts-expect-error TODO - type non-binary data\n      highlightedObjectIndex = layerProps.points.data.findIndex(\n        d => d.__source.index === highlightedObjectIndex\n      );\n    }\n\n    // Avoid duplicate sub layer ids\n    const types = new Set(pointType.split('+'));\n    const pointLayers: Layer[] = [];\n    for (const type of types) {\n      const id = `points-${type}`;\n      const PointLayerMapping = POINT_LAYER[type];\n      const PointsLayer: _ConstructorOf<Layer> =\n        PointLayerMapping &&\n        this.shouldRenderSubLayer(id, layerProps.points?.data) &&\n        this.getSubLayerClass(id, PointLayerMapping.type);\n      if (PointsLayer) {\n        const forwardedProps = forwardProps(this, PointLayerMapping.props);\n        let pointsLayerProps = layerProps.points;\n\n        if (type === 'text' && binary) {\n          // Picking colors are per-point but for text per-character are required\n          // getPickingInfo() maps back to the correct index\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          // @ts-expect-error TODO - type binary data\n          const {instancePickingColors, ...rest} = pointsLayerProps.data.attributes;\n          pointsLayerProps = {\n            ...pointsLayerProps,\n            // @ts-expect-error TODO - type binary data\n            data: {...(pointsLayerProps.data as LayerData), attributes: rest}\n          };\n        }\n\n        pointLayers.push(\n          new PointsLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id,\n              updateTriggers: forwardedProps.updateTriggers,\n              highlightedObjectIndex\n            }),\n            pointsLayerProps\n          )\n        );\n      }\n    }\n    return pointLayers;\n  }\n\n  renderLayers() {\n    const {extruded} = this.props;\n\n    const polygonFillLayer = this._renderPolygonLayer();\n    const lineLayers = this._renderLineLayers();\n    const pointLayers = this._renderPointLayers();\n\n    return [\n      // If not extruded: flat fill layer is drawn below outlines\n      !extruded && polygonFillLayer,\n      lineLayers,\n      pointLayers,\n      // If extruded: draw fill layer last for correct blending behavior\n      extruded && polygonFillLayer\n    ];\n  }\n\n  protected getSubLayerAccessor<In, Out>(accessor: Accessor<In, Out>): Accessor<In, Out> {\n    const {binary} = this.state;\n    if (!binary || typeof accessor !== 'function') {\n      return super.getSubLayerAccessor(accessor);\n    }\n\n    return (object, info) => {\n      const {data, index} = info;\n      const feature = binaryToFeatureForAccesor(data as unknown as BinaryFeatureTypes, index);\n      // @ts-ignore (TS2349) accessor is always function\n      return accessor(feature, info);\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}