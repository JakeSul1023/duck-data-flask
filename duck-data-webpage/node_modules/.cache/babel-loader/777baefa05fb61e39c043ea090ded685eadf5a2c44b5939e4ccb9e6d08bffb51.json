{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBlob } from \"../../javascript-utils/is-type.js\";\nimport { isLoaderObject } from \"../loader-utils/normalize-loader.js\";\nimport { getFetchFunction } from \"../loader-utils/get-fetch-function.js\";\nimport { parse } from \"./parse.js\";\n// export async function load(url: string | DataType, loaders: LoaderOptions): Promise<any>;\n// implementation signature\nexport async function load(url, loaders, options, context) {\n  let resolvedLoaders;\n  let resolvedOptions;\n  // Signature: load(url, options)\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    resolvedLoaders = [];\n    resolvedOptions = loaders;\n    context = undefined; // context not supported in short signature\n  } else {\n    resolvedLoaders = loaders;\n    resolvedOptions = options;\n  }\n  // Select fetch function\n  const fetch = getFetchFunction(resolvedOptions);\n  // at this point, `url` could be already loaded binary data\n  let data = url;\n  // url is a string, fetch the url\n  if (typeof url === 'string') {\n    data = await fetch(url);\n    // URL is Blob or File, fetchFile handles it (alt: we could generate ObjectURL here)\n  }\n  if (isBlob(url)) {\n    // The fetch response object will contain blob.name\n    // @ts-expect-error TODO - This may not work for overridden fetch functions\n    data = await fetch(url);\n  }\n  // Data is loaded (at least we have a `Response` object) so time to hand over to `parse`\n  // return await parse(data, loaders as Loader[], options);\n  return Array.isArray(resolvedLoaders) ? await parse(data, resolvedLoaders, resolvedOptions) // loader array overload\n  : await parse(data, resolvedLoaders, resolvedOptions); // single loader overload\n}","map":{"version":3,"names":["isBlob","isLoaderObject","getFetchFunction","parse","load","url","loaders","options","context","resolvedLoaders","resolvedOptions","Array","isArray","undefined","fetch","data"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/core/dist/lib/api/load.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBlob } from \"../../javascript-utils/is-type.js\";\nimport { isLoaderObject } from \"../loader-utils/normalize-loader.js\";\nimport { getFetchFunction } from \"../loader-utils/get-fetch-function.js\";\nimport { parse } from \"./parse.js\";\n// export async function load(url: string | DataType, loaders: LoaderOptions): Promise<any>;\n// implementation signature\nexport async function load(url, loaders, options, context) {\n    let resolvedLoaders;\n    let resolvedOptions;\n    // Signature: load(url, options)\n    if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n        resolvedLoaders = [];\n        resolvedOptions = loaders;\n        context = undefined; // context not supported in short signature\n    }\n    else {\n        resolvedLoaders = loaders;\n        resolvedOptions = options;\n    }\n    // Select fetch function\n    const fetch = getFetchFunction(resolvedOptions);\n    // at this point, `url` could be already loaded binary data\n    let data = url;\n    // url is a string, fetch the url\n    if (typeof url === 'string') {\n        data = await fetch(url);\n        // URL is Blob or File, fetchFile handles it (alt: we could generate ObjectURL here)\n    }\n    if (isBlob(url)) {\n        // The fetch response object will contain blob.name\n        // @ts-expect-error TODO - This may not work for overridden fetch functions\n        data = await fetch(url);\n    }\n    // Data is loaded (at least we have a `Response` object) so time to hand over to `parse`\n    // return await parse(data, loaders as Loader[], options);\n    return Array.isArray(resolvedLoaders)\n        ? await parse(data, resolvedLoaders, resolvedOptions) // loader array overload\n        : await parse(data, resolvedLoaders, resolvedOptions); // single loader overload\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,MAAM,QAAQ,mCAAmC;AAC1D,SAASC,cAAc,QAAQ,qCAAqC;AACpE,SAASC,gBAAgB,QAAQ,uCAAuC;AACxE,SAASC,KAAK,QAAQ,YAAY;AAClC;AACA;AACA,OAAO,eAAeC,IAAIA,CAACC,GAAG,EAAEC,OAAO,EAAEC,OAAO,EAAEC,OAAO,EAAE;EACvD,IAAIC,eAAe;EACnB,IAAIC,eAAe;EACnB;EACA,IAAI,CAACC,KAAK,CAACC,OAAO,CAACN,OAAO,CAAC,IAAI,CAACL,cAAc,CAACK,OAAO,CAAC,EAAE;IACrDG,eAAe,GAAG,EAAE;IACpBC,eAAe,GAAGJ,OAAO;IACzBE,OAAO,GAAGK,SAAS,CAAC,CAAC;EACzB,CAAC,MACI;IACDJ,eAAe,GAAGH,OAAO;IACzBI,eAAe,GAAGH,OAAO;EAC7B;EACA;EACA,MAAMO,KAAK,GAAGZ,gBAAgB,CAACQ,eAAe,CAAC;EAC/C;EACA,IAAIK,IAAI,GAAGV,GAAG;EACd;EACA,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IACzBU,IAAI,GAAG,MAAMD,KAAK,CAACT,GAAG,CAAC;IACvB;EACJ;EACA,IAAIL,MAAM,CAACK,GAAG,CAAC,EAAE;IACb;IACA;IACAU,IAAI,GAAG,MAAMD,KAAK,CAACT,GAAG,CAAC;EAC3B;EACA;EACA;EACA,OAAOM,KAAK,CAACC,OAAO,CAACH,eAAe,CAAC,GAC/B,MAAMN,KAAK,CAACY,IAAI,EAAEN,eAAe,EAAEC,eAAe,CAAC,CAAC;EAAA,EACpD,MAAMP,KAAK,CAACY,IAAI,EAAEN,eAAe,EAAEC,eAAe,CAAC,CAAC,CAAC;AAC/D","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}