{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { CompositeLayer, AttributeManager } from '@deck.gl/core';\nclass AggregationLayer extends CompositeLayer {\n  /** Allow this layer to participates in the draw cycle */\n  get isDrawable() {\n    return true;\n  }\n  initializeState() {\n    this.getAttributeManager().remove(['instancePickingColors']);\n  }\n  // Extend Layer.updateState to update the Aggregator instance\n  // returns true if aggregator is changed\n  updateState(params) {\n    super.updateState(params);\n    const aggregatorType = this.getAggregatorType();\n    if (params.changeFlags.extensionsChanged || this.state.aggregatorType !== aggregatorType) {\n      this.state.aggregator?.destroy();\n      const aggregator = this.createAggregator(aggregatorType);\n      aggregator.setProps({\n        attributes: this.getAttributeManager()?.attributes\n      });\n      this.setState({\n        aggregator,\n        aggregatorType\n      });\n      return true;\n    }\n    return false;\n  }\n  // Override Layer.finalizeState to dispose the Aggregator instance\n  finalizeState(context) {\n    super.finalizeState(context);\n    this.state.aggregator.destroy();\n  }\n  // Override Layer.updateAttributes to update the aggregator\n  updateAttributes(changedAttributes) {\n    const {\n      aggregator\n    } = this.state;\n    aggregator.setProps({\n      attributes: changedAttributes\n    });\n    for (const id in changedAttributes) {\n      this.onAttributeChange(id);\n    }\n    // In aggregator.update() the aggregator allocates the buffers to store its output\n    // These buffers will be exposed by aggregator.getResults() and passed to the sublayers\n    // Therefore update() must be called before renderLayers()\n    // CPUAggregator's output is populated right here in update()\n    // GPUAggregator's output is pre-allocated and populated in preDraw(), see comments below\n    aggregator.update();\n  }\n  draw({\n    shaderModuleProps\n  }) {\n    // GPU aggregation needs `shaderModuleProps` for projection/filter uniforms which are only accessible at draw time\n    // GPUAggregator's Buffers are pre-allocated during `update()` and passed down to the sublayer attributes in renderLayers()\n    // Although the Buffers have been bound to the sublayer's Model, their content are not populated yet\n    // GPUAggregator.preDraw() is called in the draw cycle here right before Buffers are used by sublayer.draw()\n    const {\n      aggregator\n    } = this.state;\n    // @ts-expect-error only used by GPU aggregators\n    aggregator.setProps({\n      shaderModuleProps\n    });\n    aggregator.preDraw();\n  }\n  // override CompositeLayer._getAttributeManager to create AttributeManager instance\n  _getAttributeManager() {\n    return new AttributeManager(this.context.device, {\n      id: this.props.id,\n      stats: this.context.stats\n    });\n  }\n}\nAggregationLayer.layerName = 'AggregationLayer';\nexport default AggregationLayer;","map":{"version":3,"names":["CompositeLayer","AttributeManager","AggregationLayer","isDrawable","initializeState","getAttributeManager","remove","updateState","params","aggregatorType","getAggregatorType","changeFlags","extensionsChanged","state","aggregator","destroy","createAggregator","setProps","attributes","setState","finalizeState","context","updateAttributes","changedAttributes","id","onAttributeChange","update","draw","shaderModuleProps","preDraw","_getAttributeManager","device","props","stats","layerName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\aggregation-layers\\src\\common\\aggregation-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  CompositeLayer,\n  LayerDataSource,\n  LayerContext,\n  UpdateParameters,\n  CompositeLayerProps,\n  Attribute,\n  AttributeManager\n} from '@deck.gl/core';\nimport {Aggregator} from './aggregator/aggregator';\n\nexport type AggregationLayerProps<DataT> = CompositeLayerProps & {\n  data: LayerDataSource<DataT>;\n};\n\nexport default abstract class AggregationLayer<\n  DataT,\n  ExtraPropsT extends {} = {}\n> extends CompositeLayer<Required<AggregationLayer<DataT>> & ExtraPropsT> {\n  static layerName = 'AggregationLayer';\n\n  state!: {\n    aggregatorType: string;\n    aggregator: Aggregator;\n  };\n\n  /** Allow this layer to participates in the draw cycle */\n  get isDrawable() {\n    return true;\n  }\n\n  abstract getAggregatorType(): string;\n  /** Called to create an Aggregator instance */\n  abstract createAggregator(type: string): Aggregator;\n  /** Called when some attributes change, a chance to mark Aggregator as dirty */\n  abstract onAttributeChange(id: string): void;\n\n  initializeState(): void {\n    this.getAttributeManager()!.remove(['instancePickingColors']);\n  }\n\n  // Extend Layer.updateState to update the Aggregator instance\n  // returns true if aggregator is changed\n  updateState(params: UpdateParameters<this>): boolean {\n    super.updateState(params);\n\n    const aggregatorType = this.getAggregatorType();\n    if (params.changeFlags.extensionsChanged || this.state.aggregatorType !== aggregatorType) {\n      this.state.aggregator?.destroy();\n      const aggregator = this.createAggregator(aggregatorType);\n      aggregator.setProps({\n        attributes: this.getAttributeManager()?.attributes\n      });\n      this.setState({aggregator, aggregatorType});\n      return true;\n    }\n    return false;\n  }\n\n  // Override Layer.finalizeState to dispose the Aggregator instance\n  finalizeState(context: LayerContext) {\n    super.finalizeState(context);\n    this.state.aggregator.destroy();\n  }\n\n  // Override Layer.updateAttributes to update the aggregator\n  protected updateAttributes(changedAttributes: {[id: string]: Attribute}) {\n    const {aggregator} = this.state;\n    aggregator.setProps({\n      attributes: changedAttributes\n    });\n\n    for (const id in changedAttributes) {\n      this.onAttributeChange(id);\n    }\n\n    // In aggregator.update() the aggregator allocates the buffers to store its output\n    // These buffers will be exposed by aggregator.getResults() and passed to the sublayers\n    // Therefore update() must be called before renderLayers()\n    // CPUAggregator's output is populated right here in update()\n    // GPUAggregator's output is pre-allocated and populated in preDraw(), see comments below\n    aggregator.update();\n  }\n\n  draw({shaderModuleProps}) {\n    // GPU aggregation needs `shaderModuleProps` for projection/filter uniforms which are only accessible at draw time\n    // GPUAggregator's Buffers are pre-allocated during `update()` and passed down to the sublayer attributes in renderLayers()\n    // Although the Buffers have been bound to the sublayer's Model, their content are not populated yet\n    // GPUAggregator.preDraw() is called in the draw cycle here right before Buffers are used by sublayer.draw()\n    const {aggregator} = this.state;\n    // @ts-expect-error only used by GPU aggregators\n    aggregator.setProps({shaderModuleProps});\n    aggregator.preDraw();\n  }\n\n  // override CompositeLayer._getAttributeManager to create AttributeManager instance\n  _getAttributeManager() {\n    return new AttributeManager(this.context.device, {\n      id: this.props.id,\n      stats: this.context.stats\n    });\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA,SACEA,cAAc,EAMdC,gBAAgB,QACX,eAAe;AAOtB,MAA8BC,gBAG5B,SAAQF,cAA+D;EAQvE;EACA,IAAIG,UAAUA,CAAA;IACZ,OAAO,IAAI;EACb;EAQAC,eAAeA,CAAA;IACb,IAAI,CAACC,mBAAmB,EAAG,CAACC,MAAM,CAAC,CAAC,uBAAuB,CAAC,CAAC;EAC/D;EAEA;EACA;EACAC,WAAWA,CAACC,MAA8B;IACxC,KAAK,CAACD,WAAW,CAACC,MAAM,CAAC;IAEzB,MAAMC,cAAc,GAAG,IAAI,CAACC,iBAAiB,EAAE;IAC/C,IAAIF,MAAM,CAACG,WAAW,CAACC,iBAAiB,IAAI,IAAI,CAACC,KAAK,CAACJ,cAAc,KAAKA,cAAc,EAAE;MACxF,IAAI,CAACI,KAAK,CAACC,UAAU,EAAEC,OAAO,EAAE;MAChC,MAAMD,UAAU,GAAG,IAAI,CAACE,gBAAgB,CAACP,cAAc,CAAC;MACxDK,UAAU,CAACG,QAAQ,CAAC;QAClBC,UAAU,EAAE,IAAI,CAACb,mBAAmB,EAAE,EAAEa;OACzC,CAAC;MACF,IAAI,CAACC,QAAQ,CAAC;QAACL,UAAU;QAAEL;MAAc,CAAC,CAAC;MAC3C,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;EAEA;EACAW,aAAaA,CAACC,OAAqB;IACjC,KAAK,CAACD,aAAa,CAACC,OAAO,CAAC;IAC5B,IAAI,CAACR,KAAK,CAACC,UAAU,CAACC,OAAO,EAAE;EACjC;EAEA;EACUO,gBAAgBA,CAACC,iBAA4C;IACrE,MAAM;MAACT;IAAU,CAAC,GAAG,IAAI,CAACD,KAAK;IAC/BC,UAAU,CAACG,QAAQ,CAAC;MAClBC,UAAU,EAAEK;KACb,CAAC;IAEF,KAAK,MAAMC,EAAE,IAAID,iBAAiB,EAAE;MAClC,IAAI,CAACE,iBAAiB,CAACD,EAAE,CAAC;IAC5B;IAEA;IACA;IACA;IACA;IACA;IACAV,UAAU,CAACY,MAAM,EAAE;EACrB;EAEAC,IAAIA,CAAC;IAACC;EAAiB,CAAC;IACtB;IACA;IACA;IACA;IACA,MAAM;MAACd;IAAU,CAAC,GAAG,IAAI,CAACD,KAAK;IAC/B;IACAC,UAAU,CAACG,QAAQ,CAAC;MAACW;IAAiB,CAAC,CAAC;IACxCd,UAAU,CAACe,OAAO,EAAE;EACtB;EAEA;EACAC,oBAAoBA,CAAA;IAClB,OAAO,IAAI7B,gBAAgB,CAAC,IAAI,CAACoB,OAAO,CAACU,MAAM,EAAE;MAC/CP,EAAE,EAAE,IAAI,CAACQ,KAAK,CAACR,EAAE;MACjBS,KAAK,EAAE,IAAI,CAACZ,OAAO,CAACY;KACrB,CAAC;EACJ;;AAlFO/B,gBAAA,CAAAgC,SAAS,GAAG,kBAAkB;eAJThC,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}