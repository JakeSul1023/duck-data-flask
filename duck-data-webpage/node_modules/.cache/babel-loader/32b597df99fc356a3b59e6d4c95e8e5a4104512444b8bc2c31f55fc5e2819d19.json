{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { cellToBoundary, cellToLatLng } from 'h3-js';\nimport { lerp } from '@math.gl/core';\n// normalize longitudes w.r.t center (refLng), when not provided first vertex\nexport function normalizeLongitudes(vertices, refLng) {\n  refLng = refLng === undefined ? vertices[0][0] : refLng;\n  for (const pt of vertices) {\n    const deltaLng = pt[0] - refLng;\n    if (deltaLng > 180) {\n      pt[0] -= 360;\n    } else if (deltaLng < -180) {\n      pt[0] += 360;\n    }\n  }\n}\n// scale polygon vertices w.r.t center (hexId)\nexport function scalePolygon(hexId, vertices, factor) {\n  const [lat, lng] = cellToLatLng(hexId);\n  const actualCount = vertices.length;\n  // normalize with respect to center\n  normalizeLongitudes(vertices, lng);\n  // `cellToBoundary` returns same array object for first and last vertex (closed polygon),\n  // if so skip scaling the last vertex\n  const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;\n  for (let i = 0; i < vertexCount; i++) {\n    vertices[i][0] = lerp(lng, vertices[i][0], factor);\n    vertices[i][1] = lerp(lat, vertices[i][1], factor);\n  }\n}\n// gets hexagon centroid\nexport function getHexagonCentroid(getHexagon, object, objectInfo) {\n  const hexagonId = getHexagon(object, objectInfo);\n  const [lat, lng] = cellToLatLng(hexagonId);\n  return [lng, lat];\n}\nexport function h3ToPolygon(hexId, coverage = 1) {\n  const vertices = cellToBoundary(hexId, true);\n  if (coverage !== 1) {\n    // scale and normalize vertices w.r.t to center\n    scalePolygon(hexId, vertices, coverage);\n  } else {\n    // normalize w.r.t to start vertex\n    normalizeLongitudes(vertices);\n  }\n  return vertices;\n}\nexport function flattenPolygon(vertices) {\n  const positions = new Float64Array(vertices.length * 2);\n  let i = 0;\n  for (const pt of vertices) {\n    positions[i++] = pt[0];\n    positions[i++] = pt[1];\n  }\n  return positions;\n}","map":{"version":3,"names":["cellToBoundary","cellToLatLng","lerp","normalizeLongitudes","vertices","refLng","undefined","pt","deltaLng","scalePolygon","hexId","factor","lat","lng","actualCount","length","vertexCount","i","getHexagonCentroid","getHexagon","object","objectInfo","hexagonId","h3ToPolygon","coverage","flattenPolygon","positions","Float64Array"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\geo-layers\\src\\h3-layers\\h3-utils.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {CoordPair, H3IndexInput, cellToBoundary, cellToLatLng} from 'h3-js';\nimport {lerp} from '@math.gl/core';\n\n// normalize longitudes w.r.t center (refLng), when not provided first vertex\nexport function normalizeLongitudes(vertices: CoordPair[], refLng?: number): void {\n  refLng = refLng === undefined ? vertices[0][0] : refLng;\n  for (const pt of vertices) {\n    const deltaLng = pt[0] - refLng;\n    if (deltaLng > 180) {\n      pt[0] -= 360;\n    } else if (deltaLng < -180) {\n      pt[0] += 360;\n    }\n  }\n}\n\n// scale polygon vertices w.r.t center (hexId)\nexport function scalePolygon(hexId: H3IndexInput, vertices: CoordPair[], factor: number): void {\n  const [lat, lng] = cellToLatLng(hexId);\n  const actualCount = vertices.length;\n\n  // normalize with respect to center\n  normalizeLongitudes(vertices, lng);\n\n  // `cellToBoundary` returns same array object for first and last vertex (closed polygon),\n  // if so skip scaling the last vertex\n  const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;\n  for (let i = 0; i < vertexCount; i++) {\n    vertices[i][0] = lerp(lng, vertices[i][0], factor);\n    vertices[i][1] = lerp(lat, vertices[i][1], factor);\n  }\n}\n\n// gets hexagon centroid\nexport function getHexagonCentroid(getHexagon, object, objectInfo) {\n  const hexagonId = getHexagon(object, objectInfo);\n  const [lat, lng] = cellToLatLng(hexagonId);\n  return [lng, lat];\n}\n\nexport function h3ToPolygon(hexId: H3IndexInput, coverage: number = 1): number[][] {\n  const vertices = cellToBoundary(hexId, true);\n\n  if (coverage !== 1) {\n    // scale and normalize vertices w.r.t to center\n    scalePolygon(hexId, vertices, coverage);\n  } else {\n    // normalize w.r.t to start vertex\n    normalizeLongitudes(vertices);\n  }\n\n  return vertices;\n}\n\nexport function flattenPolygon(vertices: number[][]): Float64Array {\n  const positions = new Float64Array(vertices.length * 2);\n  let i = 0;\n  for (const pt of vertices) {\n    positions[i++] = pt[0];\n    positions[i++] = pt[1];\n  }\n  return positions;\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA,SAAiCA,cAAc,EAAEC,YAAY,QAAO,OAAO;AAC3E,SAAQC,IAAI,QAAO,eAAe;AAElC;AACA,OAAM,SAAUC,mBAAmBA,CAACC,QAAqB,EAAEC,MAAe;EACxEA,MAAM,GAAGA,MAAM,KAAKC,SAAS,GAAGF,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGC,MAAM;EACvD,KAAK,MAAME,EAAE,IAAIH,QAAQ,EAAE;IACzB,MAAMI,QAAQ,GAAGD,EAAE,CAAC,CAAC,CAAC,GAAGF,MAAM;IAC/B,IAAIG,QAAQ,GAAG,GAAG,EAAE;MAClBD,EAAE,CAAC,CAAC,CAAC,IAAI,GAAG;IACd,CAAC,MAAM,IAAIC,QAAQ,GAAG,CAAC,GAAG,EAAE;MAC1BD,EAAE,CAAC,CAAC,CAAC,IAAI,GAAG;IACd;EACF;AACF;AAEA;AACA,OAAM,SAAUE,YAAYA,CAACC,KAAmB,EAAEN,QAAqB,EAAEO,MAAc;EACrF,MAAM,CAACC,GAAG,EAAEC,GAAG,CAAC,GAAGZ,YAAY,CAACS,KAAK,CAAC;EACtC,MAAMI,WAAW,GAAGV,QAAQ,CAACW,MAAM;EAEnC;EACAZ,mBAAmB,CAACC,QAAQ,EAAES,GAAG,CAAC;EAElC;EACA;EACA,MAAMG,WAAW,GAAGZ,QAAQ,CAAC,CAAC,CAAC,KAAKA,QAAQ,CAACU,WAAW,GAAG,CAAC,CAAC,GAAGA,WAAW,GAAG,CAAC,GAAGA,WAAW;EAC7F,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,WAAW,EAAEC,CAAC,EAAE,EAAE;IACpCb,QAAQ,CAACa,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGf,IAAI,CAACW,GAAG,EAAET,QAAQ,CAACa,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEN,MAAM,CAAC;IAClDP,QAAQ,CAACa,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGf,IAAI,CAACU,GAAG,EAAER,QAAQ,CAACa,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEN,MAAM,CAAC;EACpD;AACF;AAEA;AACA,OAAM,SAAUO,kBAAkBA,CAACC,UAAU,EAAEC,MAAM,EAAEC,UAAU;EAC/D,MAAMC,SAAS,GAAGH,UAAU,CAACC,MAAM,EAAEC,UAAU,CAAC;EAChD,MAAM,CAACT,GAAG,EAAEC,GAAG,CAAC,GAAGZ,YAAY,CAACqB,SAAS,CAAC;EAC1C,OAAO,CAACT,GAAG,EAAED,GAAG,CAAC;AACnB;AAEA,OAAM,SAAUW,WAAWA,CAACb,KAAmB,EAAEc,QAAA,GAAmB,CAAC;EACnE,MAAMpB,QAAQ,GAAGJ,cAAc,CAACU,KAAK,EAAE,IAAI,CAAC;EAE5C,IAAIc,QAAQ,KAAK,CAAC,EAAE;IAClB;IACAf,YAAY,CAACC,KAAK,EAAEN,QAAQ,EAAEoB,QAAQ,CAAC;EACzC,CAAC,MAAM;IACL;IACArB,mBAAmB,CAACC,QAAQ,CAAC;EAC/B;EAEA,OAAOA,QAAQ;AACjB;AAEA,OAAM,SAAUqB,cAAcA,CAACrB,QAAoB;EACjD,MAAMsB,SAAS,GAAG,IAAIC,YAAY,CAACvB,QAAQ,CAACW,MAAM,GAAG,CAAC,CAAC;EACvD,IAAIE,CAAC,GAAG,CAAC;EACT,KAAK,MAAMV,EAAE,IAAIH,QAAQ,EAAE;IACzBsB,SAAS,CAACT,CAAC,EAAE,CAAC,GAAGV,EAAE,CAAC,CAAC,CAAC;IACtBmB,SAAS,CAACT,CAAC,EAAE,CAAC,GAAGV,EAAE,CAAC,CAAC,CAAC;EACxB;EACA,OAAOmB,SAAS;AAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}