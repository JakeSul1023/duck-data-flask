{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Layer, project32, picking, UNIT } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/engine';\nimport { gouraudMaterial } from '@luma.gl/shadertools';\nimport { pointCloudUniforms } from \"./point-cloud-layer-uniforms.js\";\nimport vs from \"./point-cloud-layer-vertex.glsl.js\";\nimport fs from \"./point-cloud-layer-fragment.glsl.js\";\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst DEFAULT_NORMAL = [0, 0, 1];\nconst defaultProps = {\n  sizeUnits: 'pixels',\n  pointSize: {\n    type: 'number',\n    min: 0,\n    value: 10\n  },\n  //  point radius in pixels\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getNormal: {\n    type: 'accessor',\n    value: DEFAULT_NORMAL\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  material: true,\n  // Depreated\n  radiusPixels: {\n    deprecatedFor: 'pointSize'\n  }\n};\n// support loaders.gl point cloud format\nfunction normalizeData(data) {\n  const {\n    header,\n    attributes\n  } = data;\n  if (!header || !attributes) {\n    return;\n  }\n  data.length = header.vertexCount;\n  if (attributes.POSITION) {\n    attributes.instancePositions = attributes.POSITION;\n  }\n  if (attributes.NORMAL) {\n    attributes.instanceNormals = attributes.NORMAL;\n  }\n  if (attributes.COLOR_0) {\n    const {\n      size,\n      value\n    } = attributes.COLOR_0;\n    attributes.instanceColors = {\n      size,\n      type: 'unorm8',\n      value\n    };\n  }\n}\n/** Render a point cloud with 3D positions, normals and colors. */\nclass PointCloudLayer extends Layer {\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, gouraudMaterial, picking, pointCloudUniforms]\n    });\n  }\n  initializeState() {\n    this.getAttributeManager().addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 'float64',\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceNormals: {\n        size: 3,\n        transition: true,\n        accessor: 'getNormal',\n        defaultValue: DEFAULT_NORMAL\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: 'unorm8',\n        transition: true,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR\n      }\n    });\n  }\n  updateState(params) {\n    const {\n      changeFlags,\n      props\n    } = params;\n    super.updateState(params);\n    if (changeFlags.extensionsChanged) {\n      this.state.model?.destroy();\n      this.state.model = this._getModel();\n      this.getAttributeManager().invalidateAll();\n    }\n    if (changeFlags.dataChanged) {\n      normalizeData(props.data);\n    }\n  }\n  draw({\n    uniforms\n  }) {\n    const {\n      pointSize,\n      sizeUnits\n    } = this.props;\n    const model = this.state.model;\n    const pointCloudProps = {\n      sizeUnits: UNIT[sizeUnits],\n      radiusPixels: pointSize\n    };\n    model.shaderInputs.setProps({\n      pointCloud: pointCloudProps\n    });\n    model.draw(this.context.renderPass);\n  }\n  _getModel() {\n    // a triangle that minimally cover the unit circle\n    const positions = [];\n    for (let i = 0; i < 3; i++) {\n      const angle = i / 3 * Math.PI * 2;\n      positions.push(Math.cos(angle) * 2, Math.sin(angle) * 2, 0);\n    }\n    return new Model(this.context.device, {\n      ...this.getShaders(),\n      id: this.props.id,\n      bufferLayout: this.getAttributeManager().getBufferLayouts(),\n      geometry: new Geometry({\n        topology: 'triangle-list',\n        attributes: {\n          positions: new Float32Array(positions)\n        }\n      }),\n      isInstanced: true\n    });\n  }\n}\nPointCloudLayer.layerName = 'PointCloudLayer';\nPointCloudLayer.defaultProps = defaultProps;\nexport default PointCloudLayer;","map":{"version":3,"names":["Layer","project32","picking","UNIT","Model","Geometry","gouraudMaterial","pointCloudUniforms","vs","fs","DEFAULT_COLOR","DEFAULT_NORMAL","defaultProps","sizeUnits","pointSize","type","min","value","getPosition","x","position","getNormal","getColor","material","radiusPixels","deprecatedFor","normalizeData","data","header","attributes","length","vertexCount","POSITION","instancePositions","NORMAL","instanceNormals","COLOR_0","size","instanceColors","PointCloudLayer","getShaders","modules","initializeState","getAttributeManager","addInstanced","fp64","use64bitPositions","transition","accessor","defaultValue","props","colorFormat","updateState","params","changeFlags","extensionsChanged","state","model","destroy","_getModel","invalidateAll","dataChanged","draw","uniforms","pointCloudProps","shaderInputs","setProps","pointCloud","context","renderPass","positions","i","angle","Math","PI","push","cos","sin","device","id","bufferLayout","getBufferLayouts","geometry","topology","Float32Array","isInstanced","layerName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\layers\\src\\point-cloud-layer\\point-cloud-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  Layer,\n  project32,\n  picking,\n  UNIT,\n  LayerProps,\n  LayerDataSource,\n  UpdateParameters,\n  Unit,\n  AccessorFunction,\n  Position,\n  Accessor,\n  Color,\n  Material,\n  DefaultProps\n} from '@deck.gl/core';\nimport {Model, Geometry} from '@luma.gl/engine';\nimport {gouraudMaterial} from '@luma.gl/shadertools';\n\nimport {pointCloudUniforms, PointCloudProps} from './point-cloud-layer-uniforms';\nimport vs from './point-cloud-layer-vertex.glsl';\nimport fs from './point-cloud-layer-fragment.glsl';\n\nconst DEFAULT_COLOR: [number, number, number, number] = [0, 0, 0, 255];\nconst DEFAULT_NORMAL: [number, number, number] = [0, 0, 1];\n\nconst defaultProps: DefaultProps<PointCloudLayerProps> = {\n  sizeUnits: 'pixels',\n  pointSize: {type: 'number', min: 0, value: 10}, //  point radius in pixels\n\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\n  getNormal: {type: 'accessor', value: DEFAULT_NORMAL},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n\n  material: true,\n\n  // Depreated\n  radiusPixels: {deprecatedFor: 'pointSize'}\n};\n\n// support loaders.gl point cloud format\nfunction normalizeData(data) {\n  const {header, attributes} = data;\n  if (!header || !attributes) {\n    return;\n  }\n\n  data.length = header.vertexCount;\n\n  if (attributes.POSITION) {\n    attributes.instancePositions = attributes.POSITION;\n  }\n  if (attributes.NORMAL) {\n    attributes.instanceNormals = attributes.NORMAL;\n  }\n  if (attributes.COLOR_0) {\n    const {size, value} = attributes.COLOR_0;\n    attributes.instanceColors = {size, type: 'unorm8', value};\n  }\n}\n\n/** All properties supported by PointCloudLayer. */\nexport type PointCloudLayerProps<DataT = unknown> = _PointCloudLayerProps<DataT> & LayerProps;\n\n/** Properties added by PointCloudLayer. */\ntype _PointCloudLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  /**\n   * The units of the point size, one of `'meters'`, `'common'`, and `'pixels'`.\n   * @default 'pixels'\n   */\n  sizeUnits?: Unit;\n\n  /**\n   * Global radius of all points, in units specified by `sizeUnits`\n   * @default 10\n   */\n  pointSize?: number;\n\n  /**\n   * @deprecated Use `pointSize` instead\n   */\n  radiusPixels?: number;\n\n  /**\n   * Material settings for lighting effect.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: AccessorFunction<DataT, Position>;\n\n  /**\n   * The normal of each object, in `[nx, ny, nz]`.\n   * @default [0, 0, 1]\n   */\n  getNormal?: Accessor<DataT, [number, number, number]>;\n\n  /**\n   * The rgba color is in the format of `[r, g, b, [a]]`\n   * @default [0, 0, 0, 255]\n   */\n  getColor?: Accessor<DataT, Color>;\n};\n\n/** Render a point cloud with 3D positions, normals and colors. */\nexport default class PointCloudLayer<DataT = any, ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_PointCloudLayerProps<DataT>>\n> {\n  static layerName = 'PointCloudLayer';\n  static defaultProps = defaultProps;\n\n  state!: {\n    model?: Model;\n  };\n\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, gouraudMaterial, picking, pointCloudUniforms]\n    });\n  }\n\n  initializeState() {\n    this.getAttributeManager()!.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 'float64',\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceNormals: {\n        size: 3,\n        transition: true,\n        accessor: 'getNormal',\n        defaultValue: DEFAULT_NORMAL\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: 'unorm8',\n        transition: true,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR\n      }\n    });\n  }\n\n  updateState(params: UpdateParameters<this>): void {\n    const {changeFlags, props} = params;\n    super.updateState(params);\n    if (changeFlags.extensionsChanged) {\n      this.state.model?.destroy();\n      this.state.model = this._getModel();\n      this.getAttributeManager()!.invalidateAll();\n    }\n    if (changeFlags.dataChanged) {\n      normalizeData(props.data);\n    }\n  }\n\n  draw({uniforms}) {\n    const {pointSize, sizeUnits} = this.props;\n    const model = this.state.model!;\n    const pointCloudProps: PointCloudProps = {\n      sizeUnits: UNIT[sizeUnits],\n      radiusPixels: pointSize\n    };\n    model.shaderInputs.setProps({pointCloud: pointCloudProps});\n    model.draw(this.context.renderPass);\n  }\n\n  protected _getModel(): Model {\n    // a triangle that minimally cover the unit circle\n    const positions: number[] = [];\n    for (let i = 0; i < 3; i++) {\n      const angle = (i / 3) * Math.PI * 2;\n      positions.push(Math.cos(angle) * 2, Math.sin(angle) * 2, 0);\n    }\n\n    return new Model(this.context.device, {\n      ...this.getShaders(),\n      id: this.props.id,\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts(),\n      geometry: new Geometry({\n        topology: 'triangle-list',\n        attributes: {\n          positions: new Float32Array(positions)\n        }\n      }),\n      isInstanced: true\n    });\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA,SACEA,KAAK,EACLC,SAAS,EACTC,OAAO,EACPC,IAAI,QAWC,eAAe;AACtB,SAAQC,KAAK,EAAEC,QAAQ,QAAO,iBAAiB;AAC/C,SAAQC,eAAe,QAAO,sBAAsB;AAEpD,SAAQC,kBAAkB,QAAkB;AAC5C,OAAOC,EAAE;AACT,OAAOC,EAAE;AAET,MAAMC,aAAa,GAAqC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC;AACtE,MAAMC,cAAc,GAA6B,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AAE1D,MAAMC,YAAY,GAAuC;EACvDC,SAAS,EAAE,QAAQ;EACnBC,SAAS,EAAE;IAACC,IAAI,EAAE,QAAQ;IAAEC,GAAG,EAAE,CAAC;IAAEC,KAAK,EAAE;EAAE,CAAC;EAAE;EAEhDC,WAAW,EAAE;IAACH,IAAI,EAAE,UAAU;IAAEE,KAAK,EAAGE,CAAM,IAAKA,CAAC,CAACC;EAAQ,CAAC;EAC9DC,SAAS,EAAE;IAACN,IAAI,EAAE,UAAU;IAAEE,KAAK,EAAEN;EAAc,CAAC;EACpDW,QAAQ,EAAE;IAACP,IAAI,EAAE,UAAU;IAAEE,KAAK,EAAEP;EAAa,CAAC;EAElDa,QAAQ,EAAE,IAAI;EAEd;EACAC,YAAY,EAAE;IAACC,aAAa,EAAE;EAAW;CAC1C;AAED;AACA,SAASC,aAAaA,CAACC,IAAI;EACzB,MAAM;IAACC,MAAM;IAAEC;EAAU,CAAC,GAAGF,IAAI;EACjC,IAAI,CAACC,MAAM,IAAI,CAACC,UAAU,EAAE;IAC1B;EACF;EAEAF,IAAI,CAACG,MAAM,GAAGF,MAAM,CAACG,WAAW;EAEhC,IAAIF,UAAU,CAACG,QAAQ,EAAE;IACvBH,UAAU,CAACI,iBAAiB,GAAGJ,UAAU,CAACG,QAAQ;EACpD;EACA,IAAIH,UAAU,CAACK,MAAM,EAAE;IACrBL,UAAU,CAACM,eAAe,GAAGN,UAAU,CAACK,MAAM;EAChD;EACA,IAAIL,UAAU,CAACO,OAAO,EAAE;IACtB,MAAM;MAACC,IAAI;MAAEpB;IAAK,CAAC,GAAGY,UAAU,CAACO,OAAO;IACxCP,UAAU,CAACS,cAAc,GAAG;MAACD,IAAI;MAAEtB,IAAI,EAAE,QAAQ;MAAEE;IAAK,CAAC;EAC3D;AACF;AAoDA;AACA,MAAqBsB,eAA0D,SAAQvC,KAEtF;EAQCwC,UAAUA,CAAA;IACR,OAAO,KAAK,CAACA,UAAU,CAAC;MACtBhC,EAAE;MACFC,EAAE;MACFgC,OAAO,EAAE,CAACxC,SAAS,EAAEK,eAAe,EAAEJ,OAAO,EAAEK,kBAAkB;KAClE,CAAC;EACJ;EAEAmC,eAAeA,CAAA;IACb,IAAI,CAACC,mBAAmB,EAAG,CAACC,YAAY,CAAC;MACvCX,iBAAiB,EAAE;QACjBI,IAAI,EAAE,CAAC;QACPtB,IAAI,EAAE,SAAS;QACf8B,IAAI,EAAE,IAAI,CAACC,iBAAiB,EAAE;QAC9BC,UAAU,EAAE,IAAI;QAChBC,QAAQ,EAAE;OACX;MACDb,eAAe,EAAE;QACfE,IAAI,EAAE,CAAC;QACPU,UAAU,EAAE,IAAI;QAChBC,QAAQ,EAAE,WAAW;QACrBC,YAAY,EAAEtC;OACf;MACD2B,cAAc,EAAE;QACdD,IAAI,EAAE,IAAI,CAACa,KAAK,CAACC,WAAW,CAACrB,MAAM;QACnCf,IAAI,EAAE,QAAQ;QACdgC,UAAU,EAAE,IAAI;QAChBC,QAAQ,EAAE,UAAU;QACpBC,YAAY,EAAEvC;;KAEjB,CAAC;EACJ;EAEA0C,WAAWA,CAACC,MAA8B;IACxC,MAAM;MAACC,WAAW;MAAEJ;IAAK,CAAC,GAAGG,MAAM;IACnC,KAAK,CAACD,WAAW,CAACC,MAAM,CAAC;IACzB,IAAIC,WAAW,CAACC,iBAAiB,EAAE;MACjC,IAAI,CAACC,KAAK,CAACC,KAAK,EAAEC,OAAO,EAAE;MAC3B,IAAI,CAACF,KAAK,CAACC,KAAK,GAAG,IAAI,CAACE,SAAS,EAAE;MACnC,IAAI,CAAChB,mBAAmB,EAAG,CAACiB,aAAa,EAAE;IAC7C;IACA,IAAIN,WAAW,CAACO,WAAW,EAAE;MAC3BnC,aAAa,CAACwB,KAAK,CAACvB,IAAI,CAAC;IAC3B;EACF;EAEAmC,IAAIA,CAAC;IAACC;EAAQ,CAAC;IACb,MAAM;MAACjD,SAAS;MAAED;IAAS,CAAC,GAAG,IAAI,CAACqC,KAAK;IACzC,MAAMO,KAAK,GAAG,IAAI,CAACD,KAAK,CAACC,KAAM;IAC/B,MAAMO,eAAe,GAAoB;MACvCnD,SAAS,EAAEV,IAAI,CAACU,SAAS,CAAC;MAC1BW,YAAY,EAAEV;KACf;IACD2C,KAAK,CAACQ,YAAY,CAACC,QAAQ,CAAC;MAACC,UAAU,EAAEH;IAAe,CAAC,CAAC;IAC1DP,KAAK,CAACK,IAAI,CAAC,IAAI,CAACM,OAAO,CAACC,UAAU,CAAC;EACrC;EAEUV,SAASA,CAAA;IACjB;IACA,MAAMW,SAAS,GAAa,EAAE;IAC9B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC1B,MAAMC,KAAK,GAAID,CAAC,GAAG,CAAC,GAAIE,IAAI,CAACC,EAAE,GAAG,CAAC;MACnCJ,SAAS,CAACK,IAAI,CAACF,IAAI,CAACG,GAAG,CAACJ,KAAK,CAAC,GAAG,CAAC,EAAEC,IAAI,CAACI,GAAG,CAACL,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;IAC7D;IAEA,OAAO,IAAIpE,KAAK,CAAC,IAAI,CAACgE,OAAO,CAACU,MAAM,EAAE;MACpC,GAAG,IAAI,CAACtC,UAAU,EAAE;MACpBuC,EAAE,EAAE,IAAI,CAAC7B,KAAK,CAAC6B,EAAE;MACjBC,YAAY,EAAE,IAAI,CAACrC,mBAAmB,EAAG,CAACsC,gBAAgB,EAAE;MAC5DC,QAAQ,EAAE,IAAI7E,QAAQ,CAAC;QACrB8E,QAAQ,EAAE,eAAe;QACzBtD,UAAU,EAAE;UACVyC,SAAS,EAAE,IAAIc,YAAY,CAACd,SAAS;;OAExC,CAAC;MACFe,WAAW,EAAE;KACd,CAAC;EACJ;;AApFO9C,eAAA,CAAA+C,SAAS,GAAG,iBAAiB;AAC7B/C,eAAA,CAAA3B,YAAY,GAAGA,YAAY;eAJf2B,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}