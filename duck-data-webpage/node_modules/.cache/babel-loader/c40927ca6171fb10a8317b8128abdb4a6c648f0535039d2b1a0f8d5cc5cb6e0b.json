{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst DEFAULT_ROW_COUNT = 100;\nexport class ColumnarTableBatchAggregator {\n  schema;\n  length = 0;\n  allocated = 0;\n  columns = {};\n  constructor(schema, options) {\n    this.schema = schema;\n    this._reallocateColumns();\n  }\n  rowCount() {\n    return this.length;\n  }\n  addArrayRow(row) {\n    // If user keeps pushing rows beyond batch size, reallocate\n    this._reallocateColumns();\n    let i = 0;\n    // TODO what if no csv header, columns not populated?\n    for (const fieldName in this.columns) {\n      this.columns[fieldName][this.length] = row[i++];\n    }\n    this.length++;\n  }\n  addObjectRow(row) {\n    // If user keeps pushing rows beyond batch size, reallocate\n    this._reallocateColumns();\n    for (const fieldName in row) {\n      this.columns[fieldName][this.length] = row[fieldName];\n    }\n    this.length++;\n  }\n  getBatch() {\n    this._pruneColumns();\n    const columns = Array.isArray(this.schema) ? this.columns : {};\n    // schema is an array if there're no headers\n    // object if there are headers\n    // columns should match schema format\n    if (!Array.isArray(this.schema)) {\n      for (const fieldName in this.schema) {\n        const field = this.schema[fieldName];\n        columns[field.name] = this.columns[field.index];\n      }\n    }\n    this.columns = {};\n    const batch = {\n      shape: 'columnar-table',\n      batchType: 'data',\n      data: columns,\n      schema: this.schema,\n      length: this.length\n    };\n    return batch;\n  }\n  // HELPERS\n  _reallocateColumns() {\n    if (this.length < this.allocated) {\n      return;\n    }\n    // @ts-ignore TODO\n    this.allocated = this.allocated > 0 ? this.allocated *= 2 : DEFAULT_ROW_COUNT;\n    this.columns = {};\n    for (const fieldName in this.schema) {\n      const field = this.schema[fieldName];\n      const ArrayType = field.type || Float32Array;\n      const oldColumn = this.columns[field.index];\n      if (oldColumn && ArrayBuffer.isView(oldColumn)) {\n        // Copy the old data to the new array\n        const typedArray = new ArrayType(this.allocated);\n        typedArray.set(oldColumn);\n        this.columns[field.index] = typedArray;\n      } else if (oldColumn) {\n        // Plain array\n        oldColumn.length = this.allocated;\n        this.columns[field.index] = oldColumn;\n      } else {\n        // Create new\n        this.columns[field.index] = new ArrayType(this.allocated);\n      }\n    }\n  }\n  _pruneColumns() {\n    for (const [columnName, column] of Object.entries(this.columns)) {\n      this.columns[columnName] = column.slice(0, this.length);\n    }\n  }\n}","map":{"version":3,"names":["DEFAULT_ROW_COUNT","ColumnarTableBatchAggregator","schema","length","allocated","columns","constructor","options","_reallocateColumns","rowCount","addArrayRow","row","i","fieldName","addObjectRow","getBatch","_pruneColumns","Array","isArray","field","name","index","batch","shape","batchType","data","ArrayType","type","Float32Array","oldColumn","ArrayBuffer","isView","typedArray","set","columnName","column","Object","entries","slice"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/schema/dist/lib/table/batches/columnar-table-batch-aggregator.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst DEFAULT_ROW_COUNT = 100;\nexport class ColumnarTableBatchAggregator {\n    schema;\n    length = 0;\n    allocated = 0;\n    columns = {};\n    constructor(schema, options) {\n        this.schema = schema;\n        this._reallocateColumns();\n    }\n    rowCount() {\n        return this.length;\n    }\n    addArrayRow(row) {\n        // If user keeps pushing rows beyond batch size, reallocate\n        this._reallocateColumns();\n        let i = 0;\n        // TODO what if no csv header, columns not populated?\n        for (const fieldName in this.columns) {\n            this.columns[fieldName][this.length] = row[i++];\n        }\n        this.length++;\n    }\n    addObjectRow(row) {\n        // If user keeps pushing rows beyond batch size, reallocate\n        this._reallocateColumns();\n        for (const fieldName in row) {\n            this.columns[fieldName][this.length] = row[fieldName];\n        }\n        this.length++;\n    }\n    getBatch() {\n        this._pruneColumns();\n        const columns = Array.isArray(this.schema) ? this.columns : {};\n        // schema is an array if there're no headers\n        // object if there are headers\n        // columns should match schema format\n        if (!Array.isArray(this.schema)) {\n            for (const fieldName in this.schema) {\n                const field = this.schema[fieldName];\n                columns[field.name] = this.columns[field.index];\n            }\n        }\n        this.columns = {};\n        const batch = {\n            shape: 'columnar-table',\n            batchType: 'data',\n            data: columns,\n            schema: this.schema,\n            length: this.length\n        };\n        return batch;\n    }\n    // HELPERS\n    _reallocateColumns() {\n        if (this.length < this.allocated) {\n            return;\n        }\n        // @ts-ignore TODO\n        this.allocated = this.allocated > 0 ? (this.allocated *= 2) : DEFAULT_ROW_COUNT;\n        this.columns = {};\n        for (const fieldName in this.schema) {\n            const field = this.schema[fieldName];\n            const ArrayType = field.type || Float32Array;\n            const oldColumn = this.columns[field.index];\n            if (oldColumn && ArrayBuffer.isView(oldColumn)) {\n                // Copy the old data to the new array\n                const typedArray = new ArrayType(this.allocated);\n                typedArray.set(oldColumn);\n                this.columns[field.index] = typedArray;\n            }\n            else if (oldColumn) {\n                // Plain array\n                oldColumn.length = this.allocated;\n                this.columns[field.index] = oldColumn;\n            }\n            else {\n                // Create new\n                this.columns[field.index] = new ArrayType(this.allocated);\n            }\n        }\n    }\n    _pruneColumns() {\n        for (const [columnName, column] of Object.entries(this.columns)) {\n            this.columns[columnName] = column.slice(0, this.length);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}