{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Adapter, Device, log } from '@luma.gl/core';\nimport { WebGLDevice } from \"./webgl-device.js\";\nimport { enforceWebGL2 } from \"../context/polyfills/polyfill-webgl1-extensions.js\";\nimport { loadSpectorJS, DEFAULT_SPECTOR_PROPS } from \"../context/debug/spector.js\";\nimport { loadWebGLDeveloperTools } from \"../context/debug/webgl-developer-tools.js\";\nconst LOG_LEVEL = 1;\nexport class WebGLAdapter extends Adapter {\n  /** type of device's created by this adapter */\n  type = 'webgl';\n  constructor() {\n    super();\n    // Add spector default props to device default props, so that runtime settings are observed\n    Device.defaultProps = {\n      ...Device.defaultProps,\n      ...DEFAULT_SPECTOR_PROPS\n    };\n    // @ts-ignore DEPRECATED For backwards compatibility luma.registerDevices\n    WebGLDevice.adapter = this;\n  }\n  /** Check if WebGL 2 is available */\n  isSupported() {\n    return typeof WebGL2RenderingContext !== 'undefined';\n  }\n  /** Force any created WebGL contexts to be WebGL2 contexts, polyfilled with WebGL1 extensions */\n  enforceWebGL2(enable) {\n    enforceWebGL2(enable);\n  }\n  /**\n   * Get a device instance from a GL context\n   * Creates a WebGLCanvasContext against the contexts canvas\n   * @note autoResize will be disabled, assuming that whoever created the external context will be handling resizes.\n   * @param gl\n   * @returns\n   */\n  async attach(gl) {\n    if (gl instanceof WebGLDevice) {\n      return gl;\n    }\n    // @ts-expect-error\n    if (gl?.device instanceof Device) {\n      // @ts-expect-error\n      return gl.device;\n    }\n    if (!isWebGL(gl)) {\n      throw new Error('Invalid WebGL2RenderingContext');\n    }\n    // We create a new device using the provided WebGL context and its canvas\n    // Assume that whoever created the external context will be handling resizes.\n    return new WebGLDevice({\n      _handle: gl,\n      createCanvasContext: {\n        canvas: gl.canvas,\n        autoResize: false\n      }\n    });\n  }\n  async create() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    log.groupCollapsed(LOG_LEVEL, 'WebGLDevice created')();\n    const promises = [];\n    // Load webgl and spector debug scripts from CDN if requested\n    if (props.debugWebGL || props.debug) {\n      promises.push(loadWebGLDeveloperTools());\n    }\n    if (props.debugSpectorJS) {\n      promises.push(loadSpectorJS(props));\n    }\n    // Wait for all the loads to settle before creating the context.\n    // The Device.create() functions are async, so in contrast to the constructor, we can `await` here.\n    const results = await Promise.allSettled(promises);\n    for (const result of results) {\n      if (result.status === 'rejected') {\n        log.error(`Failed to initialize debug libraries ${result.reason}`)();\n      }\n    }\n    const device = new WebGLDevice(props);\n    // Log some debug info about the newly created context\n    const message = `\\\n${device._reused ? 'Reusing' : 'Created'} device with WebGL2 ${device.debug ? 'debug ' : ''}context: \\\n${device.info.vendor}, ${device.info.renderer} for canvas: ${device.canvasContext.id}`;\n    log.probe(LOG_LEVEL, message)();\n    log.table(LOG_LEVEL, device.info)();\n    log.groupEnd(LOG_LEVEL)();\n    return device;\n  }\n}\n/** Check if supplied parameter is a WebGL2RenderingContext */\nfunction isWebGL(gl) {\n  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {\n    return true;\n  }\n  // Look for debug contexts, headless gl etc\n  return Boolean(gl && Number.isFinite(gl._version));\n}\nexport const webgl2Adapter = new WebGLAdapter();\n//# sourceMappingURL=webgl-adapter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}