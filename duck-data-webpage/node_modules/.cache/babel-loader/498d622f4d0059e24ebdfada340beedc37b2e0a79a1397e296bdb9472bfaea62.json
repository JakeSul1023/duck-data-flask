{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { RequestScheduler } from '@loaders.gl/loader-utils';\nimport { Matrix4, equals } from '@math.gl/core';\nimport { Tile2DHeader } from \"./tile-2d-header.js\";\nimport { getTileIndices, tileToBoundingBox, getCullBounds } from \"./utils.js\";\nimport { memoize } from \"./memoize.js\";\n// bit masks\nconst TILE_STATE_VISITED = 1;\nconst TILE_STATE_VISIBLE = 2;\n/*\n   show cached parent tile if children are loading\n   +-----------+       +-----+            +-----+-----+\n   |           |       |     |            |     |     |\n   |           |       |     |            |     |     |\n   |           |  -->  +-----+-----+  ->  +-----+-----+\n   |           |             |     |      |     |     |\n   |           |             |     |      |     |     |\n   +-----------+             +-----+      +-----+-----+\n\n   show cached children tiles when parent is loading\n   +-------+----       +------------\n   |       |           |\n   |       |           |\n   |       |           |\n   +-------+----  -->  |\n   |       |           |\n */\nexport const STRATEGY_NEVER = 'never';\nexport const STRATEGY_REPLACE = 'no-overlap';\nexport const STRATEGY_DEFAULT = 'best-available';\nconst DEFAULT_CACHE_SCALE = 5;\nconst STRATEGIES = {\n  [STRATEGY_DEFAULT]: updateTileStateDefault,\n  [STRATEGY_REPLACE]: updateTileStateReplace,\n  [STRATEGY_NEVER]: () => {}\n};\nexport const DEFAULT_TILESET2D_PROPS = {\n  extent: null,\n  tileSize: 512,\n  maxZoom: null,\n  minZoom: null,\n  maxCacheSize: null,\n  maxCacheByteSize: null,\n  refinementStrategy: 'best-available',\n  zRange: null,\n  maxRequests: 6,\n  debounceTime: 0,\n  zoomOffset: 0,\n  // onTileLoad: (tile: Tile2DHeader) => void,  // onTileUnload: (tile: Tile2DHeader) => void,  // onTileError: (error: any, tile: Tile2DHeader) => void,  /** Called when all tiles in the current viewport are loaded. */\n  // onViewportLoad: ((tiles: Tile2DHeader<DataT>[]) => void) | null,\n  onTileLoad: () => {},\n  onTileUnload: () => {},\n  onTileError: () => {}\n};\n/**\n * Manages loading and purging of tile data. This class caches recently visited tiles\n * and only creates new tiles if they are present.\n */\nexport class Tileset2D {\n  /**\n   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.\n   * Cache size defaults to 5 * number of tiles in the current viewport\n   */\n  constructor(opts) {\n    /* Private methods */\n    this._getCullBounds = memoize(getCullBounds);\n    this.opts = {\n      ...DEFAULT_TILESET2D_PROPS,\n      ...opts\n    };\n    this.setOptions(this.opts);\n    this.onTileLoad = tile => {\n      this.opts.onTileLoad?.(tile);\n      if (this.opts.maxCacheByteSize !== null) {\n        this._cacheByteSize += tile.byteLength;\n        this._resizeCache();\n      }\n    };\n    this._requestScheduler = new RequestScheduler({\n      throttleRequests: this.opts.maxRequests > 0 || this.opts.debounceTime > 0,\n      maxRequests: this.opts.maxRequests,\n      debounceTime: this.opts.debounceTime\n    });\n    // Maps tile id in string {z}-{x}-{y} to a Tile object\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n    // Cache the last processed viewport\n    this._viewport = null;\n    this._zRange = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n    this._modelMatrix = new Matrix4();\n    this._modelMatrixInverse = new Matrix4();\n  }\n  /* Public API */\n  get tiles() {\n    return this._tiles;\n  }\n  get selectedTiles() {\n    return this._selectedTiles;\n  }\n  get isLoaded() {\n    return this._selectedTiles !== null && this._selectedTiles.every(tile => tile.isLoaded);\n  }\n  get needsReload() {\n    return this._selectedTiles !== null && this._selectedTiles.some(tile => tile.needsReload);\n  }\n  setOptions(opts) {\n    Object.assign(this.opts, opts);\n    if (Number.isFinite(opts.maxZoom)) {\n      this._maxZoom = Math.floor(opts.maxZoom);\n    }\n    if (Number.isFinite(opts.minZoom)) {\n      this._minZoom = Math.ceil(opts.minZoom);\n    }\n  }\n  // Clean up any outstanding tile requests.\n  finalize() {\n    for (const tile of this._cache.values()) {\n      if (tile.isLoading) {\n        tile.abort();\n      }\n    }\n    this._cache.clear();\n    this._tiles = [];\n    this._selectedTiles = null;\n  }\n  reloadAll() {\n    for (const id of this._cache.keys()) {\n      const tile = this._cache.get(id);\n      if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {\n        this._cache.delete(id);\n      } else {\n        tile.setNeedsReload();\n      }\n    }\n  }\n  /**\n   * Update the cache with the given viewport and model matrix and triggers callback onUpdate.\n   */\n  update(viewport) {\n    let {\n      zRange,\n      modelMatrix\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      zRange: null,\n      modelMatrix: null\n    };\n    const modelMatrixAsMatrix4 = modelMatrix ? new Matrix4(modelMatrix) : new Matrix4();\n    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);\n    if (!this._viewport || !viewport.equals(this._viewport) || !equals(this._zRange, zRange) || isModelMatrixNew) {\n      if (isModelMatrixNew) {\n        this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();\n        this._modelMatrix = modelMatrixAsMatrix4;\n      }\n      this._viewport = viewport;\n      this._zRange = zRange;\n      const tileIndices = this.getTileIndices({\n        viewport,\n        maxZoom: this._maxZoom,\n        minZoom: this._minZoom,\n        zRange,\n        modelMatrix: this._modelMatrix,\n        modelMatrixInverse: this._modelMatrixInverse\n      });\n      this._selectedTiles = tileIndices.map(index => this._getTile(index, true));\n      if (this._dirty) {\n        // Some new tiles are added\n        this._rebuildTree();\n      }\n      // Check for needed reloads explicitly even if the view/matrix has not changed.\n    } else if (this.needsReload) {\n      this._selectedTiles = this._selectedTiles.map(tile => this._getTile(tile.index, true));\n    }\n    // Update tile states\n    const changed = this.updateTileStates();\n    this._pruneRequests();\n    if (this._dirty) {\n      // cache size is either the user defined maxSize or 5 * number of current tiles in the viewport.\n      this._resizeCache();\n    }\n    if (changed) {\n      this._frameNumber++;\n    }\n    return this._frameNumber;\n  }\n  // eslint-disable-next-line complexity\n  isTileVisible(tile, cullRect) {\n    if (!tile.isVisible) {\n      return false;\n    }\n    if (cullRect && this._viewport) {\n      const boundsArr = this._getCullBounds({\n        viewport: this._viewport,\n        z: this._zRange,\n        cullRect\n      });\n      const {\n        bbox\n      } = tile;\n      for (const [minX, minY, maxX, maxY] of boundsArr) {\n        let overlaps;\n        if ('west' in bbox) {\n          overlaps = bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;\n        } else {\n          // top/bottom could be swapped depending on the indexing system\n          const y0 = Math.min(bbox.top, bbox.bottom);\n          const y1 = Math.max(bbox.top, bbox.bottom);\n          overlaps = bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;\n        }\n        if (overlaps) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return true;\n  }\n  /* Public interface for subclassing */\n  /** Returns array of tile indices in the current viewport */\n  getTileIndices(_ref) {\n    let {\n      viewport,\n      maxZoom,\n      minZoom,\n      zRange,\n      modelMatrix,\n      modelMatrixInverse\n    } = _ref;\n    const {\n      tileSize,\n      extent,\n      zoomOffset\n    } = this.opts;\n    return getTileIndices({\n      viewport,\n      maxZoom,\n      minZoom,\n      zRange,\n      tileSize,\n      extent: extent,\n      modelMatrix,\n      modelMatrixInverse,\n      zoomOffset\n    });\n  }\n  /** Returns unique string key for a tile index */\n  getTileId(index) {\n    return `${index.x}-${index.y}-${index.z}`;\n  }\n  /** Returns a zoom level for a tile index */\n  getTileZoom(index) {\n    return index.z;\n  }\n  /** Returns additional metadata to add to tile, bbox by default */\n  getTileMetadata(index) {\n    const {\n      tileSize\n    } = this.opts;\n    return {\n      bbox: tileToBoundingBox(this._viewport, index.x, index.y, index.z, tileSize)\n    };\n  }\n  /** Returns index of the parent tile */\n  getParentIndex(index) {\n    const x = Math.floor(index.x / 2);\n    const y = Math.floor(index.y / 2);\n    const z = index.z - 1;\n    return {\n      x,\n      y,\n      z\n    };\n  }\n  // Returns true if any tile's visibility changed\n  updateTileStates() {\n    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n    const visibilities = new Array(this._cache.size);\n    let i = 0;\n    // Reset state\n    for (const tile of this._cache.values()) {\n      // save previous state\n      visibilities[i++] = tile.isVisible;\n      tile.isSelected = false;\n      tile.isVisible = false;\n    }\n    // @ts-expect-error called only when _selectedTiles is already defined\n    for (const tile of this._selectedTiles) {\n      tile.isSelected = true;\n      tile.isVisible = true;\n    }\n    // Strategy-specific state logic\n    (typeof refinementStrategy === 'function' ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));\n    i = 0;\n    // Check if any visibility has changed\n    for (const tile of this._cache.values()) {\n      if (visibilities[i++] !== tile.isVisible) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _pruneRequests() {\n    const {\n      maxRequests = 0\n    } = this.opts;\n    const abortCandidates = [];\n    let ongoingRequestCount = 0;\n    for (const tile of this._cache.values()) {\n      // Keep track of all the ongoing requests\n      if (tile.isLoading) {\n        ongoingRequestCount++;\n        if (!tile.isSelected && !tile.isVisible) {\n          abortCandidates.push(tile);\n        }\n      }\n    }\n    while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {\n      // There are too many ongoing requests, so abort some that are unselected\n      const tile = abortCandidates.shift();\n      tile.abort();\n      ongoingRequestCount--;\n    }\n  }\n  // This needs to be called every time some tiles have been added/removed from cache\n  _rebuildTree() {\n    const {\n      _cache\n    } = this;\n    // Reset states\n    for (const tile of _cache.values()) {\n      tile.parent = null;\n      if (tile.children) {\n        tile.children.length = 0;\n      }\n    }\n    // Rebuild tree\n    for (const tile of _cache.values()) {\n      const parent = this._getNearestAncestor(tile);\n      tile.parent = parent;\n      if (parent?.children) {\n        parent.children.push(tile);\n      }\n    }\n  }\n  /**\n   * Clear tiles that are not visible when the cache is full\n   */\n  /* eslint-disable complexity */\n  _resizeCache() {\n    const {\n      _cache,\n      opts\n    } = this;\n    const maxCacheSize = opts.maxCacheSize ?? (\n    // @ts-expect-error called only when selectedTiles is initialized\n    opts.maxCacheByteSize !== null ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n    const maxCacheByteSize = opts.maxCacheByteSize ?? Infinity;\n    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n    if (overflown) {\n      for (const [id, tile] of _cache) {\n        if (!tile.isVisible && !tile.isSelected) {\n          // delete tile\n          this._cacheByteSize -= opts.maxCacheByteSize !== null ? tile.byteLength : 0;\n          _cache.delete(id);\n          this.opts.onTileUnload?.(tile);\n        }\n        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n          break;\n        }\n      }\n      this._rebuildTree();\n      this._dirty = true;\n    }\n    if (this._dirty) {\n      // sort by zoom level so that smaller tiles are displayed on top\n      this._tiles = Array.from(this._cache.values()).sort((t1, t2) => t1.zoom - t2.zoom);\n      this._dirty = false;\n    }\n  }\n  _getTile(index, create) {\n    const id = this.getTileId(index);\n    let tile = this._cache.get(id);\n    let needsReload = false;\n    if (!tile && create) {\n      tile = new Tile2DHeader(index);\n      Object.assign(tile, this.getTileMetadata(tile.index));\n      Object.assign(tile, {\n        id,\n        zoom: this.getTileZoom(tile.index)\n      });\n      needsReload = true;\n      this._cache.set(id, tile);\n      this._dirty = true;\n    } else if (tile && tile.needsReload) {\n      needsReload = true;\n    }\n    if (tile && needsReload) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      tile.loadData({\n        getData: this.opts.getTileData,\n        requestScheduler: this._requestScheduler,\n        onLoad: this.onTileLoad,\n        onError: this.opts.onTileError\n      });\n    }\n    return tile;\n  }\n  _getNearestAncestor(tile) {\n    const {\n      _minZoom = 0\n    } = this;\n    let index = tile.index;\n    while (this.getTileZoom(index) > _minZoom) {\n      index = this.getParentIndex(index);\n      const parent = this._getTile(index);\n      if (parent) {\n        return parent;\n      }\n    }\n    return null;\n  }\n}\n/* -- Refinement strategies --*/\n/* eslint-disable max-depth */\n// For all the selected && pending tiles:\n// - pick the closest ancestor as placeholder\n// - if no ancestor is visible, pick the closest children as placeholder\nfunction updateTileStateDefault(allTiles) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n  for (const tile of allTiles) {\n    if (tile.isSelected && !getPlaceholderInAncestors(tile)) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n  for (const tile of allTiles) {\n    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n  }\n}\n// Until a selected tile and all its selected siblings are loaded, use the closest ancestor as placeholder\nfunction updateTileStateReplace(allTiles) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n  for (const tile of allTiles) {\n    if (tile.isSelected) {\n      getPlaceholderInAncestors(tile);\n    }\n  }\n  // Always process parents first\n  const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.zoom - t2.zoom);\n  for (const tile of sortedTiles) {\n    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n    if (tile.children && (tile.isVisible || tile.state & TILE_STATE_VISITED)) {\n      // If the tile is rendered, or if the tile has been explicitly hidden, hide all of its children\n      for (const child of tile.children) {\n        child.state = TILE_STATE_VISITED;\n      }\n    } else if (tile.isSelected) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n}\n// Walk up the tree until we find one ancestor that is loaded. Returns true if successful.\nfunction getPlaceholderInAncestors(startTile) {\n  let tile = startTile;\n  while (tile) {\n    if (tile.isLoaded || tile.content) {\n      tile.state |= TILE_STATE_VISIBLE;\n      return true;\n    }\n    tile = tile.parent;\n  }\n  return false;\n}\n// Recursively set children as placeholder\nfunction getPlaceholderInChildren(tile) {\n  for (const child of tile.children) {\n    if (child.isLoaded || child.content) {\n      child.state |= TILE_STATE_VISIBLE;\n    } else {\n      getPlaceholderInChildren(child);\n    }\n  }\n}\n//# sourceMappingURL=tileset-2d.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}