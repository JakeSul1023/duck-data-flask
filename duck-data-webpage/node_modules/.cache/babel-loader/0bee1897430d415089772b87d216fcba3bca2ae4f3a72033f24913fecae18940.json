{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Geometry, GroupNode } from '@luma.gl/engine';\nimport { Matrix4 } from '@math.gl/core';\nimport { GLTFAnimator } from \"./gltf-animator.js\";\nimport { createGLTFModel } from \"./create-gltf-model.js\";\nimport { convertGLDrawModeToTopology } from \"./gl-utils.js\";\nconst DEFAULT_OPTIONS = {\n  modelOptions: {},\n  pbrDebug: false,\n  imageBasedLightingEnvironment: null,\n  lights: true,\n  useTangents: false\n};\n/**\n * GLTF instantiator for luma.gl\n * Walks the parsed and resolved glTF structure and builds a luma.gl scenegraph\n */\nexport class GLTFInstantiator {\n  device;\n  options;\n  gltf;\n  constructor(device, options = {}) {\n    this.device = device;\n    this.options = {\n      ...DEFAULT_OPTIONS,\n      ...options\n    };\n  }\n  instantiate(gltf) {\n    this.gltf = deepCopy(gltf);\n    const scenes = (this.gltf.scenes || []).map(scene => this.createScene(scene));\n    return scenes;\n  }\n  createAnimator() {\n    if (Array.isArray(this.gltf.animations)) {\n      return new GLTFAnimator(this.gltf);\n    }\n    return null;\n  }\n  createScene(gltfScene) {\n    const gltfNodes = gltfScene.nodes || [];\n    const nodes = gltfNodes.map(node => this.createNode(node));\n    const scene = new GroupNode({\n      id: gltfScene.name || gltfScene.id,\n      children: nodes\n    });\n    return scene;\n  }\n  createNode(gltfNode) {\n    if (!gltfNode._node) {\n      const gltfChildren = gltfNode.children || [];\n      const children = gltfChildren.map(child => this.createNode(child));\n      // Node can have children nodes and meshes at the same time\n      if (gltfNode.mesh) {\n        children.push(this.createMesh(gltfNode.mesh));\n      }\n      const node = new GroupNode({\n        id: gltfNode.name || gltfNode.id,\n        children\n      });\n      if (gltfNode.matrix) {\n        node.setMatrix(gltfNode.matrix);\n      } else {\n        node.matrix.identity();\n        if (gltfNode.translation) {\n          node.matrix.translate(gltfNode.translation);\n        }\n        if (gltfNode.rotation) {\n          const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);\n          node.matrix.multiplyRight(rotationMatrix);\n        }\n        if (gltfNode.scale) {\n          node.matrix.scale(gltfNode.scale);\n        }\n      }\n      gltfNode._node = node;\n    }\n    // Copy _node so that gltf-animator can access\n    const topLevelNode = this.gltf.nodes.find(node => node.id === gltfNode.id);\n    topLevelNode._node = gltfNode._node;\n    return gltfNode._node;\n  }\n  createMesh(gltfMesh) {\n    // TODO: avoid changing the gltf\n    if (!gltfMesh._mesh) {\n      const gltfPrimitives = gltfMesh.primitives || [];\n      const primitives = gltfPrimitives.map((gltfPrimitive, i) => this.createPrimitive(gltfPrimitive, i, gltfMesh));\n      const mesh = new GroupNode({\n        id: gltfMesh.name || gltfMesh.id,\n        children: primitives\n      });\n      gltfMesh._mesh = mesh;\n    }\n    return gltfMesh._mesh;\n  }\n  createPrimitive(gltfPrimitive, i, gltfMesh) {\n    const id = gltfPrimitive.name || `${gltfMesh.name || gltfMesh.id}-primitive-${i}`;\n    const topology = convertGLDrawModeToTopology(gltfPrimitive.mode || 4);\n    const vertexCount = gltfPrimitive.indices ? gltfPrimitive.indices.count : this.getVertexCount(gltfPrimitive.attributes);\n    const modelNode = createGLTFModel(this.device, {\n      id,\n      geometry: this.createGeometry(id, gltfPrimitive, topology),\n      material: gltfPrimitive.material,\n      materialOptions: this.options,\n      modelOptions: this.options.modelOptions,\n      vertexCount\n    });\n    modelNode.bounds = [gltfPrimitive.attributes.POSITION.min, gltfPrimitive.attributes.POSITION.max];\n    // TODO this holds on to all the CPU side texture and attribute data\n    // modelNode.material =  gltfPrimitive.material;\n    return modelNode;\n  }\n  getVertexCount(attributes) {\n    throw new Error('getVertexCount not implemented');\n  }\n  createGeometry(id, gltfPrimitive, topology) {\n    const attributes = {};\n    for (const [attributeName, attribute] of Object.entries(gltfPrimitive.attributes)) {\n      const {\n        components,\n        size,\n        value\n      } = attribute;\n      attributes[attributeName] = {\n        size: size ?? components,\n        value\n      };\n    }\n    return new Geometry({\n      id,\n      topology,\n      indices: gltfPrimitive.indices.value,\n      attributes\n    });\n  }\n  createBuffer(attribute, usage) {\n    if (!attribute.bufferView) {\n      // Draco decoded files do not have a bufferView\n      attribute.bufferView = {};\n    }\n    const {\n      bufferView\n    } = attribute;\n    if (!bufferView.lumaBuffers) {\n      bufferView.lumaBuffers = {};\n    }\n    if (!bufferView.lumaBuffers[usage]) {\n      bufferView.lumaBuffers[usage] = this.device.createBuffer({\n        id: `from-${bufferView.id}`,\n        // Draco decoded files have attribute.value\n        data: bufferView.data || attribute.value\n      });\n    }\n    return bufferView.lumaBuffers[usage];\n  }\n  // TODO - create sampler in WebGL2\n  createSampler(gltfSampler) {\n    return gltfSampler;\n  }\n  // Helper methods (move to GLTFLoader.resolve...?)\n  needsPOT() {\n    // Has a wrapping mode (either wrapS or wrapT) equal to REPEAT or MIRRORED_REPEAT, or\n    // Has a minification filter (minFilter) that uses mipmapping\n    // (NEAREST_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR,\n    // LINEAR_MIPMAP_NEAREST, or LINEAR_MIPMAP_LINEAR).\n    return false;\n  }\n}\n/** Deeply copies a JS data structure */\nfunction deepCopy(object) {\n  // don't copy binary data\n  if (ArrayBuffer.isView(object) || object instanceof ArrayBuffer || object instanceof ImageBitmap) {\n    return object;\n  }\n  if (Array.isArray(object)) {\n    return object.map(deepCopy);\n  }\n  if (object && typeof object === 'object') {\n    const result = {};\n    for (const key in object) {\n      result[key] = deepCopy(object[key]);\n    }\n    return result;\n  }\n  return object;\n}","map":{"version":3,"names":["Geometry","GroupNode","Matrix4","GLTFAnimator","createGLTFModel","convertGLDrawModeToTopology","DEFAULT_OPTIONS","modelOptions","pbrDebug","imageBasedLightingEnvironment","lights","useTangents","GLTFInstantiator","device","options","gltf","constructor","instantiate","deepCopy","scenes","map","scene","createScene","createAnimator","Array","isArray","animations","gltfScene","gltfNodes","nodes","node","createNode","id","name","children","gltfNode","_node","gltfChildren","child","mesh","push","createMesh","matrix","setMatrix","identity","translation","translate","rotation","rotationMatrix","fromQuaternion","multiplyRight","scale","topLevelNode","find","gltfMesh","_mesh","gltfPrimitives","primitives","gltfPrimitive","i","createPrimitive","topology","mode","vertexCount","indices","count","getVertexCount","attributes","modelNode","geometry","createGeometry","material","materialOptions","bounds","POSITION","min","max","Error","attributeName","attribute","Object","entries","components","size","value","createBuffer","usage","bufferView","lumaBuffers","data","createSampler","gltfSampler","needsPOT","object","ArrayBuffer","isView","ImageBitmap","result","key"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\gltf\\src\\gltf\\gltf-instantiator.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, Buffer, PrimitiveTopology} from '@luma.gl/core';\nimport {Geometry, GeometryAttribute, GroupNode, ModelNode, ModelProps} from '@luma.gl/engine';\nimport {Matrix4} from '@math.gl/core';\n\nimport {GLTFAnimator} from './gltf-animator';\nimport {createGLTFModel} from './create-gltf-model';\nimport type {PBREnvironment} from '../pbr/pbr-environment';\nimport {convertGLDrawModeToTopology} from './gl-utils';\n\nexport type GLTFInstantiatorOptions = {\n  modelOptions?: Partial<ModelProps>;\n  pbrDebug?: boolean;\n  imageBasedLightingEnvironment?: PBREnvironment;\n  lights?: boolean;\n  useTangents?: boolean;\n};\n\nconst DEFAULT_OPTIONS: GLTFInstantiatorOptions = {\n  modelOptions: {},\n  pbrDebug: false,\n  imageBasedLightingEnvironment: null,\n  lights: true,\n  useTangents: false\n};\n\n/**\n * GLTF instantiator for luma.gl\n * Walks the parsed and resolved glTF structure and builds a luma.gl scenegraph\n */\nexport class GLTFInstantiator {\n  device: Device;\n  options: GLTFInstantiatorOptions;\n  gltf: any;\n\n  constructor(device: Device, options: GLTFInstantiatorOptions = {}) {\n    this.device = device;\n    this.options = {...DEFAULT_OPTIONS, ...options};\n  }\n\n  instantiate(gltf: any): GroupNode[] {\n    this.gltf = deepCopy(gltf);\n    const scenes = (this.gltf.scenes || []).map(scene => this.createScene(scene));\n    return scenes;\n  }\n\n  createAnimator(): GLTFAnimator {\n    if (Array.isArray(this.gltf.animations)) {\n      return new GLTFAnimator(this.gltf);\n    }\n\n    return null;\n  }\n\n  createScene(gltfScene: any): GroupNode {\n    const gltfNodes = gltfScene.nodes || [];\n    const nodes = gltfNodes.map(node => this.createNode(node));\n    const scene = new GroupNode({\n      id: gltfScene.name || gltfScene.id,\n      children: nodes\n    });\n    return scene;\n  }\n\n  createNode(gltfNode) {\n    if (!gltfNode._node) {\n      const gltfChildren = gltfNode.children || [];\n      const children = gltfChildren.map(child => this.createNode(child));\n\n      // Node can have children nodes and meshes at the same time\n      if (gltfNode.mesh) {\n        children.push(this.createMesh(gltfNode.mesh));\n      }\n\n      const node = new GroupNode({\n        id: gltfNode.name || gltfNode.id,\n        children\n      });\n\n      if (gltfNode.matrix) {\n        node.setMatrix(gltfNode.matrix);\n      } else {\n        node.matrix.identity();\n\n        if (gltfNode.translation) {\n          node.matrix.translate(gltfNode.translation);\n        }\n\n        if (gltfNode.rotation) {\n          const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);\n          node.matrix.multiplyRight(rotationMatrix);\n        }\n\n        if (gltfNode.scale) {\n          node.matrix.scale(gltfNode.scale);\n        }\n      }\n      gltfNode._node = node;\n    }\n\n    // Copy _node so that gltf-animator can access\n    const topLevelNode = this.gltf.nodes.find(node => node.id === gltfNode.id);\n    topLevelNode._node = gltfNode._node;\n\n    return gltfNode._node;\n  }\n\n  createMesh(gltfMesh): GroupNode {\n    // TODO: avoid changing the gltf\n    if (!gltfMesh._mesh) {\n      const gltfPrimitives = gltfMesh.primitives || [];\n      const primitives = gltfPrimitives.map((gltfPrimitive, i) =>\n        this.createPrimitive(gltfPrimitive, i, gltfMesh)\n      );\n      const mesh = new GroupNode({\n        id: gltfMesh.name || gltfMesh.id,\n        children: primitives\n      });\n      gltfMesh._mesh = mesh;\n    }\n\n    return gltfMesh._mesh;\n  }\n\n  createPrimitive(gltfPrimitive: any, i: number, gltfMesh): ModelNode {\n    const id = gltfPrimitive.name || `${gltfMesh.name || gltfMesh.id}-primitive-${i}`;\n    const topology = convertGLDrawModeToTopology(gltfPrimitive.mode || 4);\n    const vertexCount = gltfPrimitive.indices\n      ? gltfPrimitive.indices.count\n      : this.getVertexCount(gltfPrimitive.attributes);\n\n    const modelNode = createGLTFModel(this.device, {\n      id,\n      geometry: this.createGeometry(id, gltfPrimitive, topology),\n      material: gltfPrimitive.material,\n      materialOptions: this.options,\n      modelOptions: this.options.modelOptions,\n      vertexCount\n    });\n\n    modelNode.bounds = [\n      gltfPrimitive.attributes.POSITION.min,\n      gltfPrimitive.attributes.POSITION.max\n    ];\n    // TODO this holds on to all the CPU side texture and attribute data\n    // modelNode.material =  gltfPrimitive.material;\n\n    return modelNode;\n  }\n\n  getVertexCount(attributes: any) {\n    throw new Error('getVertexCount not implemented');\n  }\n\n  createGeometry(id: string, gltfPrimitive: any, topology: PrimitiveTopology): Geometry {\n    const attributes = {};\n    for (const [attributeName, attribute] of Object.entries(gltfPrimitive.attributes)) {\n      const {components, size, value} = attribute as GeometryAttribute;\n\n      attributes[attributeName] = {size: size ?? components, value};\n    }\n\n    return new Geometry({\n      id,\n      topology,\n      indices: gltfPrimitive.indices.value,\n      attributes\n    });\n  }\n\n  createBuffer(attribute, usage: number): Buffer {\n    if (!attribute.bufferView) {\n      // Draco decoded files do not have a bufferView\n      attribute.bufferView = {};\n    }\n\n    const {bufferView} = attribute;\n    if (!bufferView.lumaBuffers) {\n      bufferView.lumaBuffers = {};\n    }\n\n    if (!bufferView.lumaBuffers[usage]) {\n      bufferView.lumaBuffers[usage] = this.device.createBuffer({\n        id: `from-${bufferView.id}`,\n        // Draco decoded files have attribute.value\n        data: bufferView.data || attribute.value\n      });\n    }\n\n    return bufferView.lumaBuffers[usage];\n  }\n\n  // TODO - create sampler in WebGL2\n  createSampler(gltfSampler) {\n    return gltfSampler;\n  }\n\n  // Helper methods (move to GLTFLoader.resolve...?)\n\n  needsPOT(): boolean {\n    // Has a wrapping mode (either wrapS or wrapT) equal to REPEAT or MIRRORED_REPEAT, or\n    // Has a minification filter (minFilter) that uses mipmapping\n    // (NEAREST_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR,\n    // LINEAR_MIPMAP_NEAREST, or LINEAR_MIPMAP_LINEAR).\n    return false;\n  }\n}\n\n/** Deeply copies a JS data structure */\nfunction deepCopy(object: any): any {\n  // don't copy binary data\n  if (\n    ArrayBuffer.isView(object) ||\n    object instanceof ArrayBuffer ||\n    object instanceof ImageBitmap\n  ) {\n    return object;\n  }\n  if (Array.isArray(object)) {\n    return object.map(deepCopy);\n  }\n  if (object && typeof object === 'object') {\n    const result = {};\n    for (const key in object) {\n      result[key] = deepCopy(object[key]);\n    }\n    return result;\n  }\n  return object;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}