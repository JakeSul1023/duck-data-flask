{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { LayerExtension } from '@deck.gl/core';\nimport { TerrainEffect } from \"./terrain-effect.js\";\nimport { terrainModule } from \"./shader-module.js\";\nconst defaultProps = {\n  terrainDrawMode: undefined\n};\n/** Allows layers to show/hide objects by a geofence. */\nclass TerrainExtension extends LayerExtension {\n  getShaders() {\n    return {\n      modules: [terrainModule]\n    };\n  }\n  initializeState() {\n    this.context.deck?._addDefaultEffect(new TerrainEffect());\n  }\n  updateState(params) {\n    const {\n      props,\n      oldProps\n    } = params;\n    if (this.state.terrainDrawMode && props.terrainDrawMode === oldProps.terrainDrawMode &&\n    // @ts-ignore `extruded` may not exist in props\n    props.extruded === oldProps.extruded) {\n      return;\n    }\n    let {\n      terrainDrawMode\n    } = props;\n    if (!terrainDrawMode) {\n      // props.extruded is used as an indication that the layer is 2.5D\n      // @ts-ignore `extruded` may not exist in props\n      const is3d = this.props.extruded;\n      const attributes = this.getAttributeManager()?.attributes;\n      const hasAnchor = attributes && 'instancePositions' in attributes;\n      terrainDrawMode = is3d || hasAnchor ? 'offset' : 'drape';\n    }\n    this.setState({\n      terrainDrawMode\n    });\n  }\n  onNeedsRedraw() {\n    const state = this.state;\n    if (state.terrainDrawMode === 'drape') {\n      state.terrainCoverNeedsRedraw = true;\n    }\n  }\n}\nTerrainExtension.defaultProps = defaultProps;\nTerrainExtension.extensionName = 'TerrainExtension';\nexport default TerrainExtension;","map":{"version":3,"names":["LayerExtension","TerrainEffect","terrainModule","defaultProps","terrainDrawMode","undefined","TerrainExtension","getShaders","modules","initializeState","context","deck","_addDefaultEffect","updateState","params","props","oldProps","state","extruded","is3d","attributes","getAttributeManager","hasAnchor","setState","onNeedsRedraw","terrainCoverNeedsRedraw","extensionName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\extensions\\src\\terrain\\terrain-extension.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {LayerExtension, UpdateParameters} from '@deck.gl/core';\nimport {TerrainEffect} from './terrain-effect';\nimport {terrainModule} from './shader-module';\n\nimport type {Layer} from '@deck.gl/core';\n\nconst defaultProps = {\n  terrainDrawMode: undefined\n};\n\nexport type TerrainExtensionProps = {\n  /**\n   * controls whether an object is drawn over the terrain surface by its anchor (usually defined by an accessor called `getPosition`, e.g. icon, scatterplot) or by its geometry (e.g. path, polygon).\n   * If not specified, it is automatically deduced from the layer.\n   */\n  terrainDrawMode?: 'offset' | 'drape';\n};\n\ntype TerrainExtensionState = {\n  /** Resolved fitting mode */\n  terrainDrawMode: 'offset' | 'drape';\n  /** Set when a layer is flagged as needs redraw */\n  terrainCoverNeedsRedraw: boolean;\n};\n\n/** Allows layers to show/hide objects by a geofence. */\nexport default class TerrainExtension extends LayerExtension {\n  static defaultProps = defaultProps;\n  static extensionName = 'TerrainExtension';\n\n  getShaders(this: Layer<TerrainExtensionProps>): any {\n    return {\n      modules: [terrainModule]\n    };\n  }\n\n  initializeState(this: Layer<TerrainExtensionProps>) {\n    this.context.deck?._addDefaultEffect(new TerrainEffect());\n  }\n\n  updateState(\n    this: Layer<TerrainExtensionProps>,\n    params: UpdateParameters<Layer<TerrainExtensionProps>>\n  ) {\n    const {props, oldProps} = params;\n\n    if (\n      this.state.terrainDrawMode &&\n      props.terrainDrawMode === oldProps.terrainDrawMode &&\n      // @ts-ignore `extruded` may not exist in props\n      props.extruded === oldProps.extruded\n    ) {\n      return;\n    }\n\n    let {terrainDrawMode} = props;\n    if (!terrainDrawMode) {\n      // props.extruded is used as an indication that the layer is 2.5D\n      // @ts-ignore `extruded` may not exist in props\n      const is3d = this.props.extruded as boolean;\n      const attributes = this.getAttributeManager()?.attributes;\n      const hasAnchor = attributes && 'instancePositions' in attributes;\n      terrainDrawMode = is3d || hasAnchor ? 'offset' : 'drape';\n    }\n    this.setState({terrainDrawMode});\n  }\n\n  onNeedsRedraw(this: Layer<{}>): void {\n    const state = this.state as TerrainExtensionState;\n    if (state.terrainDrawMode === 'drape') {\n      state.terrainCoverNeedsRedraw = true;\n    }\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA,SAAQA,cAAc,QAAyB,eAAe;AAC9D,SAAQC,aAAa,QAAC;AACtB,SAAQC,aAAa,QAAC;AAItB,MAAMC,YAAY,GAAG;EACnBC,eAAe,EAAEC;CAClB;AAiBD;AACA,MAAqBC,gBAAiB,SAAQN,cAAc;EAI1DO,UAAUA,CAAA;IACR,OAAO;MACLC,OAAO,EAAE,CAACN,aAAa;KACxB;EACH;EAEAO,eAAeA,CAAA;IACb,IAAI,CAACC,OAAO,CAACC,IAAI,EAAEC,iBAAiB,CAAC,IAAIX,aAAa,EAAE,CAAC;EAC3D;EAEAY,WAAWA,CAETC,MAAsD;IAEtD,MAAM;MAACC,KAAK;MAAEC;IAAQ,CAAC,GAAGF,MAAM;IAEhC,IACE,IAAI,CAACG,KAAK,CAACb,eAAe,IAC1BW,KAAK,CAACX,eAAe,KAAKY,QAAQ,CAACZ,eAAe;IAClD;IACAW,KAAK,CAACG,QAAQ,KAAKF,QAAQ,CAACE,QAAQ,EACpC;MACA;IACF;IAEA,IAAI;MAACd;IAAe,CAAC,GAAGW,KAAK;IAC7B,IAAI,CAACX,eAAe,EAAE;MACpB;MACA;MACA,MAAMe,IAAI,GAAG,IAAI,CAACJ,KAAK,CAACG,QAAmB;MAC3C,MAAME,UAAU,GAAG,IAAI,CAACC,mBAAmB,EAAE,EAAED,UAAU;MACzD,MAAME,SAAS,GAAGF,UAAU,IAAI,mBAAmB,IAAIA,UAAU;MACjEhB,eAAe,GAAGe,IAAI,IAAIG,SAAS,GAAG,QAAQ,GAAG,OAAO;IAC1D;IACA,IAAI,CAACC,QAAQ,CAAC;MAACnB;IAAe,CAAC,CAAC;EAClC;EAEAoB,aAAaA,CAAA;IACX,MAAMP,KAAK,GAAG,IAAI,CAACA,KAA8B;IACjD,IAAIA,KAAK,CAACb,eAAe,KAAK,OAAO,EAAE;MACrCa,KAAK,CAACQ,uBAAuB,GAAG,IAAI;IACtC;EACF;;AA7COnB,gBAAA,CAAAH,YAAY,GAAGA,YAAY;AAC3BG,gBAAA,CAAAoB,aAAa,GAAG,kBAAkB;eAFtBpB,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}