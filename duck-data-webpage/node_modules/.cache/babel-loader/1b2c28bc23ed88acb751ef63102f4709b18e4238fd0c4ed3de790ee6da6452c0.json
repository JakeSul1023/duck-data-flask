{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { CPUAggregator, WebGLAggregator } from \"../common/aggregator/index.js\";\n/** Returns an accessor to the aggregated values from bin id */\nexport function getAggregatorValueReader(opts) {\n  const {\n    aggregator,\n    binIdRange,\n    channel\n  } = opts;\n  if (aggregator instanceof WebGLAggregator) {\n    const buffer = aggregator.getResult(channel)?.buffer;\n    if (buffer) {\n      const values = new Float32Array(buffer.readSyncWebGL().buffer);\n      return getWebGLAggregatorValueReader(values, binIdRange);\n    }\n  }\n  if (aggregator instanceof CPUAggregator) {\n    const values = aggregator.getResult(channel)?.value;\n    const ids = aggregator.getBins()?.value;\n    if (ids && values) {\n      return getCPUAggregatorValueReader(values, ids, aggregator.binCount);\n    }\n  }\n  return null;\n}\nfunction getWebGLAggregatorValueReader(values, binIdRange) {\n  const [[minX, maxX], [minY, maxY]] = binIdRange;\n  const width = maxX - minX;\n  const height = maxY - minY;\n  return (x, y) => {\n    x -= minX;\n    y -= minY;\n    if (x < 0 || x >= width || y < 0 || y >= height) {\n      return NaN;\n    }\n    return values[y * width + x];\n  };\n}\nfunction getCPUAggregatorValueReader(values, ids, count) {\n  const idMap = {};\n  for (let i = 0; i < count; i++) {\n    const x = ids[i * 2];\n    const y = ids[i * 2 + 1];\n    idMap[x] = idMap[x] || {};\n    idMap[x][y] = values[i];\n  }\n  return (x, y) => idMap[x]?.[y] ?? NaN;\n}\n//# sourceMappingURL=value-reader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}