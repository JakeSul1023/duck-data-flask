{"ast":null,"code":"/* global setTimeout, clearTimeout */\nimport { Recognizer } from \"../recognizer/recognizer.js\";\nimport { TOUCH_ACTION_MANIPULATION } from \"../touchaction/touchaction-Consts.js\";\nimport { InputEvent } from \"../input/input-consts.js\";\nimport { RecognizerState } from \"../recognizer/recognizer-state.js\";\nimport { getPointDistance } from \"../input/get-distance.js\";\n/**\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n */\nexport class TapRecognizer extends Recognizer {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      enable: true,\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      time: 250,\n      threshold: 9,\n      posThreshold: 10,\n      ...options\n    });\n    /** previous time for tap counting */\n    this.pTime = null;\n    /** previous center for tap counting */\n    this.pCenter = null;\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n  getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  }\n  process(input) {\n    const {\n      options\n    } = this;\n    const validPointers = input.pointers.length === options.pointers;\n    const validMovement = input.distance < options.threshold;\n    const validTouchTime = input.deltaTime < options.time;\n    this.reset();\n    if (input.eventType & InputEvent.Start && this.count === 0) {\n      return this.failTimeout();\n    }\n    // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== InputEvent.End) {\n        return this.failTimeout();\n      }\n      const validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n      const validMultiTap = !this.pCenter || getPointDistance(this.pCenter, input.center) < options.posThreshold;\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n      this._input = input;\n      // if tap count matches we have recognized it,\n      // else it has began recognizing...\n      const tapCount = this.count % options.taps;\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return RecognizerState.Recognized;\n        }\n        this._timer = setTimeout(() => {\n          this.state = RecognizerState.Recognized;\n          this.tryEmit(this._input);\n        }, options.interval);\n        return RecognizerState.Began;\n      }\n    }\n    return RecognizerState.Failed;\n  }\n  failTimeout() {\n    this._timer = setTimeout(() => {\n      this.state = RecognizerState.Failed;\n    }, this.options.interval);\n    return RecognizerState.Failed;\n  }\n  reset() {\n    clearTimeout(this._timer);\n  }\n  emit(input) {\n    if (this.state === RecognizerState.Recognized) {\n      input.tapCount = this.count;\n      this.manager.emit(this.options.event, input);\n    }\n  }\n}\n//# sourceMappingURL=tap.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}