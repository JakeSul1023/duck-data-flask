{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst count = pointIndices => {\n  return pointIndices.length;\n};\nconst sum = (pointIndices, getValue) => {\n  let result = 0;\n  for (const i of pointIndices) {\n    result += getValue(i);\n  }\n  return result;\n};\nconst mean = (pointIndices, getValue) => {\n  if (pointIndices.length === 0) {\n    return NaN;\n  }\n  return sum(pointIndices, getValue) / pointIndices.length;\n};\nconst min = (pointIndices, getValue) => {\n  let result = Infinity;\n  for (const i of pointIndices) {\n    const value = getValue(i);\n    if (value < result) {\n      result = value;\n    }\n  }\n  return result;\n};\nconst max = (pointIndices, getValue) => {\n  let result = -Infinity;\n  for (const i of pointIndices) {\n    const value = getValue(i);\n    if (value > result) {\n      result = value;\n    }\n  }\n  return result;\n};\nexport const BUILT_IN_OPERATIONS = {\n  COUNT: count,\n  SUM: sum,\n  MEAN: mean,\n  MIN: min,\n  MAX: max\n};\n/**\n * Performs the aggregation step. See interface Aggregator comments.\n * @returns Floa32Array of aggregated values, one for each bin, and the [min,max] of the values\n */\nexport function aggregate({\n  bins,\n  getValue,\n  operation,\n  target\n}) {\n  if (!target || target.length < bins.length) {\n    target = new Float32Array(bins.length);\n  }\n  let min = Infinity;\n  let max = -Infinity;\n  for (let j = 0; j < bins.length; j++) {\n    const {\n      points\n    } = bins[j];\n    target[j] = operation(points, getValue);\n    if (target[j] < min) min = target[j];\n    if (target[j] > max) max = target[j];\n  }\n  return {\n    value: target,\n    domain: [min, max]\n  };\n}\n//# sourceMappingURL=aggregate.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}