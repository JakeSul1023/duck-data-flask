{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Layer, project32, picking, log } from '@deck.gl/core';\nimport { pbrMaterial } from '@luma.gl/shadertools';\nimport { ScenegraphNode, GroupNode, ModelNode } from '@luma.gl/engine';\nimport { createScenegraphsFromGLTF } from '@luma.gl/gltf';\nimport { GLTFLoader, postProcessGLTF } from '@loaders.gl/gltf';\nimport { waitForGLTFAssets } from \"./gltf-utils.js\";\nimport { MATRIX_ATTRIBUTES, shouldComposeModelMatrix } from \"../utils/matrix.js\";\nimport { scenegraphUniforms } from \"./scenegraph-layer-uniforms.js\";\nimport vs from \"./scenegraph-layer-vertex.glsl.js\";\nimport fs from \"./scenegraph-layer-fragment.glsl.js\";\nconst DEFAULT_COLOR = [255, 255, 255, 255];\nconst defaultProps = {\n  scenegraph: {\n    type: 'object',\n    value: null,\n    async: true\n  },\n  getScene: gltf => {\n    if (gltf && gltf.scenes) {\n      // gltf post processor replaces `gltf.scene` number with the scene `object`\n      return typeof gltf.scene === 'object' ? gltf.scene : gltf.scenes[gltf.scene || 0];\n    }\n    return gltf;\n  },\n  getAnimator: scenegraph => scenegraph && scenegraph.animator,\n  _animations: null,\n  sizeScale: {\n    type: 'number',\n    value: 1,\n    min: 0\n  },\n  sizeMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  sizeMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  // flat or pbr\n  _lighting: 'flat',\n  // _lighting must be pbr for this to work\n  _imageBasedLightingEnvironment: undefined,\n  // yaw, pitch and roll are in degrees\n  // https://en.wikipedia.org/wiki/Euler_angles\n  // [pitch, yaw, roll]\n  getOrientation: {\n    type: 'accessor',\n    value: [0, 0, 0]\n  },\n  getScale: {\n    type: 'accessor',\n    value: [1, 1, 1]\n  },\n  getTranslation: {\n    type: 'accessor',\n    value: [0, 0, 0]\n  },\n  // 4x4 matrix\n  getTransformMatrix: {\n    type: 'accessor',\n    value: []\n  },\n  loaders: [GLTFLoader]\n};\n/** Render a number of instances of a complete glTF scenegraph. */\nclass ScenegraphLayer extends Layer {\n  getShaders() {\n    const defines = {};\n    let pbr;\n    if (this.props._lighting === 'pbr') {\n      pbr = pbrMaterial;\n      defines.LIGHTING_PBR = 1;\n    } else {\n      // Dummy shader module needed to handle\n      // pbrMaterial.pbr_baseColorSampler binding\n      pbr = {\n        name: 'pbrMaterial'\n      };\n    }\n    const modules = [project32, picking, scenegraphUniforms, pbr];\n    return super.getShaders({\n      defines,\n      vs,\n      fs,\n      modules\n    });\n  }\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    // attributeManager is always defined for primitive layers\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 'float64',\n        fp64: this.use64bitPositions(),\n        accessor: 'getPosition',\n        transition: true\n      },\n      instanceColors: {\n        type: 'unorm8',\n        size: this.props.colorFormat.length,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR,\n        transition: true\n      },\n      instanceModelMatrix: MATRIX_ATTRIBUTES\n    });\n  }\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps\n    } = params;\n    if (props.scenegraph !== oldProps.scenegraph) {\n      this._updateScenegraph();\n    } else if (props._animations !== oldProps._animations) {\n      this._applyAnimationsProp(this.state.animator, props._animations);\n    }\n  }\n  finalizeState(context) {\n    super.finalizeState(context);\n    this.state.scenegraph?.destroy();\n  }\n  get isLoaded() {\n    return Boolean(this.state?.scenegraph && super.isLoaded);\n  }\n  _updateScenegraph() {\n    const props = this.props;\n    const {\n      device\n    } = this.context;\n    let scenegraphData = null;\n    if (props.scenegraph instanceof ScenegraphNode) {\n      // Signature 1: props.scenegraph is a proper luma.gl Scenegraph\n      scenegraphData = {\n        scenes: [props.scenegraph]\n      };\n    } else if (props.scenegraph && typeof props.scenegraph === 'object') {\n      // Converts loaders.gl gltf to luma.gl scenegraph using the undocumented @luma.gl/experimental function\n      const gltf = props.scenegraph;\n      // Tiles3DLoader already processes GLTF\n      const processedGLTF = gltf.json ? postProcessGLTF(gltf) : gltf;\n      const gltfObjects = createScenegraphsFromGLTF(device, processedGLTF, this._getModelOptions());\n      scenegraphData = {\n        gltf: processedGLTF,\n        ...gltfObjects\n      };\n      waitForGLTFAssets(gltfObjects).then(() => {\n        this.setNeedsRedraw();\n      }).catch(ex => {\n        this.raiseError(ex, 'loading glTF');\n      });\n    }\n    const options = {\n      layer: this,\n      device: this.context.device\n    };\n    const scenegraph = props.getScene(scenegraphData, options);\n    const animator = props.getAnimator(scenegraphData, options);\n    if (scenegraph instanceof GroupNode) {\n      this.state.scenegraph?.destroy();\n      this._applyAnimationsProp(animator, props._animations);\n      const models = [];\n      scenegraph.traverse(node => {\n        if (node instanceof ModelNode) {\n          models.push(node.model);\n        }\n      });\n      this.setState({\n        scenegraph,\n        animator,\n        models\n      });\n      this.getAttributeManager().invalidateAll();\n    } else if (scenegraph !== null) {\n      log.warn('invalid scenegraph:', scenegraph)();\n    }\n  }\n  _applyAnimationsProp(animator, animationsProp) {\n    if (!animator || !animationsProp) {\n      return;\n    }\n    const animations = animator.getAnimations();\n    // sort() to ensure '*' comes first so that other values can override\n    Object.keys(animationsProp).sort().forEach(key => {\n      // Key can be:\n      //  - number for index number\n      //  - name for animation name\n      //  - * to affect all animations\n      const value = animationsProp[key];\n      if (key === '*') {\n        animations.forEach(animation => {\n          Object.assign(animation, value);\n        });\n      } else if (Number.isFinite(Number(key))) {\n        const number = Number(key);\n        if (number >= 0 && number < animations.length) {\n          Object.assign(animations[number], value);\n        } else {\n          log.warn(`animation ${key} not found`)();\n        }\n      } else {\n        const findResult = animations.find(({\n          name\n        }) => name === key);\n        if (findResult) {\n          Object.assign(findResult, value);\n        } else {\n          log.warn(`animation ${key} not found`)();\n        }\n      }\n    });\n  }\n  _getModelOptions() {\n    const {\n      _imageBasedLightingEnvironment\n    } = this.props;\n    let env;\n    if (_imageBasedLightingEnvironment) {\n      if (typeof _imageBasedLightingEnvironment === 'function') {\n        env = _imageBasedLightingEnvironment({\n          gl: this.context.gl,\n          layer: this\n        });\n      } else {\n        env = _imageBasedLightingEnvironment;\n      }\n    }\n    return {\n      imageBasedLightingEnvironment: env,\n      modelOptions: {\n        id: this.props.id,\n        isInstanced: true,\n        bufferLayout: this.getAttributeManager().getBufferLayouts(),\n        ...this.getShaders()\n      },\n      // tangents are not supported\n      useTangents: false\n    };\n  }\n  draw({\n    context\n  }) {\n    if (!this.state.scenegraph) return;\n    if (this.props._animations && this.state.animator) {\n      this.state.animator.animate(context.timeline.getTime());\n      this.setNeedsRedraw();\n    }\n    const {\n      viewport,\n      renderPass\n    } = this.context;\n    const {\n      sizeScale,\n      sizeMinPixels,\n      sizeMaxPixels,\n      coordinateSystem\n    } = this.props;\n    const numInstances = this.getNumInstances();\n    this.state.scenegraph.traverse((node, {\n      worldMatrix\n    }) => {\n      if (node instanceof ModelNode) {\n        const {\n          model\n        } = node;\n        model.setInstanceCount(numInstances);\n        const pbrProjectionProps = {\n          // Needed for PBR (TODO: find better way to get it)\n          camera: model.uniforms.cameraPosition\n        };\n        const scenegraphProps = {\n          sizeScale,\n          sizeMinPixels,\n          sizeMaxPixels,\n          composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),\n          sceneModelMatrix: worldMatrix\n        };\n        model.shaderInputs.setProps({\n          pbrProjection: pbrProjectionProps,\n          scenegraph: scenegraphProps\n        });\n        model.draw(renderPass);\n      }\n    });\n  }\n}\nScenegraphLayer.defaultProps = defaultProps;\nScenegraphLayer.layerName = 'ScenegraphLayer';\nexport default ScenegraphLayer;\n//# sourceMappingURL=scenegraph-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}