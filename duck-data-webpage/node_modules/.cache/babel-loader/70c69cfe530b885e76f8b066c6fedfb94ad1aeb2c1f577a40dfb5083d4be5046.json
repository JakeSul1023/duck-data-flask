{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* global setTimeout clearTimeout */\nimport { getBounds, boundsContain, packVertices, scaleToAspectRatio, getTextureCoordinates } from \"./heatmap-layer-utils.js\";\nimport { TextureTransform } from '@luma.gl/engine';\nimport { AttributeManager, COORDINATE_SYSTEM, log, project32 } from '@deck.gl/core';\nimport TriangleLayer from \"./triangle-layer.js\";\nimport AggregationLayer from \"./aggregation-layer.js\";\nimport { defaultColorRange, colorRangeToFlatArray } from \"../common/utils/color-utils.js\";\nimport weightsVs from \"./weights-vs.glsl.js\";\nimport weightsFs from \"./weights-fs.glsl.js\";\nimport maxVs from \"./max-vs.glsl.js\";\nimport maxFs from \"./max-fs.glsl.js\";\nimport { maxWeightUniforms, weightUniforms } from \"./heatmap-layer-uniforms.js\";\nconst RESOLUTION = 2; // (number of common space pixels) / (number texels)\nconst TEXTURE_PROPS = {\n  format: 'rgba8unorm',\n  mipmaps: false,\n  sampler: {\n    minFilter: 'linear',\n    magFilter: 'linear',\n    addressModeU: 'clamp-to-edge',\n    addressModeV: 'clamp-to-edge'\n  }\n};\nconst DEFAULT_COLOR_DOMAIN = [0, 0];\nconst AGGREGATION_MODE = {\n  SUM: 0,\n  MEAN: 1\n};\nconst defaultProps = {\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  intensity: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  radiusPixels: {\n    type: 'number',\n    min: 1,\n    max: 100,\n    value: 50\n  },\n  colorRange: defaultColorRange,\n  threshold: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 0.05\n  },\n  colorDomain: {\n    type: 'array',\n    value: null,\n    optional: true\n  },\n  // 'SUM' or 'MEAN'\n  aggregation: 'SUM',\n  weightsTextureSize: {\n    type: 'number',\n    min: 128,\n    max: 2048,\n    value: 2048\n  },\n  debounceTimeout: {\n    type: 'number',\n    min: 0,\n    max: 1000,\n    value: 500\n  }\n};\nconst FLOAT_TARGET_FEATURES = ['float32-renderable-webgl',\n// ability to render to float texture\n'texture-blend-float-webgl' // ability to blend when rendering to float texture\n];\nconst DIMENSIONS = {\n  data: {\n    props: ['radiusPixels']\n  }\n};\n/** Visualizes the spatial distribution of data. */\nclass HeatmapLayer extends AggregationLayer {\n  getShaders(shaders) {\n    let modules = [project32];\n    if (shaders.modules) {\n      modules = [...modules, ...shaders.modules];\n    }\n    return super.getShaders({\n      ...shaders,\n      modules\n    });\n  }\n  initializeState() {\n    super.initializeAggregationLayer(DIMENSIONS);\n    this.setState({\n      colorDomain: DEFAULT_COLOR_DOMAIN\n    });\n    this._setupTextureParams();\n    this._setupAttributes();\n    this._setupResources();\n  }\n  shouldUpdateState(_ref) {\n    let {\n      changeFlags\n    } = _ref;\n    // Need to be updated when viewport changes\n    return changeFlags.somethingChanged;\n  }\n  /* eslint-disable max-statements,complexity */\n  updateState(opts) {\n    super.updateState(opts);\n    this._updateHeatmapState(opts);\n  }\n  _updateHeatmapState(opts) {\n    const {\n      props,\n      oldProps\n    } = opts;\n    const changeFlags = this._getChangeFlags(opts);\n    if (changeFlags.dataChanged || changeFlags.viewportChanged) {\n      // if data is changed, do not debounce and immediately update the weight map\n      changeFlags.boundsChanged = this._updateBounds(changeFlags.dataChanged);\n      this._updateTextureRenderingBounds();\n    }\n    if (changeFlags.dataChanged || changeFlags.boundsChanged) {\n      // Update weight map immediately\n      clearTimeout(this.state.updateTimer);\n      this.setState({\n        isWeightMapDirty: true\n      });\n    } else if (changeFlags.viewportZoomChanged) {\n      // Update weight map when zoom stops\n      this._debouncedUpdateWeightmap();\n    }\n    if (props.colorRange !== oldProps.colorRange) {\n      this._updateColorTexture(opts);\n    }\n    if (this.state.isWeightMapDirty) {\n      this._updateWeightmap();\n    }\n    this.setState({\n      zoom: opts.context.viewport.zoom\n    });\n  }\n  renderLayers() {\n    const {\n      weightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      maxWeightsTexture,\n      colorTexture,\n      colorDomain\n    } = this.state;\n    const {\n      updateTriggers,\n      intensity,\n      threshold,\n      aggregation\n    } = this.props;\n    const TriangleLayerClass = this.getSubLayerClass('triangle', TriangleLayer);\n    return new TriangleLayerClass(this.getSubLayerProps({\n      id: 'triangle-layer',\n      updateTriggers\n    }), {\n      // position buffer is filled with world coordinates generated from viewport.unproject\n      // i.e. LNGLAT if geospatial, CARTESIAN otherwise\n      coordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n      data: {\n        attributes: {\n          positions: triPositionBuffer,\n          texCoords: triTexCoordBuffer\n        }\n      },\n      vertexCount: 4,\n      maxTexture: maxWeightsTexture,\n      colorTexture,\n      aggregationMode: AGGREGATION_MODE[aggregation] || 0,\n      weightsTexture,\n      intensity,\n      threshold,\n      colorDomain\n    });\n  }\n  finalizeState(context) {\n    super.finalizeState(context);\n    const {\n      weightsTransform,\n      weightsTexture,\n      maxWeightTransform,\n      maxWeightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      colorTexture,\n      updateTimer\n    } = this.state;\n    weightsTransform?.destroy();\n    weightsTexture?.destroy();\n    maxWeightTransform?.destroy();\n    maxWeightsTexture?.destroy();\n    triPositionBuffer?.destroy();\n    triTexCoordBuffer?.destroy();\n    colorTexture?.destroy();\n    if (updateTimer) {\n      clearTimeout(updateTimer);\n    }\n  }\n  // PRIVATE\n  // override Composite layer private method to create AttributeManager instance\n  _getAttributeManager() {\n    return new AttributeManager(this.context.device, {\n      id: this.props.id,\n      stats: this.context.stats\n    });\n  }\n  _getChangeFlags(opts) {\n    const changeFlags = {};\n    const {\n      dimensions\n    } = this.state;\n    changeFlags.dataChanged = this.isAttributeChanged() && 'attribute changed' ||\n    // if any attribute is changed\n    this.isAggregationDirty(opts, {\n      compareAll: true,\n      dimension: dimensions.data\n    }) && 'aggregation is dirty';\n    changeFlags.viewportChanged = opts.changeFlags.viewportChanged;\n    const {\n      zoom\n    } = this.state;\n    if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {\n      changeFlags.viewportZoomChanged = true;\n    }\n    return changeFlags;\n  }\n  _createTextures() {\n    const {\n      textureSize,\n      format\n    } = this.state;\n    this.setState({\n      weightsTexture: this.context.device.createTexture({\n        ...TEXTURE_PROPS,\n        width: textureSize,\n        height: textureSize,\n        format\n      }),\n      maxWeightsTexture: this.context.device.createTexture({\n        ...TEXTURE_PROPS,\n        width: 1,\n        height: 1,\n        format\n      })\n    });\n  }\n  _setupAttributes() {\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {\n        size: 3,\n        type: 'float64',\n        accessor: 'getPosition'\n      },\n      weights: {\n        size: 1,\n        accessor: 'getWeight'\n      }\n    });\n    this.setState({\n      positionAttributeName: 'positions'\n    });\n  }\n  _setupTextureParams() {\n    const {\n      device\n    } = this.context;\n    const {\n      weightsTextureSize\n    } = this.props;\n    const textureSize = Math.min(weightsTextureSize, device.limits.maxTextureDimension2D);\n    const floatTargetSupport = FLOAT_TARGET_FEATURES.every(feature => device.features.has(feature));\n    const format = floatTargetSupport ? 'rgba32float' : 'rgba8unorm';\n    const weightsScale = floatTargetSupport ? 1 : 1 / 255;\n    this.setState({\n      textureSize,\n      format,\n      weightsScale\n    });\n    if (!floatTargetSupport) {\n      log.warn(`HeatmapLayer: ${this.id} rendering to float texture not supported, falling back to low precision format`)();\n    }\n  }\n  _createWeightsTransform(shaders) {\n    let {\n      weightsTransform\n    } = this.state;\n    const {\n      weightsTexture\n    } = this.state;\n    const attributeManager = this.getAttributeManager();\n    weightsTransform?.destroy();\n    weightsTransform = new TextureTransform(this.context.device, {\n      id: `${this.id}-weights-transform`,\n      bufferLayout: attributeManager.getBufferLayouts(),\n      vertexCount: 1,\n      targetTexture: weightsTexture,\n      parameters: {\n        depthWriteEnabled: false,\n        blendColorOperation: 'add',\n        blendColorSrcFactor: 'one',\n        blendColorDstFactor: 'one',\n        blendAlphaSrcFactor: 'one',\n        blendAlphaDstFactor: 'one'\n      },\n      topology: 'point-list',\n      ...shaders,\n      modules: [...shaders.modules, weightUniforms]\n    });\n    this.setState({\n      weightsTransform\n    });\n  }\n  _setupResources() {\n    this._createTextures();\n    const {\n      device\n    } = this.context;\n    const {\n      textureSize,\n      weightsTexture,\n      maxWeightsTexture\n    } = this.state;\n    const weightsTransformShaders = this.getShaders({\n      vs: weightsVs,\n      fs: weightsFs\n    });\n    this._createWeightsTransform(weightsTransformShaders);\n    const maxWeightsTransformShaders = this.getShaders({\n      vs: maxVs,\n      fs: maxFs,\n      modules: [maxWeightUniforms]\n    });\n    const maxWeightTransform = new TextureTransform(device, {\n      id: `${this.id}-max-weights-transform`,\n      targetTexture: maxWeightsTexture,\n      ...maxWeightsTransformShaders,\n      vertexCount: textureSize * textureSize,\n      topology: 'point-list',\n      parameters: {\n        depthWriteEnabled: false,\n        blendColorOperation: 'max',\n        blendAlphaOperation: 'max',\n        blendColorSrcFactor: 'one',\n        blendColorDstFactor: 'one',\n        blendAlphaSrcFactor: 'one',\n        blendAlphaDstFactor: 'one'\n      }\n    });\n    const maxWeightProps = {\n      inTexture: weightsTexture,\n      textureSize\n    };\n    maxWeightTransform.model.shaderInputs.setProps({\n      maxWeight: maxWeightProps\n    });\n    this.setState({\n      weightsTexture,\n      maxWeightsTexture,\n      maxWeightTransform,\n      zoom: null,\n      triPositionBuffer: device.createBuffer({\n        byteLength: 48\n      }),\n      triTexCoordBuffer: device.createBuffer({\n        byteLength: 48\n      })\n    });\n  }\n  // overwrite super class method to update transform model\n  updateShaders(shaderOptions) {\n    // shader params (modules, injects) changed, update model object\n    this._createWeightsTransform({\n      vs: weightsVs,\n      fs: weightsFs,\n      ...shaderOptions\n    });\n  }\n  _updateMaxWeightValue() {\n    const {\n      maxWeightTransform\n    } = this.state;\n    maxWeightTransform.run({\n      parameters: {\n        viewport: [0, 0, 1, 1]\n      },\n      clearColor: [0, 0, 0, 0]\n    });\n  }\n  // Computes world bounds area that needs to be processed for generate heatmap\n  _updateBounds() {\n    let forceUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const {\n      viewport\n    } = this.context;\n    // Unproject all 4 corners of the current screen coordinates into world coordinates (lng/lat)\n    // Takes care of viewport has non zero bearing/pitch (i.e axis not aligned with world coordiante system)\n    const viewportCorners = [viewport.unproject([0, 0]), viewport.unproject([viewport.width, 0]), viewport.unproject([0, viewport.height]), viewport.unproject([viewport.width, viewport.height])].map(p => p.map(Math.fround));\n    // #1: get world bounds for current viewport extends\n    const visibleWorldBounds = getBounds(viewportCorners); // TODO: Change to visible bounds\n    const newState = {\n      visibleWorldBounds,\n      viewportCorners\n    };\n    let boundsChanged = false;\n    if (forceUpdate || !this.state.worldBounds || !boundsContain(this.state.worldBounds, visibleWorldBounds)) {\n      // #2 : convert world bounds to common (Flat) bounds\n      // #3 : extend common bounds to match aspect ratio with viewport\n      const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);\n      // #4 :convert aligned common bounds to world bounds\n      const worldBounds = this._commonToWorldBounds(scaledCommonBounds);\n      // Clip webmercator projection limits\n      if (this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n        worldBounds[1] = Math.max(worldBounds[1], -85.051129);\n        worldBounds[3] = Math.min(worldBounds[3], 85.051129);\n        worldBounds[0] = Math.max(worldBounds[0], -360);\n        worldBounds[2] = Math.min(worldBounds[2], 360);\n      }\n      // #5: now convert world bounds to common using Layer's coordiante system and origin\n      const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);\n      newState.worldBounds = worldBounds;\n      newState.normalizedCommonBounds = normalizedCommonBounds;\n      boundsChanged = true;\n    }\n    this.setState(newState);\n    return boundsChanged;\n  }\n  _updateTextureRenderingBounds() {\n    // Just render visible portion of the texture\n    const {\n      triPositionBuffer,\n      triTexCoordBuffer,\n      normalizedCommonBounds,\n      viewportCorners\n    } = this.state;\n    const {\n      viewport\n    } = this.context;\n    triPositionBuffer.write(packVertices(viewportCorners, 3));\n    const textureBounds = viewportCorners.map(p => getTextureCoordinates(viewport.projectPosition(p), normalizedCommonBounds));\n    triTexCoordBuffer.write(packVertices(textureBounds, 2));\n  }\n  _updateColorTexture(opts) {\n    const {\n      colorRange\n    } = opts.props;\n    let {\n      colorTexture\n    } = this.state;\n    const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);\n    if (colorTexture && colorTexture?.width === colorRange.length) {\n      // TODO(v9): Unclear whether `setSubImageData` is a public API, or what to use if not.\n      colorTexture.setTexture2DData({\n        data: colors\n      });\n    } else {\n      colorTexture?.destroy();\n      // @ts-expect-error TODO(ib) - texture API change\n      colorTexture = this.context.device.createTexture({\n        ...TEXTURE_PROPS,\n        data: colors,\n        width: colorRange.length,\n        height: 1\n      });\n    }\n    this.setState({\n      colorTexture\n    });\n  }\n  _updateWeightmap() {\n    const {\n      radiusPixels,\n      colorDomain,\n      aggregation\n    } = this.props;\n    const {\n      worldBounds,\n      textureSize,\n      weightsScale,\n      weightsTexture\n    } = this.state;\n    const weightsTransform = this.state.weightsTransform;\n    this.state.isWeightMapDirty = false;\n    // convert world bounds to common using Layer's coordiante system and origin\n    const commonBounds = this._worldToCommonBounds(worldBounds, {\n      useLayerCoordinateSystem: true\n    });\n    if (colorDomain && aggregation === 'SUM') {\n      // scale color domain to weight per pixel\n      const {\n        viewport\n      } = this.context;\n      const metersPerPixel = viewport.distanceScales.metersPerUnit[2] * (commonBounds[2] - commonBounds[0]) / textureSize;\n      this.state.colorDomain = colorDomain.map(x => x * metersPerPixel * weightsScale);\n    } else {\n      this.state.colorDomain = colorDomain || DEFAULT_COLOR_DOMAIN;\n    }\n    const attributeManager = this.getAttributeManager();\n    const attributes = attributeManager.getAttributes();\n    const moduleSettings = this.getModuleSettings();\n    this._setModelAttributes(weightsTransform.model, attributes);\n    weightsTransform.model.setVertexCount(this.getNumInstances());\n    const weightProps = {\n      radiusPixels,\n      commonBounds,\n      textureWidth: textureSize,\n      weightsScale,\n      weightsTexture: weightsTexture\n    };\n    const {\n      viewport,\n      devicePixelRatio,\n      coordinateSystem,\n      coordinateOrigin\n    } = moduleSettings;\n    const {\n      modelMatrix\n    } = this.props;\n    weightsTransform.model.shaderInputs.setProps({\n      project: {\n        viewport,\n        devicePixelRatio,\n        modelMatrix,\n        coordinateSystem,\n        coordinateOrigin\n      },\n      weight: weightProps\n    });\n    weightsTransform.run({\n      parameters: {\n        viewport: [0, 0, textureSize, textureSize]\n      },\n      clearColor: [0, 0, 0, 0]\n    });\n    this._updateMaxWeightValue();\n  }\n  _debouncedUpdateWeightmap() {\n    let fromTimer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let {\n      updateTimer\n    } = this.state;\n    const {\n      debounceTimeout\n    } = this.props;\n    if (fromTimer) {\n      updateTimer = null;\n      // update\n      this._updateBounds(true);\n      this._updateTextureRenderingBounds();\n      this.setState({\n        isWeightMapDirty: true\n      });\n    } else {\n      this.setState({\n        isWeightMapDirty: false\n      });\n      clearTimeout(updateTimer);\n      updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), debounceTimeout);\n    }\n    this.setState({\n      updateTimer\n    });\n  }\n  // input: worldBounds: [minLong, minLat, maxLong, maxLat]\n  // input: opts.useLayerCoordinateSystem : layers coordiante system is used\n  // optput: commonBounds: [minX, minY, maxX, maxY] scaled to fit the current texture\n  _worldToCommonBounds(worldBounds) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      useLayerCoordinateSystem = false\n    } = opts;\n    const [minLong, minLat, maxLong, maxLat] = worldBounds;\n    const {\n      viewport\n    } = this.context;\n    const {\n      textureSize\n    } = this.state;\n    const {\n      coordinateSystem\n    } = this.props;\n    const offsetMode = useLayerCoordinateSystem && (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS);\n    const offsetOriginCommon = offsetMode ? viewport.projectPosition(this.props.coordinateOrigin) : [0, 0];\n    const size = textureSize * RESOLUTION / viewport.scale;\n    let bottomLeftCommon;\n    let topRightCommon;\n    // Y-axis is flipped between World and Common bounds\n    if (useLayerCoordinateSystem && !offsetMode) {\n      bottomLeftCommon = this.projectPosition([minLong, minLat, 0]);\n      topRightCommon = this.projectPosition([maxLong, maxLat, 0]);\n    } else {\n      bottomLeftCommon = viewport.projectPosition([minLong, minLat, 0]);\n      topRightCommon = viewport.projectPosition([maxLong, maxLat, 0]);\n    }\n    // Ignore z component\n    return scaleToAspectRatio([bottomLeftCommon[0] - offsetOriginCommon[0], bottomLeftCommon[1] - offsetOriginCommon[1], topRightCommon[0] - offsetOriginCommon[0], topRightCommon[1] - offsetOriginCommon[1]], size, size);\n  }\n  // input commonBounds: [xMin, yMin, xMax, yMax]\n  // output worldBounds: [minLong, minLat, maxLong, maxLat]\n  _commonToWorldBounds(commonBounds) {\n    const [xMin, yMin, xMax, yMax] = commonBounds;\n    const {\n      viewport\n    } = this.context;\n    const bottomLeftWorld = viewport.unprojectPosition([xMin, yMin]);\n    const topRightWorld = viewport.unprojectPosition([xMax, yMax]);\n    return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));\n  }\n}\nHeatmapLayer.layerName = 'HeatmapLayer';\nHeatmapLayer.defaultProps = defaultProps;\nexport default HeatmapLayer;\n//# sourceMappingURL=heatmap-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}