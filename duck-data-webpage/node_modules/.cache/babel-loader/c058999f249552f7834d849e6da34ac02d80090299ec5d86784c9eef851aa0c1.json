{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Hash } from \"./hash.js\";\nimport CRC32 from \"./algorithms/crc32.js\";\nimport { encodeNumber } from \"./utils/digest-utils.js\";\n/**\n * Calculates CRC32 Cryptographic Hash\n */\nexport class CRC32Hash extends Hash {\n  name = 'crc32';\n  options;\n  constructor(options = {}) {\n    super();\n    this.options = {\n      crypto: {},\n      ...options\n    };\n    this.hashBatches = this.hashBatches.bind(this);\n  }\n  /**\n   * Atomic hash calculation\n   * @returns base64 encoded hash\n   */\n  async hash(input, encoding) {\n    return this.hashSync(input, encoding);\n  }\n  hashSync(input, encoding) {\n    const hash = new CRC32();\n    hash.update(input);\n    const digest = hash.finalize();\n    return encodeNumber(digest, encoding);\n  }\n  async *hashBatches(asyncIterator, encoding = 'base64') {\n    const hash = new CRC32();\n    for await (const chunk of asyncIterator) {\n      hash.update(chunk);\n      yield chunk;\n    }\n    const digest = hash.finalize();\n    this.options.crypto?.onEnd?.({\n      hash: encodeNumber(digest, encoding)\n    });\n  }\n}","map":{"version":3,"names":["Hash","CRC32","encodeNumber","CRC32Hash","name","options","constructor","crypto","hashBatches","bind","hash","input","encoding","hashSync","update","digest","finalize","asyncIterator","chunk","onEnd"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/crypto/dist/lib/crc32-hash.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Hash } from \"./hash.js\";\nimport CRC32 from \"./algorithms/crc32.js\";\nimport { encodeNumber } from \"./utils/digest-utils.js\";\n/**\n * Calculates CRC32 Cryptographic Hash\n */\nexport class CRC32Hash extends Hash {\n    name = 'crc32';\n    options;\n    constructor(options = {}) {\n        super();\n        this.options = { crypto: {}, ...options };\n        this.hashBatches = this.hashBatches.bind(this);\n    }\n    /**\n     * Atomic hash calculation\n     * @returns base64 encoded hash\n     */\n    async hash(input, encoding) {\n        return this.hashSync(input, encoding);\n    }\n    hashSync(input, encoding) {\n        const hash = new CRC32();\n        hash.update(input);\n        const digest = hash.finalize();\n        return encodeNumber(digest, encoding);\n    }\n    async *hashBatches(asyncIterator, encoding = 'base64') {\n        const hash = new CRC32();\n        for await (const chunk of asyncIterator) {\n            hash.update(chunk);\n            yield chunk;\n        }\n        const digest = hash.finalize();\n        this.options.crypto?.onEnd?.({ hash: encodeNumber(digest, encoding) });\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,IAAI,QAAQ,WAAW;AAChC,OAAOC,KAAK,MAAM,uBAAuB;AACzC,SAASC,YAAY,QAAQ,yBAAyB;AACtD;AACA;AACA;AACA,OAAO,MAAMC,SAAS,SAASH,IAAI,CAAC;EAChCI,IAAI,GAAG,OAAO;EACdC,OAAO;EACPC,WAAWA,CAACD,OAAO,GAAG,CAAC,CAAC,EAAE;IACtB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,OAAO,GAAG;MAAEE,MAAM,EAAE,CAAC,CAAC;MAAE,GAAGF;IAAQ,CAAC;IACzC,IAAI,CAACG,WAAW,GAAG,IAAI,CAACA,WAAW,CAACC,IAAI,CAAC,IAAI,CAAC;EAClD;EACA;AACJ;AACA;AACA;EACI,MAAMC,IAAIA,CAACC,KAAK,EAAEC,QAAQ,EAAE;IACxB,OAAO,IAAI,CAACC,QAAQ,CAACF,KAAK,EAAEC,QAAQ,CAAC;EACzC;EACAC,QAAQA,CAACF,KAAK,EAAEC,QAAQ,EAAE;IACtB,MAAMF,IAAI,GAAG,IAAIT,KAAK,CAAC,CAAC;IACxBS,IAAI,CAACI,MAAM,CAACH,KAAK,CAAC;IAClB,MAAMI,MAAM,GAAGL,IAAI,CAACM,QAAQ,CAAC,CAAC;IAC9B,OAAOd,YAAY,CAACa,MAAM,EAAEH,QAAQ,CAAC;EACzC;EACA,OAAOJ,WAAWA,CAACS,aAAa,EAAEL,QAAQ,GAAG,QAAQ,EAAE;IACnD,MAAMF,IAAI,GAAG,IAAIT,KAAK,CAAC,CAAC;IACxB,WAAW,MAAMiB,KAAK,IAAID,aAAa,EAAE;MACrCP,IAAI,CAACI,MAAM,CAACI,KAAK,CAAC;MAClB,MAAMA,KAAK;IACf;IACA,MAAMH,MAAM,GAAGL,IAAI,CAACM,QAAQ,CAAC,CAAC;IAC9B,IAAI,CAACX,OAAO,CAACE,MAAM,EAAEY,KAAK,GAAG;MAAET,IAAI,EAAER,YAAY,CAACa,MAAM,EAAEH,QAAQ;IAAE,CAAC,CAAC;EAC1E;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}