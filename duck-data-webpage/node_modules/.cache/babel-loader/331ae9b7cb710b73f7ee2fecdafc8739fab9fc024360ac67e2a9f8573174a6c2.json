{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\nimport { setGLParameters } from \"../../context/parameters/unified-parameter-api.js\";\n/* eslint-disable no-unused-expressions */ // For expression ? gl.enable() : gl.disable()\n/**\n * Execute a function with a set of temporary WebGL parameter overrides\n * - Saves current \"global\" WebGL context settings\n * - Sets the supplies WebGL context parameters,\n * - Executes supplied function\n * - Restores parameters\n * - Returns the return value of the supplied function\n */\nexport function withDeviceAndGLParameters(device, parameters, glParameters, func) {\n  if (isObjectEmpty(parameters)) {\n    // Avoid setting state if no parameters provided. Just call and return\n    return func(device);\n  }\n  // Wrap in a try-catch to ensure that parameters are restored on exceptions\n  const webglDevice = device;\n  webglDevice.pushState();\n  try {\n    setDeviceParameters(device, parameters);\n    setGLParameters(webglDevice.gl, glParameters);\n    return func(device);\n  } finally {\n    webglDevice.popState();\n  }\n}\n/**\n * Execute a function with a set of temporary WebGL parameter overrides\n * - Saves current \"global\" WebGL context settings\n * - Sets the supplies WebGL context parameters,\n * - Executes supplied function\n * - Restores parameters\n * - Returns the return value of the supplied function\n * @deprecated use withDeviceParameters instead\n */\nexport function withGLParameters(device, parameters, func) {\n  if (isObjectEmpty(parameters)) {\n    // Avoid setting state if no parameters provided. Just call and return\n    return func(device);\n  }\n  // Wrap in a try-catch to ensure that parameters are restored on exceptions\n  const webglDevice = device;\n  webglDevice.pushState();\n  try {\n    setGLParameters(webglDevice.gl, parameters);\n    return func(device);\n  } finally {\n    webglDevice.popState();\n  }\n}\n/**\n * Execute a function with a set of temporary WebGL parameter overrides\n * - Saves current \"global\" WebGL context settings\n * - Sets the supplies WebGL context parameters,\n * - Executes supplied function\n * - Restores parameters\n * - Returns the return value of the supplied function\n */\nexport function withDeviceParameters(device, parameters, func) {\n  if (isObjectEmpty(parameters)) {\n    // Avoid setting state if no parameters provided. Just call and return\n    return func(device);\n  }\n  // Wrap in a try-catch to ensure that parameters are restored on exceptions'\n  const webglDevice = device;\n  webglDevice.pushState();\n  try {\n    setDeviceParameters(device, parameters);\n    return func(device);\n  } finally {\n    webglDevice.popState();\n  }\n}\n/** Set WebGPU Style Parameters */\nexport function setDeviceParameters(device, parameters) {\n  const webglDevice = device;\n  const {\n    gl\n  } = webglDevice;\n  // RASTERIZATION SETTINGS\n  if (parameters.cullMode) {\n    switch (parameters.cullMode) {\n      case 'none':\n        gl.disable(2884);\n        break;\n      case 'front':\n        gl.enable(2884);\n        gl.cullFace(1028);\n        break;\n      case 'back':\n        gl.enable(2884);\n        gl.cullFace(1029);\n        break;\n    }\n  }\n  if (parameters.frontFace) {\n    gl.frontFace(map('frontFace', parameters.frontFace, {\n      ccw: 2305,\n      cw: 2304\n    }));\n  }\n  if (parameters.unclippedDepth) {\n    if (device.features.has('depth-clip-control')) {\n      // EXT_depth_clamp\n      gl.enable(34383);\n    }\n  }\n  if (parameters.depthBias !== undefined) {\n    gl.enable(32823);\n    gl.polygonOffset(parameters.depthBias, parameters.depthBiasSlopeScale || 0);\n  }\n  // depthBiasSlopeScale: {\n  //   // Handled by depthBias\n  // },\n  // WEBGL EXTENSIONS\n  if (parameters.provokingVertex) {\n    if (device.features.has('provoking-vertex-webgl')) {\n      const extensions = webglDevice.getExtension('WEBGL_provoking_vertex');\n      const ext = extensions.WEBGL_provoking_vertex;\n      const vertex = map('provokingVertex', parameters.provokingVertex, {\n        first: 36429,\n        last: 36430\n      });\n      ext?.provokingVertexWEBGL(vertex);\n    }\n  }\n  if (parameters.polygonMode || parameters.polygonOffsetLine) {\n    if (device.features.has('polygon-mode-webgl')) {\n      if (parameters.polygonMode) {\n        const extensions = webglDevice.getExtension('WEBGL_polygon_mode');\n        const ext = extensions.WEBGL_polygon_mode;\n        const mode = map('polygonMode', parameters.polygonMode, {\n          fill: 6914,\n          line: 6913\n        });\n        ext?.polygonModeWEBGL(1028, mode);\n        ext?.polygonModeWEBGL(1029, mode);\n      }\n      if (parameters.polygonOffsetLine) {\n        gl.enable(10754);\n      }\n    }\n  }\n  if (device.features.has('shader-clip-cull-distance-webgl')) {\n    if (parameters.clipDistance0) {\n      gl.enable(12288);\n    }\n    if (parameters.clipDistance1) {\n      gl.enable(12289);\n    }\n    if (parameters.clipDistance2) {\n      gl.enable(12290);\n    }\n    if (parameters.clipDistance3) {\n      gl.enable(12291);\n    }\n    if (parameters.clipDistance4) {\n      gl.enable(12292);\n    }\n    if (parameters.clipDistance5) {\n      gl.enable(12293);\n    }\n    if (parameters.clipDistance6) {\n      gl.enable(12294);\n    }\n    if (parameters.clipDistance7) {\n      gl.enable(12295);\n    }\n  }\n  // DEPTH STENCIL\n  if (parameters.depthWriteEnabled !== undefined) {\n    gl.depthMask(mapBoolean('depthWriteEnabled', parameters.depthWriteEnabled));\n  }\n  if (parameters.depthCompare) {\n    parameters.depthCompare !== 'always' ? gl.enable(2929) : gl.disable(2929);\n    gl.depthFunc(convertCompareFunction('depthCompare', parameters.depthCompare));\n  }\n  if (parameters.stencilWriteMask) {\n    const mask = parameters.stencilWriteMask;\n    gl.stencilMaskSeparate(1028, mask);\n    gl.stencilMaskSeparate(1029, mask);\n  }\n  if (parameters.stencilReadMask) {\n    // stencilReadMask is handle inside stencil***Compare.\n    log.warn('stencilReadMask not supported under WebGL');\n  }\n  if (parameters.stencilCompare) {\n    const mask = parameters.stencilReadMask || 0xffffffff;\n    const glValue = convertCompareFunction('depthCompare', parameters.stencilCompare);\n    // TODO - ensure back doesn't overwrite\n    parameters.stencilCompare !== 'always' ? gl.enable(2960) : gl.disable(2960);\n    gl.stencilFuncSeparate(1028, glValue, 0, mask);\n    gl.stencilFuncSeparate(1029, glValue, 0, mask);\n  }\n  if (parameters.stencilPassOperation && parameters.stencilFailOperation && parameters.stencilDepthFailOperation) {\n    const dppass = convertStencilOperation('stencilPassOperation', parameters.stencilPassOperation);\n    const sfail = convertStencilOperation('stencilFailOperation', parameters.stencilFailOperation);\n    const dpfail = convertStencilOperation('stencilDepthFailOperation', parameters.stencilDepthFailOperation);\n    gl.stencilOpSeparate(1028, sfail, dpfail, dppass);\n    gl.stencilOpSeparate(1029, sfail, dpfail, dppass);\n  }\n  // stencilDepthFailOperation() {\n  //   // handled by stencilPassOperation\n  // },\n  // stencilFailOperation() {\n  //   // handled by stencilPassOperation\n  // },\n  // COLOR STATE\n  switch (parameters.blend) {\n    case true:\n      gl.enable(3042);\n      break;\n    case false:\n      gl.disable(3042);\n      break;\n    default:\n    // leave WebGL blend state unchanged if `parameters.blend` is not set\n  }\n  if (parameters.blendColorOperation || parameters.blendAlphaOperation) {\n    const colorEquation = convertBlendOperationToEquation('blendColorOperation', parameters.blendColorOperation || 'add');\n    const alphaEquation = convertBlendOperationToEquation('blendAlphaOperation', parameters.blendAlphaOperation || 'add');\n    gl.blendEquationSeparate(colorEquation, alphaEquation);\n    const colorSrcFactor = convertBlendFactorToFunction('blendColorSrcFactor', parameters.blendColorSrcFactor || 'one');\n    const colorDstFactor = convertBlendFactorToFunction('blendColorDstFactor', parameters.blendColorDstFactor || 'zero');\n    const alphaSrcFactor = convertBlendFactorToFunction('blendAlphaSrcFactor', parameters.blendAlphaSrcFactor || 'one');\n    const alphaDstFactor = convertBlendFactorToFunction('blendAlphaDstFactor', parameters.blendAlphaDstFactor || 'zero');\n    gl.blendFuncSeparate(colorSrcFactor, colorDstFactor, alphaSrcFactor, alphaDstFactor);\n  }\n}\n/*\n      rasterizationState: {\n        cullMode: \"back\",\n      },\n\n      depthStencilState: {\n        depthWriteEnabled: true,\n        depthCompare: \"less\",\n        format: \"depth24plus-stencil8\",\n      },\n\n      colorStates: [\n        {\n          format: \"bgra8unorm\",\n          // colorBlend.srcFactor = wgpu::BlendFactor::SrcAlpha;\n          // colorBlend.dstFactor = wgpu::BlendFactor::OneMinusSrcAlpha;\n          // alphaBlend.srcFactor = wgpu::BlendFactor::SrcAlpha;\n          // alphaBlend.dstFactor = wgpu::BlendFactor::OneMinusSrcAlpha;\n        },\n      ],\n    });\n*/\nexport function convertCompareFunction(parameter, value) {\n  return map(parameter, value, {\n    never: 512,\n    less: 513,\n    equal: 514,\n    'less-equal': 515,\n    greater: 516,\n    'not-equal': 517,\n    'greater-equal': 518,\n    always: 519\n  });\n}\nexport function convertToCompareFunction(parameter, value) {\n  return map(parameter, value, {\n    [512]: 'never',\n    [513]: 'less',\n    [514]: 'equal',\n    [515]: 'less-equal',\n    [516]: 'greater',\n    [517]: 'not-equal',\n    [518]: 'greater-equal',\n    [519]: 'always'\n  });\n}\nfunction convertStencilOperation(parameter, value) {\n  return map(parameter, value, {\n    keep: 7680,\n    zero: 0,\n    replace: 7681,\n    invert: 5386,\n    'increment-clamp': 7682,\n    'decrement-clamp': 7683,\n    'increment-wrap': 34055,\n    'decrement-wrap': 34056\n  });\n}\nfunction convertBlendOperationToEquation(parameter, value) {\n  return map(parameter, value, {\n    add: 32774,\n    subtract: 32778,\n    'reverse-subtract': 32779,\n    min: 32775,\n    max: 32776\n  });\n}\nfunction convertBlendFactorToFunction(parameter, value) {\n  return map(parameter, value, {\n    one: 1,\n    zero: 0,\n    'src-color': 768,\n    'one-minus-src-color': 769,\n    'dst-color': 774,\n    'one-minus-dst-color': 775,\n    'src-alpha': 770,\n    'one-minus-src-alpha': 771,\n    'dst-alpha': 772,\n    'one-minus-dst-alpha': 773,\n    'src-alpha-saturated': 776,\n    'constant-color': 32769,\n    'one-minus-constant-color': 32770,\n    'constant-alpha': 32771,\n    'one-minus-constant-alpha': 32772\n  });\n}\nfunction message(parameter, value) {\n  return `Illegal parameter ${value} for ${parameter}`;\n}\nfunction map(parameter, value, valueMap) {\n  if (!(value in valueMap)) {\n    throw new Error(message(parameter, value));\n  }\n  return valueMap[value];\n}\nfunction mapBoolean(parameter, value) {\n  return value;\n}\n/** Returns true if given object is empty, false otherwise. */\nfunction isObjectEmpty(obj) {\n  let isEmpty = true;\n  // @ts-ignore key is unused\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for (const key in obj) {\n    isEmpty = false;\n    break;\n  }\n  return isEmpty;\n}\n//# sourceMappingURL=device-parameters.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}