{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Framebuffer } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\nimport { getGLTypeFromTypedArray, getTypedArrayFromGLType } from \"./typed-array-utils.js\";\nimport { glFormatToComponents, glTypeToBytes } from \"./format-utils.js\";\nimport { WEBGLTexture } from \"../resources/webgl-texture.js\";\nimport { withGLParameters } from \"../../context/state-tracker/with-parameters.js\";\n/** A \"border\" parameter is required in many WebGL texture APIs, but must always be 0... */\nconst BORDER = 0;\n/**\n * Initializes a texture memory space\n * Clear all the textures and mip levels of a two-dimensional or array texture at the same time.\n * On some implementations faster than repeatedly setting levels\n *\n * @note From WebGL 2 spec section 3.7.6:\n * @see https://registry.khronos.org/webgl/specs/latest/2.0/\n * - The image contents are set as if a buffer of sufficient size initialized to 0 would be passed to each level's texImage2D/3D\n * - texStorage2D should be considered a preferred alternative to texImage2D. It may have lower memory costs than texImage2D in some implementations.\n * - Once texStorage*D has been called, the texture is immutable and can only be updated with texSubImage*(), not texImage()\n */\nexport function initializeTextureStorage(gl, levels, options) {\n  const {\n    dimension,\n    width,\n    height,\n    depth = 0\n  } = options;\n  const {\n    glInternalFormat\n  } = options;\n  const glTarget = options.glTarget; // getWebGLCubeFaceTarget(options.glTarget, dimension, depth);\n  switch (dimension) {\n    case '2d-array':\n    case '3d':\n      gl.texStorage3D(glTarget, levels, glInternalFormat, width, height, depth);\n      break;\n    default:\n      gl.texStorage2D(glTarget, levels, glInternalFormat, width, height);\n  }\n}\n/**\n * Copy a region of compressed data from a GPU memory buffer into this texture.\n */\nexport function copyExternalImageToMipLevel(gl, handle, image, options) {\n  const {\n    width,\n    height\n  } = options;\n  const {\n    dimension,\n    depth = 0,\n    mipLevel = 0\n  } = options;\n  const {\n    x = 0,\n    y = 0,\n    z = 0\n  } = options;\n  const {\n    glFormat,\n    glType\n  } = options;\n  const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);\n  const glParameters = options.flipY ? {\n    [37440]: true\n  } : {};\n  withGLParameters(gl, glParameters, () => {\n    switch (dimension) {\n      case '2d-array':\n      case '3d':\n        gl.bindTexture(glTarget, handle);\n        // prettier-ignore\n        gl.texSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, glType, image);\n        gl.bindTexture(glTarget, null);\n        break;\n      case '2d':\n      case 'cube':\n        gl.bindTexture(glTarget, handle);\n        // prettier-ignore\n        gl.texSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, glType, image);\n        gl.bindTexture(glTarget, null);\n        break;\n      default:\n        throw new Error(dimension);\n    }\n  });\n}\n/**\n * Copy a region of data from a CPU memory buffer into this texture.\n */\nexport function copyCPUDataToMipLevel(gl, typedArray, options) {\n  const {\n    dimension,\n    width,\n    height,\n    depth = 0,\n    mipLevel = 0,\n    byteOffset = 0\n  } = options;\n  const {\n    x = 0,\n    y = 0,\n    z = 0\n  } = options;\n  const {\n    glFormat,\n    glType,\n    compressed\n  } = options;\n  const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);\n  // gl.bindTexture(glTarget, null);\n  switch (dimension) {\n    case '2d-array':\n    case '3d':\n      if (compressed) {\n        // prettier-ignore\n        gl.compressedTexSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, typedArray, byteOffset); // , byteLength\n      } else {\n        // prettier-ignore\n        gl.texSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, glType, typedArray, byteOffset); // , byteLength\n      }\n      break;\n    case '2d':\n    case 'cube':\n      if (compressed) {\n        // prettier-ignore\n        gl.compressedTexSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, typedArray, byteOffset); // , byteLength\n      } else {\n        // prettier-ignore\n        gl.texSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, glType, typedArray, byteOffset); // , byteLength\n      }\n      break;\n    default:\n      throw new Error(dimension);\n  }\n}\n/**\n * Copy a region of compressed data from a GPU memory buffer into this texture.\n */\nexport function copyGPUBufferToMipLevel(gl, webglBuffer, byteLength, options) {\n  const {\n    dimension,\n    width,\n    height,\n    depth = 0,\n    mipLevel = 0,\n    byteOffset = 0\n  } = options;\n  const {\n    x = 0,\n    y = 0,\n    z = 0\n  } = options;\n  const {\n    glFormat,\n    glType,\n    compressed\n  } = options;\n  const glTarget = getWebGLCubeFaceTarget(options.glTarget, dimension, depth);\n  gl.bindBuffer(35052, webglBuffer);\n  switch (dimension) {\n    case '2d-array':\n    case '3d':\n      // 3 dimensional textures requires 3D texture functions\n      if (compressed) {\n        // TODO enable extension?\n        // prettier-ignore\n        gl.compressedTexSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, byteLength, byteOffset);\n      } else {\n        // prettier-ignore\n        gl.texSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, glType, byteOffset);\n      }\n      break;\n    case '2d':\n    case 'cube':\n      if (compressed) {\n        // prettier-ignore\n        gl.compressedTexSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, byteLength, byteOffset);\n      } else {\n        // prettier-ignore\n        gl.texSubImage2D(glTarget, mipLevel, x, y, width, height, BORDER, glFormat, byteOffset);\n      }\n      break;\n    default:\n      throw new Error(dimension);\n  }\n}\n// INTERNAL HELPERS\n/** Convert a WebGPU style texture constant to a WebGL style texture constant */\nexport function getWebGLTextureTarget(dimension) {\n  // prettier-ignore\n  switch (dimension) {\n    case '1d':\n      break;\n    // not supported in any WebGL version\n    case '2d':\n      return 3553;\n    // supported in WebGL1\n    case '3d':\n      return 32879;\n    // supported in WebGL2\n    case 'cube':\n      return 34067;\n    // supported in WebGL1\n    case '2d-array':\n      return 35866;\n    // supported in WebGL2\n    case 'cube-array':\n      break;\n    // not supported in any WebGL version\n  }\n  throw new Error(dimension);\n}\n/**\n * In WebGL, cube maps specify faces by overriding target instead of using the depth parameter.\n * @note We still bind the texture using GL.TEXTURE_CUBE_MAP, but we need to use the face-specific target when setting mip levels.\n * @returns glTarget unchanged, if dimension !== 'cube'.\n */\nexport function getWebGLCubeFaceTarget(glTarget, dimension, level) {\n  return dimension === 'cube' ? 34069 + level : glTarget;\n}\n/**\n * Copies data from a type  or a Texture object into ArrayBuffer object.\n * App can provide targetPixelArray or have it auto allocated by this method\n *  newly allocated by this method unless provided by app.\n * @deprecated Use CommandEncoder.copyTextureToBuffer and Buffer.read\n * @note Slow requires roundtrip to GPU\n *\n * @param source\n * @param options\n * @returns pixel array,\n */\nexport function readPixelsToArray(source, options) {\n  const {\n    sourceX = 0,\n    sourceY = 0,\n    sourceAttachment = 0 // TODO - support gl.readBuffer\n  } = options || {};\n  let {\n    target = null,\n    // following parameters are auto deduced if not provided\n    sourceWidth,\n    sourceHeight,\n    sourceDepth,\n    sourceFormat,\n    sourceType\n  } = options || {};\n  const {\n    framebuffer,\n    deleteFramebuffer\n  } = getFramebuffer(source);\n  // assert(framebuffer);\n  const {\n    gl,\n    handle\n  } = framebuffer;\n  sourceWidth ||= framebuffer.width;\n  sourceHeight ||= framebuffer.height;\n  const texture = framebuffer.colorAttachments[sourceAttachment]?.texture;\n  if (!texture) {\n    throw new Error(`Invalid framebuffer attachment ${sourceAttachment}`);\n  }\n  sourceDepth = texture?.depth || 1;\n  sourceFormat ||= texture?.glFormat || 6408;\n  // Deduce the type from color attachment if not provided.\n  sourceType ||= texture?.glType || 5121;\n  // Deduce type and allocated pixelArray if needed\n  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight, sourceDepth);\n  // Pixel array available, if necessary, deduce type from it.\n  sourceType = sourceType || getGLTypeFromTypedArray(target);\n  // Note: luma.gl overrides bindFramebuffer so that we can reliably restore the previous framebuffer (this is the only function for which we do that)\n  const prevHandle = gl.bindFramebuffer(36160, handle);\n  // Select the color attachment to read from\n  gl.readBuffer(36064 + sourceAttachment);\n  // There is a lot of hedging in the WebGL2 spec about what formats are guaranteed to be readable\n  // (It should always be possible to read RGBA/UNSIGNED_BYTE, but most other combinations are not guaranteed)\n  // Querying is possible but expensive:\n  // const {device} = framebuffer;\n  // texture.glReadFormat ||= gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT);\n  // texture.glReadType ||= gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE);\n  // console.log('params', device.getGLKey(texture.glReadFormat), device.getGLKey(texture.glReadType));\n  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);\n  gl.readBuffer(36064);\n  gl.bindFramebuffer(36160, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.destroy();\n  }\n  return target;\n}\n/**\n * Copies data from a Framebuffer or a Texture object into a Buffer object.\n * NOTE: doesn't wait for copy to be complete, it programs GPU to perform a DMA transffer.\n * @deprecated Use CommandEncoder\n * @param source\n * @param options\n */\nexport function readPixelsToBuffer(source, options) {\n  const {\n    target,\n    sourceX = 0,\n    sourceY = 0,\n    sourceFormat = 6408,\n    targetByteOffset = 0\n  } = options || {};\n  // following parameters are auto deduced if not provided\n  let {\n    sourceWidth,\n    sourceHeight,\n    sourceType\n  } = options || {};\n  const {\n    framebuffer,\n    deleteFramebuffer\n  } = getFramebuffer(source);\n  // assert(framebuffer);\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n  // Asynchronous read (PIXEL_PACK_BUFFER) is WebGL2 only feature\n  const webglFramebuffer = framebuffer;\n  // deduce type if not available.\n  sourceType = sourceType || 5121;\n  let webglBufferTarget = target;\n  if (!webglBufferTarget) {\n    // Create new buffer with enough size\n    const components = glFormatToComponents(sourceFormat);\n    const byteCount = glTypeToBytes(sourceType);\n    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;\n    webglBufferTarget = webglFramebuffer.device.createBuffer({\n      byteLength\n    });\n  }\n  // TODO(donmccurdy): Do we have tests to confirm this is working?\n  const commandEncoder = source.device.createCommandEncoder();\n  commandEncoder.copyTextureToBuffer({\n    sourceTexture: source,\n    width: sourceWidth,\n    height: sourceHeight,\n    origin: [sourceX, sourceY],\n    destinationBuffer: webglBufferTarget,\n    byteOffset: targetByteOffset\n  });\n  commandEncoder.destroy();\n  if (deleteFramebuffer) {\n    framebuffer.destroy();\n  }\n  return webglBufferTarget;\n}\n/**\n * Copy a rectangle from a Framebuffer or Texture object into a texture (at an offset)\n * @deprecated Use CommandEncoder\n */\n// eslint-disable-next-line complexity, max-statements\nexport function copyToTexture(sourceTexture, destinationTexture, options) {\n  const {\n    sourceX = 0,\n    sourceY = 0,\n    // attachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetMipmaplevel = 0,\n    targetInternalFormat = 6408\n  } = options || {};\n  let {\n    targetX,\n    targetY,\n    targetZ,\n    width,\n    // defaults to target width\n    height // defaults to target height\n  } = options || {};\n  const {\n    framebuffer,\n    deleteFramebuffer\n  } = getFramebuffer(sourceTexture);\n  // assert(framebuffer);\n  const webglFramebuffer = framebuffer;\n  const {\n    device,\n    handle\n  } = webglFramebuffer;\n  const isSubCopy = typeof targetX !== 'undefined' || typeof targetY !== 'undefined' || typeof targetZ !== 'undefined';\n  targetX = targetX || 0;\n  targetY = targetY || 0;\n  targetZ = targetZ || 0;\n  const prevHandle = device.gl.bindFramebuffer(36160, handle);\n  // TODO - support gl.readBuffer (WebGL2 only)\n  // const prevBuffer = gl.readBuffer(attachment);\n  // assert(target);\n  let texture = null;\n  let textureTarget;\n  if (destinationTexture instanceof WEBGLTexture) {\n    texture = destinationTexture;\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n    texture?.bind(0);\n    // @ts-ignore\n    textureTarget = texture.target;\n  } else {\n    // @ts-ignore\n    textureTarget = target;\n  }\n  if (!isSubCopy) {\n    device.gl.copyTexImage2D(textureTarget, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0 /* border must be 0 */);\n  } else {\n    switch (textureTarget) {\n      case 3553:\n      case 34067:\n        device.gl.copyTexSubImage2D(textureTarget, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);\n        break;\n      case 35866:\n      case 32879:\n        device.gl.copyTexSubImage3D(textureTarget, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);\n        break;\n      default:\n    }\n  }\n  if (texture) {\n    texture.unbind();\n  }\n  // @ts-expect-error\n  device.gl.bindFramebuffer(36160, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.destroy();\n  }\n  return texture;\n}\nfunction getFramebuffer(source) {\n  if (!(source instanceof Framebuffer)) {\n    return {\n      framebuffer: toFramebuffer(source),\n      deleteFramebuffer: true\n    };\n  }\n  return {\n    framebuffer: source,\n    deleteFramebuffer: false\n  };\n}\n/**\n * Wraps a given texture into a framebuffer object, that can be further used\n * to read data from the texture object.\n */\nexport function toFramebuffer(texture, props) {\n  const {\n    device,\n    width,\n    height,\n    id\n  } = texture;\n  const framebuffer = device.createFramebuffer({\n    ...props,\n    id: `framebuffer-for-${id}`,\n    width,\n    height,\n    colorAttachments: [texture]\n  });\n  return framebuffer;\n}\n// eslint-disable-next-line max-params\nfunction getPixelArray(pixelArray, glType, glFormat, width, height, depth) {\n  if (pixelArray) {\n    return pixelArray;\n  }\n  // const formatInfo = decodeTextureFormat(format);\n  // Allocate pixel array if not already available, using supplied type\n  glType ||= 5121;\n  const ArrayType = getTypedArrayFromGLType(glType, {\n    clamped: false\n  });\n  const components = glFormatToComponents(glFormat);\n  // TODO - check for composite type (components = 1).\n  return new ArrayType(width * height * components);\n}\n//# sourceMappingURL=webgl-texture-utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}