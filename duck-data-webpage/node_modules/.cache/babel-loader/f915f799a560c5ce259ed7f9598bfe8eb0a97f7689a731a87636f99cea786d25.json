{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// cyan color\nconst DEFAULT_HIGHLIGHT_COLOR = [0, 1, 1, 1];\nconst vs = /* glsl */`\\\nuniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nout vec4 picking_vRGBcolor_Avalid;\n\n// Normalize unsigned byte color to 0-1 range\nvec3 picking_normalizeColor(vec3 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\n// Normalize unsigned byte color to 0-1 range\nvec4 picking_normalizeColor(vec4 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\nbool picking_isColorZero(vec3 color) {\n  return dot(color, vec3(1.0)) < 0.00001;\n}\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.00001;\n}\n\n// Check if this vertex is highlighted \nbool isVertexHighlighted(vec3 vertexColor) {\n  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\n  return\n    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\n\n// Set the current picking color\nvoid picking_setPickingColor(vec3 pickingColor) {\n  pickingColor = picking_normalizeColor(pickingColor);\n\n  if (bool(picking.isActive)) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!bool(picking.isAttribute)) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec2 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec3 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n`;\nconst fs = /* glsl */`\\\nuniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (picking.isActive > 0.5) {\n    return color;\n  }\n\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    // Blend in highlight color based on its alpha value\n    float highLightAlpha = picking.highlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highlightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highlightColor);\n}\n`;\n/**\n * Provides support for color-coding-based picking and highlighting.\n * In particular, supports picking a specific instance in an instanced\n * draw call and highlighting an instance based on its picking color,\n * and correspondingly, supports picking and highlighting groups of\n * primitives with the same picking color in non-instanced draw-calls\n */\nexport const picking = {\n  props: {},\n  uniforms: {},\n  name: 'picking',\n  uniformTypes: {\n    isActive: 'f32',\n    isAttribute: 'f32',\n    isHighlightActive: 'f32',\n    useFloatColors: 'f32',\n    highlightedObjectColor: 'vec3<f32>',\n    highlightColor: 'vec4<f32>'\n  },\n  defaultUniforms: {\n    isActive: false,\n    isAttribute: false,\n    isHighlightActive: false,\n    useFloatColors: true,\n    highlightedObjectColor: [0, 0, 0],\n    highlightColor: DEFAULT_HIGHLIGHT_COLOR\n  },\n  vs,\n  fs,\n  getUniforms\n};\nfunction getUniforms(opts = {}, prevUniforms) {\n  const uniforms = {};\n  if (opts.highlightedObjectColor === undefined) {\n    // Unless highlightedObjectColor explicitly null or set, do not update state\n  } else if (opts.highlightedObjectColor === null) {\n    uniforms.isHighlightActive = false;\n  } else {\n    uniforms.isHighlightActive = true;\n    const highlightedObjectColor = opts.highlightedObjectColor.slice(0, 3);\n    uniforms.highlightedObjectColor = highlightedObjectColor;\n  }\n  if (opts.highlightColor) {\n    const color = Array.from(opts.highlightColor, x => x / 255);\n    if (!Number.isFinite(color[3])) {\n      color[3] = 1;\n    }\n    uniforms.highlightColor = color;\n  }\n  if (opts.isActive !== undefined) {\n    uniforms.isActive = Boolean(opts.isActive);\n    uniforms.isAttribute = Boolean(opts.isAttribute);\n  }\n  if (opts.useFloatColors !== undefined) {\n    uniforms.useFloatColors = Boolean(opts.useFloatColors);\n  }\n  return uniforms;\n}","map":{"version":3,"names":["DEFAULT_HIGHLIGHT_COLOR","vs","fs","picking","props","uniforms","name","uniformTypes","isActive","isAttribute","isHighlightActive","useFloatColors","highlightedObjectColor","highlightColor","defaultUniforms","getUniforms","opts","prevUniforms","undefined","slice","color","Array","from","x","Number","isFinite","Boolean"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\shadertools\\src\\modules\\engine\\picking\\picking.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {ShaderModule} from '../../../lib/shader-module/shader-module';\nimport type {NumberArray3, NumberArray4} from '@math.gl/core';\n\n// cyan color\nconst DEFAULT_HIGHLIGHT_COLOR: NumberArray4 = [0, 1, 1, 1];\n\n/**\n * Props for the picking module, which depending on mode renders picking colors or highlighted item.\n * When active, renders picking colors, assumed to be rendered to off-screen \"picking\" buffer.\n * When inactive, renders normal colors, with the exception of selected object which is rendered with highlight\n */\nexport type PickingProps = {\n  /** Are we picking? I.e. rendering picking colors? */\n  isActive?: boolean;\n  /** Set to true when picking an attribute value instead of object index */\n  isAttribute?: boolean;\n  /** Set to a picking color to visually highlight that item, or `null` to explicitly clear **/\n  highlightedObjectColor?: NumberArray3 | null;\n  /** Color of visual highlight of \"selected\" item */\n  highlightColor?: NumberArray3 | NumberArray4;\n  /** Color range 0-1 or 0-255 */\n  useFloatColors?: boolean;\n};\n\n/**\n * Uniforms for the picking module, which renders picking colors and highlighted item.\n * When active, renders picking colors, assumed to be rendered to off-screen \"picking\" buffer.\n * When inactive, renders normal colors, with the exception of selected object which is rendered with highlight\n */\nexport type PickingUniforms = {\n  /**\n   * When true, renders picking colors. Set when rendering to off-screen \"picking\" buffer.\n   * When false, renders normal colors, with the exception of selected object which is rendered with highlight\n   */\n  isActive?: boolean;\n  /** Set to true when picking an attribute value instead of object index */\n  isAttribute?: boolean;\n  /** Color range 0-1 or 0-255 */\n  useFloatColors?: boolean;\n  /** Do we have a highlighted item? */\n  isHighlightActive?: boolean;\n  /** Set to a picking color to visually highlight that item */\n  highlightedObjectColor?: NumberArray3;\n  /** Color of visual highlight of \"selected\" item */\n  highlightColor?: NumberArray4;\n};\n\nconst vs = /* glsl */ `\\\nuniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nout vec4 picking_vRGBcolor_Avalid;\n\n// Normalize unsigned byte color to 0-1 range\nvec3 picking_normalizeColor(vec3 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\n// Normalize unsigned byte color to 0-1 range\nvec4 picking_normalizeColor(vec4 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\nbool picking_isColorZero(vec3 color) {\n  return dot(color, vec3(1.0)) < 0.00001;\n}\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.00001;\n}\n\n// Check if this vertex is highlighted \nbool isVertexHighlighted(vec3 vertexColor) {\n  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\n  return\n    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\n\n// Set the current picking color\nvoid picking_setPickingColor(vec3 pickingColor) {\n  pickingColor = picking_normalizeColor(pickingColor);\n\n  if (bool(picking.isActive)) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!bool(picking.isAttribute)) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec2 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec3 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n`;\n\nconst fs = /* glsl */ `\\\nuniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (picking.isActive > 0.5) {\n    return color;\n  }\n\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    // Blend in highlight color based on its alpha value\n    float highLightAlpha = picking.highlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highlightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highlightColor);\n}\n`;\n\n/**\n * Provides support for color-coding-based picking and highlighting.\n * In particular, supports picking a specific instance in an instanced\n * draw call and highlighting an instance based on its picking color,\n * and correspondingly, supports picking and highlighting groups of\n * primitives with the same picking color in non-instanced draw-calls\n */\nexport const picking = {\n  props: {} as PickingProps,\n  uniforms: {} as PickingUniforms,\n\n  name: 'picking',\n\n  uniformTypes: {\n    isActive: 'f32',\n    isAttribute: 'f32',\n    isHighlightActive: 'f32',\n    useFloatColors: 'f32',\n    highlightedObjectColor: 'vec3<f32>',\n    highlightColor: 'vec4<f32>'\n  },\n  defaultUniforms: {\n    isActive: false,\n    isAttribute: false,\n    isHighlightActive: false,\n    useFloatColors: true,\n    highlightedObjectColor: [0, 0, 0],\n    highlightColor: DEFAULT_HIGHLIGHT_COLOR\n  },\n\n  vs,\n  fs,\n  getUniforms\n} as const satisfies ShaderModule<PickingProps, PickingUniforms>;\n\nfunction getUniforms(opts: PickingProps = {}, prevUniforms?: PickingUniforms): PickingUniforms {\n  const uniforms = {} as PickingUniforms;\n\n  if (opts.highlightedObjectColor === undefined) {\n    // Unless highlightedObjectColor explicitly null or set, do not update state\n  } else if (opts.highlightedObjectColor === null) {\n    uniforms.isHighlightActive = false;\n  } else {\n    uniforms.isHighlightActive = true;\n    const highlightedObjectColor = opts.highlightedObjectColor.slice(0, 3) as NumberArray3;\n    uniforms.highlightedObjectColor = highlightedObjectColor;\n  }\n\n  if (opts.highlightColor) {\n    const color = Array.from(opts.highlightColor, x => x / 255);\n    if (!Number.isFinite(color[3])) {\n      color[3] = 1;\n    }\n    uniforms.highlightColor = color as NumberArray4;\n  }\n\n  if (opts.isActive !== undefined) {\n    uniforms.isActive = Boolean(opts.isActive);\n    uniforms.isAttribute = Boolean(opts.isAttribute);\n  }\n\n  if (opts.useFloatColors !== undefined) {\n    uniforms.useFloatColors = Boolean(opts.useFloatColors);\n  }\n\n  return uniforms;\n}\n"],"mappings":"AAAA;AACA;AACA;AAKA;AACA,MAAMA,uBAAuB,GAAiB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AA2C1D,MAAMC,EAAE,GAAG,UAAW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwErB;AAED,MAAMC,EAAE,GAAG,UAAW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAyDrB;AAED;;;;;;;AAOA,OAAO,MAAMC,OAAO,GAAG;EACrBC,KAAK,EAAE,EAAkB;EACzBC,QAAQ,EAAE,EAAqB;EAE/BC,IAAI,EAAE,SAAS;EAEfC,YAAY,EAAE;IACZC,QAAQ,EAAE,KAAK;IACfC,WAAW,EAAE,KAAK;IAClBC,iBAAiB,EAAE,KAAK;IACxBC,cAAc,EAAE,KAAK;IACrBC,sBAAsB,EAAE,WAAW;IACnCC,cAAc,EAAE;GACjB;EACDC,eAAe,EAAE;IACfN,QAAQ,EAAE,KAAK;IACfC,WAAW,EAAE,KAAK;IAClBC,iBAAiB,EAAE,KAAK;IACxBC,cAAc,EAAE,IAAI;IACpBC,sBAAsB,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACjCC,cAAc,EAAEb;GACjB;EAEDC,EAAE;EACFC,EAAE;EACFa;CAC8D;AAEhE,SAASA,WAAWA,CAACC,IAAA,GAAqB,EAAE,EAAEC,YAA8B;EAC1E,MAAMZ,QAAQ,GAAG,EAAqB;EAEtC,IAAIW,IAAI,CAACJ,sBAAsB,KAAKM,SAAS,EAAE;IAC7C;EAAA,CACD,MAAM,IAAIF,IAAI,CAACJ,sBAAsB,KAAK,IAAI,EAAE;IAC/CP,QAAQ,CAACK,iBAAiB,GAAG,KAAK;EACpC,CAAC,MAAM;IACLL,QAAQ,CAACK,iBAAiB,GAAG,IAAI;IACjC,MAAME,sBAAsB,GAAGI,IAAI,CAACJ,sBAAsB,CAACO,KAAK,CAAC,CAAC,EAAE,CAAC,CAAiB;IACtFd,QAAQ,CAACO,sBAAsB,GAAGA,sBAAsB;EAC1D;EAEA,IAAII,IAAI,CAACH,cAAc,EAAE;IACvB,MAAMO,KAAK,GAAGC,KAAK,CAACC,IAAI,CAACN,IAAI,CAACH,cAAc,EAAEU,CAAC,IAAIA,CAAC,GAAG,GAAG,CAAC;IAC3D,IAAI,CAACC,MAAM,CAACC,QAAQ,CAACL,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;MAC9BA,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC;IACd;IACAf,QAAQ,CAACQ,cAAc,GAAGO,KAAqB;EACjD;EAEA,IAAIJ,IAAI,CAACR,QAAQ,KAAKU,SAAS,EAAE;IAC/Bb,QAAQ,CAACG,QAAQ,GAAGkB,OAAO,CAACV,IAAI,CAACR,QAAQ,CAAC;IAC1CH,QAAQ,CAACI,WAAW,GAAGiB,OAAO,CAACV,IAAI,CAACP,WAAW,CAAC;EAClD;EAEA,IAAIO,IAAI,CAACL,cAAc,KAAKO,SAAS,EAAE;IACrCb,QAAQ,CAACM,cAAc,GAAGe,OAAO,CAACV,IAAI,CAACL,cAAc,CAAC;EACxD;EAEA,OAAON,QAAQ;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}