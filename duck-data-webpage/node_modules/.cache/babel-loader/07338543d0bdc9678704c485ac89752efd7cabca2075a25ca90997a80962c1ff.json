{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { decodeShaderUniformType, alignTo } from \"../gpu-type-utils/decode-shader-types.js\";\nimport { getScratchArrayBuffer } from \"../utils/array-utils-flat.js\";\nimport { isNumberArray } from \"../utils/is-array.js\";\nimport { log } from \"../utils/log.js\";\n/**\n * Smallest buffer size that can be used for uniform buffers.\n * TODO - does this depend on device?\n */\nconst minBufferSize = 1024;\n/**\n * Std140 layout for uniform buffers\n * Supports manual listing of uniforms\n */\nexport class UniformBufferLayout {\n  layout = {};\n  /** number of bytes needed for buffer allocation */\n  byteLength;\n  /** Create a new UniformBufferLayout given a map of attributes. */\n  constructor(uniformTypes) {\n    /** number of 4 byte slots taken */\n    let size = 0;\n    // Add layout (type, size and offset) definitions for each uniform in the layout\n    for (const [key, uniformType] of Object.entries(uniformTypes)) {\n      const typeAndComponents = decodeShaderUniformType(uniformType);\n      const {\n        type,\n        components: count\n      } = typeAndComponents;\n      // First, align (bump) current offset to an even multiple of current object (1, 2, 4)\n      size = alignTo(size, count);\n      // Use the aligned size as the offset of the current uniform.\n      const offset = size;\n      // Then, add our object's padded size ((1, 2, multiple of 4) to the current offset\n      size += count;\n      this.layout[key] = {\n        type,\n        size: count,\n        offset\n      };\n    }\n    size += (4 - size % 4) % 4;\n    const actualByteLength = size * 4;\n    this.byteLength = Math.max(actualByteLength, minBufferSize);\n  }\n  /** Get the data for the complete buffer */\n  getData(uniformValues) {\n    const bufferSize = Math.max(this.byteLength, minBufferSize);\n    // Allocate three typed arrays pointing at same memory\n    const arrayBuffer = getScratchArrayBuffer(bufferSize);\n    const typedArrays = {\n      i32: new Int32Array(arrayBuffer),\n      u32: new Uint32Array(arrayBuffer),\n      f32: new Float32Array(arrayBuffer),\n      // TODO not implemented\n      f16: new Uint16Array(arrayBuffer)\n    };\n    // TODO is this needed?\n    // typedArrays.i32.fill(0);\n    for (const [name, value] of Object.entries(uniformValues)) {\n      const uniformLayout = this.layout[name];\n      if (!uniformLayout) {\n        log.warn(`Supplied uniform value ${name} not present in uniform block layout`)();\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      const {\n        type,\n        size,\n        offset\n      } = uniformLayout;\n      const typedArray = typedArrays[type];\n      if (size === 1) {\n        if (typeof value !== 'number' && typeof value !== 'boolean') {\n          log.warn(`Supplied value for single component uniform ${name} is not a number: ${value}`)();\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        // single value -> just set it\n        typedArray[offset] = Number(value);\n      } else {\n        if (!isNumberArray(value)) {\n          log.warn(`Supplied value for multi component / array uniform ${name} is not a numeric array: ${value}`)();\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        // vector/matrix -> copy the supplied (typed) array, starting from offset\n        // TODO: we should limit or check size in case the supplied data overflows\n        typedArray.set(value, offset);\n      }\n    }\n    return new Uint8Array(arrayBuffer);\n  }\n  /** Does this layout have a field with specified name */\n  has(name) {\n    return Boolean(this.layout[name]);\n  }\n  /** Get offset and size for a field with specified name */\n  get(name) {\n    const layout = this.layout[name];\n    return layout;\n  }\n}\n//# sourceMappingURL=uniform-buffer-layout.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}