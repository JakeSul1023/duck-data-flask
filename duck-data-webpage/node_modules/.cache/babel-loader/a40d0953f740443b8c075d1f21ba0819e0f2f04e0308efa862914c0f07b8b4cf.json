{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Device, log } from '@luma.gl/core';\nimport { WebGLStateTracker } from \"../context/state-tracker/webgl-state-tracker.js\";\nimport { createBrowserContext } from \"../context/helpers/create-browser-context.js\";\nimport { getDeviceInfo } from \"./device-helpers/webgl-device-info.js\";\nimport { WebGLDeviceFeatures } from \"./device-helpers/webgl-device-features.js\";\nimport { WebGLDeviceLimits } from \"./device-helpers/webgl-device-limits.js\";\nimport { WebGLCanvasContext } from \"./webgl-canvas-context.js\";\nimport { initializeSpectorJS } from \"../context/debug/spector.js\";\nimport { makeDebugContext } from \"../context/debug/webgl-developer-tools.js\";\nimport { getTextureFormatCapabilitiesWebGL } from \"./converters/webgl-texture-table.js\";\nimport { uid } from \"../utils/uid.js\";\nimport { WEBGLBuffer } from \"./resources/webgl-buffer.js\";\nimport { WEBGLShader } from \"./resources/webgl-shader.js\";\nimport { WEBGLSampler } from \"./resources/webgl-sampler.js\";\nimport { WEBGLTexture } from \"./resources/webgl-texture.js\";\nimport { WEBGLFramebuffer } from \"./resources/webgl-framebuffer.js\";\nimport { WEBGLRenderPass } from \"./resources/webgl-render-pass.js\";\nimport { WEBGLRenderPipeline } from \"./resources/webgl-render-pipeline.js\";\nimport { WEBGLCommandEncoder } from \"./resources/webgl-command-encoder.js\";\nimport { WEBGLVertexArray } from \"./resources/webgl-vertex-array.js\";\nimport { WEBGLTransformFeedback } from \"./resources/webgl-transform-feedback.js\";\nimport { WEBGLQuerySet } from \"./resources/webgl-query-set.js\";\nimport { readPixelsToArray, readPixelsToBuffer } from \"./helpers/webgl-texture-utils.js\";\nimport { setGLParameters, getGLParameters, resetGLParameters } from \"../context/parameters/unified-parameter-api.js\";\nimport { withGLParameters } from \"../context/state-tracker/with-parameters.js\";\nimport { getWebGLExtension } from \"../context/helpers/webgl-extensions.js\";\n/** WebGPU style Device API for a WebGL context */\nexport class WebGLDevice extends Device {\n  //\n  // Public `Device` API\n  //\n  /** type of this device */\n  type = 'webgl';\n  // Use the ! assertion to handle the case where _reuseDevices causes the constructor to return early\n  /** The underlying WebGL context */\n  handle;\n  features;\n  limits;\n  info;\n  canvasContext;\n  lost;\n  _resolveContextLost;\n  /** WebGL2 context. */\n  gl;\n  debug = false;\n  /** State used by luma.gl classes: TODO - move to canvasContext*/\n  _canvasSizeInfo = {\n    clientWidth: 0,\n    clientHeight: 0,\n    devicePixelRatio: 1\n  };\n  /** State used by luma.gl classes - TODO - not used? */\n  _extensions = {};\n  _polyfilled = false;\n  /** Instance of Spector.js (if initialized) */\n  spectorJS;\n  //\n  // Public API\n  //\n  constructor(props) {\n    super({\n      ...props,\n      id: props.id || uid('webgl-device')\n    });\n    const canvasContextProps = Device._getCanvasContextProps(props);\n    // WebGL requires a canvas to be created before creating the context\n    if (!canvasContextProps) {\n      throw new Error('WebGLDevice requires props.createCanvasContext to be set');\n    }\n    // Check if the WebGL context is already associated with a device\n    // Note that this can be avoided in webgl2adapter.create() if\n    // DeviceProps._reuseDevices is set.\n    // @ts-expect-error device is attached to context\n    let device = canvasContextProps.canvas?.gl?.device;\n    if (device) {\n      throw new Error(`WebGL context already attached to device ${device.id}`);\n    }\n    // Create and instrument context\n    this.canvasContext = new WebGLCanvasContext(this, canvasContextProps);\n    this.lost = new Promise(resolve => {\n      this._resolveContextLost = resolve;\n    });\n    const webglContextAttributes = {\n      ...props.webgl\n    };\n    // Copy props from CanvasContextProps\n    if (canvasContextProps.alphaMode === 'premultiplied') {\n      webglContextAttributes.premultipliedAlpha = true;\n    }\n    if (props.powerPreference !== undefined) {\n      webglContextAttributes.powerPreference = props.powerPreference;\n    }\n    // Check if we should attach to an externally created context or create a new context\n    const externalGLContext = this.props._handle;\n    const gl = externalGLContext || createBrowserContext(this.canvasContext.canvas, {\n      onContextLost: event => this._resolveContextLost?.({\n        reason: 'destroyed',\n        message: 'Entered sleep mode, or too many apps or browser tabs are using the GPU.'\n      }),\n      // eslint-disable-next-line no-console\n      onContextRestored: event => console.log('WebGL context restored')\n    }, webglContextAttributes);\n    if (!gl) {\n      throw new Error('WebGL context creation failed');\n    }\n    // Note that the browser will only create one WebGL context per canvas.\n    // This means that a newly created gl context may already have a device attached to it.\n    // @ts-expect-error luma.gl stores a device reference on the context.\n    device = gl.device;\n    if (device) {\n      if (props._reuseDevices) {\n        log.log(1, `Not creating a new Device, instead returning a reference to Device ${device.id} already attached to WebGL context`, device)();\n        device._reused = true;\n        return device;\n      }\n      throw new Error(`WebGL context already attached to device ${device.id}`);\n    }\n    this.handle = gl;\n    this.gl = gl;\n    // Add spector debug instrumentation to context\n    // We need to trust spector integration to decide if spector should be initialized\n    // We also run spector instrumentation first, otherwise spector can clobber luma instrumentation.\n    this.spectorJS = initializeSpectorJS({\n      ...this.props,\n      gl: this.handle\n    });\n    // Instrument context\n    this.gl.device = this; // Update GL context: Link webgl context back to device\n    // TODO - remove, this is only used to detect debug contexts.\n    this.gl._version = 2; // Update GL context: Store WebGL version field on gl context (HACK to identify debug contexts)\n    // initialize luma Device fields\n    this.info = getDeviceInfo(this.gl, this._extensions);\n    this.limits = new WebGLDeviceLimits(this.gl);\n    this.features = new WebGLDeviceFeatures(this.gl, this._extensions, this.props._disabledFeatures);\n    if (this.props._initializeFeatures) {\n      this.features.initializeFeatures();\n    }\n    if (canvasContextProps.autoResize !== false) {\n      this.canvasContext.resize();\n    }\n    // Install context state tracking\n    const glState = new WebGLStateTracker(this.gl, {\n      log: function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        return log.log(1, ...args)();\n      }\n    });\n    glState.trackState(this.gl, {\n      copyState: false\n    });\n    // DEBUG contexts: Add luma debug instrumentation to the context, force log level to at least 1\n    const debugWebGL = props.debugWebGL || props.debug;\n    const traceWebGL = props.debugWebGL;\n    if (debugWebGL) {\n      this.gl = makeDebugContext(this.gl, {\n        debugWebGL,\n        traceWebGL\n      });\n      log.warn('WebGL debug mode activated. Performance reduced.')();\n      if (props.debugWebGL) {\n        log.level = Math.max(log.level, 1);\n      }\n    }\n  }\n  /**\n   * Destroys the device\n   *\n   * @note \"Detaches\" from the WebGL context unless _reuseDevices is true.\n   *\n   * @note The underlying WebGL context is not immediately destroyed,\n   * but may be destroyed later through normal JavaScript garbage collection.\n   * This is a fundamental limitation since WebGL does not offer any\n   * browser API for destroying WebGL contexts.\n   */\n  destroy() {\n    // Note that deck.gl (especially in React strict mode) depends on being able\n    // to asynchronously create a Device against the same canvas (i.e. WebGL context)\n    // multiple times and getting the same device back. Since deck.gl is not aware\n    // of this sharing, it might call destroy() multiple times on the same device.\n    // Therefore we must do nothing in destroy() if props._reuseDevices is true\n    if (!this.props._reuseDevices && !this._reused) {\n      // Delete the reference to the device that we store on the WebGL context\n      delete this.gl.device;\n    }\n  }\n  get isLost() {\n    return this.gl.isContextLost();\n  }\n  // IMPLEMENTATION OF ABSTRACT DEVICE\n  createCanvasContext(props) {\n    throw new Error('WebGL only supports a single canvas');\n  }\n  createBuffer(props) {\n    const newProps = this._normalizeBufferProps(props);\n    return new WEBGLBuffer(this, newProps);\n  }\n  createTexture(props) {\n    return new WEBGLTexture(this, props);\n  }\n  createExternalTexture(props) {\n    throw new Error('createExternalTexture() not implemented'); // return new Program(props);\n  }\n  createSampler(props) {\n    return new WEBGLSampler(this, props);\n  }\n  createShader(props) {\n    return new WEBGLShader(this, props);\n  }\n  createFramebuffer(props) {\n    return new WEBGLFramebuffer(this, props);\n  }\n  createVertexArray(props) {\n    return new WEBGLVertexArray(this, props);\n  }\n  createTransformFeedback(props) {\n    return new WEBGLTransformFeedback(this, props);\n  }\n  createQuerySet(props) {\n    return new WEBGLQuerySet(this, props);\n  }\n  createRenderPipeline(props) {\n    return new WEBGLRenderPipeline(this, props);\n  }\n  beginRenderPass(props) {\n    return new WEBGLRenderPass(this, props);\n  }\n  createComputePipeline(props) {\n    throw new Error('ComputePipeline not supported in WebGL');\n  }\n  beginComputePass(props) {\n    throw new Error('ComputePass not supported in WebGL');\n  }\n  renderPass = null;\n  createCommandEncoder() {\n    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new WEBGLCommandEncoder(this, props);\n  }\n  /**\n   * Offscreen Canvas Support: Commit the frame\n   * https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/commit\n   * Chrome's offscreen canvas does not require gl.commit\n   */\n  submit() {\n    this.renderPass?.end();\n    this.renderPass = null;\n    // this.canvasContext.commit();\n  }\n  //\n  // TEMPORARY HACKS - will be removed in v9.1\n  //\n  /** @deprecated - should use command encoder */\n  readPixelsToArrayWebGL(source, options) {\n    return readPixelsToArray(source, options);\n  }\n  /** @deprecated - should use command encoder */\n  readPixelsToBufferWebGL(source, options) {\n    return readPixelsToBuffer(source, options);\n  }\n  setParametersWebGL(parameters) {\n    setGLParameters(this.gl, parameters);\n  }\n  getParametersWebGL(parameters) {\n    return getGLParameters(this.gl, parameters);\n  }\n  withParametersWebGL(parameters, func) {\n    return withGLParameters(this.gl, parameters, func);\n  }\n  resetWebGL() {\n    log.warn('WebGLDevice.resetWebGL is deprecated, use only for debugging')();\n    resetGLParameters(this.gl);\n  }\n  _getDeviceSpecificTextureFormatCapabilities(capabilities) {\n    return getTextureFormatCapabilitiesWebGL(this.gl, capabilities, this._extensions);\n  }\n  //\n  // WebGL-only API (not part of `Device` API)\n  //\n  /**\n   * Triggers device (or WebGL context) loss.\n   * @note primarily intended for testing how application reacts to device loss\n   */\n  loseDevice() {\n    let deviceLossTriggered = false;\n    const extensions = this.getExtension('WEBGL_lose_context');\n    const ext = extensions.WEBGL_lose_context;\n    if (ext) {\n      deviceLossTriggered = true;\n      ext.loseContext();\n      // ext.loseContext should trigger context loss callback but the platform may not do this, so do it explicitly\n    }\n    this._resolveContextLost?.({\n      reason: 'destroyed',\n      message: 'Application triggered context loss'\n    });\n    return deviceLossTriggered;\n  }\n  /** Save current WebGL context state onto an internal stack */\n  pushState() {\n    const webglState = WebGLStateTracker.get(this.gl);\n    webglState.push();\n  }\n  /** Restores previously saved context state */\n  popState() {\n    const webglState = WebGLStateTracker.get(this.gl);\n    webglState.pop();\n  }\n  /**\n   * Storing data on a special field on WebGLObjects makes that data visible in SPECTOR chrome debug extension\n   * luma.gl ids and props can be inspected\n   */\n  setSpectorMetadata(handle, props) {\n    // @ts-expect-error\n    // eslint-disable-next-line camelcase\n    handle.__SPECTOR_Metadata = props;\n  }\n  /**\n   * Returns the GL.<KEY> constant that corresponds to a numeric value of a GL constant\n   * Be aware that there are some duplicates especially for constants that are 0,\n   * so this isn't guaranteed to return the right key in all cases.\n   */\n  getGLKey(value, options) {\n    const number = Number(value);\n    for (const key in this.gl) {\n      // @ts-ignore expect-error depends on settings\n      if (this.gl[key] === number) {\n        return `GL.${key}`;\n      }\n    }\n    // No constant found. Stringify the value and return it.\n    return options?.emptyIfUnknown ? '' : String(value);\n  }\n  /**\n   * Returns a map with any GL.<KEY> constants mapped to strings, both for keys and values\n   */\n  getGLKeys(glParameters) {\n    const opts = {\n      emptyIfUnknown: true\n    };\n    return Object.entries(glParameters).reduce((keys, _ref) => {\n      let [key, value] = _ref;\n      // eslint-disable-next-line @typescript-eslint/no-base-to-string\n      keys[`${key}:${this.getGLKey(key, opts)}`] = `${value}:${this.getGLKey(value, opts)}`;\n      return keys;\n    }, {});\n  }\n  /** Store constants */\n  _constants;\n  /**\n   * Set a constant value for a location. Disabled attributes at that location will read from this value\n   * @note WebGL constants are stored globally on the WebGL context, not the VertexArray\n   * so they need to be updated before every render\n   * @todo - remember/cache values to avoid setting them unnecessarily?\n   */\n  setConstantAttributeWebGL(location, constant) {\n    const maxVertexAttributes = this.limits.maxVertexAttributes;\n    this._constants = this._constants || new Array(maxVertexAttributes).fill(null);\n    const currentConstant = this._constants[location];\n    if (currentConstant && compareConstantArrayValues(currentConstant, constant)) {\n      log.info(1, `setConstantAttributeWebGL(${location}) could have been skipped, value unchanged`)();\n    }\n    this._constants[location] = constant;\n    switch (constant.constructor) {\n      case Float32Array:\n        setConstantFloatArray(this, location, constant);\n        break;\n      case Int32Array:\n        setConstantIntArray(this, location, constant);\n        break;\n      case Uint32Array:\n        setConstantUintArray(this, location, constant);\n        break;\n      default:\n        throw new Error('constant');\n    }\n  }\n  /** Ensure extensions are only requested once */\n  getExtension(name) {\n    getWebGLExtension(this.gl, name, this._extensions);\n    return this._extensions;\n  }\n}\n/** Set constant float array attribute */\nfunction setConstantFloatArray(device, location, array) {\n  switch (array.length) {\n    case 1:\n      device.gl.vertexAttrib1fv(location, array);\n      break;\n    case 2:\n      device.gl.vertexAttrib2fv(location, array);\n      break;\n    case 3:\n      device.gl.vertexAttrib3fv(location, array);\n      break;\n    case 4:\n      device.gl.vertexAttrib4fv(location, array);\n      break;\n    default:\n    // assert(false);\n  }\n}\n/** Set constant signed int array attribute */\nfunction setConstantIntArray(device, location, array) {\n  device.gl.vertexAttribI4iv(location, array);\n  // TODO - not clear if we need to use the special forms, more testing needed\n  // switch (array.length) {\n  //   case 1:\n  //     gl.vertexAttribI1iv(location, array);\n  //     break;\n  //   case 2:\n  //     gl.vertexAttribI2iv(location, array);\n  //     break;\n  //   case 3:\n  //     gl.vertexAttribI3iv(location, array);\n  //     break;\n  //   case 4:\n  //     break;\n  //   default:\n  //     assert(false);\n  // }\n}\n/** Set constant unsigned int array attribute */\nfunction setConstantUintArray(device, location, array) {\n  device.gl.vertexAttribI4uiv(location, array);\n  // TODO - not clear if we need to use the special forms, more testing needed\n  // switch (array.length) {\n  //   case 1:\n  //     gl.vertexAttribI1uiv(location, array);\n  //     break;\n  //   case 2:\n  //     gl.vertexAttribI2uiv(location, array);\n  //     break;\n  //   case 3:\n  //     gl.vertexAttribI3uiv(location, array);\n  //     break;\n  //   case 4:\n  //     gl.vertexAttribI4uiv(location, array);\n  //     break;\n  //   default:\n  //     assert(false);\n  // }\n}\n/**\n * Compares contents of two typed arrays\n * @todo max length?\n */\nfunction compareConstantArrayValues(v1, v2) {\n  if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {\n    return false;\n  }\n  for (let i = 0; i < v1.length; ++i) {\n    if (v1[i] !== v2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n//# sourceMappingURL=webgl-device.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}