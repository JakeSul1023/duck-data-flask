{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { lumaStats } from \"../utils/stats-manager.js\";\nimport { log } from \"../utils/log.js\";\nimport { uid } from \"../utils/uid.js\";\nimport { Buffer } from \"./resources/buffer.js\";\nimport { isTextureFormatCompressed } from \"../gpu-type-utils/decode-texture-format.js\";\nimport { getTextureFormatCapabilities } from \"../gpu-type-utils/texture-format-capabilities.js\";\n/** Limits for a device (max supported sizes of resources, max number of bindings etc) */\nexport class DeviceLimits {}\n/** Set-like class for features (lets apps check for WebGL / WebGPU extensions) */\nexport class DeviceFeatures {\n  features;\n  disabledFeatures;\n  constructor(features = [], disabledFeatures) {\n    this.features = new Set(features);\n    this.disabledFeatures = disabledFeatures || {};\n  }\n  *[Symbol.iterator]() {\n    yield* this.features;\n  }\n  has(feature) {\n    return !this.disabledFeatures?.[feature] && this.features.has(feature);\n  }\n}\n/**\n * WebGPU Device/WebGL context abstraction\n */\nexport class Device {\n  static defaultProps = {\n    id: null,\n    powerPreference: 'high-performance',\n    failIfMajorPerformanceCaveat: false,\n    createCanvasContext: undefined,\n    // Callbacks\n    onError: error => log.error(error.message)(),\n    // Experimental\n    _reuseDevices: false,\n    _requestMaxLimits: true,\n    _factoryDestroyPolicy: 'unused',\n    // TODO - Change these after confirming things work as expected\n    _initializeFeatures: true,\n    _disabledFeatures: {\n      'compilation-status-async-webgl': true\n    },\n    _resourceDefaults: {},\n    // WebGL specific\n    webgl: {},\n    debug: log.get('debug') || undefined,\n    debugShaders: log.get('debug-shaders') || undefined,\n    debugFramebuffers: Boolean(log.get('debug-framebuffers')),\n    debugWebGL: Boolean(log.get('debug-webgl')),\n    debugSpectorJS: undefined,\n    // Note: log setting is queried by the spector.js code\n    debugSpectorJSUrl: undefined,\n    // INTERNAL\n    _handle: undefined\n  };\n  get [Symbol.toStringTag]() {\n    return 'Device';\n  }\n  constructor(props) {\n    this.props = {\n      ...Device.defaultProps,\n      ...props\n    };\n    this.id = this.props.id || uid(this[Symbol.toStringTag].toLowerCase());\n  }\n  /** id of this device, primarily for debugging */\n  id;\n  /** A copy of the device props  */\n  props;\n  /** Available for the application to store data on the device */\n  userData = {};\n  /** stats */\n  statsManager = lumaStats;\n  /** An abstract timestamp used for change tracking */\n  timestamp = 0;\n  /** True if this device has been reused during device creation (app has multiple references) */\n  _reused = false;\n  /** Used by other luma.gl modules to store data on the device */\n  _lumaData = {};\n  /** Determines what operations are supported on a texture format, checking against supported device features */\n  getTextureFormatCapabilities(format) {\n    const genericCapabilities = getTextureFormatCapabilities(format);\n    // Check standard features\n    const checkFeature = featureOrBoolean => (typeof featureOrBoolean === 'string' ? this.features.has(featureOrBoolean) : featureOrBoolean) ?? true;\n    const supported = checkFeature(genericCapabilities.create);\n    const deviceCapabilities = {\n      format,\n      create: supported,\n      render: supported && checkFeature(genericCapabilities.render),\n      filter: supported && checkFeature(genericCapabilities.filter),\n      blend: supported && checkFeature(genericCapabilities.blend),\n      store: supported && checkFeature(genericCapabilities.store)\n    };\n    return this._getDeviceSpecificTextureFormatCapabilities(deviceCapabilities);\n  }\n  /** Check if device supports a specific texture format (creation and `nearest` sampling) */\n  isTextureFormatSupported(format, capabilities) {\n    return this.getTextureFormatCapabilities(format).create;\n  }\n  /** Check if linear filtering (sampler interpolation) is supported for a specific texture format */\n  isTextureFormatFilterable(format) {\n    return this.getTextureFormatCapabilities(format).filter;\n  }\n  /** Check if device supports rendering to a framebuffer color attachment of a specific texture format */\n  isTextureFormatRenderable(format) {\n    return this.getTextureFormatCapabilities(format).render;\n  }\n  /** Check if a specific texture format is GPU compressed */\n  isTextureFormatCompressed(format) {\n    return isTextureFormatCompressed(format);\n  }\n  /**\n   * Trigger device loss.\n   * @returns `true` if context loss could actually be triggered.\n   * @note primarily intended for testing how application reacts to device loss\n   */\n  loseDevice() {\n    return false;\n  }\n  /** Report error (normally called for unhandled device errors) */\n  reportError(error) {\n    this.props.onError(error);\n  }\n  /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */\n  getDefaultCanvasContext() {\n    if (!this.canvasContext) {\n      throw new Error('Device has no default CanvasContext. See props.createCanvasContext');\n    }\n    return this.canvasContext;\n  }\n  createCommandEncoder(props = {}) {\n    throw new Error('not implemented');\n  }\n  /** A monotonic counter for tracking buffer and texture updates */\n  incrementTimestamp() {\n    return this.timestamp++;\n  }\n  // Error Handling\n  /** Report unhandled device errors */\n  onError(error) {\n    this.props.onError(error);\n  }\n  // DEPRECATED METHODS\n  /** @deprecated Use getDefaultCanvasContext() */\n  getCanvasContext() {\n    return this.getDefaultCanvasContext();\n  }\n  // WebGL specific HACKS - enables app to remove webgl import\n  // Use until we have a better way to handle these\n  /** @deprecated - will be removed - should use command encoder */\n  readPixelsToArrayWebGL(source, options) {\n    throw new Error('not implemented');\n  }\n  /** @deprecated - will be removed - should use command encoder */\n  readPixelsToBufferWebGL(source, options) {\n    throw new Error('not implemented');\n  }\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  setParametersWebGL(parameters) {\n    throw new Error('not implemented');\n  }\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  getParametersWebGL(parameters) {\n    throw new Error('not implemented');\n  }\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  withParametersWebGL(parameters, func) {\n    throw new Error('not implemented');\n  }\n  /** @deprecated - will be removed - should use clear arguments in RenderPass */\n  clearWebGL(options) {\n    throw new Error('not implemented');\n  }\n  /** @deprecated - will be removed - should use for debugging only */\n  resetWebGL() {\n    throw new Error('not implemented');\n  }\n  // IMPLEMENTATION\n  /** Helper to get the canvas context props */\n  static _getCanvasContextProps(props) {\n    return props.createCanvasContext === true ? {} : props.createCanvasContext;\n  }\n  /** Subclasses use this to support .createBuffer() overloads */\n  _normalizeBufferProps(props) {\n    if (props instanceof ArrayBuffer || ArrayBuffer.isView(props)) {\n      props = {\n        data: props\n      };\n    }\n    // TODO - fragile, as this is done before we merge with default options\n    // inside the Buffer constructor\n    const newProps = {\n      ...props\n    };\n    // Deduce indexType\n    if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {\n      if (props.data instanceof Uint32Array) {\n        newProps.indexType = 'uint32';\n      } else if (props.data instanceof Uint16Array) {\n        newProps.indexType = 'uint16';\n      } else {\n        log.warn('indices buffer content must be of integer type')();\n      }\n    }\n    return newProps;\n  }\n}","map":{"version":3,"names":["lumaStats","log","uid","Buffer","isTextureFormatCompressed","getTextureFormatCapabilities","DeviceLimits","DeviceFeatures","features","disabledFeatures","constructor","Set","Symbol","iterator","has","feature","Device","defaultProps","id","powerPreference","failIfMajorPerformanceCaveat","createCanvasContext","undefined","onError","error","message","_reuseDevices","_requestMaxLimits","_factoryDestroyPolicy","_initializeFeatures","_disabledFeatures","_resourceDefaults","webgl","debug","get","debugShaders","debugFramebuffers","Boolean","debugWebGL","debugSpectorJS","debugSpectorJSUrl","_handle","toStringTag","props","toLowerCase","userData","statsManager","timestamp","_reused","_lumaData","format","genericCapabilities","checkFeature","featureOrBoolean","supported","create","deviceCapabilities","render","filter","blend","store","_getDeviceSpecificTextureFormatCapabilities","isTextureFormatSupported","capabilities","isTextureFormatFilterable","isTextureFormatRenderable","loseDevice","reportError","getDefaultCanvasContext","canvasContext","Error","createCommandEncoder","incrementTimestamp","getCanvasContext","readPixelsToArrayWebGL","source","options","readPixelsToBufferWebGL","setParametersWebGL","parameters","getParametersWebGL","withParametersWebGL","func","clearWebGL","resetWebGL","_getCanvasContextProps","_normalizeBufferProps","ArrayBuffer","isView","data","newProps","usage","INDEX","indexType","Uint32Array","Uint16Array","warn"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\core\\src\\adapter\\device.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {StatsManager, lumaStats} from '../utils/stats-manager';\nimport {log} from '../utils/log';\nimport {uid} from '../utils/uid';\nimport type {TextureFormat} from '../gpu-type-utils/texture-formats';\nimport type {TextureFormatCapabilities} from '../gpu-type-utils/texture-format-capabilities';\nimport type {CanvasContext, CanvasContextProps} from './canvas-context';\nimport type {BufferProps} from './resources/buffer';\nimport {Buffer} from './resources/buffer';\nimport type {RenderPipeline, RenderPipelineProps} from './resources/render-pipeline';\nimport type {ComputePipeline, ComputePipelineProps} from './resources/compute-pipeline';\nimport type {Sampler, SamplerProps} from './resources/sampler';\nimport type {Shader, ShaderProps} from './resources/shader';\nimport type {Texture, TextureProps} from './resources/texture';\nimport type {ExternalTexture, ExternalTextureProps} from './resources/external-texture';\nimport type {Framebuffer, FramebufferProps} from './resources/framebuffer';\nimport type {RenderPass, RenderPassProps} from './resources/render-pass';\nimport type {ComputePass, ComputePassProps} from './resources/compute-pass';\nimport type {CommandEncoder, CommandEncoderProps} from './resources/command-encoder';\nimport type {VertexArray, VertexArrayProps} from './resources/vertex-array';\nimport type {TransformFeedback, TransformFeedbackProps} from './resources/transform-feedback';\nimport type {QuerySet, QuerySetProps} from './resources/query-set';\n\nimport {isTextureFormatCompressed} from '../gpu-type-utils/decode-texture-format';\nimport {getTextureFormatCapabilities} from '../gpu-type-utils/texture-format-capabilities';\n\n/**\n * Identifies the GPU vendor and driver.\n * @note Chrome WebGPU does not provide much information, though more can be enabled with\n * @see https://developer.chrome.com/blog/new-in-webgpu-120#adapter_information_updates\n * chrome://flags/#enable-webgpu-developer-features\n */\nexport type DeviceInfo = {\n  /** Type of device */\n  type: 'webgl' | 'webgpu' | 'unknown';\n  /** Vendor (name of GPU vendor, Apple, nVidia etc */\n  vendor: string;\n  /** Renderer (usually driver name) */\n  renderer: string;\n  /** version of driver */\n  version: string;\n  /** family of GPU */\n  gpu: 'nvidia' | 'amd' | 'intel' | 'apple' | 'software' | 'unknown';\n  /** Type of GPU () */\n  gpuType: 'discrete' | 'integrated' | 'cpu' | 'unknown';\n  /** GPU architecture */\n  gpuArchitecture?: string; // 'common-3' on Apple\n  /** GPU driver backend. Can sometimes be sniffed */\n  gpuBackend?: 'opengl' | 'opengles' | 'metal' | 'd3d11' | 'd3d12' | 'vulkan' | 'unknown';\n  /** If this is a fallback adapter */\n  fallback?: boolean;\n  /** Shader language supported by device.createShader() */\n  shadingLanguage: 'wgsl' | 'glsl';\n  /** Highest supported shader language version: GLSL 3.00 = 300, WGSL 1.00 = 100 */\n  shadingLanguageVersion: number;\n};\n\n/** Limits for a device (max supported sizes of resources, max number of bindings etc) */\nexport abstract class DeviceLimits {\n  /** max number of TextureDimension1D */\n  abstract maxTextureDimension1D: number;\n  /** max number of TextureDimension2D */\n  abstract maxTextureDimension2D: number;\n  /** max number of TextureDimension3D */\n  abstract maxTextureDimension3D: number;\n  /** max number of TextureArrayLayers */\n  abstract maxTextureArrayLayers: number;\n  /** max number of BindGroups */\n  abstract maxBindGroups: number;\n  /** max number of DynamicUniformBuffers per PipelineLayout */\n  abstract maxDynamicUniformBuffersPerPipelineLayout: number;\n  /** max number of DynamicStorageBuffers per PipelineLayout */\n  abstract maxDynamicStorageBuffersPerPipelineLayout: number;\n  /** max number of SampledTextures per ShaderStage */\n  abstract maxSampledTexturesPerShaderStage: number;\n  /** max number of Samplers per ShaderStage */\n  abstract maxSamplersPerShaderStage: number;\n  /** max number of StorageBuffers per ShaderStage */\n  abstract maxStorageBuffersPerShaderStage: number;\n  /** max number of StorageTextures per ShaderStage */\n  abstract maxStorageTexturesPerShaderStage: number;\n  /** max number of UniformBuffers per ShaderStage */\n  abstract maxUniformBuffersPerShaderStage: number;\n  /** max number of UniformBufferBindingSize */\n  abstract maxUniformBufferBindingSize: number;\n  /** max number of StorageBufferBindingSize */\n  abstract maxStorageBufferBindingSize: number;\n  /** min UniformBufferOffsetAlignment */\n  abstract minUniformBufferOffsetAlignment: number;\n  /** min StorageBufferOffsetAlignment */\n  abstract minStorageBufferOffsetAlignment: number;\n  /** max number of VertexBuffers */\n  abstract maxVertexBuffers: number;\n  /** max number of VertexAttributes */\n  abstract maxVertexAttributes: number;\n  /** max number of VertexBufferArrayStride */\n  abstract maxVertexBufferArrayStride: number;\n  /** max number of InterStageShaderComponents */\n  abstract maxInterStageShaderComponents: number;\n  /** max number of ComputeWorkgroupStorageSize */\n  abstract maxComputeWorkgroupStorageSize: number;\n  /** max number of ComputeInvocations per Workgroup */\n  abstract maxComputeInvocationsPerWorkgroup: number;\n  /** max ComputeWorkgroupSizeX */\n  abstract maxComputeWorkgroupSizeX: number;\n  /** max ComputeWorkgroupSizeY */\n  abstract maxComputeWorkgroupSizeY: number;\n  /** max ComputeWorkgroupSizeZ */\n  abstract maxComputeWorkgroupSizeZ: number;\n  /** max ComputeWorkgroupsPerDimension */\n  abstract maxComputeWorkgroupsPerDimension: number;\n}\n\n/** Set-like class for features (lets apps check for WebGL / WebGPU extensions) */\nexport class DeviceFeatures {\n  protected features: Set<DeviceFeature>;\n  protected disabledFeatures?: Partial<Record<DeviceFeature, boolean>>;\n\n  constructor(\n    features: DeviceFeature[] = [],\n    disabledFeatures: Partial<Record<DeviceFeature, boolean>>\n  ) {\n    this.features = new Set<DeviceFeature>(features);\n    this.disabledFeatures = disabledFeatures || {};\n  }\n\n  *[Symbol.iterator](): IterableIterator<DeviceFeature> {\n    yield* this.features;\n  }\n\n  has(feature: DeviceFeature): boolean {\n    return !this.disabledFeatures?.[feature] && this.features.has(feature);\n  }\n}\n\n/** Device feature names */\nexport type DeviceFeature =\n  | WebGPUDeviceFeature\n  | WebGLDeviceFeature\n  | WebGLCompressedTextureFeatures;\n\nexport type WebGPUDeviceFeature =\n  | 'depth-clip-control'\n  | 'indirect-first-instance'\n  | 'timestamp-query'\n  | 'shader-f16'\n  | 'depth32float-stencil8'\n  | 'rg11b10ufloat-renderable' // Is the rg11b10ufloat texture format renderable?\n  | 'float32-filterable' // Is the float32 format filterable?\n  | 'bgra8unorm-storage' // Can the bgra8unorm texture format be used in storage buffers?\n  | 'texture-compression-bc'\n  | 'texture-compression-etc2'\n  | 'texture-compression-astc';\n// | 'depth-clamping' // removed from the WebGPU spec...\n// | 'pipeline-statistics-query' // removed from the WebGPU spec...\n\nexport type WebGLDeviceFeature =\n  // webgl extension features\n  | 'timer-query-webgl' // unify with WebGPU timestamp-query?\n  | 'compilation-status-async-webgl' // Non-blocking shader compile/link status query available\n  | 'provoking-vertex-webgl' // parameters.provokingVertex\n  | 'polygon-mode-webgl' // parameters.polygonMode and parameters.polygonOffsetLine\n\n  // GLSL extension features\n  | 'shader-noperspective-interpolation-webgl' // Vertex outputs & fragment inputs can have a `noperspective` interpolation qualifier.\n  | 'shader-conservative-depth-webgl' // GLSL `gl_FragDepth` qualifiers `depth_unchanged` etc can enable early depth test\n  | 'shader-clip-cull-distance-webgl' // Makes gl_ClipDistance and gl_CullDistance available in shaders\n\n  // texture rendering\n  | 'float32-renderable-webgl'\n  | 'float16-renderable-webgl'\n  | 'rgb9e5ufloat-renderable-webgl'\n  | 'snorm8-renderable-webgl'\n  | 'norm16-renderable-webgl'\n  | 'snorm16-renderable-webgl'\n\n  // texture filtering\n  | 'float16-filterable-webgl'\n  | 'texture-filterable-anisotropic-webgl'\n\n  // texture storage bindings\n  | 'bgra8unorm-storage'\n\n  // texture blending\n  | 'texture-blend-float-webgl';\n\ntype WebGLCompressedTextureFeatures =\n  | 'texture-compression-bc5-webgl'\n  | 'texture-compression-bc7-webgl'\n  | 'texture-compression-etc1-webgl'\n  | 'texture-compression-pvrtc-webgl'\n  | 'texture-compression-atc-webgl';\n\n/** Texture format capabilities that have been checked against a specific device */\nexport type DeviceTextureFormatCapabilities = {\n  format: TextureFormat;\n  /** Can the format be created */\n  create: boolean;\n  /** If a feature string, the specified device feature determines if format is renderable. */\n  render: boolean;\n  /** If a feature string, the specified device feature determines if format is filterable. */\n  filter: boolean;\n  /** If a feature string, the specified device feature determines if format is blendable. */\n  blend: boolean;\n  /** If a feature string, the specified device feature determines if format is storeable. */\n  store: boolean;\n};\n\n/** Device properties */\nexport type DeviceProps = {\n  /** string id for debugging. Stored on the object, used in logging and set on underlying GPU objects when feasible. */\n  id?: string;\n  /** Properties for creating a default canvas context */\n  createCanvasContext?: CanvasContextProps | true;\n  /** Control which type of GPU is preferred on systems with both integrated and discrete GPU. Defaults to \"high-performance\" / discrete GPU. */\n  powerPreference?: 'default' | 'high-performance' | 'low-power';\n  /** Hints that device creation should fail if no hardware GPU is available (if the system performance is \"low\"). */\n  failIfMajorPerformanceCaveat?: boolean;\n  /** Error handling */\n  onError?: (error: Error) => unknown;\n\n  /** WebGL specific: Properties passed through to WebGL2RenderingContext creation: `canvas.getContext('webgl2', props.webgl)` */\n  webgl?: WebGLContextProps;\n\n  // DEBUG SETTINGS\n\n  /** Turn on implementation defined checks that slow down execution but help break where errors occur */\n  debug?: boolean;\n  /** Show shader source in browser? The default is`'error'`, meaning that logs are shown when shader compilation has errors */\n  debugShaders?: 'never' | 'errors' | 'warnings' | 'always';\n  /** Renders a small version of updated Framebuffers into the primary canvas context. Can be set in console luma.log.set('debug-framebuffers', true) */\n  debugFramebuffers?: boolean;\n  /** WebGL specific - Trace WebGL calls (instruments WebGL2RenderingContext at the expense of performance). Can be set in console luma.log.set('debug-webgl', true)  */\n  debugWebGL?: boolean;\n  /** WebGL specific - Initialize the SpectorJS WebGL debugger. Can be set in console luma.log.set('debug-spectorjs', true)  */\n  debugSpectorJS?: boolean;\n  /** WebGL specific - SpectorJS URL. Override if CDN is down or different SpectorJS version is desired. */\n  debugSpectorJSUrl?: string;\n\n  // EXPERIMENTAL SETTINGS - subject to change\n\n  /** adapter.create() returns the existing Device if the provided canvas' WebGL context is already associated with a Device.  */\n  _reuseDevices?: boolean;\n  /** WebGPU specific - Request a Device with the highest limits supported by platform. On WebGPU devices can be created with minimal limits. */\n  _requestMaxLimits?: boolean;\n  /** Disable specific features */\n  _disabledFeatures?: Partial<Record<DeviceFeature, boolean>>;\n  /** WebGL specific - Initialize all features on startup */\n  _initializeFeatures?: boolean;\n  /** Never destroy cached shaders and pipelines */\n  _factoryDestroyPolicy?: 'unused' | 'never';\n  /** Resource default overrides */\n  _resourceDefaults?: {\n    texture?: Partial<TextureProps>;\n    sampler?: Partial<SamplerProps>;\n    renderPass?: Partial<RenderPassProps>;\n  };\n\n  /** @deprecated Internal, Do not use directly! Use `luma.attachDevice()` to attach to pre-created contexts/devices. */\n  _handle?: unknown; // WebGL2RenderingContext | GPUDevice | null;\n};\n\n/** WebGL independent copy of WebGLContextAttributes */\ntype WebGLContextProps = {\n  alpha?: boolean; // indicates if the canvas contains an alpha buffer.\n  desynchronized?: boolean; // hints the user agent to reduce the latency by desynchronizing the canvas paint cycle from the event loop\n  antialias?: boolean; // indicates whether or not to perform anti-aliasing.\n  depth?: boolean; // indicates that the drawing buffer has a depth buffer of at least 16 bits.\n  failIfMajorPerformanceCaveat?: boolean; // indicates if a context will be created if the system performance is low or if no hardware GPU is available.\n  powerPreference?: 'default' | 'high-performance' | 'low-power';\n  premultipliedAlpha?: boolean; // page compositor will assume the drawing buffer contains colors with pre-multiplied alpha.\n  preserveDrawingBuffer?: boolean; // buffers will not be cleared and will preserve their values until cleared or overwritten by the author.\n};\n\n/**\n * Create and attach devices for a specific backend. Currently static methods on each device\n */\nexport interface DeviceFactory {\n  // new (props: DeviceProps): Device; Constructor isn't used\n  type: string;\n  isSupported(): boolean;\n  create(props: DeviceProps): Promise<Device>;\n  attach?(handle: unknown): Device;\n}\n\n/**\n * WebGPU Device/WebGL context abstraction\n */\nexport abstract class Device {\n  static defaultProps: Required<DeviceProps> = {\n    id: null!,\n    powerPreference: 'high-performance',\n    failIfMajorPerformanceCaveat: false,\n    createCanvasContext: undefined!,\n\n    // Callbacks\n    onError: (error: Error) => log.error(error.message)(),\n\n    // Experimental\n    _reuseDevices: false,\n    _requestMaxLimits: true,\n    _factoryDestroyPolicy: 'unused',\n    // TODO - Change these after confirming things work as expected\n    _initializeFeatures: true,\n    _disabledFeatures: {\n      'compilation-status-async-webgl': true\n    },\n    _resourceDefaults: {},\n\n    // WebGL specific\n    webgl: {},\n\n    debug: log.get('debug') || undefined!,\n    debugShaders: log.get('debug-shaders') || undefined!,\n    debugFramebuffers: Boolean(log.get('debug-framebuffers')),\n    debugWebGL: Boolean(log.get('debug-webgl')),\n    debugSpectorJS: undefined!, // Note: log setting is queried by the spector.js code\n    debugSpectorJSUrl: undefined!,\n\n    // INTERNAL\n    _handle: undefined!\n  };\n\n  get [Symbol.toStringTag](): string {\n    return 'Device';\n  }\n\n  constructor(props: DeviceProps) {\n    this.props = {...Device.defaultProps, ...props};\n    this.id = this.props.id || uid(this[Symbol.toStringTag].toLowerCase());\n  }\n\n  /** id of this device, primarily for debugging */\n  readonly id: string;\n  /** type of this device */\n  abstract readonly type: 'webgl' | 'webgpu' | 'unknown';\n  /** A copy of the device props  */\n  readonly props: Required<DeviceProps>;\n  /** Available for the application to store data on the device */\n  userData: {[key: string]: unknown} = {};\n  /** stats */\n  readonly statsManager: StatsManager = lumaStats;\n  /** An abstract timestamp used for change tracking */\n  timestamp: number = 0;\n\n  /** True if this device has been reused during device creation (app has multiple references) */\n  _reused: boolean = false;\n  /** Used by other luma.gl modules to store data on the device */\n  _lumaData: {[key: string]: unknown} = {};\n\n  abstract destroy(): void;\n\n  // Capabilities\n\n  /** Information about the device (vendor, versions etc) */\n  abstract info: DeviceInfo;\n  /** Optional capability discovery */\n  abstract features: DeviceFeatures;\n  /** WebGPU style device limits */\n  abstract get limits(): DeviceLimits;\n\n  /** Determines what operations are supported on a texture format, checking against supported device features */\n  getTextureFormatCapabilities(format: TextureFormat): DeviceTextureFormatCapabilities {\n    const genericCapabilities = getTextureFormatCapabilities(format);\n\n    // Check standard features\n    const checkFeature = (featureOrBoolean: DeviceFeature | boolean | undefined) =>\n      (typeof featureOrBoolean === 'string'\n        ? this.features.has(featureOrBoolean)\n        : featureOrBoolean) ?? true;\n\n    const supported = checkFeature(genericCapabilities.create);\n\n    const deviceCapabilities: DeviceTextureFormatCapabilities = {\n      format,\n      create: supported,\n      render: supported && checkFeature(genericCapabilities.render),\n      filter: supported && checkFeature(genericCapabilities.filter),\n      blend: supported && checkFeature(genericCapabilities.blend),\n      store: supported && checkFeature(genericCapabilities.store)\n    };\n\n    return this._getDeviceSpecificTextureFormatCapabilities(deviceCapabilities);\n  }\n\n  /** Check if device supports a specific texture format (creation and `nearest` sampling) */\n  isTextureFormatSupported(\n    format: TextureFormat,\n    capabilities: Partial<TextureFormatCapabilities>\n  ): boolean {\n    return this.getTextureFormatCapabilities(format).create;\n  }\n\n  /** Check if linear filtering (sampler interpolation) is supported for a specific texture format */\n  isTextureFormatFilterable(format: TextureFormat): boolean {\n    return this.getTextureFormatCapabilities(format).filter;\n  }\n\n  /** Check if device supports rendering to a framebuffer color attachment of a specific texture format */\n  isTextureFormatRenderable(format: TextureFormat): boolean {\n    return this.getTextureFormatCapabilities(format).render;\n  }\n\n  /** Check if a specific texture format is GPU compressed */\n  isTextureFormatCompressed(format: TextureFormat): boolean {\n    return isTextureFormatCompressed(format);\n  }\n\n  // Device loss\n\n  /** `true` if device is already lost */\n  abstract get isLost(): boolean;\n\n  /** Promise that resolves when device is lost */\n  abstract readonly lost: Promise<{reason: 'destroyed'; message: string}>;\n\n  /**\n   * Trigger device loss.\n   * @returns `true` if context loss could actually be triggered.\n   * @note primarily intended for testing how application reacts to device loss\n   */\n  loseDevice(): boolean {\n    return false;\n  }\n\n  /** Report error (normally called for unhandled device errors) */\n  reportError(error: Error): void {\n    this.props.onError(error);\n  }\n\n  // Canvas context\n\n  /** Default / primary canvas context. Can be null as WebGPU devices can be created without a CanvasContext */\n  abstract canvasContext: CanvasContext | null;\n\n  /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */\n  getDefaultCanvasContext(): CanvasContext {\n    if (!this.canvasContext) {\n      throw new Error('Device has no default CanvasContext. See props.createCanvasContext');\n    }\n    return this.canvasContext;\n  }\n\n  /** Creates a new CanvasContext (WebGPU only) */\n  abstract createCanvasContext(props?: CanvasContextProps): CanvasContext;\n\n  /** Call after rendering a frame (necessary e.g. on WebGL OffscreenCanvas) */\n  abstract submit(): void;\n\n  // Resource creation\n\n  /** Create a buffer */\n  abstract createBuffer(props: BufferProps | ArrayBuffer | ArrayBufferView): Buffer;\n\n  /** Create a texture */\n  abstract createTexture(props: TextureProps): Texture;\n\n  /** Create a temporary texture view of a video source */\n  abstract createExternalTexture(props: ExternalTextureProps): ExternalTexture;\n\n  /** Create a sampler */\n  abstract createSampler(props: SamplerProps): Sampler;\n\n  /** Create a Framebuffer. Must have at least one attachment. */\n  abstract createFramebuffer(props: FramebufferProps): Framebuffer;\n\n  /** Create a shader */\n  abstract createShader(props: ShaderProps): Shader;\n\n  /** Create a render pipeline (aka program) */\n  abstract createRenderPipeline(props: RenderPipelineProps): RenderPipeline;\n\n  /** Create a compute pipeline (aka program). WebGPU only. */\n  abstract createComputePipeline(props: ComputePipelineProps): ComputePipeline;\n\n  /** Create a vertex array */\n  abstract createVertexArray(props: VertexArrayProps): VertexArray;\n\n  /** Create a RenderPass */\n  abstract beginRenderPass(props?: RenderPassProps): RenderPass;\n\n  /** Create a ComputePass */\n  abstract beginComputePass(props?: ComputePassProps): ComputePass;\n\n  /** Create a transform feedback (immutable set of output buffer bindings). WebGL only. */\n  abstract createTransformFeedback(props: TransformFeedbackProps): TransformFeedback;\n\n  abstract createQuerySet(props: QuerySetProps): QuerySet;\n\n  createCommandEncoder(props: CommandEncoderProps = {}): CommandEncoder {\n    throw new Error('not implemented');\n  }\n\n  /** A monotonic counter for tracking buffer and texture updates */\n  incrementTimestamp(): number {\n    return this.timestamp++;\n  }\n\n  // Error Handling\n\n  /** Report unhandled device errors */\n  onError(error: Error) {\n    this.props.onError(error);\n  }\n\n  // DEPRECATED METHODS\n\n  /** @deprecated Use getDefaultCanvasContext() */\n  getCanvasContext(): CanvasContext {\n    return this.getDefaultCanvasContext();\n  }\n\n  // WebGL specific HACKS - enables app to remove webgl import\n  // Use until we have a better way to handle these\n\n  /** @deprecated - will be removed - should use command encoder */\n  readPixelsToArrayWebGL(\n    source: Framebuffer | Texture,\n    options?: {\n      sourceX?: number;\n      sourceY?: number;\n      sourceFormat?: number;\n      sourceAttachment?: number;\n      target?: Uint8Array | Uint16Array | Float32Array;\n      // following parameters are auto deduced if not provided\n      sourceWidth?: number;\n      sourceHeight?: number;\n      sourceType?: number;\n    }\n  ): Uint8Array | Uint16Array | Float32Array {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use command encoder */\n  readPixelsToBufferWebGL(\n    source: Framebuffer | Texture,\n    options?: {\n      sourceX?: number;\n      sourceY?: number;\n      sourceFormat?: number;\n      target?: Buffer; // A new Buffer object is created when not provided.\n      targetByteOffset?: number; // byte offset in buffer object\n      // following parameters are auto deduced if not provided\n      sourceWidth?: number;\n      sourceHeight?: number;\n      sourceType?: number;\n    }\n  ): Buffer {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  setParametersWebGL(parameters: any): void {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  getParametersWebGL(parameters: any): void {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */\n  withParametersWebGL(parameters: any, func: any): any {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use clear arguments in RenderPass */\n  clearWebGL(options?: {framebuffer?: Framebuffer; color?: any; depth?: any; stencil?: any}): void {\n    throw new Error('not implemented');\n  }\n\n  /** @deprecated - will be removed - should use for debugging only */\n  resetWebGL(): void {\n    throw new Error('not implemented');\n  }\n\n  // IMPLEMENTATION\n\n  /** Helper to get the canvas context props */\n  static _getCanvasContextProps(props: DeviceProps): CanvasContextProps | undefined {\n    return props.createCanvasContext === true ? {} : props.createCanvasContext;\n  }\n\n  /**\n   * Determines what operations are supported on a texture format, checking against supported device features\n   * Subclasses override to apply additional checks\n   */\n  protected abstract _getDeviceSpecificTextureFormatCapabilities(\n    format: DeviceTextureFormatCapabilities\n  ): DeviceTextureFormatCapabilities;\n\n  /** Subclasses use this to support .createBuffer() overloads */\n  protected _normalizeBufferProps(props: BufferProps | ArrayBuffer | ArrayBufferView): BufferProps {\n    if (props instanceof ArrayBuffer || ArrayBuffer.isView(props)) {\n      props = {data: props};\n    }\n\n    // TODO - fragile, as this is done before we merge with default options\n    // inside the Buffer constructor\n\n    const newProps = {...props};\n    // Deduce indexType\n    if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {\n      if (props.data instanceof Uint32Array) {\n        newProps.indexType = 'uint32';\n      } else if (props.data instanceof Uint16Array) {\n        newProps.indexType = 'uint16';\n      } else {\n        log.warn('indices buffer content must be of integer type')();\n      }\n    }\n    return newProps;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}