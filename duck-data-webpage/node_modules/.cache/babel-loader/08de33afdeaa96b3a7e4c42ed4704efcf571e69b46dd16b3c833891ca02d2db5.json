{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* eslint-disable no-console */\n// Avoid using named imports for Node builtins to help with \"empty\" resolution\n// for bundlers targeting browser environments. Access imports & types\n// through the `ChildProcess` object (e.g. `ChildProcess.spawn`, `ChildProcess.ChildProcess`).\nimport * as ChildProcess from 'child_process';\nimport { getAvailablePort } from \"./process-utils.js\";\nconst DEFAULT_PROPS = {\n  command: '',\n  arguments: [],\n  port: 5000,\n  autoPort: true,\n  wait: 2000,\n  onSuccess: processProxy => {\n    console.log(`Started ${processProxy.props.command}`);\n  }\n};\n/**\n * Manager for a Node.js child process\n * Prepares arguments, starts, stops and tracks output\n */\nexport default class ChildProcessProxy {\n  id;\n  props = {\n    ...DEFAULT_PROPS\n  };\n  childProcess = null;\n  port = 0;\n  successTimer; // NodeJS.Timeout;\n  // constructor(props?: {id?: string});\n  constructor({\n    id = 'browser-driver'\n  } = {}) {\n    this.id = id;\n  }\n  /** Starts a child process with the provided props */\n  async start(props) {\n    props = {\n      ...DEFAULT_PROPS,\n      ...props\n    };\n    this.props = props;\n    const args = [...props.arguments];\n    // If portArg is set, we can look up an available port\n    this.port = Number(props.port);\n    if (props.portArg) {\n      if (props.autoPort) {\n        this.port = await getAvailablePort(props.port);\n      }\n      args.push(props.portArg, String(this.port));\n    }\n    return await new Promise((resolve, reject) => {\n      try {\n        this._setTimeout(() => {\n          if (props.onSuccess) {\n            props.onSuccess(this);\n          }\n          resolve({});\n        });\n        console.log(`Spawning ${props.command} ${props.arguments.join(' ')}`);\n        const childProcess = ChildProcess.spawn(props.command, args, props.spawn);\n        this.childProcess = childProcess;\n        childProcess.stdout.on('data', data => {\n          console.log(data.toString());\n        });\n        childProcess.stderr.on('data', data => {\n          console.log(`Child process wrote to stderr: \"${data}\".`);\n          if (!props.ignoreStderr) {\n            this._clearTimeout();\n            reject(new Error(data));\n          }\n        });\n        childProcess.on('error', error => {\n          console.log(`Child process errored with ${error}`);\n          this._clearTimeout();\n          reject(error);\n        });\n        childProcess.on('close', code => {\n          console.log(`Child process exited with ${code}`);\n          this.childProcess = null;\n          this._clearTimeout();\n          resolve({});\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  /** Stops a running child process */\n  async stop() {\n    if (this.childProcess) {\n      this.childProcess.kill();\n      this.childProcess = null;\n    }\n  }\n  /** Exits this process */\n  async exit(statusCode = 0) {\n    try {\n      await this.stop();\n      // eslint-disable-next-line no-process-exit\n      process.exit(statusCode);\n    } catch (error) {\n      console.error(error.message || error);\n      // eslint-disable-next-line no-process-exit\n      process.exit(1);\n    }\n  }\n  _setTimeout(callback) {\n    if (Number(this.props.wait) > 0) {\n      this.successTimer = setTimeout(callback, this.props.wait);\n    }\n  }\n  _clearTimeout() {\n    if (this.successTimer) {\n      clearTimeout(this.successTimer);\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}