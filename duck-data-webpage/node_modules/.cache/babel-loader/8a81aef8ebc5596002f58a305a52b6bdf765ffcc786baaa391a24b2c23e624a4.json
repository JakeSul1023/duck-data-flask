{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Copyright 2022 Foursquare Labs, Inc\n/* global TextEncoder, TextDecoder */\nimport { concatenateArrayBuffers } from '@loaders.gl/loader-utils';\nexport async function encodeTable(data, writer, options) {\n  if (writer.encode) {\n    return await writer.encode(data, options);\n  }\n  if (writer.encodeText) {\n    const text = await writer.encodeText(data, options);\n    return new TextEncoder().encode(text);\n  }\n  if (writer.encodeInBatches) {\n    // Create an iterator representing the data\n    // TODO - Assumes this is a table\n    const batches = encodeTableInBatches(data, writer, options);\n    // Concatenate the output\n    const chunks = [];\n    for await (const batch of batches) {\n      chunks.push(batch);\n    }\n    return concatenateArrayBuffers(...chunks);\n  }\n  throw new Error('Writer could not encode data');\n}\nexport async function encodeTableAsText(data, writer, options) {\n  if (writer.text && writer.encodeText) {\n    return await writer.encodeText(data, options);\n  }\n  if (writer.text) {\n    const arrayBuffer = await encodeTable(data, writer, options);\n    return new TextDecoder().decode(arrayBuffer);\n  }\n  throw new Error(`Writer ${writer.name} could not encode data as text`);\n}\nexport function encodeTableInBatches(data, writer, options) {\n  if (writer.encodeInBatches) {\n    const dataIterator = getIterator(data);\n    // @ts-expect-error\n    return writer.encodeInBatches(dataIterator, options);\n  }\n  // TODO -fall back to atomic encode?\n  throw new Error('Writer could not encode data in batches');\n}\nfunction getIterator(data) {\n  const dataIterator = [{\n    ...data,\n    start: 0,\n    end: data.length\n  }];\n  return dataIterator;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}