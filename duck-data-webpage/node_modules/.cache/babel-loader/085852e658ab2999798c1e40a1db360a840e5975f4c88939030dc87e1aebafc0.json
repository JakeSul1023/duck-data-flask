{"ast":null,"code":"import { assert } from \"../env-utils/assert.js\";\n/**\n * Calculate new size of an arrayBuffer to be aligned to an n-byte boundary\n * This function increases `byteLength` by the minimum delta,\n * allowing the total length to be divided by `padding`\n * @param byteLength\n * @param padding\n */\nexport function padToNBytes(byteLength, padding) {\n  assert(byteLength >= 0); // `Incorrect 'byteLength' value: ${byteLength}`\n  assert(padding > 0); // `Incorrect 'padding' value: ${padding}`\n  return byteLength + (padding - 1) & ~(padding - 1);\n}\n/**\n * Creates a new Uint8Array based on two different ArrayBuffers\n * @param targetBuffer The first buffer.\n * @param sourceBuffer The second buffer.\n * @return The new ArrayBuffer created out of the two.\n */\nexport function copyArrayBuffer(targetBuffer, sourceBuffer, byteOffset, byteLength = sourceBuffer.byteLength) {\n  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);\n  const sourceArray = new Uint8Array(sourceBuffer);\n  targetArray.set(sourceArray);\n  return targetBuffer;\n}\n/**\n * Copy from source to target at the targetOffset\n *\n * @param source - The data to copy\n * @param target - The destination to copy data into\n * @param targetOffset - The start offset into target to place the copied data\n * @returns the new offset taking into account proper padding\n */\nexport function copyToArray(source, target, targetOffset) {\n  let sourceArray;\n  if (source instanceof ArrayBuffer) {\n    sourceArray = new Uint8Array(source);\n  } else {\n    // Pack buffer onto the big target array\n    //\n    // 'source.data.buffer' could be a view onto a larger buffer.\n    // We MUST use this constructor to ensure the byteOffset and byteLength is\n    // set to correct values from 'source.data' and not the underlying\n    // buffer for target.set() to work properly.\n    const srcByteOffset = source.byteOffset;\n    const srcByteLength = source.byteLength;\n    // In gltf parser it is set as \"arrayBuffer\" instead of \"buffer\"\n    // https://github.com/visgl/loaders.gl/blob/1e3a82a0a65d7b6a67b1e60633453e5edda2960a/modules/gltf/src/lib/parse-gltf.js#L85\n    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);\n  }\n  // Pack buffer onto the big target array\n  target.set(sourceArray, targetOffset);\n  return targetOffset + padToNBytes(sourceArray.byteLength, 4);\n}","map":{"version":3,"names":["assert","padToNBytes","byteLength","padding","copyArrayBuffer","targetBuffer","sourceBuffer","byteOffset","targetArray","Uint8Array","sourceArray","set","copyToArray","source","target","targetOffset","ArrayBuffer","srcByteOffset","srcByteLength","buffer","arrayBuffer"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-copy-utils.js"],"sourcesContent":["import { assert } from \"../env-utils/assert.js\";\n/**\n * Calculate new size of an arrayBuffer to be aligned to an n-byte boundary\n * This function increases `byteLength` by the minimum delta,\n * allowing the total length to be divided by `padding`\n * @param byteLength\n * @param padding\n */\nexport function padToNBytes(byteLength, padding) {\n    assert(byteLength >= 0); // `Incorrect 'byteLength' value: ${byteLength}`\n    assert(padding > 0); // `Incorrect 'padding' value: ${padding}`\n    return (byteLength + (padding - 1)) & ~(padding - 1);\n}\n/**\n * Creates a new Uint8Array based on two different ArrayBuffers\n * @param targetBuffer The first buffer.\n * @param sourceBuffer The second buffer.\n * @return The new ArrayBuffer created out of the two.\n */\nexport function copyArrayBuffer(targetBuffer, sourceBuffer, byteOffset, byteLength = sourceBuffer.byteLength) {\n    const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);\n    const sourceArray = new Uint8Array(sourceBuffer);\n    targetArray.set(sourceArray);\n    return targetBuffer;\n}\n/**\n * Copy from source to target at the targetOffset\n *\n * @param source - The data to copy\n * @param target - The destination to copy data into\n * @param targetOffset - The start offset into target to place the copied data\n * @returns the new offset taking into account proper padding\n */\nexport function copyToArray(source, target, targetOffset) {\n    let sourceArray;\n    if (source instanceof ArrayBuffer) {\n        sourceArray = new Uint8Array(source);\n    }\n    else {\n        // Pack buffer onto the big target array\n        //\n        // 'source.data.buffer' could be a view onto a larger buffer.\n        // We MUST use this constructor to ensure the byteOffset and byteLength is\n        // set to correct values from 'source.data' and not the underlying\n        // buffer for target.set() to work properly.\n        const srcByteOffset = source.byteOffset;\n        const srcByteLength = source.byteLength;\n        // In gltf parser it is set as \"arrayBuffer\" instead of \"buffer\"\n        // https://github.com/visgl/loaders.gl/blob/1e3a82a0a65d7b6a67b1e60633453e5edda2960a/modules/gltf/src/lib/parse-gltf.js#L85\n        sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);\n    }\n    // Pack buffer onto the big target array\n    target.set(sourceArray, targetOffset);\n    return targetOffset + padToNBytes(sourceArray.byteLength, 4);\n}\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,WAAWA,CAACC,UAAU,EAAEC,OAAO,EAAE;EAC7CH,MAAM,CAACE,UAAU,IAAI,CAAC,CAAC,CAAC,CAAC;EACzBF,MAAM,CAACG,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;EACrB,OAAQD,UAAU,IAAIC,OAAO,GAAG,CAAC,CAAC,GAAI,EAAEA,OAAO,GAAG,CAAC,CAAC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAACC,YAAY,EAAEC,YAAY,EAAEC,UAAU,EAAEL,UAAU,GAAGI,YAAY,CAACJ,UAAU,EAAE;EAC1G,MAAMM,WAAW,GAAG,IAAIC,UAAU,CAACJ,YAAY,EAAEE,UAAU,EAAEL,UAAU,CAAC;EACxE,MAAMQ,WAAW,GAAG,IAAID,UAAU,CAACH,YAAY,CAAC;EAChDE,WAAW,CAACG,GAAG,CAACD,WAAW,CAAC;EAC5B,OAAOL,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASO,WAAWA,CAACC,MAAM,EAAEC,MAAM,EAAEC,YAAY,EAAE;EACtD,IAAIL,WAAW;EACf,IAAIG,MAAM,YAAYG,WAAW,EAAE;IAC/BN,WAAW,GAAG,IAAID,UAAU,CAACI,MAAM,CAAC;EACxC,CAAC,MACI;IACD;IACA;IACA;IACA;IACA;IACA;IACA,MAAMI,aAAa,GAAGJ,MAAM,CAACN,UAAU;IACvC,MAAMW,aAAa,GAAGL,MAAM,CAACX,UAAU;IACvC;IACA;IACAQ,WAAW,GAAG,IAAID,UAAU,CAACI,MAAM,CAACM,MAAM,IAAIN,MAAM,CAACO,WAAW,EAAEH,aAAa,EAAEC,aAAa,CAAC;EACnG;EACA;EACAJ,MAAM,CAACH,GAAG,CAACD,WAAW,EAAEK,YAAY,CAAC;EACrC,OAAOA,YAAY,GAAGd,WAAW,CAACS,WAAW,CAACR,UAAU,EAAE,CAAC,CAAC;AAChE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}