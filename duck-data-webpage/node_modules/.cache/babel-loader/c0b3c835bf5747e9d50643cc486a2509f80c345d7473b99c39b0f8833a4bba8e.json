{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { deepEqual } from \"../utils/deep-equal.js\";\nimport LightingEffect from \"../effects/lighting/lighting-effect.js\";\nconst DEFAULT_LIGHTING_EFFECT = new LightingEffect();\n/** Sort two effects. Returns 0 if equal, negative if e1 < e2, positive if e1 > e2 */\nfunction compareEffects(e1, e2) {\n  const o1 = e1.order ?? Infinity;\n  const o2 = e2.order ?? Infinity;\n  return o1 - o2;\n}\nexport default class EffectManager {\n  constructor(context) {\n    this._resolvedEffects = [];\n    /** Effect instances and order preference pairs, sorted by order */\n    this._defaultEffects = [];\n    this.effects = [];\n    this._context = context;\n    this._needsRedraw = 'Initial render';\n    this._setEffects([]);\n  }\n  /**\n   * Register a new default effect, i.e. an effect presents regardless of user supplied props.effects\n   */\n  addDefaultEffect(effect) {\n    const defaultEffects = this._defaultEffects;\n    if (!defaultEffects.find(e => e.id === effect.id)) {\n      const index = defaultEffects.findIndex(e => compareEffects(e, effect) > 0);\n      if (index < 0) {\n        defaultEffects.push(effect);\n      } else {\n        defaultEffects.splice(index, 0, effect);\n      }\n      effect.setup(this._context);\n      this._setEffects(this.effects);\n    }\n  }\n  setProps(props) {\n    if ('effects' in props) {\n      // Compare effects against each other shallowly\n      if (!deepEqual(props.effects, this.effects, 1)) {\n        this._setEffects(props.effects);\n      }\n    }\n  }\n  needsRedraw(opts = {\n    clearRedrawFlags: false\n  }) {\n    const redraw = this._needsRedraw;\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n    return redraw;\n  }\n  getEffects() {\n    return this._resolvedEffects;\n  }\n  _setEffects(effects) {\n    const oldEffectsMap = {};\n    for (const effect of this.effects) {\n      oldEffectsMap[effect.id] = effect;\n    }\n    const nextEffects = [];\n    for (const effect of effects) {\n      const oldEffect = oldEffectsMap[effect.id];\n      let effectToAdd = effect;\n      if (oldEffect && oldEffect !== effect) {\n        if (oldEffect.setProps) {\n          oldEffect.setProps(effect.props);\n          effectToAdd = oldEffect;\n        } else {\n          oldEffect.cleanup(this._context);\n        }\n      } else if (!oldEffect) {\n        effect.setup(this._context);\n      }\n      nextEffects.push(effectToAdd);\n      delete oldEffectsMap[effect.id];\n    }\n    for (const removedEffectId in oldEffectsMap) {\n      oldEffectsMap[removedEffectId].cleanup(this._context);\n    }\n    this.effects = nextEffects;\n    this._resolvedEffects = nextEffects.concat(this._defaultEffects);\n    // Special case for lighting: only add default instance if no LightingEffect is specified\n    if (!effects.some(effect => effect instanceof LightingEffect)) {\n      this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT);\n    }\n    this._needsRedraw = 'effects changed';\n  }\n  finalize() {\n    for (const effect of this._resolvedEffects) {\n      effect.cleanup(this._context);\n    }\n    this.effects.length = 0;\n    this._resolvedEffects.length = 0;\n    this._defaultEffects.length = 0;\n  }\n}\n//# sourceMappingURL=effect-manager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}