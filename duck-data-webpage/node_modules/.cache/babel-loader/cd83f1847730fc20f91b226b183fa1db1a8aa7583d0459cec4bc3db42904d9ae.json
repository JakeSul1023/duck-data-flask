{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isLoaderObject } from \"../loader-utils/normalize-loader.js\";\nimport { getFetchFunction } from \"../loader-utils/get-fetch-function.js\";\nimport { parseInBatches } from \"./parse-in-batches.js\";\nexport function loadInBatches(files, loaders, options, context) {\n  let loadersArray;\n  // Signature: load(url, options)\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined; // context not supported in short signature\n    options = loaders;\n    loadersArray = undefined;\n  } else {\n    loadersArray = loaders;\n  }\n  // Select fetch function\n  const fetch = getFetchFunction(options || {});\n  // Single url/file\n  if (!Array.isArray(files)) {\n    return loadOneFileInBatches(files, loadersArray, options || {}, fetch);\n  }\n  // Multiple URLs / files\n  const promises = files.map(file => loadOneFileInBatches(file, loadersArray, options || {}, fetch));\n  // No point in waiting here for all responses before starting to stream individual streams?\n  return promises;\n}\nasync function loadOneFileInBatches(file, loaders, options, fetch) {\n  if (typeof file === 'string') {\n    const url = file;\n    const response = await fetch(url);\n    // pick right overload\n    return Array.isArray(loaders) ? await parseInBatches(response, loaders, options) : await parseInBatches(response, loaders, options);\n  }\n  // pick right overload\n  return Array.isArray(loaders) ? await parseInBatches(file, loaders, options) : await parseInBatches(file, loaders, options);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}