{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { _PickLayersPass as PickLayersPass } from '@deck.gl/core';\n/** Renders textures used by the TerrainEffect picking pass */\nexport class TerrainPickingPass extends PickLayersPass {\n  constructor() {\n    super(...arguments);\n    /** Save layer index for use when drawing to terrain cover.\n     * When a terrain cover's picking buffer is rendered,\n     * we need to make sure each layer receives a consistent index (encoded in the alpha channel)\n     * so that a picked color can be decoded back to the correct layer.\n     * Updated in getRenderableLayers which is called in TerrainEffect.preRender\n     */\n    this.drawParameters = {};\n  }\n  getRenderableLayers(viewport, opts) {\n    const {\n      layers\n    } = opts;\n    const result = [];\n    this.drawParameters = {};\n    this._resetColorEncoder(opts.pickZ);\n    const drawParamsByIndex = this._getDrawLayerParams(viewport, opts);\n    for (let i = 0; i < layers.length; i++) {\n      const layer = layers[i];\n      if (!layer.isComposite && drawParamsByIndex[i].shouldDrawLayer) {\n        result.push(layer);\n        this.drawParameters[layer.id] = drawParamsByIndex[i].layerParameters;\n      }\n    }\n    return result;\n  }\n  renderTerrainCover(terrainCover, opts) {\n    // console.log('Updating terrain cover for picking ' + terrainCover.id)\n    const target = terrainCover.getPickingFramebuffer();\n    const viewport = terrainCover.renderViewport;\n    if (!target || !viewport) {\n      return;\n    }\n    const layers = terrainCover.filterLayers(opts.layers);\n    const terrainLayer = terrainCover.targetLayer;\n    if (terrainLayer.props.pickable) {\n      layers.unshift(terrainLayer);\n    }\n    target.resize(viewport);\n    this.render({\n      ...opts,\n      pickingFBO: target,\n      pass: `terrain-cover-picking-${terrainCover.id}`,\n      layers,\n      effects: [],\n      viewports: [viewport],\n      // Disable the default culling because TileLayer would cull sublayers based on the screen viewport,\n      // not the viewport of the terrain cover. Culling is already done by `terrainCover.filterLayers`\n      cullRect: undefined,\n      deviceRect: viewport,\n      pickZ: false\n    });\n  }\n  getLayerParameters(layer, layerIndex, viewport) {\n    let parameters;\n    if (this.drawParameters[layer.id]) {\n      parameters = this.drawParameters[layer.id];\n    } else {\n      parameters = super.getLayerParameters(layer, layerIndex, viewport);\n      parameters.blend = true;\n    }\n    return {\n      ...parameters,\n      depthCompare: 'always'\n    };\n  }\n  getShaderModuleProps(layer, effects, otherShaderModuleProps) {\n    return {\n      terrain: {\n        project: otherShaderModuleProps.project\n      }\n    };\n  }\n}","map":{"version":3,"names":["_PickLayersPass","PickLayersPass","TerrainPickingPass","constructor","drawParameters","getRenderableLayers","viewport","opts","layers","result","_resetColorEncoder","pickZ","drawParamsByIndex","_getDrawLayerParams","i","length","layer","isComposite","shouldDrawLayer","push","id","layerParameters","renderTerrainCover","terrainCover","target","getPickingFramebuffer","renderViewport","filterLayers","terrainLayer","targetLayer","props","pickable","unshift","resize","render","pickingFBO","pass","effects","viewports","cullRect","undefined","deviceRect","getLayerParameters","layerIndex","parameters","blend","depthCompare","getShaderModuleProps","otherShaderModuleProps","terrain","project"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\extensions\\src\\terrain\\terrain-picking-pass.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  Layer,\n  Viewport,\n  LayersPassRenderOptions,\n  _PickLayersPass as PickLayersPass\n} from '@deck.gl/core';\nimport type {TerrainCover} from './terrain-cover';\nimport {Parameters} from '@luma.gl/core';\n\nexport type TerrainPickingPassRenderOptions = LayersPassRenderOptions & {\n  pickZ: boolean;\n};\n\n/** Renders textures used by the TerrainEffect picking pass */\nexport class TerrainPickingPass extends PickLayersPass {\n  /** Save layer index for use when drawing to terrain cover.\n   * When a terrain cover's picking buffer is rendered,\n   * we need to make sure each layer receives a consistent index (encoded in the alpha channel)\n   * so that a picked color can be decoded back to the correct layer.\n   * Updated in getRenderableLayers which is called in TerrainEffect.preRender\n   */\n  drawParameters: Record<string, any> = {};\n\n  getRenderableLayers(viewport: Viewport, opts: TerrainPickingPassRenderOptions): Layer[] {\n    const {layers} = opts;\n    const result: Layer[] = [];\n    this.drawParameters = {};\n    this._resetColorEncoder(opts.pickZ);\n    const drawParamsByIndex = this._getDrawLayerParams(viewport, opts);\n    for (let i = 0; i < layers.length; i++) {\n      const layer = layers[i];\n      if (!layer.isComposite && drawParamsByIndex[i].shouldDrawLayer) {\n        result.push(layer);\n        this.drawParameters[layer.id] = drawParamsByIndex[i].layerParameters;\n      }\n    }\n\n    return result;\n  }\n\n  renderTerrainCover(terrainCover: TerrainCover, opts: Partial<TerrainPickingPassRenderOptions>) {\n    // console.log('Updating terrain cover for picking ' + terrainCover.id)\n    const target = terrainCover.getPickingFramebuffer();\n    const viewport = terrainCover.renderViewport;\n\n    if (!target || !viewport) {\n      return;\n    }\n\n    const layers = terrainCover.filterLayers(opts.layers!);\n    const terrainLayer = terrainCover.targetLayer;\n    if (terrainLayer.props.pickable) {\n      layers.unshift(terrainLayer);\n    }\n    target.resize(viewport);\n\n    this.render({\n      ...opts,\n      pickingFBO: target,\n      pass: `terrain-cover-picking-${terrainCover.id}`,\n      layers,\n      effects: [],\n      viewports: [viewport],\n      // Disable the default culling because TileLayer would cull sublayers based on the screen viewport,\n      // not the viewport of the terrain cover. Culling is already done by `terrainCover.filterLayers`\n      cullRect: undefined,\n      deviceRect: viewport,\n      pickZ: false\n    });\n  }\n\n  protected getLayerParameters(layer: Layer, layerIndex: number, viewport: Viewport): Parameters {\n    let parameters: any;\n    if (this.drawParameters[layer.id]) {\n      parameters = this.drawParameters[layer.id];\n    } else {\n      parameters = super.getLayerParameters(layer, layerIndex, viewport);\n      parameters.blend = true;\n    }\n    return {...parameters, depthCompare: 'always'};\n  }\n\n  getShaderModuleProps(layer: Layer, effects: any, otherShaderModuleProps: Record<string, any>) {\n    return {\n      terrain: {\n        project: otherShaderModuleProps.project\n      }\n    };\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA,SAIEA,eAAe,IAAIC,cAAc,QAC5B,eAAe;AAQtB;AACA,OAAM,MAAOC,kBAAmB,SAAQD,cAAc;EAAtDE,YAAA;;IACE;;;;;;IAMA,KAAAC,cAAc,GAAwB,EAAE;EAoE1C;EAlEEC,mBAAmBA,CAACC,QAAkB,EAAEC,IAAqC;IAC3E,MAAM;MAACC;IAAM,CAAC,GAAGD,IAAI;IACrB,MAAME,MAAM,GAAY,EAAE;IAC1B,IAAI,CAACL,cAAc,GAAG,EAAE;IACxB,IAAI,CAACM,kBAAkB,CAACH,IAAI,CAACI,KAAK,CAAC;IACnC,MAAMC,iBAAiB,GAAG,IAAI,CAACC,mBAAmB,CAACP,QAAQ,EAAEC,IAAI,CAAC;IAClE,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,MAAM,CAACO,MAAM,EAAED,CAAC,EAAE,EAAE;MACtC,MAAME,KAAK,GAAGR,MAAM,CAACM,CAAC,CAAC;MACvB,IAAI,CAACE,KAAK,CAACC,WAAW,IAAIL,iBAAiB,CAACE,CAAC,CAAC,CAACI,eAAe,EAAE;QAC9DT,MAAM,CAACU,IAAI,CAACH,KAAK,CAAC;QAClB,IAAI,CAACZ,cAAc,CAACY,KAAK,CAACI,EAAE,CAAC,GAAGR,iBAAiB,CAACE,CAAC,CAAC,CAACO,eAAe;MACtE;IACF;IAEA,OAAOZ,MAAM;EACf;EAEAa,kBAAkBA,CAACC,YAA0B,EAAEhB,IAA8C;IAC3F;IACA,MAAMiB,MAAM,GAAGD,YAAY,CAACE,qBAAqB,EAAE;IACnD,MAAMnB,QAAQ,GAAGiB,YAAY,CAACG,cAAc;IAE5C,IAAI,CAACF,MAAM,IAAI,CAAClB,QAAQ,EAAE;MACxB;IACF;IAEA,MAAME,MAAM,GAAGe,YAAY,CAACI,YAAY,CAACpB,IAAI,CAACC,MAAO,CAAC;IACtD,MAAMoB,YAAY,GAAGL,YAAY,CAACM,WAAW;IAC7C,IAAID,YAAY,CAACE,KAAK,CAACC,QAAQ,EAAE;MAC/BvB,MAAM,CAACwB,OAAO,CAACJ,YAAY,CAAC;IAC9B;IACAJ,MAAM,CAACS,MAAM,CAAC3B,QAAQ,CAAC;IAEvB,IAAI,CAAC4B,MAAM,CAAC;MACV,GAAG3B,IAAI;MACP4B,UAAU,EAAEX,MAAM;MAClBY,IAAI,EAAE,yBAAyBb,YAAY,CAACH,EAAE,EAAE;MAChDZ,MAAM;MACN6B,OAAO,EAAE,EAAE;MACXC,SAAS,EAAE,CAAChC,QAAQ,CAAC;MACrB;MACA;MACAiC,QAAQ,EAAEC,SAAS;MACnBC,UAAU,EAAEnC,QAAQ;MACpBK,KAAK,EAAE;KACR,CAAC;EACJ;EAEU+B,kBAAkBA,CAAC1B,KAAY,EAAE2B,UAAkB,EAAErC,QAAkB;IAC/E,IAAIsC,UAAe;IACnB,IAAI,IAAI,CAACxC,cAAc,CAACY,KAAK,CAACI,EAAE,CAAC,EAAE;MACjCwB,UAAU,GAAG,IAAI,CAACxC,cAAc,CAACY,KAAK,CAACI,EAAE,CAAC;IAC5C,CAAC,MAAM;MACLwB,UAAU,GAAG,KAAK,CAACF,kBAAkB,CAAC1B,KAAK,EAAE2B,UAAU,EAAErC,QAAQ,CAAC;MAClEsC,UAAU,CAACC,KAAK,GAAG,IAAI;IACzB;IACA,OAAO;MAAC,GAAGD,UAAU;MAAEE,YAAY,EAAE;IAAQ,CAAC;EAChD;EAEAC,oBAAoBA,CAAC/B,KAAY,EAAEqB,OAAY,EAAEW,sBAA2C;IAC1F,OAAO;MACLC,OAAO,EAAE;QACPC,OAAO,EAAEF,sBAAsB,CAACE;;KAEnC;EACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}