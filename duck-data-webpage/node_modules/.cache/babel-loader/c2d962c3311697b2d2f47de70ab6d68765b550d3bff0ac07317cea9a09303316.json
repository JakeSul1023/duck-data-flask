{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { createElement } from 'react';\nimport { View } from '@deck.gl/core';\nimport { inheritsFrom } from \"./inherits-from.js\";\nimport evaluateChildren, { isComponent } from \"./evaluate-children.js\";\nimport { DeckGlContext } from \"./deckgl-context.js\";\n// Iterate over views and reposition children associated with views\n// TODO - Can we supply a similar function for the non-React case?\nexport default function positionChildrenUnderViews({\n  children,\n  deck,\n  ContextProvider = DeckGlContext.Provider\n}) {\n  // @ts-expect-error accessing protected property\n  const {\n    viewManager\n  } = deck || {};\n  if (!viewManager || !viewManager.views.length) {\n    return [];\n  }\n  const views = {};\n  const defaultViewId = viewManager.views[0].id;\n  // Sort children by view id\n  for (const child of children) {\n    // Unless child is a View, position / render as part of the default view\n    let viewId = defaultViewId;\n    let viewChildren = child;\n    if (isComponent(child) && inheritsFrom(child.type, View)) {\n      viewId = child.props.id || defaultViewId;\n      viewChildren = child.props.children;\n    }\n    const viewport = viewManager.getViewport(viewId);\n    const viewState = viewManager.getViewState(viewId);\n    // Drop (auto-hide) elements with viewId that are not matched by any current view\n    if (viewport) {\n      viewState.padding = viewport.padding;\n      const {\n        x,\n        y,\n        width,\n        height\n      } = viewport;\n      // Resolve potentially relative dimensions using the deck.gl container size\n      viewChildren = evaluateChildren(viewChildren, {\n        x,\n        y,\n        width,\n        height,\n        viewport,\n        viewState\n      });\n      if (!views[viewId]) {\n        views[viewId] = {\n          viewport,\n          children: []\n        };\n      }\n      views[viewId].children.push(viewChildren);\n    }\n  }\n  // Render views\n  return Object.keys(views).map(viewId => {\n    const {\n      viewport,\n      children: viewChildren\n    } = views[viewId];\n    const {\n      x,\n      y,\n      width,\n      height\n    } = viewport;\n    const style = {\n      position: 'absolute',\n      left: x,\n      top: y,\n      width,\n      height\n    };\n    const key = `view-${viewId}`;\n    // If children is passed as an array, React will throw the \"each element in a list needs\n    // a key\" warning. Sending each child as separate arguments removes this requirement.\n    const viewElement = createElement('div', {\n      key,\n      id: key,\n      style\n    }, ...viewChildren);\n    const contextValue = {\n      deck,\n      viewport,\n      // @ts-expect-error accessing protected property\n      container: deck.canvas.offsetParent,\n      // @ts-expect-error accessing protected property\n      eventManager: deck.eventManager,\n      onViewStateChange: params => {\n        params.viewId = viewId;\n        // @ts-expect-error accessing protected method\n        deck._onViewStateChange(params);\n      },\n      widgets: []\n    };\n    const providerKey = `view-${viewId}-context`;\n    return createElement(ContextProvider, {\n      key: providerKey,\n      value: contextValue\n    }, viewElement);\n  });\n}\n//# sourceMappingURL=position-children-under-views.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}