{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { assert } from '@loaders.gl/loader-utils';\nimport { createTypedArrayFromAccessor } from \"./helpers/tile-3d-accessor-utils.js\";\nimport { initializeHierarchy, traverseHierarchy } from \"./tile-3d-batch-table-hierarchy.js\";\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\nconst clone = (x, y) => x;\n// These top level fields in the batch table json are not properties\nconst IGNORED_PROPERTY_FIELDS = {\n  HIERARCHY: true,\n  // Deprecated HIERARCHY property\n  extensions: true,\n  extras: true\n};\n// The size of this array equals the maximum instance count among all loaded tiles, which has the potential to be large.\nexport default class Tile3DBatchTableParser {\n  json;\n  binary;\n  featureCount;\n  _extensions;\n  // Copy all top-level property fields from the json object, ignoring special fields\n  _properties;\n  _binaryProperties;\n  // TODO: hierarchy support is only partially implemented and not tested\n  _hierarchy;\n  constructor(json, binary, featureCount, options = {}) {\n    assert(featureCount >= 0);\n    this.json = json || {};\n    this.binary = binary;\n    this.featureCount = featureCount;\n    this._extensions = this.json?.extensions || {};\n    // Copy all top-level property fields from the json object, ignoring special fields\n    this._properties = {};\n    for (const propertyName in this.json) {\n      if (!IGNORED_PROPERTY_FIELDS[propertyName]) {\n        this._properties[propertyName] = this.json[propertyName];\n      }\n    }\n    this._binaryProperties = this._initializeBinaryProperties();\n    // TODO: hierarchy support is only partially implemented and not tested\n    if (options['3DTILES_batch_table_hierarchy']) {\n      this._hierarchy = initializeHierarchy(this, this.json, this.binary);\n    }\n  }\n  getExtension(extensionName) {\n    return this.json && this.json.extensions && this.json.extensions[extensionName];\n  }\n  memorySizeInBytes() {\n    return 0;\n  }\n  isClass(batchId, className) {\n    this._checkBatchId(batchId);\n    assert(typeof className === 'string', className);\n    // extension: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      // PERFORMANCE_IDEA : cache results in the ancestor classes\n      //   to speed up this check if this area becomes a hotspot\n      // PERFORMANCE_IDEA : treat class names as integers for faster comparisons\n      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n        const classId = hierarchy.classIds[instanceIndex];\n        const instanceClass = hierarchy.classes[classId];\n        return instanceClass.name === className;\n      });\n      return defined(result);\n    }\n    return false;\n  }\n  isExactClass(batchId, className) {\n    assert(typeof className === 'string', className);\n    return this.getExactClassName(batchId) === className;\n  }\n  getExactClassName(batchId) {\n    this._checkBatchId(batchId);\n    // extension: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      const classId = this._hierarchy.classIds[batchId];\n      const instanceClass = this._hierarchy.classes[classId];\n      return instanceClass.name;\n    }\n    return undefined;\n  }\n  hasProperty(batchId, name) {\n    this._checkBatchId(batchId);\n    assert(typeof name === 'string', name);\n    return defined(this._properties[name]) || this._hasPropertyInHierarchy(batchId, name);\n  }\n  getPropertyNames(batchId, results) {\n    this._checkBatchId(batchId);\n    results = defined(results) ? results : [];\n    results.length = 0;\n    const propertyNames = Object.keys(this._properties);\n    results.push(...propertyNames);\n    if (this._hierarchy) {\n      this._getPropertyNamesInHierarchy(batchId, results);\n    }\n    return results;\n  }\n  getProperty(batchId, name) {\n    this._checkBatchId(batchId);\n    assert(typeof name === 'string', name);\n    if (this._binaryProperties) {\n      const binaryProperty = this._binaryProperties[name];\n      if (defined(binaryProperty)) {\n        return this._getBinaryProperty(binaryProperty, batchId);\n      }\n    }\n    const propertyValues = this._properties[name];\n    if (defined(propertyValues)) {\n      return clone(propertyValues[batchId], true);\n    }\n    // EXTENSION: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      const hierarchyProperty = this._getHierarchyProperty(batchId, name);\n      if (defined(hierarchyProperty)) {\n        return hierarchyProperty;\n      }\n    }\n    return undefined;\n  }\n  setProperty(batchId, name, value) {\n    const featureCount = this.featureCount;\n    this._checkBatchId(batchId);\n    assert(typeof name === 'string', name);\n    if (this._binaryProperties) {\n      const binaryProperty = this._binaryProperties[name];\n      if (binaryProperty) {\n        this._setBinaryProperty(binaryProperty, batchId, value);\n        return;\n      }\n    }\n    // EXTENSION: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      if (this._setHierarchyProperty(this, batchId, name, value)) {\n        return;\n      }\n    }\n    let propertyValues = this._properties[name];\n    if (!defined(propertyValues)) {\n      // Property does not exist. Create it.\n      this._properties[name] = new Array(featureCount);\n      propertyValues = this._properties[name];\n    }\n    propertyValues[batchId] = clone(value, true);\n  }\n  // PRIVATE METHODS\n  _checkBatchId(batchId) {\n    const valid = batchId >= 0 && batchId < this.featureCount;\n    if (!valid) {\n      throw new Error('batchId not in range [0, featureCount - 1].');\n    }\n  }\n  _getBinaryProperty(binaryProperty, index) {\n    return binaryProperty.unpack(binaryProperty.typedArray, index);\n  }\n  _setBinaryProperty(binaryProperty, index, value) {\n    binaryProperty.pack(value, binaryProperty.typedArray, index);\n  }\n  _initializeBinaryProperties() {\n    let binaryProperties = null;\n    for (const name in this._properties) {\n      const property = this._properties[name];\n      const binaryProperty = this._initializeBinaryProperty(name, property);\n      // Store any information needed to access the binary data, including the typed array,\n      // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n      if (binaryProperty) {\n        binaryProperties = binaryProperties || {};\n        binaryProperties[name] = binaryProperty;\n      }\n    }\n    return binaryProperties;\n  }\n  _initializeBinaryProperty(name, property) {\n    if ('byteOffset' in property) {\n      // This is a binary property\n      const tile3DAccessor = property;\n      assert(this.binary, `Property ${name} requires a batch table binary.`);\n      assert(tile3DAccessor.type, `Property ${name} requires a type.`);\n      const accessor = createTypedArrayFromAccessor(tile3DAccessor, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);\n      // Store any information needed to access the binary data, including the typed array,\n      // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n      return {\n        typedArray: accessor.values,\n        componentCount: accessor.size,\n        unpack: accessor.unpacker,\n        pack: accessor.packer\n      };\n    }\n    return null;\n  }\n  //  EXTENSION SUPPORT: 3DTILES_batch_table_hierarchy\n  _hasPropertyInHierarchy(batchId, name) {\n    if (!this._hierarchy) {\n      return false;\n    }\n    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instances = hierarchy.classes[classId].instances;\n      return defined(instances[name]);\n    });\n    return defined(result);\n  }\n  _getPropertyNamesInHierarchy(batchId, results) {\n    traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instances = hierarchy.classes[classId].instances;\n      for (const name in instances) {\n        if (instances.hasOwnProperty(name)) {\n          if (results.indexOf(name) === -1) {\n            results.push(name);\n          }\n        }\n      }\n    });\n  }\n  _getHierarchyProperty(batchId, name) {\n    return traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instanceClass = hierarchy.classes[classId];\n      const indexInClass = hierarchy.classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[name];\n      if (defined(propertyValues)) {\n        if (defined(propertyValues.typedArray)) {\n          return this._getBinaryProperty(propertyValues, indexInClass);\n        }\n        return clone(propertyValues[indexInClass], true);\n      }\n      return null;\n    });\n  }\n  _setHierarchyProperty(batchTable, batchId, name, value) {\n    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instanceClass = hierarchy.classes[classId];\n      const indexInClass = hierarchy.classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[name];\n      if (defined(propertyValues)) {\n        assert(instanceIndex === batchId, `Inherited property \"${name}\" is read-only.`);\n        if (defined(propertyValues.typedArray)) {\n          this._setBinaryProperty(propertyValues, indexInClass, value);\n        } else {\n          propertyValues[indexInClass] = clone(value, true);\n        }\n        return true;\n      }\n      return false;\n    });\n    return defined(result);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}