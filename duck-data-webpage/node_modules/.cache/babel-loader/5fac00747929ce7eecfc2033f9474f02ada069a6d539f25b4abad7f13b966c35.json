{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Extensions to math.gl library. Intended to be folded back.\nimport typedArrayManager from \"./typed-array-manager.js\";\nimport { Vector3 } from '@math.gl/core';\n// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()\nexport function createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nexport function mod(value, divisor) {\n  const modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\n// Extract camera vectors (move to math library?)\nexport function getCameraPosition(viewMatrixInverse) {\n  // Read the translation from the inverse view matrix\n  return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];\n}\n// https://www.gamedevs.org/uploads/fast-extraction-viewing-frustum-planes-from-world-view-projection-matrix.pdf\nexport function getFrustumPlanes(viewProjectionMatrix) {\n  return {\n    left: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]),\n    right: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]),\n    bottom: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]),\n    top: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]),\n    near: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]),\n    far: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14])\n  };\n}\nconst scratchVector = new Vector3();\nfunction getFrustumPlane(a, b, c, d) {\n  scratchVector.set(a, b, c);\n  const L = scratchVector.len();\n  return {\n    distance: d / L,\n    normal: new Vector3(-a / L, -b / L, -c / L)\n  };\n}\n/**\n * Calculate the low part of a WebGL 64 bit float\n * @param x {number} - the input float number\n * @returns {number} - the lower 32 bit of the number\n */\nexport function fp64LowPart(x) {\n  return x - Math.fround(x);\n}\nlet scratchArray;\n/**\n * Split a Float64Array into a double-length Float32Array\n * @param typedArray\n * @param options\n * @param options.size  - per attribute size\n * @param options.startIndex - start index in the source array\n * @param options.endIndex  - end index in the source array\n * @returns {} - high part, low part for each attribute:\n    [1xHi, 1yHi, 1zHi, 1xLow, 1yLow, 1zLow, 2xHi, ...]\n */\nexport function toDoublePrecisionArray(typedArray, options) {\n  const {\n    size = 1,\n    startIndex = 0\n  } = options;\n  const endIndex = options.endIndex !== undefined ? options.endIndex : typedArray.length;\n  const count = (endIndex - startIndex) / size;\n  scratchArray = typedArrayManager.allocate(scratchArray, count, {\n    type: Float32Array,\n    size: size * 2\n  });\n  let sourceIndex = startIndex;\n  let targetIndex = 0;\n  while (sourceIndex < endIndex) {\n    for (let j = 0; j < size; j++) {\n      const value = typedArray[sourceIndex++];\n      scratchArray[targetIndex + j] = value;\n      scratchArray[targetIndex + j + size] = fp64LowPart(value);\n    }\n    targetIndex += size * 2;\n  }\n  return scratchArray.subarray(0, count * size * 2);\n}\nexport function mergeBounds(boundsList) {\n  let mergedBounds = null;\n  let isMerged = false;\n  for (const bounds of boundsList) {\n    /* eslint-disable-next-line no-continue */\n    if (!bounds) continue;\n    if (!mergedBounds) {\n      mergedBounds = bounds;\n    } else {\n      if (!isMerged) {\n        // Copy to avoid mutating input bounds\n        mergedBounds = [[mergedBounds[0][0], mergedBounds[0][1]], [mergedBounds[1][0], mergedBounds[1][1]]];\n        isMerged = true;\n      }\n      mergedBounds[0][0] = Math.min(mergedBounds[0][0], bounds[0][0]);\n      mergedBounds[0][1] = Math.min(mergedBounds[0][1], bounds[0][1]);\n      mergedBounds[1][0] = Math.max(mergedBounds[1][0], bounds[1][0]);\n      mergedBounds[1][1] = Math.max(mergedBounds[1][1], bounds[1][1]);\n    }\n  }\n  return mergedBounds;\n}","map":{"version":3,"names":["typedArrayManager","Vector3","createMat4","mod","value","divisor","modulus","getCameraPosition","viewMatrixInverse","getFrustumPlanes","viewProjectionMatrix","left","getFrustumPlane","right","bottom","top","near","far","scratchVector","a","b","c","d","set","L","len","distance","normal","fp64LowPart","x","Math","fround","scratchArray","toDoublePrecisionArray","typedArray","options","size","startIndex","endIndex","undefined","length","count","allocate","type","Float32Array","sourceIndex","targetIndex","j","subarray","mergeBounds","boundsList","mergedBounds","isMerged","bounds","min","max"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\utils\\math-utils.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// Extensions to math.gl library. Intended to be folded back.\nimport typedArrayManager from './typed-array-manager';\nimport {Vector3, NumericArray} from '@math.gl/core';\n\nimport type {Matrix4} from '@math.gl/core';\n\n// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()\nexport function createMat4(): number[] {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n\nexport function mod(value: number, divisor: number): number {\n  const modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\n\n// Extract camera vectors (move to math library?)\nexport function getCameraPosition(\n  viewMatrixInverse: Matrix4 | NumericArray\n): [number, number, number] {\n  // Read the translation from the inverse view matrix\n  return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];\n}\n\nexport type FrustumPlane = {\n  distance: number;\n  normal: Vector3;\n};\n\n// https://www.gamedevs.org/uploads/fast-extraction-viewing-frustum-planes-from-world-view-projection-matrix.pdf\nexport function getFrustumPlanes(viewProjectionMatrix: Matrix4 | NumericArray): {\n  left: FrustumPlane;\n  right: FrustumPlane;\n  top: FrustumPlane;\n  bottom: FrustumPlane;\n  near: FrustumPlane;\n  far: FrustumPlane;\n} {\n  return {\n    left: getFrustumPlane(\n      viewProjectionMatrix[3] + viewProjectionMatrix[0],\n      viewProjectionMatrix[7] + viewProjectionMatrix[4],\n      viewProjectionMatrix[11] + viewProjectionMatrix[8],\n      viewProjectionMatrix[15] + viewProjectionMatrix[12]\n    ),\n    right: getFrustumPlane(\n      viewProjectionMatrix[3] - viewProjectionMatrix[0],\n      viewProjectionMatrix[7] - viewProjectionMatrix[4],\n      viewProjectionMatrix[11] - viewProjectionMatrix[8],\n      viewProjectionMatrix[15] - viewProjectionMatrix[12]\n    ),\n    bottom: getFrustumPlane(\n      viewProjectionMatrix[3] + viewProjectionMatrix[1],\n      viewProjectionMatrix[7] + viewProjectionMatrix[5],\n      viewProjectionMatrix[11] + viewProjectionMatrix[9],\n      viewProjectionMatrix[15] + viewProjectionMatrix[13]\n    ),\n    top: getFrustumPlane(\n      viewProjectionMatrix[3] - viewProjectionMatrix[1],\n      viewProjectionMatrix[7] - viewProjectionMatrix[5],\n      viewProjectionMatrix[11] - viewProjectionMatrix[9],\n      viewProjectionMatrix[15] - viewProjectionMatrix[13]\n    ),\n    near: getFrustumPlane(\n      viewProjectionMatrix[3] + viewProjectionMatrix[2],\n      viewProjectionMatrix[7] + viewProjectionMatrix[6],\n      viewProjectionMatrix[11] + viewProjectionMatrix[10],\n      viewProjectionMatrix[15] + viewProjectionMatrix[14]\n    ),\n    far: getFrustumPlane(\n      viewProjectionMatrix[3] - viewProjectionMatrix[2],\n      viewProjectionMatrix[7] - viewProjectionMatrix[6],\n      viewProjectionMatrix[11] - viewProjectionMatrix[10],\n      viewProjectionMatrix[15] - viewProjectionMatrix[14]\n    )\n  };\n}\n\nconst scratchVector = new Vector3();\n\nfunction getFrustumPlane(a: number, b: number, c: number, d: number): FrustumPlane {\n  scratchVector.set(a, b, c);\n  const L = scratchVector.len();\n  return {distance: d / L, normal: new Vector3(-a / L, -b / L, -c / L)};\n}\n\n/**\n * Calculate the low part of a WebGL 64 bit float\n * @param x {number} - the input float number\n * @returns {number} - the lower 32 bit of the number\n */\nexport function fp64LowPart(x: number): number {\n  return x - Math.fround(x);\n}\n\nlet scratchArray;\n\n/**\n * Split a Float64Array into a double-length Float32Array\n * @param typedArray\n * @param options\n * @param options.size  - per attribute size\n * @param options.startIndex - start index in the source array\n * @param options.endIndex  - end index in the source array\n * @returns {} - high part, low part for each attribute:\n    [1xHi, 1yHi, 1zHi, 1xLow, 1yLow, 1zLow, 2xHi, ...]\n */\nexport function toDoublePrecisionArray(\n  typedArray: Float64Array,\n  options: {size?: number; startIndex?: number; endIndex?: number}\n): Float32Array {\n  const {size = 1, startIndex = 0} = options;\n\n  const endIndex = options.endIndex !== undefined ? options.endIndex : typedArray.length;\n\n  const count = (endIndex - startIndex) / size;\n  scratchArray = typedArrayManager.allocate(scratchArray, count, {\n    type: Float32Array,\n    size: size * 2\n  });\n\n  let sourceIndex = startIndex;\n  let targetIndex = 0;\n  while (sourceIndex < endIndex) {\n    for (let j = 0; j < size; j++) {\n      const value = typedArray[sourceIndex++];\n      scratchArray[targetIndex + j] = value;\n      scratchArray[targetIndex + j + size] = fp64LowPart(value);\n    }\n    targetIndex += size * 2;\n  }\n\n  return scratchArray.subarray(0, count * size * 2);\n}\n\ntype LayerBounds = [number[], number[]];\nexport function mergeBounds(boundsList: (LayerBounds | null)[]): LayerBounds | null {\n  let mergedBounds: LayerBounds | null = null;\n  let isMerged = false;\n\n  for (const bounds of boundsList) {\n    /* eslint-disable-next-line no-continue */\n    if (!bounds) continue;\n    if (!mergedBounds) {\n      mergedBounds = bounds;\n    } else {\n      if (!isMerged) {\n        // Copy to avoid mutating input bounds\n        mergedBounds = [\n          [mergedBounds[0][0], mergedBounds[0][1]],\n          [mergedBounds[1][0], mergedBounds[1][1]]\n        ];\n        isMerged = true;\n      }\n\n      mergedBounds[0][0] = Math.min(mergedBounds[0][0], bounds[0][0]);\n      mergedBounds[0][1] = Math.min(mergedBounds[0][1], bounds[0][1]);\n      mergedBounds[1][0] = Math.max(mergedBounds[1][0], bounds[1][0]);\n      mergedBounds[1][1] = Math.max(mergedBounds[1][1], bounds[1][1]);\n    }\n  }\n\n  return mergedBounds;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}