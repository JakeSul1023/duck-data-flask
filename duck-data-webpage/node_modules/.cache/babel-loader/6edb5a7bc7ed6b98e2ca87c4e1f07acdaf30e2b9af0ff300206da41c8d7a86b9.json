{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Buffer } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\n/** WebGL Buffer interface */\nexport class WEBGLBuffer extends Buffer {\n  device;\n  gl;\n  handle;\n  /** Target in OpenGL defines the type of buffer */\n  glTarget;\n  /** Usage is a hint on how frequently the buffer will be updates */\n  glUsage;\n  /** Index type is needed when issuing draw calls, so we pre-compute it */\n  glIndexType = 5123;\n  /** Number of bytes allocated on the GPU for this buffer */\n  byteLength;\n  /** Number of bytes used */\n  bytesUsed;\n  constructor(device) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(device, props);\n    this.device = device;\n    this.gl = this.device.gl;\n    const handle = typeof props === 'object' ? props.handle : undefined;\n    this.handle = handle || this.gl.createBuffer();\n    device.setSpectorMetadata(this.handle, {\n      ...this.props,\n      data: typeof this.props.data\n    });\n    // - In WebGL1, need to make sure we use GL.ELEMENT_ARRAY_BUFFER when initializing element buffers\n    //   otherwise buffer type will lock to generic (non-element) buffer\n    // - In WebGL2, we can use GL.COPY_READ_BUFFER which avoids locking the type here\n    this.glTarget = getWebGLTarget(this.props.usage);\n    this.glUsage = getWebGLUsage(this.props.usage);\n    this.glIndexType = this.props.indexType === 'uint32' ? 5125 : 5123;\n    // Set data: (re)initializes the buffer\n    if (props.data) {\n      this._initWithData(props.data, props.byteOffset, props.byteLength);\n    } else {\n      this._initWithByteLength(props.byteLength || 0);\n    }\n  }\n  // PRIVATE METHODS\n  /** Allocate a new buffer and initialize to contents of typed array */\n  _initWithData(data) {\n    let byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let byteLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : data.byteLength + byteOffset;\n    // const glTarget = this.device.isWebGL2 ? GL.COPY_WRITE_BUFFER : this.glTarget;\n    const glTarget = this.glTarget;\n    this.gl.bindBuffer(glTarget, this.handle);\n    this.gl.bufferData(glTarget, byteLength, this.glUsage);\n    this.gl.bufferSubData(glTarget, byteOffset, data);\n    this.gl.bindBuffer(glTarget, null);\n    this.bytesUsed = byteLength;\n    this.byteLength = byteLength;\n    this._setDebugData(data, byteOffset, byteLength);\n    this.trackAllocatedMemory(byteLength);\n  }\n  // Allocate a GPU buffer of specified size.\n  _initWithByteLength(byteLength) {\n    // assert(byteLength >= 0);\n    // Workaround needed for Safari (#291):\n    // gl.bufferData with size equal to 0 crashes. Instead create zero sized array.\n    let data = byteLength;\n    if (byteLength === 0) {\n      // @ts-expect-error\n      data = new Float32Array(0);\n    }\n    // const glTarget = this.device.isWebGL2 ? GL.COPY_WRITE_BUFFER : this.glTarget;\n    const glTarget = this.glTarget;\n    this.gl.bindBuffer(glTarget, this.handle);\n    this.gl.bufferData(glTarget, data, this.glUsage);\n    this.gl.bindBuffer(glTarget, null);\n    this.bytesUsed = byteLength;\n    this.byteLength = byteLength;\n    this._setDebugData(null, 0, byteLength);\n    this.trackAllocatedMemory(byteLength);\n    return this;\n  }\n  destroy() {\n    if (!this.destroyed && this.handle) {\n      this.removeStats();\n      this.trackDeallocatedMemory();\n      this.gl.deleteBuffer(this.handle);\n      this.destroyed = true;\n      // @ts-expect-error\n      this.handle = null;\n    }\n  }\n  write(data) {\n    let byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const srcOffset = 0;\n    const byteLength = undefined; // data.byteLength;\n    // Create the buffer - binding it here for the first time locks the type\n    // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type\n    const glTarget = 36663;\n    this.gl.bindBuffer(glTarget, this.handle);\n    // WebGL2: subData supports additional srcOffset and length parameters\n    if (srcOffset !== 0 || byteLength !== undefined) {\n      this.gl.bufferSubData(glTarget, byteOffset, data, srcOffset, byteLength);\n    } else {\n      this.gl.bufferSubData(glTarget, byteOffset, data);\n    }\n    this.gl.bindBuffer(glTarget, null);\n    this._setDebugData(data, byteOffset, data.byteLength);\n  }\n  /** Asynchronously read data from the buffer */\n  async readAsync() {\n    let byteOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let byteLength = arguments.length > 1 ? arguments[1] : undefined;\n    return this.readSyncWebGL(byteOffset, byteLength);\n  }\n  /** Synchronously read data from the buffer. WebGL only. */\n  readSyncWebGL() {\n    let byteOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let byteLength = arguments.length > 1 ? arguments[1] : undefined;\n    byteLength = byteLength ?? this.byteLength - byteOffset;\n    const data = new Uint8Array(byteLength);\n    const dstOffset = 0;\n    // Use GL.COPY_READ_BUFFER to avoid disturbing other targets and locking type\n    this.gl.bindBuffer(36662, this.handle);\n    this.gl.getBufferSubData(36662, byteOffset, data, dstOffset, byteLength);\n    this.gl.bindBuffer(36662, null);\n    // Update local `data` if offsets are 0\n    this._setDebugData(data, byteOffset, byteLength);\n    return data;\n  }\n}\n/**\n * Returns a WebGL buffer target\n *\n * @param usage\n * static MAP_READ = 0x01;\n * static MAP_WRITE = 0x02;\n * static COPY_SRC = 0x0004;\n * static COPY_DST = 0x0008;\n * static INDEX = 0x0010;\n * static VERTEX = 0x0020;\n * static UNIFORM = 0x0040;\n * static STORAGE = 0x0080;\n * static INDIRECT = 0x0100;\n * static QUERY_RESOLVE = 0x0200;\n *\n * @returns WebGL buffer targe\n *\n * Buffer bind points in WebGL2\n * gl.COPY_READ_BUFFER: Buffer for copying from one buffer object to another.\n * gl.COPY_WRITE_BUFFER: Buffer for copying from one buffer object to another.\n * gl.TRANSFORM_FEEDBACK_BUFFER: Buffer for transform feedback operations.\n * gl.PIXEL_PACK_BUFFER: Buffer used for pixel transfer operations.\n * gl.PIXEL_UNPACK_BUFFER: Buffer used for pixel transfer operations.\n */\nfunction getWebGLTarget(usage) {\n  if (usage & Buffer.INDEX) {\n    return 34963;\n  }\n  if (usage & Buffer.VERTEX) {\n    return 34962;\n  }\n  if (usage & Buffer.UNIFORM) {\n    return 35345;\n  }\n  // Binding a buffer for the first time locks the type\n  // In WebGL2, we can use GL.COPY_WRITE_BUFFER to avoid locking the type\n  return 34962;\n}\n/** @todo usage is not passed correctly */\nfunction getWebGLUsage(usage) {\n  if (usage & Buffer.INDEX) {\n    return 35044;\n  }\n  if (usage & Buffer.VERTEX) {\n    return 35044;\n  }\n  if (usage & Buffer.UNIFORM) {\n    return 35048;\n  }\n  return 35044;\n}\n//# sourceMappingURL=webgl-buffer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}