{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { getPolygonSignedArea } from '@math.gl/polygon';\n/**\n *\n * @param ring\n * @returns sum\n */\nexport function signedArea(ring) {\n  let sum = 0;\n  for (let i = 0, j = ring.length - 1, p1, p2; i < ring.length; j = i++) {\n    p1 = ring[i];\n    p2 = ring[j];\n    sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);\n  }\n  return sum;\n}\n/**\n * This function projects local coordinates in a\n * [0 - bufferSize, this.extent + bufferSize] range to a\n * [0 - (bufferSize / this.extent), 1 + (bufferSize / this.extent)] range.\n * The resulting extent would be 1.\n * @param line\n * @param feature\n */\nexport function convertToLocalCoordinates(coordinates, extent) {\n  if (Array.isArray(coordinates[0])) {\n    for (const subcoords of coordinates) {\n      convertToLocalCoordinates(subcoords, extent);\n    }\n    return;\n  }\n  // Just a point\n  const p = coordinates;\n  p[0] /= extent;\n  p[1] /= extent;\n}\n/**\n * For the binary code path, the feature data is just\n * one big flat array, so we just divide each value\n * @param data\n * @param feature\n */\nexport function convertToLocalCoordinatesFlat(data, extent) {\n  for (let i = 0; i < data.length; ++i) {\n    data[i] /= extent;\n  }\n}\n/**\n * Projects local tile coordinates to lngLat in place.\n * @param points\n * @param tileIndex\n */\nexport function projectToLngLat(line, tileIndex, extent) {\n  if (typeof line[0][0] !== 'number') {\n    for (const point of line) {\n      // @ts-expect-error\n      projectToLngLat(point, tileIndex, extent);\n    }\n    return;\n  }\n  const size = extent * Math.pow(2, tileIndex.z);\n  const x0 = extent * tileIndex.x;\n  const y0 = extent * tileIndex.y;\n  for (let j = 0; j < line.length; j++) {\n    const p = line[j];\n    p[0] = (p[0] + x0) * 360 / size - 180;\n    const y2 = 180 - (p[1] + y0) * 360 / size;\n    p[1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n  }\n}\n/**\n * Projects local tile coordinates to lngLat in place.\n * @param points\n * @param tileIndex\nexport function projectTileCoordinatesToLngLat(\n  points: number[][],\n  tileIndex: {x: number; y: number; z: number},\n  extent: number\n): void {\n  const {x, y, z} = tileIndex;\n  const size = extent * Math.pow(2, z);\n  const x0 = extent * x;\n  const y0 = extent * y;\n\n  for (const p of points) {\n    p[0] = ((p[0] + x0) * 360) / size - 180;\n    const y2 = 180 - ((p[1] + y0) * 360) / size;\n    p[1] = (360 / Math.PI) * Math.atan(Math.exp((y2 * Math.PI) / 180)) - 90;\n  }\n}\n */\n/**\n *\n * @param data\n * @param x0\n * @param y0\n * @param size\n */\nexport function projectToLngLatFlat(data, tileIndex, extent) {\n  const {\n    x,\n    y,\n    z\n  } = tileIndex;\n  const size = extent * Math.pow(2, z);\n  const x0 = extent * x;\n  const y0 = extent * y;\n  for (let j = 0, jl = data.length; j < jl; j += 2) {\n    data[j] = (data[j] + x0) * 360 / size - 180;\n    const y2 = 180 - (data[j + 1] + y0) * 360 / size;\n    data[j + 1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n  }\n}\n/**\n * Classifies an array of rings into polygons with outer rings and holes\n * @param rings\n * @returns polygons\n */\nexport function classifyRings(rings) {\n  const len = rings.length;\n  if (len <= 1) return [rings];\n  const polygons = [];\n  let polygon;\n  let ccw;\n  for (let i = 0; i < len; i++) {\n    const area = signedArea(rings[i]);\n    if (area === 0) continue; // eslint-disable-line no-continue\n    if (ccw === undefined) ccw = area < 0;\n    if (ccw === area < 0) {\n      if (polygon) polygons.push(polygon);\n      polygon = [rings[i]];\n    } else if (polygon) polygon.push(rings[i]);\n  }\n  if (polygon) polygons.push(polygon);\n  return polygons;\n}\n/**\n * Classifies an array of rings into polygons with outer rings and holes\n * The function also detects holes which have zero area and\n * removes them. In doing so it modifies the input\n * `geom.data` array to remove the unneeded data\n *\n * @param geometry\n * @returns object\n */\n// eslint-disable-next-line max-statements\nexport function classifyRingsFlat(geom) {\n  const len = geom.indices.length;\n  const type = 'Polygon';\n  if (len <= 1) {\n    return {\n      type,\n      data: geom.data,\n      areas: [[getPolygonSignedArea(geom.data)]],\n      indices: [geom.indices]\n    };\n  }\n  const areas = [];\n  const polygons = [];\n  let ringAreas = [];\n  let polygon = [];\n  let ccw;\n  let offset = 0;\n  for (let endIndex, i = 0, startIndex; i < len; i++) {\n    startIndex = geom.indices[i] - offset;\n    endIndex = geom.indices[i + 1] - offset || geom.data.length;\n    const shape = geom.data.slice(startIndex, endIndex);\n    const area = getPolygonSignedArea(shape);\n    if (area === 0) {\n      // This polygon has no area, so remove it from the shape\n      // Remove the section from the data array\n      const before = geom.data.slice(0, startIndex);\n      const after = geom.data.slice(endIndex);\n      geom.data = before.concat(after);\n      // Need to offset any remaining indices as we have\n      // modified the data buffer\n      offset += endIndex - startIndex;\n      // Do not add this index to the output and process next shape\n      continue; // eslint-disable-line no-continue\n    }\n    if (ccw === undefined) ccw = area < 0;\n    if (ccw === area < 0) {\n      if (polygon.length) {\n        areas.push(ringAreas);\n        polygons.push(polygon);\n      }\n      polygon = [startIndex];\n      ringAreas = [area];\n    } else {\n      ringAreas.push(area);\n      polygon.push(startIndex);\n    }\n  }\n  if (ringAreas) areas.push(ringAreas);\n  if (polygon.length) polygons.push(polygon);\n  return {\n    type,\n    areas,\n    indices: polygons,\n    data: geom.data\n  };\n}","map":{"version":3,"names":["getPolygonSignedArea","signedArea","ring","sum","i","j","length","p1","p2","convertToLocalCoordinates","coordinates","extent","Array","isArray","subcoords","p","convertToLocalCoordinatesFlat","data","projectToLngLat","line","tileIndex","point","size","Math","pow","z","x0","x","y0","y","y2","PI","atan","exp","projectToLngLatFlat","jl","classifyRings","rings","len","polygons","polygon","ccw","area","undefined","push","classifyRingsFlat","geom","indices","type","areas","ringAreas","offset","endIndex","startIndex","shape","slice","before","after","concat"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/mvt/dist/lib/utils/geometry-utils.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { getPolygonSignedArea } from '@math.gl/polygon';\n/**\n *\n * @param ring\n * @returns sum\n */\nexport function signedArea(ring) {\n    let sum = 0;\n    for (let i = 0, j = ring.length - 1, p1, p2; i < ring.length; j = i++) {\n        p1 = ring[i];\n        p2 = ring[j];\n        sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);\n    }\n    return sum;\n}\n/**\n * This function projects local coordinates in a\n * [0 - bufferSize, this.extent + bufferSize] range to a\n * [0 - (bufferSize / this.extent), 1 + (bufferSize / this.extent)] range.\n * The resulting extent would be 1.\n * @param line\n * @param feature\n */\nexport function convertToLocalCoordinates(coordinates, extent) {\n    if (Array.isArray(coordinates[0])) {\n        for (const subcoords of coordinates) {\n            convertToLocalCoordinates(subcoords, extent);\n        }\n        return;\n    }\n    // Just a point\n    const p = coordinates;\n    p[0] /= extent;\n    p[1] /= extent;\n}\n/**\n * For the binary code path, the feature data is just\n * one big flat array, so we just divide each value\n * @param data\n * @param feature\n */\nexport function convertToLocalCoordinatesFlat(data, extent) {\n    for (let i = 0; i < data.length; ++i) {\n        data[i] /= extent;\n    }\n}\n/**\n * Projects local tile coordinates to lngLat in place.\n * @param points\n * @param tileIndex\n */\nexport function projectToLngLat(line, tileIndex, extent) {\n    if (typeof line[0][0] !== 'number') {\n        for (const point of line) {\n            // @ts-expect-error\n            projectToLngLat(point, tileIndex, extent);\n        }\n        return;\n    }\n    const size = extent * Math.pow(2, tileIndex.z);\n    const x0 = extent * tileIndex.x;\n    const y0 = extent * tileIndex.y;\n    for (let j = 0; j < line.length; j++) {\n        const p = line[j];\n        p[0] = ((p[0] + x0) * 360) / size - 180;\n        const y2 = 180 - ((p[1] + y0) * 360) / size;\n        p[1] = (360 / Math.PI) * Math.atan(Math.exp((y2 * Math.PI) / 180)) - 90;\n    }\n}\n/**\n * Projects local tile coordinates to lngLat in place.\n * @param points\n * @param tileIndex\nexport function projectTileCoordinatesToLngLat(\n  points: number[][],\n  tileIndex: {x: number; y: number; z: number},\n  extent: number\n): void {\n  const {x, y, z} = tileIndex;\n  const size = extent * Math.pow(2, z);\n  const x0 = extent * x;\n  const y0 = extent * y;\n\n  for (const p of points) {\n    p[0] = ((p[0] + x0) * 360) / size - 180;\n    const y2 = 180 - ((p[1] + y0) * 360) / size;\n    p[1] = (360 / Math.PI) * Math.atan(Math.exp((y2 * Math.PI) / 180)) - 90;\n  }\n}\n */\n/**\n *\n * @param data\n * @param x0\n * @param y0\n * @param size\n */\nexport function projectToLngLatFlat(data, tileIndex, extent) {\n    const { x, y, z } = tileIndex;\n    const size = extent * Math.pow(2, z);\n    const x0 = extent * x;\n    const y0 = extent * y;\n    for (let j = 0, jl = data.length; j < jl; j += 2) {\n        data[j] = ((data[j] + x0) * 360) / size - 180;\n        const y2 = 180 - ((data[j + 1] + y0) * 360) / size;\n        data[j + 1] = (360 / Math.PI) * Math.atan(Math.exp((y2 * Math.PI) / 180)) - 90;\n    }\n}\n/**\n * Classifies an array of rings into polygons with outer rings and holes\n * @param rings\n * @returns polygons\n */\nexport function classifyRings(rings) {\n    const len = rings.length;\n    if (len <= 1)\n        return [rings];\n    const polygons = [];\n    let polygon;\n    let ccw;\n    for (let i = 0; i < len; i++) {\n        const area = signedArea(rings[i]);\n        if (area === 0)\n            continue; // eslint-disable-line no-continue\n        if (ccw === undefined)\n            ccw = area < 0;\n        if (ccw === area < 0) {\n            if (polygon)\n                polygons.push(polygon);\n            polygon = [rings[i]];\n        }\n        else if (polygon)\n            polygon.push(rings[i]);\n    }\n    if (polygon)\n        polygons.push(polygon);\n    return polygons;\n}\n/**\n * Classifies an array of rings into polygons with outer rings and holes\n * The function also detects holes which have zero area and\n * removes them. In doing so it modifies the input\n * `geom.data` array to remove the unneeded data\n *\n * @param geometry\n * @returns object\n */\n// eslint-disable-next-line max-statements\nexport function classifyRingsFlat(geom) {\n    const len = geom.indices.length;\n    const type = 'Polygon';\n    if (len <= 1) {\n        return {\n            type,\n            data: geom.data,\n            areas: [[getPolygonSignedArea(geom.data)]],\n            indices: [geom.indices]\n        };\n    }\n    const areas = [];\n    const polygons = [];\n    let ringAreas = [];\n    let polygon = [];\n    let ccw;\n    let offset = 0;\n    for (let endIndex, i = 0, startIndex; i < len; i++) {\n        startIndex = geom.indices[i] - offset;\n        endIndex = geom.indices[i + 1] - offset || geom.data.length;\n        const shape = geom.data.slice(startIndex, endIndex);\n        const area = getPolygonSignedArea(shape);\n        if (area === 0) {\n            // This polygon has no area, so remove it from the shape\n            // Remove the section from the data array\n            const before = geom.data.slice(0, startIndex);\n            const after = geom.data.slice(endIndex);\n            geom.data = before.concat(after);\n            // Need to offset any remaining indices as we have\n            // modified the data buffer\n            offset += endIndex - startIndex;\n            // Do not add this index to the output and process next shape\n            continue; // eslint-disable-line no-continue\n        }\n        if (ccw === undefined)\n            ccw = area < 0;\n        if (ccw === area < 0) {\n            if (polygon.length) {\n                areas.push(ringAreas);\n                polygons.push(polygon);\n            }\n            polygon = [startIndex];\n            ringAreas = [area];\n        }\n        else {\n            ringAreas.push(area);\n            polygon.push(startIndex);\n        }\n    }\n    if (ringAreas)\n        areas.push(ringAreas);\n    if (polygon.length)\n        polygons.push(polygon);\n    return { type, areas, indices: polygons, data: geom.data };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}