{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Model } from \"../model/model.js\";\nimport { Geometry } from \"../geometry/geometry.js\";\nimport { uid } from \"../utils/uid.js\";\nconst CLIPSPACE_VERTEX_SHADER_WGSL = /* wgsl */`\\\nstruct VertexInputs {\n  @location(0) clipSpacePosition: vec2<f32>,\n  @location(1) texCoord: vec2<f32>,\n  @location(2) coordinate: vec2<f32>  \n}\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) position : vec2<f32>,\n  @location(1) coordinate : vec2<f32>,\n  @location(2) uv : vec2<f32>\n};\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs: FragmentInputs;\n  outputs.Position = vec4(inputs.clipSpacePosition, 0., 1.);\n  outputs.position = inputs.clipSpacePosition;\n  outputs.coordinate = inputs.coordinate;\n  outputs.uv = inputs.texCoord;\n  return outputs;\n}\n`;\nconst CLIPSPACE_VERTEX_SHADER = /* glsl */`\\\n#version 300 es\nin vec2 clipSpacePositions;\nin vec2 texCoords;\nin vec2 coordinates;\n\nout vec2 position;\nout vec2 coordinate;\nout vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(clipSpacePositions, 0., 1.);\n  position = clipSpacePositions;\n  coordinate = coordinates;\n  uv = texCoords;\n}\n`;\n/* eslint-disable indent, no-multi-spaces */\nconst POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];\n/**\n * A flat geometry that covers the \"visible area\" that the GPU renders.\n */\nexport class ClipSpace extends Model {\n  constructor(device, props) {\n    const TEX_COORDS = POSITIONS.map(coord => coord === -1 ? 0 : coord);\n    // For WGSL we need to append the supplied fragment shader to the default vertex shader source\n    if (props.source) {\n      props = {\n        ...props,\n        source: `${CLIPSPACE_VERTEX_SHADER_WGSL}\\n${props.source}`\n      };\n    }\n    super(device, {\n      id: props.id || uid('clip-space'),\n      ...props,\n      vs: CLIPSPACE_VERTEX_SHADER,\n      vertexCount: 4,\n      geometry: new Geometry({\n        topology: 'triangle-strip',\n        vertexCount: 4,\n        attributes: {\n          clipSpacePositions: {\n            size: 2,\n            value: new Float32Array(POSITIONS)\n          },\n          texCoords: {\n            size: 2,\n            value: new Float32Array(TEX_COORDS)\n          },\n          coordinates: {\n            size: 2,\n            value: new Float32Array(TEX_COORDS)\n          }\n        }\n      })\n    });\n  }\n}","map":{"version":3,"names":["Model","Geometry","uid","CLIPSPACE_VERTEX_SHADER_WGSL","CLIPSPACE_VERTEX_SHADER","POSITIONS","ClipSpace","constructor","device","props","TEX_COORDS","map","coord","source","id","vs","vertexCount","geometry","topology","attributes","clipSpacePositions","size","value","Float32Array","texCoords","coordinates"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\engine\\src\\models\\clip-space.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// ClipSpace\nimport {Device} from '@luma.gl/core';\nimport {Model, ModelProps} from '../model/model';\nimport {Geometry} from '../geometry/geometry';\nimport {uid} from '../utils/uid';\n\nconst CLIPSPACE_VERTEX_SHADER_WGSL = /* wgsl */ `\\\nstruct VertexInputs {\n  @location(0) clipSpacePosition: vec2<f32>,\n  @location(1) texCoord: vec2<f32>,\n  @location(2) coordinate: vec2<f32>  \n}\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) position : vec2<f32>,\n  @location(1) coordinate : vec2<f32>,\n  @location(2) uv : vec2<f32>\n};\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs: FragmentInputs;\n  outputs.Position = vec4(inputs.clipSpacePosition, 0., 1.);\n  outputs.position = inputs.clipSpacePosition;\n  outputs.coordinate = inputs.coordinate;\n  outputs.uv = inputs.texCoord;\n  return outputs;\n}\n`;\n\nconst CLIPSPACE_VERTEX_SHADER = /* glsl */ `\\\n#version 300 es\nin vec2 clipSpacePositions;\nin vec2 texCoords;\nin vec2 coordinates;\n\nout vec2 position;\nout vec2 coordinate;\nout vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(clipSpacePositions, 0., 1.);\n  position = clipSpacePositions;\n  coordinate = coordinates;\n  uv = texCoords;\n}\n`;\n\n/* eslint-disable indent, no-multi-spaces */\nconst POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];\n\n/** Props for ClipSpace */\nexport type ClipSpaceProps = Omit<ModelProps, 'vs' | 'vertexCount' | 'geometry'>;\n\n/**\n * A flat geometry that covers the \"visible area\" that the GPU renders.\n */\nexport class ClipSpace extends Model {\n  constructor(device: Device, props: ClipSpaceProps) {\n    const TEX_COORDS = POSITIONS.map(coord => (coord === -1 ? 0 : coord));\n\n    // For WGSL we need to append the supplied fragment shader to the default vertex shader source\n    if (props.source) {\n      props = {...props, source: `${CLIPSPACE_VERTEX_SHADER_WGSL}\\n${props.source}`};\n    }\n\n    super(device, {\n      id: props.id || uid('clip-space'),\n      ...props,\n      vs: CLIPSPACE_VERTEX_SHADER,\n      vertexCount: 4,\n      geometry: new Geometry({\n        topology: 'triangle-strip',\n        vertexCount: 4,\n        attributes: {\n          clipSpacePositions: {size: 2, value: new Float32Array(POSITIONS)},\n          texCoords: {size: 2, value: new Float32Array(TEX_COORDS)},\n          coordinates: {size: 2, value: new Float32Array(TEX_COORDS)}\n        }\n      })\n    });\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAIA,SAAQA,KAAK,QAAa;AAC1B,SAAQC,QAAQ,QAAC;AACjB,SAAQC,GAAG,QAAC;AAEZ,MAAMC,4BAA4B,GAAG,UAAW;;;;;;;;;;;;;;;;;;;;;;;CAuB/C;AAED,MAAMC,uBAAuB,GAAG,UAAW;;;;;;;;;;;;;;;;CAgB1C;AAED;AACA,MAAMC,SAAS,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AAK9C;;;AAGA,OAAM,MAAOC,SAAU,SAAQN,KAAK;EAClCO,YAAYC,MAAc,EAAEC,KAAqB;IAC/C,MAAMC,UAAU,GAAGL,SAAS,CAACM,GAAG,CAACC,KAAK,IAAKA,KAAK,KAAK,CAAC,CAAC,GAAG,CAAC,GAAGA,KAAM,CAAC;IAErE;IACA,IAAIH,KAAK,CAACI,MAAM,EAAE;MAChBJ,KAAK,GAAG;QAAC,GAAGA,KAAK;QAAEI,MAAM,EAAE,GAAGV,4BAA4B,KAAKM,KAAK,CAACI,MAAM;MAAE,CAAC;IAChF;IAEA,KAAK,CAACL,MAAM,EAAE;MACZM,EAAE,EAAEL,KAAK,CAACK,EAAE,IAAIZ,GAAG,CAAC,YAAY,CAAC;MACjC,GAAGO,KAAK;MACRM,EAAE,EAAEX,uBAAuB;MAC3BY,WAAW,EAAE,CAAC;MACdC,QAAQ,EAAE,IAAIhB,QAAQ,CAAC;QACrBiB,QAAQ,EAAE,gBAAgB;QAC1BF,WAAW,EAAE,CAAC;QACdG,UAAU,EAAE;UACVC,kBAAkB,EAAE;YAACC,IAAI,EAAE,CAAC;YAAEC,KAAK,EAAE,IAAIC,YAAY,CAAClB,SAAS;UAAC,CAAC;UACjEmB,SAAS,EAAE;YAACH,IAAI,EAAE,CAAC;YAAEC,KAAK,EAAE,IAAIC,YAAY,CAACb,UAAU;UAAC,CAAC;UACzDe,WAAW,EAAE;YAACJ,IAAI,EAAE,CAAC;YAAEC,KAAK,EAAE,IAAIC,YAAY,CAACb,UAAU;UAAC;;OAE7D;KACF,CAAC;EACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}