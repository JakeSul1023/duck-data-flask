{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { GL } from '@luma.gl/constants';\nimport { convertCompareFunction } from \"./device-parameters.js\";\n/**\n * Convert WebGPU-style sampler props to WebGL\n * @param props\n * @returns\n */\nexport function convertSamplerParametersToWebGL(props) {\n  const params = {};\n  if (props.addressModeU) {\n    params[10242] = convertAddressMode(props.addressModeU);\n  }\n  if (props.addressModeV) {\n    params[10243] = convertAddressMode(props.addressModeV);\n  }\n  if (props.addressModeW) {\n    params[32882] = convertAddressMode(props.addressModeW);\n  }\n  if (props.magFilter) {\n    params[10240] = convertMaxFilterMode(props.magFilter);\n  }\n  if (props.minFilter || props.mipmapFilter) {\n    // TODO - arbitrary choice of linear?\n    params[10241] = convertMinFilterMode(props.minFilter || 'linear', props.mipmapFilter);\n  }\n  if (props.lodMinClamp !== undefined) {\n    params[33082] = props.lodMinClamp;\n  }\n  if (props.lodMaxClamp !== undefined) {\n    params[33083] = props.lodMaxClamp;\n  }\n  if (props.type === 'comparison-sampler') {\n    // Setting prop.compare turns this into a comparison sampler\n    params[34892] = 34894;\n  }\n  if (props.compare) {\n    params[34893] = convertCompareFunction('compare', props.compare);\n  }\n  // Note depends on WebGL extension\n  if (props.maxAnisotropy) {\n    params[34046] = props.maxAnisotropy;\n  }\n  return params;\n}\n// HELPERS\n/** Convert address more */\nfunction convertAddressMode(addressMode) {\n  switch (addressMode) {\n    case 'clamp-to-edge':\n      return 33071;\n    case 'repeat':\n      return 10497;\n    case 'mirror-repeat':\n      return 33648;\n  }\n}\nfunction convertMaxFilterMode(maxFilter) {\n  switch (maxFilter) {\n    case 'nearest':\n      return 9728;\n    case 'linear':\n      return 9729;\n  }\n}\n/**\n * WebGPU has separate min filter and mipmap filter,\n * WebGL is combined and effectively offers 6 options\n */\nfunction convertMinFilterMode(minFilter, mipmapFilter = 'none') {\n  if (!mipmapFilter) {\n    return convertMaxFilterMode(minFilter);\n  }\n  switch (mipmapFilter) {\n    case 'none':\n      return convertMaxFilterMode(minFilter);\n    case 'nearest':\n      return minFilter === 'nearest' ? 9984 : 9986;\n    case 'linear':\n      return minFilter === 'nearest' ? 9985 : 9987;\n  }\n}","map":{"version":3,"names":["GL","convertCompareFunction","convertSamplerParametersToWebGL","props","params","addressModeU","convertAddressMode","addressModeV","addressModeW","magFilter","convertMaxFilterMode","minFilter","mipmapFilter","convertMinFilterMode","lodMinClamp","undefined","lodMaxClamp","type","compare","maxAnisotropy","addressMode","maxFilter"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\webgl\\src\\adapter\\converters\\sampler-parameters.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// SAMPLER FILTERS\nimport {SamplerProps} from '@luma.gl/core';\nimport {GL, GLSamplerParameters} from '@luma.gl/constants';\nimport {convertCompareFunction} from './device-parameters';\n\n/**\n * Convert WebGPU-style sampler props to WebGL\n * @param props\n * @returns\n */\nexport function convertSamplerParametersToWebGL(props: SamplerProps): GLSamplerParameters {\n  const params: GLSamplerParameters = {};\n  if (props.addressModeU) {\n    params[GL.TEXTURE_WRAP_S] = convertAddressMode(props.addressModeU);\n  }\n  if (props.addressModeV) {\n    params[GL.TEXTURE_WRAP_T] = convertAddressMode(props.addressModeV);\n  }\n  if (props.addressModeW) {\n    params[GL.TEXTURE_WRAP_R] = convertAddressMode(props.addressModeW);\n  }\n  if (props.magFilter) {\n    params[GL.TEXTURE_MAG_FILTER] = convertMaxFilterMode(props.magFilter);\n  }\n  if (props.minFilter || props.mipmapFilter) {\n    // TODO - arbitrary choice of linear?\n    params[GL.TEXTURE_MIN_FILTER] = convertMinFilterMode(\n      props.minFilter || 'linear',\n      props.mipmapFilter\n    );\n  }\n  if (props.lodMinClamp !== undefined) {\n    params[GL.TEXTURE_MIN_LOD] = props.lodMinClamp;\n  }\n  if (props.lodMaxClamp !== undefined) {\n    params[GL.TEXTURE_MAX_LOD] = props.lodMaxClamp;\n  }\n  if (props.type === 'comparison-sampler') {\n    // Setting prop.compare turns this into a comparison sampler\n    params[GL.TEXTURE_COMPARE_MODE] = GL.COMPARE_REF_TO_TEXTURE;\n  }\n  if (props.compare) {\n    params[GL.TEXTURE_COMPARE_FUNC] = convertCompareFunction('compare', props.compare);\n  }\n  // Note depends on WebGL extension\n  if (props.maxAnisotropy) {\n    params[GL.TEXTURE_MAX_ANISOTROPY_EXT] = props.maxAnisotropy;\n  }\n  return params;\n}\n\n// HELPERS\n\n/** Convert address more */\nfunction convertAddressMode(\n  addressMode: 'clamp-to-edge' | 'repeat' | 'mirror-repeat'\n): GL.CLAMP_TO_EDGE | GL.REPEAT | GL.MIRRORED_REPEAT {\n  switch (addressMode) {\n    case 'clamp-to-edge':\n      return GL.CLAMP_TO_EDGE;\n    case 'repeat':\n      return GL.REPEAT;\n    case 'mirror-repeat':\n      return GL.MIRRORED_REPEAT;\n  }\n}\n\nfunction convertMaxFilterMode(maxFilter: 'nearest' | 'linear'): GL.NEAREST | GL.LINEAR {\n  switch (maxFilter) {\n    case 'nearest':\n      return GL.NEAREST;\n    case 'linear':\n      return GL.LINEAR;\n  }\n}\n\n/**\n * WebGPU has separate min filter and mipmap filter,\n * WebGL is combined and effectively offers 6 options\n */\nfunction convertMinFilterMode(\n  minFilter: 'nearest' | 'linear',\n  mipmapFilter: 'none' | 'nearest' | 'linear' = 'none'\n):\n  | GL.NEAREST\n  | GL.LINEAR\n  | GL.NEAREST_MIPMAP_NEAREST\n  | GL.LINEAR_MIPMAP_NEAREST\n  | GL.NEAREST_MIPMAP_LINEAR\n  | GL.LINEAR_MIPMAP_LINEAR {\n  if (!mipmapFilter) {\n    return convertMaxFilterMode(minFilter);\n  }\n  switch (mipmapFilter) {\n    case 'none':\n      return convertMaxFilterMode(minFilter);\n    case 'nearest':\n      return minFilter === 'nearest' ? GL.NEAREST_MIPMAP_NEAREST : GL.NEAREST_MIPMAP_LINEAR;\n    case 'linear':\n      return minFilter === 'nearest' ? GL.LINEAR_MIPMAP_NEAREST : GL.LINEAR_MIPMAP_LINEAR;\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAIA,SAAQA,EAAE,QAA4B,oBAAoB;AAC1D,SAAQC,sBAAsB,QAAC;AAE/B;;;;;AAKA,OAAM,SAAUC,+BAA+BA,CAACC,KAAmB;EACjE,MAAMC,MAAM,GAAwB,EAAE;EACtC,IAAID,KAAK,CAACE,YAAY,EAAE;IACtBD,MAAM,OAAmB,GAAGE,kBAAkB,CAACH,KAAK,CAACE,YAAY,CAAC;EACpE;EACA,IAAIF,KAAK,CAACI,YAAY,EAAE;IACtBH,MAAM,OAAmB,GAAGE,kBAAkB,CAACH,KAAK,CAACI,YAAY,CAAC;EACpE;EACA,IAAIJ,KAAK,CAACK,YAAY,EAAE;IACtBJ,MAAM,OAAmB,GAAGE,kBAAkB,CAACH,KAAK,CAACK,YAAY,CAAC;EACpE;EACA,IAAIL,KAAK,CAACM,SAAS,EAAE;IACnBL,MAAM,OAAuB,GAAGM,oBAAoB,CAACP,KAAK,CAACM,SAAS,CAAC;EACvE;EACA,IAAIN,KAAK,CAACQ,SAAS,IAAIR,KAAK,CAACS,YAAY,EAAE;IACzC;IACAR,MAAM,OAAuB,GAAGS,oBAAoB,CAClDV,KAAK,CAACQ,SAAS,IAAI,QAAQ,EAC3BR,KAAK,CAACS,YAAY,CACnB;EACH;EACA,IAAIT,KAAK,CAACW,WAAW,KAAKC,SAAS,EAAE;IACnCX,MAAM,OAAoB,GAAGD,KAAK,CAACW,WAAW;EAChD;EACA,IAAIX,KAAK,CAACa,WAAW,KAAKD,SAAS,EAAE;IACnCX,MAAM,OAAoB,GAAGD,KAAK,CAACa,WAAW;EAChD;EACA,IAAIb,KAAK,CAACc,IAAI,KAAK,oBAAoB,EAAE;IACvC;IACAb,MAAM,OAAyB,QAA4B;EAC7D;EACA,IAAID,KAAK,CAACe,OAAO,EAAE;IACjBd,MAAM,OAAyB,GAAGH,sBAAsB,CAAC,SAAS,EAAEE,KAAK,CAACe,OAAO,CAAC;EACpF;EACA;EACA,IAAIf,KAAK,CAACgB,aAAa,EAAE;IACvBf,MAAM,OAA+B,GAAGD,KAAK,CAACgB,aAAa;EAC7D;EACA,OAAOf,MAAM;AACf;AAEA;AAEA;AACA,SAASE,kBAAkBA,CACzBc,WAAyD;EAEzD,QAAQA,WAAW;IACjB,KAAK,eAAe;MAClB;IACF,KAAK,QAAQ;MACX;IACF,KAAK,eAAe;MAClB;EACJ;AACF;AAEA,SAASV,oBAAoBA,CAACW,SAA+B;EAC3D,QAAQA,SAAS;IACf,KAAK,SAAS;MACZ;IACF,KAAK,QAAQ;MACX;EACJ;AACF;AAEA;;;;AAIA,SAASR,oBAAoBA,CAC3BF,SAA+B,EAC/BC,YAAA,GAA8C,MAAM;EAQpD,IAAI,CAACA,YAAY,EAAE;IACjB,OAAOF,oBAAoB,CAACC,SAAS,CAAC;EACxC;EACA,QAAQC,YAAY;IAClB,KAAK,MAAM;MACT,OAAOF,oBAAoB,CAACC,SAAS,CAAC;IACxC,KAAK,SAAS;MACZ,OAAOA,SAAS,KAAK,SAAS,GAAE,OAA4B,IAAyB;IACvF,KAAK,QAAQ;MACX,OAAOA,SAAS,KAAK,SAAS,GAAE,OAA2B,IAAwB;EACvF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}