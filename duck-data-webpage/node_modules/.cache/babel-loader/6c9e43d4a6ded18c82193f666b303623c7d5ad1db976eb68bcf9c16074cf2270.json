{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport Layer from \"./layer.js\";\nimport debug from \"../debug/index.js\";\nimport { flatten } from \"../utils/flatten.js\";\nimport { PROP_TYPES_SYMBOL } from \"../lifecycle/constants.js\";\nconst TRACE_RENDER_LAYERS = 'compositeLayer.renderLayers';\nclass CompositeLayer extends Layer {\n  /** `true` if this layer renders other layers */\n  get isComposite() {\n    return true;\n  }\n  /** `true` if the layer renders to screen */\n  get isDrawable() {\n    return false;\n  }\n  /** Returns true if all async resources are loaded */\n  get isLoaded() {\n    return super.isLoaded && this.getSubLayers().every(layer => layer.isLoaded);\n  }\n  /** Return last rendered sub layers */\n  getSubLayers() {\n    return this.internalState && this.internalState.subLayers || [];\n  }\n  // initializeState is usually not needed for composite layers\n  // Provide empty definition to disable check for missing definition\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  initializeState(context) {}\n  /** Updates selected state members and marks the composite layer to need rerender */\n  setState(updateObject) {\n    super.setState(updateObject);\n    // Trigger a layer update\n    // Although conceptually layer.draw and compositeLayer.renderLayers are equivalent,\n    // they are executed during different lifecycles.\n    // draw can be called without calling updateState (e.g. most viewport changes),\n    // while renderLayers can only be called during a recursive layer update.\n    this.setNeedsUpdate();\n  }\n  /** called to augment the info object that is bubbled up from a sublayer\n      override Layer.getPickingInfo() because decoding / setting uniform do\n      not apply to a composite layer. */\n  getPickingInfo({\n    info\n  }) {\n    const {\n      object\n    } = info;\n    const isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;\n    if (!isDataWrapped) {\n      return info;\n    }\n    // override object with picked data\n    info.object = object.__source.object;\n    info.index = object.__source.index;\n    return info;\n  }\n  /**\n   * Filters sub layers at draw time. Return true if the sub layer should be drawn.\n   */\n  filterSubLayer(context) {\n    return true;\n  }\n  /** Returns true if sub layer needs to be rendered */\n  shouldRenderSubLayer(subLayerId, data) {\n    return data && data.length;\n  }\n  /** Returns sub layer class for a specific sublayer */\n  getSubLayerClass(subLayerId, DefaultLayerClass) {\n    const {\n      _subLayerProps: overridingProps\n    } = this.props;\n    return overridingProps && overridingProps[subLayerId] && overridingProps[subLayerId].type || DefaultLayerClass;\n  }\n  /** When casting user data into another format to pass to sublayers,\n      add reference to the original object and object index */\n  getSubLayerRow(row, sourceObject, sourceObjectIndex) {\n    // @ts-ignore (TS2339) adding undefined property\n    row.__source = {\n      parent: this,\n      object: sourceObject,\n      index: sourceObjectIndex\n    };\n    return row;\n  }\n  /** Some composite layers cast user data into another format before passing to sublayers\n    We need to unwrap them before calling the accessor so that they see the original data\n    objects */\n  getSubLayerAccessor(accessor) {\n    if (typeof accessor === 'function') {\n      const objectInfo = {\n        index: -1,\n        // @ts-ignore accessing resolved data\n        data: this.props.data,\n        target: []\n      };\n      return (x, i) => {\n        if (x && x.__source) {\n          objectInfo.index = x.__source.index;\n          // @ts-ignore (TS2349) Out is never a function\n          return accessor(x.__source.object, objectInfo);\n        }\n        // @ts-ignore (TS2349) Out is never a function\n        return accessor(x, i);\n      };\n    }\n    return accessor;\n  }\n  /** Returns sub layer props for a specific sublayer */\n  // eslint-disable-next-line complexity\n  getSubLayerProps(sublayerProps = {}) {\n    const {\n      opacity,\n      pickable,\n      visible,\n      parameters,\n      getPolygonOffset,\n      highlightedObjectIndex,\n      autoHighlight,\n      highlightColor,\n      coordinateSystem,\n      coordinateOrigin,\n      wrapLongitude,\n      positionFormat,\n      modelMatrix,\n      extensions,\n      fetch,\n      operation,\n      _subLayerProps: overridingProps\n    } = this.props;\n    const newProps = {\n      id: '',\n      updateTriggers: {},\n      opacity,\n      pickable,\n      visible,\n      parameters,\n      getPolygonOffset,\n      highlightedObjectIndex,\n      autoHighlight,\n      highlightColor,\n      coordinateSystem,\n      coordinateOrigin,\n      wrapLongitude,\n      positionFormat,\n      modelMatrix,\n      extensions,\n      fetch,\n      operation\n    };\n    const overridingSublayerProps = overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];\n    const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;\n    const sublayerId = sublayerProps.id || 'sublayer';\n    if (overridingSublayerProps) {\n      const propTypes = this.props[PROP_TYPES_SYMBOL];\n      const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};\n      for (const key in overridingSublayerProps) {\n        const propType = subLayerPropTypes[key] || propTypes[key];\n        // eslint-disable-next-line\n        if (propType && propType.type === 'accessor') {\n          overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);\n        }\n      }\n    }\n    Object.assign(newProps, sublayerProps,\n    // experimental feature that allows users to override sublayer props via parent layer prop\n    overridingSublayerProps);\n    newProps.id = `${this.props.id}-${sublayerId}`;\n    newProps.updateTriggers = {\n      all: this.props.updateTriggers?.all,\n      ...sublayerProps.updateTriggers,\n      ...overridingSublayerTriggers\n    };\n    // Pass through extension props\n    // @ts-ignore (TS2532) extensions is always defined after merging with default props\n    for (const extension of extensions) {\n      const passThroughProps = extension.getSubLayerProps.call(this, extension);\n      if (passThroughProps) {\n        Object.assign(newProps, passThroughProps, {\n          updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)\n        });\n      }\n    }\n    return newProps;\n  }\n  /** Update sub layers to highlight the hovered object */\n  _updateAutoHighlight(info) {\n    for (const layer of this.getSubLayers()) {\n      layer.updateAutoHighlight(info);\n    }\n  }\n  /** Override base Layer method */\n  _getAttributeManager() {\n    return null;\n  }\n  /** (Internal) Called after an update to rerender sub layers */\n  _postUpdate(updateParams, forceUpdate) {\n    // @ts-ignore (TS2531) this method is only called internally when internalState is defined\n    let subLayers = this.internalState.subLayers;\n    const shouldUpdate = !subLayers || this.needsUpdate();\n    if (shouldUpdate) {\n      const subLayersList = this.renderLayers();\n      // Flatten the returned array, removing any null, undefined or false\n      // this allows layers to render sublayers conditionally\n      // (see CompositeLayer.renderLayers docs)\n      subLayers = flatten(subLayersList, Boolean);\n      // @ts-ignore (TS2531) this method is only called internally when internalState is defined\n      this.internalState.subLayers = subLayers;\n    }\n    debug(TRACE_RENDER_LAYERS, this, shouldUpdate, subLayers);\n    // populate reference to parent layer (this layer)\n    // NOTE: needs to be done even when reusing layers as the parent may have changed\n    for (const layer of subLayers) {\n      layer.parent = this;\n    }\n  }\n}\nCompositeLayer.layerName = 'CompositeLayer';\nexport default CompositeLayer;\n//# sourceMappingURL=composite-layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}