{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { cellsToMultiPolygon } from 'h3-js';\nimport { createIterable } from '@deck.gl/core';\nimport { default as H3HexagonLayer } from \"./h3-hexagon-layer.js\";\nimport GeoCellLayer from \"../geo-cell-layer/GeoCellLayer.js\";\nimport { normalizeLongitudes } from \"./h3-utils.js\";\nconst defaultProps = {\n  getHexagons: {\n    type: 'accessor',\n    value: d => d.hexagons\n  }\n};\nclass H3ClusterLayer extends GeoCellLayer {\n  initializeState() {\n    H3HexagonLayer._checkH3Lib();\n  }\n  updateState({\n    props,\n    changeFlags\n  }) {\n    if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagons) {\n      const {\n        data,\n        getHexagons\n      } = props;\n      const polygons = [];\n      const {\n        iterable,\n        objectInfo\n      } = createIterable(data);\n      for (const object of iterable) {\n        objectInfo.index++;\n        const hexagons = getHexagons(object, objectInfo);\n        const multiPolygon = cellsToMultiPolygon(hexagons, true);\n        for (const polygon of multiPolygon) {\n          // Normalize polygons to prevent wrapping over the anti-meridian\n          for (const ring of polygon) {\n            normalizeLongitudes(ring);\n          }\n          polygons.push(this.getSubLayerRow({\n            polygon\n          }, object, objectInfo.index));\n        }\n      }\n      this.setState({\n        polygons\n      });\n    }\n  }\n  indexToBounds() {\n    const {\n      getElevation,\n      getFillColor,\n      getLineColor,\n      getLineWidth\n    } = this.props;\n    return {\n      data: this.state.polygons,\n      getPolygon: d => d.polygon,\n      getElevation: this.getSubLayerAccessor(getElevation),\n      getFillColor: this.getSubLayerAccessor(getFillColor),\n      getLineColor: this.getSubLayerAccessor(getLineColor),\n      getLineWidth: this.getSubLayerAccessor(getLineWidth)\n    };\n  }\n}\nH3ClusterLayer.layerName = 'H3ClusterLayer';\nH3ClusterLayer.defaultProps = defaultProps;\nexport default H3ClusterLayer;","map":{"version":3,"names":["cellsToMultiPolygon","createIterable","default","H3HexagonLayer","GeoCellLayer","normalizeLongitudes","defaultProps","getHexagons","type","value","d","hexagons","H3ClusterLayer","initializeState","_checkH3Lib","updateState","props","changeFlags","dataChanged","updateTriggersChanged","data","polygons","iterable","objectInfo","object","index","multiPolygon","polygon","ring","push","getSubLayerRow","setState","indexToBounds","getElevation","getFillColor","getLineColor","getLineWidth","state","getPolygon","getSubLayerAccessor","layerName"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\geo-layers\\src\\h3-layers\\h3-cluster-layer.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {cellsToMultiPolygon, H3IndexInput} from 'h3-js';\n\nimport {AccessorFunction, createIterable, UpdateParameters, DefaultProps} from '@deck.gl/core';\nimport {default as H3HexagonLayer} from './h3-hexagon-layer';\nimport GeoCellLayer, {GeoCellLayerProps} from '../geo-cell-layer/GeoCellLayer';\nimport {normalizeLongitudes} from './h3-utils';\n\nconst defaultProps: DefaultProps<H3ClusterLayerProps> = {\n  getHexagons: {type: 'accessor', value: (d: any) => d.hexagons}\n};\n\n/** All properties supported by H3ClusterLayer. */\nexport type H3ClusterLayerProps<DataT = unknown> = _H3ClusterLayerProps<DataT> &\n  GeoCellLayerProps<DataT>;\n\n/** Properties added by H3ClusterLayer. */\ntype _H3ClusterLayerProps<DataT> = {\n  /**\n   * Called for each data object to retrieve the hexagon identifiers.\n   *\n   * By default, it reads `hexagons` property of data object.\n   */\n  getHexagons?: AccessorFunction<DataT, H3IndexInput[]>;\n};\n\nexport default class H3ClusterLayer<DataT = any, ExtraProps extends {} = {}> extends GeoCellLayer<\n  DataT,\n  Required<_H3ClusterLayerProps<DataT>> & ExtraProps\n> {\n  static layerName = 'H3ClusterLayer';\n  static defaultProps = defaultProps;\n\n  state!: {\n    polygons: {polygon: number[][][]}[];\n  };\n\n  initializeState(): void {\n    H3HexagonLayer._checkH3Lib();\n  }\n\n  updateState({props, changeFlags}: UpdateParameters<this>): void {\n    if (\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagons)\n    ) {\n      const {data, getHexagons} = props;\n      const polygons: {polygon: number[][][]}[] = [];\n\n      const {iterable, objectInfo} = createIterable(data);\n      for (const object of iterable) {\n        objectInfo.index++;\n        const hexagons = getHexagons(object, objectInfo);\n        const multiPolygon = cellsToMultiPolygon(hexagons, true);\n\n        for (const polygon of multiPolygon) {\n          // Normalize polygons to prevent wrapping over the anti-meridian\n          for (const ring of polygon) {\n            normalizeLongitudes(ring);\n          }\n          polygons.push(this.getSubLayerRow({polygon}, object, objectInfo.index));\n        }\n      }\n\n      this.setState({polygons});\n    }\n  }\n\n  indexToBounds(): Partial<GeoCellLayer['props']> {\n    const {getElevation, getFillColor, getLineColor, getLineWidth} = this.props;\n\n    return {\n      data: this.state.polygons,\n      getPolygon: d => d.polygon,\n\n      getElevation: this.getSubLayerAccessor(getElevation),\n      getFillColor: this.getSubLayerAccessor(getFillColor),\n      getLineColor: this.getSubLayerAccessor(getLineColor),\n      getLineWidth: this.getSubLayerAccessor(getLineWidth)\n    };\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA,SAAQA,mBAAmB,QAAqB,OAAO;AAEvD,SAA0BC,cAAc,QAAuC,eAAe;AAC9F,SAAQC,OAAO,IAAIC,cAAc,QAAC;AAClC,OAAOC,YAAiC;AACxC,SAAQC,mBAAmB,QAAC;AAE5B,MAAMC,YAAY,GAAsC;EACtDC,WAAW,EAAE;IAACC,IAAI,EAAE,UAAU;IAAEC,KAAK,EAAGC,CAAM,IAAKA,CAAC,CAACC;EAAQ;CAC9D;AAgBD,MAAqBC,cAAwD,SAAQR,YAGpF;EAQCS,eAAeA,CAAA;IACbV,cAAc,CAACW,WAAW,EAAE;EAC9B;EAEAC,WAAWA,CAAC;IAACC,KAAK;IAAEC;EAAW,CAAyB;IACtD,IACEA,WAAW,CAACC,WAAW,IACtBD,WAAW,CAACE,qBAAqB,IAAIF,WAAW,CAACE,qBAAqB,CAACZ,WAAY,EACpF;MACA,MAAM;QAACa,IAAI;QAAEb;MAAW,CAAC,GAAGS,KAAK;MACjC,MAAMK,QAAQ,GAA8B,EAAE;MAE9C,MAAM;QAACC,QAAQ;QAAEC;MAAU,CAAC,GAAGtB,cAAc,CAACmB,IAAI,CAAC;MACnD,KAAK,MAAMI,MAAM,IAAIF,QAAQ,EAAE;QAC7BC,UAAU,CAACE,KAAK,EAAE;QAClB,MAAMd,QAAQ,GAAGJ,WAAW,CAACiB,MAAM,EAAED,UAAU,CAAC;QAChD,MAAMG,YAAY,GAAG1B,mBAAmB,CAACW,QAAQ,EAAE,IAAI,CAAC;QAExD,KAAK,MAAMgB,OAAO,IAAID,YAAY,EAAE;UAClC;UACA,KAAK,MAAME,IAAI,IAAID,OAAO,EAAE;YAC1BtB,mBAAmB,CAACuB,IAAI,CAAC;UAC3B;UACAP,QAAQ,CAACQ,IAAI,CAAC,IAAI,CAACC,cAAc,CAAC;YAACH;UAAO,CAAC,EAAEH,MAAM,EAAED,UAAU,CAACE,KAAK,CAAC,CAAC;QACzE;MACF;MAEA,IAAI,CAACM,QAAQ,CAAC;QAACV;MAAQ,CAAC,CAAC;IAC3B;EACF;EAEAW,aAAaA,CAAA;IACX,MAAM;MAACC,YAAY;MAAEC,YAAY;MAAEC,YAAY;MAAEC;IAAY,CAAC,GAAG,IAAI,CAACpB,KAAK;IAE3E,OAAO;MACLI,IAAI,EAAE,IAAI,CAACiB,KAAK,CAAChB,QAAQ;MACzBiB,UAAU,EAAE5B,CAAC,IAAIA,CAAC,CAACiB,OAAO;MAE1BM,YAAY,EAAE,IAAI,CAACM,mBAAmB,CAACN,YAAY,CAAC;MACpDC,YAAY,EAAE,IAAI,CAACK,mBAAmB,CAACL,YAAY,CAAC;MACpDC,YAAY,EAAE,IAAI,CAACI,mBAAmB,CAACJ,YAAY,CAAC;MACpDC,YAAY,EAAE,IAAI,CAACG,mBAAmB,CAACH,YAAY;KACpD;EACH;;AAlDOxB,cAAA,CAAA4B,SAAS,GAAG,gBAAgB;AAC5B5B,cAAA,CAAAN,YAAY,GAAGA,YAAY;eALfM,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}