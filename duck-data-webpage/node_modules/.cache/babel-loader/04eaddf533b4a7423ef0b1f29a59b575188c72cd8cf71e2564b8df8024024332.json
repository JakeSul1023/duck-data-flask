{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* eslint-disable complexity, camelcase */\nimport { mat4, vec4 } from '@math.gl/core';\nimport { COORDINATE_SYSTEM, PROJECTION_MODE } from \"../../lib/constants.js\";\nimport memoize from \"../../utils/memoize.js\";\n// To quickly set a vector to zero\nconst ZERO_VECTOR = [0, 0, 0, 0];\n// 4x4 matrix that drops 4th component of vector\nconst VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\nconst IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nconst DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];\nconst DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];\nconst getMemoizedViewportUniforms = memoize(calculateViewportUniforms);\nexport function getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN) {\n  if (coordinateOrigin.length < 3) {\n    coordinateOrigin = [coordinateOrigin[0], coordinateOrigin[1], 0];\n  }\n  let shaderCoordinateOrigin = coordinateOrigin;\n  let geospatialOrigin;\n  let offsetMode = true;\n  if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {\n    geospatialOrigin = coordinateOrigin;\n  } else {\n    geospatialOrigin = viewport.isGeospatial ?\n    // @ts-expect-error longitude and latitude are not defined on the base Viewport, but is expected on geospatial viewports\n    [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0] : null;\n  }\n  switch (viewport.projectionMode) {\n    case PROJECTION_MODE.WEB_MERCATOR:\n      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {\n        geospatialOrigin = [0, 0, 0];\n        offsetMode = false;\n      }\n      break;\n    case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:\n      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n        // viewport center in world space\n        // @ts-expect-error when using LNGLAT coordinates, we expect the viewport to be geospatial, in which case geospatialOrigin is defined\n        shaderCoordinateOrigin = geospatialOrigin;\n      } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {\n        // viewport center in common space\n        shaderCoordinateOrigin = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1]), 0];\n        // Geospatial origin (wgs84) must match shaderCoordinateOrigin (common)\n        geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);\n        shaderCoordinateOrigin[0] -= coordinateOrigin[0];\n        shaderCoordinateOrigin[1] -= coordinateOrigin[1];\n        shaderCoordinateOrigin[2] -= coordinateOrigin[2];\n      }\n      break;\n    case PROJECTION_MODE.IDENTITY:\n      shaderCoordinateOrigin = viewport.position.map(Math.fround);\n      shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;\n      break;\n    case PROJECTION_MODE.GLOBE:\n      offsetMode = false;\n      geospatialOrigin = null;\n      break;\n    default:\n      // Unknown projection mode\n      offsetMode = false;\n  }\n  return {\n    geospatialOrigin,\n    shaderCoordinateOrigin,\n    offsetMode\n  };\n}\n// The code that utilizes Matrix4 does the same calculation as their mat4 counterparts,\n// has lower performance but provides error checking.\nfunction calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {\n  const {\n    viewMatrixUncentered,\n    projectionMatrix\n  } = viewport;\n  let {\n    viewMatrix,\n    viewProjectionMatrix\n  } = viewport;\n  let projectionCenter = ZERO_VECTOR;\n  let originCommon = ZERO_VECTOR;\n  let cameraPosCommon = viewport.cameraPosition;\n  const {\n    geospatialOrigin,\n    shaderCoordinateOrigin,\n    offsetMode\n  } = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin);\n  if (offsetMode) {\n    // Calculate transformed projectionCenter (using 64 bit precision JS)\n    // This is the key to offset mode precision\n    // (avoids doing this addition in 32 bit precision in GLSL)\n    // @ts-expect-error the 4th component is assigned below\n    originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);\n    cameraPosCommon = [cameraPosCommon[0] - originCommon[0], cameraPosCommon[1] - originCommon[1], cameraPosCommon[2] - originCommon[2]];\n    originCommon[3] = 1;\n    // projectionCenter = new Matrix4(viewProjectionMatrix)\n    //   .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);\n    projectionCenter = vec4.transformMat4([], originCommon, viewProjectionMatrix);\n    // Always apply uncentered projection matrix if available (shader adds center)\n    viewMatrix = viewMatrixUncentered || viewMatrix;\n    // Zero out 4th coordinate (\"after\" model matrix) - avoids further translations\n    // viewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)\n    //   .multiplyRight(VECTOR_TO_POINT_MATRIX);\n    viewProjectionMatrix = mat4.multiply([], projectionMatrix, viewMatrix);\n    viewProjectionMatrix = mat4.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);\n  }\n  return {\n    viewMatrix: viewMatrix,\n    viewProjectionMatrix: viewProjectionMatrix,\n    projectionCenter,\n    originCommon,\n    cameraPosCommon,\n    shaderCoordinateOrigin,\n    geospatialOrigin\n  };\n}\n/**\n * Returns uniforms for shaders based on current projection\n * includes: projection matrix suitable for shaders\n *\n * TODO - Ensure this works with any viewport, not just WebMercatorViewports\n *\n * @param {WebMercatorViewport} viewport -\n * @return {Float32Array} - 4x4 projection matrix that can be used in shaders\n */\nexport function getUniformsFromViewport({\n  viewport,\n  devicePixelRatio = 1,\n  modelMatrix = null,\n  // Match Layer.defaultProps\n  coordinateSystem = COORDINATE_SYSTEM.DEFAULT,\n  coordinateOrigin = DEFAULT_COORDINATE_ORIGIN,\n  autoWrapLongitude = false\n}) {\n  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;\n  }\n  const uniforms = getMemoizedViewportUniforms({\n    viewport,\n    devicePixelRatio,\n    coordinateSystem,\n    coordinateOrigin\n  });\n  uniforms.wrapLongitude = autoWrapLongitude;\n  uniforms.modelMatrix = modelMatrix || IDENTITY_MATRIX;\n  return uniforms;\n}\nfunction calculateViewportUniforms({\n  viewport,\n  devicePixelRatio,\n  coordinateSystem,\n  coordinateOrigin\n}) {\n  const {\n    projectionCenter,\n    viewProjectionMatrix,\n    originCommon,\n    cameraPosCommon,\n    shaderCoordinateOrigin,\n    geospatialOrigin\n  } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);\n  // Calculate projection pixels per unit\n  const distanceScales = viewport.getDistanceScales();\n  const viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];\n  // Distance at which screen pixels are projected.\n  // Used to scale sizes in clipspace to match screen pixels.\n  // When using Viewport class's default projection matrix, this yields 1 for orthographic\n  // and `viewport.focalDistance` for perspective views\n  const focalDistance = vec4.transformMat4([], [0, 0, -viewport.focalDistance, 1], viewport.projectionMatrix)[3] || 1;\n  const uniforms = {\n    // Projection mode values\n    coordinateSystem,\n    projectionMode: viewport.projectionMode,\n    coordinateOrigin: shaderCoordinateOrigin,\n    commonOrigin: originCommon.slice(0, 3),\n    center: projectionCenter,\n    // Backward compatibility\n    // TODO: remove in v9\n    // @ts-expect-error _pseudoMeters is only defined on WebMercator viewport\n    pseudoMeters: Boolean(viewport._pseudoMeters),\n    // Screen size\n    viewportSize,\n    devicePixelRatio,\n    focalDistance,\n    commonUnitsPerMeter: distanceScales.unitsPerMeter,\n    commonUnitsPerWorldUnit: distanceScales.unitsPerMeter,\n    commonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,\n    scale: viewport.scale,\n    // This is the mercator scale (2 ** zoom)\n    wrapLongitude: false,\n    viewProjectionMatrix,\n    modelMatrix: IDENTITY_MATRIX,\n    // This is for lighting calculations\n    cameraPosition: cameraPosCommon\n  };\n  if (geospatialOrigin) {\n    // Get high-precision DistanceScales from geospatial viewport\n    // TODO: stricter types in Viewport classes\n    const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);\n    switch (coordinateSystem) {\n      case COORDINATE_SYSTEM.METER_OFFSETS:\n        uniforms.commonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;\n        uniforms.commonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;\n        break;\n      case COORDINATE_SYSTEM.LNGLAT:\n      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n        // @ts-expect-error _pseudoMeters only exists on WebMercatorView\n        if (!viewport._pseudoMeters) {\n          uniforms.commonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;\n        }\n        uniforms.commonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;\n        uniforms.commonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;\n        break;\n      // a.k.a \"preprojected\" positions\n      case COORDINATE_SYSTEM.CARTESIAN:\n        uniforms.commonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];\n        uniforms.commonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];\n        break;\n      default:\n        break;\n    }\n  }\n  return uniforms;\n}","map":{"version":3,"names":["mat4","vec4","COORDINATE_SYSTEM","PROJECTION_MODE","memoize","ZERO_VECTOR","VECTOR_TO_POINT_MATRIX","IDENTITY_MATRIX","DEFAULT_PIXELS_PER_UNIT2","DEFAULT_COORDINATE_ORIGIN","getMemoizedViewportUniforms","calculateViewportUniforms","getOffsetOrigin","viewport","coordinateSystem","coordinateOrigin","length","shaderCoordinateOrigin","geospatialOrigin","offsetMode","LNGLAT_OFFSETS","METER_OFFSETS","isGeospatial","Math","fround","longitude","latitude","projectionMode","WEB_MERCATOR","LNGLAT","CARTESIAN","WEB_MERCATOR_AUTO_OFFSET","center","unprojectPosition","IDENTITY","position","map","GLOBE","calculateMatrixAndOffset","viewMatrixUncentered","projectionMatrix","viewMatrix","viewProjectionMatrix","projectionCenter","originCommon","cameraPosCommon","cameraPosition","projectPosition","transformMat4","multiply","getUniformsFromViewport","devicePixelRatio","modelMatrix","DEFAULT","autoWrapLongitude","uniforms","wrapLongitude","distanceScales","getDistanceScales","viewportSize","width","height","focalDistance","commonOrigin","slice","pseudoMeters","Boolean","_pseudoMeters","commonUnitsPerMeter","unitsPerMeter","commonUnitsPerWorldUnit","commonUnitsPerWorldUnit2","scale","distanceScalesAtOrigin","unitsPerMeter2","unitsPerDegree","unitsPerDegree2"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\shaderlib\\project\\viewport-uniforms.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable complexity, camelcase */\n\nimport {mat4, Matrix4Like, vec4} from '@math.gl/core';\n\nimport {COORDINATE_SYSTEM, PROJECTION_MODE} from '../../lib/constants';\n\nimport memoize from '../../utils/memoize';\n\nimport type Viewport from '../../viewports/viewport';\nimport type {CoordinateSystem} from '../../lib/constants';\n\ntype Vec3 = [number, number, number];\ntype Vec4 = [number, number, number, number];\n\n// To quickly set a vector to zero\nconst ZERO_VECTOR: Vec4 = [0, 0, 0, 0];\n// 4x4 matrix that drops 4th component of vector\nconst VECTOR_TO_POINT_MATRIX: Matrix4Like = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\nconst IDENTITY_MATRIX: Matrix4Like = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nconst DEFAULT_PIXELS_PER_UNIT2: Vec3 = [0, 0, 0];\nconst DEFAULT_COORDINATE_ORIGIN: Vec3 = [0, 0, 0];\n\nconst getMemoizedViewportUniforms = memoize(calculateViewportUniforms);\n\nexport function getOffsetOrigin(\n  viewport: Viewport,\n  coordinateSystem: CoordinateSystem,\n  coordinateOrigin: Vec3 = DEFAULT_COORDINATE_ORIGIN\n): {\n  geospatialOrigin: Vec3 | null;\n  shaderCoordinateOrigin: Vec3;\n  offsetMode: boolean;\n} {\n  if (coordinateOrigin.length < 3) {\n    coordinateOrigin = [coordinateOrigin[0], coordinateOrigin[1], 0];\n  }\n\n  let shaderCoordinateOrigin = coordinateOrigin;\n  let geospatialOrigin: Vec3 | null;\n  let offsetMode = true;\n\n  if (\n    coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS ||\n    coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS\n  ) {\n    geospatialOrigin = coordinateOrigin;\n  } else {\n    geospatialOrigin = viewport.isGeospatial\n      ? // @ts-expect-error longitude and latitude are not defined on the base Viewport, but is expected on geospatial viewports\n        [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0]\n      : null;\n  }\n\n  switch (viewport.projectionMode) {\n    case PROJECTION_MODE.WEB_MERCATOR:\n      if (\n        coordinateSystem === COORDINATE_SYSTEM.LNGLAT ||\n        coordinateSystem === COORDINATE_SYSTEM.CARTESIAN\n      ) {\n        geospatialOrigin = [0, 0, 0];\n        offsetMode = false;\n      }\n      break;\n\n    case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:\n      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n        // viewport center in world space\n        // @ts-expect-error when using LNGLAT coordinates, we expect the viewport to be geospatial, in which case geospatialOrigin is defined\n        shaderCoordinateOrigin = geospatialOrigin;\n      } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {\n        // viewport center in common space\n        shaderCoordinateOrigin = [\n          Math.fround(viewport.center[0]),\n          Math.fround(viewport.center[1]),\n          0\n        ];\n        // Geospatial origin (wgs84) must match shaderCoordinateOrigin (common)\n        geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);\n        shaderCoordinateOrigin[0] -= coordinateOrigin[0];\n        shaderCoordinateOrigin[1] -= coordinateOrigin[1];\n        shaderCoordinateOrigin[2] -= coordinateOrigin[2];\n      }\n      break;\n\n    case PROJECTION_MODE.IDENTITY:\n      shaderCoordinateOrigin = viewport.position.map(Math.fround) as Vec3;\n      shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;\n      break;\n\n    case PROJECTION_MODE.GLOBE:\n      offsetMode = false;\n      geospatialOrigin = null;\n      break;\n\n    default:\n      // Unknown projection mode\n      offsetMode = false;\n  }\n\n  return {geospatialOrigin, shaderCoordinateOrigin, offsetMode};\n}\n\n// The code that utilizes Matrix4 does the same calculation as their mat4 counterparts,\n// has lower performance but provides error checking.\nfunction calculateMatrixAndOffset(\n  viewport: Viewport,\n  coordinateSystem: CoordinateSystem,\n  coordinateOrigin: Vec3\n): {\n  viewMatrix: Matrix4Like;\n  viewProjectionMatrix: Matrix4Like;\n  projectionCenter: Vec4;\n  originCommon: Vec4;\n  cameraPosCommon: Vec3;\n  shaderCoordinateOrigin: Vec3;\n  geospatialOrigin: Vec3 | null;\n} {\n  const {viewMatrixUncentered, projectionMatrix} = viewport;\n  let {viewMatrix, viewProjectionMatrix} = viewport;\n\n  let projectionCenter = ZERO_VECTOR;\n  let originCommon: Vec4 = ZERO_VECTOR;\n  let cameraPosCommon: Vec3 = viewport.cameraPosition as Vec3;\n  const {geospatialOrigin, shaderCoordinateOrigin, offsetMode} = getOffsetOrigin(\n    viewport,\n    coordinateSystem,\n    coordinateOrigin\n  );\n\n  if (offsetMode) {\n    // Calculate transformed projectionCenter (using 64 bit precision JS)\n    // This is the key to offset mode precision\n    // (avoids doing this addition in 32 bit precision in GLSL)\n    // @ts-expect-error the 4th component is assigned below\n    originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);\n\n    cameraPosCommon = [\n      cameraPosCommon[0] - originCommon[0],\n      cameraPosCommon[1] - originCommon[1],\n      cameraPosCommon[2] - originCommon[2]\n    ];\n\n    originCommon[3] = 1;\n\n    // projectionCenter = new Matrix4(viewProjectionMatrix)\n    //   .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);\n    projectionCenter = vec4.transformMat4([], originCommon, viewProjectionMatrix);\n\n    // Always apply uncentered projection matrix if available (shader adds center)\n    viewMatrix = viewMatrixUncentered || viewMatrix;\n\n    // Zero out 4th coordinate (\"after\" model matrix) - avoids further translations\n    // viewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)\n    //   .multiplyRight(VECTOR_TO_POINT_MATRIX);\n    viewProjectionMatrix = mat4.multiply([], projectionMatrix, viewMatrix);\n    viewProjectionMatrix = mat4.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);\n  }\n\n  return {\n    viewMatrix: viewMatrix as Matrix4Like,\n    viewProjectionMatrix: viewProjectionMatrix as Matrix4Like,\n    projectionCenter,\n    originCommon,\n    cameraPosCommon,\n    shaderCoordinateOrigin,\n    geospatialOrigin\n  };\n}\n\nexport type ProjectUniforms = {\n  coordinateSystem: number;\n  projectionMode: number;\n  coordinateOrigin: Vec3;\n  commonOrigin: Vec3;\n  center: Vec4;\n  // Backward compatibility\n  // TODO: remove in v9\n  pseudoMeters: boolean;\n\n  // Screen size\n  viewportSize: [number, number];\n  devicePixelRatio: number;\n\n  focalDistance: number;\n  commonUnitsPerMeter: Vec3;\n  commonUnitsPerWorldUnit: Vec3;\n  commonUnitsPerWorldUnit2: Vec3;\n  /** 2^zoom */\n  scale: number;\n  wrapLongitude: boolean;\n\n  viewProjectionMatrix: Matrix4Like;\n  modelMatrix: Matrix4Like;\n\n  // This is for lighting calculations\n  cameraPosition: Vec3;\n};\n\nexport type ProjectProps = {\n  viewport: Viewport;\n  devicePixelRatio?: number;\n  modelMatrix?: Matrix4Like | null;\n  coordinateSystem?: CoordinateSystem;\n  coordinateOrigin?: Vec3;\n  autoWrapLongitude?: boolean;\n};\n\n/**\n * Returns uniforms for shaders based on current projection\n * includes: projection matrix suitable for shaders\n *\n * TODO - Ensure this works with any viewport, not just WebMercatorViewports\n *\n * @param {WebMercatorViewport} viewport -\n * @return {Float32Array} - 4x4 projection matrix that can be used in shaders\n */\nexport function getUniformsFromViewport({\n  viewport,\n  devicePixelRatio = 1,\n  modelMatrix = null,\n  // Match Layer.defaultProps\n  coordinateSystem = COORDINATE_SYSTEM.DEFAULT,\n  coordinateOrigin = DEFAULT_COORDINATE_ORIGIN,\n  autoWrapLongitude = false\n}: ProjectProps): ProjectUniforms {\n  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n    coordinateSystem = viewport.isGeospatial\n      ? COORDINATE_SYSTEM.LNGLAT\n      : COORDINATE_SYSTEM.CARTESIAN;\n  }\n\n  const uniforms = getMemoizedViewportUniforms({\n    viewport,\n    devicePixelRatio,\n    coordinateSystem,\n    coordinateOrigin\n  });\n\n  uniforms.wrapLongitude = autoWrapLongitude;\n  uniforms.modelMatrix = modelMatrix || IDENTITY_MATRIX;\n\n  return uniforms;\n}\n\nfunction calculateViewportUniforms({\n  viewport,\n  devicePixelRatio,\n  coordinateSystem,\n  coordinateOrigin\n}: {\n  viewport: Viewport;\n  devicePixelRatio: number;\n  coordinateSystem: CoordinateSystem;\n  coordinateOrigin: Vec3;\n}): ProjectUniforms {\n  const {\n    projectionCenter,\n    viewProjectionMatrix,\n    originCommon,\n    cameraPosCommon,\n    shaderCoordinateOrigin,\n    geospatialOrigin\n  } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);\n\n  // Calculate projection pixels per unit\n  const distanceScales = viewport.getDistanceScales();\n\n  const viewportSize: [number, number] = [\n    viewport.width * devicePixelRatio,\n    viewport.height * devicePixelRatio\n  ];\n\n  // Distance at which screen pixels are projected.\n  // Used to scale sizes in clipspace to match screen pixels.\n  // When using Viewport class's default projection matrix, this yields 1 for orthographic\n  // and `viewport.focalDistance` for perspective views\n  const focalDistance =\n    vec4.transformMat4([], [0, 0, -viewport.focalDistance, 1], viewport.projectionMatrix)[3] || 1;\n\n  const uniforms: ProjectUniforms = {\n    // Projection mode values\n    coordinateSystem,\n    projectionMode: viewport.projectionMode,\n    coordinateOrigin: shaderCoordinateOrigin,\n    commonOrigin: originCommon.slice(0, 3) as Vec3,\n    center: projectionCenter,\n\n    // Backward compatibility\n    // TODO: remove in v9\n    // @ts-expect-error _pseudoMeters is only defined on WebMercator viewport\n    pseudoMeters: Boolean(viewport._pseudoMeters),\n\n    // Screen size\n    viewportSize,\n    devicePixelRatio,\n\n    focalDistance,\n    commonUnitsPerMeter: distanceScales.unitsPerMeter as Vec3,\n    commonUnitsPerWorldUnit: distanceScales.unitsPerMeter as Vec3,\n    commonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,\n    scale: viewport.scale, // This is the mercator scale (2 ** zoom)\n    wrapLongitude: false,\n\n    viewProjectionMatrix,\n    modelMatrix: IDENTITY_MATRIX,\n\n    // This is for lighting calculations\n    cameraPosition: cameraPosCommon\n  };\n\n  if (geospatialOrigin) {\n    // Get high-precision DistanceScales from geospatial viewport\n    // TODO: stricter types in Viewport classes\n    const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin) as {\n      unitsPerMeter: Vec3;\n      metersPerUnit: Vec3;\n      unitsPerMeter2: Vec3;\n      unitsPerDegree: Vec3;\n      degreesPerUnit: Vec3;\n      unitsPerDegree2: Vec3;\n    };\n    switch (coordinateSystem) {\n      case COORDINATE_SYSTEM.METER_OFFSETS:\n        uniforms.commonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;\n        uniforms.commonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;\n        break;\n\n      case COORDINATE_SYSTEM.LNGLAT:\n      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n        // @ts-expect-error _pseudoMeters only exists on WebMercatorView\n        if (!viewport._pseudoMeters) {\n          uniforms.commonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;\n        }\n        uniforms.commonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;\n        uniforms.commonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;\n        break;\n\n      // a.k.a \"preprojected\" positions\n      case COORDINATE_SYSTEM.CARTESIAN:\n        uniforms.commonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];\n        uniforms.commonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  return uniforms;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}