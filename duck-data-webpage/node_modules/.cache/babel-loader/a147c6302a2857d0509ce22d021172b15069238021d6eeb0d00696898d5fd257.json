{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBrowser, toArrayBuffer } from '@loaders.gl/loader-utils';\n/**\n * Returns an async iterable that reads from a stream (works in both Node.js and browsers)\n * @param stream stream to iterator over\n */\nexport function makeStreamIterator(stream, options) {\n  return isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);\n}\n/**\n * Returns an async iterable that reads from a DOM (browser) stream\n * @param stream stream to iterate from\n * @see https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate\n */\nasync function* makeBrowserStreamIterator(stream, options) {\n  // WhatWG: stream is supposed to have a `getIterator` method\n  // if (typeof stream.getIterator === 'function') {\n  //   return stream.getIterator();\n  // }\n  // if (typeof stream[Symbol.asyncIterator] === 'function') {\n  //   return makeToArrayBufferIterator(stream);\n  // }\n  // In the browser, we first need to get a lock on the stream\n  const reader = stream.getReader();\n  let nextBatchPromise;\n  try {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const currentBatchPromise = nextBatchPromise || reader.read();\n      // Issue a read for an additional batch, while we await the next batch\n      // Idea is to make fetching happen in parallel with processing / parsing\n      if (options?._streamReadAhead) {\n        nextBatchPromise = reader.read();\n      }\n      // Read from the stream\n      // value is a Uint8Array\n      const {\n        done,\n        value\n      } = await currentBatchPromise;\n      // Exit if we're done\n      if (done) {\n        return;\n      }\n      // Else yield the chunk\n      yield toArrayBuffer(value);\n    }\n  } catch (error) {\n    // TODO - examples makes it look like this should always be called,\n    // but that generates exceptions so only call it if we do not reach the end\n    reader.releaseLock();\n  }\n}\n/**\n * Returns an async iterable that reads from a DOM (browser) stream\n * @param stream stream to iterate from\n * @note Requires Node.js >= 10\n */\nasync function* makeNodeStreamIterator(stream, options) {\n  // Hacky test for node version to ensure we don't call bad polyfills\n  // NODE 10+: stream is an asyncIterator\n  for await (const chunk of stream) {\n    yield toArrayBuffer(chunk); // Coerce each chunk to ArrayBuffer\n  }\n}\n/* TODO - remove NODE < 10\n * @see https://github.com/bustle/streaming-iterables, MIT license\n *\n  if (typeof stream[Symbol.asyncIterator] === 'function') {\n    return;\n  }\n\n  // TODO - check if is this ever used in Node 10+?\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const data = stream.read();\n    if (data !== null) {\n      yield toArrayBuffer(data);\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    if (stream._readableState?.ended) {\n      return;\n    }\n    await onceReadable(stream);\n  }\n\nasync function onceReadable(stream: Readable): Promise<any> {\n  return new Promise((resolve) => {\n    stream.once('readable', resolve);\n  });\n}\n  */","map":{"version":3,"names":["isBrowser","toArrayBuffer","makeStreamIterator","stream","options","makeBrowserStreamIterator","makeNodeStreamIterator","reader","getReader","nextBatchPromise","currentBatchPromise","read","_streamReadAhead","done","value","error","releaseLock","chunk"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-stream-iterator.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBrowser, toArrayBuffer } from '@loaders.gl/loader-utils';\n/**\n * Returns an async iterable that reads from a stream (works in both Node.js and browsers)\n * @param stream stream to iterator over\n */\nexport function makeStreamIterator(stream, options) {\n    return isBrowser\n        ? makeBrowserStreamIterator(stream, options)\n        : makeNodeStreamIterator(stream, options);\n}\n/**\n * Returns an async iterable that reads from a DOM (browser) stream\n * @param stream stream to iterate from\n * @see https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate\n */\nasync function* makeBrowserStreamIterator(stream, options) {\n    // WhatWG: stream is supposed to have a `getIterator` method\n    // if (typeof stream.getIterator === 'function') {\n    //   return stream.getIterator();\n    // }\n    // if (typeof stream[Symbol.asyncIterator] === 'function') {\n    //   return makeToArrayBufferIterator(stream);\n    // }\n    // In the browser, we first need to get a lock on the stream\n    const reader = stream.getReader();\n    let nextBatchPromise;\n    try {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const currentBatchPromise = nextBatchPromise || reader.read();\n            // Issue a read for an additional batch, while we await the next batch\n            // Idea is to make fetching happen in parallel with processing / parsing\n            if (options?._streamReadAhead) {\n                nextBatchPromise = reader.read();\n            }\n            // Read from the stream\n            // value is a Uint8Array\n            const { done, value } = await currentBatchPromise;\n            // Exit if we're done\n            if (done) {\n                return;\n            }\n            // Else yield the chunk\n            yield toArrayBuffer(value);\n        }\n    }\n    catch (error) {\n        // TODO - examples makes it look like this should always be called,\n        // but that generates exceptions so only call it if we do not reach the end\n        reader.releaseLock();\n    }\n}\n/**\n * Returns an async iterable that reads from a DOM (browser) stream\n * @param stream stream to iterate from\n * @note Requires Node.js >= 10\n */\nasync function* makeNodeStreamIterator(stream, options) {\n    // Hacky test for node version to ensure we don't call bad polyfills\n    // NODE 10+: stream is an asyncIterator\n    for await (const chunk of stream) {\n        yield toArrayBuffer(chunk); // Coerce each chunk to ArrayBuffer\n    }\n}\n/* TODO - remove NODE < 10\n * @see https://github.com/bustle/streaming-iterables, MIT license\n *\n  if (typeof stream[Symbol.asyncIterator] === 'function') {\n    return;\n  }\n\n  // TODO - check if is this ever used in Node 10+?\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const data = stream.read();\n    if (data !== null) {\n      yield toArrayBuffer(data);\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    if (stream._readableState?.ended) {\n      return;\n    }\n    await onceReadable(stream);\n  }\n\nasync function onceReadable(stream: Readable): Promise<any> {\n  return new Promise((resolve) => {\n    stream.once('readable', resolve);\n  });\n}\n  */\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,SAAS,EAAEC,aAAa,QAAQ,0BAA0B;AACnE;AACA;AACA;AACA;AACA,OAAO,SAASC,kBAAkBA,CAACC,MAAM,EAAEC,OAAO,EAAE;EAChD,OAAOJ,SAAS,GACVK,yBAAyB,CAACF,MAAM,EAAEC,OAAO,CAAC,GAC1CE,sBAAsB,CAACH,MAAM,EAAEC,OAAO,CAAC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgBC,yBAAyBA,CAACF,MAAM,EAAEC,OAAO,EAAE;EACvD;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAMG,MAAM,GAAGJ,MAAM,CAACK,SAAS,CAAC,CAAC;EACjC,IAAIC,gBAAgB;EACpB,IAAI;IACA;IACA,OAAO,IAAI,EAAE;MACT,MAAMC,mBAAmB,GAAGD,gBAAgB,IAAIF,MAAM,CAACI,IAAI,CAAC,CAAC;MAC7D;MACA;MACA,IAAIP,OAAO,EAAEQ,gBAAgB,EAAE;QAC3BH,gBAAgB,GAAGF,MAAM,CAACI,IAAI,CAAC,CAAC;MACpC;MACA;MACA;MACA,MAAM;QAAEE,IAAI;QAAEC;MAAM,CAAC,GAAG,MAAMJ,mBAAmB;MACjD;MACA,IAAIG,IAAI,EAAE;QACN;MACJ;MACA;MACA,MAAMZ,aAAa,CAACa,KAAK,CAAC;IAC9B;EACJ,CAAC,CACD,OAAOC,KAAK,EAAE;IACV;IACA;IACAR,MAAM,CAACS,WAAW,CAAC,CAAC;EACxB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgBV,sBAAsBA,CAACH,MAAM,EAAEC,OAAO,EAAE;EACpD;EACA;EACA,WAAW,MAAMa,KAAK,IAAId,MAAM,EAAE;IAC9B,MAAMF,aAAa,CAACgB,KAAK,CAAC,CAAC,CAAC;EAChC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}