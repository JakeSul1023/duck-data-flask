{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport LayersPass from \"./layers-pass.js\";\nexport default class ShadowPass extends LayersPass {\n  constructor(device, props) {\n    super(device, props);\n    // The shadowMap texture\n    const shadowMap = device.createTexture({\n      format: 'rgba8unorm',\n      width: 1,\n      height: 1,\n      sampler: {\n        minFilter: 'linear',\n        magFilter: 'linear',\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge'\n      },\n      mipmaps: true\n    });\n    const depthBuffer = device.createTexture({\n      format: 'depth16unorm',\n      width: 1,\n      height: 1,\n      mipmaps: false\n    });\n    this.fbo = device.createFramebuffer({\n      id: 'shadowmap',\n      width: 1,\n      height: 1,\n      colorAttachments: [shadowMap],\n      // Depth attachment has to be specified for depth test to work\n      depthStencilAttachment: depthBuffer\n    });\n  }\n  delete() {\n    if (this.fbo) {\n      this.fbo.destroy();\n      this.fbo = null;\n    }\n  }\n  getShadowMap() {\n    return this.fbo.colorAttachments[0].texture;\n  }\n  render(params) {\n    const target = this.fbo;\n    // @ts-expect-error TODO - assuming WebGL context\n    const pixelRatio = this.device.canvasContext.cssToDeviceRatio();\n    const viewport = params.viewports[0];\n    const width = viewport.width * pixelRatio;\n    const height = viewport.height * pixelRatio;\n    const clearColor = [1, 1, 1, 1];\n    if (width !== target.width || height !== target.height) {\n      target.resize({\n        width,\n        height\n      });\n    }\n    super.render({\n      ...params,\n      clearColor,\n      target,\n      pass: 'shadow'\n    });\n  }\n  getLayerParameters(layer, layerIndex, viewport) {\n    return {\n      ...layer.props.parameters,\n      blend: false,\n      depthWriteEnabled: true,\n      depthCompare: 'less-equal'\n    };\n  }\n  shouldDrawLayer(layer) {\n    return layer.props.shadowEnabled !== false;\n  }\n  getShaderModuleProps(layer, effects, otherShaderModuleProps) {\n    return {\n      shadow: {\n        project: otherShaderModuleProps.project,\n        drawToShadowMap: true\n      }\n    };\n  }\n}\n//# sourceMappingURL=shadow-pass.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}