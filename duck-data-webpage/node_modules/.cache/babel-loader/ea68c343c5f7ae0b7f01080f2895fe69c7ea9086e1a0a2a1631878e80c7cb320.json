{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Resource } from \"./resource.js\";\n/** Abstract GPU buffer */\nexport class Buffer extends Resource {\n  static defaultProps = {\n    ...Resource.defaultProps,\n    usage: 0,\n    // Buffer.COPY_DST | Buffer.COPY_SRC\n    byteLength: 0,\n    byteOffset: 0,\n    data: null,\n    indexType: 'uint16',\n    mappedAtCreation: false\n  };\n  // Usage Flags\n  static MAP_READ = 0x01;\n  static MAP_WRITE = 0x02;\n  static COPY_SRC = 0x0004;\n  static COPY_DST = 0x0008;\n  /** Index buffer */\n  static INDEX = 0x0010;\n  /** Vertex buffer */\n  static VERTEX = 0x0020;\n  /** Uniform buffer */\n  static UNIFORM = 0x0040;\n  /** Storage buffer */\n  static STORAGE = 0x0080;\n  static INDIRECT = 0x0100;\n  static QUERY_RESOLVE = 0x0200;\n  get [Symbol.toStringTag]() {\n    return 'Buffer';\n  }\n  /** The usage with which this buffer was created */\n  usage;\n  /** For index buffers, whether indices are 16 or 32 bit */\n  indexType;\n  /** \"Time\" of last update, can be used to check if redraw is needed */\n  updateTimestamp;\n  constructor(device, props) {\n    const deducedProps = {\n      ...props\n    };\n    // Deduce indexType\n    if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {\n      if (props.data instanceof Uint32Array) {\n        deducedProps.indexType = 'uint32';\n      } else if (props.data instanceof Uint16Array) {\n        deducedProps.indexType = 'uint16';\n      }\n    }\n    // Remove data from props before storing, we don't want to hold on to a big chunk of memory\n    delete deducedProps.data;\n    super(device, deducedProps, Buffer.defaultProps);\n    this.usage = deducedProps.usage || 0;\n    this.indexType = deducedProps.indexType;\n    // TODO - perhaps this should be set on async write completion?\n    this.updateTimestamp = device.incrementTimestamp();\n  }\n  /**\n   * Create a copy of this Buffer with new byteLength, with same props but of the specified size.\n   * @note Does not copy contents of the cloned Buffer.\n   */\n  clone(props) {\n    return this.device.createBuffer({\n      ...this.props,\n      ...props\n    });\n  }\n  /** Read data synchronously. @note WebGL2 only */\n  readSyncWebGL(byteOffset, byteLength) {\n    throw new Error('not implemented');\n  }\n  // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)\n  /** Max amount of debug data saved. Two vec4's */\n  static DEBUG_DATA_MAX_LENGTH = 32;\n  /** A partial CPU-side copy of the data in this buffer, for debugging purposes */\n  debugData = new ArrayBuffer(0);\n  /** This doesn't handle partial non-zero offset updates correctly */\n  _setDebugData(data, byteOffset, byteLength) {\n    const arrayBuffer = ArrayBuffer.isView(data) ? data.buffer : data;\n    const debugDataLength = Math.min(data ? data.byteLength : byteLength, Buffer.DEBUG_DATA_MAX_LENGTH);\n    if (arrayBuffer === null) {\n      this.debugData = new ArrayBuffer(debugDataLength);\n    } else if (byteOffset === 0 && byteLength === arrayBuffer.byteLength) {\n      this.debugData = arrayBuffer.slice(0, debugDataLength);\n    } else {\n      this.debugData = arrayBuffer.slice(byteOffset, byteOffset + debugDataLength);\n    }\n  }\n}","map":{"version":3,"names":["Resource","Buffer","defaultProps","usage","byteLength","byteOffset","data","indexType","mappedAtCreation","MAP_READ","MAP_WRITE","COPY_SRC","COPY_DST","INDEX","VERTEX","UNIFORM","STORAGE","INDIRECT","QUERY_RESOLVE","Symbol","toStringTag","updateTimestamp","constructor","device","props","deducedProps","Uint32Array","Uint16Array","incrementTimestamp","clone","createBuffer","readSyncWebGL","Error","DEBUG_DATA_MAX_LENGTH","debugData","ArrayBuffer","_setDebugData","arrayBuffer","isView","buffer","debugDataLength","Math","min","slice"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\core\\src\\adapter\\resources\\buffer.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device} from '../device';\nimport {Resource, ResourceProps} from './resource';\n\nexport type BufferProps = ResourceProps & {\n  /** Supply a handle to connect to an existing device-specific buffer */\n  handle?: WebGLBuffer;\n  /** Specifies how this buffer can be used */\n  usage?: number;\n  /** Length in bytes of memory to be allocated. If not specified, `byteLength` of  `props.data` will be used. */\n  byteLength?: number;\n  /** Data to initialize the buffer with. */\n  data?: ArrayBuffer | ArrayBufferView | null;\n  /** Byte offset into the newly created Buffer to store data at */\n  byteOffset?: number;\n  /** If props.usage includes Buffer.INDEX */\n  indexType?: 'uint16' | 'uint32';\n\n  // TBD\n  mappedAtCreation?: boolean;\n};\n\n/** Abstract GPU buffer */\nexport abstract class Buffer extends Resource<BufferProps> {\n  static override defaultProps: Required<BufferProps> = {\n    ...Resource.defaultProps,\n    usage: 0, // Buffer.COPY_DST | Buffer.COPY_SRC\n    byteLength: 0,\n    byteOffset: 0,\n    data: null,\n    indexType: 'uint16',\n    mappedAtCreation: false\n  };\n\n  // Usage Flags\n  static MAP_READ = 0x01;\n  static MAP_WRITE = 0x02;\n  static COPY_SRC = 0x0004;\n  static COPY_DST = 0x0008;\n  /** Index buffer */\n  static INDEX = 0x0010;\n  /** Vertex buffer */\n  static VERTEX = 0x0020;\n  /** Uniform buffer */\n  static UNIFORM = 0x0040;\n  /** Storage buffer */\n  static STORAGE = 0x0080;\n  static INDIRECT = 0x0100;\n  static QUERY_RESOLVE = 0x0200;\n\n  override get [Symbol.toStringTag](): string {\n    return 'Buffer';\n  }\n\n  /** The usage with which this buffer was created */\n  readonly usage: number;\n  /** For index buffers, whether indices are 16 or 32 bit */\n  readonly indexType?: 'uint16' | 'uint32';\n  /** Length of buffer in bytes */\n  abstract byteLength: number;\n  /** \"Time\" of last update, can be used to check if redraw is needed */\n  updateTimestamp: number;\n\n  constructor(device: Device, props: BufferProps) {\n    const deducedProps = {...props};\n\n    // Deduce indexType\n    if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {\n      if (props.data instanceof Uint32Array) {\n        deducedProps.indexType = 'uint32';\n      } else if (props.data instanceof Uint16Array) {\n        deducedProps.indexType = 'uint16';\n      }\n    }\n\n    // Remove data from props before storing, we don't want to hold on to a big chunk of memory\n    delete deducedProps.data;\n\n    super(device, deducedProps, Buffer.defaultProps);\n\n    this.usage = deducedProps.usage || 0;\n    this.indexType = deducedProps.indexType;\n\n    // TODO - perhaps this should be set on async write completion?\n    this.updateTimestamp = device.incrementTimestamp();\n  }\n\n  /**\n   * Create a copy of this Buffer with new byteLength, with same props but of the specified size.\n   * @note Does not copy contents of the cloned Buffer.\n   */\n  clone(props: {byteLength: number}): Buffer {\n    return this.device.createBuffer({...this.props, ...props});\n  }\n\n  /** Write data to buffer */\n  abstract write(data: ArrayBufferView, byteOffset?: number): void;\n\n  /** Read data asynchronously */\n  abstract readAsync(byteOffset?: number, byteLength?: number): Promise<Uint8Array>;\n\n  /** Read data synchronously. @note WebGL2 only */\n  readSyncWebGL(byteOffset?: number, byteLength?: number): Uint8Array {\n    throw new Error('not implemented');\n  }\n\n  // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)\n\n  /** Max amount of debug data saved. Two vec4's */\n  static DEBUG_DATA_MAX_LENGTH = 32;\n\n  /** A partial CPU-side copy of the data in this buffer, for debugging purposes */\n  debugData: ArrayBuffer = new ArrayBuffer(0);\n\n  /** This doesn't handle partial non-zero offset updates correctly */\n  protected _setDebugData(\n    data: ArrayBufferView | ArrayBuffer | null,\n    byteOffset: number,\n    byteLength: number\n  ): void {\n    const arrayBuffer: ArrayBuffer | null = ArrayBuffer.isView(data) ? data.buffer : data;\n    const debugDataLength = Math.min(\n      data ? data.byteLength : byteLength,\n      Buffer.DEBUG_DATA_MAX_LENGTH\n    );\n    if (arrayBuffer === null) {\n      this.debugData = new ArrayBuffer(debugDataLength);\n    } else if (byteOffset === 0 && byteLength === arrayBuffer.byteLength) {\n      this.debugData = arrayBuffer.slice(0, debugDataLength);\n    } else {\n      this.debugData = arrayBuffer.slice(byteOffset, byteOffset + debugDataLength);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}