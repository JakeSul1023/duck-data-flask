{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@luma.gl/core';\nimport { WgslReflect } from 'wgsl_reflect';\n/**\n * Parse a ShaderLayout from WGSL shader source code.\n * @param source WGSL source code (can contain both @vertex and @fragment entry points)\n * @returns\n */\nexport function getShaderLayoutFromWGSL(source) {\n  const shaderLayout = {\n    attributes: [],\n    bindings: []\n  };\n  let parsedWGSL;\n  try {\n    parsedWGSL = parseWGSL(source);\n  } catch (error) {\n    log.error(error.message)();\n    return shaderLayout;\n  }\n  for (const uniform of parsedWGSL.uniforms) {\n    const members = [];\n    for (const attribute of uniform.type?.members || []) {\n      members.push({\n        name: attribute.name,\n        type: getType(attribute.type)\n      });\n    }\n    shaderLayout.bindings.push({\n      type: 'uniform',\n      name: uniform.name,\n      group: uniform.group,\n      location: uniform.binding,\n      // @ts-expect-error TODO - unused for now but needs fixing\n      members\n    });\n  }\n  for (const texture of parsedWGSL.textures) {\n    shaderLayout.bindings.push({\n      type: 'texture',\n      name: texture.name,\n      group: texture.group,\n      location: texture.binding\n    });\n  }\n  for (const sampler of parsedWGSL.samplers) {\n    shaderLayout.bindings.push({\n      type: 'sampler',\n      name: sampler.name,\n      group: sampler.group,\n      location: sampler.binding\n    });\n  }\n  const vertex = parsedWGSL.entry.vertex[0]; // \"main\"\n  // Vertex shader inputs\n  const attributeCount = vertex?.inputs.length || 0; // inputs to \"main\"\n  for (let i = 0; i < attributeCount; i++) {\n    const wgslAttribute = vertex.inputs[i];\n    // locationType can be \"builtin\"\n    if (wgslAttribute.locationType === 'location') {\n      const type = getType(wgslAttribute.type);\n      shaderLayout.attributes.push({\n        name: wgslAttribute.name,\n        location: Number(wgslAttribute.location),\n        type\n      });\n    }\n  }\n  return shaderLayout;\n}\n/** Get a valid shader attribute type string from a wgsl-reflect type */\nfunction getType(type) {\n  return type.format ? `${type.name}<${type.format.name}>` : type.name;\n}\nfunction parseWGSL(source) {\n  try {\n    return new WgslReflect(source);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw error;\n    }\n    let message = 'WGSL parse error';\n    if (typeof error === 'object' && error?.message) {\n      message += `: ${error.message} `;\n    }\n    if (typeof error === 'object' && error?.token) {\n      message += error.token.line || '';\n    }\n    throw new Error(message, {\n      cause: error\n    });\n  }\n}\n//# sourceMappingURL=get-shader-layout-wgsl.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}