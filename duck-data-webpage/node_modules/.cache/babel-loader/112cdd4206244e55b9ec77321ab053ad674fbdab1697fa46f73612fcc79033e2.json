{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* eslint-disable complexity */\nimport DataColumn from \"./data-column.js\";\nimport assert from \"../../utils/assert.js\";\nimport { createIterable, getAccessorFromBuffer } from \"../../utils/iterable-utils.js\";\nimport { fillArray } from \"../../utils/flatten.js\";\nimport * as range from \"../../utils/range.js\";\nimport { bufferLayoutEqual } from \"./gl-utils.js\";\nimport { normalizeTransitionSettings } from \"./transition-settings.js\";\nexport default class Attribute extends DataColumn {\n  constructor(device, opts) {\n    super(device, opts, {\n      startIndices: null,\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      layoutChanged: false,\n      updateRanges: range.FULL\n    });\n    /** Legacy approach to set attribute value - read `isConstant` instead for attribute state */\n    this.constant = false;\n    // eslint-disable-next-line\n    this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : undefined);\n    Object.seal(this.settings);\n    Object.seal(this.state);\n    // Check all fields and generate helpful error messages\n    this._validateAttributeUpdaters();\n  }\n  get startIndices() {\n    return this.state.startIndices;\n  }\n  set startIndices(layout) {\n    this.state.startIndices = layout;\n  }\n  needsUpdate() {\n    return this.state.needsUpdate;\n  }\n  needsRedraw({\n    clearChangedFlags = false\n  } = {}) {\n    const needsRedraw = this.state.needsRedraw;\n    this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n    return needsRedraw;\n  }\n  layoutChanged() {\n    return this.state.layoutChanged;\n  }\n  setAccessor(accessor) {\n    var _a;\n    (_a = this.state).layoutChanged || (_a.layoutChanged = !bufferLayoutEqual(accessor, this.getAccessor()));\n    super.setAccessor(accessor);\n  }\n  getUpdateTriggers() {\n    const {\n      accessor\n    } = this.settings;\n    // Backards compatibility: allow attribute name to be used as update trigger key\n    return [this.id].concat(typeof accessor !== 'function' && accessor || []);\n  }\n  supportsTransition() {\n    return Boolean(this.settings.transition);\n  }\n  // Resolve transition settings object if transition is enabled, otherwise `null`\n  getTransitionSetting(opts) {\n    if (!opts || !this.supportsTransition()) {\n      return null;\n    }\n    const {\n      accessor\n    } = this.settings;\n    // TODO: have the layer resolve these transition settings itself?\n    const layerSettings = this.settings.transition;\n    // these are the transition settings passed in by the user\n    const userSettings = Array.isArray(accessor) ?\n    // @ts-ignore\n    opts[accessor.find(a => opts[a])] :\n    // @ts-ignore\n    opts[accessor];\n    // Shorthand: use duration instead of parameter object\n    return normalizeTransitionSettings(userSettings, layerSettings);\n  }\n  setNeedsUpdate(reason = this.id, dataRange) {\n    this.state.needsUpdate = this.state.needsUpdate || reason;\n    this.setNeedsRedraw(reason);\n    if (dataRange) {\n      const {\n        startRow = 0,\n        endRow = Infinity\n      } = dataRange;\n      this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n    } else {\n      this.state.updateRanges = range.FULL;\n    }\n  }\n  clearNeedsUpdate() {\n    this.state.needsUpdate = false;\n    this.state.updateRanges = range.EMPTY;\n  }\n  setNeedsRedraw(reason = this.id) {\n    this.state.needsRedraw = this.state.needsRedraw || reason;\n  }\n  allocate(numInstances) {\n    const {\n      state,\n      settings\n    } = this;\n    if (settings.noAlloc) {\n      // Data is provided through a Buffer object.\n      return false;\n    }\n    if (settings.update) {\n      super.allocate(numInstances, state.updateRanges !== range.FULL);\n      return true;\n    }\n    return false;\n  }\n  updateBuffer({\n    numInstances,\n    data,\n    props,\n    context\n  }) {\n    if (!this.needsUpdate()) {\n      return false;\n    }\n    const {\n      state: {\n        updateRanges\n      },\n      settings: {\n        update,\n        noAlloc\n      }\n    } = this;\n    let updated = true;\n    if (update) {\n      // Custom updater - typically for non-instanced layers\n      for (const [startRow, endRow] of updateRanges) {\n        update.call(context, this, {\n          data,\n          startRow,\n          endRow,\n          props,\n          numInstances\n        });\n      }\n      if (!this.value) {\n        // no value was assigned during update\n      } else if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {\n        this.setData({\n          value: this.value,\n          constant: this.constant\n        });\n        // Setting attribute.constant in updater is a legacy approach that interferes with allocation in the next cycle\n        // Respect it here but reset after use\n        this.constant = false;\n      } else {\n        for (const [startRow, endRow] of updateRanges) {\n          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n          const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;\n          super.updateSubBuffer({\n            startOffset,\n            endOffset\n          });\n        }\n      }\n      this._checkAttributeArray();\n    } else {\n      updated = false;\n    }\n    this.clearNeedsUpdate();\n    this.setNeedsRedraw();\n    return updated;\n  }\n  // Use generic value\n  // Returns true if successful\n  setConstantValue(value) {\n    // TODO(ibgreen): WebGPU does not support constant values\n    const isWebGPU = this.device.type === 'webgpu';\n    if (isWebGPU || value === undefined || typeof value === 'function') {\n      return false;\n    }\n    const hasChanged = this.setData({\n      constant: true,\n      value\n    });\n    if (hasChanged) {\n      this.setNeedsRedraw();\n    }\n    this.clearNeedsUpdate();\n    return true;\n  }\n  // Use external buffer\n  // Returns true if successful\n  // eslint-disable-next-line max-statements\n  setExternalBuffer(buffer) {\n    const {\n      state\n    } = this;\n    if (!buffer) {\n      state.lastExternalBuffer = null;\n      return false;\n    }\n    this.clearNeedsUpdate();\n    if (state.lastExternalBuffer === buffer) {\n      return true;\n    }\n    state.lastExternalBuffer = buffer;\n    this.setNeedsRedraw();\n    this.setData(buffer);\n    return true;\n  }\n  // Binary value is a typed array packed from mapping the source data with the accessor\n  // If the returned value from the accessor is the same as the attribute value, set it directly\n  // Otherwise use the auto updater for transform/normalization\n  setBinaryValue(buffer, startIndices = null) {\n    const {\n      state,\n      settings\n    } = this;\n    if (!buffer) {\n      state.binaryValue = null;\n      state.binaryAccessor = null;\n      return false;\n    }\n    if (settings.noAlloc) {\n      // Let the layer handle this\n      return false;\n    }\n    if (state.binaryValue === buffer) {\n      this.clearNeedsUpdate();\n      return true;\n    }\n    state.binaryValue = buffer;\n    this.setNeedsRedraw();\n    const needsUpdate = settings.transform || startIndices !== this.startIndices;\n    if (needsUpdate) {\n      if (ArrayBuffer.isView(buffer)) {\n        buffer = {\n          value: buffer\n        };\n      }\n      const binaryValue = buffer;\n      assert(ArrayBuffer.isView(binaryValue.value), `invalid ${settings.accessor}`);\n      const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;\n      state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {\n        size: binaryValue.size || this.size,\n        stride: binaryValue.stride,\n        offset: binaryValue.offset,\n        startIndices: startIndices,\n        nested: needsNormalize\n      });\n      // Fall through to auto updater\n      return false;\n    }\n    this.clearNeedsUpdate();\n    this.setData(buffer);\n    return true;\n  }\n  getVertexOffset(row) {\n    const {\n      startIndices\n    } = this;\n    const vertexIndex = startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row;\n    return vertexIndex * this.size;\n  }\n  getValue() {\n    const shaderAttributeDefs = this.settings.shaderAttributes;\n    const result = super.getValue();\n    if (!shaderAttributeDefs) {\n      return result;\n    }\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      Object.assign(result, super.getValue(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));\n    }\n    return result;\n  }\n  /** Generate WebGPU-style buffer layout descriptor from this attribute */\n  getBufferLayout(/** A luma.gl Model-shaped object that supplies additional hint to attribute resolution */\n  modelInfo) {\n    // Clear change flag\n    this.state.layoutChanged = false;\n    const shaderAttributeDefs = this.settings.shaderAttributes;\n    const result = super._getBufferLayout();\n    const {\n      stepMode\n    } = this.settings;\n    if (stepMode === 'dynamic') {\n      // If model info is provided, use isInstanced flag to determine step mode\n      // If no model info is provided, assume it's an instanced model (most common use case)\n      result.stepMode = modelInfo ? modelInfo.isInstanced ? 'instance' : 'vertex' : 'instance';\n    } else {\n      result.stepMode = stepMode ?? 'vertex';\n    }\n    if (!shaderAttributeDefs) {\n      return result;\n    }\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      const map = super._getBufferLayout(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]);\n      // @ts-ignore\n      result.attributes.push(...map.attributes);\n    }\n    return result;\n  }\n  /* eslint-disable max-depth, max-statements */\n  _autoUpdater(attribute, {\n    data,\n    startRow,\n    endRow,\n    props,\n    numInstances\n  }) {\n    if (attribute.constant) {\n      // @ts-ignore TODO(ibgreen) declare context?\n      if (this.context.device.type !== 'webgpu') {\n        return;\n      }\n    }\n    const {\n      settings,\n      state,\n      value,\n      size,\n      startIndices\n    } = attribute;\n    const {\n      accessor,\n      transform\n    } = settings;\n    let accessorFunc = state.binaryAccessor || (\n    // @ts-ignore\n    typeof accessor === 'function' ? accessor : props[accessor]);\n    // TODO(ibgreen) WebGPU needs buffers, generate an accessor function from a constant\n    if (typeof accessorFunc !== 'function') {\n      accessorFunc = () => accessorFunc;\n    }\n    assert(typeof accessorFunc === 'function', `accessor \"${accessor}\" is not a function`);\n    let i = attribute.getVertexOffset(startRow);\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      let objectValue = accessorFunc(object, objectInfo);\n      if (transform) {\n        // transform callbacks could be bound to a particular layer instance.\n        // always point `this` to the current layer.\n        objectValue = transform.call(this, objectValue);\n      }\n      if (startIndices) {\n        const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];\n        if (objectValue && Array.isArray(objectValue[0])) {\n          let startIndex = i;\n          for (const item of objectValue) {\n            attribute._normalizeValue(item, value, startIndex);\n            startIndex += size;\n          }\n        } else if (objectValue && objectValue.length > size) {\n          value.set(objectValue, i);\n        } else {\n          attribute._normalizeValue(objectValue, objectInfo.target, 0);\n          fillArray({\n            target: value,\n            source: objectInfo.target,\n            start: i,\n            count: numVertices\n          });\n        }\n        i += numVertices * size;\n      } else {\n        attribute._normalizeValue(objectValue, value, i);\n        i += size;\n      }\n    }\n  }\n  /* eslint-enable max-depth, max-statements */\n  // Validate deck.gl level fields\n  _validateAttributeUpdaters() {\n    const {\n      settings\n    } = this;\n    // Check that 'update' is a valid function\n    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n    if (!hasUpdater) {\n      throw new Error(`Attribute ${this.id} missing update or accessor`);\n    }\n  }\n  // check that the first few elements of the attribute are reasonable\n  /* eslint-disable no-fallthrough */\n  _checkAttributeArray() {\n    const {\n      value\n    } = this;\n    const limit = Math.min(4, this.size);\n    if (value && value.length >= limit) {\n      let valid = true;\n      switch (limit) {\n        case 4:\n          valid = valid && Number.isFinite(value[3]);\n        case 3:\n          valid = valid && Number.isFinite(value[2]);\n        case 2:\n          valid = valid && Number.isFinite(value[1]);\n        case 1:\n          valid = valid && Number.isFinite(value[0]);\n          break;\n        default:\n          valid = false;\n      }\n      if (!valid) {\n        throw new Error(`Illegal attribute generated for ${this.id}`);\n      }\n    }\n  }\n}","map":{"version":3,"names":["DataColumn","assert","createIterable","getAccessorFromBuffer","fillArray","range","bufferLayoutEqual","normalizeTransitionSettings","Attribute","constructor","device","opts","startIndices","lastExternalBuffer","binaryValue","binaryAccessor","needsUpdate","needsRedraw","layoutChanged","updateRanges","FULL","constant","settings","update","accessor","_autoUpdater","undefined","Object","seal","state","_validateAttributeUpdaters","layout","clearChangedFlags","setAccessor","_a","getAccessor","getUpdateTriggers","id","concat","supportsTransition","Boolean","transition","getTransitionSetting","layerSettings","userSettings","Array","isArray","find","a","setNeedsUpdate","reason","dataRange","setNeedsRedraw","startRow","endRow","Infinity","add","clearNeedsUpdate","EMPTY","allocate","numInstances","noAlloc","updateBuffer","data","props","context","updated","call","value","buffer","byteLength","byteOffset","setData","startOffset","Number","isFinite","getVertexOffset","endOffset","length","size","updateSubBuffer","_checkAttributeArray","setConstantValue","isWebGPU","type","hasChanged","setExternalBuffer","setBinaryValue","transform","ArrayBuffer","isView","needsNormalize","stride","offset","nested","row","vertexIndex","getValue","shaderAttributeDefs","shaderAttributes","result","shaderAttributeName","assign","getBufferLayout","modelInfo","_getBufferLayout","stepMode","isInstanced","map","attributes","push","attribute","accessorFunc","i","iterable","objectInfo","object","index","objectValue","numVertices","startIndex","item","_normalizeValue","set","target","source","start","count","hasUpdater","Error","limit","Math","min","valid"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\core\\src\\lib\\attribute\\attribute.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable complexity */\nimport DataColumn, {\n  DataColumnOptions,\n  ShaderAttributeOptions,\n  BufferAccessor,\n  DataColumnSettings\n} from './data-column';\nimport assert from '../../utils/assert';\nimport {createIterable, getAccessorFromBuffer} from '../../utils/iterable-utils';\nimport {fillArray} from '../../utils/flatten';\nimport * as range from '../../utils/range';\nimport {bufferLayoutEqual} from './gl-utils';\nimport {normalizeTransitionSettings, TransitionSettings} from './transition-settings';\nimport type {Device, Buffer, BufferLayout} from '@luma.gl/core';\n\nimport type {NumericArray, TypedArray} from '../../types/types';\n\nexport type Accessor<DataType, ReturnType> = (\n  object: DataType,\n  context: {\n    data: any;\n    index: number;\n    target: number[];\n  }\n) => ReturnType;\n\nexport type Updater = (\n  attribute: Attribute,\n  {\n    data,\n    startRow,\n    endRow,\n    props,\n    numInstances\n  }: {\n    data: any;\n    startRow: number;\n    endRow: number;\n    props: any;\n    numInstances: number;\n  }\n) => void;\n\nexport type AttributeOptions = DataColumnOptions<{\n  transition?: boolean | Partial<TransitionSettings>;\n  stepMode?: 'vertex' | 'instance' | 'dynamic';\n  noAlloc?: boolean;\n  update?: Updater;\n  accessor?: Accessor<any, any> | string | string[];\n  transform?: (value: any) => any;\n  shaderAttributes?: Record<string, Partial<ShaderAttributeOptions>>;\n}>;\n\nexport type BinaryAttribute = Partial<BufferAccessor> & {value?: TypedArray; buffer?: Buffer};\n\ntype AttributeInternalState = {\n  startIndices: NumericArray | null;\n  /** Legacy: external binary supplied via attribute name */\n  lastExternalBuffer: TypedArray | Buffer | BinaryAttribute | null;\n  /** External binary supplied via accessor name */\n  binaryValue: TypedArray | Buffer | BinaryAttribute | null;\n  binaryAccessor: Accessor<any, any> | null;\n  needsUpdate: string | boolean;\n  needsRedraw: string | boolean;\n  layoutChanged: boolean;\n  updateRanges: number[][];\n};\n\nexport default class Attribute extends DataColumn<AttributeOptions, AttributeInternalState> {\n  /** Legacy approach to set attribute value - read `isConstant` instead for attribute state */\n  constant: boolean = false;\n\n  constructor(device: Device, opts: AttributeOptions) {\n    super(device, opts, {\n      startIndices: null,\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      layoutChanged: false,\n      updateRanges: range.FULL\n    });\n\n    // eslint-disable-next-line\n    this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : undefined);\n\n    Object.seal(this.settings);\n    Object.seal(this.state);\n\n    // Check all fields and generate helpful error messages\n    this._validateAttributeUpdaters();\n  }\n\n  get startIndices(): NumericArray | null {\n    return this.state.startIndices;\n  }\n\n  set startIndices(layout: NumericArray | null) {\n    this.state.startIndices = layout;\n  }\n\n  needsUpdate(): string | boolean {\n    return this.state.needsUpdate;\n  }\n\n  needsRedraw({clearChangedFlags = false}: {clearChangedFlags?: boolean} = {}): string | boolean {\n    const needsRedraw = this.state.needsRedraw;\n    this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n    return needsRedraw;\n  }\n\n  layoutChanged(): boolean {\n    return this.state.layoutChanged;\n  }\n\n  setAccessor(accessor: DataColumnSettings<AttributeOptions>) {\n    this.state.layoutChanged ||= !bufferLayoutEqual(accessor, this.getAccessor());\n    super.setAccessor(accessor);\n  }\n\n  getUpdateTriggers(): string[] {\n    const {accessor} = this.settings;\n\n    // Backards compatibility: allow attribute name to be used as update trigger key\n    return [this.id].concat((typeof accessor !== 'function' && accessor) || []);\n  }\n\n  supportsTransition(): boolean {\n    return Boolean(this.settings.transition);\n  }\n\n  // Resolve transition settings object if transition is enabled, otherwise `null`\n  getTransitionSetting(opts: Record<string, any>): TransitionSettings | null {\n    if (!opts || !this.supportsTransition()) {\n      return null;\n    }\n    const {accessor} = this.settings;\n    // TODO: have the layer resolve these transition settings itself?\n    const layerSettings = this.settings.transition;\n    // these are the transition settings passed in by the user\n    const userSettings = Array.isArray(accessor)\n      ? // @ts-ignore\n        opts[accessor.find(a => opts[a])]\n      : // @ts-ignore\n        opts[accessor];\n\n    // Shorthand: use duration instead of parameter object\n    return normalizeTransitionSettings(userSettings, layerSettings);\n  }\n\n  setNeedsUpdate(reason: string = this.id, dataRange?: {startRow?: number; endRow?: number}): void {\n    this.state.needsUpdate = this.state.needsUpdate || reason;\n    this.setNeedsRedraw(reason);\n    if (dataRange) {\n      const {startRow = 0, endRow = Infinity} = dataRange;\n      this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n    } else {\n      this.state.updateRanges = range.FULL;\n    }\n  }\n\n  clearNeedsUpdate(): void {\n    this.state.needsUpdate = false;\n    this.state.updateRanges = range.EMPTY;\n  }\n\n  setNeedsRedraw(reason: string = this.id): void {\n    this.state.needsRedraw = this.state.needsRedraw || reason;\n  }\n\n  allocate(numInstances: number): boolean {\n    const {state, settings} = this;\n\n    if (settings.noAlloc) {\n      // Data is provided through a Buffer object.\n      return false;\n    }\n\n    if (settings.update) {\n      super.allocate(numInstances, state.updateRanges !== range.FULL);\n      return true;\n    }\n\n    return false;\n  }\n\n  updateBuffer({\n    numInstances,\n    data,\n    props,\n    context\n  }: {\n    numInstances: number;\n    data: any;\n    props: any;\n    context: any;\n  }): boolean {\n    if (!this.needsUpdate()) {\n      return false;\n    }\n\n    const {\n      state: {updateRanges},\n      settings: {update, noAlloc}\n    } = this;\n\n    let updated = true;\n    if (update) {\n      // Custom updater - typically for non-instanced layers\n      for (const [startRow, endRow] of updateRanges) {\n        update.call(context, this, {data, startRow, endRow, props, numInstances});\n      }\n      if (!this.value) {\n        // no value was assigned during update\n      } else if (\n        this.constant ||\n        !this.buffer ||\n        this.buffer.byteLength < (this.value as TypedArray).byteLength + this.byteOffset\n      ) {\n        this.setData({\n          value: this.value,\n          constant: this.constant\n        });\n        // Setting attribute.constant in updater is a legacy approach that interferes with allocation in the next cycle\n        // Respect it here but reset after use\n        this.constant = false;\n      } else {\n        for (const [startRow, endRow] of updateRanges) {\n          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n          const endOffset = Number.isFinite(endRow)\n            ? this.getVertexOffset(endRow)\n            : noAlloc || !Number.isFinite(numInstances)\n              ? this.value.length\n              : numInstances * this.size;\n\n          super.updateSubBuffer({startOffset, endOffset});\n        }\n      }\n      this._checkAttributeArray();\n    } else {\n      updated = false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setNeedsRedraw();\n\n    return updated;\n  }\n\n  // Use generic value\n  // Returns true if successful\n  setConstantValue(value?: NumericArray): boolean {\n    // TODO(ibgreen): WebGPU does not support constant values\n    const isWebGPU = this.device.type === 'webgpu';\n    if (isWebGPU || value === undefined || typeof value === 'function') {\n      return false;\n    }\n\n    const hasChanged = this.setData({constant: true, value});\n\n    if (hasChanged) {\n      this.setNeedsRedraw();\n    }\n    this.clearNeedsUpdate();\n    return true;\n  }\n\n  // Use external buffer\n  // Returns true if successful\n  // eslint-disable-next-line max-statements\n  setExternalBuffer(buffer?: TypedArray | Buffer | BinaryAttribute): boolean {\n    const {state} = this;\n\n    if (!buffer) {\n      state.lastExternalBuffer = null;\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n\n    if (state.lastExternalBuffer === buffer) {\n      return true;\n    }\n    state.lastExternalBuffer = buffer;\n    this.setNeedsRedraw();\n    this.setData(buffer);\n    return true;\n  }\n\n  // Binary value is a typed array packed from mapping the source data with the accessor\n  // If the returned value from the accessor is the same as the attribute value, set it directly\n  // Otherwise use the auto updater for transform/normalization\n  setBinaryValue(\n    buffer?: TypedArray | Buffer | BinaryAttribute,\n    startIndices: NumericArray | null = null\n  ): boolean {\n    const {state, settings} = this;\n\n    if (!buffer) {\n      state.binaryValue = null;\n      state.binaryAccessor = null;\n      return false;\n    }\n\n    if (settings.noAlloc) {\n      // Let the layer handle this\n      return false;\n    }\n\n    if (state.binaryValue === buffer) {\n      this.clearNeedsUpdate();\n      return true;\n    }\n    state.binaryValue = buffer;\n    this.setNeedsRedraw();\n\n    const needsUpdate = settings.transform || startIndices !== this.startIndices;\n\n    if (needsUpdate) {\n      if (ArrayBuffer.isView(buffer)) {\n        buffer = {value: buffer};\n      }\n      const binaryValue = buffer as BinaryAttribute;\n      assert(ArrayBuffer.isView(binaryValue.value), `invalid ${settings.accessor}`);\n      const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;\n\n      state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {\n        size: binaryValue.size || this.size,\n        stride: binaryValue.stride,\n        offset: binaryValue.offset,\n        startIndices: startIndices as NumericArray,\n        nested: needsNormalize\n      });\n      // Fall through to auto updater\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setData(buffer);\n    return true;\n  }\n\n  getVertexOffset(row: number): number {\n    const {startIndices} = this;\n    const vertexIndex = startIndices\n      ? row < startIndices.length\n        ? startIndices[row]\n        : this.numInstances\n      : row;\n    return vertexIndex * this.size;\n  }\n\n  getValue(): Record<string, Buffer | TypedArray | null> {\n    const shaderAttributeDefs = this.settings.shaderAttributes;\n    const result = super.getValue();\n    if (!shaderAttributeDefs) {\n      return result;\n    }\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      Object.assign(\n        result,\n        super.getValue(shaderAttributeName, shaderAttributeDefs[shaderAttributeName])\n      );\n    }\n    return result;\n  }\n\n  /** Generate WebGPU-style buffer layout descriptor from this attribute */\n  getBufferLayout(\n    /** A luma.gl Model-shaped object that supplies additional hint to attribute resolution */\n    modelInfo?: {isInstanced?: boolean}\n  ): BufferLayout {\n    // Clear change flag\n    this.state.layoutChanged = false;\n\n    const shaderAttributeDefs = this.settings.shaderAttributes;\n    const result: BufferLayout = super._getBufferLayout();\n    const {stepMode} = this.settings;\n    if (stepMode === 'dynamic') {\n      // If model info is provided, use isInstanced flag to determine step mode\n      // If no model info is provided, assume it's an instanced model (most common use case)\n      result.stepMode = modelInfo ? (modelInfo.isInstanced ? 'instance' : 'vertex') : 'instance';\n    } else {\n      result.stepMode = stepMode ?? 'vertex';\n    }\n\n    if (!shaderAttributeDefs) {\n      return result;\n    }\n\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      const map = super._getBufferLayout(\n        shaderAttributeName,\n        shaderAttributeDefs[shaderAttributeName]\n      );\n      // @ts-ignore\n      result.attributes.push(...map.attributes);\n    }\n    return result;\n  }\n\n  /* eslint-disable max-depth, max-statements */\n  private _autoUpdater(\n    attribute: Attribute,\n    {\n      data,\n      startRow,\n      endRow,\n      props,\n      numInstances\n    }: {\n      data: any;\n      startRow: number;\n      endRow: number;\n      props: any;\n      numInstances: number;\n    }\n  ): void {\n    if (attribute.constant) {\n      // @ts-ignore TODO(ibgreen) declare context?\n      if (this.context.device.type !== 'webgpu') {\n        return;\n      }\n    }\n    const {settings, state, value, size, startIndices} = attribute;\n\n    const {accessor, transform} = settings;\n    let accessorFunc: Accessor<any, any> =\n      state.binaryAccessor ||\n      // @ts-ignore\n      (typeof accessor === 'function' ? accessor : props[accessor]);\n    // TODO(ibgreen) WebGPU needs buffers, generate an accessor function from a constant\n    if (typeof accessorFunc !== 'function') {\n      accessorFunc = () => accessorFunc;\n    }\n    assert(typeof accessorFunc === 'function', `accessor \"${accessor}\" is not a function`);\n\n    let i = attribute.getVertexOffset(startRow);\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n\n      let objectValue = accessorFunc(object, objectInfo);\n      if (transform) {\n        // transform callbacks could be bound to a particular layer instance.\n        // always point `this` to the current layer.\n        objectValue = transform.call(this, objectValue);\n      }\n\n      if (startIndices) {\n        const numVertices =\n          (objectInfo.index < startIndices.length - 1\n            ? startIndices[objectInfo.index + 1]\n            : numInstances) - startIndices[objectInfo.index];\n        if (objectValue && Array.isArray(objectValue[0])) {\n          let startIndex = i;\n          for (const item of objectValue) {\n            attribute._normalizeValue(item, value as TypedArray, startIndex);\n            startIndex += size;\n          }\n        } else if (objectValue && objectValue.length > size) {\n          (value as TypedArray).set(objectValue, i);\n        } else {\n          attribute._normalizeValue(objectValue, objectInfo.target, 0);\n          fillArray({\n            target: value,\n            source: objectInfo.target,\n            start: i,\n            count: numVertices\n          });\n        }\n        i += numVertices * size;\n      } else {\n        attribute._normalizeValue(objectValue, value as TypedArray, i);\n        i += size;\n      }\n    }\n  }\n  /* eslint-enable max-depth, max-statements */\n\n  // Validate deck.gl level fields\n  private _validateAttributeUpdaters() {\n    const {settings} = this;\n\n    // Check that 'update' is a valid function\n    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n    if (!hasUpdater) {\n      throw new Error(`Attribute ${this.id} missing update or accessor`);\n    }\n  }\n\n  // check that the first few elements of the attribute are reasonable\n  /* eslint-disable no-fallthrough */\n  private _checkAttributeArray() {\n    const {value} = this;\n    const limit = Math.min(4, this.size);\n    if (value && value.length >= limit) {\n      let valid = true;\n      switch (limit) {\n        case 4:\n          valid = valid && Number.isFinite(value[3]);\n        case 3:\n          valid = valid && Number.isFinite(value[2]);\n        case 2:\n          valid = valid && Number.isFinite(value[1]);\n        case 1:\n          valid = valid && Number.isFinite(value[0]);\n          break;\n        default:\n          valid = false;\n      }\n\n      if (!valid) {\n        throw new Error(`Illegal attribute generated for ${this.id}`);\n      }\n    }\n  }\n  /* eslint-enable no-fallthrough */\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}