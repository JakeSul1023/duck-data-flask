{"ast":null,"code":"// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { _deepEqual as deepEqual } from '@deck.gl/core';\nimport { sortBins, packBinIds } from \"./sort-bins.js\";\nimport { aggregate, BUILT_IN_OPERATIONS } from \"./aggregate.js\";\nimport { evaluateVertexAccessor } from \"./vertex-accessor.js\";\n/** An Aggregator implementation that calculates aggregation on the CPU */\nexport class CPUAggregator {\n  constructor(props) {\n    this.bins = [];\n    this.binIds = null;\n    this.results = [];\n    this.dimensions = props.dimensions;\n    this.channelCount = props.getValue.length;\n    this.props = {\n      ...props,\n      binOptions: {},\n      pointCount: 0,\n      operations: [],\n      customOperations: [],\n      attributes: {}\n    };\n    this.needsUpdate = true;\n    this.setProps(props);\n  }\n  destroy() {}\n  get binCount() {\n    return this.bins.length;\n  }\n  /** Update aggregation props */\n  setProps(props) {\n    const oldProps = this.props;\n    if (props.binOptions) {\n      if (!deepEqual(props.binOptions, oldProps.binOptions, 2)) {\n        this.setNeedsUpdate();\n      }\n    }\n    if (props.operations) {\n      for (let channel = 0; channel < this.channelCount; channel++) {\n        if (props.operations[channel] !== oldProps.operations[channel]) {\n          this.setNeedsUpdate(channel);\n        }\n      }\n    }\n    if (props.customOperations) {\n      for (let channel = 0; channel < this.channelCount; channel++) {\n        if (Boolean(props.customOperations[channel]) !== Boolean(oldProps.customOperations[channel])) {\n          this.setNeedsUpdate(channel);\n        }\n      }\n    }\n    if (props.pointCount !== undefined && props.pointCount !== oldProps.pointCount) {\n      this.setNeedsUpdate();\n    }\n    if (props.attributes) {\n      props.attributes = {\n        ...oldProps.attributes,\n        ...props.attributes\n      };\n    }\n    Object.assign(this.props, props);\n  }\n  /** Flags a channel to need update\n   * This is called internally by setProps() if certain props change\n   * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed\n   * the underlying buffers could have been updated and require rerunning the aggregation\n   * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.\n   */\n  setNeedsUpdate(channel) {\n    if (channel === undefined) {\n      this.needsUpdate = true;\n    } else if (this.needsUpdate !== true) {\n      this.needsUpdate = this.needsUpdate || [];\n      this.needsUpdate[channel] = true;\n    }\n  }\n  /** Run aggregation */\n  update() {\n    if (this.needsUpdate === true) {\n      this.bins = sortBins({\n        pointCount: this.props.pointCount,\n        getBinId: evaluateVertexAccessor(this.props.getBin, this.props.attributes, this.props.binOptions)\n      });\n      const value = packBinIds({\n        bins: this.bins,\n        dimensions: this.dimensions,\n        // Reuse allocated typed array\n        target: this.binIds?.value\n      });\n      this.binIds = {\n        value,\n        type: 'float32',\n        size: this.dimensions\n      };\n    }\n    for (let channel = 0; channel < this.channelCount; channel++) {\n      if (this.needsUpdate === true || this.needsUpdate[channel]) {\n        const operation = this.props.customOperations[channel] || BUILT_IN_OPERATIONS[this.props.operations[channel]];\n        const {\n          value,\n          domain\n        } = aggregate({\n          bins: this.bins,\n          getValue: evaluateVertexAccessor(this.props.getValue[channel], this.props.attributes, undefined),\n          operation,\n          // Reuse allocated typed array\n          target: this.results[channel]?.value\n        });\n        this.results[channel] = {\n          value,\n          domain,\n          type: 'float32',\n          size: 1\n        };\n        this.props.onUpdate?.({\n          channel\n        });\n      }\n    }\n    this.needsUpdate = false;\n  }\n  preDraw() {}\n  /** Returns an accessor to the bins. */\n  getBins() {\n    return this.binIds;\n  }\n  /** Returns an accessor to the output for a given channel. */\n  getResult(channel) {\n    return this.results[channel];\n  }\n  /** Returns the [min, max] of aggregated values for a given channel. */\n  getResultDomain(channel) {\n    return this.results[channel]?.domain ?? [Infinity, -Infinity];\n  }\n  /** Returns the information for a given bin. */\n  getBin(index) {\n    const bin = this.bins[index];\n    if (!bin) {\n      return null;\n    }\n    const value = new Array(this.channelCount);\n    for (let i = 0; i < value.length; i++) {\n      const result = this.results[i];\n      value[i] = result?.value[index];\n    }\n    return {\n      id: bin.id,\n      value,\n      count: bin.points.length,\n      pointIndices: bin.points\n    };\n  }\n}","map":{"version":3,"names":["_deepEqual","deepEqual","sortBins","packBinIds","aggregate","BUILT_IN_OPERATIONS","evaluateVertexAccessor","CPUAggregator","constructor","props","bins","binIds","results","dimensions","channelCount","getValue","length","binOptions","pointCount","operations","customOperations","attributes","needsUpdate","setProps","destroy","binCount","oldProps","setNeedsUpdate","channel","Boolean","undefined","Object","assign","update","getBinId","getBin","value","target","type","size","operation","domain","onUpdate","preDraw","getBins","getResult","getResultDomain","Infinity","index","bin","Array","i","result","id","count","points","pointIndices"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@deck.gl\\aggregation-layers\\src\\common\\aggregator\\cpu-aggregator\\cpu-aggregator.ts"],"sourcesContent":["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Aggregator, AggregationProps, AggregatedBin} from '../aggregator';\nimport {_deepEqual as deepEqual, BinaryAttribute} from '@deck.gl/core';\nimport {sortBins, packBinIds} from './sort-bins';\nimport {aggregate, AggregationFunc, BUILT_IN_OPERATIONS} from './aggregate';\nimport {VertexAccessor, evaluateVertexAccessor} from './vertex-accessor';\n\n/** Options used to construct a new CPUAggregator */\nexport type CPUAggregatorProps = {\n  /** Size of bin IDs */\n  dimensions: number;\n  /** Accessor to map each data point to a bin ID.\n   * Bin ID should be an array with [dimensions] elements; or null if the data point should be skipped\n   */\n  getBin: VertexAccessor<number[] | null, any>;\n  /** Accessor to map each data point to a weight value, defined per channel */\n  getValue: VertexAccessor<number>[];\n} & Partial<CPUAggregationProps>;\n\n/** Props used to run CPU aggregation, can be changed at any time */\ntype CPUAggregationProps = AggregationProps & {\n  /** Custom callback to aggregate points, overrides the built-in operations */\n  customOperations: (AggregationFunc | null | undefined)[];\n};\n\nexport type Bin = {\n  id: number[];\n  index: number;\n  /** list of data point indices */\n  points: number[];\n};\n\n/** An Aggregator implementation that calculates aggregation on the CPU */\nexport class CPUAggregator implements Aggregator {\n  readonly dimensions: number;\n  readonly channelCount: number;\n\n  props: CPUAggregatorProps & CPUAggregationProps;\n\n  /** Dirty flag\n   * If true, redo sorting\n   * If array, redo aggregation on the specified channel\n   */\n  protected needsUpdate: boolean[] | boolean;\n\n  protected bins: Bin[] = [];\n  protected binIds: (BinaryAttribute & {value: Float32Array}) | null = null;\n  protected results: (BinaryAttribute & {\n    value: Float32Array;\n    domain: [min: number, max: number];\n  })[] = [];\n\n  constructor(props: CPUAggregatorProps) {\n    this.dimensions = props.dimensions;\n    this.channelCount = props.getValue.length;\n    this.props = {\n      ...props,\n      binOptions: {},\n      pointCount: 0,\n      operations: [],\n      customOperations: [],\n      attributes: {}\n    };\n    this.needsUpdate = true;\n    this.setProps(props);\n  }\n\n  destroy() {}\n\n  get binCount() {\n    return this.bins.length;\n  }\n\n  /** Update aggregation props */\n  setProps(props: Partial<CPUAggregationProps>) {\n    const oldProps = this.props;\n\n    if (props.binOptions) {\n      if (!deepEqual(props.binOptions, oldProps.binOptions, 2)) {\n        this.setNeedsUpdate();\n      }\n    }\n    if (props.operations) {\n      for (let channel = 0; channel < this.channelCount; channel++) {\n        if (props.operations[channel] !== oldProps.operations[channel]) {\n          this.setNeedsUpdate(channel);\n        }\n      }\n    }\n    if (props.customOperations) {\n      for (let channel = 0; channel < this.channelCount; channel++) {\n        if (\n          Boolean(props.customOperations[channel]) !== Boolean(oldProps.customOperations[channel])\n        ) {\n          this.setNeedsUpdate(channel);\n        }\n      }\n    }\n    if (props.pointCount !== undefined && props.pointCount !== oldProps.pointCount) {\n      this.setNeedsUpdate();\n    }\n    if (props.attributes) {\n      props.attributes = {...oldProps.attributes, ...props.attributes};\n    }\n    Object.assign(this.props, props);\n  }\n\n  /** Flags a channel to need update\n   * This is called internally by setProps() if certain props change\n   * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed\n   * the underlying buffers could have been updated and require rerunning the aggregation\n   * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.\n   */\n  setNeedsUpdate(channel?: number): void {\n    if (channel === undefined) {\n      this.needsUpdate = true;\n    } else if (this.needsUpdate !== true) {\n      this.needsUpdate = this.needsUpdate || [];\n      this.needsUpdate[channel] = true;\n    }\n  }\n\n  /** Run aggregation */\n  update() {\n    if (this.needsUpdate === true) {\n      this.bins = sortBins({\n        pointCount: this.props.pointCount,\n        getBinId: evaluateVertexAccessor(\n          this.props.getBin,\n          this.props.attributes,\n          this.props.binOptions\n        )\n      });\n      const value = packBinIds({\n        bins: this.bins,\n        dimensions: this.dimensions,\n        // Reuse allocated typed array\n        target: this.binIds?.value\n      });\n      this.binIds = {value, type: 'float32', size: this.dimensions};\n    }\n    for (let channel = 0; channel < this.channelCount; channel++) {\n      if (this.needsUpdate === true || this.needsUpdate[channel]) {\n        const operation =\n          this.props.customOperations[channel] ||\n          BUILT_IN_OPERATIONS[this.props.operations[channel]];\n        const {value, domain} = aggregate({\n          bins: this.bins,\n          getValue: evaluateVertexAccessor(\n            this.props.getValue[channel],\n            this.props.attributes,\n            undefined\n          ),\n          operation,\n          // Reuse allocated typed array\n          target: this.results[channel]?.value\n        });\n        this.results[channel] = {value, domain, type: 'float32', size: 1};\n        this.props.onUpdate?.({channel});\n      }\n    }\n    this.needsUpdate = false;\n  }\n\n  preDraw() {}\n\n  /** Returns an accessor to the bins. */\n  getBins(): BinaryAttribute | null {\n    return this.binIds;\n  }\n\n  /** Returns an accessor to the output for a given channel. */\n  getResult(channel: number): BinaryAttribute | null {\n    return this.results[channel];\n  }\n\n  /** Returns the [min, max] of aggregated values for a given channel. */\n  getResultDomain(channel: number): [min: number, max: number] {\n    return this.results[channel]?.domain ?? [Infinity, -Infinity];\n  }\n\n  /** Returns the information for a given bin. */\n  getBin(index: number): AggregatedBin | null {\n    const bin = this.bins[index];\n    if (!bin) {\n      return null;\n    }\n    const value = new Array(this.channelCount);\n    for (let i = 0; i < value.length; i++) {\n      const result = this.results[i];\n      value[i] = result?.value[index];\n    }\n    return {\n      id: bin.id,\n      value,\n      count: bin.points.length,\n      pointIndices: bin.points\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}