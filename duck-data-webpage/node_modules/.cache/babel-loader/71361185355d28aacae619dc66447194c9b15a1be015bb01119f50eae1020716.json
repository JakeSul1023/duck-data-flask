{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isLoaderObject } from \"../loader-utils/normalize-loader.js\";\nimport { getFetchFunction } from \"../loader-utils/get-fetch-function.js\";\nimport { parseInBatches } from \"./parse-in-batches.js\";\nexport function loadInBatches(files, loaders, options, context) {\n  let loadersArray;\n  // Signature: load(url, options)\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = undefined; // context not supported in short signature\n    options = loaders;\n    loadersArray = undefined;\n  } else {\n    loadersArray = loaders;\n  }\n  // Select fetch function\n  const fetch = getFetchFunction(options || {});\n  // Single url/file\n  if (!Array.isArray(files)) {\n    return loadOneFileInBatches(files, loadersArray, options || {}, fetch);\n  }\n  // Multiple URLs / files\n  const promises = files.map(file => loadOneFileInBatches(file, loadersArray, options || {}, fetch));\n  // No point in waiting here for all responses before starting to stream individual streams?\n  return promises;\n}\nasync function loadOneFileInBatches(file, loaders, options, fetch) {\n  if (typeof file === 'string') {\n    const url = file;\n    const response = await fetch(url);\n    // pick right overload\n    return Array.isArray(loaders) ? await parseInBatches(response, loaders, options) : await parseInBatches(response, loaders, options);\n  }\n  // pick right overload\n  return Array.isArray(loaders) ? await parseInBatches(file, loaders, options) : await parseInBatches(file, loaders, options);\n}","map":{"version":3,"names":["isLoaderObject","getFetchFunction","parseInBatches","loadInBatches","files","loaders","options","context","loadersArray","Array","isArray","undefined","fetch","loadOneFileInBatches","promises","map","file","url","response"],"sources":["C:/Users/jakes/Documents/GitHub/duck-data-flask/duck-data-webpage/node_modules/@loaders.gl/core/dist/lib/api/load-in-batches.js"],"sourcesContent":["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isLoaderObject } from \"../loader-utils/normalize-loader.js\";\nimport { getFetchFunction } from \"../loader-utils/get-fetch-function.js\";\nimport { parseInBatches } from \"./parse-in-batches.js\";\nexport function loadInBatches(files, loaders, options, context) {\n    let loadersArray;\n    // Signature: load(url, options)\n    if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n        context = undefined; // context not supported in short signature\n        options = loaders;\n        loadersArray = undefined;\n    }\n    else {\n        loadersArray = loaders;\n    }\n    // Select fetch function\n    const fetch = getFetchFunction(options || {});\n    // Single url/file\n    if (!Array.isArray(files)) {\n        return loadOneFileInBatches(files, loadersArray, options || {}, fetch);\n    }\n    // Multiple URLs / files\n    const promises = files.map((file) => loadOneFileInBatches(file, loadersArray, options || {}, fetch));\n    // No point in waiting here for all responses before starting to stream individual streams?\n    return promises;\n}\nasync function loadOneFileInBatches(file, loaders, options, fetch) {\n    if (typeof file === 'string') {\n        const url = file;\n        const response = await fetch(url);\n        // pick right overload\n        return Array.isArray(loaders)\n            ? await parseInBatches(response, loaders, options)\n            : await parseInBatches(response, loaders, options);\n    }\n    // pick right overload\n    return Array.isArray(loaders)\n        ? await parseInBatches(file, loaders, options)\n        : await parseInBatches(file, loaders, options);\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,cAAc,QAAQ,qCAAqC;AACpE,SAASC,gBAAgB,QAAQ,uCAAuC;AACxE,SAASC,cAAc,QAAQ,uBAAuB;AACtD,OAAO,SAASC,aAAaA,CAACC,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,OAAO,EAAE;EAC5D,IAAIC,YAAY;EAChB;EACA,IAAI,CAACC,KAAK,CAACC,OAAO,CAACL,OAAO,CAAC,IAAI,CAACL,cAAc,CAACK,OAAO,CAAC,EAAE;IACrDE,OAAO,GAAGI,SAAS,CAAC,CAAC;IACrBL,OAAO,GAAGD,OAAO;IACjBG,YAAY,GAAGG,SAAS;EAC5B,CAAC,MACI;IACDH,YAAY,GAAGH,OAAO;EAC1B;EACA;EACA,MAAMO,KAAK,GAAGX,gBAAgB,CAACK,OAAO,IAAI,CAAC,CAAC,CAAC;EAC7C;EACA,IAAI,CAACG,KAAK,CAACC,OAAO,CAACN,KAAK,CAAC,EAAE;IACvB,OAAOS,oBAAoB,CAACT,KAAK,EAAEI,YAAY,EAAEF,OAAO,IAAI,CAAC,CAAC,EAAEM,KAAK,CAAC;EAC1E;EACA;EACA,MAAME,QAAQ,GAAGV,KAAK,CAACW,GAAG,CAAEC,IAAI,IAAKH,oBAAoB,CAACG,IAAI,EAAER,YAAY,EAAEF,OAAO,IAAI,CAAC,CAAC,EAAEM,KAAK,CAAC,CAAC;EACpG;EACA,OAAOE,QAAQ;AACnB;AACA,eAAeD,oBAAoBA,CAACG,IAAI,EAAEX,OAAO,EAAEC,OAAO,EAAEM,KAAK,EAAE;EAC/D,IAAI,OAAOI,IAAI,KAAK,QAAQ,EAAE;IAC1B,MAAMC,GAAG,GAAGD,IAAI;IAChB,MAAME,QAAQ,GAAG,MAAMN,KAAK,CAACK,GAAG,CAAC;IACjC;IACA,OAAOR,KAAK,CAACC,OAAO,CAACL,OAAO,CAAC,GACvB,MAAMH,cAAc,CAACgB,QAAQ,EAAEb,OAAO,EAAEC,OAAO,CAAC,GAChD,MAAMJ,cAAc,CAACgB,QAAQ,EAAEb,OAAO,EAAEC,OAAO,CAAC;EAC1D;EACA;EACA,OAAOG,KAAK,CAACC,OAAO,CAACL,OAAO,CAAC,GACvB,MAAMH,cAAc,CAACc,IAAI,EAAEX,OAAO,EAAEC,OAAO,CAAC,GAC5C,MAAMJ,cAAc,CAACc,IAAI,EAAEX,OAAO,EAAEC,OAAO,CAAC;AACtD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}