{"ast":null,"code":"// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@luma.gl/core';\nimport { Matrix4, Quaternion } from '@math.gl/core';\n// TODO: import from loaders.gl?\nexport const ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nclass GLTFAnimation {\n  name;\n  startTime = 0;\n  playing = true;\n  speed = 1;\n  channels = [];\n  constructor(props) {\n    Object.assign(this, props);\n  }\n  animate(timeMs) {\n    if (!this.playing) {\n      return;\n    }\n    const absTime = timeMs / 1000;\n    const time = (absTime - this.startTime) * this.speed;\n    this.channels.forEach(({\n      sampler,\n      target,\n      path\n    }) => {\n      interpolate(time, sampler, target, path);\n      applyTranslationRotationScale(target, target._node);\n    });\n  }\n}\nexport class GLTFAnimator {\n  animations;\n  constructor(gltf) {\n    this.animations = gltf.animations.map((animation, index) => {\n      const name = animation.name || `Animation-${index}`;\n      const samplers = animation.samplers.map(({\n        input,\n        interpolation = 'LINEAR',\n        output\n      }) => ({\n        input: accessorToJsArray(gltf.accessors[input]),\n        interpolation,\n        output: accessorToJsArray(gltf.accessors[output])\n      }));\n      const channels = animation.channels.map(({\n        sampler,\n        target\n      }) => ({\n        sampler: samplers[sampler],\n        target: gltf.nodes[target.node],\n        path: target.path\n      }));\n      return new GLTFAnimation({\n        name,\n        channels\n      });\n    });\n  }\n  /** @deprecated Use .setTime(). Will be removed (deck.gl is using this) */\n  animate(time) {\n    this.setTime(time);\n  }\n  setTime(time) {\n    this.animations.forEach(animation => animation.animate(time));\n  }\n  getAnimations() {\n    return this.animations;\n  }\n}\n//\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    const length = components * accessor.count;\n    const {\n      buffer,\n      byteOffset\n    } = accessor.bufferView.data;\n    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      // Slice array\n      const slicedArray = [];\n      for (let i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n      accessor._animation = slicedArray;\n    }\n  }\n  return accessor._animation;\n}\n// TODO: share with GLTFInstantiator\nconst helperMatrix = new Matrix4();\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n  if (gltfNode.rotation) {\n    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\nconst quaternion = new Quaternion();\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    // SLERP when path is rotation\n    quaternion.slerp({\n      start,\n      target: stop,\n      ratio\n    });\n    for (let i = 0; i < quaternion.length; i++) {\n      target[path][i] = quaternion[i];\n    }\n  } else {\n    // regular interpolation\n    for (let i = 0; i < start.length; i++) {\n      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];\n    }\n  }\n}\nfunction cubicsplineInterpolate(target, path, {\n  p0,\n  outTangent0,\n  inTangent1,\n  p1,\n  tDiff,\n  ratio: t\n}) {\n  // TODO: Quaternion might need normalization\n  for (let i = 0; i < target[path].length; i++) {\n    const m0 = outTangent0[i] * tDiff;\n    const m1 = inTangent1[i] * tDiff;\n    target[path][i] = (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] + (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 + (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] + (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\nfunction stepInterpolate(target, path, value) {\n  for (let i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\nfunction interpolate(time, {\n  input,\n  interpolation,\n  output\n}, target, path) {\n  const maxTime = input[input.length - 1];\n  const animationTime = time % maxTime;\n  const nextIndex = input.findIndex(t => t >= animationTime);\n  const previousIndex = Math.max(0, nextIndex - 1);\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n      default:\n        log.warn(`Bad animation path ${path}`)();\n    }\n  }\n  // assert(target[path].length === output[previousIndex].length);\n  const previousTime = input[previousIndex];\n  const nextTime = input[nextIndex];\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n      break;\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        const tDiff = nextTime - previousTime;\n        const p0 = output[3 * previousIndex + 1];\n        const outTangent0 = output[3 * previousIndex + 2];\n        const inTangent1 = output[3 * nextIndex + 0];\n        const p1 = output[3 * nextIndex + 1];\n        cubicsplineInterpolate(target, path, {\n          p0,\n          outTangent0,\n          inTangent1,\n          p1,\n          tDiff,\n          ratio\n        });\n      }\n      break;\n    default:\n      log.warn(`Interpolation ${interpolation} not supported`)();\n      break;\n  }\n}","map":{"version":3,"names":["log","Matrix4","Quaternion","ATTRIBUTE_TYPE_TO_COMPONENTS","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY","Int8Array","Uint8Array","Int16Array","Uint16Array","Uint32Array","Float32Array","GLTFAnimation","name","startTime","playing","speed","channels","constructor","props","Object","assign","animate","timeMs","absTime","time","forEach","sampler","target","path","interpolate","applyTranslationRotationScale","_node","GLTFAnimator","animations","gltf","map","animation","index","samplers","input","interpolation","output","accessorToJsArray","accessors","nodes","node","setTime","getAnimations","accessor","_animation","ArrayType","componentType","components","type","length","count","buffer","byteOffset","bufferView","data","array","Array","from","slicedArray","i","push","slice","helperMatrix","gltfNode","matrix","identity","translation","translate","rotation","rotationMatrix","fromQuaternion","multiplyRight","scale","quaternion","linearInterpolate","start","stop","ratio","slerp","cubicsplineInterpolate","p0","outTangent0","inTangent1","p1","tDiff","t","m0","m1","Math","pow","stepInterpolate","value","maxTime","animationTime","nextIndex","findIndex","previousIndex","max","isArray","warn","previousTime","nextTime"],"sources":["C:\\Users\\jakes\\Documents\\GitHub\\duck-data-flask\\duck-data-webpage\\node_modules\\@luma.gl\\gltf\\src\\gltf\\gltf-animator.ts"],"sourcesContent":["// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {log} from '@luma.gl/core';\nimport {Matrix4, Quaternion} from '@math.gl/core';\n\n// TODO: import from loaders.gl?\nexport const ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\ntype GLTFAnimationProps = {\n  name: string;\n  startTime?: number;\n  playing?: boolean;\n  speed?: number;\n  channels?: any;\n};\n\nclass GLTFAnimation {\n  name: string;\n  startTime: number = 0;\n  playing: boolean = true;\n  speed: number = 1;\n  channels: any = [];\n\n  constructor(props: GLTFAnimationProps) {\n    Object.assign(this, props);\n  }\n\n  animate(timeMs: number) {\n    if (!this.playing) {\n      return;\n    }\n\n    const absTime = timeMs / 1000;\n    const time = (absTime - this.startTime) * this.speed;\n\n    this.channels.forEach(({sampler, target, path}) => {\n      interpolate(time, sampler, target, path);\n      applyTranslationRotationScale(target, target._node);\n    });\n  }\n}\n\nexport class GLTFAnimator {\n  animations: GLTFAnimation[];\n\n  constructor(gltf: any) {\n    this.animations = gltf.animations.map((animation, index) => {\n      const name = animation.name || `Animation-${index}`;\n      const samplers = animation.samplers.map(({input, interpolation = 'LINEAR', output}) => ({\n        input: accessorToJsArray(gltf.accessors[input]),\n        interpolation,\n        output: accessorToJsArray(gltf.accessors[output])\n      }));\n      const channels = animation.channels.map(({sampler, target}) => ({\n        sampler: samplers[sampler],\n        target: gltf.nodes[target.node],\n        path: target.path\n      }));\n      return new GLTFAnimation({name, channels});\n    });\n  }\n\n  /** @deprecated Use .setTime(). Will be removed (deck.gl is using this) */\n  animate(time: number): void {\n    this.setTime(time);\n  }\n\n  setTime(time: number): void {\n    this.animations.forEach(animation => animation.animate(time));\n  }\n\n  getAnimations() {\n    return this.animations;\n  }\n}\n\n//\n\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    const length = components * accessor.count;\n    const {buffer, byteOffset} = accessor.bufferView.data;\n\n    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      // Slice array\n      const slicedArray = [];\n      for (let i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n      accessor._animation = slicedArray;\n    }\n  }\n\n  return accessor._animation;\n}\n\n// TODO: share with GLTFInstantiator\nconst helperMatrix = new Matrix4();\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n\n  if (gltfNode.rotation) {\n    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\n\nconst quaternion = new Quaternion();\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    // SLERP when path is rotation\n    quaternion.slerp({start, target: stop, ratio});\n    for (let i = 0; i < quaternion.length; i++) {\n      target[path][i] = quaternion[i];\n    }\n  } else {\n    // regular interpolation\n    for (let i = 0; i < start.length; i++) {\n      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];\n    }\n  }\n}\n\nfunction cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio: t}) {\n  // TODO: Quaternion might need normalization\n  for (let i = 0; i < target[path].length; i++) {\n    const m0 = outTangent0[i] * tDiff;\n    const m1 = inTangent1[i] * tDiff;\n    target[path][i] =\n      (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] +\n      (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 +\n      (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] +\n      (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\n\nfunction stepInterpolate(target, path, value) {\n  for (let i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\n\nfunction interpolate(time, {input, interpolation, output}, target, path) {\n  const maxTime = input[input.length - 1];\n  const animationTime = time % maxTime;\n\n  const nextIndex = input.findIndex(t => t >= animationTime);\n  const previousIndex = Math.max(0, nextIndex - 1);\n\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n\n      default:\n        log.warn(`Bad animation path ${path}`)();\n    }\n  }\n\n  // assert(target[path].length === output[previousIndex].length);\n  const previousTime = input[previousIndex];\n  const nextTime = input[nextIndex];\n\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n      break;\n\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        const tDiff = nextTime - previousTime;\n\n        const p0 = output[3 * previousIndex + 1];\n        const outTangent0 = output[3 * previousIndex + 2];\n        const inTangent1 = output[3 * nextIndex + 0];\n        const p1 = output[3 * nextIndex + 1];\n\n        cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio});\n      }\n      break;\n\n    default:\n      log.warn(`Interpolation ${interpolation} not supported`)();\n      break;\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AAEA,SAAQA,GAAG,QAAO,eAAe;AACjC,SAAQC,OAAO,EAAEC,UAAU,QAAO,eAAe;AAEjD;AACA,OAAO,MAAMC,4BAA4B,GAAG;EAC1CC,MAAM,EAAE,CAAC;EACTC,IAAI,EAAE,CAAC;EACPC,IAAI,EAAE,CAAC;EACPC,IAAI,EAAE,CAAC;EACPC,IAAI,EAAE,CAAC;EACPC,IAAI,EAAE,CAAC;EACPC,IAAI,EAAE;CACP;AAED,OAAO,MAAMC,iCAAiC,GAAG;EAC/C,IAAI,EAAEC,SAAS;EACf,IAAI,EAAEC,UAAU;EAChB,IAAI,EAAEC,UAAU;EAChB,IAAI,EAAEC,WAAW;EACjB,IAAI,EAAEC,WAAW;EACjB,IAAI,EAAEC;CACP;AAUD,MAAMC,aAAa;EACjBC,IAAI;EACJC,SAAS,GAAW,CAAC;EACrBC,OAAO,GAAY,IAAI;EACvBC,KAAK,GAAW,CAAC;EACjBC,QAAQ,GAAQ,EAAE;EAElBC,YAAYC,KAAyB;IACnCC,MAAM,CAACC,MAAM,CAAC,IAAI,EAAEF,KAAK,CAAC;EAC5B;EAEAG,OAAOA,CAACC,MAAc;IACpB,IAAI,CAAC,IAAI,CAACR,OAAO,EAAE;MACjB;IACF;IAEA,MAAMS,OAAO,GAAGD,MAAM,GAAG,IAAI;IAC7B,MAAME,IAAI,GAAG,CAACD,OAAO,GAAG,IAAI,CAACV,SAAS,IAAI,IAAI,CAACE,KAAK;IAEpD,IAAI,CAACC,QAAQ,CAACS,OAAO,CAAC,CAAC;MAACC,OAAO;MAAEC,MAAM;MAAEC;IAAI,CAAC,KAAI;MAChDC,WAAW,CAACL,IAAI,EAAEE,OAAO,EAAEC,MAAM,EAAEC,IAAI,CAAC;MACxCE,6BAA6B,CAACH,MAAM,EAAEA,MAAM,CAACI,KAAK,CAAC;IACrD,CAAC,CAAC;EACJ;;AAGF,OAAM,MAAOC,YAAY;EACvBC,UAAU;EAEVhB,YAAYiB,IAAS;IACnB,IAAI,CAACD,UAAU,GAAGC,IAAI,CAACD,UAAU,CAACE,GAAG,CAAC,CAACC,SAAS,EAAEC,KAAK,KAAI;MACzD,MAAMzB,IAAI,GAAGwB,SAAS,CAACxB,IAAI,IAAI,aAAayB,KAAK,EAAE;MACnD,MAAMC,QAAQ,GAAGF,SAAS,CAACE,QAAQ,CAACH,GAAG,CAAC,CAAC;QAACI,KAAK;QAAEC,aAAa,GAAG,QAAQ;QAAEC;MAAM,CAAC,MAAM;QACtFF,KAAK,EAAEG,iBAAiB,CAACR,IAAI,CAACS,SAAS,CAACJ,KAAK,CAAC,CAAC;QAC/CC,aAAa;QACbC,MAAM,EAAEC,iBAAiB,CAACR,IAAI,CAACS,SAAS,CAACF,MAAM,CAAC;OACjD,CAAC,CAAC;MACH,MAAMzB,QAAQ,GAAGoB,SAAS,CAACpB,QAAQ,CAACmB,GAAG,CAAC,CAAC;QAACT,OAAO;QAAEC;MAAM,CAAC,MAAM;QAC9DD,OAAO,EAAEY,QAAQ,CAACZ,OAAO,CAAC;QAC1BC,MAAM,EAAEO,IAAI,CAACU,KAAK,CAACjB,MAAM,CAACkB,IAAI,CAAC;QAC/BjB,IAAI,EAAED,MAAM,CAACC;OACd,CAAC,CAAC;MACH,OAAO,IAAIjB,aAAa,CAAC;QAACC,IAAI;QAAEI;MAAQ,CAAC,CAAC;IAC5C,CAAC,CAAC;EACJ;EAEA;EACAK,OAAOA,CAACG,IAAY;IAClB,IAAI,CAACsB,OAAO,CAACtB,IAAI,CAAC;EACpB;EAEAsB,OAAOA,CAACtB,IAAY;IAClB,IAAI,CAACS,UAAU,CAACR,OAAO,CAACW,SAAS,IAAIA,SAAS,CAACf,OAAO,CAACG,IAAI,CAAC,CAAC;EAC/D;EAEAuB,aAAaA,CAAA;IACX,OAAO,IAAI,CAACd,UAAU;EACxB;;AAGF;AAEA,SAASS,iBAAiBA,CAACM,QAAQ;EACjC,IAAI,CAACA,QAAQ,CAACC,UAAU,EAAE;IACxB,MAAMC,SAAS,GAAG9C,iCAAiC,CAAC4C,QAAQ,CAACG,aAAa,CAAC;IAC3E,MAAMC,UAAU,GAAGxD,4BAA4B,CAACoD,QAAQ,CAACK,IAAI,CAAC;IAC9D,MAAMC,MAAM,GAAGF,UAAU,GAAGJ,QAAQ,CAACO,KAAK;IAC1C,MAAM;MAACC,MAAM;MAAEC;IAAU,CAAC,GAAGT,QAAQ,CAACU,UAAU,CAACC,IAAI;IAErD,MAAMC,KAAK,GAAG,IAAIV,SAAS,CAACM,MAAM,EAAEC,UAAU,IAAIT,QAAQ,CAACS,UAAU,IAAI,CAAC,CAAC,EAAEH,MAAM,CAAC;IAEpF,IAAIF,UAAU,KAAK,CAAC,EAAE;MACpBJ,QAAQ,CAACC,UAAU,GAAGY,KAAK,CAACC,IAAI,CAACF,KAAK,CAAC;IACzC,CAAC,MAAM;MACL;MACA,MAAMG,WAAW,GAAG,EAAE;MACtB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,CAACN,MAAM,EAAEU,CAAC,IAAIZ,UAAU,EAAE;QACjDW,WAAW,CAACE,IAAI,CAACJ,KAAK,CAACC,IAAI,CAACF,KAAK,CAACM,KAAK,CAACF,CAAC,EAAEA,CAAC,GAAGZ,UAAU,CAAC,CAAC,CAAC;MAC9D;MACAJ,QAAQ,CAACC,UAAU,GAAGc,WAAW;IACnC;EACF;EAEA,OAAOf,QAAQ,CAACC,UAAU;AAC5B;AAEA;AACA,MAAMkB,YAAY,GAAG,IAAIzE,OAAO,EAAE;AAClC,SAASoC,6BAA6BA,CAACsC,QAAQ,EAAEvB,IAAI;EACnDA,IAAI,CAACwB,MAAM,CAACC,QAAQ,EAAE;EAEtB,IAAIF,QAAQ,CAACG,WAAW,EAAE;IACxB1B,IAAI,CAACwB,MAAM,CAACG,SAAS,CAACJ,QAAQ,CAACG,WAAW,CAAC;EAC7C;EAEA,IAAIH,QAAQ,CAACK,QAAQ,EAAE;IACrB,MAAMC,cAAc,GAAGP,YAAY,CAACQ,cAAc,CAACP,QAAQ,CAACK,QAAQ,CAAC;IACrE5B,IAAI,CAACwB,MAAM,CAACO,aAAa,CAACF,cAAc,CAAC;EAC3C;EAEA,IAAIN,QAAQ,CAACS,KAAK,EAAE;IAClBhC,IAAI,CAACwB,MAAM,CAACQ,KAAK,CAACT,QAAQ,CAACS,KAAK,CAAC;EACnC;AACF;AAEA,MAAMC,UAAU,GAAG,IAAInF,UAAU,EAAE;AACnC,SAASoF,iBAAiBA,CAACpD,MAAM,EAAEC,IAAI,EAAEoD,KAAK,EAAEC,IAAI,EAAEC,KAAK;EACzD,IAAItD,IAAI,KAAK,UAAU,EAAE;IACvB;IACAkD,UAAU,CAACK,KAAK,CAAC;MAACH,KAAK;MAAErD,MAAM,EAAEsD,IAAI;MAAEC;IAAK,CAAC,CAAC;IAC9C,KAAK,IAAIlB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGc,UAAU,CAACxB,MAAM,EAAEU,CAAC,EAAE,EAAE;MAC1CrC,MAAM,CAACC,IAAI,CAAC,CAACoC,CAAC,CAAC,GAAGc,UAAU,CAACd,CAAC,CAAC;IACjC;EACF,CAAC,MAAM;IACL;IACA,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgB,KAAK,CAAC1B,MAAM,EAAEU,CAAC,EAAE,EAAE;MACrCrC,MAAM,CAACC,IAAI,CAAC,CAACoC,CAAC,CAAC,GAAGkB,KAAK,GAAGD,IAAI,CAACjB,CAAC,CAAC,GAAG,CAAC,CAAC,GAAGkB,KAAK,IAAIF,KAAK,CAAChB,CAAC,CAAC;IAC5D;EACF;AACF;AAEA,SAASoB,sBAAsBA,CAACzD,MAAM,EAAEC,IAAI,EAAE;EAACyD,EAAE;EAAEC,WAAW;EAAEC,UAAU;EAAEC,EAAE;EAAEC,KAAK;EAAEP,KAAK,EAAEQ;AAAC,CAAC;EAC9F;EACA,KAAK,IAAI1B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrC,MAAM,CAACC,IAAI,CAAC,CAAC0B,MAAM,EAAEU,CAAC,EAAE,EAAE;IAC5C,MAAM2B,EAAE,GAAGL,WAAW,CAACtB,CAAC,CAAC,GAAGyB,KAAK;IACjC,MAAMG,EAAE,GAAGL,UAAU,CAACvB,CAAC,CAAC,GAAGyB,KAAK;IAChC9D,MAAM,CAACC,IAAI,CAAC,CAACoC,CAAC,CAAC,GACb,CAAC,CAAC,GAAG6B,IAAI,CAACC,GAAG,CAACJ,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,GAAGG,IAAI,CAACC,GAAG,CAACJ,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,IAAIL,EAAE,CAACrB,CAAC,CAAC,GACrD,CAAC6B,IAAI,CAACC,GAAG,CAACJ,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,GAAGG,IAAI,CAACC,GAAG,CAACJ,CAAC,EAAE,CAAC,CAAC,GAAGA,CAAC,IAAIC,EAAE,GAC9C,CAAC,CAAC,CAAC,GAAGE,IAAI,CAACC,GAAG,CAACJ,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,GAAGG,IAAI,CAACC,GAAG,CAACJ,CAAC,EAAE,CAAC,CAAC,IAAIF,EAAE,CAACxB,CAAC,CAAC,GAClD,CAAC6B,IAAI,CAACC,GAAG,CAACJ,CAAC,EAAE,CAAC,CAAC,GAAGG,IAAI,CAACC,GAAG,CAACJ,CAAC,EAAE,CAAC,CAAC,IAAIE,EAAE;EAC1C;AACF;AAEA,SAASG,eAAeA,CAACpE,MAAM,EAAEC,IAAI,EAAEoE,KAAK;EAC1C,KAAK,IAAIhC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgC,KAAK,CAAC1C,MAAM,EAAEU,CAAC,EAAE,EAAE;IACrCrC,MAAM,CAACC,IAAI,CAAC,CAACoC,CAAC,CAAC,GAAGgC,KAAK,CAAChC,CAAC,CAAC;EAC5B;AACF;AAEA,SAASnC,WAAWA,CAACL,IAAI,EAAE;EAACe,KAAK;EAAEC,aAAa;EAAEC;AAAM,CAAC,EAAEd,MAAM,EAAEC,IAAI;EACrE,MAAMqE,OAAO,GAAG1D,KAAK,CAACA,KAAK,CAACe,MAAM,GAAG,CAAC,CAAC;EACvC,MAAM4C,aAAa,GAAG1E,IAAI,GAAGyE,OAAO;EAEpC,MAAME,SAAS,GAAG5D,KAAK,CAAC6D,SAAS,CAACV,CAAC,IAAIA,CAAC,IAAIQ,aAAa,CAAC;EAC1D,MAAMG,aAAa,GAAGR,IAAI,CAACS,GAAG,CAAC,CAAC,EAAEH,SAAS,GAAG,CAAC,CAAC;EAEhD,IAAI,CAACtC,KAAK,CAAC0C,OAAO,CAAC5E,MAAM,CAACC,IAAI,CAAC,CAAC,EAAE;IAChC,QAAQA,IAAI;MACV,KAAK,aAAa;QAChBD,MAAM,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACxB;MAEF,KAAK,UAAU;QACbD,MAAM,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QAC3B;MAEF,KAAK,OAAO;QACVD,MAAM,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACxB;MAEF;QACEnC,GAAG,CAAC+G,IAAI,CAAC,sBAAsB5E,IAAI,EAAE,CAAC,EAAE;IAC5C;EACF;EAEA;EACA,MAAM6E,YAAY,GAAGlE,KAAK,CAAC8D,aAAa,CAAC;EACzC,MAAMK,QAAQ,GAAGnE,KAAK,CAAC4D,SAAS,CAAC;EAEjC,QAAQ3D,aAAa;IACnB,KAAK,MAAM;MACTuD,eAAe,CAACpE,MAAM,EAAEC,IAAI,EAAEa,MAAM,CAAC4D,aAAa,CAAC,CAAC;MACpD;IAEF,KAAK,QAAQ;MACX,IAAIK,QAAQ,GAAGD,YAAY,EAAE;QAC3B,MAAMvB,KAAK,GAAG,CAACgB,aAAa,GAAGO,YAAY,KAAKC,QAAQ,GAAGD,YAAY,CAAC;QACxE1B,iBAAiB,CAACpD,MAAM,EAAEC,IAAI,EAAEa,MAAM,CAAC4D,aAAa,CAAC,EAAE5D,MAAM,CAAC0D,SAAS,CAAC,EAAEjB,KAAK,CAAC;MAClF;MACA;IAEF,KAAK,aAAa;MAChB,IAAIwB,QAAQ,GAAGD,YAAY,EAAE;QAC3B,MAAMvB,KAAK,GAAG,CAACgB,aAAa,GAAGO,YAAY,KAAKC,QAAQ,GAAGD,YAAY,CAAC;QACxE,MAAMhB,KAAK,GAAGiB,QAAQ,GAAGD,YAAY;QAErC,MAAMpB,EAAE,GAAG5C,MAAM,CAAC,CAAC,GAAG4D,aAAa,GAAG,CAAC,CAAC;QACxC,MAAMf,WAAW,GAAG7C,MAAM,CAAC,CAAC,GAAG4D,aAAa,GAAG,CAAC,CAAC;QACjD,MAAMd,UAAU,GAAG9C,MAAM,CAAC,CAAC,GAAG0D,SAAS,GAAG,CAAC,CAAC;QAC5C,MAAMX,EAAE,GAAG/C,MAAM,CAAC,CAAC,GAAG0D,SAAS,GAAG,CAAC,CAAC;QAEpCf,sBAAsB,CAACzD,MAAM,EAAEC,IAAI,EAAE;UAACyD,EAAE;UAAEC,WAAW;UAAEC,UAAU;UAAEC,EAAE;UAAEC,KAAK;UAAEP;QAAK,CAAC,CAAC;MACvF;MACA;IAEF;MACEzF,GAAG,CAAC+G,IAAI,CAAC,iBAAiBhE,aAAa,gBAAgB,CAAC,EAAE;MAC1D;EACJ;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}