{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { BaseTableBatchAggregator } from \"./base-table-batch-aggregator.js\";\nimport { RowTableBatchAggregator } from \"./row-table-batch-aggregator.js\";\nimport { ColumnarTableBatchAggregator } from \"./columnar-table-batch-aggregator.js\";\nconst DEFAULT_OPTIONS = {\n  shape: undefined,\n  batchSize: 'auto',\n  batchDebounceMs: 0,\n  limit: 0,\n  _limitMB: 0\n};\nconst ERR_MESSAGE = 'TableBatchBuilder';\n/** Incrementally builds batches from a stream of rows */\nexport class TableBatchBuilder {\n  schema;\n  options;\n  aggregator = null;\n  batchCount = 0;\n  bytesUsed = 0;\n  isChunkComplete = false;\n  lastBatchEmittedMs = Date.now();\n  totalLength = 0;\n  totalBytes = 0;\n  rowBytes = 0;\n  static ArrowBatch;\n  constructor(schema, options) {\n    this.schema = schema;\n    this.options = {\n      ...DEFAULT_OPTIONS,\n      ...options\n    };\n  }\n  limitReached() {\n    if (Boolean(this.options?.limit) && this.totalLength >= this.options.limit) {\n      return true;\n    }\n    if (Boolean(this.options?._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {\n      return true;\n    }\n    return false;\n  }\n  /** @deprecated Use addArrayRow or addObjectRow */\n  addRow(row) {\n    if (this.limitReached()) {\n      return;\n    }\n    this.totalLength++;\n    this.rowBytes = this.rowBytes || this._estimateRowMB(row);\n    this.totalBytes += this.rowBytes;\n    if (Array.isArray(row)) {\n      this.addArrayRow(row);\n    } else {\n      this.addObjectRow(row);\n    }\n  }\n  /** Add one row to the batch */\n  addArrayRow(row) {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addArrayRow(row);\n  }\n  /** Add one row to the batch */\n  addObjectRow(row) {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addObjectRow(row);\n  }\n  /** Mark an incoming raw memory chunk has completed */\n  chunkComplete(chunk) {\n    if (chunk instanceof ArrayBuffer) {\n      this.bytesUsed += chunk.byteLength;\n    }\n    if (typeof chunk === 'string') {\n      this.bytesUsed += chunk.length;\n    }\n    this.isChunkComplete = true;\n  }\n  getFullBatch(options) {\n    return this._isFull() ? this._getBatch(options) : null;\n  }\n  getFinalBatch(options) {\n    return this._getBatch(options);\n  }\n  // INTERNAL\n  _estimateRowMB(row) {\n    return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;\n  }\n  _isFull() {\n    // No batch, not ready\n    if (!this.aggregator || this.aggregator.rowCount() === 0) {\n      return false;\n    }\n    // if batchSize === 'auto' we wait for chunk to complete\n    // if batchSize === number, ensure we have enough rows\n    if (this.options.batchSize === 'auto') {\n      if (!this.isChunkComplete) {\n        return false;\n      }\n    } else if (this.options.batchSize > this.aggregator.rowCount()) {\n      return false;\n    }\n    // Debounce batches\n    if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {\n      return false;\n    }\n    // Emit batch\n    this.isChunkComplete = false;\n    this.lastBatchEmittedMs = Date.now();\n    return true;\n  }\n  /**\n   * bytesUsed can be set via chunkComplete or via getBatch*\n   */\n  _getBatch(options) {\n    if (!this.aggregator) {\n      return null;\n    }\n    // TODO - this can overly increment bytes used?\n    if (options?.bytesUsed) {\n      this.bytesUsed = options.bytesUsed;\n    }\n    const normalizedBatch = this.aggregator.getBatch();\n    normalizedBatch.count = this.batchCount;\n    normalizedBatch.bytesUsed = this.bytesUsed;\n    Object.assign(normalizedBatch, options);\n    this.batchCount++;\n    this.aggregator = null;\n    return normalizedBatch;\n  }\n  _getTableBatchType() {\n    switch (this.options.shape) {\n      case 'array-row-table':\n      case 'object-row-table':\n        return RowTableBatchAggregator;\n      case 'columnar-table':\n        return ColumnarTableBatchAggregator;\n      case 'arrow-table':\n        if (!TableBatchBuilder.ArrowBatch) {\n          throw new Error(ERR_MESSAGE);\n        }\n        return TableBatchBuilder.ArrowBatch;\n      default:\n        return BaseTableBatchAggregator;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}