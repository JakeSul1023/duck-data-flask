{"ast":null,"code":"// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Copyright (c) 2012 Pierre Curto\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* eslint-disable complexity */\n/* eslint-disable max-statements */\n// LZ4\nimport { toArrayBuffer, registerJSModules, getJSModule } from '@loaders.gl/loader-utils';\nimport { Compression } from \"./compression.js\";\n// import lz4js from 'lz4js'; // https://bundlephobia.com/package/lz4\nconst LZ4_MAGIC_NUMBER = 0x184d2204;\n/**\n * LZ4 compression / decompression\n */\nexport class LZ4Compression extends Compression {\n  name = 'lz4';\n  extensions = ['lz4'];\n  contentEncodings = ['x-lz4'];\n  isSupported = true;\n  options;\n  constructor(options) {\n    super(options);\n    this.options = options;\n    registerJSModules(options?.modules);\n  }\n  async preload() {\n    let modules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    registerJSModules(modules);\n  }\n  compressSync(input) {\n    const lz4js = getJSModule('lz4js', this.name);\n    const inputArray = new Uint8Array(input);\n    return lz4js.compress(inputArray).buffer;\n  }\n  /**\n   * Decompresses an ArrayBuffer containing an Lz4 frame. maxSize is optional; if not\n   * provided, a maximum size will be determined by examining the data. The\n   * returned ArrayBuffer will always be perfectly sized.\n   * If data provided without magic number we will parse it as block\n   */\n  decompressSync(data, maxSize) {\n    const lz4js = getJSModule('lz4js', this.name);\n    try {\n      const isMagicNumberExists = this.checkMagicNumber(data);\n      const inputArray = new Uint8Array(data);\n      if (isMagicNumberExists) {\n        return lz4js.decompress(inputArray, maxSize).buffer;\n      }\n      if (!maxSize) {\n        const error = new Error('Need to provide maxSize');\n        throw this.improveError(error);\n      }\n      let uncompressed = new Uint8Array(maxSize);\n      const uncompressedSize = this.decodeBlock(inputArray, uncompressed);\n      uncompressed = uncompressed.slice(0, uncompressedSize);\n      return toArrayBuffer(uncompressed);\n    } catch (error) {\n      throw this.improveError(error);\n    }\n  }\n  /**\n   * Decode lz4 file as block\n   * Solution taken from here\n   * https://github.com/pierrec/node-lz4/blob/0dac687262403fd34f905b963da7220692f2a4a1/lib/binding.js#L25\n   * @param input\n   * @param output\n   * @param startIndex\n   * @param endIndex\n   */\n  decodeBlock(data, output, startIndex, endIndex) {\n    startIndex = startIndex || 0;\n    endIndex = endIndex || data.length - startIndex;\n    let uncompressedSize = 0;\n    // Process each sequence in the incoming data\n    for (let index = startIndex; index < endIndex;) {\n      const token = data[index++];\n      // Literals\n      let literalsLength = token >> 4;\n      if (literalsLength > 0) {\n        // length of literals\n        let length = literalsLength + 240;\n        while (length === 255) {\n          length = data[index++];\n          literalsLength += length;\n        }\n        // Copy the literals\n        const end = index + literalsLength;\n        while (index < end) {\n          output[uncompressedSize++] = data[index++];\n        }\n        // End of buffer?\n        if (index === endIndex) {\n          return uncompressedSize;\n        }\n      }\n      // Match copy\n      // 2 bytes offset (little endian)\n      const offset = data[index++] | data[index++] << 8;\n      // 0 is an invalid offset value\n      if (offset === 0 || offset > uncompressedSize) {\n        return -(index - 2);\n      }\n      // length of match copy\n      let matchLength = token & 0xf;\n      let length = matchLength + 240;\n      while (length === 255) {\n        length = data[index++];\n        matchLength += length;\n      }\n      // Copy the match\n      let pos = uncompressedSize - offset; // position of the match copy in the current output\n      const end = uncompressedSize + matchLength + 4; // minmatch = 4\n      while (uncompressedSize < end) {\n        output[uncompressedSize++] = output[pos++];\n      }\n    }\n    return uncompressedSize;\n  }\n  /**\n   * Compare file magic with lz4 magic number\n   * @param input\n   */\n  checkMagicNumber(data) {\n    const magic = new Uint32Array(data.slice(0, 4));\n    return magic[0] === LZ4_MAGIC_NUMBER;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}